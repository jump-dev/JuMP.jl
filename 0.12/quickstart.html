<!DOCTYPE html><HTML class="no-js" lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Quick Start Guide — JuMP -- Julia for Mathematical Programming 0.12 documentation</title><link href="_static/css/theme.css" rel="stylesheet" type="text/css"/><link href="index.html" rel="top" title="JuMP -- Julia for Mathematical Programming 0.12 documentation"/><link href="refmodel.html" rel="next" title="Models"/><link href="installation.html" rel="prev" title="Installation Guide"/><script src="_static/js/modernizr.min.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body class="wy-body-for-nav" role="document"><div class="wy-grid-for-nav"><nav class="wy-nav-side" data-toggle="wy-nav-shift"><div class="wy-side-nav-search"><a class="icon icon-home" href="index.html"> JuMP -- Julia for Mathematical Programming
        

        
        </a><div role="search"><form action="search.html" class="wy-form" id="rtd-search-form" method="get"><input name="q" placeholder="Search docs" type="text"/><input name="check_keywords" type="hidden" value="yes"/><input name="area" type="hidden" value="default"/></form></div></div><div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation"><ul class="current"><li class="toctree-l1"><a class="reference internal" href="installation.html">Installation Guide</a><ul><li class="toctree-l2"><a class="reference internal" href="installation.html#getting-julia">Getting Julia</a></li><li class="toctree-l2"><a class="reference internal" href="installation.html#getting-jump">Getting JuMP</a></li><li class="toctree-l2"><a class="reference internal" href="installation.html#getting-solvers">Getting Solvers</a><ul><li class="toctree-l3"><a class="reference internal" href="installation.html#coin-or-clp-and-cbc">COIN-OR Clp and Cbc</a></li><li class="toctree-l3"><a class="reference internal" href="installation.html#id3">CPLEX</a></li><li class="toctree-l3"><a class="reference internal" href="installation.html#id5">ECOS</a></li><li class="toctree-l3"><a class="reference internal" href="installation.html#id6">GLPK</a></li><li class="toctree-l3"><a class="reference internal" href="installation.html#id7">Gurobi</a></li><li class="toctree-l3"><a class="reference internal" href="installation.html#id8">Ipopt</a></li><li class="toctree-l3"><a class="reference internal" href="installation.html#id9">KNITRO</a></li><li class="toctree-l3"><a class="reference internal" href="installation.html#id10">MOSEK</a></li><li class="toctree-l3"><a class="reference internal" href="installation.html#id11">NLopt</a></li><li class="toctree-l3"><a class="reference internal" href="installation.html#id12">SCS</a></li><li class="toctree-l3"><a class="reference internal" href="installation.html#coin-or-bonmin-and-couenne">COIN-OR Bonmin and Couenne</a></li><li class="toctree-l3"><a class="reference internal" href="installation.html#other-ampl-compatible-solvers">Other AMPL-compatible solvers</a></li></ul></li></ul></li><li class="toctree-l1 current"><a class="current reference internal" href="">Quick Start Guide</a><ul><li class="toctree-l2"><a class="reference internal" href="#creating-a-model">Creating a Model</a></li><li class="toctree-l2"><a class="reference internal" href="#defining-variables">Defining Variables</a></li><li class="toctree-l2"><a class="reference internal" href="#objective-and-constraints">Objective and Constraints</a></li><li class="toctree-l2"><a class="reference internal" href="#simple-example">Simple Example</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="refmodel.html">Models</a><ul><li class="toctree-l2"><a class="reference internal" href="refmodel.html#constructor">Constructor</a></li><li class="toctree-l2"><a class="reference internal" href="refmodel.html#methods">Methods</a></li><li class="toctree-l2"><a class="reference internal" href="refmodel.html#solve-status">Solve status</a></li><li class="toctree-l2"><a class="reference internal" href="refmodel.html#quadratic-objectives">Quadratic Objectives</a></li><li class="toctree-l2"><a class="reference internal" href="refmodel.html#second-order-cone-constraints">Second-order cone constraints</a></li><li class="toctree-l2"><a class="reference internal" href="refmodel.html#accessing-the-low-level-model">Accessing the low-level model</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="refvariable.html">Variables</a><ul><li class="toctree-l2"><a class="reference internal" href="refvariable.html#constructors">Constructors</a></li><li class="toctree-l2"><a class="reference internal" href="refvariable.html#semidefinite-and-symmetric-variables">Semidefinite and symmetric variables</a></li><li class="toctree-l2"><a class="reference internal" href="refvariable.html#methods">Methods</a></li><li class="toctree-l2"><a class="reference internal" href="refvariable.html#fixed-variables">Fixed variables</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="refexpr.html">Expressions and Constraints</a><ul><li class="toctree-l2"><a class="reference internal" href="refexpr.html#constructor">Constructor</a></li><li class="toctree-l2"><a class="reference internal" href="refexpr.html#methods">Methods</a></li><li class="toctree-l2"><a class="reference internal" href="refexpr.html#constraint-references">Constraint References</a></li><li class="toctree-l2"><a class="reference internal" href="refexpr.html#conic-constraint-duals">Conic constraint duals</a></li><li class="toctree-l2"><a class="reference internal" href="refexpr.html#vectorized-operations">Vectorized operations</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="probmod.html">Problem Modification</a><ul><li class="toctree-l2"><a class="reference internal" href="probmod.html#differences-in-solvers">Differences in Solvers</a></li><li class="toctree-l2"><a class="reference internal" href="probmod.html#modifying-variables">Modifying variables</a></li><li class="toctree-l2"><a class="reference internal" href="probmod.html#modifying-constraints">Modifying constraints</a></li><li class="toctree-l2"><a class="reference internal" href="probmod.html#modifying-the-objective">Modifying the objective</a></li><li class="toctree-l2"><a class="reference internal" href="probmod.html#modifying-nonlinear-models">Modifying nonlinear models</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="callbacks.html">Solver Callbacks</a><ul><li class="toctree-l2"><a class="reference internal" href="callbacks.html#lazy-constraints">Lazy Constraints</a></li><li class="toctree-l2"><a class="reference internal" href="callbacks.html#user-cuts">User Cuts</a></li><li class="toctree-l2"><a class="reference internal" href="callbacks.html#user-heuristics">User Heuristics</a></li><li class="toctree-l2"><a class="reference internal" href="callbacks.html#querying-solver-progress">Querying Solver Progress</a></li><li class="toctree-l2"><a class="reference internal" href="callbacks.html#informational-callbacks">Informational Callbacks</a></li><li class="toctree-l2"><a class="reference internal" href="callbacks.html#code-design-considerations">Code Design Considerations</a></li><li class="toctree-l2"><a class="reference internal" href="callbacks.html#exiting-a-callback-early">Exiting a callback early</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="nlp.html">Nonlinear Modeling</a><ul><li class="toctree-l2"><a class="reference internal" href="nlp.html#syntax-notes">Syntax notes</a></li><li class="toctree-l2"><a class="reference internal" href="nlp.html#nonlinear-parameters">Nonlinear Parameters</a></li><li class="toctree-l2"><a class="reference internal" href="nlp.html#user-defined-functions">User-defined functions</a></li><li class="toctree-l2"><a class="reference internal" href="nlp.html#factors-affecting-solution-time">Factors affecting solution time</a></li><li class="toctree-l2"><a class="reference internal" href="nlp.html#querying-derivatives-from-a-jump-model">Querying derivatives from a JuMP model</a></li></ul></li></ul></div>
       
    </nav><section class="wy-nav-content-wrap" data-toggle="wy-nav-shift"><nav aria-label="top navigation" class="wy-nav-top" role="navigation"><i class="fa fa-bars" data-toggle="wy-nav-top"></i><a href="index.html">JuMP -- Julia for Mathematical Programming</a></nav><div class="wy-nav-content"><div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation"><ul class="wy-breadcrumbs"><li><a href="index.html">Docs</a> »</li><li>Quick Start Guide</li><li class="wy-breadcrumbs-aside"><a href="_sources/quickstart.txt" rel="nofollow"> View page source</a></li></ul><hr/></div><div class="document" role="main"><div class="section" id="quick-start-guide"><span id="quick-start"></span><h1>Quick Start Guide<a class="headerlink" href="#quick-start-guide" title="Permalink to this headline">¶</a></h1><p>This quick start guide will introduce the main concepts of JuMP.
If you are familiar with another modeling language embedded in a high-level
language such as PuLP (Python) or a solver-specific interface you will find
most of this familiar, with the exception of <em>macros</em>. A deep understanding
of macros is not essential, but if you would like to know more please see
the <a class="reference external" href="http://docs.julialang.org/en/latest/manual/metaprogramming/">Julia documentation</a>.
If you are coming from an AMPL or similar background, you may find some of
the concepts novel but the general appearance will still be familiar.</p><div class="section" id="creating-a-model"><h2>Creating a Model<a class="headerlink" href="#creating-a-model" title="Permalink to this headline">¶</a></h2><p><strong>Models</strong> are Julia objects. They are created by calling the constructor:</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">m</span><span class="o">=</span><span class="n">Model</span><span class="p">()</span></pre></div></div><p>All variables and constraints are associated with a <code class="docutils literal"><span class="pre">Model</span></code> object. For
a list of all functions related to <code class="docutils literal"><span class="pre">Model</span></code>, including how to change the
default solver and set solver parameters, see <a class="reference internal" href="refmodel.html#ref-model"><span>Models</span></a>.</p></div><div class="section" id="defining-variables"><h2>Defining Variables<a class="headerlink" href="#defining-variables" title="Permalink to this headline">¶</a></h2><p><strong>Variables</strong> are also Julia objects, and are defined using the <code class="docutils literal"><span class="pre">@defVar</span></code>
macro. The first argument will always be the <code class="docutils literal"><span class="pre">Model</span></code> to associate this
variable with. In the examples below we assume <code class="docutils literal"><span class="pre">m</span></code> is already defined.
The second argument is an expression that declares the variable name and
optionally allows specification of lower and upper bounds. For example:</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">defVar</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="c"># No bounds</span><span class="p">@</span><span class="n">defVar</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">lb</span><span class="p">)</span><span class="c"># Lower bound only (note: 'lb &lt;= x' is not valid)</span><span class="p">@</span><span class="n">defVar</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">ub</span><span class="p">)</span><span class="c"># Upper bound only</span><span class="p">@</span><span class="n">defVar</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">lb</span><span class="o">&lt;=</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">ub</span><span class="p">)</span><span class="c"># Lower and upper bounds</span></pre></div></div><p>All these variations introduce a new variable <code class="docutils literal"><span class="pre">x</span></code> in the local scope.
The names of your variables must be valid Julia variable names.
For information about common operations on variables, e.g. changing their
bounds, see the <a class="reference internal" href="refvariable.html#ref-variable"><span>Variables</span></a> section.</p><p><strong>Integer</strong> and <strong>binary</strong> restrictions can optionally be specified with a
third argument, <code class="docutils literal"><span class="pre">Int</span></code> or <code class="docutils literal"><span class="pre">Bin</span></code>.</p><p>To create arrays of variables we append brackets to the variable name.
For example:</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">defVar</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">M</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span></pre></div></div><p>will create an <code class="docutils literal"><span class="pre">M</span></code> by <code class="docutils literal"><span class="pre">N</span></code> array of variables. Both ranges and arbitrary
iterable sets are supported as index sets. Currently we only support ranges
of the form <code class="docutils literal"><span class="pre">a:b</span></code> where <code class="docutils literal"><span class="pre">a</span></code> is an explicit integer, not a variable.
Using ranges will generally be faster than using arbitrary symbols. You can
mix both ranges and lists of symbols, as in the following example:</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">s</span><span class="o">=</span><span class="p">[</span><span class="s">"Green"</span><span class="p">,</span><span class="s">"Blue"</span><span class="p">]</span><span class="p">@</span><span class="n">defVar</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="n">s</span><span class="p">],</span><span class="kt">Int</span><span class="p">)</span><span class="c"># e.g. x[-4, "Green"]</span></pre></div></div><p>Finally, bounds can depend on variable indices:</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">defVar</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">i</span><span class="p">)</span></pre></div></div></div><div class="section" id="objective-and-constraints"><h2>Objective and Constraints<a class="headerlink" href="#objective-and-constraints" title="Permalink to this headline">¶</a></h2><p>JuMP allows users to use a natural notation to describe linear expressions.
There are two ways to do so. The first is very similar to other modeling
languages and has no restrictions. The second utilizes Julia’s powerful
metaprogramming features to get excellent performance even for large problems,
but has some restrictions on how they can be used.</p><p>To add constraints in the first way, use the <code class="docutils literal"><span class="pre">addConstraint()</span></code> and <code class="docutils literal"><span class="pre">setObjective()</span></code>
functions, e.g.:</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">addConstraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="n">z</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span><span class="c"># Other options: &lt;= and &gt;=</span><span class="n">setObjective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="p">:</span><span class="n">Max</span><span class="p">,</span><span class="mi">5</span><span class="n">x</span><span class="o">+</span><span class="mi">22</span><span class="n">y</span><span class="o">+</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="c"># or :Min</span></pre></div></div><p>The second way is visually very similar, and uses the <code class="docutils literal"><span class="pre">@addConstraint</span></code> and <code class="docutils literal"><span class="pre">@setObjective</span></code>
macros, e.g.:</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">addConstraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span><span class="p">@</span><span class="n">setObjective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">Max</span><span class="p">,</span><span class="n">sum</span><span class="p">{</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">numLocation</span><span class="p">}</span><span class="p">)</span></pre></div></div><div class="admonition note"><p class="first admonition-title">Note</p><p class="last">The <code class="docutils literal"><span class="pre">sense</span></code> passed to <code class="docutils literal"><span class="pre">setObjective</span></code> must be a <a class="reference external" href="http://docs.julialang.org/en/latest/manual/metaprogramming/#symbols">symbol</a> type: <code class="docutils literal"><span class="pre">:Min</span></code> or <code class="docutils literal"><span class="pre">:Max</span></code>.
The <code class="docutils literal"><span class="pre">@setObjective</span></code> macro accepts <code class="docutils literal"><span class="pre">:Min</span></code> and <code class="docutils literal"><span class="pre">:Max</span></code>, as well as <code class="docutils literal"><span class="pre">Min</span></code> and <code class="docutils literal"><span class="pre">Max</span></code> (without the colon) directly.</p></div><p>You may have noticed a special <code class="docutils literal"><span class="pre">sum{}</span></code> operator above. This is defined only for
the second kind of function. The syntax is of the form (where <code class="docutils literal"><span class="pre">IX</span></code> can be any iterable):</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">sum</span><span class="p">{</span><span class="n">expression</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">I1</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">I2</span><span class="p">,</span><span class="o">...</span><span class="p">}</span></pre></div></div><p>which is equivalent to:</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">a</span><span class="o">=</span><span class="n">zero</span><span class="p">(</span><span class="n">AffExpr</span><span class="p">)</span><span class="c"># Create a new empty affine expression</span><span class="k">for</span><span class="n">i</span><span class="o">=</span><span class="n">I1</span><span class="k">for</span><span class="n">j</span><span class="o">=</span><span class="n">I2</span><span class="o">...</span><span class="n">a</span><span class="o">+=</span><span class="n">expression</span><span class="o">...</span><span class="k">end</span><span class="k">end</span></pre></div></div><p>You can also put a condition in:</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">sum</span><span class="p">{</span><span class="n">expression</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">I1</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">I2</span><span class="p">,</span><span class="o">...</span><span class="p">;</span><span class="n">cond</span><span class="p">}</span></pre></div></div><p>which is equivalent to:</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">a</span><span class="o">=</span><span class="n">zero</span><span class="p">(</span><span class="n">AffExpr</span><span class="p">)</span><span class="k">for</span><span class="n">i</span><span class="o">=</span><span class="n">I1</span><span class="k">for</span><span class="n">j</span><span class="o">=</span><span class="n">I2</span><span class="o">...</span><span class="k">if</span><span class="n">cond</span><span class="n">a</span><span class="o">+=</span><span class="n">expression</span><span class="k">end</span><span class="o">...</span><span class="k">end</span><span class="k">end</span></pre></div></div></div><div class="section" id="simple-example"><span id="id1"></span><h2>Simple Example<a class="headerlink" href="#simple-example" title="Permalink to this headline">¶</a></h2><p>In this section we will construct a simple model and explain every step along the way.
The are more complex examples in the <code class="docutils literal"><span class="pre">JuMP/examples/</span></code><a class="reference external" href="https://github.com/JuliaOpt/JuMP.jl/tree/master/examples">folder</a>. Here is the code we will walk through:</p><div class="highlight-julia"><div class="highlight"><pre><span class="k">using</span><span class="n">JuMP</span><span class="n">m</span><span class="o">=</span><span class="n">Model</span><span class="p">()</span><span class="p">@</span><span class="n">defVar</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">)</span><span class="p">@</span><span class="n">defVar</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span><span class="o">&lt;=</span><span class="mi">30</span><span class="p">)</span><span class="p">@</span><span class="n">setObjective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">Max</span><span class="p">,</span><span class="mi">5</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="p">@</span><span class="n">addConstraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="n">x</span><span class="o">+</span><span class="mi">5</span><span class="n">y</span><span class="o">&lt;=</span><span class="mf">3.0</span><span class="p">)</span><span class="n">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="n">status</span><span class="o">=</span><span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="n">println</span><span class="p">(</span><span class="s">"Objective value: "</span><span class="p">,</span><span class="n">getObjectiveValue</span><span class="p">(</span><span class="n">m</span><span class="p">))</span><span class="n">println</span><span class="p">(</span><span class="s">"x = "</span><span class="p">,</span><span class="n">getValue</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="n">println</span><span class="p">(</span><span class="s">"y = "</span><span class="p">,</span><span class="n">getValue</span><span class="p">(</span><span class="n">y</span><span class="p">))</span></pre></div></div><p>Once JuMP is <a class="reference internal" href="installation.html#jump-installation"><span>installed</span></a>, to use JuMP in your
programs, you just need to say:</p><div class="highlight-julia"><div class="highlight"><pre><span class="k">using</span><span class="n">JuMP</span></pre></div></div><p>Models are created with the <code class="docutils literal"><span class="pre">Model()</span></code> function:</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">m</span><span class="o">=</span><span class="n">Model</span><span class="p">()</span></pre></div></div><div class="admonition note"><p class="first admonition-title">Note</p><p class="last">Your model doesn’t have to be called m - it’s just a name.</p></div><p>There are a few options for defining a variable, depending on whether you want
to have lower bounds, upper bounds, both bounds, or even no bounds. The following
commands will create two variables, <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code>, with both lower and upper bounds.
Note the first argument is our model variable <code class="docutils literal"><span class="pre">m</span></code>. These variables are associated
with this model and cannot be used in another model.:</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">defVar</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">)</span><span class="p">@</span><span class="n">defVar</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span><span class="o">&lt;=</span><span class="mi">30</span><span class="p">)</span></pre></div></div><p>Next we’ll set our objective. Note again the <code class="docutils literal"><span class="pre">m</span></code>, so we know which model’s
objective we are setting! The objective sense, <code class="docutils literal"><span class="pre">Max</span></code> or <code class="docutils literal"><span class="pre">Min</span></code>, should
be provided as the second argument. Note also that we don’t have a multiplication <code class="docutils literal"><span class="pre">*</span></code>
symbol between 5 and our variable <code class="docutils literal"><span class="pre">x</span></code> - Julia is smart enough to not need it!
Feel free to stick with <code class="docutils literal"><span class="pre">*</span></code> if it makes you feel more comfortable, as we have
done with <code class="docutils literal"><span class="pre">3*y</span></code>:</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">setObjective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">Max</span><span class="p">,</span><span class="mi">5</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)</span></pre></div></div><p>Adding constraints is a lot like setting the objective. Here we create a
less-than-or-equal-to constraint using <code class="docutils literal"><span class="pre">&lt;=</span></code>, but we can also create equality
constraints using <code class="docutils literal"><span class="pre">==</span></code> and greater-than-or-equal-to constraints with <code class="docutils literal"><span class="pre">&gt;=</span></code>:</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">addConstraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="n">x</span><span class="o">+</span><span class="mi">5</span><span class="n">y</span><span class="o">&lt;=</span><span class="mf">3.0</span><span class="p">)</span></pre></div></div><p>If you want to see what your model looks like in a human-readable format,
the <code class="docutils literal"><span class="pre">print</span></code> function is defined for models.</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span></pre></div></div><p>Models are solved with the <code class="docutils literal"><span class="pre">solve()</span></code> function. This function will not raise
an error if your model is infeasible - instead it will return a flag. In this
case, the model is feasible so the value of <code class="docutils literal"><span class="pre">status</span></code> will be <code class="docutils literal"><span class="pre">:Optimal</span></code>,
where <code class="docutils literal"><span class="pre">:</span></code> again denotes a symbol. The possible values of <code class="docutils literal"><span class="pre">status</span></code>
are described <a class="reference internal" href="refmodel.html#solvestatus"><span>here</span></a>.</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">status</span><span class="o">=</span><span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="p">)</span></pre></div></div><p>Finally, we can access the results of our optimization. Getting the objective
value is simple:</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">println</span><span class="p">(</span><span class="s">"Objective value: "</span><span class="p">,</span><span class="n">getObjectiveValue</span><span class="p">(</span><span class="n">m</span><span class="p">))</span></pre></div></div><p>To get the value from a variable, we call the <code class="docutils literal"><span class="pre">getValue()</span></code> function. If <code class="docutils literal"><span class="pre">x</span></code>
is not a single variable, but instead a range of variables, <code class="docutils literal"><span class="pre">getValue()</span></code> will
return a list. In this case, however, it will just return a single value.</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">println</span><span class="p">(</span><span class="s">"x = "</span><span class="p">,</span><span class="n">getValue</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="n">println</span><span class="p">(</span><span class="s">"y = "</span><span class="p">,</span><span class="n">getValue</span><span class="p">(</span><span class="n">y</span><span class="p">))</span></pre></div></div></div></div></div><footer><div aria-label="footer navigation" class="rst-footer-buttons" role="navigation"><a accesskey="n" class="btn btn-neutral float-right" href="refmodel.html" title="Models">Next <span class="fa fa-arrow-circle-right"></span></a><a accesskey="p" class="btn btn-neutral" href="installation.html" title="Installation Guide"><span class="fa fa-arrow-circle-left"></span> Previous</a></div><hr/><div role="contentinfo"><p>
        © Copyright 2015, Miles Lubin, Iain Dunning, and Joey Huchette.
    </p></div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer></div></div></section></div><script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.12',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script><script src="_static/jquery.js" type="text/javascript"></script><script src="_static/underscore.js" type="text/javascript"></script><script src="_static/doctools.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script src="_static/js/theme.js" type="text/javascript"></script><script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script><script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview');
</script><script async="" src="https://www.google-analytics.com/analytics.js"></script></body></HTML>