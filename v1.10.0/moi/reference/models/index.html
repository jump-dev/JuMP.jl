<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Models · JuMP</title><meta name="title" content="Models · JuMP"/><meta property="og:title" content="Models · JuMP"/><meta property="twitter:title" content="Models · JuMP"/><meta name="description" content="Documentation for JuMP."/><meta property="og:description" content="Documentation for JuMP."/><meta property="twitter:description" content="Documentation for JuMP."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-44252521-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-44252521-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.048/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img class="docs-light-only" src="../../../assets/logo.svg" alt="JuMP logo"/><img class="docs-dark-only" src="../../../assets/logo-dark.svg" alt="JuMP logo"/></a><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs (Ctrl + /)"/></form><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../">Introduction</a></li><li><a class="tocitem" href="../../../should_i_use/">Should you use JuMP?</a></li><li><a class="tocitem" href="../../../installation/">Installation Guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/getting_started/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/getting_started_with_julia/">Getting started with Julia</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/getting_started_with_JuMP/">Getting started with JuMP</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/getting_started_with_sets_and_indexing/">Getting started with sets and indexing</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/getting_started_with_data_and_plotting/">Getting started with data and plotting</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/debugging/">Debugging</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/design_patterns_for_larger_models/">Design patterns for larger models</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/performance_tips/">Performance tips</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Linear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/linear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../tutorials/linear/diet/">The diet problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../../tutorials/linear/facility_location/">The facility location problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../../../tutorials/linear/finance/">Financial modeling problems</a></li><li><a class="tocitem" href="../../../tutorials/linear/geographic_clustering/">Geographical clustering</a></li><li><a class="tocitem" href="../../../tutorials/linear/multi_objective_knapsack/">Multi-objective knapsack</a></li><li><a class="tocitem" href="../../../tutorials/linear/multi_objective_examples/">Simple multi-objective examples</a></li><li><a class="tocitem" href="../../../tutorials/linear/knapsack/">The knapsack problem example</a></li><li><a class="tocitem" href="../../../tutorials/linear/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/n-queens/">N-Queens</a></li><li><a class="tocitem" href="../../../tutorials/linear/lp_sensitivity/">Sensitivity analysis of a linear program</a></li><li><a class="tocitem" href="../../../tutorials/linear/network_flows/">Network flow problems</a></li><li><a class="tocitem" href="../../../tutorials/linear/sudoku/">Sudoku</a></li><li><a class="tocitem" href="../../../tutorials/linear/transp/">The transportation problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../tutorials/linear/constraint_programming/">Constraint programming</a></li><li><a class="tocitem" href="../../../tutorials/linear/mip_duality/">Computing the duals of a mixed-integer program</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Nonlinear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/nonlinear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/simple_examples/">Simple examples</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/portfolio/">Portfolio optimization</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/rocket_control/">Rocket Control</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/space_shuttle_reentry_trajectory/">Optimal control for a Space Shuttle reentry trajectory</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/user_defined_hessians/">User-defined Hessians</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/nested_problems/">Nested optimization problems</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/querying_hessians/">Computing Hessians</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Conic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/conic/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../tutorials/conic/start_values/">Primal and dual warm-starts</a></li><li><a class="tocitem" href="../../../tutorials/conic/tips_and_tricks/">Tips and Tricks</a></li><li><a class="tocitem" href="../../../tutorials/conic/simple_examples/">Simple semidefinite programming examples</a></li><li><a class="tocitem" href="../../../tutorials/conic/logistic_regression/">Logistic regression</a></li><li><a class="tocitem" href="../../../tutorials/conic/experiment_design/">Experiment design</a></li><li><a class="tocitem" href="../../../tutorials/conic/min_ellipse/">Minimal ellipses</a></li><li><a class="tocitem" href="../../../tutorials/conic/ellipse_approx/">Ellipsoid approximation</a></li><li><a class="tocitem" href="../../../tutorials/conic/quantum_discrimination/">Quantum state discrimination</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/algorithms/benders_decomposition/">Benders decomposition</a></li><li><a class="tocitem" href="../../../tutorials/algorithms/cutting_stock_column_generation/">Column generation</a></li><li><a class="tocitem" href="../../../tutorials/algorithms/tsp_lazy_constraints/">Traveling Salesperson Problem</a></li><li><a class="tocitem" href="../../../tutorials/algorithms/parallelism/">Parallelism</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/applications/power_systems/">Power Systems</a></li><li><a class="tocitem" href="../../../tutorials/applications/web_app/">Serving web apps</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../manual/models/">Models</a></li><li><a class="tocitem" href="../../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../manual/expressions/">Expressions</a></li><li><a class="tocitem" href="../../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../../manual/containers/">Containers</a></li><li><a class="tocitem" href="../../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../manual/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../../manual/callbacks/">Solver-independent Callbacks</a></li><li><a class="tocitem" href="../../../manual/complex/">Complex number support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../reference/models/">Models</a></li><li><a class="tocitem" href="../../../reference/variables/">Variables</a></li><li><a class="tocitem" href="../../../reference/expressions/">Expressions</a></li><li><a class="tocitem" href="../../../reference/objectives/">Objectives</a></li><li><a class="tocitem" href="../../../reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../reference/containers/">Containers</a></li><li><a class="tocitem" href="../../../reference/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../reference/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../../reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../reference/extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Background Information</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../background/algebraic_modeling_languages/">Algebraic modeling languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../developers/contributing/">Contributing</a></li><li><a class="tocitem" href="../../../developers/extensions/">Extensions</a></li><li><a class="tocitem" href="../../../developers/custom_solver_binaries/">Custom binaries</a></li><li><a class="tocitem" href="../../../developers/style/">Style Guide</a></li><li><a class="tocitem" href="../../../developers/roadmap/">Roadmap</a></li></ul></li><li><a class="tocitem" href="../../../release_notes/">Release notes</a></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox" checked/><label class="tocitem" for="menuitem-8"><span class="docs-label">MathOptInterface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../background/motivation/">Motivation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/example/">Solving a problem using MathOptInterface</a></li><li><a class="tocitem" href="../../tutorials/implementing/">Implementing a solver interface</a></li><li><a class="tocitem" href="../../tutorials/mathprogbase/">Transitioning from MathProgBase</a></li><li><a class="tocitem" href="../../tutorials/bridging_constraint/">Implementing a constraint bridge</a></li><li><a class="tocitem" href="../../tutorials/manipulating_expressions/">Manipulating expressions</a></li><li><a class="tocitem" href="../../tutorials/latency/">Latency</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/standard_form/">Standard form problem</a></li><li><a class="tocitem" href="../../manual/models/">Models</a></li><li><a class="tocitem" href="../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../manual/modification/">Problem modification</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox"/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/duality/">Duality</a></li><li><a class="tocitem" href="../../background/infeasibility_certificates/">Infeasibility certificates</a></li><li><a class="tocitem" href="../../background/naming_conventions/">Naming conventions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox" checked/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../standard_form/">Standard form</a></li><li class="is-active"><a class="tocitem" href>Models</a><ul class="internal"><li><a class="tocitem" href="#Attribute-interface"><span>Attribute interface</span></a></li><li><a class="tocitem" href="#Model-interface"><span>Model interface</span></a></li><li><a class="tocitem" href="#Model-attributes"><span>Model attributes</span></a></li><li><a class="tocitem" href="#Optimizer-interface"><span>Optimizer interface</span></a></li><li><a class="tocitem" href="#Optimizer-attributes"><span>Optimizer attributes</span></a></li></ul></li><li><a class="tocitem" href="../variables/">Variables</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../modification/">Modifications</a></li><li><a class="tocitem" href="../nonlinear/">Nonlinear programming</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../errors/">Errors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6" type="checkbox"/><label class="tocitem" for="menuitem-8-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-6-1" type="checkbox"/><label class="tocitem" for="menuitem-8-6-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-2" type="checkbox"/><label class="tocitem" for="menuitem-8-6-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Bridges/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Bridges/list_of_bridges/">List of bridges</a></li><li><a class="tocitem" href="../../submodules/Bridges/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-3" type="checkbox"/><label class="tocitem" for="menuitem-8-6-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/FileFormats/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-4" type="checkbox"/><label class="tocitem" for="menuitem-8-6-4"><span class="docs-label">Nonlinear</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Nonlinear/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Nonlinear/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-5" type="checkbox"/><label class="tocitem" for="menuitem-8-6-5"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Utilities/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Utilities/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-6" type="checkbox"/><label class="tocitem" for="menuitem-8-6-6"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Test/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Test/reference/">API Reference</a></li></ul></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">MathOptInterface</a></li><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/moi/reference/models.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h1><h2 id="Attribute-interface"><a class="docs-heading-anchor" href="#Attribute-interface">Attribute interface</a><a id="Attribute-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Attribute-interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.is_set_by_optimize" href="#MathOptInterface.is_set_by_optimize"><code>MathOptInterface.is_set_by_optimize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_set_by_optimize(::AnyAttribute)</code></pre><p>Return a <code>Bool</code> indicating whether the value of the attribute is modified during an <a href="#MathOptInterface.optimize!"><code>optimize!</code></a> call, that is, the attribute is used to query the result of the optimization.</p><p><strong>Important note when defining new attributes</strong></p><p>This function returns <code>false</code> by default so it should be implemented for attributes that are modified by <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.is_copyable" href="#MathOptInterface.is_copyable"><code>MathOptInterface.is_copyable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_copyable(::AnyAttribute)</code></pre><p>Return a <code>Bool</code> indicating whether the value of the attribute may be copied during <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> using <a href="#MathOptInterface.set"><code>set</code></a>.</p><p><strong>Important note when defining new attributes</strong></p><p>By default <code>is_copyable(attr)</code> returns <code>!is_set_by_optimize(attr)</code>. A specific method should be defined for attributes which are copied indirectly during <a href="#MathOptInterface.copy_to"><code>copy_to</code></a>. For instance, both <code>is_copyable</code> and <a href="#MathOptInterface.is_set_by_optimize"><code>is_set_by_optimize</code></a> return <code>false</code> for the following attributes:</p><ul><li><a href="#MathOptInterface.ListOfOptimizerAttributesSet"><code>ListOfOptimizerAttributesSet</code></a>, <a href="#MathOptInterface.ListOfModelAttributesSet"><code>ListOfModelAttributesSet</code></a>, <a href="#MathOptInterface.ListOfConstraintAttributesSet"><code>ListOfConstraintAttributesSet</code></a> and <a href="#MathOptInterface.ListOfVariableAttributesSet"><code>ListOfVariableAttributesSet</code></a>.</li><li><a href="#MathOptInterface.SolverName"><code>SolverName</code></a> and <a href="#MathOptInterface.RawSolver"><code>RawSolver</code></a>: these attributes cannot be set.</li><li><a href="#MathOptInterface.NumberOfVariables"><code>NumberOfVariables</code></a> and <a href="#MathOptInterface.ListOfVariableIndices"><code>ListOfVariableIndices</code></a>: these attributes are set indirectly by <a href="../variables/#MathOptInterface.add_variable"><code>add_variable</code></a> and <a href="../variables/#MathOptInterface.add_variables"><code>add_variables</code></a>.</li><li><a href="#MathOptInterface.ObjectiveFunctionType"><code>ObjectiveFunctionType</code></a>: this attribute is set indirectly when setting the <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a> attribute.</li><li><a href="#MathOptInterface.NumberOfConstraints"><code>NumberOfConstraints</code></a>, <a href="#MathOptInterface.ListOfConstraintIndices"><code>ListOfConstraintIndices</code></a>, <a href="#MathOptInterface.ListOfConstraintTypesPresent"><code>ListOfConstraintTypesPresent</code></a>, <a href="../constraints/#MathOptInterface.CanonicalConstraintFunction"><code>CanonicalConstraintFunction</code></a>, <a href="../constraints/#MathOptInterface.ConstraintFunction"><code>ConstraintFunction</code></a> and <a href="../constraints/#MathOptInterface.ConstraintSet"><code>ConstraintSet</code></a>: these attributes are set indirectly by <a href="../constraints/#MathOptInterface.add_constraint"><code>add_constraint</code></a> and <a href="../constraints/#MathOptInterface.add_constraints"><code>add_constraints</code></a>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.get" href="#MathOptInterface.get"><code>MathOptInterface.get</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">MOI.get(b::AbstractBridge, ::MOI.NumberOfVariables)::Int64</code></pre><p>Return the number of variables created by the bridge <code>b</code> in the model.</p><p>See also <a href="#MathOptInterface.NumberOfConstraints"><code>MOI.NumberOfConstraints</code></a>.</p><p><strong>Implementation notes</strong></p><ul><li>There is a default fallback, so you need only implement this if the bridge adds new variables.</li></ul></div></section><section><div><pre><code class="language-julia hljs">MOI.get(b::AbstractBridge, ::MOI.ListOfVariableIndices)</code></pre><p>Return the list of variables created by the bridge <code>b</code>.</p><p>See also <a href="#MathOptInterface.ListOfVariableIndices"><code>MOI.ListOfVariableIndices</code></a>.</p><p><strong>Implementation notes</strong></p><ul><li>There is a default fallback, so you need only implement this if the bridge adds new variables.</li></ul></div></section><section><div><pre><code class="language-julia hljs">MOI.get(b::AbstractBridge, ::MOI.NumberOfConstraints{F,S})::Int64 where {F,S}</code></pre><p>Return the number of constraints of the type <code>F</code>-in-<code>S</code> created by the bridge <code>b</code>.</p><p>See also <a href="#MathOptInterface.NumberOfConstraints"><code>MOI.NumberOfConstraints</code></a>.</p><p><strong>Implementation notes</strong></p><ul><li>There is a default fallback, so you need only implement this for the constraint types returned by <a href="../../submodules/Bridges/reference/#MathOptInterface.Bridges.added_constraint_types"><code>added_constraint_types</code></a>.</li></ul></div></section><section><div><pre><code class="language-julia hljs">MOI.get(b::AbstractBridge, ::MOI.ListOfConstraintIndices{F,S}) where {F,S}</code></pre><p>Return a  <code>Vector{ConstraintIndex{F,S}}</code> with indices of all constraints of type <code>F</code>-in-<code>S</code> created by the bride <code>b</code>.</p><p>See also <a href="#MathOptInterface.ListOfConstraintIndices"><code>MOI.ListOfConstraintIndices</code></a>.</p><p><strong>Implementation notes</strong></p><ul><li>There is a default fallback, so you need only implement this for the constraint types returned by <a href="../../submodules/Bridges/reference/#MathOptInterface.Bridges.added_constraint_types"><code>added_constraint_types</code></a>.</li></ul></div></section><section><div><pre><code class="language-julia hljs">function MOI.get(
    model::MOI.ModelLike,
    attr::MOI.AbstractConstraintAttribute,
    bridge::AbstractBridge,
)</code></pre><p>Return the value of the attribute <code>attr</code> of the model <code>model</code> for the constraint bridged by <code>bridge</code>.</p></div></section><section><div><pre><code class="language-julia hljs">get(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute)</code></pre><p>Return an attribute <code>attr</code> of the optimizer <code>optimizer</code>.</p><pre><code class="language-julia hljs">get(model::ModelLike, attr::AbstractModelAttribute)</code></pre><p>Return an attribute <code>attr</code> of the model <code>model</code>.</p><pre><code class="language-julia hljs">get(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex)</code></pre><p>If the attribute <code>attr</code> is set for the variable <code>v</code> in the model <code>model</code>, return its value, return <code>nothing</code> otherwise. If the attribute <code>attr</code> is not supported by <code>model</code> then an error should be thrown instead of returning <code>nothing</code>.</p><pre><code class="language-julia hljs">get(model::ModelLike, attr::AbstractVariableAttribute, v::Vector{VariableIndex})</code></pre><p>Return a vector of attributes corresponding to each variable in the collection <code>v</code> in the model <code>model</code>.</p><pre><code class="language-julia hljs">get(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex)</code></pre><p>If the attribute <code>attr</code> is set for the constraint <code>c</code> in the model <code>model</code>, return its value, return <code>nothing</code> otherwise. If the attribute <code>attr</code> is not supported by <code>model</code> then an error should be thrown instead of returning <code>nothing</code>.</p><pre><code class="language-julia hljs">get(
    model::ModelLike,
    attr::AbstractConstraintAttribute,
    c::Vector{ConstraintIndex{F,S}},
) where {F,S}</code></pre><p>Return a vector of attributes corresponding to each constraint in the collection <code>c</code> in the model <code>model</code>.</p><pre><code class="language-julia hljs">get(model::ModelLike, ::Type{VariableIndex}, name::String)</code></pre><p>If a variable with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. Errors if two variables have the same name.</p><pre><code class="language-julia hljs">get(
    model::ModelLike,
    ::Type{ConstraintIndex{F,S}},
    name::String,
) where {F,S}</code></pre><p>If an <code>F</code>-in-<code>S</code> constraint with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. Errors if two constraints have the same name.</p><pre><code class="language-julia hljs">get(model::ModelLike, ::Type{ConstraintIndex}, name::String)</code></pre><p>If <em>any</em> constraint with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. This version is available for convenience but may incur a performance penalty because it is not type stable. Errors if two constraints have the same name.</p></div></section><section><div><pre><code class="language-julia hljs">get(model::Model, attr::MathOptInterface.AbstractOptimizerAttribute)</code></pre><p>Return the value of the attribute <code>attr</code> from the model&#39;s MOI backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/3dd83b540ca18c404857a302bbf7002c5cca1c65/src/optimizer_interface.jl#L601-L605">source</a></section><section><div><pre><code class="language-julia hljs">get(model::Model, attr::MathOptInterface.AbstractModelAttribute)</code></pre><p>Return the value of the attribute <code>attr</code> from the model&#39;s MOI backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/3dd83b540ca18c404857a302bbf7002c5cca1c65/src/optimizer_interface.jl#L643-L647">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.get!" href="#MathOptInterface.get!"><code>MathOptInterface.get!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get!(output, model::ModelLike, args...)</code></pre><p>An in-place version of <a href="#MathOptInterface.get"><code>get</code></a>.</p><p>The signature matches that of <a href="#MathOptInterface.get"><code>get</code></a> except that the the result is placed in the vector <code>output</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.set" href="#MathOptInterface.set"><code>MathOptInterface.set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function MOI.set(
    model::MOI.ModelLike,
    attr::MOI.AbstractConstraintAttribute,
    bridge::AbstractBridge,
    value,
)</code></pre><p>Set the value of the attribute <code>attr</code> of the model <code>model</code> for the constraint bridged by <code>bridge</code>.</p></div></section><section><div><pre><code class="language-julia hljs">set(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the optimizer <code>optimizer</code>.</p><pre><code class="language-julia hljs">set(model::ModelLike, attr::AbstractModelAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the model <code>model</code>.</p><pre><code class="language-julia hljs">set(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of variable <code>v</code> in model <code>model</code>.</p><pre><code class="language-julia hljs">set(
    model::ModelLike,
    attr::AbstractVariableAttribute,
    v::Vector{VariableIndex},
    vector_of_values,
)</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each variable in the collection <code>v</code> in model <code>model</code>.</p><pre><code class="language-julia hljs">set(
    model::ModelLike,
    attr::AbstractConstraintAttribute,
    c::ConstraintIndex,
    value,
)</code></pre><p>Assign a value to the attribute <code>attr</code> of constraint <code>c</code> in model <code>model</code>.</p><pre><code class="language-julia hljs">set(
    model::ModelLike,
    attr::AbstractConstraintAttribute,
    c::Vector{ConstraintIndex{F,S}},
    vector_of_values,
) where {F,S}</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each constraint in the collection <code>c</code> in model <code>model</code>.</p><p>An <a href="../errors/#MathOptInterface.UnsupportedAttribute"><code>UnsupportedAttribute</code></a> error is thrown if <code>model</code> does not support the attribute <code>attr</code> (see <a href="#MathOptInterface.supports"><code>supports</code></a>) and a <a href="../errors/#MathOptInterface.SetAttributeNotAllowed"><code>SetAttributeNotAllowed</code></a> error is thrown if it supports the attribute <code>attr</code> but it cannot be set.</p><pre><code class="language-julia hljs">set(
    model::ModelLike,
    ::ConstraintSet,
    c::ConstraintIndex{F,S},
    set::S,
) where {F,S}</code></pre><p>Change the set of constraint <code>c</code> to the new set <code>set</code> which should be of the same type as the original set.</p><pre><code class="language-julia hljs">set(
    model::ModelLike,
    ::ConstraintFunction,
    c::ConstraintIndex{F,S},
    func::F,
) where {F,S}</code></pre><p>Replace the function in constraint <code>c</code> with <code>func</code>. <code>F</code> must match the original function type used to define the constraint.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Setting the constraint function is not allowed if <code>F</code> is <a href="../standard_form/#MathOptInterface.VariableIndex"><code>VariableIndex</code></a>; a <a href="../errors/#MathOptInterface.SettingVariableIndexNotAllowed"><code>SettingVariableIndexNotAllowed</code></a> error is thrown instead. This is because, it would require changing the index <code>c</code> since the index of <a href="../standard_form/#MathOptInterface.VariableIndex"><code>VariableIndex</code></a> constraints must be the same as the index of the variable.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.supports" href="#MathOptInterface.supports"><code>MathOptInterface.supports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">MOI.supports(
    model::MOI.ModelLike,
    attr::MOI.AbstractConstraintAttribute,
    BT::Type{&lt;:AbstractBridge},
)</code></pre><p>Return a <code>Bool</code> indicating whether <code>BT</code> supports setting <code>attr</code> to <code>model</code>.</p></div></section><section><div><pre><code class="language-julia hljs">supports(model::ModelLike, sub::AbstractSubmittable)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the submittable <code>sub</code>.</p><pre><code class="language-julia hljs">supports(model::ModelLike, attr::AbstractOptimizerAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the optimizer attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> shows a warning in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfOptimizerAttributesSet"><code>ListOfOptimizerAttributesSet</code></a> of <code>src</code>; see <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> for more details on how unsupported optimizer attributes are handled in copy.</p><pre><code class="language-julia hljs">supports(model::ModelLike, attr::AbstractModelAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the model attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfModelAttributesSet"><code>ListOfModelAttributesSet</code></a> of <code>src</code>.</p><pre><code class="language-julia hljs">supports(
    model::ModelLike,
    attr::AbstractVariableAttribute,
    ::Type{VariableIndex},
)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the variable attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfVariableAttributesSet"><code>ListOfVariableAttributesSet</code></a> of <code>src</code>.</p><pre><code class="language-julia hljs">supports(
    model::ModelLike,
    attr::AbstractConstraintAttribute,
    ::Type{ConstraintIndex{F,S}},
)::Bool where {F,S}</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the constraint attribute <code>attr</code> applied to an <code>F</code>-in-<code>S</code> constraint. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfConstraintAttributesSet"><code>ListOfConstraintAttributesSet</code></a> of <code>src</code>.</p><p>For all five methods, if the attribute is only not supported in specific circumstances, it should still return <code>true</code>.</p><p>Note that <code>supports</code> is only defined for attributes for which <a href="#MathOptInterface.is_copyable"><code>is_copyable</code></a> returns <code>true</code> as other attributes do not appear in the list of attributes set obtained by <code>ListOf...AttributesSet</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.attribute_value_type" href="#MathOptInterface.attribute_value_type"><code>MathOptInterface.attribute_value_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">attribute_value_type(attr::AnyAttribute)</code></pre><p>Given an attribute <code>attr</code>, return the type of value expected by <a href="#MathOptInterface.get"><code>get</code></a>, or returned by <a href="#MathOptInterface.set"><code>set</code></a>.</p><p><strong>Notes</strong></p><ul><li>Only implement this if it make sense to do so. If un-implemented, the default is <code>Any</code>.</li></ul></div></section></article><h2 id="Model-interface"><a class="docs-heading-anchor" href="#Model-interface">Model interface</a><a id="Model-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Model-interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ModelLike" href="#MathOptInterface.ModelLike"><code>MathOptInterface.ModelLike</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModelLike</code></pre><p>Abstract supertype for objects that implement the &quot;Model&quot; interface for defining an optimization problem.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.is_empty" href="#MathOptInterface.is_empty"><code>MathOptInterface.is_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_empty(model::ModelLike)</code></pre><p>Returns <code>false</code> if the <code>model</code> has any model attribute set or has any variables or constraints.</p><p>Note that an empty model can have optimizer attributes set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.empty!" href="#MathOptInterface.empty!"><code>MathOptInterface.empty!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">empty!(model::ModelLike)</code></pre><p>Empty the model, that is, remove all variables, constraints and model attributes but not optimizer attributes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.write_to_file" href="#MathOptInterface.write_to_file"><code>MathOptInterface.write_to_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write_to_file(model::ModelLike, filename::String)</code></pre><p>Write the current model to the file at <code>filename</code>.</p><p>Supported file types depend on the model type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.read_from_file" href="#MathOptInterface.read_from_file"><code>MathOptInterface.read_from_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_from_file(model::ModelLike, filename::String)</code></pre><p>Read the file <code>filename</code> into the model <code>model</code>. If <code>model</code> is non-empty, this may throw an error.</p><p>Supported file types depend on the model type.</p><p><strong>Note</strong></p><p>Once the contents of the file are loaded into the model, users can query the variables via <code>get(model, ListOfVariableIndices())</code>. However, some filetypes, such as LP files, do not maintain an explicit ordering of the variables. Therefore, the returned list may be in an arbitrary order.</p><p>To avoid depending on the order of the indices, look up each variable index by name using  <code>get(model, VariableIndex, &quot;name&quot;)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.supports_incremental_interface" href="#MathOptInterface.supports_incremental_interface"><code>MathOptInterface.supports_incremental_interface</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">supports_incremental_interface(model::ModelLike)</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports building incrementally via <a href="../variables/#MathOptInterface.add_variable"><code>add_variable</code></a> and <a href="../constraints/#MathOptInterface.add_constraint"><code>add_constraint</code></a>.</p><p>The main purpose of this function is to determine whether a model can be loaded into <code>model</code> incrementally or whether it should be cached and copied at once instead.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.copy_to" href="#MathOptInterface.copy_to"><code>MathOptInterface.copy_to</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">copy_to(dest::ModelLike, src::ModelLike)::IndexMap</code></pre><p>Copy the model from <code>src</code> into <code>dest</code>.</p><p>The target <code>dest</code> is emptied, and all previous indices to variables and constraints in <code>dest</code> are invalidated.</p><p>Returns an <a href="#MathOptInterface.IndexMap"><code>IndexMap</code></a> object that translates variable and constraint indices from the <code>src</code> model to the corresponding indices in the <code>dest</code> model.</p><p><strong>Notes</strong></p><ul><li>If a constraint that in <code>src</code> is not supported by <code>dest</code>, then an <a href="../errors/#MathOptInterface.UnsupportedConstraint"><code>UnsupportedConstraint</code></a> error is thrown.</li><li>If an <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a>, <a href="../variables/#MathOptInterface.AbstractVariableAttribute"><code>AbstractVariableAttribute</code></a>, or <a href="../constraints/#MathOptInterface.AbstractConstraintAttribute"><code>AbstractConstraintAttribute</code></a> is set in <code>src</code> but not supported by <code>dest</code>, then an <a href="../errors/#MathOptInterface.UnsupportedAttribute"><code>UnsupportedAttribute</code></a> error is thrown.</li></ul><p><a href="#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a>s are <em>not</em> copied  to the <code>dest</code> model.</p><p><strong>IndexMap</strong></p><p>Implementations of <code>copy_to</code> must return an <a href="#MathOptInterface.IndexMap"><code>IndexMap</code></a>. For technical reasons, this type is defined in the Utilities submodule as <code>MOI.Utilities.IndexMap</code>. However, since it is an integral part of the MOI API, we provide <code>MOI.IndexMap</code> as an alias.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Given empty `ModelLike` objects `src` and `dest`.

x = add_variable(src)

is_valid(src, x)   # true
is_valid(dest, x)  # false (`dest` has no variables)

index_map = copy_to(dest, src)
is_valid(dest, x) # false (unless index_map[x] == x)
is_valid(dest, index_map[x]) # true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.IndexMap" href="#MathOptInterface.IndexMap"><code>MathOptInterface.IndexMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndexMap()</code></pre><p>The dictionary-like object returned by <a href="#MathOptInterface.copy_to"><code>copy_to</code></a>.</p><p><strong>IndexMap</strong></p><p>Implementations of <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> must return an <a href="#MathOptInterface.IndexMap"><code>IndexMap</code></a>. For technical reasons, the <code>IndexMap</code> type is defined in the Utilities submodule as <code>MOI.Utilities.IndexMap</code>. However, since it is an integral part of the MOI API, we provide this <code>MOI.IndexMap</code> as an alias.</p></div></section></article><h2 id="Model-attributes"><a class="docs-heading-anchor" href="#Model-attributes">Model attributes</a><a id="Model-attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Model-attributes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractModelAttribute" href="#MathOptInterface.AbstractModelAttribute"><code>MathOptInterface.AbstractModelAttribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractModelAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Name" href="#MathOptInterface.Name"><code>MathOptInterface.Name</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Name()</code></pre><p>A model attribute for the string identifying the model. It has a default value of <code>&quot;&quot;</code> if not set`.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveFunction" href="#MathOptInterface.ObjectiveFunction"><code>MathOptInterface.ObjectiveFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObjectiveFunction{F&lt;:AbstractScalarFunction}()</code></pre><p>A model attribute for the objective function which has a type <code>F&lt;:AbstractScalarFunction</code>.</p><p><code>F</code> should be guaranteed to be equivalent but not necessarily identical to the function type provided by the user.</p><p>Throws an <code>InexactError</code> if the objective function cannot be converted to <code>F</code>, e.g., the objective function is quadratic and <code>F</code> is <code>ScalarAffineFunction{Float64}</code> or it has non-integer coefficient and <code>F</code> is <code>ScalarAffineFunction{Int}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveFunctionType" href="#MathOptInterface.ObjectiveFunctionType"><code>MathOptInterface.ObjectiveFunctionType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObjectiveFunctionType()</code></pre><p>A model attribute for the type <code>F</code> of the objective function set using the <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction{F}</code></a> attribute.</p><p><strong>Examples</strong></p><p>In the following code, <code>attr</code> should be equal to <code>MOI.VariableIndex</code>:</p><pre><code class="language-julia hljs">x = MOI.add_variable(model)
MOI.set(model, MOI.ObjectiveFunction{MOI.VariableIndex}(), x)
attr = MOI.get(model, MOI.ObjectiveFunctionType())</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveSense" href="#MathOptInterface.ObjectiveSense"><code>MathOptInterface.ObjectiveSense</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObjectiveSense()</code></pre><p>A model attribute for the objective sense of the objective function, which must be an <code>OptimizationSense</code>: <code>MIN_SENSE</code>, <code>MAX_SENSE</code>, or <code>FEASIBILITY_SENSE</code>. The default is <code>FEASIBILITY_SENSE</code>.</p><p><strong>Interaction with <code>ObjectiveFunction</code></strong></p><p>Setting the sense to <code>FEASIBILITY_SENSE</code> unsets the <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a> attribute. That is, if you first set <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a> and then set <code>ObjectiveSense</code> to be <code>FEASIBILITY_SENSE</code>, no objective function will be passed to the solver.</p><p>In addition, some reformulations of <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a> via bridges rely on the value of <code>ObjectiveSense</code>. Therefore, you should set <code>ObjectiveSense</code> before setting <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NumberOfVariables" href="#MathOptInterface.NumberOfVariables"><code>MathOptInterface.NumberOfVariables</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NumberOfVariables()</code></pre><p>A model attribute for the number of variables in the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfVariableIndices" href="#MathOptInterface.ListOfVariableIndices"><code>MathOptInterface.ListOfVariableIndices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ListOfVariableIndices()</code></pre><p>A model attribute for the <code>Vector{VariableIndex}</code> of all variable indices present in the model (i.e., of length equal to the value of <a href="#MathOptInterface.NumberOfVariables"><code>NumberOfVariables</code></a> in the order in which they were added.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfConstraintTypesPresent" href="#MathOptInterface.ListOfConstraintTypesPresent"><code>MathOptInterface.ListOfConstraintTypesPresent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ListOfConstraintTypesPresent()</code></pre><p>A model attribute for the list of tuples of the form <code>(F,S)</code>, where <code>F</code> is a function type and <code>S</code> is a set type indicating that the attribute <a href="#MathOptInterface.NumberOfConstraints"><code>NumberOfConstraints{F,S}</code></a> has a value greater than zero.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NumberOfConstraints" href="#MathOptInterface.NumberOfConstraints"><code>MathOptInterface.NumberOfConstraints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NumberOfConstraints{F,S}()</code></pre><p>A model attribute for the number of constraints of the type <code>F</code>-in-<code>S</code> present in the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfConstraintIndices" href="#MathOptInterface.ListOfConstraintIndices"><code>MathOptInterface.ListOfConstraintIndices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ListOfConstraintIndices{F,S}()</code></pre><p>A model attribute for the <code>Vector{ConstraintIndex{F,S}}</code> of all constraint indices of type <code>F</code>-in-<code>S</code> in the model (i.e., of length equal to the value of <a href="#MathOptInterface.NumberOfConstraints"><code>NumberOfConstraints{F,S}</code></a>) in the order in which they were added.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfOptimizerAttributesSet" href="#MathOptInterface.ListOfOptimizerAttributesSet"><code>MathOptInterface.ListOfOptimizerAttributesSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ListOfOptimizerAttributesSet()</code></pre><p>An optimizer attribute for the <code>Vector{AbstractOptimizerAttribute}</code> of all optimizer attributes that were set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfModelAttributesSet" href="#MathOptInterface.ListOfModelAttributesSet"><code>MathOptInterface.ListOfModelAttributesSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ListOfModelAttributesSet()</code></pre><p>A model attribute for the <code>Vector{AbstractModelAttribute}</code> of all model attributes <code>attr</code> such that:</p><ol><li><code>is_copyable(attr)</code> returns <code>true</code>, and</li><li>the attribute was set to the model</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfVariableAttributesSet" href="#MathOptInterface.ListOfVariableAttributesSet"><code>MathOptInterface.ListOfVariableAttributesSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ListOfVariableAttributesSet()</code></pre><p>A model attribute for the <code>Vector{AbstractVariableAttribute}</code> of all variable attributes <code>attr</code> such that 1) <code>is_copyable(attr)</code> returns <code>true</code> and 2) the attribute was set to variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfConstraintAttributesSet" href="#MathOptInterface.ListOfConstraintAttributesSet"><code>MathOptInterface.ListOfConstraintAttributesSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ListOfConstraintAttributesSet{F, S}()</code></pre><p>A model attribute for the <code>Vector{AbstractConstraintAttribute}</code> of all constraint attributes <code>attr</code> such that:</p><ol><li><code>is_copyable(attr)</code> returns <code>true</code> and</li><li>the attribute was set to <code>F</code>-in-<code>S</code> constraints.</li></ol><p><strong>Note</strong></p><p>The attributes <a href="../constraints/#MathOptInterface.ConstraintFunction"><code>ConstraintFunction</code></a> and <a href="../constraints/#MathOptInterface.ConstraintSet"><code>ConstraintSet</code></a> should not be included in the list even if then have been set with <a href="#MathOptInterface.set"><code>set</code></a>.</p></div></section></article><h2 id="Optimizer-interface"><a class="docs-heading-anchor" href="#Optimizer-interface">Optimizer interface</a><a id="Optimizer-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizer-interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractOptimizer" href="#MathOptInterface.AbstractOptimizer"><code>MathOptInterface.AbstractOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractOptimizer &lt;: ModelLike</code></pre><p>Abstract supertype for objects representing an instance of an optimization problem tied to a particular solver. This is typically a solver&#39;s in-memory representation. In addition to <code>ModelLike</code>, <code>AbstractOptimizer</code> objects let you solve the model and query the solution.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.OptimizerWithAttributes" href="#MathOptInterface.OptimizerWithAttributes"><code>MathOptInterface.OptimizerWithAttributes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct OptimizerWithAttributes
    optimizer_constructor
    params::Vector{Pair{AbstractOptimizerAttribute,&lt;:Any}}
end</code></pre><p>Object grouping an optimizer constructor and a list of optimizer attributes. Instances are created with <a href="#MathOptInterface.instantiate"><code>instantiate</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.optimize!" href="#MathOptInterface.optimize!"><code>MathOptInterface.optimize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimize!(optimizer::AbstractOptimizer)</code></pre><p>Optimize the problem contained in <code>optimizer</code>.</p><p>Before calling <code>optimize!</code>, the problem should first be constructed using the incremental interface (see <a href="#MathOptInterface.supports_incremental_interface"><code>supports_incremental_interface</code></a>) or <a href="#MathOptInterface.copy_to"><code>copy_to</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.optimize!-Tuple{MathOptInterface.ModelLike, MathOptInterface.ModelLike}" href="#MathOptInterface.optimize!-Tuple{MathOptInterface.ModelLike, MathOptInterface.ModelLike}"><code>MathOptInterface.optimize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimize!(dest::AbstractOptimizer, src::ModelLike)::Tuple{IndexMap,Bool}</code></pre><p>A &quot;one-shot&quot; call that copies the problem from <code>src</code> into <code>dest</code> and then uses <code>dest</code> to optimize the problem.</p><p>Returns a tuple of an <a href="#MathOptInterface.IndexMap"><code>IndexMap</code></a> and a <code>Bool</code> <code>copied</code>.</p><ul><li>The <a href="#MathOptInterface.IndexMap"><code>IndexMap</code></a> object translates variable and constraint indices from the <code>src</code> model to the corresponding indices in the <code>dest</code> optimizer. See <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> for details.</li><li>If <code>copied == true</code>, <code>src</code> was copied to <code>dest</code> and then cached, allowing incremental modification if supported by the solver.</li><li>If <code>copied == false</code>, a cache of the model was <em>not</em> kept in <code>dest</code>. Therefore, only the solution information (attributes for which <a href="#MathOptInterface.is_set_by_optimize"><code>is_set_by_optimize</code></a> is true) is available to query.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The main purpose of <code>optimize!</code> method with two arguments is for use in <a href="../../submodules/Utilities/reference/#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a>.</p></div></div><p><strong>Relationship to the single-argument <code>optimize!</code></strong></p><p>The default fallback of <code>optimize!(dest::AbstractOptimizer, src::ModelLike)</code> is</p><pre><code class="language-julia hljs">function optimize!(dest::AbstractOptimizer, src::ModelLike)
    index_map = copy_to(dest, src)
    optimize!(dest)
    return index_map, true
end</code></pre><p>Therefore, subtypes of <a href="#MathOptInterface.AbstractOptimizer"><code>AbstractOptimizer</code></a> should either implement this two-argument method, or implement both <a href="#MathOptInterface.copy_to"><code>copy_to(::Optimizer, ::ModelLike)</code></a> and <code>optimize!(::Optimizer)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.instantiate" href="#MathOptInterface.instantiate"><code>MathOptInterface.instantiate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">instantiate(
    optimizer_constructor,
    with_cache_type::Union{Nothing,Type} = nothing,
    with_bridge_type::Union{Nothing,Type} = nothing,
)</code></pre><p>Create an instance of an optimizer by either:</p><ul><li>calling <code>optimizer_constructor.optimizer_constructor()</code> and setting the parameters in <code>optimizer_constructor.params</code> if <code>optimizer_constructor</code> is a <a href="#MathOptInterface.OptimizerWithAttributes"><code>OptimizerWithAttributes</code></a></li><li>calling <code>optimizer_constructor()</code> if <code>optimizer_constructor</code> is callable.</li></ul><p><strong>with<em>cache</em>type</strong></p><p>If <code>with_cache_type</code> is not <code>nothing</code>, then the optimizer is wrapped in a <a href="../../submodules/Utilities/reference/#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a> to store a cache of the model. This is most useful if the optimizer you are constructing does not support the incremental interface (see <a href="#MathOptInterface.supports_incremental_interface"><code>supports_incremental_interface</code></a>).</p><p><strong>with<em>bridge</em>type</strong></p><p>If <code>with_bridge_type</code> is not <code>nothing</code>, the optimizer is wrapped in a <a href="../../submodules/Bridges/reference/#MathOptInterface.Bridges.full_bridge_optimizer"><code>Bridges.full_bridge_optimizer</code></a>, enabling all the bridges defined in the MOI.Bridges submodule with coefficient type <code>with_bridge_type</code>.</p><p>In addition, if the optimizer created by <code>optimizer_constructor</code> does not support the incremental interface (see <a href="#MathOptInterface.supports_incremental_interface"><code>supports_incremental_interface</code></a>), then, irrespective of <code>with_cache_type</code>, the optimizer is wrapped in a <a href="../../submodules/Utilities/reference/#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a> to store a cache of the bridged model.</p><p>If <code>with_cache_type</code> and <code>with_bridge_type</code> are both not <code>nothing</code>, then they must be the same type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.default_cache" href="#MathOptInterface.default_cache"><code>MathOptInterface.default_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default_cache(optimizer::ModelLike, ::Type{T}) where {T}</code></pre><p>Return a new instance of the default model type to be used as cache for <code>optimizer</code> in a <a href="../../submodules/Utilities/reference/#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a> for holding constraints of coefficient type <code>T</code>. By default, this returns <code>Utilities.UniversalFallback(Utilities.Model{T}())</code>. If copying from a instance of a given model type is faster for <code>optimizer</code> then a new method returning an instance of this model type should be defined.</p></div></section></article><h2 id="Optimizer-attributes"><a class="docs-heading-anchor" href="#Optimizer-attributes">Optimizer attributes</a><a id="Optimizer-attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizer-attributes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractOptimizerAttribute" href="#MathOptInterface.AbstractOptimizerAttribute"><code>MathOptInterface.AbstractOptimizerAttribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractOptimizerAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the optimizer.</p><p><strong>Notes</strong></p><p>The difference between <code>AbstractOptimizerAttribute</code> and <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> lies in the behavior of <a href="#MathOptInterface.is_empty"><code>is_empty</code></a>, <a href="#MathOptInterface.empty!"><code>empty!</code></a> and <a href="#MathOptInterface.copy_to"><code>copy_to</code></a>. Typically optimizer attributes affect only how the model is solved.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SolverName" href="#MathOptInterface.SolverName"><code>MathOptInterface.SolverName</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolverName()</code></pre><p>An optimizer attribute for the string identifying the solver/optimizer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SolverVersion" href="#MathOptInterface.SolverVersion"><code>MathOptInterface.SolverVersion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolverVersion()</code></pre><p>An optimizer attribute for the string identifying the version of the solver.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For solvers supporting <a href="https://semver.org">semantic versioning</a>, the <code>SolverVersion</code> should be a string of the form &quot;vMAJOR.MINOR.PATCH&quot;, so that it can be converted to a Julia <code>VersionNumber</code> (e.g., `VersionNumber(&quot;v1.2.3&quot;)).</p><p>We do not require Semantic Versioning because some solvers use alternate versioning systems. For example, CPLEX uses Calendar Versioning, so <code>SolverVersion</code> will return a string like <code>&quot;202001&quot;</code>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Silent" href="#MathOptInterface.Silent"><code>MathOptInterface.Silent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Silent()</code></pre><p>An optimizer attribute for silencing the output of an optimizer. When <code>set</code> to <code>true</code>, it takes precedence over any other attribute controlling verbosity and requires the solver to produce no output. The default value is <code>false</code> which has no effect. In this case the verbosity is controlled by other attributes.</p><p><strong>Note</strong></p><p>Every optimizer should have verbosity on by default. For instance, if a solver has a solver-specific log level attribute, the MOI implementation should set it to <code>1</code> by default. If the user sets <code>Silent</code> to <code>true</code>, then the log level should be set to <code>0</code>, even if the user specifically sets a value of log level. If the value of <code>Silent</code> is <code>false</code> then the log level set to the solver is the value given by the user for this solver-specific parameter or <code>1</code> if none is given.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.TimeLimitSec" href="#MathOptInterface.TimeLimitSec"><code>MathOptInterface.TimeLimitSec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeLimitSec()</code></pre><p>An optimizer attribute for setting a time limit (in seconnds) for an optimization. When <code>set</code> to <code>nothing</code>, it deactivates the solver time limit. The default value is <code>nothing</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RawOptimizerAttribute" href="#MathOptInterface.RawOptimizerAttribute"><code>MathOptInterface.RawOptimizerAttribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RawOptimizerAttribute(name::String)</code></pre><p>An optimizer attribute for the solver-specific parameter identified by <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NumberOfThreads" href="#MathOptInterface.NumberOfThreads"><code>MathOptInterface.NumberOfThreads</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NumberOfThreads()</code></pre><p>An optimizer attribute for setting the number of threads used for an optimization. When set to <code>nothing</code> uses solver default. Values are positive integers. The default value is <code>nothing</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RawSolver" href="#MathOptInterface.RawSolver"><code>MathOptInterface.RawSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RawSolver()</code></pre><p>A model attribute for the object that may be used to access a solver-specific API for this optimizer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbsoluteGapTolerance" href="#MathOptInterface.AbsoluteGapTolerance"><code>MathOptInterface.AbsoluteGapTolerance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbsoluteGapTolerance()</code></pre><p>An optimizer attribute for setting the absolute gap tolerance for an optimization. This is an <em>optimizer</em> attribute, and should be set before calling <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>. When set to <code>nothing</code> (if supported), uses solver default.</p><p>To set a <em>relative</em> gap tolerance, see <a href="#MathOptInterface.RelativeGapTolerance"><code>RelativeGapTolerance</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The mathematical definition of &quot;absolute gap&quot;, and its treatment during the optimization, are solver-dependent. However, assuming no other limit nor issue is encountered during the optimization, most solvers that implement this attribute will stop once <span>$|f - b| ≤ g_{abs}$</span>, where <span>$b$</span> is the best bound, <span>$f$</span> is the best feasible objective value, and <span>$g_{abs}$</span> is the absolute gap.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RelativeGapTolerance" href="#MathOptInterface.RelativeGapTolerance"><code>MathOptInterface.RelativeGapTolerance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RelativeGapTolerance()</code></pre><p>An optimizer attribute for setting the relative gap tolerance for an optimization. This is an <em>optimizer</em> attribute, and should be set before calling <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>. When set to <code>nothing</code> (if supported), uses solver default.</p><p>If you are looking for the relative gap of the current best solution, see <a href="#MathOptInterface.RelativeGap"><code>RelativeGap</code></a>. If no limit nor issue is encountered during the optimization, the value of <a href="#MathOptInterface.RelativeGap"><code>RelativeGap</code></a> should be at most as large as <code>RelativeGapTolerance</code>.</p><pre><code class="language-julia hljs"># Before optimizing: set relative gap tolerance
# set 0.1% relative gap tolerance
MOI.set(model, MOI.RelativeGapTolerance(), 1e-3)
MOI.optimize!(model)

# After optimizing (assuming all went well)
# The relative gap tolerance has not changed...
MOI.get(model, MOI.RelativeGapTolerance())  # returns 1e-3
# ... and the relative gap of the obtained solution is smaller or equal to the
# tolerance
MOI.get(model, MOI.RelativeGap())  # should return something ≤ 1e-3</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The mathematical definition of &quot;relative gap&quot;, and its allowed range, are solver-dependent. Typically, solvers expect a value between <code>0.0</code> and <code>1.0</code>.</p></div></div></div></section></article><p>List of attributes useful for optimizers</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.TerminationStatus" href="#MathOptInterface.TerminationStatus"><code>MathOptInterface.TerminationStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TerminationStatus()</code></pre><p>A model attribute for the <code>TerminationStatusCode</code> explaining why the optimizer stopped.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.TerminationStatusCode" href="#MathOptInterface.TerminationStatusCode"><code>MathOptInterface.TerminationStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TerminationStatusCode</code></pre><p>An Enum of possible values for the <code>TerminationStatus</code> attribute. This attribute is meant to explain the reason why the optimizer stopped executing in the most recent call to <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>.</p><p>If no call has been made to <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>, then the <code>TerminationStatus</code> is:</p><ul><li><code>OPTIMIZE_NOT_CALLED</code>: The algorithm has not started.</li></ul><p><strong>OK</strong></p><p>These are generally OK statuses, i.e., the algorithm ran to completion normally.</p><ul><li><code>OPTIMAL</code>: The algorithm found a globally optimal solution.</li><li><code>INFEASIBLE</code>: The algorithm concluded that no feasible solution exists.</li><li><code>DUAL_INFEASIBLE</code>: The algorithm concluded that no dual bound exists for the problem. If, additionally, a feasible (primal) solution is known to exist, this status typically implies that the problem is unbounded, with some technical exceptions.</li><li><code>LOCALLY_SOLVED</code>: The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.</li><li><code>LOCALLY_INFEASIBLE</code>: The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.</li><li><code>INFEASIBLE_OR_UNBOUNDED</code>: The algorithm stopped because it decided that the problem is infeasible or unbounded; this occasionally happens during MIP presolve.</li></ul><p><strong>Solved to relaxed tolerances</strong></p><ul><li><code>ALMOST_OPTIMAL</code>: The algorithm found a globally optimal solution to relaxed tolerances.</li><li><code>ALMOST_INFEASIBLE</code>: The algorithm concluded that no feasible solution exists within relaxed tolerances.</li><li><code>ALMOST_DUAL_INFEASIBLE</code>: The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.</li><li><code>ALMOST_LOCALLY_SOLVED</code>: The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.</li></ul><p><strong>Limits</strong></p><p>The optimizer stopped because of some user-defined limit.</p><ul><li><code>ITERATION_LIMIT</code>: An iterative algorithm stopped after conducting the maximum number of iterations.</li><li><code>TIME_LIMIT</code>: The algorithm stopped after a user-specified computation time.</li><li><code>NODE_LIMIT</code>: A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.</li><li><code>SOLUTION_LIMIT</code>: The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.</li><li><code>MEMORY_LIMIT</code>: The algorithm stopped because it ran out of memory.</li><li><code>OBJECTIVE_LIMIT</code>: The algorithm stopped because it found a solution better than a minimum limit set by the user.</li><li><code>NORM_LIMIT</code>: The algorithm stopped because the norm of an iterate became too large.</li><li><code>OTHER_LIMIT</code>: The algorithm stopped due to a limit not covered by one of the above.</li></ul><p><strong>Problematic</strong></p><p>This group of statuses means that something unexpected or problematic happened.</p><ul><li><code>SLOW_PROGRESS</code>: The algorithm stopped because it was unable to continue making progress towards the solution.</li><li><code>NUMERICAL_ERROR</code>: The algorithm stopped because it encountered unrecoverable numerical error.</li><li><code>INVALID_MODEL</code>: The algorithm stopped because the model is invalid.</li><li><code>INVALID_OPTION</code>: The algorithm stopped because it was provided an invalid option.</li><li><code>INTERRUPTED</code>: The algorithm stopped because of an interrupt signal.</li><li><code>OTHER_ERROR</code>: The algorithm stopped because of an error not covered by one of the statuses defined above.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.PrimalStatus" href="#MathOptInterface.PrimalStatus"><code>MathOptInterface.PrimalStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrimalStatus(result_index::Int = 1)</code></pre><p>A model attribute for the <a href="#MathOptInterface.ResultStatusCode"><code>ResultStatusCode</code></a> of the primal result <code>result_index</code>. If <code>result_index</code> is omitted, it defaults to 1.</p><p>See <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> for information on how the results are ordered.</p><p>If <code>result_index</code> is larger than the value of <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> then <code>NO_SOLUTION</code> is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.DualStatus" href="#MathOptInterface.DualStatus"><code>MathOptInterface.DualStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DualStatus(result_index::Int = 1)</code></pre><p>A model attribute for the <code>ResultStatusCode</code> of the dual result <code>result_index</code>. If <code>result_index</code> is omitted, it defaults to 1.</p><p>See <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> for information on how the results are ordered.</p><p>If <code>result_index</code> is larger than the value of <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> then <code>NO_SOLUTION</code> is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ResultStatusCode" href="#MathOptInterface.ResultStatusCode"><code>MathOptInterface.ResultStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ResultStatusCode</code></pre><p>An Enum of possible values for the <code>PrimalStatus</code> and <code>DualStatus</code> attributes. The values indicate how to interpret the result vector.</p><ul><li><code>NO_SOLUTION</code>: the result vector is empty.</li><li><code>FEASIBLE_POINT</code>: the result vector is a feasible point.</li><li><code>NEARLY_FEASIBLE_POINT</code>: the result vector is feasible if some constraint tolerances are relaxed.</li><li><code>INFEASIBLE_POINT</code>: the result vector is an infeasible point.</li><li><code>INFEASIBILITY_CERTIFICATE</code>: the result vector is an infeasibility certificate. If the <code>PrimalStatus</code> is <code>INFEASIBILITY_CERTIFICATE</code>, then the primal result vector is a certificate of dual infeasibility. If the <code>DualStatus</code> is <code>INFEASIBILITY_CERTIFICATE</code>, then the dual result vector is a proof of primal infeasibility.</li><li><code>NEARLY_INFEASIBILITY_CERTIFICATE</code>: the result satisfies a relaxed criterion for a certificate of infeasibility.</li><li><code>REDUCTION_CERTIFICATE</code>: the result vector is an ill-posed certificate; see <a href="https://arxiv.org/abs/1408.4685">this article</a> for details. If the <code>PrimalStatus</code> is <code>REDUCTION_CERTIFICATE</code>, then the primal result vector is a proof that the dual problem is ill-posed. If the <code>DualStatus</code> is <code>REDUCTION_CERTIFICATE</code>, then the dual result vector is a proof that the primal is ill-posed.</li><li><code>NEARLY_REDUCTION_CERTIFICATE</code>: the result satisfies a relaxed criterion for an ill-posed certificate.</li><li><code>UNKNOWN_RESULT_STATUS</code>: the result vector contains a solution with an unknown interpretation.</li><li><code>OTHER_RESULT_STATUS</code>: the result vector contains a solution with an interpretation not covered by one of the statuses defined above.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RawStatusString" href="#MathOptInterface.RawStatusString"><code>MathOptInterface.RawStatusString</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RawStatusString()</code></pre><p>A model attribute for a solver specific string explaining why the optimizer stopped.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ResultCount" href="#MathOptInterface.ResultCount"><code>MathOptInterface.ResultCount</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ResultCount()</code></pre><p>A model attribute for the number of results available.</p><p><strong>Order of solutions</strong></p><p>A number of attributes contain an index, <code>result_index</code>, which is used to refer to one of the available results. Thus, <code>result_index</code> must be an integer between <code>1</code> and the number of available results.</p><p>As a general rule, the first result (<code>result_index=1</code>) is the most important result (e.g., an optimal solution or an infeasibility certificate). Other results will typically be alternate solutions that the solver found during the search for the first result.</p><p>If a (local) optimal solution is available, i.e., <a href="#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a> is <code>OPTIMAL</code> or <code>LOCALLY_SOLVED</code>, the first result must correspond to the (locally) optimal solution. Other results may be alternative optimal solutions, or they may be other suboptimal solutions; use <a href="#MathOptInterface.ObjectiveValue"><code>ObjectiveValue</code></a> to distingiush between them.</p><p>If a primal or dual infeasibility certificate is available, i.e., <a href="#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a> is <code>INFEASIBLE</code> or <code>DUAL_INFEASIBLE</code> and the corresponding <a href="#MathOptInterface.PrimalStatus"><code>PrimalStatus</code></a> or <a href="#MathOptInterface.DualStatus"><code>DualStatus</code></a> is <code>INFEASIBILITY_CERTIFICATE</code>, then the first result must be a certificate. Other results may be alternate certificates, or infeasible points.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveValue" href="#MathOptInterface.ObjectiveValue"><code>MathOptInterface.ObjectiveValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObjectiveValue(result_index::Int = 1)</code></pre><p>A model attribute for the objective value of the primal solution <code>result_index</code>.</p><p>If the solver does not have a primal value for the objective because the <code>result_index</code> is beyond the available solutions (whose number is indicated by the <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> attribute), getting this attribute must throw a <a href="../errors/#MathOptInterface.ResultIndexBoundsError"><code>ResultIndexBoundsError</code></a>. Otherwise, if the result is unavailable for another reason (for instance, only a dual solution is available), the result is undefined. Users should first check <a href="#MathOptInterface.PrimalStatus"><code>PrimalStatus</code></a> before accessing the <code>ObjectiveValue</code> attribute.</p><p>See <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> for information on how the results are ordered.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.DualObjectiveValue" href="#MathOptInterface.DualObjectiveValue"><code>MathOptInterface.DualObjectiveValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DualObjectiveValue(result_index::Int = 1)</code></pre><p>A model attribute for the value of the objective function of the dual problem for the <code>result_index</code>th dual result.</p><p>If the solver does not have a dual value for the objective because the <code>result_index</code> is beyond the available solutions (whose number is indicated by the <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> attribute), getting this attribute must throw a <a href="../errors/#MathOptInterface.ResultIndexBoundsError"><code>ResultIndexBoundsError</code></a>. Otherwise, if the result is unavailable for another reason (for instance, only a primal solution is available), the result is undefined. Users should first check <a href="#MathOptInterface.DualStatus"><code>DualStatus</code></a> before accessing the <code>DualObjectiveValue</code> attribute.</p><p>See <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> for information on how the results are ordered.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveBound" href="#MathOptInterface.ObjectiveBound"><code>MathOptInterface.ObjectiveBound</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObjectiveBound()</code></pre><p>A model attribute for the best known bound on the optimal objective value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RelativeGap" href="#MathOptInterface.RelativeGap"><code>MathOptInterface.RelativeGap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RelativeGap()</code></pre><p>A model attribute for the final relative optimality gap.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The definition of this gap is solver-dependent. However, most solvers implementing this attribute define the relative gap as some variation of <span>$\frac{|b-f|}{|f|}$</span>, where <span>$b$</span> is the best bound and <span>$f$</span> is the best feasible objective value.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SolveTimeSec" href="#MathOptInterface.SolveTimeSec"><code>MathOptInterface.SolveTimeSec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolveTimeSec()</code></pre><p>A model attribute for the total elapsed solution time (in seconds) as reported by the optimizer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SimplexIterations" href="#MathOptInterface.SimplexIterations"><code>MathOptInterface.SimplexIterations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimplexIterations()</code></pre><p>A model attribute for the cumulative number of simplex iterations during the optimization process.</p><p>For a mixed-integer program (MIP), the return value is the total simplex iterations for all nodes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.BarrierIterations" href="#MathOptInterface.BarrierIterations"><code>MathOptInterface.BarrierIterations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BarrierIterations()</code></pre><p>A model attribute for the cumulative number of barrier iterations while solving a problem.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NodeCount" href="#MathOptInterface.NodeCount"><code>MathOptInterface.NodeCount</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NodeCount()</code></pre><p>A model attribute for the total number of branch-and-bound nodes explored while solving a mixed-integer program (MIP).</p></div></section></article><h3 id="Conflict-Status"><a class="docs-heading-anchor" href="#Conflict-Status">Conflict Status</a><a id="Conflict-Status-1"></a><a class="docs-heading-anchor-permalink" href="#Conflict-Status" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.compute_conflict!" href="#MathOptInterface.compute_conflict!"><code>MathOptInterface.compute_conflict!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_conflict!(optimizer::AbstractOptimizer)</code></pre><p>Computes a minimal subset of constraints such that the model with the other constraint removed is still infeasible.</p><p>Some solvers call a set of conflicting constraints an Irreducible Inconsistent Subsystem (IIS).</p><p>See also <a href="#MathOptInterface.ConflictStatus"><code>ConflictStatus</code></a> and <a href="#MathOptInterface.ConstraintConflictStatus"><code>ConstraintConflictStatus</code></a>.</p><p><strong>Note</strong></p><p>If the model is modified after a call to <code>compute_conflict!</code>, the implementor is not obliged to purge the conflict. Any calls to the above attributes may return values for the original conflict without a warning. Similarly, when modifying the model, the conflict can be discarded.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictStatus" href="#MathOptInterface.ConflictStatus"><code>MathOptInterface.ConflictStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConflictStatus()</code></pre><p>A model attribute for the <a href="#MathOptInterface.ConflictStatusCode"><code>ConflictStatusCode</code></a> explaining why the conflict refiner stopped when computing the conflict.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictStatusCode" href="#MathOptInterface.ConflictStatusCode"><code>MathOptInterface.ConflictStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConflictStatusCode</code></pre><p>An Enum of possible values for the <code>ConflictStatus</code> attribute. This attribute is meant to explain the reason why the conflict finder stopped executing in the most recent call to <a href="#MathOptInterface.compute_conflict!"><code>compute_conflict!</code></a>.</p><p>Possible values are:</p><ul><li><code>COMPUTE_CONFLICT_NOT_CALLED</code>: the function <a href="#MathOptInterface.compute_conflict!"><code>compute_conflict!</code></a> has not yet been called</li><li><code>NO_CONFLICT_EXISTS</code>: there is no conflict because the problem is feasible</li><li><code>NO_CONFLICT_FOUND</code>: the solver could not find a conflict</li><li><code>CONFLICT_FOUND</code>: at least one conflict could be found</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConstraintConflictStatus" href="#MathOptInterface.ConstraintConflictStatus"><code>MathOptInterface.ConstraintConflictStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstraintConflictStatus()</code></pre><p>A constraint attribute indicating whether the constraint participates in the conflict. Its type is <a href="#MathOptInterface.ConflictParticipationStatusCode"><code>ConflictParticipationStatusCode</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictParticipationStatusCode" href="#MathOptInterface.ConflictParticipationStatusCode"><code>MathOptInterface.ConflictParticipationStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConflictParticipationStatusCode</code></pre><p>An Enum of possible values for the <a href="#MathOptInterface.ConstraintConflictStatus"><code>ConstraintConflictStatus</code></a> attribute. This attribute is meant to indicate whether a given constraint participates or not in the last computed conflict.</p><p>Possible values are:</p><ul><li><code>NOT_IN_CONFLICT</code>: the constraint does not participate in the conflict</li><li><code>IN_CONFLICT</code>: the constraint participates in the conflict</li><li><code>MAYBE_IN_CONFLICT</code>: the constraint may participate in the conflict, the solver was not able to prove that the constraint can be excluded from the conflict</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../standard_form/">« Standard form</a><a class="docs-footer-nextpage" href="../variables/">Variables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Monday 3 April 2023 10:25">Monday 3 April 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
