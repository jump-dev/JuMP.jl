<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Solvers · JuMP</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><a href="../index.html"><img alt="JuMP logo" class="logo" src="../assets/logo.png"/></a><h1>JuMP</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search/" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../installation/">Installation Guide</a></li><li><a class="toctext" href="../quickstart/">Quick Start Guide</a></li><li><a class="toctext" href="../variables/">Variables</a></li><li><a class="toctext" href="../expressions/">Expressions</a></li><li><a class="toctext" href="../objective/">Objective</a></li><li><a class="toctext" href="../constraints/">Constraints</a></li><li><a class="toctext" href="../containers/">Containers</a></li><li class="current"><a class="toctext" href="">Solvers</a><ul class="internal"><li><a class="toctext" href="#Automatic-and-Manual-modes-1">Automatic and Manual modes</a></li><li><a class="toctext" href="#Direct-mode-1">Direct mode</a></li><li><a class="toctext" href="#Solver-attributes-1">Solver attributes</a></li></ul></li><li><a class="toctext" href="../solutions/">Query Solutions</a></li><li><a class="toctext" href="../nlp/">Nonlinear Modeling</a></li><li><a class="toctext" href="../style/">Style Guide</a></li><li><a class="toctext" href="../extensions/">Extensions</a></li><li><a class="toctext" href="../roadmap/">Development Roadmap</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="">Solvers</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/JuMP.jl/blob/master/docs/src/solvers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Interacting-with-solvers-1" id="Interacting-with-solvers-1">Interacting with solvers</a></h1><p>A JuMP model keeps a <a href="https://github.com/JuliaOpt/MathOptInterface.jl">MathOptInterface (MOI)</a><em>backend</em> of type <code>MOI.ModelLike</code> that stores the optimization problem and acts as the optimization solver. We call it an MOI <em>backend</em> and not optimizer as it can also be a wrapper around an optimization file format such as MPS that writes the JuMP model in a file. From JuMP, the MOI backend can be accessed using the <a href="#JuMP.backend"><code>backend</code></a> function. JuMP can be viewed as a lightweight, user-friendly layer on top of the MOI backend, in the sense that:</p><ul><li>JuMP does not maintain any copy of the model outside this MOI backend.</li><li>JuMP variable (resp. constraint) references are simple structures containing both a reference to the JuMP model and the MOI index of the variable (resp. constraint).</li><li>JuMP gives the constraints to the MOI backend in the form provided by the user without doing any automatic reformulation.</li><li>variables additions, constraints additions/modifications and objective modifications are directly applied to the MOI backend thus expecting the backend to support such modifications.</li></ul><p>While this allows JuMP to be a thin wrapper on top of the solver API, as mentioned in the last point above, this seems rather demanding on the solver. Indeed, while some solvers support incremental building of the model and modifications before and after solve, other solvers only support the model being copied at once before solve. Moreover, it seems to require all solvers to implement all possible reformulations independently which seems both very ambitious and might generate a lot of duplicated code.</p><p>These apparent limitations are addressed at level of MOI in a manner that is completely transparent to JuMP. While the MOI API may seem very demanding, it allows MOI models to be a succession of lightweight MOI layers that fill the gap between JuMP requirements and the solver capabilities. The remainder of this section describes how JuMP interacts with the MOI backend.</p><p>JuMP models can be created in three different modes: <code>AUTOMATIC</code>, <code>MANUAL</code> and <code>DIRECT</code>.</p><h2><a class="nav-anchor" href="#Automatic-and-Manual-modes-1" id="Automatic-and-Manual-modes-1">Automatic and Manual modes</a></h2><p>In <code>AUTOMATIC</code> and <code>MANUAL</code> modes, two MOI layers are automatically applied to the optimizer:</p><ul><li><code>CachingOptimizer</code>: maintains a cache of the model so that when the optimizer does not support an incremental change to the model, the optimizer's internal model can be discarded and restored from the cache just before optimization. The <code>CachingOptimizer</code> has two different modes: <code>AUTOMATIC</code> and <code>MANUAL</code> corresponding to the two JuMP modes with the same names.</li><li><code>LazyBridgeOptimizer</code> (this can be disabled using the <code>bridge_constraints</code> keyword argument to <a href="#JuMP.Model-Tuple{}"><code>Model</code></a> constructor): when a constraint added is not supported by the optimizer, it attempts to transform the constraint into an equivalent form, possibly adding new variables and constraints that are supported by the optimizer. The applied transformations are selected among known recipes which are called bridges. A few default bridges are defined in MOI but new ones can be defined and added to the <code>LazyBridgeOptimizer</code> used by JuMP.</li></ul><p>See the <a href="http://www.juliaopt.org/MathOptInterface.jl/v0.9.1/">MOI documentation</a> for more details on these two MOI layers.</p><p>To attach an optimizer to a JuMP model, JuMP needs to create a new empty optimizer instance. New optimizer instances can be obtained using an <code>OptimizerFactory</code> that can be created using the <a href="#JuMP.with_optimizer"><code>with_optimizer</code></a> function:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.with_optimizer" id="JuMP.with_optimizer"><code>JuMP.with_optimizer</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">with_optimizer(constructor, args...; kwargs...)</code></pre><p>Return an <code>OptimizerFactory</code> that creates optimizers using the constructor <code>constructor</code> with positional arguments <code>args</code> and keyword arguments <code>kwargs</code>.</p><p><strong>Examples</strong></p><p>The following returns an optimizer factory that creates <code>Ipopt.Optimizer</code>s using the constructor call <code>Ipopt.Optimizer(print_level=0)</code>:</p><pre><code class="language-julia">with_optimizer(Ipopt.Optimizer, print_level=0)</code></pre></div></div></section><p>The factory can be provided either at model construction time or at <a href="#JuMP.optimize!"><code>optimize!</code></a> time:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.NoOptimizer" id="JuMP.NoOptimizer"><code>JuMP.NoOptimizer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct NoOptimizer &lt;: Exception end</code></pre><p>No optimizer is set. The optimizer can be provided at the <a href="#JuMP.Model-Tuple{}"><code>Model</code></a> constructor or at the <a href="#JuMP.optimize!"><code>optimize!</code></a> call with <a href="#JuMP.with_optimizer"><code>with_optimizer</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.optimize!" id="JuMP.optimize!"><code>JuMP.optimize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">optimize!(model::Model,
          optimizer_factory::Union{Nothing, OptimizerFactory}=nothing;
          bridge_constraints::Bool=true,
          ignore_optimize_hook=(model.optimize_hook === nothing),
          kwargs...)</code></pre><p>Optimize the model. If <code>optimizer_factory</code> is not <code>nothing</code>, it first sets the optimizer to a new one created using the optimizer factory. The factory can be created using the <a href="#JuMP.with_optimizer"><code>with_optimizer</code></a> function. If <code>optimizer_factory</code> is <code>nothing</code> and no optimizer was set to <code>model</code> before calling this function, a <a href="#JuMP.NoOptimizer"><code>NoOptimizer</code></a> error is thrown.</p><p>Keyword arguments <code>kwargs</code> are passed to the <code>optimize_hook</code>. An error is thrown if <code>optimize_hook</code> is <code>nothing</code> and keyword arguments are provided.</p><p><strong>Examples</strong></p><p>The optimizer factory can either be given in the <a href="#JuMP.Model-Tuple{}"><code>Model</code></a> constructor as follows:</p><pre><code class="language-julia">model = Model(with_optimizer(GLPK.Optimizer))
# ...fill model with variables, constraints and objectives...
# Solve the model with GLPK
optimize!(model)</code></pre><p>or in the <code>optimize!</code> call as follows:</p><pre><code class="language-julia">model = Model()
# ...fill model with variables, constraints and objectives...
# Solve the model with GLPK
optimize!(model, with_optimizer(GLPK.Optimizer))</code></pre></div></div></section><p>New JuMP models are created using the <a href="#JuMP.Model-Tuple{}"><code>Model</code></a> constructor:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.Model-Tuple{}" id="JuMP.Model-Tuple{}"><code>JuMP.Model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Model(; caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC,
        bridge_constraints::Bool=true)</code></pre><p>Return a new JuMP model without any optimizer; the model is stored the model in a cache. The mode of the <code>CachingOptimizer</code> storing this cache is <code>caching_mode</code>. The optimizer can be set later in the <a href="#JuMP.optimize!"><code>optimize!</code></a> call. If <code>bridge_constraints</code> is true, constraints that are not supported by the optimizer are automatically bridged to equivalent supported constraints when an appropriate transformation is defined in the <code>MathOptInterface.Bridges</code> module or is defined in another module and is explicitely added.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.Model-Tuple{OptimizerFactory}" id="JuMP.Model-Tuple{OptimizerFactory}"><code>JuMP.Model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Model(optimizer_factory::OptimizerFactory;
      caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC,
      bridge_constraints::Bool=true)</code></pre><p>Return a new JuMP model using the optimizer factory <code>optimizer_factory</code> to create the optimizer. The optimizer factory can be created by the <a href="#JuMP.with_optimizer"><code>with_optimizer</code></a> function.</p><p><strong>Examples</strong></p><p>The following creates a model using the optimizer <code>Ipopt.Optimizer(print_level=0)</code>:</p><pre><code class="language-julia">model = Model(with_optimizer(Ipopt.Optimizer, print_level=0))</code></pre></div></div></section><h2><a class="nav-anchor" href="#Direct-mode-1" id="Direct-mode-1">Direct mode</a></h2><p>JuMP models can be created in <code>DIRECT</code> mode using the <a href="#JuMP.direct_model"><code>JuMP.direct_model</code></a> function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.direct_model" id="JuMP.direct_model"><code>JuMP.direct_model</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">direct_model(backend::MOI.ModelLike)</code></pre><p>Return a new JuMP model using <code>backend</code> to store the model and solve it. As opposed to the <a href="#JuMP.Model-Tuple{}"><code>Model</code></a> constructor, no cache of the model is stored outside of <code>backend</code> and no bridges are automatically applied to <code>backend</code>. The absence of cache reduces the memory footprint but it is important to bear in mind the following implications of creating models using this <em>direct</em> mode:</p><ul><li>When <code>backend</code> does not support an operation, such as modifying constraints or adding variables/constraints after solving, an error is thrown. For models created using the <a href="#JuMP.Model-Tuple{}"><code>Model</code></a> constructor, such situations can be dealt with by storing the modifications in a cache and loading them into the optimizer when <code>optimize!</code> is called.</li><li>No constraint bridging is supported by default.</li><li>The optimizer used cannot be changed the model is constructed.</li><li>The model created cannot be copied.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.backend" id="JuMP.backend"><code>JuMP.backend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">backend(model::Model)</code></pre><p>Return the lower-level MathOptInterface model that sits underneath JuMP. This model depends on which operating mode JuMP is in (manual, automatic, or direct), and whether there are any bridges in the model.</p><p>If JuMP is in direct mode (i.e., the model was created using <a href="#JuMP.direct_model"><code>direct_model</code></a>), the backend with be the optimizer passed to <code>direct_model</code>. If JuMP is in manual or automatic mode, the backend is a <code>MOI.Utilities.CachingOptimizer</code>.</p><p>This function should only be used by advanced users looking to access low-level MathOptInterface or solver-specific functionality.</p></div></div></section><h2><a class="nav-anchor" href="#Solver-attributes-1" id="Solver-attributes-1">Solver attributes</a></h2><p>Some solver attributes can be queried and set through JuMP models.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.solver_name" id="JuMP.solver_name"><code>JuMP.solver_name</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solver_name(model::Model)</code></pre><p>If available, returns the <code>SolverName</code> property of the underlying optimizer. Returns <code>"No optimizer attached"</code> in <code>AUTOMATIC</code> or <code>MANUAL</code> modes when no optimizer is attached. Returns "SolverName() attribute not implemented by the optimizer." if the attribute is not implemented.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.bridge_constraints" id="JuMP.bridge_constraints"><code>JuMP.bridge_constraints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bridge_constraints(model::Model)</code></pre><p>When in direct mode, return <code>false</code>. When in manual or automatic mode, return a <code>Bool</code> indicating whether the optimizer is set and unsupported constraints are automatically bridged to equivalent supported constraints when an appropriate transformation is available.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.set_silent" id="JuMP.set_silent"><code>JuMP.set_silent</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_silent(model::Model)</code></pre><p>Takes precedence over any other attribute controlling verbosity and requires the solver to produce no output.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.unset_silent" id="JuMP.unset_silent"><code>JuMP.unset_silent</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unset_silent(model::Model)</code></pre><p>Neutralize the effect of the <code>set_silent</code> function and let the solver attributes control the verbosity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.set_parameter" id="JuMP.set_parameter"><code>JuMP.set_parameter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_parameter(model::Model, name, value)</code></pre><p>Sets solver-specific parameter identified by <code>name</code> to <code>value</code>.</p></div></div></section><footer><hr/><a class="previous" href="../containers/"><span class="direction">Previous</span><span class="title">Containers</span></a><a class="next" href="../solutions/"><span class="direction">Next</span><span class="title">Query Solutions</span></a></footer></article></body></HTML>