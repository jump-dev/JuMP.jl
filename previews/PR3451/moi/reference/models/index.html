<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Models · JuMP</title><meta name="title" content="Models · JuMP"/><meta property="og:title" content="Models · JuMP"/><meta property="twitter:title" content="Models · JuMP"/><meta name="description" content="Documentation for JuMP."/><meta property="og:description" content="Documentation for JuMP."/><meta property="twitter:description" content="Documentation for JuMP."/><script async src="https://www.googletagmanager.com/gtag/js?id=G-0RZ8X3D3D0"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-0RZ8X3D3D0', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/extra_styles.css" rel="stylesheet" type="text/css"/><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img class="docs-light-only" src="../../../assets/logo.svg" alt="JuMP logo"/><img class="docs-dark-only" src="../../../assets/logo-dark.svg" alt="JuMP logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../">Introduction</a></li><li><a class="tocitem" href="../../../should_i_use/">Should you use JuMP?</a></li><li><a class="tocitem" href="../../../installation/">Installation Guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/getting_started/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/getting_started_with_julia/">Getting started with Julia</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/getting_started_with_JuMP/">Getting started with JuMP</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/getting_started_with_sets_and_indexing/">Getting started with sets and indexing</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/getting_started_with_data_and_plotting/">Getting started with data and plotting</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/debugging/">Debugging</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/tolerances/">Tolerances and numerical issues</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/design_patterns_for_larger_models/">Design patterns for larger models</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/performance_tips/">Performance tips</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/sum_if/">Performance problems with sum-if formulations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Transitioning</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/transitioning/transitioning_from_matlab/">Transitioning from MATLAB</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Linear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/linear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../tutorials/linear/knapsack/">The knapsack problem example</a></li><li><a class="tocitem" href="../../../tutorials/linear/diet/">The diet problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/typed_indices/">Strategies for dealing with many indices</a></li><li><a class="tocitem" href="../../../tutorials/linear/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../../../tutorials/linear/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/multi_commodity_network/">The network multi-commodity flow problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../../tutorials/linear/piecewise_linear/">Approximating nonlinear functions</a></li><li><a class="tocitem" href="../../../tutorials/linear/facility_location/">The facility location problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/finance/">Financial modeling problems</a></li><li><a class="tocitem" href="../../../tutorials/linear/geographic_clustering/">Geographical clustering</a></li><li><a class="tocitem" href="../../../tutorials/linear/network_flows/">Network flow problems</a></li><li><a class="tocitem" href="../../../tutorials/linear/transp/">The transportation problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/multi_objective_examples/">Simple multi-objective examples</a></li><li><a class="tocitem" href="../../../tutorials/linear/multi_objective_knapsack/">Multi-objective knapsack</a></li><li><a class="tocitem" href="../../../tutorials/linear/multi_objective_project_planning/">Multi-objective project planning</a></li><li><a class="tocitem" href="../../../tutorials/linear/sudoku/">Sudoku</a></li><li><a class="tocitem" href="../../../tutorials/linear/n-queens/">N-Queens</a></li><li><a class="tocitem" href="../../../tutorials/linear/constraint_programming/">Constraint programming</a></li><li><a class="tocitem" href="../../../tutorials/linear/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../tutorials/linear/lp_sensitivity/">Sensitivity analysis of a linear program</a></li><li><a class="tocitem" href="../../../tutorials/linear/basis/">Basis matrices</a></li><li><a class="tocitem" href="../../../tutorials/linear/mip_duality/">Computing the duals of a mixed-integer program</a></li><li><a class="tocitem" href="../../../tutorials/linear/multiple_solutions/">Finding multiple feasible solutions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Nonlinear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/nonlinear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/simple_examples/">Simple examples</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/tips_and_tricks/">User-defined operators with vector outputs</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/operator_ad/">Automatic differentiation of user-defined operators</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/user_defined_hessians/">User-defined Hessians</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/nested_problems/">Nested optimization problems</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/querying_hessians/">Computing Hessians</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/complementarity/">Example: mixed complementarity problems</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/classifiers/">Example: classification problems</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/portfolio/">Example: portfolio optimization</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/rocket_control/">Example: nonlinear optimal control of a rocket</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/space_shuttle_reentry_trajectory/">Example: optimal control for a Space Shuttle reentry trajectory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Conic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/conic/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../tutorials/conic/tips_and_tricks/">Modeling with cones</a></li><li><a class="tocitem" href="../../../tutorials/conic/dualization/">Dualization</a></li><li><a class="tocitem" href="../../../tutorials/conic/arbitrary_precision/">Arbitrary precision arithmetic</a></li><li><a class="tocitem" href="../../../tutorials/conic/start_values/">Primal and dual warm-starts</a></li><li><a class="tocitem" href="../../../tutorials/conic/simple_examples/">Simple semidefinite programming examples</a></li><li><a class="tocitem" href="../../../tutorials/conic/chordal_decomposition/">Chordal decomposition</a></li><li><a class="tocitem" href="../../../tutorials/conic/logistic_regression/">Example: logistic regression</a></li><li><a class="tocitem" href="../../../tutorials/conic/experiment_design/">Example: experiment design</a></li><li><a class="tocitem" href="../../../tutorials/conic/min_ellipse/">Example: minimal ellipses</a></li><li><a class="tocitem" href="../../../tutorials/conic/ellipse_approx/">Example: ellipsoid approximation</a></li><li><a class="tocitem" href="../../../tutorials/conic/ellipse_fitting/">Example: fitting of circles and ellipses</a></li><li><a class="tocitem" href="../../../tutorials/conic/quantum_discrimination/">Example: quantum state discrimination</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/algorithms/benders_decomposition/">Benders decomposition</a></li><li><a class="tocitem" href="../../../tutorials/algorithms/cutting_stock_column_generation/">Column generation</a></li><li><a class="tocitem" href="../../../tutorials/algorithms/tsp_lazy_constraints/">Traveling Salesperson Problem</a></li><li><a class="tocitem" href="../../../tutorials/algorithms/rolling_horizon/">Rolling horizon problems</a></li><li><a class="tocitem" href="../../../tutorials/algorithms/parallelism/">Parallelism</a></li><li><a class="tocitem" href="../../../tutorials/algorithms/pdhg/">Writing a solver interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-7" type="checkbox"/><label class="tocitem" for="menuitem-2-7"><span class="docs-label">Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/applications/power_systems/">Power Systems</a></li><li><a class="tocitem" href="../../../tutorials/applications/optimal_power_flow/">Optimal power flow</a></li><li><a class="tocitem" href="../../../tutorials/applications/web_app/">Serving web apps</a></li><li><a class="tocitem" href="../../../tutorials/applications/two_stage_stochastic/">Two-stage stochastic programs</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../manual/models/">Models</a></li><li><a class="tocitem" href="../../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../manual/expressions/">Expressions</a></li><li><a class="tocitem" href="../../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../../manual/containers/">Containers</a></li><li><a class="tocitem" href="../../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../manual/callbacks/">Solver-independent Callbacks</a></li><li><a class="tocitem" href="../../../manual/complex/">Complex number support</a></li><li><a class="tocitem" href="../../../manual/nonlinear/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../../manual/nlp/">Nonlinear Modeling (Legacy)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../api/JuMP/">JuMP</a></li><li><a class="tocitem" href="../../../api/JuMP.Containers/">JuMP.Containers</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Background Information</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../background/algebraic_modeling_languages/">Algebraic modeling languages</a></li><li><a class="tocitem" href="../../../background/bibliography/">Bibliography</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../developers/contributing/">Contributing</a></li><li><a class="tocitem" href="../../../developers/extensions/">Extensions</a></li><li><a class="tocitem" href="../../../developers/custom_solver_binaries/">Custom binaries</a></li><li><a class="tocitem" href="../../../developers/style/">Style Guide</a></li><li><a class="tocitem" href="../../../developers/conventions/">Conventions</a></li><li><a class="tocitem" href="../../../developers/roadmap/">Roadmap</a></li><li><a class="tocitem" href="../../../developers/checklists/">Checklists</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../packages/solvers/">Introduction</a></li><li><a class="tocitem" href="../../../packages/AmplNLWriter/">jump-dev/AmplNLWriter.jl</a></li><li><a class="tocitem" href="../../../packages/BARON/">jump-dev/BARON.jl</a></li><li><a class="tocitem" href="../../../packages/CPLEX/">jump-dev/CPLEX.jl</a></li><li><a class="tocitem" href="../../../packages/CSDP/">jump-dev/CSDP.jl</a></li><li><a class="tocitem" href="../../../packages/Cbc/">jump-dev/Cbc.jl</a></li><li><a class="tocitem" href="../../../packages/Clp/">jump-dev/Clp.jl</a></li><li><a class="tocitem" href="../../../packages/Dualization/">jump-dev/Dualization.jl</a></li><li><a class="tocitem" href="../../../packages/ECOS/">jump-dev/ECOS.jl</a></li><li><a class="tocitem" href="../../../packages/GLPK/">jump-dev/GLPK.jl</a></li><li><a class="tocitem" href="../../../packages/Gurobi/">jump-dev/Gurobi.jl</a></li><li><a class="tocitem" href="../../../packages/HiGHS/">jump-dev/HiGHS.jl</a></li><li><a class="tocitem" href="../../../packages/Hypatia/">jump-dev/Hypatia.jl</a></li><li><a class="tocitem" href="../../../packages/Ipopt/">jump-dev/Ipopt.jl</a></li><li><a class="tocitem" href="../../../packages/KNITRO/">jump-dev/KNITRO.jl</a></li><li><a class="tocitem" href="../../../packages/MathOptAnalyzer/">jump-dev/MathOptAnalyzer.jl</a></li><li><a class="tocitem" href="../../../packages/MathOptIIS/">jump-dev/MathOptIIS.jl</a></li><li><a class="tocitem" href="../../../packages/MiniZinc/">jump-dev/MiniZinc.jl</a></li><li><a class="tocitem" href="../../../packages/MosekTools/">jump-dev/MosekTools.jl</a></li><li><a class="tocitem" href="../../../packages/MultiObjectiveAlgorithms/">jump-dev/MultiObjectiveAlgorithms.jl</a></li><li><a class="tocitem" href="../../../packages/NEOSServer/">jump-dev/NEOSServer.jl</a></li><li><a class="tocitem" href="../../../packages/NLopt/">jump-dev/NLopt.jl</a></li><li><a class="tocitem" href="../../../packages/Pajarito/">jump-dev/Pajarito.jl</a></li><li><a class="tocitem" href="../../../packages/Pavito/">jump-dev/Pavito.jl</a></li><li><a class="tocitem" href="../../../packages/SCS/">jump-dev/SCS.jl</a></li><li><a class="tocitem" href="../../../packages/SDPA/">jump-dev/SDPA.jl</a></li><li><a class="tocitem" href="../../../packages/SDPLR/">jump-dev/SDPLR.jl</a></li><li><a class="tocitem" href="../../../packages/SDPNAL/">jump-dev/SDPNAL.jl</a></li><li><a class="tocitem" href="../../../packages/SDPT3/">jump-dev/SDPT3.jl</a></li><li><a class="tocitem" href="../../../packages/SeDuMi/">jump-dev/SeDuMi.jl</a></li><li><a class="tocitem" href="../../../packages/Xpress/">jump-dev/Xpress.jl</a></li><li><a class="tocitem" href="../../../packages/cuOpt/">jump-dev/cuOpt.jl</a></li><li><a class="tocitem" href="../../../packages/COPT/">COPT-Public/COPT.jl</a></li><li><a class="tocitem" href="../../../packages/GAMS/">GAMS-dev/GAMS.jl</a></li><li><a class="tocitem" href="../../../packages/Manopt/">JuliaManifolds/Manopt.jl</a></li><li><a class="tocitem" href="../../../packages/Optim/">JuliaNLSolvers/Optim.jl</a></li><li><a class="tocitem" href="../../../packages/CDDLib/">JuliaPolyhedra/CDDLib.jl</a></li><li><a class="tocitem" href="../../../packages/Percival/">JuliaSmoothOptimizers/Percival.jl</a></li><li><a class="tocitem" href="../../../packages/MAiNGO/">MAiNGO-github/MAiNGO.jl</a></li><li><a class="tocitem" href="../../../packages/MadNLP/">MadNLP/MadNLP.jl</a></li><li><a class="tocitem" href="../../../packages/EAGO/">PSORLab/EAGO.jl</a></li><li><a class="tocitem" href="../../../packages/PATHSolver/">chkwon/PATHSolver.jl</a></li><li><a class="tocitem" href="../../../packages/Uno/">cvanaret/Uno</a></li><li><a class="tocitem" href="../../../packages/DAQP/">darnstrom/DAQP.jl</a></li><li><a class="tocitem" href="../../../packages/Tulip/">ds4dm/Tulip.jl</a></li><li><a class="tocitem" href="../../../packages/CATrustRegionMethod/">fadihamad94/CATrustRegionMethod.jl</a></li><li><a class="tocitem" href="../../../packages/Loraine/">kocvara/Loraine.jl</a></li><li><a class="tocitem" href="../../../packages/Alpine/">lanl-ansi/Alpine.jl</a></li><li><a class="tocitem" href="../../../packages/Juniper/">lanl-ansi/Juniper.jl</a></li><li><a class="tocitem" href="../../../packages/ProxSDP/">mariohsouto/ProxSDP.jl</a></li><li><a class="tocitem" href="../../../packages/OSQP/">osqp/OSQP.jl</a></li><li><a class="tocitem" href="../../../packages/CDCS/">oxfordcontrol/CDCS.jl</a></li><li><a class="tocitem" href="../../../packages/COSMO/">oxfordcontrol/COSMO.jl</a></li><li><a class="tocitem" href="../../../packages/Clarabel/">oxfordcontrol/Clarabel.jl</a></li><li><a class="tocitem" href="../../../packages/MathOptChordalDecomposition/">samuelsonric/MathOptChordalDecomposition.jl</a></li><li><a class="tocitem" href="../../../packages/SCIP/">scipopt/SCIP.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Extensions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../extensions/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../packages/DiffOpt/">jump-dev/DiffOpt.jl</a></li><li><a class="tocitem" href="../../../packages/ParametricOptInterface/">jump-dev/ParametricOptInterface.jl</a></li><li><a class="tocitem" href="../../../packages/PiecewiseLinearOpt/">jump-dev/PiecewiseLinearOpt.jl</a></li><li><a class="tocitem" href="../../../packages/PolyJuMP/">jump-dev/PolyJuMP.jl</a></li><li><a class="tocitem" href="../../../packages/SumOfSquares/">jump-dev/SumOfSquares.jl</a></li><li><a class="tocitem" href="../../../packages/DisjunctiveProgramming/">hdavid16/DisjunctiveProgramming.jl</a></li><li><a class="tocitem" href="../../../packages/InfiniteOpt/">infiniteopt/InfiniteOpt.jl</a></li><li><a class="tocitem" href="../../../packages/BilevelJuMP/">joaquimg/BilevelJuMP.jl</a></li><li><a class="tocitem" href="../../../packages/MathOptAI/">lanl-ansi/MathOptAI.jl</a></li><li><a class="tocitem" href="../../../packages/MathOptSymbolicAD/">lanl-ansi/MathOptSymbolicAD.jl</a></li><li><a class="tocitem" href="../../../packages/SDDP/">odow/SDDP.jl</a></li><li><a class="tocitem" href="../../../packages/Plasmo/">plasmo-dev/Plasmo.jl</a></li><li><a class="tocitem" href="../../../extensions/DimensionalData/">rafaqz/DimensionalData.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox" checked/><label class="tocitem" for="menuitem-9"><span class="docs-label">MathOptInterface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-1" type="checkbox"/><label class="tocitem" for="menuitem-9-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../background/motivation/">Motivation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-2" type="checkbox"/><label class="tocitem" for="menuitem-9-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/example/">Solving a problem using MathOptInterface</a></li><li><a class="tocitem" href="../../tutorials/implementing/">Implementing a solver interface</a></li><li><a class="tocitem" href="../../tutorials/mathprogbase/">Transitioning from MathProgBase</a></li><li><a class="tocitem" href="../../tutorials/bridging_constraint/">Implementing a constraint bridge</a></li><li><a class="tocitem" href="../../tutorials/manipulating_expressions/">Manipulating expressions</a></li><li><a class="tocitem" href="../../tutorials/latency/">Latency</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-3" type="checkbox"/><label class="tocitem" for="menuitem-9-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/standard_form/">Standard form problem</a></li><li><a class="tocitem" href="../../manual/models/">Models</a></li><li><a class="tocitem" href="../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../manual/modification/">Problem modification</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-4" type="checkbox"/><label class="tocitem" for="menuitem-9-4"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/duality/">Duality</a></li><li><a class="tocitem" href="../../background/infeasibility_certificates/">Infeasibility certificates</a></li><li><a class="tocitem" href="../../background/naming_conventions/">Naming conventions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-5" type="checkbox" checked/><label class="tocitem" for="menuitem-9-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../standard_form/">Standard form</a></li><li class="is-active"><a class="tocitem" href>Models</a><ul class="internal"><li><a class="tocitem" href="#Attribute-interface"><span>Attribute interface</span></a></li><li><a class="tocitem" href="#Model-interface"><span>Model interface</span></a></li><li><a class="tocitem" href="#Model-attributes"><span>Model attributes</span></a></li><li><a class="tocitem" href="#Optimizer-interface"><span>Optimizer interface</span></a></li><li><a class="tocitem" href="#Optimizer-attributes"><span>Optimizer attributes</span></a></li></ul></li><li><a class="tocitem" href="../variables/">Variables</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../modification/">Modifications</a></li><li><a class="tocitem" href="../nonlinear/">Nonlinear programming</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../errors/">Errors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-6-1" type="checkbox"/><label class="tocitem" for="menuitem-9-6-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-2" type="checkbox"/><label class="tocitem" for="menuitem-9-6-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Bridges/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Bridges/implementation/">Implementation</a></li><li><a class="tocitem" href="../../submodules/Bridges/list_of_bridges/">List of bridges</a></li><li><a class="tocitem" href="../../submodules/Bridges/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-3" type="checkbox"/><label class="tocitem" for="menuitem-9-6-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/FileFormats/reference/">API Reference</a></li><li><a class="tocitem" href="../../submodules/FileFormats/LP/">The LP file format</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-4" type="checkbox"/><label class="tocitem" for="menuitem-9-6-4"><span class="docs-label">Nonlinear</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Nonlinear/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Nonlinear/SymbolicAD/">SymbolicAD</a></li><li><a class="tocitem" href="../../submodules/Nonlinear/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-5" type="checkbox"/><label class="tocitem" for="menuitem-9-6-5"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Utilities/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Utilities/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6-6"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Test/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Test/reference/">API Reference</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../developer/checklists/">Checklists</a></li><li><a class="tocitem" href="../../developer/contributing/">Contributing</a></li><li><a class="tocitem" href="../../developer/defining_a_new_set/">Defining a new set</a></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release notes</a></li></ul></li><li><a class="tocitem" href="../../../release_notes/">Release notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">MathOptInterface</a></li><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/docs/src/reference/models.md" title="View source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h1><h2 id="Attribute-interface"><a class="docs-heading-anchor" href="#Attribute-interface">Attribute interface</a><a id="Attribute-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Attribute-interface" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptInterface.is_set_by_optimize"><a class="docstring-binding" href="#MathOptInterface.is_set_by_optimize"><code>MathOptInterface.is_set_by_optimize</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_set_by_optimize(::AnyAttribute)</code></pre><p>Return a <code>Bool</code> indicating whether the value of the attribute is set during an <a href="../../../api/JuMP/#optimize!"><code>optimize!</code></a> call, that is, the attribute is used to query the result of the optimization.</p><p>If an attribute can be set by the user, define <a href="#MathOptInterface.is_copyable"><code>is_copyable</code></a> instead.</p><p>An attribute cannot be both <a href="#MathOptInterface.is_copyable"><code>is_copyable</code></a> and <a href="#MathOptInterface.is_set_by_optimize"><code>is_set_by_optimize</code></a>.</p><p><strong>Default fallback</strong></p><p>This function returns <code>false</code> by default so it should be implemented for attributes that are set by <a href="../../../api/JuMP/#optimize!"><code>optimize!</code></a>.</p><p><strong>Undefined behavior</strong></p><p>Querying the value of the attribute that <a href="#MathOptInterface.is_set_by_optimize"><code>is_set_by_optimize</code></a> before a call to <a href="../../../api/JuMP/#optimize!"><code>optimize!</code></a> is undefined and depends on solver-specific behavior.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; MOI.is_set_by_optimize(MOI.ObjectiveValue())
true

julia&gt; MOI.is_set_by_optimize(MOI.VariableName())
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3341-L3372">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.is_copyable"><a class="docstring-binding" href="#MathOptInterface.is_copyable"><code>MathOptInterface.is_copyable</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_copyable(::AnyAttribute)</code></pre><p>Return a <code>Bool</code> indicating whether the value of the attribute may be copied during <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> using <a href="#MathOptInterface.set"><code>set</code></a>.</p><p>If an attribute <code>is_copyable</code>, then it cannot be modified by the optimizer, and <a href="#MathOptInterface.get"><code>get</code></a> must always return the value that was <a href="#MathOptInterface.set"><code>set</code></a> by the user.</p><p>If an attribute is the result of an optimization, define <a href="#MathOptInterface.is_set_by_optimize"><code>is_set_by_optimize</code></a> instead.</p><p>An attribute cannot be both <a href="#MathOptInterface.is_set_by_optimize"><code>is_set_by_optimize</code></a> and <code>is_copyable</code>.</p><p><strong>Default fallback</strong></p><p>By default <code>is_copyable(attr)</code> returns <code>!is_set_by_optimize(attr)</code>, which is most probably <code>true</code>.</p><p>If an attribute should not be copied, define <code>is_copyable(::MyAttribute) = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3405-L3425">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.get"><a class="docstring-binding" href="#MathOptInterface.get"><code>MathOptInterface.get</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">MOI.get(b::AbstractBridge, ::MOI.NumberOfVariables)::Int64</code></pre><p>Return the number of variables created by the bridge <code>b</code> in the model.</p><p>See also <a href="#MathOptInterface.NumberOfConstraints"><code>MOI.NumberOfConstraints</code></a>.</p><p><strong>Implementation notes</strong></p><ul><li>There is a default fallback, so you need only implement this if the bridge adds new variables.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/Bridges/bridge.jl#L42-L53">source</a></section><section><div><pre><code class="language-julia hljs">MOI.get(b::AbstractBridge, ::MOI.ListOfVariableIndices)</code></pre><p>Return the list of variables created by the bridge <code>b</code>.</p><p>See also <a href="#MathOptInterface.ListOfVariableIndices"><code>MOI.ListOfVariableIndices</code></a>.</p><p><strong>Implementation notes</strong></p><ul><li>There is a default fallback, so you need only implement this if the bridge adds new variables.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/Bridges/bridge.jl#L56-L67">source</a></section><section><div><pre><code class="language-julia hljs">MOI.get(b::AbstractBridge, ::MOI.NumberOfConstraints{F,S})::Int64 where {F,S}</code></pre><p>Return the number of constraints of the type <code>F</code>-in-<code>S</code> created by the bridge <code>b</code>.</p><p>See also <a href="#MathOptInterface.NumberOfConstraints"><code>MOI.NumberOfConstraints</code></a>.</p><p><strong>Implementation notes</strong></p><ul><li>There is a default fallback, so you need only implement this for the constraint types returned by <a href="../../submodules/Bridges/reference/#MathOptInterface.Bridges.added_constraint_types"><code>added_constraint_types</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/Bridges/bridge.jl#L70-L82">source</a></section><section><div><pre><code class="language-julia hljs">MOI.get(b::AbstractBridge, ::MOI.ListOfConstraintIndices{F,S}) where {F,S}</code></pre><p>Return a  <code>Vector{ConstraintIndex{F,S}}</code> with indices of all constraints of type <code>F</code>-in-<code>S</code> created by the bride <code>b</code>.</p><p>See also <a href="#MathOptInterface.ListOfConstraintIndices"><code>MOI.ListOfConstraintIndices</code></a>.</p><p><strong>Implementation notes</strong></p><ul><li>There is a default fallback, so you need only implement this for the constraint types returned by <a href="../../submodules/Bridges/reference/#MathOptInterface.Bridges.added_constraint_types"><code>added_constraint_types</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/Bridges/bridge.jl#L85-L97">source</a></section><section><div><pre><code class="language-julia hljs">function MOI.get(
    model::MOI.ModelLike,
    attr::MOI.AbstractConstraintAttribute,
    bridge::AbstractBridge,
)</code></pre><p>Return the value of the attribute <code>attr</code> of the model <code>model</code> for the constraint bridged by <code>bridge</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/Bridges/bridge.jl#L133-L142">source</a></section><section><div><pre><code class="language-julia hljs">get(model::GenericModel, attr::MathOptInterface.AbstractOptimizerAttribute)</code></pre><p>Return the value of the attribute <code>attr</code> from the model&#39;s MOI backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/c6c5167f21d42dc02d1920ae53d7576d99e7967c/src/optimizer_interface.jl#L1133-L1137">source</a></section><section><div><pre><code class="language-julia hljs">get(model::GenericModel, attr::MathOptInterface.AbstractModelAttribute)</code></pre><p>Return the value of the attribute <code>attr</code> from the model&#39;s MOI backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/c6c5167f21d42dc02d1920ae53d7576d99e7967c/src/optimizer_interface.jl#L1202-L1206">source</a></section><section><div><pre><code class="language-julia hljs">get(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute)</code></pre><p>Return an attribute <code>attr</code> of the optimizer <code>optimizer</code>.</p><pre><code class="language-julia hljs">get(model::ModelLike, attr::AbstractModelAttribute)</code></pre><p>Return an attribute <code>attr</code> of the model <code>model</code>.</p><pre><code class="language-julia hljs">get(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex)</code></pre><p>If the attribute <code>attr</code> is set for the variable <code>v</code> in the model <code>model</code>, return its value, return <code>nothing</code> otherwise. If the attribute <code>attr</code> is not supported by <code>model</code> then an error should be thrown instead of returning <code>nothing</code>.</p><pre><code class="language-julia hljs">get(model::ModelLike, attr::AbstractVariableAttribute, v::Vector{VariableIndex})</code></pre><p>Return a vector of attributes corresponding to each variable in the collection <code>v</code> in the model <code>model</code>.</p><pre><code class="language-julia hljs">get(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex)</code></pre><p>If the attribute <code>attr</code> is set for the constraint <code>c</code> in the model <code>model</code>, return its value, return <code>nothing</code> otherwise. If the attribute <code>attr</code> is not supported by <code>model</code> then an error should be thrown instead of returning <code>nothing</code>.</p><pre><code class="language-julia hljs">get(
    model::ModelLike,
    attr::AbstractConstraintAttribute,
    c::Vector{ConstraintIndex{F,S}},
) where {F,S}</code></pre><p>Return a vector of attributes corresponding to each constraint in the collection <code>c</code> in the model <code>model</code>.</p><pre><code class="language-julia hljs">get(model::ModelLike, ::Type{VariableIndex}, name::String)</code></pre><p>If a variable with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. Errors if two variables have the same name.</p><pre><code class="language-julia hljs">get(
    model::ModelLike,
    ::Type{ConstraintIndex{F,S}},
    name::String,
) where {F,S}</code></pre><p>If an <code>F</code>-in-<code>S</code> constraint with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. Errors if two constraints have the same name.</p><pre><code class="language-julia hljs">get(model::ModelLike, ::Type{ConstraintIndex}, name::String)</code></pre><p>If <em>any</em> constraint with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. This version is available for convenience but may incur a performance penalty because it is not type stable. Errors if two constraints have the same name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L356-L430">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.get!"><a class="docstring-binding" href="#MathOptInterface.get!"><code>MathOptInterface.get!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get!(output, model::ModelLike, args...)</code></pre><p>An in-place version of <a href="#MathOptInterface.get"><code>get</code></a>.</p><p>The signature matches that of <a href="#MathOptInterface.get"><code>get</code></a> except that the result is placed in the vector <code>output</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L494-L501">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.set"><a class="docstring-binding" href="#MathOptInterface.set"><code>MathOptInterface.set</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function MOI.set(
    model::MOI.ModelLike,
    attr::MOI.AbstractConstraintAttribute,
    bridge::AbstractBridge,
    value,
)</code></pre><p>Set the value of the attribute <code>attr</code> of the model <code>model</code> for the constraint bridged by <code>bridge</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/Bridges/bridge.jl#L162-L172">source</a></section><section><div><pre><code class="language-julia hljs">set(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the optimizer <code>optimizer</code>.</p><pre><code class="language-julia hljs">set(model::ModelLike, attr::AbstractModelAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the model <code>model</code>.</p><pre><code class="language-julia hljs">set(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of variable <code>v</code> in model <code>model</code>.</p><pre><code class="language-julia hljs">set(
    model::ModelLike,
    attr::AbstractVariableAttribute,
    v::Vector{VariableIndex},
    vector_of_values,
)</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each variable in the collection <code>v</code> in model <code>model</code>.</p><pre><code class="language-julia hljs">set(
    model::ModelLike,
    attr::AbstractConstraintAttribute,
    c::ConstraintIndex,
    value,
)</code></pre><p>Assign a value to the attribute <code>attr</code> of constraint <code>c</code> in model <code>model</code>.</p><pre><code class="language-julia hljs">set(
    model::ModelLike,
    attr::AbstractConstraintAttribute,
    c::Vector{ConstraintIndex{F,S}},
    vector_of_values,
) where {F,S}</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each constraint in the collection <code>c</code> in model <code>model</code>.</p><p>An <a href="../errors/#MathOptInterface.UnsupportedAttribute"><code>UnsupportedAttribute</code></a> error is thrown if <code>model</code> does not support the attribute <code>attr</code> (see <a href="#MathOptInterface.supports"><code>supports</code></a>) and a <a href="../errors/#MathOptInterface.SetAttributeNotAllowed"><code>SetAttributeNotAllowed</code></a> error is thrown if it supports the attribute <code>attr</code> but it cannot be set.</p><pre><code class="language-julia hljs">set(
    model::ModelLike,
    ::ConstraintSet,
    c::ConstraintIndex{F,S},
    set::S,
) where {F,S}</code></pre><p>Change the set of constraint <code>c</code> to the new set <code>set</code> which should be of the same type as the original set.</p><pre><code class="language-julia hljs">set(
    model::ModelLike,
    ::ConstraintFunction,
    c::ConstraintIndex{F,S},
    func::F,
) where {F,S}</code></pre><p>Replace the function in constraint <code>c</code> with <code>func</code>. <code>F</code> must match the original function type used to define the constraint.</p><div class="admonition is-info" id="Note-44fa3114e383a959"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-44fa3114e383a959" title="Permalink"></a></header><div class="admonition-body"><p>Setting the constraint function is not allowed if <code>F</code> is <a href="../standard_form/#MathOptInterface.VariableIndex"><code>VariableIndex</code></a>; a <a href="../errors/#MathOptInterface.SettingVariableIndexNotAllowed"><code>SettingVariableIndexNotAllowed</code></a> error is thrown instead. This is because, it would require changing the index <code>c</code> since the index of <a href="../standard_form/#MathOptInterface.VariableIndex"><code>VariableIndex</code></a> constraints must be the same as the index of the variable.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L507-L593">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.supports"><a class="docstring-binding" href="#MathOptInterface.supports"><code>MathOptInterface.supports</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">MOI.supports(
    model::MOI.ModelLike,
    attr::MOI.AbstractConstraintAttribute,
    BT::Type{&lt;:AbstractBridge},
)</code></pre><p>Return a <code>Bool</code> indicating whether <code>BT</code> supports setting <code>attr</code> to <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/Bridges/bridge.jl#L105-L113">source</a></section><section><div><pre><code class="language-julia hljs">supports(model::ModelLike, sub::AbstractSubmittable)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the submittable <code>sub</code>.</p><pre><code class="language-julia hljs">supports(model::ModelLike, attr::AbstractOptimizerAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the optimizer attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> shows a warning in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfOptimizerAttributesSet"><code>ListOfOptimizerAttributesSet</code></a> of <code>src</code>; see <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> for more details on how unsupported optimizer attributes are handled in copy.</p><pre><code class="language-julia hljs">supports(model::ModelLike, attr::AbstractModelAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the model attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfModelAttributesSet"><code>ListOfModelAttributesSet</code></a> of <code>src</code>.</p><pre><code class="language-julia hljs">supports(
    model::ModelLike,
    attr::AbstractVariableAttribute,
    ::Type{VariableIndex},
)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the variable attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfVariableAttributesSet"><code>ListOfVariableAttributesSet</code></a> of <code>src</code>.</p><pre><code class="language-julia hljs">supports(
    model::ModelLike,
    attr::AbstractConstraintAttribute,
    ::Type{ConstraintIndex{F,S}},
)::Bool where {F,S}</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the constraint attribute <code>attr</code> applied to an <code>F</code>-in-<code>S</code> constraint. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfConstraintAttributesSet"><code>ListOfConstraintAttributesSet</code></a> of <code>src</code>.</p><p>For all five methods, if the attribute is only not supported in specific circumstances, it should still return <code>true</code>.</p><p>Note that <code>supports</code> is only defined for attributes for which <a href="#MathOptInterface.is_copyable"><code>is_copyable</code></a> returns <code>true</code> as other attributes do not appear in the list of attributes set obtained by <code>ListOfXXXAttributesSet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L262-L316">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.attribute_value_type"><a class="docstring-binding" href="#MathOptInterface.attribute_value_type"><code>MathOptInterface.attribute_value_type</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">attribute_value_type(attr::AnyAttribute)</code></pre><p>Given an attribute <code>attr</code>, return the type of value expected by <a href="#MathOptInterface.get"><code>get</code></a>, or returned by <a href="#MathOptInterface.set"><code>set</code></a>.</p><p><strong>Notes</strong></p><ul><li>Only implement this if it make sense to do so. If un-implemented, the default is <code>Any</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L59-L69">source</a></section></details></article><h2 id="Model-interface"><a class="docs-heading-anchor" href="#Model-interface">Model interface</a><a id="Model-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Model-interface" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptInterface.ModelLike"><a class="docstring-binding" href="#MathOptInterface.ModelLike"><code>MathOptInterface.ModelLike</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ModelLike</code></pre><p>Abstract supertype for objects that implement the &quot;Model&quot; interface for defining an optimization problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/MathOptInterface.jl#L11-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.is_empty"><a class="docstring-binding" href="#MathOptInterface.is_empty"><code>MathOptInterface.is_empty</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_empty(model::ModelLike)</code></pre><p>Returns <code>false</code> if the <code>model</code> has any model attribute set or has any variables or constraints.</p><p>Note that an empty model can have optimizer attributes set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/MathOptInterface.jl#L252-L259">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.empty!"><a class="docstring-binding" href="#MathOptInterface.empty!"><code>MathOptInterface.empty!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">empty!(model::ModelLike)</code></pre><p>Empty the model, that is, remove all variables, constraints and model attributes but not optimizer attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/MathOptInterface.jl#L262-L267">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.write_to_file"><a class="docstring-binding" href="#MathOptInterface.write_to_file"><code>MathOptInterface.write_to_file</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">write_to_file(model::ModelLike, filename::String; kwargs...)</code></pre><p>Write the current model to the file at <code>filename</code>.</p><p>Supported file types depend on the model type.</p><p>Additional keyword arguments are passed to the <code>Model</code> constructor of the relevant file format. See, for example, <a href="../../submodules/FileFormats/reference/#MathOptInterface.FileFormats.LP.Model"><code>FileFormats.LP.Model</code></a> and <a href="../../submodules/FileFormats/reference/#MathOptInterface.FileFormats.MPS.Model"><code>FileFormats.MPS.Model</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = MOI.Utilities.Model{Int}();

julia&gt; x, _ = MOI.add_constrained_variable(model, MOI.Interval(2, 3));

julia&gt; MOI.set(model, MOI.VariableName(), x, &quot;x&quot;);

julia&gt; filename = joinpath(tempdir(), &quot;model.lp&quot;);

julia&gt; MOI.write_to_file(model, filename; coefficient_type = Int);

julia&gt; print(read(filename, String))
minimize
obj:
subject to
Bounds
2 &lt;= x &lt;= 3
End</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/MathOptInterface.jl#L153-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.read_from_file"><a class="docstring-binding" href="#MathOptInterface.read_from_file"><code>MathOptInterface.read_from_file</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">read_from_file(model::ModelLike, filename::String; kwargs...)</code></pre><p>Read the file <code>filename</code> into the model <code>model</code>. If <code>model</code> is non-empty, this may throw an error.</p><p>Supported file types depend on the model type.</p><p>Additional keyword arguments are passed to the <code>Model</code> constructor of the relevant file format. See, for example, <a href="../../submodules/FileFormats/reference/#MathOptInterface.FileFormats.LP.Model"><code>FileFormats.LP.Model</code></a> and <a href="../../submodules/FileFormats/reference/#MathOptInterface.FileFormats.MPS.Model"><code>FileFormats.MPS.Model</code></a>.</p><p><strong>Note</strong></p><p>Once the contents of the file are loaded into the model, you can query the variables via <code>MOI.get(model, MOI.ListOfVariableIndices())</code>. However, some filetypes, such as LP files, do not maintain an explicit ordering of the variables. Therefore, the returned list may be in an arbitrary order.</p><p>To avoid depending on the order of the indices, look up each variable index by name using <code>MOI.get(model, MOI.VariableIndex, &quot;name&quot;)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = MOI.Utilities.Model{Int}();

julia&gt; x, _ = MOI.add_constrained_variable(model, MOI.GreaterThan(2));

julia&gt; MOI.set(model, MOI.VariableName(), x, &quot;x&quot;);

julia&gt; filename = joinpath(tempdir(), &quot;model.lp&quot;);

julia&gt; MOI.write_to_file(model, filename; coefficient_type = Int);

julia&gt; new_model = MOI.Utilities.Model{Int}();

julia&gt; MOI.read_from_file(new_model, filename; coefficient_type = Int);

julia&gt; print(new_model)
Minimize ScalarAffineFunction{Int64}:
 (0)

Subject to:

VariableIndex-in-GreaterThan{Int64}
 x &gt;= (2)

julia&gt; MOI.get(new_model, MOI.VariableIndex, &quot;x&quot;)
MOI.VariableIndex(1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/MathOptInterface.jl#L193-L244">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.supports_incremental_interface"><a class="docstring-binding" href="#MathOptInterface.supports_incremental_interface"><code>MathOptInterface.supports_incremental_interface</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">supports_incremental_interface(model::ModelLike)</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports building incrementally via <a href="../../../api/JuMP/#add_variable"><code>add_variable</code></a> and <a href="../../../api/JuMP/#add_constraint"><code>add_constraint</code></a>.</p><p>The main purpose of this function is to determine whether a model can be loaded into <code>model</code> incrementally or whether it should be cached and copied at once instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/MathOptInterface.jl#L270-L279">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.copy_to"><a class="docstring-binding" href="#MathOptInterface.copy_to"><code>MathOptInterface.copy_to</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">copy_to(dest::ModelLike, src::ModelLike)::IndexMap</code></pre><p>Copy the model from <code>src</code> into <code>dest</code>.</p><p>The target <code>dest</code> is emptied, and all previous indices to variables and constraints in <code>dest</code> are invalidated.</p><p>Returns an <a href="#MathOptInterface.IndexMap"><code>IndexMap</code></a> object that translates variable and constraint indices from the <code>src</code> model to the corresponding indices in the <code>dest</code> model.</p><p><strong>Notes</strong></p><ul><li>If a constraint that in <code>src</code> is not supported by <code>dest</code>, then an <a href="../errors/#MathOptInterface.UnsupportedConstraint"><code>UnsupportedConstraint</code></a> error is thrown.</li><li>If an <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a>, <a href="../variables/#MathOptInterface.AbstractVariableAttribute"><code>AbstractVariableAttribute</code></a>, or <a href="../constraints/#MathOptInterface.AbstractConstraintAttribute"><code>AbstractConstraintAttribute</code></a> is set in <code>src</code> but not supported by <code>dest</code>, then an <a href="../errors/#MathOptInterface.UnsupportedAttribute"><code>UnsupportedAttribute</code></a> error is thrown.</li></ul><p><a href="#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a>s are <em>not</em> copied  to the <code>dest</code> model.</p><p><strong>IndexMap</strong></p><p>Implementations of <code>copy_to</code> must return an <a href="#MathOptInterface.IndexMap"><code>IndexMap</code></a>. For technical reasons, this type is defined in the Utilities submodule as <code>MOI.Utilities.IndexMap</code>. However, since it is an integral part of the MOI API, we provide <code>MOI.IndexMap</code> as an alias.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Given empty `ModelLike` objects `src` and `dest`.

x = add_variable(src)

is_valid(src, x)   # true
is_valid(dest, x)  # false (`dest` has no variables)

index_map = copy_to(dest, src)
is_valid(dest, x) # false (unless index_map[x] == x)
is_valid(dest, index_map[x]) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/MathOptInterface.jl#L282-L324">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.IndexMap"><a class="docstring-binding" href="#MathOptInterface.IndexMap"><code>MathOptInterface.IndexMap</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IndexMap()</code></pre><p>The dictionary-like object returned by <a href="#MathOptInterface.copy_to"><code>copy_to</code></a>.</p><p><strong>IndexMap</strong></p><p>Implementations of <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> must return an <a href="#MathOptInterface.IndexMap"><code>IndexMap</code></a>. For technical reasons, the <code>IndexMap</code> type is defined in the Utilities submodule as <code>MOI.Utilities.IndexMap</code>. However, since it is an integral part of the MOI API, we provide this <code>MOI.IndexMap</code> as an alias.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/MathOptInterface.jl#L444-L455">source</a></section></details></article><h2 id="Model-attributes"><a class="docs-heading-anchor" href="#Model-attributes">Model attributes</a><a id="Model-attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Model-attributes" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptInterface.AbstractModelAttribute"><a class="docstring-binding" href="#MathOptInterface.AbstractModelAttribute"><code>MathOptInterface.AbstractModelAttribute</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractModelAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L22-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.Name"><a class="docstring-binding" href="#MathOptInterface.Name"><code>MathOptInterface.Name</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Name()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the string identifying the model.</p><p>It has a default value of <code>&quot;&quot;</code> if not set.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.Name)::String
MOI.set(::Optimizer, ::MOI.Name, ::String)::Nothing
MOI.supports(::Optimizer, ::MOI.Name)::Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1360-L1375">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ObjectiveFunction"><a class="docstring-binding" href="#MathOptInterface.ObjectiveFunction"><code>MathOptInterface.ObjectiveFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ObjectiveFunction{F&lt;:AbstractScalarFunction}()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the objective function which has a type <code>F&lt;:AbstractScalarFunction</code>.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(
    ::Optimizer,
    ::MOI.ObjectiveFunction{F},
)::F where {F&lt;:MOI.AbstractFunction}
MOI.set(
    ::Optimizer,
    ::MOI.ObjectiveFunction{F},
    ::F,
)::F where {F&lt;:MOI.AbstractFunction}
MOI.supports(::Optimizer, ::MOI.ObjectiveFunction{&lt;:MOI.AbstractFunction})::Bool</code></pre><p>When implementing <code>get</code>, <code>F</code> may to be equivalent but not necessarily identical to the function type set by the user. If the objective function cannot be converted to <code>F</code>, an <code>InexactError</code> must be thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1556-L1581">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ObjectiveFunctionType"><a class="docstring-binding" href="#MathOptInterface.ObjectiveFunctionType"><code>MathOptInterface.ObjectiveFunctionType</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ObjectiveFunctionType()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the type <code>F</code> of the objective function set using the <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction{F}</code></a> attribute.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(
    ::Optimizer,
    ::MOI.ObjectiveFunctionType,
)::Type{&lt;:MOI.AbstractFunction}</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = MOI.Utilities.Model{Float64}();

julia&gt; x = MOI.add_variable(model)
MOI.VariableIndex(1)

julia&gt; MOI.set(model, MOI.ObjectiveFunction{MOI.VariableIndex}(), x)

julia&gt; MOI.get(model, MOI.ObjectiveFunctionType())
MathOptInterface.VariableIndex</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1586-L1616">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ObjectiveSense"><a class="docstring-binding" href="#MathOptInterface.ObjectiveSense"><code>MathOptInterface.ObjectiveSense</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ObjectiveSense()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the objective sense of the objective function, which must be an <a href="../../../api/JuMP/#OptimizationSense"><code>OptimizationSense</code></a>.</p><p>The default is <a href="../../../api/JuMP/#FEASIBILITY_SENSE"><code>FEASIBILITY_SENSE</code></a>.</p><p><strong>Interaction with <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a></strong></p><p>Setting the sense to <a href="../../../api/JuMP/#FEASIBILITY_SENSE"><code>FEASIBILITY_SENSE</code></a> unsets the <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a> attribute. That is, if you first set <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a> and then set <code>ObjectiveSense</code> to be <a href="../../../api/JuMP/#FEASIBILITY_SENSE"><code>FEASIBILITY_SENSE</code></a>, no objective function will be passed to the solver.</p><p>In addition, some reformulations of <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a> via bridges rely on the value of <a href="#MathOptInterface.ObjectiveSense"><code>ObjectiveSense</code></a>. Therefore, you should set <a href="#MathOptInterface.ObjectiveSense"><code>ObjectiveSense</code></a> before setting <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a>.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.ObjectiveSense)::MOI.OptimizationSense
MOI.set(::Optimizer, ::MOI.ObjectiveSense, ::MOI.OptimizationSense)::Nothing
MOI.supports(::Optimizer, ::MOI.ObjectiveSense)::Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1395-L1422">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.OptimizationSense"><a class="docstring-binding" href="#MathOptInterface.OptimizationSense"><code>MathOptInterface.OptimizationSense</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OptimizationSense</code></pre><p>An Enum for the value of the <a href="#MathOptInterface.ObjectiveSense"><code>ObjectiveSense</code></a> attribute.</p><p><strong>Values</strong></p><p><strong><a href="../../../api/JuMP/#MIN_SENSE"><code>MIN_SENSE</code></a></strong></p><p>The goal is to minimize the objective function.</p><p><strong><a href="../../../api/JuMP/#MAX_SENSE"><code>MAX_SENSE</code></a></strong></p><p>The goal is to maximize the objective function.</p><p><strong><a href="../../../api/JuMP/#FEASIBILITY_SENSE"><code>FEASIBILITY_SENSE</code></a></strong></p><p>The model does not have an objective function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1380-L1396">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.MIN_SENSE"><a class="docstring-binding" href="#MathOptInterface.MIN_SENSE"><code>MathOptInterface.MIN_SENSE</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">MIN_SENSE::OptimizationSense</code></pre><p>An instance of the <a href="../../../api/JuMP/#OptimizationSense"><code>OptimizationSense</code></a> enum.</p><p><strong>About</strong></p><p>The goal is to minimize the objective function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1380-L1388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.MAX_SENSE"><a class="docstring-binding" href="#MathOptInterface.MAX_SENSE"><code>MathOptInterface.MAX_SENSE</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">MAX_SENSE::OptimizationSense</code></pre><p>An instance of the <a href="../../../api/JuMP/#OptimizationSense"><code>OptimizationSense</code></a> enum.</p><p><strong>About</strong></p><p>The goal is to maximize the objective function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1380-L1388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.FEASIBILITY_SENSE"><a class="docstring-binding" href="#MathOptInterface.FEASIBILITY_SENSE"><code>MathOptInterface.FEASIBILITY_SENSE</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">FEASIBILITY_SENSE::OptimizationSense</code></pre><p>An instance of the <a href="../../../api/JuMP/#OptimizationSense"><code>OptimizationSense</code></a> enum.</p><p><strong>About</strong></p><p>The model does not have an objective function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1380-L1388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.NumberOfVariables"><a class="docstring-binding" href="#MathOptInterface.NumberOfVariables"><code>MathOptInterface.NumberOfVariables</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NumberOfVariables()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the number of variables in the model.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.NumberOfVariables)::Int64</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1427-L1440">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ListOfVariableIndices"><a class="docstring-binding" href="#MathOptInterface.ListOfVariableIndices"><code>MathOptInterface.ListOfVariableIndices</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ListOfVariableIndices()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for querying the <code>Vector{MOI.VariableIndex}</code> of all [<code>MOI.VariableIndex</code>] present in the model.</p><p><strong>Order</strong></p><p>The variables must be returned in the order in which they were added to the model.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.ListOfVariableIndices)::Vector{MOI.VariableIndex}</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1445-L1463">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ListOfConstraintTypesPresent"><a class="docstring-binding" href="#MathOptInterface.ListOfConstraintTypesPresent"><code>MathOptInterface.ListOfConstraintTypesPresent</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ListOfConstraintTypesPresent()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the list of tuples of the form <code>(F, S)</code>, indicating that the attribute <a href="#MathOptInterface.NumberOfConstraints"><code>NumberOfConstraints{F,S}</code></a> has a value greater than zero.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(
    ::Optimizer,
    ::MOI.ListOfConstraintTypesPresent,
)::Vector{Tuple{Type,Type}}</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1536-L1553">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.NumberOfConstraints"><a class="docstring-binding" href="#MathOptInterface.NumberOfConstraints"><code>MathOptInterface.NumberOfConstraints</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NumberOfConstraints{F,S}()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for querying the number of constraints of the type <code>F</code>-in-<code>S</code> present in the model.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(
    ::Optimizer,
    ::MOI.NumberOfConstraints{F,S},
)::Int64 where {F&lt;:MOI.AbstractFunction,MOI.AbstractSet}</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1504-L1520">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ListOfConstraintIndices"><a class="docstring-binding" href="#MathOptInterface.ListOfConstraintIndices"><code>MathOptInterface.ListOfConstraintIndices</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ListOfConstraintIndices{F,S}()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the <code>Vector{MOI.ConstraintIndex{F,S}}</code> of all constraint indices of type <code>F</code>-in-<code>S</code> in the model.</p><p><strong>Order</strong></p><p>The constraints must be returned in the order in which they were added to the model.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(
    ::Optimizer,
    ::MOI.ListOfConstraintIndices{F,S},
)::Vector{MOI.ConstraintIndex{F,S}} where {F&lt;:MOI.AbstractFunction,MOI.AbstractSet}</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1466-L1487">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ListOfOptimizerAttributesSet"><a class="docstring-binding" href="#MathOptInterface.ListOfOptimizerAttributesSet"><code>MathOptInterface.ListOfOptimizerAttributesSet</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ListOfOptimizerAttributesSet()</code></pre><p>An <a href="#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a> for the <code>Vector{AbstractOptimizerAttribute}</code> of all optimizer attributes that were set.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(
    ::Optimizer,
    ::MOI.ListOfOptimizerAttributesSet,
)::Vector{MOI.AbstractOptimizerAttribute}</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L840-L857">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ListOfModelAttributesSet"><a class="docstring-binding" href="#MathOptInterface.ListOfModelAttributesSet"><code>MathOptInterface.ListOfModelAttributesSet</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ListOfModelAttributesSet()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the <code>Vector{AbstractModelAttribute}</code> of all model attributes <code>attr</code> such that:</p><ol><li><code>is_copyable(attr)</code> returns <code>true</code>, and</li><li>the attribute was set to the model</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1349-L1357">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ListOfVariableAttributesSet"><a class="docstring-binding" href="#MathOptInterface.ListOfVariableAttributesSet"><code>MathOptInterface.ListOfVariableAttributesSet</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ListOfVariableAttributesSet()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the <code>Vector{AbstractVariableAttribute}</code> of all variable attributes <code>attr</code> such that:</p><ol><li><code>is_copyable(attr)</code> returns <code>true</code></li><li>the attribute was set for at least one variable in the model</li></ol><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(
    ::Optimizer,
    ::MOI.ListOfVariableAttributesSet,
)::Vector{MOI.AbstractVariableAttribute}</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1907-L1926">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ListOfVariablesWithAttributeSet"><a class="docstring-binding" href="#MathOptInterface.ListOfVariablesWithAttributeSet"><code>MathOptInterface.ListOfVariablesWithAttributeSet</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ListOfVariablesWithAttributeSet(attr::AbstractVariableAttribute)</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the <code>Vector{MOI.VariableIndex}</code> of all variables with the attribute <code>attr</code> set.</p><p>The returned list may not be minimal, so some elements may have their default value set.</p><p><strong>Note</strong></p><p>This is an optional attribute to implement. The default fallback is to get <a href="#MathOptInterface.ListOfVariableIndices"><code>ListOfVariableIndices</code></a>.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(
    ::Optimizer,
    ::MOI.ListOfVariablesWithAttributeSet{&lt;:MOI.AbstractVariableAttribute},
)::Vector{MOI.VarialbeIndex}</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1929-L1953">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ListOfConstraintAttributesSet"><a class="docstring-binding" href="#MathOptInterface.ListOfConstraintAttributesSet"><code>MathOptInterface.ListOfConstraintAttributesSet</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ListOfConstraintAttributesSet{F, S}()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the <code>Vector{AbstractConstraintAttribute}</code> of all constraint attributes <code>attr</code> such that:</p><ol><li><code>is_copyable(attr)</code> returns <code>true</code> and</li><li>the attribute was set to <code>F</code>-in-<code>S</code> constraints.</li></ol><p><strong>Note</strong></p><p>The attributes <a href="../constraints/#MathOptInterface.ConstraintFunction"><code>ConstraintFunction</code></a> and <a href="../constraints/#MathOptInterface.ConstraintSet"><code>ConstraintSet</code></a> should not be included in the list even if then have been set with <a href="#MathOptInterface.set"><code>set</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2176-L2189">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ListOfConstraintsWithAttributeSet"><a class="docstring-binding" href="#MathOptInterface.ListOfConstraintsWithAttributeSet"><code>MathOptInterface.ListOfConstraintsWithAttributeSet</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ListOfConstraintsWithAttributeSet{F,S}(attr:AbstractConstraintAttribute)</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the <code>Vector{ConstraintIndex{F,S}}</code> of all constraints with the attribute <code>attr</code> set.</p><p>The returned list may not be minimal, so some elements may have their default value set.</p><p><strong>Note</strong></p><p>This is an optional attribute to implement. The default fallback is to get <a href="#MathOptInterface.ListOfConstraintIndices"><code>ListOfConstraintIndices</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2192-L2205">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.UserDefinedFunction"><a class="docstring-binding" href="#MathOptInterface.UserDefinedFunction"><code>MathOptInterface.UserDefinedFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UserDefinedFunction(name::Symbol, arity::Int) &lt;: AbstractModelAttribute</code></pre><p>Set this attribute to register a user-defined function by the name of <code>name</code> with <code>arity</code> arguments.</p><p>Once registered, <code>name</code> will appear in <a href="#MathOptInterface.ListOfSupportedNonlinearOperators"><code>ListOfSupportedNonlinearOperators</code></a>.</p><p>You cannot register multiple <code>UserDefinedFunction</code>s with the same <code>name</code> but different <code>arity</code>.</p><p><strong>Value type</strong></p><p>The value to be set is a tuple containing one, two, or three functions to evaluate the function, the first-order derivative, and the second-order derivative respectively. Both derivatives are optional, but if you pass the second-order derivative you must also pass the first-order derivative.</p><p>For univariate functions with <code>arity == 1</code>, the functions in the tuple must have the form:</p><ul><li><code>f(x::T)::T</code>: returns the value of the function at <code>x</code></li><li><code>∇f(x::T)::T</code>: returns the first-order derivative of <code>f</code> with respect to <code>x</code></li><li><code>∇²f(x::T)::T</code>: returns the second-order derivative of <code>f</code> with respect to <code>x</code>.</li></ul><p>For multivariate functions with <code>arity &gt; 1</code>, the functions in the tuple must have the form:</p><ul><li><code>f(x::T...)::T</code>: returns the value of the function at <code>x</code></li><li><code>∇f(g::AbstractVector{T}, x::T...)::Nothing</code>: fills the components of <code>g</code>, with <code>g[i]</code> being the first-order partial derivative of <code>f</code> with respect to <code>x[i]</code></li><li><code>∇²f(H::AbstractMatrix{T}, x::T...)::Nothing</code>: fills the non-zero components  of <code>H</code>, with <code>H[i, j]</code> being the second-order partial derivative of <code>f</code> with  respect to <code>x[i]</code> and then <code>x[j]</code>. <code>H</code> is initialized to the zero matrix,  so you do not need to set any zero elements.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f(x, y) = x^2 + y^2
f (generic function with 1 method)

julia&gt; function ∇f(g, x, y)
           g .= 2 * x, 2 * y
           return
       end
∇f (generic function with 1 method)

julia&gt; function ∇²f(H, x...)
           H[1, 1] = H[2, 2] = 2.0
           return
       end
∇²f (generic function with 1 method)

julia&gt; model = MOI.Utilities.UniversalFallback(MOI.Utilities.Model{Float64}());

julia&gt; MOI.set(model, MOI.UserDefinedFunction(:f, 2), (f,))

julia&gt; MOI.set(model, MOI.UserDefinedFunction(:g, 2), (f, ∇f))

julia&gt; MOI.set(model, MOI.UserDefinedFunction(:h, 2), (f, ∇f, ∇²f))

julia&gt; x = MOI.add_variables(model, 2)
2-element Vector{MathOptInterface.VariableIndex}:
 MOI.VariableIndex(1)
 MOI.VariableIndex(2)

julia&gt; MOI.set(model, MOI.ObjectiveSense(), MOI.MIN_SENSE)

julia&gt; obj_f = MOI.ScalarNonlinearFunction(:f, Any[x[1], x[2]])
f(MOI.VariableIndex(1), MOI.VariableIndex(2))

julia&gt; MOI.set(model, MOI.ObjectiveFunction{typeof(obj_f)}(), obj_f)

julia&gt; print(model)
Minimize ScalarNonlinearFunction:
 f(v[1], v[2])

Subject to:
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2773-L2856">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ListOfSupportedNonlinearOperators"><a class="docstring-binding" href="#MathOptInterface.ListOfSupportedNonlinearOperators"><code>MathOptInterface.ListOfSupportedNonlinearOperators</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ListOfSupportedNonlinearOperators() &lt;: AbstractModelAttribute</code></pre><p>When queried with <a href="#MathOptInterface.get"><code>get</code></a>, return a <code>Vector{Symbol}</code> listing the operators supported by the model. These operators may appear in the <code>head</code> field of <a href="../../submodules/FileFormats/overview/#ScalarNonlinearFunction"><code>ScalarNonlinearFunction</code></a>.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(
    ::Optimizer,
    ::MOI.ListOfSupportedNonlinearOperators,
)::Vector{Symbol}</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2862-L2879">source</a></section></details></article><h2 id="Optimizer-interface"><a class="docs-heading-anchor" href="#Optimizer-interface">Optimizer interface</a><a id="Optimizer-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizer-interface" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptInterface.AbstractOptimizer"><a class="docstring-binding" href="#MathOptInterface.AbstractOptimizer"><code>MathOptInterface.AbstractOptimizer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractOptimizer &lt;: ModelLike</code></pre><p>Abstract supertype for objects representing an instance of an optimization problem tied to a particular solver. This is typically a solver&#39;s in-memory representation. In addition to <code>ModelLike</code>, <code>AbstractOptimizer</code> objects let you solve the model and query the solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/MathOptInterface.jl#L64-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.OptimizerWithAttributes"><a class="docstring-binding" href="#MathOptInterface.OptimizerWithAttributes"><code>MathOptInterface.OptimizerWithAttributes</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct OptimizerWithAttributes
    optimizer_constructor
    params::Vector{Pair{AbstractOptimizerAttribute,&lt;:Any}}
end</code></pre><p>Object grouping an optimizer constructor and a list of optimizer attributes. Instances are created with <a href="#MathOptInterface.instantiate"><code>instantiate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/instantiate.jl#L7-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.optimize!"><a class="docstring-binding" href="#MathOptInterface.optimize!"><code>MathOptInterface.optimize!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">optimize!(optimizer::AbstractOptimizer)</code></pre><p>Optimize the problem contained in <code>optimizer</code>.</p><p>Before calling <code>optimize!</code>, the problem should first be constructed using the incremental interface (see <a href="#MathOptInterface.supports_incremental_interface"><code>supports_incremental_interface</code></a>) or <a href="#MathOptInterface.copy_to"><code>copy_to</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/MathOptInterface.jl#L74-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.optimize!-Tuple{MathOptInterface.ModelLike, MathOptInterface.ModelLike}"><a class="docstring-binding" href="#MathOptInterface.optimize!-Tuple{MathOptInterface.ModelLike, MathOptInterface.ModelLike}"><code>MathOptInterface.optimize!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">optimize!(dest::AbstractOptimizer, src::ModelLike)::Tuple{IndexMap,Bool}</code></pre><p>A &quot;one-shot&quot; call that copies the problem from <code>src</code> into <code>dest</code> and then uses <code>dest</code> to optimize the problem.</p><p>Returns a tuple of an <a href="#MathOptInterface.IndexMap"><code>IndexMap</code></a> and a <code>Bool</code> <code>copied</code>.</p><ul><li>The <a href="#MathOptInterface.IndexMap"><code>IndexMap</code></a> object translates variable and constraint indices from the <code>src</code> model to the corresponding indices in the <code>dest</code> optimizer. See <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> for details.</li><li>If <code>copied == true</code>, <code>src</code> was copied to <code>dest</code> and then cached, allowing incremental modification if supported by the solver.</li><li>If <code>copied == false</code>, a cache of the model was <em>not</em> kept in <code>dest</code>. Therefore, only the solution information (attributes for which <a href="#MathOptInterface.is_set_by_optimize"><code>is_set_by_optimize</code></a> is true) is available to query.</li></ul><div class="admonition is-info" id="Note-df1c48d868af58ba"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-df1c48d868af58ba" title="Permalink"></a></header><div class="admonition-body"><p>The main purpose of <code>optimize!</code> method with two arguments is for use in <a href="../../submodules/Utilities/overview/#Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a>.</p></div></div><p><strong>Relationship to the single-argument <code>optimize!</code></strong></p><p>The default fallback of <code>optimize!(dest::AbstractOptimizer, src::ModelLike)</code> is</p><pre><code class="language-julia hljs">function optimize!(dest::AbstractOptimizer, src::ModelLike)
    index_map = copy_to(dest, src)
    optimize!(dest)
    return index_map, true
end</code></pre><p>Therefore, subtypes of <a href="#MathOptInterface.AbstractOptimizer"><code>AbstractOptimizer</code></a> should either implement this two-argument method, or implement both <a href="#MathOptInterface.copy_to"><code>copy_to(::Optimizer, ::ModelLike)</code></a> and <code>optimize!(::Optimizer)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/MathOptInterface.jl#L84-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.instantiate"><a class="docstring-binding" href="#MathOptInterface.instantiate"><code>MathOptInterface.instantiate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">instantiate(
    optimizer_constructor,
    with_cache_type::Union{Nothing,Type} = nothing,
    with_bridge_type::Union{Nothing,Type} = nothing,
)</code></pre><p>Create an instance of an optimizer by either:</p><ul><li>calling <code>optimizer_constructor.optimizer_constructor()</code> and setting the parameters in <code>optimizer_constructor.params</code> if <code>optimizer_constructor</code> is a <a href="#MathOptInterface.OptimizerWithAttributes"><code>OptimizerWithAttributes</code></a></li><li>calling <code>optimizer_constructor()</code> if <code>optimizer_constructor</code> is callable.</li></ul><p><strong>with<em>cache</em>type</strong></p><p>If <code>with_cache_type</code> is not <code>nothing</code>, then the optimizer is wrapped in a <a href="../../submodules/Utilities/overview/#Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a> to store a cache of the model. This is most useful if the optimizer you are constructing does not support the incremental interface (see <a href="#MathOptInterface.supports_incremental_interface"><code>supports_incremental_interface</code></a>).</p><p><strong>with<em>bridge</em>type</strong></p><p>If <code>with_bridge_type</code> is not <code>nothing</code>, the optimizer is wrapped in a <a href="../../submodules/Bridges/overview/#Bridges.full_bridge_optimizer"><code>Bridges.full_bridge_optimizer</code></a>, enabling all the bridges defined in the MOI.Bridges submodule with coefficient type <code>with_bridge_type</code>.</p><p>In addition, if the optimizer created by <code>optimizer_constructor</code> does not support the incremental interface (see <a href="#MathOptInterface.supports_incremental_interface"><code>supports_incremental_interface</code></a>), then, irrespective of <code>with_cache_type</code>, the optimizer is wrapped in a <a href="../../submodules/Utilities/overview/#Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a> to store a cache of the bridged model.</p><p>If <code>with_cache_type</code> and <code>with_bridge_type</code> are both not <code>nothing</code>, then they must be the same type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/instantiate.jl#L127-L161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.default_cache"><a class="docstring-binding" href="#MathOptInterface.default_cache"><code>MathOptInterface.default_cache</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">default_cache(optimizer::ModelLike, ::Type{T}) where {T}</code></pre><p>Return a new instance of the default model type to be used as cache for <code>optimizer</code> in a <a href="../../submodules/Utilities/overview/#Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a> for holding constraints of coefficient type <code>T</code>. By default, this returns <code>Utilities.UniversalFallback(Utilities.Model{T}())</code>. If copying from a instance of a given model type is faster for <code>optimizer</code> then a new method returning an instance of this model type should be defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/instantiate.jl#L194-L203">source</a></section></details></article><h2 id="Optimizer-attributes"><a class="docs-heading-anchor" href="#Optimizer-attributes">Optimizer attributes</a><a id="Optimizer-attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizer-attributes" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathOptInterface.AbstractOptimizerAttribute"><a class="docstring-binding" href="#MathOptInterface.AbstractOptimizerAttribute"><code>MathOptInterface.AbstractOptimizerAttribute</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractOptimizerAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the optimizer.</p><p><strong>Notes</strong></p><p>The difference between <code>AbstractOptimizerAttribute</code> and <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> lies in the behavior of <a href="#MathOptInterface.is_empty"><code>is_empty</code></a>, <a href="#MathOptInterface.empty!"><code>empty!</code></a> and <a href="#MathOptInterface.copy_to"><code>copy_to</code></a>. Typically optimizer attributes affect only how the model is solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L7-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.SolverName"><a class="docstring-binding" href="#MathOptInterface.SolverName"><code>MathOptInterface.SolverName</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SolverName()</code></pre><p>An <a href="#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a> for the string identifying the solver.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.SolverName)::String</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L860-L872">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.SolverVersion"><a class="docstring-binding" href="#MathOptInterface.SolverVersion"><code>MathOptInterface.SolverVersion</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SolverVersion()</code></pre><p>An <a href="#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a> for the string identifying the version of the solver.</p><p><strong>Versioning systems</strong></p><p>For solvers supporting <a href="https://semver.org">semantic versioning</a>, the <a href="#MathOptInterface.SolverVersion"><code>SolverVersion</code></a> should be a string of the form &quot;vMAJOR.MINOR.PATCH&quot;, so that it can be converted to a Julia <code>VersionNumber</code> (for example, `VersionNumber(&quot;v1.2.3&quot;)).</p><p>We do not require Semantic Versioning because some solvers use alternate versioning systems. For example, CPLEX uses Calendar Versioning, so <a href="#MathOptInterface.SolverVersion"><code>SolverVersion</code></a> will return a string like <code>&quot;202001&quot;</code>.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.SolverVersion)::String</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L877-L901">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.Silent"><a class="docstring-binding" href="#MathOptInterface.Silent"><code>MathOptInterface.Silent</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Silent()</code></pre><p>An <a href="#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a> for silencing the output of an optimizer.</p><p>When <code>set</code> to <code>true</code>, this attribute takes precedence over any other attribute controlling verbosity and requires the optimizer to produce no output.</p><p>The default value is <code>false</code> which has no effect. In this case the verbosity is controlled by other optimizer-specific attributes.</p><p><strong>Value and default</strong></p><p>The provided value must be a <code>Bool</code>.</p><p>The default value is <code>false</code>.</p><p><strong>Note</strong></p><p>Every optimizer should have verbosity on by default. For instance, if a solver has a solver-specific log level attribute, the MOI implementation should set it to <code>1</code> by default. If the user sets <code>Silent</code> to <code>true</code>, then the log level should be set to <code>0</code>, even if the user specifically sets a value of log level. If the value of <code>Silent</code> is <code>false</code> then the log level set to the solver is the value given by the user for this solver-specific parameter or <code>1</code> if none is given.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.Silent)::Bool
MOI.set(::Optimizer, ::MOI.Silent, ::Bool)::Nothing
MOI.supports(::Optimizer, ::MOI.Silent)::Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L906-L942">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.TimeLimitSec"><a class="docstring-binding" href="#MathOptInterface.TimeLimitSec"><code>MathOptInterface.TimeLimitSec</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TimeLimitSec()</code></pre><p>An <a href="#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a> for setting a time limit (in seconds) for a call to <a href="../../../api/JuMP/#optimize!"><code>optimize!</code></a>.</p><p><strong>Value and default</strong></p><p>The provided limit must be a <code>Union{Nothing,Real}</code>.</p><p>When <code>set</code> to <code>nothing</code>, it deactivates the time limit.</p><p>The default value is <code>nothing</code>.</p><p><strong>TerminationStatus</strong></p><p>The optimizer may stop when the <a href="#MathOptInterface.SolveTimeSec"><code>SolveTimeSec</code></a> is larger than the <a href="#MathOptInterface.TimeLimitSec"><code>TimeLimitSec</code></a>. If stopped because of this limit, the <a href="#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a> must be <a href="../../../api/JuMP/#TIME_LIMIT"><code>TIME_LIMIT</code></a>.</p><p>Note that most optimizers do not strictly respect a time limit. Instead, they terminate at the first convenient time after the time limit has been exceeded. Thus, you may find that the <a href="#MathOptInterface.SolveTimeSec"><code>SolveTimeSec</code></a> exceeds the <a href="#MathOptInterface.TimeLimitSec"><code>TimeLimitSec</code></a> by a few seconds.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.TimeLimitSec)::Union{Nothing,Float64}
MOI.set(::Optimizer, ::MOI.TimeLimitSec, ::Union{Nothing,Real})::Nothing
MOI.supports(::Optimizer, ::MOI.TimeLimitSec)::Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L947-L980">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ObjectiveLimit"><a class="docstring-binding" href="#MathOptInterface.ObjectiveLimit"><code>MathOptInterface.ObjectiveLimit</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ObjectiveLimit()</code></pre><p>An <a href="#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a> for setting a limit on the objective value.</p><p><strong>Value and default</strong></p><p>The provided limit must be a <code>Union{Nothing,Real}</code>.</p><p>When <code>set</code> to <code>nothing</code>, the limit reverts to the solver&#39;s default.</p><p>The default value is <code>nothing</code>.</p><p><strong>TerminationStatus</strong></p><p>The solver may stop when the <a href="#MathOptInterface.ObjectiveValue"><code>ObjectiveValue</code></a> is better (lower for minimization, higher for maximization) than the <code>ObjectiveLimit</code>. If stopped, because of this limit, the <a href="#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a> should be <a href="../../../api/JuMP/#OBJECTIVE_LIMIT"><code>OBJECTIVE_LIMIT</code></a>.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.ObjectiveLimit)::Union{Nothing,Float64}
MOI.set(::Optimizer, ::MOI.ObjectiveLimit, ::Union{Nothing,Real})::Nothing
MOI.supports(::Optimizer, ::MOI.ObjectiveLimit)::Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L985-L1014">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.SolutionLimit"><a class="docstring-binding" href="#MathOptInterface.SolutionLimit"><code>MathOptInterface.SolutionLimit</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SolutionLimit()</code></pre><p>An <a href="#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a> for setting a limit on the number of available feasible solutions.</p><p><strong>Value and default</strong></p><p>The provided limit must be a <code>Union{Nothing,Int}</code>.</p><p>When <code>set</code> to <code>nothing</code>, the limit reverts to the solver&#39;s default.</p><p>The default value is <code>nothing</code>.</p><p><strong>Termination criteria</strong></p><p>The solver may stop when the <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> is larger than or equal to the <a href="#MathOptInterface.SolutionLimit"><code>SolutionLimit</code></a>. If stopped because of this attribute, the <a href="#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a> must be <a href="../../../api/JuMP/#SOLUTION_LIMIT"><code>SOLUTION_LIMIT</code></a>.</p><p><strong>Solution quality</strong></p><p>The quality of the available solutions is solver-dependent. The set of resulting solutions is not guaranteed to contain an optimal solution.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.SolutionLimit)::Union{Nothing,Int}
MOI.set(::Optimizer, ::MOI.SolutionLimit, ::Union{Nothing,Int})::Nothing
MOI.supports(::Optimizer, ::MOI.SolutionLimit)::Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1017-L1050">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.NodeLimit"><a class="docstring-binding" href="#MathOptInterface.NodeLimit"><code>MathOptInterface.NodeLimit</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NodeLimit()</code></pre><p>An <a href="#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a> for setting a limit on the number of branch-and-bound nodes explored by a mixed-integer program (MIP) solver.</p><p><strong>Value and default</strong></p><p>The provided limit must be a <code>Union{Nothing,Int}</code>.</p><p>When <code>set</code> to <code>nothing</code>, the limit reverts to the solver&#39;s default.</p><p>The default value is <code>nothing</code>.</p><p><strong>Termination criteria</strong></p><p>The solver may stop when the <a href="#MathOptInterface.NodeCount"><code>NodeCount</code></a> is larger than or equal to the <a href="#MathOptInterface.NodeLimit"><code>NodeLimit</code></a>. If stopped because of this attribute, the <a href="#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a> must be <a href="../../../api/JuMP/#NODE_LIMIT"><code>NODE_LIMIT</code></a>.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.NodeLimit)::Union{Nothing,Int}
MOI.set(::Optimizer, ::MOI.NodeLimit, ::Union{Nothing,Int})::Nothing
MOI.supports(::Optimizer, ::MOI.NodeLimit)::Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1055-L1083">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.RawOptimizerAttribute"><a class="docstring-binding" href="#MathOptInterface.RawOptimizerAttribute"><code>MathOptInterface.RawOptimizerAttribute</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RawOptimizerAttribute(name::String)</code></pre><p>An <a href="#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a> for the solver-specific parameter identified by <code>name</code>.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.RawOptimizerAttribute)::Any
MOI.set(::Optimizer, ::MOI.RawOptimizerAttribute, ::Any)::Nothing
MOI.supports(::Optimizer, ::MOI.RawOptimizerAttribute)::Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1088-L1102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.NumberOfThreads"><a class="docstring-binding" href="#MathOptInterface.NumberOfThreads"><code>MathOptInterface.NumberOfThreads</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NumberOfThreads()</code></pre><p>An <a href="#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a> for setting the number of threads used for an optimization.</p><p><strong>Value and default</strong></p><p>The provided value must be <code>nothing</code> or a positive <code>Int</code>.</p><p>When <code>set</code> to <code>nothing</code>, the value reverts to the solver&#39;s default.</p><p>The default value is <code>nothing</code>.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.NumberOfThreads)::Union{Nothing,Int}
MOI.set(::Optimizer, ::MOI.NumberOfThreads, ::Union{Nothing,Int})::Nothing
MOI.supports(::Optimizer, ::MOI.NumberOfThreads)::Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1107-L1129">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.RawSolver"><a class="docstring-binding" href="#MathOptInterface.RawSolver"><code>MathOptInterface.RawSolver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RawSolver()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the object that may be used to access a solver-specific API for this optimizer.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.RawSolver)::Any</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1793-L1806">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.AbsoluteGapTolerance"><a class="docstring-binding" href="#MathOptInterface.AbsoluteGapTolerance"><code>MathOptInterface.AbsoluteGapTolerance</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbsoluteGapTolerance()</code></pre><p>An <a href="#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a> for setting the absolute gap tolerance for an optimization.</p><p><strong>Definition</strong></p><p>The mathematical definition of &quot;absolute gap&quot; and its allowed range are solver-dependent. However, most solvers that implement this attribute will stop once <span>$|f - b| ≤ g_{abs}$</span>, where <span>$b$</span> is the best bound, <span>$f$</span> is the best feasible objective value, and <span>$g_{abs}$</span> is the absolute gap.</p><p><strong>Value and default</strong></p><p>The provided value must be a <code>Union{Nothing,Float64}</code>.</p><p>When set to <code>nothing</code>, the limit reverts to the solver&#39;s default.</p><p><strong>TerminationStatus</strong></p><p>The optimizer may stop when the absolute difference between <a href="#MathOptInterface.ObjectiveValue"><code>ObjectiveValue</code></a> and <a href="#MathOptInterface.ObjectiveBound"><code>ObjectiveBound</code></a> is smaller than the <a href="#MathOptInterface.AbsoluteGapTolerance"><code>AbsoluteGapTolerance</code></a>. If stopped because of this limit, the <a href="#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a> may be <a href="../../../api/JuMP/#OPTIMAL"><code>OPTIMAL</code></a>.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.AbsoluteGapTolerance)::Union{Nothing,Float64}
MOI.set(
    ::Optimizer,
    ::MOI.AbsoluteGapTolerance,
    ::Union{Nothing,Float64},
)::Nothing
MOI.supports(::Optimizer, ::MOI.AbsoluteGapTolerance)::Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1174-L1212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.RelativeGapTolerance"><a class="docstring-binding" href="#MathOptInterface.RelativeGapTolerance"><code>MathOptInterface.RelativeGapTolerance</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RelativeGapTolerance()</code></pre><p>An <a href="#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a> for setting the relative gap tolerance for an optimization.</p><p><strong>Definition</strong></p><p>The mathematical definition of &quot;relative gap&quot; and its allowed range are solver-dependent. Typically, solvers expect a value between <code>0.0</code> and <code>1.0</code>.</p><p><strong>Value and default</strong></p><p>The provided value must be a <code>Union{Nothing,Float64}</code>.</p><p>When set to <code>nothing</code>, the limit reverts to the solver&#39;s default.</p><p><strong>TerminationStatus</strong></p><p>The optimizer may stop when the <a href="#MathOptInterface.RelativeGap"><code>RelativeGap</code></a> is smaller than the <a href="#MathOptInterface.RelativeGapTolerance"><code>RelativeGapTolerance</code></a>. If stopped because of this limit, the <a href="#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a> may be <a href="../../../api/JuMP/#OPTIMAL"><code>OPTIMAL</code></a>.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.RelativeGapTolerance)::Union{Nothing,Float64}
MOI.set(
    ::Optimizer,
    ::MOI.RelativeGapTolerance,
    ::Union{Nothing,Float64},
)::Nothing
MOI.supports(::Optimizer, ::MOI.RelativeGapTolerance)::Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1134-L1169">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.AutomaticDifferentiationBackend"><a class="docstring-binding" href="#MathOptInterface.AutomaticDifferentiationBackend"><code>MathOptInterface.AutomaticDifferentiationBackend</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AutomaticDifferentiationBackend() &lt;: AbstractOptimizerAttribute</code></pre><p>An <a href="#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a> for setting the automatic differentiation backend used by the solver.</p><p>The value must be a subtype of <a href="../../submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.AbstractAutomaticDifferentiation"><code>Nonlinear.AbstractAutomaticDifferentiation</code></a>.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(
    ::Optimizer,
    ::MOI.AutomaticDifferentiationBackend,
)::MOI.Nonlinear.AbstractAutomaticDifferentiation
MOI.set(
    ::Optimizer,
    ::MOI.AutomaticDifferentiationBackend,
    ::MOI.Nonlinear.AbstractAutomaticDifferentiation,
)::Nothing
MOI.supports(::Optimizer, ::MOI.AutomaticDifferentiationBackend)::Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3054-L3077">source</a></section></details></article><p>List of attributes useful for optimizers</p><article><details class="docstring" open="true"><summary id="MathOptInterface.TerminationStatus"><a class="docstring-binding" href="#MathOptInterface.TerminationStatus"><code>MathOptInterface.TerminationStatus</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TerminationStatus()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> explaining why the optimizer stopped.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.TerminationStatus)::MOI.TerminationStatusCode</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3084-L3097">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.TerminationStatusCode"><a class="docstring-binding" href="#MathOptInterface.TerminationStatusCode"><code>MathOptInterface.TerminationStatusCode</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TerminationStatusCode</code></pre><p>An Enum of possible values for the <a href="#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a> attribute.</p><p>This attribute explains why the optimizer stopped executing in the most recent call to <a href="../../../api/JuMP/#optimize!"><code>optimize!</code></a>.</p><p><strong>Values</strong></p><p><strong><a href="../../../api/JuMP/#OPTIMIZE_NOT_CALLED"><code>OPTIMIZE_NOT_CALLED</code></a></strong></p><p>The algorithm has not started.</p><p><strong><a href="../../../api/JuMP/#OPTIMAL"><code>OPTIMAL</code></a></strong></p><p>The algorithm found a globally optimal solution.</p><p><strong><a href="../../../api/JuMP/#INFEASIBLE"><code>INFEASIBLE</code></a></strong></p><p>The algorithm proved that no primal feasible solution exists.</p><p><strong><a href="../../../api/JuMP/#DUAL_INFEASIBLE"><code>DUAL_INFEASIBLE</code></a></strong></p><p>The algorithm proved that no dual feasible solution exists.</p><p>To check if the primal problem is feasible, set the objective sense to    <a href="../../../api/JuMP/#FEASIBILITY_SENSE"><code>FEASIBILITY_SENSE</code></a> and re-solve the problem.</p><p>If a primal feasible point does not exist, the original problem is both    primal and dual infeasible.</p><p>If a primal feasible solution exists, this status typically implies that the    problem is unbounded, with some technical exceptions (for example, if the    problem is a conic optimization problem in which strong duality does not    hold).</p><p>The technical exceptions do not apply to linear programs. The combination of    <a href="../../../api/JuMP/#DUAL_INFEASIBLE"><code>DUAL_INFEASIBLE</code></a> and a primal feasible point means that the primal    linear program is unbounded.</p><p><strong><a href="../../../api/JuMP/#LOCALLY_SOLVED"><code>LOCALLY_SOLVED</code></a></strong></p><p>The algorithm converged to a stationary point, local optimal solution, could    not find directions for improvement, or otherwise completed its search    without global guarantees.</p><p><strong><a href="../../../api/JuMP/#LOCALLY_INFEASIBLE"><code>LOCALLY_INFEASIBLE</code></a></strong></p><p>The algorithm converged to an infeasible point or otherwise completed its    search without finding a feasible solution, without guarantees that no    feasible solution exists.</p><p>If you know a primal feasible solution exists, use    <a href="../variables/#MathOptInterface.VariablePrimalStart"><code>VariablePrimalStart</code></a> to provide a feasible starting point to the    solver.</p><p><strong><a href="../../../api/JuMP/#INFEASIBLE_OR_UNBOUNDED"><code>INFEASIBLE_OR_UNBOUNDED</code></a></strong></p><p>The algorithm stopped because it proved that the problem is infeasible or    unbounded, without distinguishing between the two cases.</p><p>To distinguish between the two cases, set the objective sense to    <a href="../../../api/JuMP/#FEASIBILITY_SENSE"><code>FEASIBILITY_SENSE</code></a> and re-solve the problem. If a primal feasible    point exists, the original problem is unbounded. If a primal feasible point    does not exist, the original problem is infeasible.</p><p><strong><a href="../../../api/JuMP/#ALMOST_OPTIMAL"><code>ALMOST_OPTIMAL</code></a></strong></p><p>The algorithm found a globally optimal solution to relaxed tolerances.</p><p><strong><a href="../../../api/JuMP/#ALMOST_INFEASIBLE"><code>ALMOST_INFEASIBLE</code></a></strong></p><p>The algorithm concluded that no feasible solution exists within relaxed    tolerances.</p><p><strong><a href="../../../api/JuMP/#ALMOST_DUAL_INFEASIBLE"><code>ALMOST_DUAL_INFEASIBLE</code></a></strong></p><p>The algorithm concluded that no dual bound exists for the problem within    relaxed tolerances.</p><p><strong><a href="../../../api/JuMP/#ALMOST_LOCALLY_SOLVED"><code>ALMOST_LOCALLY_SOLVED</code></a></strong></p><p>The algorithm converged to a stationary point, local optimal solution, or    could not find directions for improvement within relaxed tolerances.</p><p><strong><a href="../../../api/JuMP/#ITERATION_LIMIT"><code>ITERATION_LIMIT</code></a></strong></p><p>An iterative algorithm stopped after conducting the maximum number of    iterations.</p><p><strong><a href="../../../api/JuMP/#TIME_LIMIT"><code>TIME_LIMIT</code></a></strong></p><p>The algorithm stopped after a user-specified computation time.</p><p>This status may be returned in relation to the <a href="#MathOptInterface.TimeLimitSec"><code>TimeLimitSec</code></a>    attribute, or some other solver-specific attribute.</p><p><strong><a href="../../../api/JuMP/#NODE_LIMIT"><code>NODE_LIMIT</code></a></strong></p><p>A branch-and-bound algorithm stopped because it explored a maximum number of    nodes in the branch-and-bound tree.</p><p>This status may be returned in relation to the <a href="#MathOptInterface.NodeLimit"><code>NodeLimit</code></a>    attribute, or some other solver-specific attribute.</p><p><strong><a href="../../../api/JuMP/#SOLUTION_LIMIT"><code>SOLUTION_LIMIT</code></a></strong></p><p>The algorithm stopped because it found the required number of solutions.    This is often used in MIPs to get the solver to return the first feasible    solution it encounters.</p><p>This status may be returned in relation to the <a href="#MathOptInterface.SolutionLimit"><code>SolutionLimit</code></a>    attribute, or some other solver-specific attribute.</p><p><strong><a href="../../../api/JuMP/#MEMORY_LIMIT"><code>MEMORY_LIMIT</code></a></strong></p><p>The algorithm stopped because it ran out of memory.</p><p><strong><a href="../../../api/JuMP/#OBJECTIVE_LIMIT"><code>OBJECTIVE_LIMIT</code></a></strong></p><p>The algorithm stopped because it found a solution better than a minimum    limit set by the user.</p><p>This status may be returned in relation to the <a href="#MathOptInterface.ObjectiveLimit"><code>ObjectiveLimit</code></a>    attribute, or some other solver-specific attribute.</p><p><strong><a href="../../../api/JuMP/#NORM_LIMIT"><code>NORM_LIMIT</code></a></strong></p><p>The algorithm stopped because the norm of an iterate became too large.</p><p>This typically means that the primal problem is unbounded, but that the    solver could not prove so.</p><p><strong><a href="../../../api/JuMP/#OTHER_LIMIT"><code>OTHER_LIMIT</code></a></strong></p><p>The algorithm stopped due to a limit not covered by one of the <code>_LIMIT_</code>    statuses above.</p><p><strong><a href="../../../api/JuMP/#SLOW_PROGRESS"><code>SLOW_PROGRESS</code></a></strong></p><p>The algorithm stopped because it was unable to continue making progress    towards the solution.</p><p><strong><a href="../../../api/JuMP/#NUMERICAL_ERROR"><code>NUMERICAL_ERROR</code></a></strong></p><p>The algorithm stopped because it encountered unrecoverable numerical error.</p><p><strong><a href="../../../api/JuMP/#INVALID_MODEL"><code>INVALID_MODEL</code></a></strong></p><p>The algorithm stopped because the model is invalid.</p><p>The reason for this return code is solver-specific, but common causes are    that the problem has zero variables or constraints, or that the problem data    contains an invalid number such as <code>NaN</code>.</p><p><strong><a href="../../../api/JuMP/#INVALID_OPTION"><code>INVALID_OPTION</code></a></strong></p><p>The algorithm stopped because it was provided an invalid option.</p><p><strong><a href="../../../api/JuMP/#INTERRUPTED"><code>INTERRUPTED</code></a></strong></p><p>The algorithm stopped because of an interrupt signal.</p><p>This typically means that the solver was interrupted by the user with    <code>CTRL+C</code>.</p><p><strong><a href="../../../api/JuMP/#OTHER_ERROR"><code>OTHER_ERROR</code></a></strong></p><p>The algorithm stopped because of an error not covered by one of the statuses    defined above. Check the solver log for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L3051">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.OPTIMIZE_NOT_CALLED"><a class="docstring-binding" href="#MathOptInterface.OPTIMIZE_NOT_CALLED"><code>MathOptInterface.OPTIMIZE_NOT_CALLED</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">OPTIMIZE_NOT_CALLED::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm has not started.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2890">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.OPTIMAL"><a class="docstring-binding" href="#MathOptInterface.OPTIMAL"><code>MathOptInterface.OPTIMAL</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">OPTIMAL::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm found a globally optimal solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2891">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.INFEASIBLE"><a class="docstring-binding" href="#MathOptInterface.INFEASIBLE"><code>MathOptInterface.INFEASIBLE</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">INFEASIBLE::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm proved that no primal feasible solution exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2891">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.DUAL_INFEASIBLE"><a class="docstring-binding" href="#MathOptInterface.DUAL_INFEASIBLE"><code>MathOptInterface.DUAL_INFEASIBLE</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">DUAL_INFEASIBLE::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm proved that no dual feasible solution exists.</p><p>To check if the primal problem is feasible, set the objective sense to <a href="../../../api/JuMP/#FEASIBILITY_SENSE"><code>FEASIBILITY_SENSE</code></a> and re-solve the problem.</p><p>If a primal feasible point does not exist, the original problem is both primal and dual infeasible.</p><p>If a primal feasible solution exists, this status typically implies that the problem is unbounded, with some technical exceptions (for example, if the problem is a conic optimization problem in which strong duality does not hold).</p><p>The technical exceptions do not apply to linear programs. The combination of <a href="../../../api/JuMP/#DUAL_INFEASIBLE"><code>DUAL_INFEASIBLE</code></a> and a primal feasible point means that the primal linear program is unbounded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2906">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.LOCALLY_SOLVED"><a class="docstring-binding" href="#MathOptInterface.LOCALLY_SOLVED"><code>MathOptInterface.LOCALLY_SOLVED</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">LOCALLY_SOLVED::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2893">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.LOCALLY_INFEASIBLE"><a class="docstring-binding" href="#MathOptInterface.LOCALLY_INFEASIBLE"><code>MathOptInterface.LOCALLY_INFEASIBLE</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">LOCALLY_INFEASIBLE::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.</p><p>If you know a primal feasible solution exists, use <a href="../variables/#MathOptInterface.VariablePrimalStart"><code>VariablePrimalStart</code></a> to provide a feasible starting point to the solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2897">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.INFEASIBLE_OR_UNBOUNDED"><a class="docstring-binding" href="#MathOptInterface.INFEASIBLE_OR_UNBOUNDED"><code>MathOptInterface.INFEASIBLE_OR_UNBOUNDED</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">INFEASIBLE_OR_UNBOUNDED::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm stopped because it proved that the problem is infeasible or unbounded, without distinguishing between the two cases.</p><p>To distinguish between the two cases, set the objective sense to <a href="../../../api/JuMP/#FEASIBILITY_SENSE"><code>FEASIBILITY_SENSE</code></a> and re-solve the problem. If a primal feasible point exists, the original problem is unbounded. If a primal feasible point does not exist, the original problem is infeasible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2897">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ALMOST_OPTIMAL"><a class="docstring-binding" href="#MathOptInterface.ALMOST_OPTIMAL"><code>MathOptInterface.ALMOST_OPTIMAL</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ALMOST_OPTIMAL::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm found a globally optimal solution to relaxed tolerances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2890">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ALMOST_INFEASIBLE"><a class="docstring-binding" href="#MathOptInterface.ALMOST_INFEASIBLE"><code>MathOptInterface.ALMOST_INFEASIBLE</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ALMOST_INFEASIBLE::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm concluded that no feasible solution exists within relaxed tolerances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2892">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ALMOST_DUAL_INFEASIBLE"><a class="docstring-binding" href="#MathOptInterface.ALMOST_DUAL_INFEASIBLE"><code>MathOptInterface.ALMOST_DUAL_INFEASIBLE</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ALMOST_DUAL_INFEASIBLE::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2892">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ALMOST_LOCALLY_SOLVED"><a class="docstring-binding" href="#MathOptInterface.ALMOST_LOCALLY_SOLVED"><code>MathOptInterface.ALMOST_LOCALLY_SOLVED</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ALMOST_LOCALLY_SOLVED::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2892">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ITERATION_LIMIT"><a class="docstring-binding" href="#MathOptInterface.ITERATION_LIMIT"><code>MathOptInterface.ITERATION_LIMIT</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ITERATION_LIMIT::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>An iterative algorithm stopped after conducting the maximum number of iterations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2892">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.TIME_LIMIT"><a class="docstring-binding" href="#MathOptInterface.TIME_LIMIT"><code>MathOptInterface.TIME_LIMIT</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">TIME_LIMIT::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm stopped after a user-specified computation time.</p><p>This status may be returned in relation to the <a href="#MathOptInterface.TimeLimitSec"><code>TimeLimitSec</code></a> attribute, or some other solver-specific attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2894">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.NODE_LIMIT"><a class="docstring-binding" href="#MathOptInterface.NODE_LIMIT"><code>MathOptInterface.NODE_LIMIT</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">NODE_LIMIT::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.</p><p>This status may be returned in relation to the <a href="#MathOptInterface.NodeLimit"><code>NodeLimit</code></a> attribute, or some other solver-specific attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2895">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.SOLUTION_LIMIT"><a class="docstring-binding" href="#MathOptInterface.SOLUTION_LIMIT"><code>MathOptInterface.SOLUTION_LIMIT</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">SOLUTION_LIMIT::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.</p><p>This status may be returned in relation to the <a href="#MathOptInterface.SolutionLimit"><code>SolutionLimit</code></a> attribute, or some other solver-specific attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2896">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.MEMORY_LIMIT"><a class="docstring-binding" href="#MathOptInterface.MEMORY_LIMIT"><code>MathOptInterface.MEMORY_LIMIT</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">MEMORY_LIMIT::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm stopped because it ran out of memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2890">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.OBJECTIVE_LIMIT"><a class="docstring-binding" href="#MathOptInterface.OBJECTIVE_LIMIT"><code>MathOptInterface.OBJECTIVE_LIMIT</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">OBJECTIVE_LIMIT::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm stopped because it found a solution better than a minimum limit set by the user.</p><p>This status may be returned in relation to the <a href="#MathOptInterface.ObjectiveLimit"><code>ObjectiveLimit</code></a> attribute, or some other solver-specific attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2895">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.NORM_LIMIT"><a class="docstring-binding" href="#MathOptInterface.NORM_LIMIT"><code>MathOptInterface.NORM_LIMIT</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">NORM_LIMIT::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm stopped because the norm of an iterate became too large.</p><p>This typically means that the primal problem is unbounded, but that the solver could not prove so.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2894">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.OTHER_LIMIT"><a class="docstring-binding" href="#MathOptInterface.OTHER_LIMIT"><code>MathOptInterface.OTHER_LIMIT</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">OTHER_LIMIT::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm stopped due to a limit not covered by one of the <code>_LIMIT_</code> statuses above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2892">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.SLOW_PROGRESS"><a class="docstring-binding" href="#MathOptInterface.SLOW_PROGRESS"><code>MathOptInterface.SLOW_PROGRESS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">SLOW_PROGRESS::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm stopped because it was unable to continue making progress towards the solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2892">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.NUMERICAL_ERROR"><a class="docstring-binding" href="#MathOptInterface.NUMERICAL_ERROR"><code>MathOptInterface.NUMERICAL_ERROR</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">NUMERICAL_ERROR::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm stopped because it encountered unrecoverable numerical error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2891">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.INVALID_MODEL"><a class="docstring-binding" href="#MathOptInterface.INVALID_MODEL"><code>MathOptInterface.INVALID_MODEL</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">INVALID_MODEL::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm stopped because the model is invalid.</p><p>The reason for this return code is solver-specific, but common causes are that the problem has zero variables or constraints, or that the problem data contains an invalid number such as <code>NaN</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2895">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.INVALID_OPTION"><a class="docstring-binding" href="#MathOptInterface.INVALID_OPTION"><code>MathOptInterface.INVALID_OPTION</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">INVALID_OPTION::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm stopped because it was provided an invalid option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2891">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.INTERRUPTED"><a class="docstring-binding" href="#MathOptInterface.INTERRUPTED"><code>MathOptInterface.INTERRUPTED</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">INTERRUPTED::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm stopped because of an interrupt signal.</p><p>This typically means that the solver was interrupted by the user with <code>CTRL+C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2894">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.OTHER_ERROR"><a class="docstring-binding" href="#MathOptInterface.OTHER_ERROR"><code>MathOptInterface.OTHER_ERROR</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">OTHER_ERROR::TerminationStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#TerminationStatusCode"><code>TerminationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The algorithm stopped because of an error not covered by one of the statuses defined above. Check the solver log for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2882-L2892">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.PrimalStatus"><a class="docstring-binding" href="#MathOptInterface.PrimalStatus"><code>MathOptInterface.PrimalStatus</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PrimalStatus(result_index::Int = 1)</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the <a href="../../../api/JuMP/#ResultStatusCode"><code>ResultStatusCode</code></a> of the primal result <code>result_index</code>.</p><p><strong><code>result_index</code></strong></p><p>If <code>result_index</code> is omitted, it defaults to 1.</p><p>See <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> for information on how the results are ordered.</p><p>If <code>result_index</code> is larger than the value of <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> then <a href="../../../api/JuMP/#NO_SOLUTION"><code>NO_SOLUTION</code></a> is returned.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.PrimalStatus)::MOI.ResultStatusCode</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3185-L3207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.DualStatus"><a class="docstring-binding" href="#MathOptInterface.DualStatus"><code>MathOptInterface.DualStatus</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DualStatus(result_index::Int = 1)</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the <a href="../../../api/JuMP/#ResultStatusCode"><code>ResultStatusCode</code></a> of the dual result <code>result_index</code>.</p><p><strong><code>result_index</code></strong></p><p>See <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> for information on how the results are ordered.</p><p>If <code>result_index</code> is larger than the value of <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> then <a href="../../../api/JuMP/#NO_SOLUTION"><code>NO_SOLUTION</code></a> is returned.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.PrimalStatus)::MOI.ResultStatusCode</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3215-L3235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.RawStatusString"><a class="docstring-binding" href="#MathOptInterface.RawStatusString"><code>MathOptInterface.RawStatusString</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RawStatusString()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for a solver specific string explaining why the optimizer stopped.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.RawStatusString)::MOI.String</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3102-L3115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ResultCount"><a class="docstring-binding" href="#MathOptInterface.ResultCount"><code>MathOptInterface.ResultCount</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ResultCount()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the number of results available.</p><p><strong>Order of solutions</strong></p><p>A number of attributes contain an index, <code>result_index</code>, which is used to refer to one of the available results. Thus, <code>result_index</code> must be an integer between <code>1</code> and the number of available results.</p><p>As a general rule, the first result (<code>result_index = 1</code>) is the most important result (for example, an optimal solution or an infeasibility certificate). Other results will typically be alternate solutions that the solver found during the search for the first result.</p><p>If a (local) optimal solution is available, that is, <a href="#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a> is <a href="../../../api/JuMP/#OPTIMAL"><code>OPTIMAL</code></a> or <a href="../../../api/JuMP/#LOCALLY_SOLVED"><code>LOCALLY_SOLVED</code></a>, the first result must correspond to the (locally) optimal solution. Other results may be alternative optimal solutions, or they may be other suboptimal solutions; use <a href="#MathOptInterface.ObjectiveValue"><code>ObjectiveValue</code></a> to distinguish between them.</p><p>If a primal or dual infeasibility certificate is available, that is, <a href="#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a> is <a href="../../../api/JuMP/#INFEASIBLE"><code>INFEASIBLE</code></a> or <a href="../../../api/JuMP/#DUAL_INFEASIBLE"><code>DUAL_INFEASIBLE</code></a> and the corresponding <a href="#MathOptInterface.PrimalStatus"><code>PrimalStatus</code></a> or <a href="#MathOptInterface.DualStatus"><code>DualStatus</code></a> is <a href="../../../api/JuMP/#INFEASIBILITY_CERTIFICATE"><code>INFEASIBILITY_CERTIFICATE</code></a>, then the first result must be a certificate. Other results may be alternate certificates, or infeasible points.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.ResultCount)::Int</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1809-L1844">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ObjectiveValue"><a class="docstring-binding" href="#MathOptInterface.ObjectiveValue"><code>MathOptInterface.ObjectiveValue</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ObjectiveValue(result_index::Int = 1)</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the objective value of the primal solution <code>result_index</code>.</p><p><strong>PrimalStatus</strong></p><p>Before quering this attribute you should first check <a href="#MathOptInterface.PrimalStatus"><code>PrimalStatus</code></a> to confirm that a primal solution is avaiable.</p><p>If the <a href="#MathOptInterface.PrimalStatus"><code>PrimalStatus</code></a> is <a href="../../../api/JuMP/#NO_SOLUTION"><code>NO_SOLUTION</code></a> the result of querying this attribute is undefined.</p><p><strong><code>result_index</code></strong></p><p>The optimizer may return multiple primal solutions. See <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> for information on how the results are ordered.</p><p>If the solver does not have a primal value for the objective because the <code>result_index</code> is beyond the available solutions (whose number is indicated by the <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> attribute), getting this attribute must throw a <a href="../errors/#MathOptInterface.ResultIndexBoundsError"><code>ResultIndexBoundsError</code></a>.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(
    ::Optimizer,
    ::MOI.ObjectiveValue,
)::Union{T,Vector{T}} where {T&lt;:Real}</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1621-L1655">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.DualObjectiveValue"><a class="docstring-binding" href="#MathOptInterface.DualObjectiveValue"><code>MathOptInterface.DualObjectiveValue</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DualObjectiveValue(result_index::Int = 1)</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the value of the objective function of the dual solution <code>result_index</code>.</p><p><strong>DualStatus</strong></p><p>Before quering this attribute you should first check <a href="#MathOptInterface.DualStatus"><code>DualStatus</code></a> to confirm that a dual solution is avaiable.</p><p>If the <a href="#MathOptInterface.DualStatus"><code>DualStatus</code></a> is <a href="../../../api/JuMP/#NO_SOLUTION"><code>NO_SOLUTION</code></a> the result of querying this attribute is undefined.</p><p><strong><code>result_index</code></strong></p><p>The optimizer may return multiple dual solutions. See <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> for information on how the results are ordered.</p><p>If the solver does not have a dual value for the objective because the <code>result_index</code> is beyond the available solutions (whose number is indicated by the <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> attribute), getting this attribute must throw a <a href="../errors/#MathOptInterface.ResultIndexBoundsError"><code>ResultIndexBoundsError</code></a>.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(
    ::Optimizer,
    ::MOI.DualObjectiveValue,
)::Union{T,Vector{T}} where {T&lt;:Real}</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1661-L1695">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ObjectiveBound"><a class="docstring-binding" href="#MathOptInterface.ObjectiveBound"><code>MathOptInterface.ObjectiveBound</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ObjectiveBound()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the best known bound on the optimal objective value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1701-L1705">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.RelativeGap"><a class="docstring-binding" href="#MathOptInterface.RelativeGap"><code>MathOptInterface.RelativeGap</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RelativeGap()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the final relative optimality gap.</p><div class="admonition is-warning" id="Warning-bef5d20c45fc8248"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-bef5d20c45fc8248" title="Permalink"></a></header><div class="admonition-body"><p>The definition of this gap is solver-dependent. However, most solvers implementing this attribute define the relative gap as some variation of <span>$\frac{|b-f|}{|f|}$</span>, where <span>$b$</span> is the best bound and <span>$f$</span> is the best feasible objective value.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1708-L1718">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.SolveTimeSec"><a class="docstring-binding" href="#MathOptInterface.SolveTimeSec"><code>MathOptInterface.SolveTimeSec</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SolveTimeSec()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the total elapsed solution time (in seconds) as reported by the optimizer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1723-L1728">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.SimplexIterations"><a class="docstring-binding" href="#MathOptInterface.SimplexIterations"><code>MathOptInterface.SimplexIterations</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SimplexIterations()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the cumulative number of simplex iterations while solving a problem.</p><p>For a mixed-integer program (MIP), the return value is the total simplex iterations for all nodes.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.SimplexIterations)::Int64</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1733-L1749">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.BarrierIterations"><a class="docstring-binding" href="#MathOptInterface.BarrierIterations"><code>MathOptInterface.BarrierIterations</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BarrierIterations()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the cumulative number of barrier iterations while solving a problem.</p><p>For a mixed-integer program (MIP), the return value is the total barrier iterations for all nodes.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.BarrierIterations)::Int64</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1754-L1770">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.NodeCount"><a class="docstring-binding" href="#MathOptInterface.NodeCount"><code>MathOptInterface.NodeCount</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NodeCount()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the total number of branch-and-bound nodes explored while solving a mixed-integer program (MIP).</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.NodeCount)::Int64</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1775-L1788">source</a></section></details></article><h3 id="Result-Status"><a class="docs-heading-anchor" href="#Result-Status">Result Status</a><a id="Result-Status-1"></a><a class="docs-heading-anchor-permalink" href="#Result-Status" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MathOptInterface.ResultStatusCode"><a class="docstring-binding" href="#MathOptInterface.ResultStatusCode"><code>MathOptInterface.ResultStatusCode</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ResultStatusCode</code></pre><p>An Enum of possible values for the <a href="#MathOptInterface.PrimalStatus"><code>PrimalStatus</code></a> and <a href="#MathOptInterface.DualStatus"><code>DualStatus</code></a> attributes.</p><p>The values indicate how to interpret the result vector.</p><p><strong>Values</strong></p><p><strong><a href="../../../api/JuMP/#NO_SOLUTION"><code>NO_SOLUTION</code></a></strong></p><p>The result vector is empty.</p><p><strong><a href="../../../api/JuMP/#FEASIBLE_POINT"><code>FEASIBLE_POINT</code></a></strong></p><p>The result vector is a feasible point.</p><p><strong><a href="../../../api/JuMP/#NEARLY_FEASIBLE_POINT"><code>NEARLY_FEASIBLE_POINT</code></a></strong></p><p>The result vector is feasible if some constraint tolerances are relaxed.</p><p><strong><a href="../../../api/JuMP/#INFEASIBLE_POINT"><code>INFEASIBLE_POINT</code></a></strong></p><p>The result vector is an infeasible point.</p><p><strong><a href="../../../api/JuMP/#INFEASIBILITY_CERTIFICATE"><code>INFEASIBILITY_CERTIFICATE</code></a></strong></p><p>The result vector is an infeasibility certificate.</p><p>If the <a href="#MathOptInterface.PrimalStatus"><code>PrimalStatus</code></a> is <a href="../../../api/JuMP/#INFEASIBILITY_CERTIFICATE"><code>INFEASIBILITY_CERTIFICATE</code></a>, then    the primal result vector is a certificate of dual infeasibility.</p><p>If the <a href="#MathOptInterface.DualStatus"><code>DualStatus</code></a> is <a href="../../../api/JuMP/#INFEASIBILITY_CERTIFICATE"><code>INFEASIBILITY_CERTIFICATE</code></a>, then the    dual result vector is a proof of primal infeasibility.</p><p><strong><a href="../../../api/JuMP/#NEARLY_INFEASIBILITY_CERTIFICATE"><code>NEARLY_INFEASIBILITY_CERTIFICATE</code></a></strong></p><p>The result satisfies a relaxed criterion for a certificate of infeasibility.</p><p>If the <a href="#MathOptInterface.PrimalStatus"><code>PrimalStatus</code></a> is <a href="../../../api/JuMP/#NEARLY_INFEASIBILITY_CERTIFICATE"><code>NEARLY_INFEASIBILITY_CERTIFICATE</code></a>,    then the primal result vector is a certificate of dual infeasibility.</p><p>If the <a href="#MathOptInterface.DualStatus"><code>DualStatus</code></a> is <a href="../../../api/JuMP/#NEARLY_INFEASIBILITY_CERTIFICATE"><code>NEARLY_INFEASIBILITY_CERTIFICATE</code></a>,    then the dual result vector is a proof of primal infeasibility.</p><p><strong><a href="../../../api/JuMP/#REDUCTION_CERTIFICATE"><code>REDUCTION_CERTIFICATE</code></a></strong></p><p>The result vector is an ill-posed certificate; see <a href="https://arxiv.org/abs/1408.4685">this article</a>    for details.</p><p>If the <a href="#MathOptInterface.PrimalStatus"><code>PrimalStatus</code></a> is <a href="../../../api/JuMP/#REDUCTION_CERTIFICATE"><code>REDUCTION_CERTIFICATE</code></a>, then the    primal result vector is a proof that the dual problem is ill-posed.</p><p>If the <a href="#MathOptInterface.DualStatus"><code>DualStatus</code></a> is <a href="../../../api/JuMP/#REDUCTION_CERTIFICATE"><code>REDUCTION_CERTIFICATE</code></a>, then the    dual result vector is a proof that the primal is ill-posed.</p><p><strong><a href="../../../api/JuMP/#NEARLY_REDUCTION_CERTIFICATE"><code>NEARLY_REDUCTION_CERTIFICATE</code></a></strong></p><p>The result satisfies a relaxed criterion for an ill-posed certificate.</p><p><strong><a href="../../../api/JuMP/#UNKNOWN_RESULT_STATUS"><code>UNKNOWN_RESULT_STATUS</code></a></strong></p><p>The result vector contains a solution with an unknown interpretation. Check    the solver log for more details.</p><p><strong><a href="../../../api/JuMP/#OTHER_RESULT_STATUS"><code>OTHER_RESULT_STATUS</code></a></strong></p><p>The result vector contains a solution with an interpretation not covered by    one of the statuses defined above. Check the solver log for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3120-L3187">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.NO_SOLUTION"><a class="docstring-binding" href="#MathOptInterface.NO_SOLUTION"><code>MathOptInterface.NO_SOLUTION</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">NO_SOLUTION::ResultStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#ResultStatusCode"><code>ResultStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The result vector is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3120-L3128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.FEASIBLE_POINT"><a class="docstring-binding" href="#MathOptInterface.FEASIBLE_POINT"><code>MathOptInterface.FEASIBLE_POINT</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">FEASIBLE_POINT::ResultStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#ResultStatusCode"><code>ResultStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The result vector is a feasible point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3120-L3128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.NEARLY_FEASIBLE_POINT"><a class="docstring-binding" href="#MathOptInterface.NEARLY_FEASIBLE_POINT"><code>MathOptInterface.NEARLY_FEASIBLE_POINT</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">NEARLY_FEASIBLE_POINT::ResultStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#ResultStatusCode"><code>ResultStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The result vector is feasible if some constraint tolerances are relaxed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3120-L3128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.INFEASIBLE_POINT"><a class="docstring-binding" href="#MathOptInterface.INFEASIBLE_POINT"><code>MathOptInterface.INFEASIBLE_POINT</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">INFEASIBLE_POINT::ResultStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#ResultStatusCode"><code>ResultStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The result vector is an infeasible point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3120-L3128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.INFEASIBILITY_CERTIFICATE"><a class="docstring-binding" href="#MathOptInterface.INFEASIBILITY_CERTIFICATE"><code>MathOptInterface.INFEASIBILITY_CERTIFICATE</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">INFEASIBILITY_CERTIFICATE::ResultStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#ResultStatusCode"><code>ResultStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The result vector is an infeasibility certificate.</p><p>If the <a href="#MathOptInterface.PrimalStatus"><code>PrimalStatus</code></a> is <a href="../../../api/JuMP/#INFEASIBILITY_CERTIFICATE"><code>INFEASIBILITY_CERTIFICATE</code></a>, then the primal result vector is a certificate of dual infeasibility.</p><p>If the <a href="#MathOptInterface.DualStatus"><code>DualStatus</code></a> is <a href="../../../api/JuMP/#INFEASIBILITY_CERTIFICATE"><code>INFEASIBILITY_CERTIFICATE</code></a>, then the dual result vector is a proof of primal infeasibility.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3120-L3135">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.NEARLY_INFEASIBILITY_CERTIFICATE"><a class="docstring-binding" href="#MathOptInterface.NEARLY_INFEASIBILITY_CERTIFICATE"><code>MathOptInterface.NEARLY_INFEASIBILITY_CERTIFICATE</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">NEARLY_INFEASIBILITY_CERTIFICATE::ResultStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#ResultStatusCode"><code>ResultStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The result satisfies a relaxed criterion for a certificate of infeasibility.</p><p>If the <a href="#MathOptInterface.PrimalStatus"><code>PrimalStatus</code></a> is <a href="../../../api/JuMP/#NEARLY_INFEASIBILITY_CERTIFICATE"><code>NEARLY_INFEASIBILITY_CERTIFICATE</code></a>, then the primal result vector is a certificate of dual infeasibility.</p><p>If the <a href="#MathOptInterface.DualStatus"><code>DualStatus</code></a> is <a href="../../../api/JuMP/#NEARLY_INFEASIBILITY_CERTIFICATE"><code>NEARLY_INFEASIBILITY_CERTIFICATE</code></a>, then the dual result vector is a proof of primal infeasibility.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3120-L3135">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.REDUCTION_CERTIFICATE"><a class="docstring-binding" href="#MathOptInterface.REDUCTION_CERTIFICATE"><code>MathOptInterface.REDUCTION_CERTIFICATE</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">REDUCTION_CERTIFICATE::ResultStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#ResultStatusCode"><code>ResultStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The result vector is an ill-posed certificate; see <a href="https://arxiv.org/abs/1408.4685">this article</a> for details.</p><p>If the <a href="#MathOptInterface.PrimalStatus"><code>PrimalStatus</code></a> is <a href="../../../api/JuMP/#REDUCTION_CERTIFICATE"><code>REDUCTION_CERTIFICATE</code></a>, then the primal result vector is a proof that the dual problem is ill-posed.</p><p>If the <a href="#MathOptInterface.DualStatus"><code>DualStatus</code></a> is <a href="../../../api/JuMP/#REDUCTION_CERTIFICATE"><code>REDUCTION_CERTIFICATE</code></a>, then the dual result vector is a proof that the primal is ill-posed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3120-L3136">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.NEARLY_REDUCTION_CERTIFICATE"><a class="docstring-binding" href="#MathOptInterface.NEARLY_REDUCTION_CERTIFICATE"><code>MathOptInterface.NEARLY_REDUCTION_CERTIFICATE</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">NEARLY_REDUCTION_CERTIFICATE::ResultStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#ResultStatusCode"><code>ResultStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The result satisfies a relaxed criterion for an ill-posed certificate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3120-L3129">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.UNKNOWN_RESULT_STATUS"><a class="docstring-binding" href="#MathOptInterface.UNKNOWN_RESULT_STATUS"><code>MathOptInterface.UNKNOWN_RESULT_STATUS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">UNKNOWN_RESULT_STATUS::ResultStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#ResultStatusCode"><code>ResultStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The result vector contains a solution with an unknown interpretation. Check the solver log for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3120-L3130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.OTHER_RESULT_STATUS"><a class="docstring-binding" href="#MathOptInterface.OTHER_RESULT_STATUS"><code>MathOptInterface.OTHER_RESULT_STATUS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">OTHER_RESULT_STATUS::ResultStatusCode</code></pre><p>An instance of the <a href="../../../api/JuMP/#ResultStatusCode"><code>ResultStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The result vector contains a solution with an interpretation not covered by one of the statuses defined above. Check the solver log for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L3120-L3130">source</a></section></details></article><h3 id="Conflict-Status"><a class="docs-heading-anchor" href="#Conflict-Status">Conflict Status</a><a id="Conflict-Status-1"></a><a class="docs-heading-anchor-permalink" href="#Conflict-Status" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MathOptInterface.compute_conflict!"><a class="docstring-binding" href="#MathOptInterface.compute_conflict!"><code>MathOptInterface.compute_conflict!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_conflict!(optimizer::AbstractOptimizer)</code></pre><p>Computes a minimal subset of constraints such that the model with the other constraint removed is still infeasible.</p><p>Some solvers call a set of conflicting constraints an Irreducible Inconsistent Subsystem (IIS).</p><p>See also <a href="#MathOptInterface.ConflictStatus"><code>ConflictStatus</code></a> and <a href="#MathOptInterface.ConstraintConflictStatus"><code>ConstraintConflictStatus</code></a>.</p><p><strong>Note</strong></p><p>If the model is modified after a call to <code>compute_conflict!</code>, the implementor is not obliged to purge the conflict. Any calls to the above attributes may return values for the original conflict without a warning. Similarly, when modifying the model, the conflict can be discarded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/MathOptInterface.jl#L126-L143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ConflictStatus"><a class="docstring-binding" href="#MathOptInterface.ConflictStatus"><code>MathOptInterface.ConflictStatus</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConflictStatus()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the <a href="#MathOptInterface.ConflictStatusCode"><code>ConflictStatusCode</code></a> explaining why [<code>compute_conflict!</code>] stopped when computing the conflict.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.ConflictStatus)::MOI.ConflictStatusCode</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1871-L1884">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ConflictStatusCode"><a class="docstring-binding" href="#MathOptInterface.ConflictStatusCode"><code>MathOptInterface.ConflictStatusCode</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConflictStatusCode</code></pre><p>An Enum of possible values for the <a href="#MathOptInterface.ConflictStatus"><code>ConflictStatus</code></a> attribute.</p><p>This attribute is meant to explain the reason why the conflict finder stopped executing in the most recent call to <a href="../../../api/JuMP/#compute_conflict!"><code>compute_conflict!</code></a>.</p><p><strong>Values</strong></p><p><strong><a href="#MathOptInterface.COMPUTE_CONFLICT_NOT_CALLED"><code>COMPUTE_CONFLICT_NOT_CALLED</code></a></strong></p><p>The function <a href="../../../api/JuMP/#compute_conflict!"><code>compute_conflict!</code></a> has not yet been called.</p><p><strong><a href="#MathOptInterface.NO_CONFLICT_EXISTS"><code>NO_CONFLICT_EXISTS</code></a></strong></p><p>There is no conflict because the problem is feasible.</p><p><strong><a href="#MathOptInterface.NO_CONFLICT_FOUND"><code>NO_CONFLICT_FOUND</code></a></strong></p><p>The solver could not find a conflict.</p><p><strong><a href="#MathOptInterface.CONFLICT_FOUND"><code>CONFLICT_FOUND</code></a></strong></p><p>The solver found a conflict.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1849-L1872">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.COMPUTE_CONFLICT_NOT_CALLED"><a class="docstring-binding" href="#MathOptInterface.COMPUTE_CONFLICT_NOT_CALLED"><code>MathOptInterface.COMPUTE_CONFLICT_NOT_CALLED</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">COMPUTE_CONFLICT_NOT_CALLED::ConflictStatusCode</code></pre><p>An instance of the <a href="#MathOptInterface.ConflictStatusCode"><code>ConflictStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The function <a href="../../../api/JuMP/#compute_conflict!"><code>compute_conflict!</code></a> has not yet been called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1849-L1858">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.NO_CONFLICT_EXISTS"><a class="docstring-binding" href="#MathOptInterface.NO_CONFLICT_EXISTS"><code>MathOptInterface.NO_CONFLICT_EXISTS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">NO_CONFLICT_EXISTS::ConflictStatusCode</code></pre><p>An instance of the <a href="#MathOptInterface.ConflictStatusCode"><code>ConflictStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>There is no conflict because the problem is feasible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1849-L1857">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.NO_CONFLICT_FOUND"><a class="docstring-binding" href="#MathOptInterface.NO_CONFLICT_FOUND"><code>MathOptInterface.NO_CONFLICT_FOUND</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">NO_CONFLICT_FOUND::ConflictStatusCode</code></pre><p>An instance of the <a href="#MathOptInterface.ConflictStatusCode"><code>ConflictStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The solver could not find a conflict.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1849-L1857">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.CONFLICT_FOUND"><a class="docstring-binding" href="#MathOptInterface.CONFLICT_FOUND"><code>MathOptInterface.CONFLICT_FOUND</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">CONFLICT_FOUND::ConflictStatusCode</code></pre><p>An instance of the <a href="#MathOptInterface.ConflictStatusCode"><code>ConflictStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The solver found a conflict.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1849-L1857">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ConflictCount"><a class="docstring-binding" href="#MathOptInterface.ConflictCount"><code>MathOptInterface.ConflictCount</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConflictCount()</code></pre><p>An <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a> for the number of conflicts found by the solver in the most recent call to <a href="../../../api/JuMP/#compute_conflict!"><code>compute_conflict!</code></a>.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(::Optimizer, ::MOI.ConflictCount)::Int</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L1889-L1902">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ConstraintConflictStatus"><a class="docstring-binding" href="#MathOptInterface.ConstraintConflictStatus"><code>MathOptInterface.ConstraintConflictStatus</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConstraintConflictStatus(conflict_index = 1)</code></pre><p>A constraint attribute to query the <a href="#MathOptInterface.ConflictParticipationStatusCode"><code>ConflictParticipationStatusCode</code></a> indicating whether the constraint participates in the conflict.</p><p><strong><code>conflict_index</code></strong></p><p>The optimizer may return multiple conflicts. See <a href="#MathOptInterface.ConflictCount"><code>ConflictCount</code></a> for querying the number of conflicts found.</p><p>If the solver does not have a conflict because the <code>conflict_index</code> is beyond the available solutions (whose number is indicated by the <a href="#MathOptInterface.ConflictCount"><code>ConflictCount</code></a> attribute), then <code>MOI.check_result_index_bounds(model, ConstraintConflictStatus(conflict_index))</code> will throw a <a href="../errors/#MathOptInterface.ResultIndexBoundsError"><code>ResultIndexBoundsError</code></a>.</p><p><strong>Implementation</strong></p><p>Optimizers should implement the following methods:</p><pre><code class="language-julia hljs">MOI.get(
    ::Optimizer,
    ::MOI.ConstraintConflictStatus,
    ::MOI.ConstraintIndex,
)::ConflictParticipationStatusCode</code></pre><p>They should not implement <a href="#MathOptInterface.set"><code>set</code></a> or <a href="#MathOptInterface.supports"><code>supports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2735-L2763">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.ConflictParticipationStatusCode"><a class="docstring-binding" href="#MathOptInterface.ConflictParticipationStatusCode"><code>MathOptInterface.ConflictParticipationStatusCode</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConflictParticipationStatusCode</code></pre><p>An Enum for the value of the <a href="#MathOptInterface.ConstraintConflictStatus"><code>ConstraintConflictStatus</code></a> attribute.</p><p>This attribute is meant to indicate whether a given constraint participates or not in the last computed conflict.</p><p><strong>Values</strong></p><p><strong><a href="#MathOptInterface.NOT_IN_CONFLICT"><code>NOT_IN_CONFLICT</code></a></strong></p><p>The constraint does not participate in the conflict.</p><p><strong><a href="#MathOptInterface.IN_CONFLICT"><code>IN_CONFLICT</code></a></strong></p><p>The constraint participates in the conflict.</p><p><strong><a href="#MathOptInterface.MAYBE_IN_CONFLICT"><code>MAYBE_IN_CONFLICT</code></a></strong></p><p>The solver was not able to prove whether the constraint is required to    participate in the conflict.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2714-L2735">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.NOT_IN_CONFLICT"><a class="docstring-binding" href="#MathOptInterface.NOT_IN_CONFLICT"><code>MathOptInterface.NOT_IN_CONFLICT</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">NOT_IN_CONFLICT::ConflictParticipationStatusCode</code></pre><p>An instance of the <a href="#MathOptInterface.ConflictParticipationStatusCode"><code>ConflictParticipationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The constraint does not participate in the conflict.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2714-L2722">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.IN_CONFLICT"><a class="docstring-binding" href="#MathOptInterface.IN_CONFLICT"><code>MathOptInterface.IN_CONFLICT</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">IN_CONFLICT::ConflictParticipationStatusCode</code></pre><p>An instance of the <a href="#MathOptInterface.ConflictParticipationStatusCode"><code>ConflictParticipationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The constraint participates in the conflict.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2714-L2722">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathOptInterface.MAYBE_IN_CONFLICT"><a class="docstring-binding" href="#MathOptInterface.MAYBE_IN_CONFLICT"><code>MathOptInterface.MAYBE_IN_CONFLICT</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">MAYBE_IN_CONFLICT::ConflictParticipationStatusCode</code></pre><p>An instance of the <a href="#MathOptInterface.ConflictParticipationStatusCode"><code>ConflictParticipationStatusCode</code></a> enum.</p><p><strong>About</strong></p><p>The solver was not able to prove whether the constraint is required to participate in the conflict.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/v1.48.0/src/attributes.jl#L2714-L2724">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../standard_form/">« Standard form</a><a class="docs-footer-nextpage" href="../variables/">Variables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 7 January 2026 20:52">Wednesday 7 January 2026</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
