var documenterSearchIndex = {"docs":
[{"location":"tutorials/Semidefinite programs/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Semidefinite programs/robust_uncertainty.jl\"","category":"page"},{"location":"tutorials/Semidefinite programs/robust_uncertainty/#Robust-uncertainty-sets","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"Computes the Value at Risk for a data-driven uncertainty set; see \"Data-Driven Robust Optimization\" (Bertsimas 2013), section 6.1 for details. Closed-form expressions for the optimal value are available.","category":"page"},{"location":"tutorials/Semidefinite programs/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"using JuMP\nimport SCS\nimport LinearAlgebra\nimport Test\n\nfunction example_robust_uncertainty()\n    R = 1\n    d = 3\n    ùõø = 0.05\n    …õ = 0.05\n    N = ceil((2 + 2 * log(2 / ùõø))^2) + 1\n    c = randn(d)\n    Œºhat = rand(d)\n    M = rand(d, d)\n    Œ£hat = 1 / (d - 1) * (M - ones(d) * Œºhat')' * (M - ones(d) * Œºhat')\n    Œì1(ùõø, N) = R / sqrt(N) * (2 + sqrt(2 * log(1 / ùõø)))\n    Œì2(ùõø, N) = 2 * R^2 / sqrt(N) * (2 + sqrt(2 * log(2 / ùõø)))\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, Œ£[1:d, 1:d], PSD)\n    @variable(model, u[1:d])\n    @variable(model, Œº[1:d])\n    @constraint(model, [Œì1(ùõø / 2, N); Œº - Œºhat] in SecondOrderCone())\n    @constraint(model, [Œì2(ùõø / 2, N); vec(Œ£ - Œ£hat)] in SecondOrderCone())\n    @SDconstraint(model, [((1 - …õ) / …õ) (u - Œº)'; (u - Œº) Œ£] >= 0)\n    @objective(model, Max, LinearAlgebra.dot(c, u))\n    optimize!(model)\n    I = Matrix(1.0 * LinearAlgebra.I, d, d)\n    exact =\n        LinearAlgebra.dot(Œºhat, c) +\n        Œì1(ùõø / 2, N) * LinearAlgebra.norm(c) +\n        sqrt((1 - …õ) / …õ) * sqrt(LinearAlgebra.dot(c, (Œ£hat + Œì2(ùõø / 2, N) * I) * c))\n    Test.@test objective_value(model) ‚âà exact atol = 1e-3\n    return\nend\n\nexample_robust_uncertainty()","category":"page"},{"location":"tutorials/Semidefinite programs/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"View this file on Github.","category":"page"},{"location":"tutorials/Semidefinite programs/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"","category":"page"},{"location":"tutorials/Semidefinite programs/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Getting started/solvers_and_solutions.jl\"","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#Solvers-and-Solutions","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"The purpose of this part of the tutorial is to introduce you to solvers and how to use them with JuMP. We'll also learn what to do with a problem after the solver has finished optimizing it.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#What-is-a-Solver?","page":"Solvers and Solutions","title":"What is a Solver?","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"A solver is a software package that incorporates algorithms for finding solutions to one or more classes of problem. For example, GLPK, which we used in the previous tutorials is a solver for linear programming (LP) and mixed integer programming (MIP) problems. It incorporates algorithms such as the simplex method, interior-point method etc. JuMP currently supports a number of open-source and commercial solvers which can be viewed in the Supported-solvers table.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#What-is-MathOptInterface?","page":"Solvers and Solutions","title":"What is MathOptInterface?","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Each mathematical optimization solver API has its own concepts and data structures for representing optimization models and obtaining results. However, it is often desirable to represent an instance of an optimization problem at a higher level so that it is easy to try using different solvers.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"MathOptInterface (MOI) is an abstraction layer designed to provide an interface to mathematical optimization solvers so that users do not need to understand multiple solver-specific APIs. MOI can be used directly, or through a higher-level modeling interface like JuMP.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Note that JuMP re-exports MathOptInterface and you can use the shortcut MOI to refer to MathOptInterface in your code.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#Constructing-a-model","page":"Solvers and Solutions","title":"Constructing a model","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"JuMP models can be created in three different modes: AUTOMATIC, MANUAL and DIRECT. We'll use the following LP to illustrate them.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"beginaligned\n max_xy  x + 2y \n textst  x + y leq 1 \n  0leq x y leq 1 \nendaligned","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"using JuMP\nusing GLPK","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#AUTOMATIC-Mode","page":"Solvers and Solutions","title":"AUTOMATIC Mode","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/#With-Optimizer","page":"Solvers and Solutions","title":"With Optimizer","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"This is the easiest method to use a solver in JuMP. In order to do so, we simply set the solver inside the Model constructor.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"model_auto = Model(GLPK.Optimizer)\n@variable(model_auto, 0 <= x <= 1)\n@variable(model_auto, 0 <= y <= 1)\n@constraint(model_auto, x + y <= 1)\n@objective(model_auto, Max, x + 2y)\noptimize!(model_auto)\nobjective_value(model_auto)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#No-Optimizer-(at-first)","page":"Solvers and Solutions","title":"No Optimizer (at first)","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"It is also possible to create a JuMP model with no optimizer attached. After the model object is initialized empty and all its variables, constraints and objective are set, then we can attach the solver at optimize! time.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"model_auto_no = Model()\n@variable(model_auto_no, 0 <= x <= 1)\n@variable(model_auto_no, 0 <= y <= 1)\n@constraint(model_auto_no, x + y <= 1)\n@objective(model_auto_no, Max, x + 2y)\nset_optimizer(model_auto_no, GLPK.Optimizer)\noptimize!(model_auto_no)\nobjective_value(model_auto_no)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Note that we can also enforce the automatic mode by passing caching_mode = MOIU.AUTOMATIC in the Model function call.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#MANUAL-Mode","page":"Solvers and Solutions","title":"MANUAL Mode","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"This mode is similar to the AUTOMATIC mode, but there are less protections from the user getting errors from the solver API. On the other side, nothing happens silently, which might give the user more control. It requires attaching the solver before the solve step using the MOIU.attach_optimizer() function.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"model_manual = Model(GLPK.Optimizer, caching_mode = MOIU.MANUAL)\n@variable(model_manual, 0 <= x <= 1)\n@variable(model_manual, 0 <= y <= 1)\n@constraint(model_manual, x + y <= 1)\n@objective(model_manual, Max, x + 2y)\nMOIU.attach_optimizer(model_manual)\noptimize!(model_manual)\nobjective_value(model_manual)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#DIRECT-Mode","page":"Solvers and Solutions","title":"DIRECT Mode","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Some solvers are able to handle the problem data directly. This is common for LP/MIP solver but not very common for open-source conic solvers. In this case we do not set a optimizer, we set a backend which is more generic and is able to hold data and not only solving a model.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"model_direct = direct_model(GLPK.Optimizer())\n@variable(model_direct, 0 <= x <= 1)\n@variable(model_direct, 0 <= y <= 1)\n@constraint(model_direct, x + y <= 1)\n@objective(model_direct, Max, x + 2y)\noptimize!(model_direct)\nobjective_value(model_direct)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#Solver-Options","page":"Solvers and Solutions","title":"Solver Options","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Many of the solvers also allow options to be passed in. However, these options are solver-specific. To find out the various options available, please check out the individual solver packages. Some examples for the GLPK solver are given below.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"using GLPK","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"To turn off printing (i.e. silence the solver),","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"model = Model(optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 0));\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"To increase the maximum number of simplex iterations:","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"model = Model(optimizer_with_attributes(GLPK.Optimizer, \"it_lim\" => 10_000));\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"To set the solution timeout limit (in milliseconds):","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"model = Model(optimizer_with_attributes(GLPK.Optimizer, \"tm_lim\" => 5_000));\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#How-to-querying-the-solution","page":"Solvers and Solutions","title":"How to querying the solution","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"So far we have seen all the elements and constructs related to writing a JuMP optimization model. In this section we reach the point of what to do with a solved problem. JuMP follows closely the concepts defined in MathOptInterface to answer user questions about a finished call to optimize!(model). The three main steps in querying a solution are given below. We'll use the model we created in AUTOMATIC mode with an optimizer attached in this section.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#The-termination-status","page":"Solvers and Solutions","title":"The termination status","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Termination statuses are meant to explain the reason why the optimizer stopped executing in the most recent call to optimize!.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"termination_status(model_auto)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"You can view the different termination status codes by referring to the docs or though checking the possible types using the below command.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"display(typeof(MOI.OPTIMAL))","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#The-primal-and-dual-status","page":"Solvers and Solutions","title":"The primal and dual status","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"These statuses indicate what kind of result is available to be queried from the model. It's possible that no result is available to be queried. We shall discuss more on the dual status and solutions in the Duality tutorial.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"primal_status(model_auto)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"dual_status(model_auto)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"As we saw before, the result (solution) status codes can be viewed directly from Julia.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"display(typeof(MOI.FEASIBLE_POINT))","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#Getting-the-primal-solution","page":"Solvers and Solutions","title":"Getting the primal solution","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Provided the primal status is not MOI.NO_SOLUTION, we can inspect the solution values and optimal cost.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"value(x)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"value(y)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"objective_value(model_auto)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Since it is possible that no solution is available to be queried from the model, calls to value may throw errors. Hence, it is recommended to check for the presence of solutions.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"model_no_solution = Model(GLPK.Optimizer)\n@variable(model_no_solution, 0 <= x <= 1)\n@variable(model_no_solution, 0 <= y <= 1)\n@constraint(model_no_solution, x + y >= 3)\n@objective(model_no_solution, Max, x + 2y)\n\noptimize!(model_no_solution)\n\ntry #hide\nif termination_status(model_no_solution) == MOI.OPTIMAL\n    optimal_solution = value(x)\n    optimal_objective = objective_value(model_no_solution)\nelseif termination_status(model_no_solution) == MOI.TIME_LIMIT && has_values(model_no_solution)\n    suboptimal_solution = value(x)\n    suboptimal_objective = objective_value(model_no_solution)\nelse\n    error(\"The model was not solved correctly.\")\nend\ncatch err; showerror(stderr, err); end  #hide","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"View this file on Github.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"moi/submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\n\n    # For compatibility with both Julia 1.0.5 and 1.5.2\n    # Upon the Julia LTS version becoming 1.6, these imports could be dropped,\n    # and all ScalarAffineTerm and VariableIndex instances in doctests below\n    # could be replaced with MOI.ScalarAffineTerm and MOI.VariableIndex\n    # Check discussion at PR 1184: https://github.com/jump-dev/MathOptInterface.jl/pull/1184#discussion_r515300914\n    import MathOptInterface.ScalarAffineTerm\n    import MathOptInterface.VariableIndex\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/FileFormats/reference/#File-Formats","page":"API Reference","title":"File Formats","text":"","category":"section"},{"location":"moi/submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"Functions to help read and write MOI models to/from various file formats. See The FileFormats submodule for more details.","category":"page"},{"location":"moi/submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"FileFormats.Model\nFileFormats.FileFormat","category":"page"},{"location":"moi/submodules/FileFormats/reference/#MathOptInterface.FileFormats.Model","page":"API Reference","title":"MathOptInterface.FileFormats.Model","text":"Model(\n    ;\n    format::FileFormat = FORMAT_AUTOMATIC,\n    filename::Union{Nothing, String} = nothing,\n    kwargs...\n)\n\nReturn model corresponding to the FileFormat format, or, if format == FORMAT_AUTOMATIC, guess the format from filename.\n\nThe filename argument is only needed if format == FORMAT_AUTOMATIC.\n\nkwargs are passed to the underlying model constructor.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/FileFormats/reference/#MathOptInterface.FileFormats.FileFormat","page":"API Reference","title":"MathOptInterface.FileFormats.FileFormat","text":"FileFormat\n\nList of accepted export formats.\n\nFORMAT_AUTOMATIC: try to detect the file format based on the file name\nFORMAT_CBF: the Conic Benchmark format\nFORMAT_LP: the LP file format\nFORMAT_MOF: the MathOptFormat file format\nFORMAT_MPS: the MPS file format\nFORMAT_SDPA: the SemiDefinite Programming Algorithm format\n\n\n\n\n\n","category":"type"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/solutions/#Solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"moi/manual/solutions/#Solving-and-retrieving-the-results","page":"Solutions","title":"Solving and retrieving the results","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Once an optimizer is loaded with the objective function and all of the constraints, we can ask the solver to solve the model by calling optimize!.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"MOI.optimize!(optimizer)","category":"page"},{"location":"moi/manual/solutions/#Why-did-the-solver-stop?","page":"Solutions","title":"Why did the solver stop?","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"The optimization procedure may terminate for a number of reasons. The TerminationStatus attribute of the optimizer returns a TerminationStatusCode object which explains why the solver stopped.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"The termination statuses distinguish between proofs of optimality, infeasibility, local convergence, limits, and termination because of something unexpected like invalid problem data or failure to converge.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"A typical usage of the TerminationStatus attribute is as follows:","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"status = MOI.get(optimizer, TerminationStatus())\nif status == MOI.OPTIMAL\n    # Ok, we solved the problem!\nelse\n    # Handle other cases.\nend","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"After checking the TerminationStatus, one should typically check ResultCount. This attribute returns the number of results that the solver has available to return. A result is defined as a primal-dual pair, but either the primal or the dual may be missing from the result. While the OPTIMAL termination status normally implies that at least one result is available, other statuses do not. For example, in the case of infeasiblity, a solver may return no result or a proof of infeasibility. The ResultCount attribute distinguishes between these two cases.","category":"page"},{"location":"moi/manual/solutions/#Primal-solutions","page":"Solutions","title":"Primal solutions","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Use the PrimalStatus optimizer attribute to return a ResultStatusCode describing the status of the primal solution.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Common returns are described below in the Common status situations section.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Query the primal solution using the VariablePrimal and ConstraintPrimal attributes.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Query the objective function value using the ObjectiveValue attribute.","category":"page"},{"location":"moi/manual/solutions/#Dual-solutions","page":"Solutions","title":"Dual solutions","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nSee Duality for a discussion of the MOI conventions for primal-dual pairs and certificates.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Use the DualStatus optimizer attribute to return a ResultStatusCode describing the status of the dual solution.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Query the dual solution using the ConstraintDual attribute.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Query the dual objective function value using the DualObjectiveValue attribute.","category":"page"},{"location":"moi/manual/solutions/#Common-status-situations","page":"Solutions","title":"Common status situations","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"The sections below describe how to interpret typical or interesting status cases for three common classes of solvers. The example cases are illustrative, not comprehensive. Solver wrappers may provide additional information on how the solver's statuses map to MOI statuses.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"info: Info\n* in the tables indicate that multiple different values are possible.","category":"page"},{"location":"moi/manual/solutions/#Primal-dual-convex-solver","page":"Solutions","title":"Primal-dual convex solver","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Linear programming and conic optimization solvers fall into this category.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"What happened? TerminationStatus ResultCount PrimalStatus DualStatus\nProved optimality OPTIMAL 1 FEASIBLE_POINT FEASIBLE_POINT\nProved infeasible INFEASIBLE 1 NO_SOLUTION INFEASIBILITY_CERTIFICATE\nOptimal within relaxed tolerances ALMOST_OPTIMAL 1 FEASIBLE_POINT FEASIBLE_POINT\nOptimal within relaxed tolerances ALMOST_OPTIMAL 1 ALMOST_FEASIBLE_POINT ALMOST_FEASIBLE_POINT\nDetected an unbounded ray of the primal DUAL_INFEASIBLE 1 INFEASIBILITY_CERTIFICATE NO_SOLUTION\nStall SLOW_PROGRESS 1 * *","category":"page"},{"location":"moi/manual/solutions/#Global-branch-and-bound-solvers","page":"Solutions","title":"Global branch-and-bound solvers","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Mixed-integer programming solvers fall into this category.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"What happened? TerminationStatus ResultCount PrimalStatus DualStatus\nProved optimality OPTIMAL 1 FEASIBLE_POINT NO_SOLUTION\nPresolve detected infeasibility or unboundedness INFEASIBLE_OR_UNBOUNDED 0 NO_SOLUTION NO_SOLUTION\nProved infeasibility INFEASIBLE 0 NO_SOLUTION NO_SOLUTION\nTimed out (no solution) TIME_LIMIT 0 NO_SOLUTION NO_SOLUTION\nTimed out (with a solution) TIME_LIMIT 1 FEASIBLE_POINT NO_SOLUTION\nCPXMIP_OPTIMAL_INFEAS ALMOST_OPTIMAL 1 INFEASIBLE_POINT NO_SOLUTION","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"info: Info\nCPXMIP_OPTIMAL_INFEAS is a CPLEX status that indicates that a preprocessed problem was solved to optimality, but the solver was unable to recover a feasible solution to the original problem. Handling this status was one of the motivating drivers behind the design of MOI.","category":"page"},{"location":"moi/manual/solutions/#Local-search-solvers","page":"Solutions","title":"Local search solvers","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Nonlinear programming solvers fall into this category. It also includes non-global tree search solvers like Juniper.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"What happened? TerminationStatus ResultCount PrimalStatus DualStatus\nConverged to a stationary point LOCALLY_SOLVED 1 FEASIBLE_POINT FEASIBLE_POINT\nCompleted a non-global tree search (with a solution) LOCALLY_SOLVED 1 FEASIBLE_POINT FEASIBLE_POINT\nConverged to an infeasible point LOCALLY_INFEASIBLE 1 INFEASIBLE_POINT *\nCompleted a non-global tree search (no solution found) LOCALLY_INFEASIBLE 0 NO_SOLUTION NO_SOLUTION\nIteration limit ITERATION_LIMIT 1 * *\nDiverging iterates NORM_LIMIT or OBJECTIVE_LIMIT 1 * *","category":"page"},{"location":"moi/reference/nonlinear/","page":"Nonlinear programming","title":"Nonlinear programming","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/reference/nonlinear/","page":"Nonlinear programming","title":"Nonlinear programming","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/nonlinear/#Nonlinear-programming","page":"Nonlinear programming","title":"Nonlinear programming","text":"","category":"section"},{"location":"moi/reference/nonlinear/#Types","page":"Nonlinear programming","title":"Types","text":"","category":"section"},{"location":"moi/reference/nonlinear/","page":"Nonlinear programming","title":"Nonlinear programming","text":"AbstractNLPEvaluator\nNLPBoundsPair\nNLPBlockData","category":"page"},{"location":"moi/reference/nonlinear/#MathOptInterface.AbstractNLPEvaluator","page":"Nonlinear programming","title":"MathOptInterface.AbstractNLPEvaluator","text":"AbstractNLPEvaluator\n\nAbstract supertype for the callback object used in NLPBlock.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#MathOptInterface.NLPBoundsPair","page":"Nonlinear programming","title":"MathOptInterface.NLPBoundsPair","text":"NLPBoundsPair(lower,upper)\n\nA struct holding a pair of lower and upper bounds. -Inf and Inf can be used to indicate no lower or upper bound, respectively.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#MathOptInterface.NLPBlockData","page":"Nonlinear programming","title":"MathOptInterface.NLPBlockData","text":"struct NLPBlockData\n    constraint_bounds::Vector{NLPBoundsPair}\n    evaluator::AbstractNLPEvaluator\n    has_objective::Bool\nend\n\nA struct encoding a set of nonlinear constraints of the form lb le g(x) le ub and, if has_objective == true, a nonlinear objective function f(x). constraint_bounds holds the pairs of lb and ub elements. Nonlinear objectives override any objective set by using the ObjectiveFunction attribute. The evaluator is a callback object that is used to query function values, derivatives, and expression graphs. If has_objective == false, then it is an error to query properties of the objective function, and in Hessian-of-the-Lagrangian queries, œÉ must be set to zero. Throughout the evaluator, all variables are ordered according to ListOfVariableIndices(). \n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#Attributes","page":"Nonlinear programming","title":"Attributes","text":"","category":"section"},{"location":"moi/reference/nonlinear/","page":"Nonlinear programming","title":"Nonlinear programming","text":"NLPBlock\nNLPBlockDual\nNLPBlockDualStart","category":"page"},{"location":"moi/reference/nonlinear/#MathOptInterface.NLPBlock","page":"Nonlinear programming","title":"MathOptInterface.NLPBlock","text":"NLPBlock()\n\nHolds the NLPBlockData that represents a set of nonlinear constraints, and optionally a nonlinear objective.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#MathOptInterface.NLPBlockDual","page":"Nonlinear programming","title":"MathOptInterface.NLPBlockDual","text":"NLPBlockDual(N)\nNLPBlockDual()\n\nThe Lagrange multipliers on the constraints from the NLPBlock in result N. If N is omitted, it is 1 by default.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#MathOptInterface.NLPBlockDualStart","page":"Nonlinear programming","title":"MathOptInterface.NLPBlockDualStart","text":"NLPBlockDualStart()\n\nAn initial assignment of the Lagrange multipliers on the constraints from the NLPBlock that the solver may use to warm-start the solve.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#Functions","page":"Nonlinear programming","title":"Functions","text":"","category":"section"},{"location":"moi/reference/nonlinear/","page":"Nonlinear programming","title":"Nonlinear programming","text":"initialize\nfeatures_available\neval_objective\neval_constraint\neval_objective_gradient\njacobian_structure\nhessian_lagrangian_structure\neval_constraint_jacobian\neval_constraint_jacobian_product\neval_constraint_jacobian_transpose_product\neval_hessian_lagrangian\neval_hessian_lagrangian_product\nobjective_expr\nconstraint_expr","category":"page"},{"location":"moi/reference/nonlinear/#MathOptInterface.initialize","page":"Nonlinear programming","title":"MathOptInterface.initialize","text":"initialize(d::AbstractNLPEvaluator, requested_features::Vector{Symbol})\n\nMust be called before any other methods. The vector requested_features lists features requested by the solver. These may include :Grad for gradients of f, :Jac for explicit Jacobians of g, :JacVec for Jacobian-vector products, :HessVec for Hessian-vector and Hessian-of-Lagrangian-vector products, :Hess for explicit Hessians and Hessian-of-Lagrangians, and :ExprGraph for expression graphs.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.features_available","page":"Nonlinear programming","title":"MathOptInterface.features_available","text":"features_available(d::AbstractNLPEvaluator)\n\nReturns the subset of features available for this problem instance, as a list of symbols in the same format as in initialize.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_objective","page":"Nonlinear programming","title":"MathOptInterface.eval_objective","text":"eval_objective(d::AbstractNLPEvaluator, x)\n\nEvaluate the objective f(x), returning a scalar value.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_constraint","page":"Nonlinear programming","title":"MathOptInterface.eval_constraint","text":"eval_constraint(d::AbstractNLPEvaluator, g, x)\n\nEvaluate the constraint function g(x), storing the result in the vector g which must be of the appropriate size.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_objective_gradient","page":"Nonlinear programming","title":"MathOptInterface.eval_objective_gradient","text":"eval_objective_gradient(d::AbstractNLPEvaluator, g, x)\n\nEvaluate nabla f(x) as a dense vector, storing the result in the vector g which must be of the appropriate size.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.jacobian_structure","page":"Nonlinear programming","title":"MathOptInterface.jacobian_structure","text":"jacobian_structure(d::AbstractNLPEvaluator)::Vector{Tuple{Int64,Int64}}\n\nReturns the sparsity structure of the Jacobian matrix J_g(x) = left beginarrayc nabla g_1(x)  nabla g_2(x)  vdots  nabla g_m(x) endarrayright where g_i is the itextth component of g. The sparsity structure is assumed to be independent of the point x. Returns a vector of tuples, (row, column), where each indicates the position of a structurally nonzero element. These indices are not required to be sorted and can contain duplicates, in which case the solver should combine the corresponding elements by adding them together.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.hessian_lagrangian_structure","page":"Nonlinear programming","title":"MathOptInterface.hessian_lagrangian_structure","text":"hessian_lagrangian_structure(d::AbstractNLPEvaluator)::Vector{Tuple{Int64,Int64}}\n\nReturns the sparsity structure of the Hessian-of-the-Lagrangian matrix nabla^2 f + sum_i=1^m nabla^2 g_i as a vector of tuples, where each indicates the position of a structurally nonzero element. These indices are not required to be sorted and can contain duplicates, in which case the solver should combine the corresponding elements by adding them together. Any mix of lower and upper-triangular indices is valid. Elements (i,j) and (j,i), if both present, should be treated as duplicates.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_constraint_jacobian","page":"Nonlinear programming","title":"MathOptInterface.eval_constraint_jacobian","text":"eval_constraint_jacobian(d::AbstractNLPEvaluator, J, x)\n\nEvaluates the sparse Jacobian matrix J_g(x) = left beginarrayc nabla g_1(x)  nabla g_2(x)  vdots  nabla g_m(x) endarrayright. The result is stored in the vector J in the same order as the indices returned by jacobian_structure.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_constraint_jacobian_product","page":"Nonlinear programming","title":"MathOptInterface.eval_constraint_jacobian_product","text":"eval_constraint_jacobian_product(d::AbstractNLPEvaluator, y, x, w)\n\nComputes the Jacobian-vector product J_g(x)w, storing the result in the vector y.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_constraint_jacobian_transpose_product","page":"Nonlinear programming","title":"MathOptInterface.eval_constraint_jacobian_transpose_product","text":"eval_constraint_jacobian_transpose_product(d::AbstractNLPEvaluator, y, x, w)\n\nComputes the Jacobian-transpose-vector product J_g(x)^Tw, storing the result in the vector y.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_hessian_lagrangian","page":"Nonlinear programming","title":"MathOptInterface.eval_hessian_lagrangian","text":"eval_hessian_lagrangian(d::AbstractNLPEvaluator, H, x, œÉ, Œº)\n\nGiven scalar weight œÉ and vector of constraint weights Œº, computes the sparse Hessian-of-the-Lagrangian matrix sigmanabla^2 f(x) + sum_i=1^m mu_i nabla^2 g_i(x), storing the result in the vector H in the same order as the indices returned by hessian_lagrangian_structure.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_hessian_lagrangian_product","page":"Nonlinear programming","title":"MathOptInterface.eval_hessian_lagrangian_product","text":"eval_hessian_lagrangian_product(d::AbstractNLPEvaluator, h, x, v, œÉ, Œº)\n\nGiven scalar weight œÉ and vector of constraint weights Œº, computes the Hessian-of-the-Lagrangian-vector product left(sigmanabla^2 f(x) + sum_i=1^m mu_i nabla^2 g_i(x)right)v, storing the result in the vector h.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.objective_expr","page":"Nonlinear programming","title":"MathOptInterface.objective_expr","text":"objective_expr(d::AbstractNLPEvaluator)\n\nReturns an expression graph for the objective function as a standard Julia Expr object. All sums and products are flattened out as simple Expr(:+,...) and Expr(:*,...) objects. The symbol x is used as a placeholder for the vector of decision variables. No other undefined symbols are permitted; coefficients are embedded as explicit values. For example, the expression x_1+sin(x_2exp(x_3)) would be represented as the Julia object :(x[1] + sin(x[2]/exp(x[3]))). Each integer index is wrapped in a VariableIndex. See the Julia manual for more information on the structure of Expr objects. There are currently no restrictions on recognized functions; typically these will be built-in Julia functions like ^, exp, log, cos, tan, sqrt, etc., but modeling interfaces may choose to extend these basic functions.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.constraint_expr","page":"Nonlinear programming","title":"MathOptInterface.constraint_expr","text":"constraint_expr(d::AbstractNLPEvaluator, i)\n\nReturns an expression graph for the itextth constraint in the same format as described above, with an additional comparison operator indicating the sense of and bounds on the constraint. The right-hand side of the comparison must be a constant; that is, :(x[1]^3 <= 1) is allowed, while :(1 <= x[1]^3) is not valid. Double-sided constraints are allowed, in which case both the lower bound and upper bounds should be constants; for example, :(-1 <= cos(x[1]) + sin(x[2]) <= 1) is valid.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/Mixed-integer linear programs/transp/","page":"The transportation problem","title":"The transportation problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/transp.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/transp/#The-transportation-problem","page":"The transportation problem","title":"The transportation problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/transp/","page":"The transportation problem","title":"The transportation problem","text":"Allocation of passenger cars to trains to minimize cars required or car-miles run. Based on:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/transp/","page":"The transportation problem","title":"The transportation problem","text":"Fourer, D.M. Gay and Brian W. Kernighan, A Modeling Language for Mathematical Programming, https://ampl.com/REFS/amplmod.ps.gz Appendix D.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/transp/","page":"The transportation problem","title":"The transportation problem","text":"Originally contributed by Louis Luangkesorn, January 30, 2015.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/transp/","page":"The transportation problem","title":"The transportation problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_transp()\n\tORIG = [\"GARY\", \"CLEV\", \"PITT\"]\n\tDEST = [\"FRA\", \"DET\", \"LAN\", \"WIN\", \"STL\", \"FRE\", \"LAF\"]\n\tsupply = [1_400, 2_600, 2_900]\n\tdemand = [900, 1_200, 600, 400, 1_700, 1_100, 1_000]\n\tTest.@test sum(supply) == sum(demand)\n\tcost = [\n\t\t39   14   11   14   16   82    8;\n\t\t27    9   12    9   26   95   17;\n\t\t24   14   17   13   28   99   20\n\t]\n\tmodel = Model(GLPK.Optimizer)\n\t@variable(model, trans[1:length(ORIG), 1:length(DEST)] >= 0)\n\t@objective(\n\t\tmodel,\n\t\tMin,\n\t\tsum(\n\t\t\tcost[i, j] * trans[i, j]\n\t\t\tfor i in 1:length(ORIG), j in 1:length(DEST)\n\t\t)\n\t)\n\t@constraints(model, begin\n\t\t[i in 1:length(ORIG)], sum(trans[i, :]) == supply[i]\n\t\t[j in 1:length(DEST)], sum(trans[:, j]) == demand[j]\n\tend)\n\toptimize!(model)\n\tTest.@test termination_status(model) == MOI.OPTIMAL\n\tTest.@test primal_status(model) == MOI.FEASIBLE_POINT\n\tTest.@test objective_value(model) == 196200.0\n\tprintln(\"The optimal solution is:\")\n\tprintln(value.(trans))\n\treturn\nend\n\nexample_transp()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/transp/","page":"The transportation problem","title":"The transportation problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/transp/","page":"The transportation problem","title":"The transportation problem","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/transp/","page":"The transportation problem","title":"The transportation problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/containers/#ContainersAPI","page":"Containers","title":"Containers","text":"","category":"section"},{"location":"reference/containers/","page":"Containers","title":"Containers","text":"More information can be found in the Containers section of the manual.","category":"page"},{"location":"reference/containers/","page":"Containers","title":"Containers","text":"Containers\nContainers.DenseAxisArray\nContainers.SparseAxisArray\nContainers.container\nContainers.default_container\nContainers.VectorizedProductIterator\nContainers.NestedIterator\nContainers.@container","category":"page"},{"location":"reference/containers/#JuMP.Containers","page":"Containers","title":"JuMP.Containers","text":"Containers\n\nModule defining the containers DenseAxisArray and SparseAxisArray that behaves as a regular AbstractArray but with custom indexes that are not necessarily integers.\n\n\n\n\n\n","category":"module"},{"location":"reference/containers/#JuMP.Containers.DenseAxisArray","page":"Containers","title":"JuMP.Containers.DenseAxisArray","text":"DenseAxisArray(data::Array{T, N}, axes...) where {T, N}\n\nConstruct a JuMP array with the underlying data specified by the data array and the given axes. Exactly N axes must be provided, and their lengths must match size(data) in the corresponding dimensions.\n\nExample\n\njulia> array = JuMP.Containers.DenseAxisArray([1 2; 3 4], [:a, :b], 2:3)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 2:3\nAnd data, a 2√ó2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> array[:b, 3]\n4\n\n\n\n\n\nDenseAxisArray{T}(undef, axes...) where T\n\nConstruct an uninitialized DenseAxisArray with element-type T indexed over the given axes.\n\nExample\n\njulia> array = JuMP.Containers.DenseAxisArray{Float64}(undef, [:a, :b], 1:2);\n\njulia> fill!(array, 1.0)\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 1:2\nAnd data, a 2√ó2 Array{Float64,2}:\n 1.0  1.0\n 1.0  1.0\n\njulia> array[:a, 2] = 5.0\n5.0\n\njulia> array[:a, 2]\n5.0\n\njulia> array\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 1:2\nAnd data, a 2√ó2 Array{Float64,2}:\n 1.0  5.0\n 1.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"reference/containers/#JuMP.Containers.SparseAxisArray","page":"Containers","title":"JuMP.Containers.SparseAxisArray","text":"struct SparseAxisArray{T,N,K<:NTuple{N, Any}} <: AbstractArray{T,N}\n    data::Dict{K,T}\nend\n\nN-dimensional array with elements of type T where only a subset of the entries are defined. The entries with indices idx = (i1, i2, ..., iN) in keys(data) has value data[idx]. Note that as opposed to SparseArrays.AbstractSparseArray, the missing entries are not assumed to be zero(T), they are simply not part of the array. This means that the result of map(f, sa::SparseAxisArray) or f.(sa::SparseAxisArray) has the same sparsity structure than sa even if f(zero(T)) is not zero.\n\nExample\n\njulia> dict = Dict((:a, 2) => 1.0, (:a, 3) => 2.0, (:b, 3) => 3.0)\nDict{Tuple{Symbol,Int64},Float64} with 3 entries:\n  (:b, 3) => 3.0\n  (:a, 2) => 1.0\n  (:a, 3) => 2.0\n\njulia> array = JuMP.Containers.SparseAxisArray(dict)\nJuMP.Containers.SparseAxisArray{Float64,2,Tuple{Symbol,Int64}} with 3 entries:\n  [b, 3]  =  3.0\n  [a, 2]  =  1.0\n  [a, 3]  =  2.0\n\njulia> array[:b, 3]\n3.0\n\n\n\n\n\n","category":"type"},{"location":"reference/containers/#JuMP.Containers.container","page":"Containers","title":"JuMP.Containers.container","text":"container(f::Function, indices, ::Type{C})\n\nCreate a container of type C with indices indices and values at given indices given by f.\n\ncontainer(f::Function, indices)\n\nCreate a container with indices indices and values at given indices given by f. The type of container used is determined by default_container.\n\nExamples\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(Base.OneTo(3), Base.OneTo(3)))\n3√ó3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(1:3, 1:3))\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, 1:3\nAnd data, a 3√ó3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(2:3, Base.OneTo(3)))\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, Base.OneTo(3)\nAnd data, a 2√ó3 Array{Int64,2}:\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.nested(() -> 1:3, i -> i:3, condition = (i, j) -> isodd(i) || isodd(j)))\nSparseAxisArray{Int64,2,Tuple{Int64,Int64}} with 5 entries:\n  [1, 2]  =  3\n  [2, 3]  =  5\n  [3, 3]  =  6\n  [1, 1]  =  2\n  [1, 3]  =  4\n\n\n\n\n\n","category":"function"},{"location":"reference/containers/#JuMP.Containers.default_container","page":"Containers","title":"JuMP.Containers.default_container","text":"default_container(indices)\n\nIf indices is a NestedIterator, return a SparseAxisArray. Otherwise, indices should be a VectorizedProductIterator and the function returns Array if all iterators of the product are Base.OneTo and retunrs DenseAxisArray otherwise.\n\n\n\n\n\n","category":"function"},{"location":"reference/containers/#JuMP.Containers.VectorizedProductIterator","page":"Containers","title":"JuMP.Containers.VectorizedProductIterator","text":"struct VectorizedProductIterator{T}\n    prod::Iterators.ProductIterator{T}\nend\n\nCartesian product of the iterators prod.iterators. It is the same iterator as Base.Iterators.ProductIterator except that it is independent of the IteratorSize of the elements of prod.iterators. For instance:\n\nsize(Iterators.product(1, 2)) is tuple() while size(VectorizedProductIterator(1, 2)) is (1, 1).\nsize(Iterators.product(ones(2, 3))) is (2, 3) while size(VectorizedProductIterator(ones(2, 3))) is (1, 1).\n\n\n\n\n\n","category":"type"},{"location":"reference/containers/#JuMP.Containers.NestedIterator","page":"Containers","title":"JuMP.Containers.NestedIterator","text":"struct NestedIterator{T}\n    iterators::T # Tuple of functions\n    condition::Function\nend\n\nIterators over the tuples that are produced by a nested for loop. For instance, if length(iterators) == 3 , this corresponds to the tuples (i1, i2, i3) produced by:\n\nfor i1 in iterators[1]()\n    for i2 in iterator[2](i1)\n        for i3 in iterator[3](i1, i2)\n            if condition(i1, i2, i3)\n                # produces (i1, i2, i3)\n            end\n        end\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/containers/#JuMP.Containers.@container","page":"Containers","title":"JuMP.Containers.@container","text":"@container([i=..., j=..., ...], expr)\n\nCreate a container with indices i, j, ... and values given by expr that may depend on the value of the indices.\n\n@container(ref[i=..., j=..., ...], expr)\n\nSame as above but the container is assigned to the variable of name ref.\n\nThe type of container can be controlled by the container keyword. Note that when the index set is explicitly given as 1:n for any expression n, it is transformed to Base.OneTo(n) before being given to container.\n\nExamples\n\njulia> Containers.@container([i = 1:3, j = 1:3], i + j)\n3√ó3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> I = 1:3\n1:3\n\njulia> Containers.@container([i = I, j = I], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, 1:3\nAnd data, a 3√ó3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.@container([i = 2:3, j = 1:3], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, Base.OneTo(3)\nAnd data, a 2√ó3 Array{Int64,2}:\n 3  4  5\n 4  5  6\n\njulia> Containers.@container([i = 1:3, j = 1:3; i <= j], i + j)\nJuMP.Containers.SparseAxisArray{Int64,2,Tuple{Int64,Int64}} with 6 entries:\n  [1, 2]  =  3\n  [2, 3]  =  5\n  [3, 3]  =  6\n  [2, 2]  =  4\n  [1, 1]  =  2\n  [1, 3]  =  4\n\n\n\n\n\n","category":"macro"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"moi/reference/models/#Attribute-interface","page":"Models","title":"Attribute interface","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"is_set_by_optimize\nis_copyable\nget\nget!\nset\nsupports","category":"page"},{"location":"moi/reference/models/#MathOptInterface.is_set_by_optimize","page":"Models","title":"MathOptInterface.is_set_by_optimize","text":"is_set_by_optimize(::AnyAttribute)\n\nReturn a Bool indicating whether the value of the attribute is modified during an optimize! call, that is, the attribute is used to query the result of the optimization.\n\nImportant note when defining new attributes\n\nThis function returns false by default so it should be implemented for attributes that are modified by optimize!.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.is_copyable","page":"Models","title":"MathOptInterface.is_copyable","text":"is_copyable(::AnyAttribute)\n\nReturn a Bool indicating whether the value of the attribute may be copied during copy_to using set.\n\nImportant note when defining new attributes\n\nBy default is_copyable(attr) returns !is_set_by_optimize(attr). A specific method should be defined for attributes which are copied indirectly during copy_to. For instance, both is_copyable and is_set_by_optimize return false for the following attributes:\n\nListOfOptimizerAttributesSet, ListOfModelAttributesSet, ListOfConstraintAttributesSet and ListOfVariableAttributesSet.\nSolverName and RawSolver: these attributes cannot be set.\nNumberOfVariables and ListOfVariableIndices: these attributes are set indirectly by add_variable and add_variables.\nObjectiveFunctionType: this attribute is set indirectly when setting the ObjectiveFunction attribute.\nNumberOfConstraints, ListOfConstraintIndices, ListOfConstraints, CanonicalConstraintFunction, ConstraintFunction and ConstraintSet: these attributes are set indirectly by add_constraint and add_constraints.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.get","page":"Models","title":"MathOptInterface.get","text":"get(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute)\n\nReturn an attribute attr of the optimizer optimizer.\n\nget(model::ModelLike, attr::AbstractModelAttribute)\n\nReturn an attribute attr of the model model.\n\nget(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex)\n\nIf the attribute attr is set for the variable v in the model model, return its value, return nothing otherwise. If the attribute attr is not supported by model then an error should be thrown instead of returning nothing.\n\nget(model::ModelLike, attr::AbstractVariableAttribute, v::Vector{VariableIndex})\n\nReturn a vector of attributes corresponding to each variable in the collection v in the model model.\n\nget(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex)\n\nIf the attribute attr is set for the constraint c in the model model, return its value, return nothing otherwise. If the attribute attr is not supported by model then an error should be thrown instead of returning nothing.\n\nget(model::ModelLike, attr::AbstractConstraintAttribute, c::Vector{ConstraintIndex{F,S}})\n\nReturn a vector of attributes corresponding to each constraint in the collection c in the model model.\n\nget(model::ModelLike, ::Type{VariableIndex}, name::String)\n\nIf a variable with name name exists in the model model, return the corresponding index, otherwise return nothing. Errors if two variables have the same name.\n\nget(model::ModelLike, ::Type{ConstraintIndex{F,S}}, name::String) where {F<:AbstractFunction,S<:AbstractSet}\n\nIf an F-in-S constraint with name name exists in the model model, return the corresponding index, otherwise return nothing. Errors if two constraints have the same name.\n\nget(model::ModelLike, ::Type{ConstraintIndex}, name::String)\n\nIf any constraint with name name exists in the model model, return the corresponding index, otherwise return nothing. This version is available for convenience but may incur a performance penalty because it is not type stable. Errors if two constraints have the same name.\n\nExamples\n\nget(model, ObjectiveValue())\nget(model, VariablePrimal(), ref)\nget(model, VariablePrimal(5), [ref1, ref2])\nget(model, OtherAttribute(\"something specific to cplex\"))\nget(model, VariableIndex, \"var1\")\nget(model, ConstraintIndex{ScalarAffineFunction{Float64},LessThan{Float64}}, \"con1\")\nget(model, ConstraintIndex, \"con1\")\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.get!","page":"Models","title":"MathOptInterface.get!","text":"get!(output, model::ModelLike, args...)\n\nAn in-place version of get. The signature matches that of get except that the the result is placed in the vector output.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.set","page":"Models","title":"MathOptInterface.set","text":"set(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute, value)\n\nAssign value to the attribute attr of the optimizer optimizer.\n\nset(model::ModelLike, attr::AbstractModelAttribute, value)\n\nAssign value to the attribute attr of the model model.\n\nset(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex, value)\n\nAssign value to the attribute attr of variable v in model model.\n\nset(model::ModelLike, attr::AbstractVariableAttribute, v::Vector{VariableIndex}, vector_of_values)\n\nAssign a value respectively to the attribute attr of each variable in the collection v in model model.\n\nset(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex, value)\n\nAssign a value to the attribute attr of constraint c in model model.\n\nset(model::ModelLike, attr::AbstractConstraintAttribute, c::Vector{ConstraintIndex{F,S}}, vector_of_values)\n\nAssign a value respectively to the attribute attr of each constraint in the collection c in model model.\n\nAn UnsupportedAttribute error is thrown if model does not support the attribute attr (see supports) and a SetAttributeNotAllowed error is thrown if it supports the attribute attr but it cannot be set.\n\nReplace set in a constraint\n\nset(model::ModelLike, ::ConstraintSet, c::ConstraintIndex{F,S}, set::S)\n\nChange the set of constraint c to the new set set which should be of the same type as the original set.\n\nExamples\n\nIf c is a ConstraintIndex{F,Interval}\n\nset(model, ConstraintSet(), c, Interval(0, 5))\nset(model, ConstraintSet(), c, GreaterThan(0.0))  # Error\n\nReplace function in a constraint\n\nset(model::ModelLike, ::ConstraintFunction, c::ConstraintIndex{F,S}, func::F)\n\nReplace the function in constraint c with func. F must match the original function type used to define the constraint.\n\nNote\n\nSetting the constraint function is not allowed if F is SingleVariable, it throws a SettingSingleVariableFunctionNotAllowed error. Indeed, it would require changing the index c as the index of SingleVariable constraints should be the same as the index of the variable.\n\nExamples\n\nIf c is a ConstraintIndex{ScalarAffineFunction,S} and v1 and v2 are VariableIndex objects,\n\nset(model, ConstraintFunction(), c,\n    ScalarAffineFunction(ScalarAffineTerm.([1.0, 2.0], [v1, v2]), 5.0))\nset(model, ConstraintFunction(), c, SingleVariable(v1)) # Error\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.supports","page":"Models","title":"MathOptInterface.supports","text":"supports(model::ModelLike, sub::AbstractSubmittable)::Bool\n\nReturn a Bool indicating whether model supports the submittable sub.\n\nsupports(model::ModelLike, attr::AbstractOptimizerAttribute)::Bool\n\nReturn a Bool indicating whether model supports the optimizer attribute attr. That is, it returns false if copy_to(model, src) shows a warning in case attr is in the ListOfOptimizerAttributesSet of src; see copy_to for more details on how unsupported optimizer attributes are handled in copy.\n\nsupports(model::ModelLike, attr::AbstractModelAttribute)::Bool\n\nReturn a Bool indicating whether model supports the model attribute attr. That is, it returns false if copy_to(model, src) cannot be performed in case attr is in the ListOfModelAttributesSet of src.\n\nsupports(model::ModelLike, attr::AbstractVariableAttribute, ::Type{VariableIndex})::Bool\n\nReturn a Bool indicating whether model supports the variable attribute attr. That is, it returns false if copy_to(model, src) cannot be performed in case attr is in the ListOfVariableAttributesSet of src.\n\nsupports(model::ModelLike, attr::AbstractConstraintAttribute, ::Type{ConstraintIndex{F,S}})::Bool where {F,S}\n\nReturn a Bool indicating whether model supports the constraint attribute attr applied to an F-in-S constraint. That is, it returns false if copy_to(model, src) cannot be performed in case attr is in the ListOfConstraintAttributesSet of src.\n\nFor all five methods, if the attribute is only not supported in specific circumstances, it should still return true.\n\nNote that supports is only defined for attributes for which is_copyable returns true as other attributes do not appear in the list of attributes set obtained by ListOf...AttributesSet.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#Model-interface","page":"Models","title":"Model interface","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"ModelLike\nis_empty\nempty!\nwrite_to_file\nread_from_file\ncopy_to","category":"page"},{"location":"moi/reference/models/#MathOptInterface.ModelLike","page":"Models","title":"MathOptInterface.ModelLike","text":"ModelLike\n\nAbstract supertype for objects that implement the \"Model\" interface for defining an optimization problem.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.is_empty","page":"Models","title":"MathOptInterface.is_empty","text":"is_empty(model::ModelLike)\n\nReturns false if the model has any model attribute set or has any variables or constraints. Note that an empty model can have optimizer attributes set.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.empty!","page":"Models","title":"MathOptInterface.empty!","text":"empty!(model::ModelLike)\n\nEmpty the model, that is, remove all variables, constraints and model attributes but not optimizer attributes.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.write_to_file","page":"Models","title":"MathOptInterface.write_to_file","text":"write_to_file(model::ModelLike, filename::String)\n\nWrites the current model data to the given file. Supported file types depend on the model type.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.read_from_file","page":"Models","title":"MathOptInterface.read_from_file","text":"read_from_file(model::ModelLike, filename::String)\n\nRead the file filename into the model model. If model is non-empty, this may throw an error.\n\nSupported file types depend on the model type.\n\nNote\n\nOnce the contents of the file are loaded into the model, users can query the variables via get(model, ListOfVariableIndices()). However, some filetypes, such as LP files, do not maintain an explicit ordering of the variables. Therefore, the returned list may be in an arbitrary order. To avoid depending on the order of the indices, users should look up each variable index by name: get(model, VariableIndex, \"name\").\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.copy_to","page":"Models","title":"MathOptInterface.copy_to","text":"copy_to(dest::ModelLike, src::ModelLike; copy_names=true, warn_attributes=true)\n\nCopy the model from src into dest. The target dest is emptied, and all previous indices to variables or constraints in dest are invalidated. Returns a dictionary-like object that translates variable and constraint indices from the src model to the corresponding indices in the dest model.\n\nIf copy_names is false, the Name, VariableName and ConstraintName attributes are not copied even if they are set in src. If a constraint that is copied from src is not supported by dest then an UnsupportedConstraint error is thrown. Similarly, if a model, variable or constraint attribute that is copied from src is not supported by dest then an UnsupportedAttribute error is thrown. Unsupported optimizer attributes are treated differently:\n\nIf warn_attributes is true, a warning is displayed, otherwise,\nthe attribute is silently ignored.\n\nExample\n\n# Given empty `ModelLike` objects `src` and `dest`.\n\nx = add_variable(src)\n\nis_valid(src, x)   # true\nis_valid(dest, x)  # false (`dest` has no variables)\n\nindex_map = copy_to(dest, src)\nis_valid(dest, x) # false (unless index_map[x] == x)\nis_valid(dest, index_map[x]) # true\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#Model-attributes","page":"Models","title":"Model attributes","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"AbstractModelAttribute\nName\nObjectiveFunction\nObjectiveFunctionType\nObjectiveSense\nNumberOfVariables\nListOfVariableIndices\nListOfConstraints\nNumberOfConstraints\nListOfConstraintIndices\nListOfOptimizerAttributesSet\nListOfModelAttributesSet\nListOfVariableAttributesSet\nListOfConstraintAttributesSet","category":"page"},{"location":"moi/reference/models/#MathOptInterface.AbstractModelAttribute","page":"Models","title":"MathOptInterface.AbstractModelAttribute","text":"AbstractModelAttribute\n\nAbstract supertype for attribute objects that can be used to set or get attributes (properties) of the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.Name","page":"Models","title":"MathOptInterface.Name","text":"Name()\n\nA model attribute for the string identifying the model. It has a default value of \"\" if not set`.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ObjectiveFunction","page":"Models","title":"MathOptInterface.ObjectiveFunction","text":"ObjectiveFunction{F<:AbstractScalarFunction}()\n\nA model attribute for the objective function which has a type F<:AbstractScalarFunction. F should be guaranteed to be equivalent but not necessarily identical to the function type provided by the user. Throws an InexactError if the objective function cannot be converted to F, e.g. the objective function is quadratic and F is ScalarAffineFunction{Float64} or it has non-integer coefficient and F is ScalarAffineFunction{Int}.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ObjectiveFunctionType","page":"Models","title":"MathOptInterface.ObjectiveFunctionType","text":"ObjectiveFunctionType()\n\nA model attribute for the type F of the objective function set using the ObjectiveFunction{F} attribute.\n\nExamples\n\nIn the following code, attr should be equal to MOI.SingleVariable:\n\nx = MOI.add_variable(model)\nMOI.set(model, MOI.ObjectiveFunction{MOI.SingleVariable}(),\n         MOI.SingleVariable(x))\nattr = MOI.get(model, MOI.ObjectiveFunctionType())\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ObjectiveSense","page":"Models","title":"MathOptInterface.ObjectiveSense","text":"ObjectiveSense()\n\nA model attribute for the objective sense of the objective function, which must be an OptimizationSense: MIN_SENSE, MAX_SENSE, or FEASIBILITY_SENSE. The default is FEASIBILITY_SENSE.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.NumberOfVariables","page":"Models","title":"MathOptInterface.NumberOfVariables","text":"NumberOfVariables()\n\nA model attribute for the number of variables in the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfVariableIndices","page":"Models","title":"MathOptInterface.ListOfVariableIndices","text":"ListOfVariableIndices()\n\nA model attribute for the Vector{VariableIndex} of all variable indices present in the model (i.e., of length equal to the value of NumberOfVariables()) in the order in which they were added.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfConstraints","page":"Models","title":"MathOptInterface.ListOfConstraints","text":"ListOfConstraints()\n\nA model attribute for the list of tuples of the form (F,S), where F is a function type and S is a set type indicating that the attribute NumberOfConstraints{F,S}() has value greater than zero.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.NumberOfConstraints","page":"Models","title":"MathOptInterface.NumberOfConstraints","text":"NumberOfConstraints{F,S}()\n\nA model attribute for the number of constraints of the type F-in-S present in the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfConstraintIndices","page":"Models","title":"MathOptInterface.ListOfConstraintIndices","text":"ListOfConstraintIndices{F,S}()\n\nA model attribute for the Vector{ConstraintIndex{F,S}} of all constraint indices of type F-in-S in the model (i.e., of length equal to the value of NumberOfConstraints{F,S}()) in the order in which they were added.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfOptimizerAttributesSet","page":"Models","title":"MathOptInterface.ListOfOptimizerAttributesSet","text":"ListOfOptimizerAttributesSet()\n\nAn optimizer attribute for the Vector{AbstractOptimizerAttribute} of all optimizer attributes that were set.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfModelAttributesSet","page":"Models","title":"MathOptInterface.ListOfModelAttributesSet","text":"ListOfModelAttributesSet()\n\nA model attribute for the Vector{AbstractModelAttribute} of all model attributes attr such that 1) is_copyable(attr) returns true and 2) the attribute was set to the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfVariableAttributesSet","page":"Models","title":"MathOptInterface.ListOfVariableAttributesSet","text":"ListOfVariableAttributesSet()\n\nA model attribute for the Vector{AbstractVariableAttribute} of all variable attributes attr such that 1) is_copyable(attr) returns true and 2) the attribute was set to variables.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfConstraintAttributesSet","page":"Models","title":"MathOptInterface.ListOfConstraintAttributesSet","text":"ListOfConstraintAttributesSet{F, S}()\n\nA model attribute for the Vector{AbstractConstraintAttribute} of all constraint attributes attr such that 1) is_copyable(attr) returns true and\n\nthe attribute was set to F-in-S constraints.\n\nNote\n\nThe attributes ConstraintFunction and ConstraintSet should not be included in the list even if then have been set with set.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#Optimizer-interface","page":"Models","title":"Optimizer interface","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"AbstractOptimizer\nOptimizerWithAttributes\noptimize!\ninstantiate","category":"page"},{"location":"moi/reference/models/#MathOptInterface.AbstractOptimizer","page":"Models","title":"MathOptInterface.AbstractOptimizer","text":"AbstractOptimizer\n\nAbstract supertype for objects representing an instance of an optimization problem tied to a particular solver. This is typically a solver's in-memory representation. In addition to ModelLike, AbstractOptimizer objects let you solve the model and query the solution.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.OptimizerWithAttributes","page":"Models","title":"MathOptInterface.OptimizerWithAttributes","text":"struct OptimizerWithAttributes\n    optimizer_constructor\n    params::Vector{Pair{AbstractOptimizerAttribute,<:Any}}\nend\n\nObject grouping an optimizer constructor and a list of optimizer attributes. Instances are created with instantiate.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.optimize!","page":"Models","title":"MathOptInterface.optimize!","text":"optimize!(optimizer::AbstractOptimizer)\n\nStart the solution procedure.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.instantiate","page":"Models","title":"MathOptInterface.instantiate","text":"instantiate(optimizer_constructor,\n            with_bridge_type::Union{Nothing, Type}=nothing,\n            with_names::Bool=false)\n\nCreates an instance of optimizer either by calling optimizer_constructor.optimizer_constructor() and setting the parameters in optimizer_constructor.params if optimizer_constructor is a OptimizerWithAttributes or by calling optimizer_constructor() if optimizer_constructor is callable.\n\nIf with_bridge_type is not nothing, it enables all the bridges defined in the MathOptInterface.Bridges submodule with coefficient type with_bridge_type.\n\nIf the optimizer created by optimizer_constructor does not support loading the problem incrementally or does not support names and with_names is true (see Utilities.supports_default_copy_to) then a Utilities.CachingOptimizer is added to store a cache of the bridged model. Hence set with_names to true if names might be set.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#Optimizer-attributes","page":"Models","title":"Optimizer attributes","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"AbstractOptimizerAttribute\nSolverName\nSilent\nTimeLimitSec\nRawParameter\nNumberOfThreads\nRawSolver","category":"page"},{"location":"moi/reference/models/#MathOptInterface.AbstractOptimizerAttribute","page":"Models","title":"MathOptInterface.AbstractOptimizerAttribute","text":"AbstractOptimizerAttribute\n\nAbstract supertype for attribute objects that can be used to set or get attributes (properties) of the optimizer.\n\nNote\n\nThe difference between AbstractOptimizerAttribute and AbstractModelAttribute lies in the behavior of is_empty, empty! and copy_to. Typically optimizer attributes only affect how the model is solved.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.SolverName","page":"Models","title":"MathOptInterface.SolverName","text":"SolverName()\n\nAn optimizer attribute for the string identifying the solver/optimizer.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.Silent","page":"Models","title":"MathOptInterface.Silent","text":"Silent()\n\nAn optimizer attribute for silencing the output of an optimizer. When set to true, it takes precedence over any other attribute controlling verbosity and requires the solver to produce no output. The default value is false which has no effect. In this case the verbosity is controlled by other attributes.\n\nNote\n\nEvery optimizer should have verbosity on by default. For instance, if a solver has a solver-specific log level attribute, the MOI implementation should set it to 1 by default. If the user sets Silent to true, then the log level should be set to 0, even if the user specifically sets a value of log level. If the value of Silent is false then the log level set to the solver is the value given by the user for this solver-specific parameter or 1 if none is given.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.TimeLimitSec","page":"Models","title":"MathOptInterface.TimeLimitSec","text":"TimeLimitSec()\n\nAn optimizer attribute for setting a time limit for an optimization. When set to nothing, it deactivates the solver time limit. The default value is nothing. The time limit is in seconds.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.RawParameter","page":"Models","title":"MathOptInterface.RawParameter","text":"RawParameter(name)\n\nAn optimizer attribute for the solver-specific parameter identified by name which is typically an Enum or a String.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.NumberOfThreads","page":"Models","title":"MathOptInterface.NumberOfThreads","text":"NumberOfThreads()\n\nAn optimizer attribute for setting the number of threads used for an optimization. When set to nothing uses solver default. Values are positive integers. The default value is nothing.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.RawSolver","page":"Models","title":"MathOptInterface.RawSolver","text":"RawSolver()\n\nA model attribute for the object that may be used to access a solver-specific API for this optimizer.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"List of attributes useful for optimizers","category":"page"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"TerminationStatus\nTerminationStatusCode\nPrimalStatus\nDualStatus\nResultStatusCode\nRawStatusString\nResultCount\nObjectiveValue\nDualObjectiveValue\nObjectiveBound\nRelativeGap\nSolveTime\nSimplexIterations\nBarrierIterations\nNodeCount","category":"page"},{"location":"moi/reference/models/#MathOptInterface.TerminationStatus","page":"Models","title":"MathOptInterface.TerminationStatus","text":"TerminationStatus()\n\nA model attribute for the TerminationStatusCode explaining why the optimizer stopped.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.TerminationStatusCode","page":"Models","title":"MathOptInterface.TerminationStatusCode","text":"TerminationStatusCode\n\nAn Enum of possible values for the TerminationStatus attribute. This attribute is meant to explain the reason why the optimizer stopped executing in the most recent call to optimize!.\n\nIf no call has been made to optimize!, then the TerminationStatus is:\n\nOPTIMIZE_NOT_CALLED: The algorithm has not started.\n\nOK\n\nThese are generally OK statuses, i.e., the algorithm ran to completion normally.\n\nOPTIMAL: The algorithm found a globally optimal solution.\nINFEASIBLE: The algorithm concluded that no feasible solution exists.\nDUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem. If, additionally, a feasible (primal) solution is known to exist, this status typically implies that the problem is unbounded, with some technical exceptions.\nLOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.\nLOCALLY_INFEASIBLE: The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.\nINFEASIBLE_OR_UNBOUNDED: The algorithm stopped because it decided that the problem is infeasible or unbounded; this occasionally happens during MIP presolve.\n\nSolved to relaxed tolerances\n\nALMOST_OPTIMAL: The algorithm found a globally optimal solution to relaxed tolerances.\nALMOST_INFEASIBLE: The algorithm concluded that no feasible solution exists within relaxed tolerances.\nALMOST_DUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.\nALMOST_LOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.\n\nLimits\n\nThe optimizer stopped because of some user-defined limit.\n\nITERATION_LIMIT: An iterative algorithm stopped after conducting the maximum number of iterations.\nTIME_LIMIT: The algorithm stopped after a user-specified computation time.\nNODE_LIMIT: A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.\nSOLUTION_LIMIT: The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.\nMEMORY_LIMIT: The algorithm stopped because it ran out of memory.\nOBJECTIVE_LIMIT: The algorithm stopped because it found a solution better than a minimum limit set by the user.\nNORM_LIMIT: The algorithm stopped because the norm of an iterate became too large.\nOTHER_LIMIT: The algorithm stopped due to a limit not covered by one of the above.\n\nProblematic\n\nThis group of statuses means that something unexpected or problematic happened.\n\nSLOW_PROGRESS: The algorithm stopped because it was unable to continue making progress towards the solution.\nNUMERICAL_ERROR: The algorithm stopped because it encountered unrecoverable numerical error.\nINVALID_MODEL: The algorithm stopped because the model is invalid.\nINVALID_OPTION: The algorithm stopped because it was provided an invalid option.\nINTERRUPTED: The algorithm stopped because of an interrupt signal.\nOTHER_ERROR: The algorithm stopped because of an error not covered by one of the statuses defined above.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.PrimalStatus","page":"Models","title":"MathOptInterface.PrimalStatus","text":"PrimalStatus(N)\nPrimalStatus()\n\nA model attribute for the ResultStatusCode of the primal result N. If N is omitted, it defaults to 1. If N is larger than the value of ResultCount then NO_SOLUTION is returned.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.DualStatus","page":"Models","title":"MathOptInterface.DualStatus","text":"DualStatus(N)\nDualStatus()\n\nA model attribute for the ResultStatusCode of the dual result N. If N is omitted, it defaults to 1. If N is larger than the value of ResultCount then NO_SOLUTION is returned.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ResultStatusCode","page":"Models","title":"MathOptInterface.ResultStatusCode","text":"ResultStatusCode\n\nAn Enum of possible values for the PrimalStatus and DualStatus attributes. The values indicate how to interpret the result vector.\n\nNO_SOLUTION: the result vector is empty.\nFEASIBLE_POINT: the result vector is a feasible point.\nNEARLY_FEASIBLE_POINT: the result vector is feasible if some constraint tolerances are relaxed.\nINFEASIBLE_POINT: the result vector is an infeasible point.\nINFEASIBILITY_CERTIFICATE: the result vector is an infeasibility certificate. If the PrimalStatus is INFEASIBILITY_CERTIFICATE, then the primal result vector is a certificate of dual infeasibility. If the DualStatus is INFEASIBILITY_CERTIFICATE, then the dual result vector is a proof of primal infeasibility.\nNEARLY_INFEASIBILITY_CERTIFICATE: the result satisfies a relaxed criterion for a certificate of infeasibility.\nREDUCTION_CERTIFICATE: the result vector is an ill-posed certificate; see this article for details. If the PrimalStatus is REDUCTION_CERTIFICATE, then the primal result vector is a proof that the dual problem is ill-posed. If the DualStatus is REDUCTION_CERTIFICATE, then the dual result vector is a proof that the primal is ill-posed.\nNEARLY_REDUCTION_CERTIFICATE: the result satisfies a relaxed criterion for an ill-posed certificate.\nUNKNOWN_RESULT_STATUS: the result vector contains a solution with an unknown interpretation.\nOTHER_RESULT_STATUS: the result vector contains a solution with an interpretation not covered by one of the statuses defined above.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.RawStatusString","page":"Models","title":"MathOptInterface.RawStatusString","text":"RawStatusString()\n\nA model attribute for a solver specific string explaining why the optimizer stopped.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ResultCount","page":"Models","title":"MathOptInterface.ResultCount","text":"ResultCount()\n\nA model attribute for the number of results available.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ObjectiveValue","page":"Models","title":"MathOptInterface.ObjectiveValue","text":"ObjectiveValue(resultidx::Int=1)\n\nA model attribute for the objective value of the result_indexth primal result.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.DualObjectiveValue","page":"Models","title":"MathOptInterface.DualObjectiveValue","text":"DualObjectiveValue(result_index::Int=1)\n\nA model attribute for the value of the objective function of the dual problem for the result_indexth dual result.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ObjectiveBound","page":"Models","title":"MathOptInterface.ObjectiveBound","text":"ObjectiveBound()\n\nA model attribute for the best known bound on the optimal objective value.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.RelativeGap","page":"Models","title":"MathOptInterface.RelativeGap","text":"RelativeGap()\n\nA model attribute for the final relative optimality gap, defined as fracb-ff, where b is the best bound and f is the best feasible objective value.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.SolveTime","page":"Models","title":"MathOptInterface.SolveTime","text":"SolveTime()\n\nA model attribute for the total elapsed solution time (in seconds) as reported by the optimizer.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.SimplexIterations","page":"Models","title":"MathOptInterface.SimplexIterations","text":"SimplexIterations()\n\nA model attribute for the cumulative number of simplex iterations during the optimization process. In particular, for a mixed-integer program (MIP), the total simplex iterations for all nodes.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.BarrierIterations","page":"Models","title":"MathOptInterface.BarrierIterations","text":"BarrierIterations()\n\nA model attribute for the cumulative number of barrier iterations while solving a problem.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.NodeCount","page":"Models","title":"MathOptInterface.NodeCount","text":"NodeCount()\n\nA model attribute for the total number of branch-and-bound nodes explored while solving a mixed-integer program (MIP).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#Conflict-Status","page":"Models","title":"Conflict Status","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"compute_conflict!\nConflictStatus\nConflictStatusCode\nConstraintConflictStatus\nConflictParticipationStatusCode","category":"page"},{"location":"moi/reference/models/#MathOptInterface.compute_conflict!","page":"Models","title":"MathOptInterface.compute_conflict!","text":"compute_conflict!(optimizer::AbstractOptimizer)\n\nComputes a minimal subset of constraints such that the model with the other constraint removed is still infeasible.\n\nSome solvers call a set of conflicting constraints an Irreducible Inconsistent Subsystem (IIS).\n\nSee also ConflictStatus and ConstraintConflictStatus.\n\nNote\n\nIf the model is modified after a call to compute_conflict!, the implementor is not obliged to purge the conflict. Any calls to the above attributes may return values for the original conflict without a warning. Similarly, when modifying the model, the conflict can be discarded.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.ConflictStatus","page":"Models","title":"MathOptInterface.ConflictStatus","text":"ConflictStatus()\n\nA model attribute for the ConflictStatusCode explaining why the conflict refiner stopped when computing the conflict.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ConflictStatusCode","page":"Models","title":"MathOptInterface.ConflictStatusCode","text":"ConflictStatusCode\n\nAn Enum of possible values for the ConflictStatus attribute. This attribute is meant to explain the reason why the conflict finder stopped executing in the most recent call to compute_conflict!.\n\nPossible values are:\n\nCOMPUTE_CONFLICT_NOT_CALLED: the function compute_conflict! has not yet been called\nNO_CONFLICT_EXISTS: there is no conflict because the problem is feasible\nNO_CONFLICT_FOUND: the solver could not find a conflict\nCONFLICT_FOUND: at least one conflict could be found\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ConstraintConflictStatus","page":"Models","title":"MathOptInterface.ConstraintConflictStatus","text":"ConstraintConflictStatus()\n\nA constraint attribute indicating whether the constraint participates in the conflict. Its type is ConflictParticipationStatusCode.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ConflictParticipationStatusCode","page":"Models","title":"MathOptInterface.ConflictParticipationStatusCode","text":"ConflictParticipationStatusCode\n\nAn Enum of possible values for the ConstraintConflictStatus attribute. This attribute is meant to indicate whether a given constraint participates or not in the last computed conflict.\n\nPossible values are:\n\nNOT_IN_CONFLICT: the constraint does not participate in the conflict\nIN_CONFLICT: the constraint participates in the conflict\nMAYBE_IN_CONFLICT: the constraint may participate in the conflict, the solver was not able to prove that the constraint can be excluded from the conflict\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Utilities/overview/#The-Utilities-submodule","page":"Overview","title":"The Utilities submodule","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The Utilities submodule provides a variety of functionality for managing MOI.ModelLike objects.","category":"page"},{"location":"moi/submodules/Utilities/overview/#Utilities.Model","page":"Overview","title":"Utilities.Model","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Utilities.Model provides an implementation of a ModelLike that efficiently supports all functions and sets defined within MOI. However, given the extensibility of MOI, this might not cover all use cases.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Create a model as follows:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.Utilities.Model{Float64}()\nMOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}","category":"page"},{"location":"moi/submodules/Utilities/overview/#Utilities.UniversalFallback","page":"Overview","title":"Utilities.UniversalFallback","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Utilities.UniversalFallback is a layer that sits on top of any ModelLike and provides non-specialized (slower) fallbacks for constraints and attributes that the underlying ModelLike does not support.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"For example, Utilities.Model doesn't support some variable attributes like VariablePrimalStart, so JuMP uses a combination of Universal fallback and Utilities.Model as a generic problem cache:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.Utilities.UniversalFallback(MOI.Utilities.Model{Float64}())\nMOIU.UniversalFallback{MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}}\nfallback for MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"warning: Warning\nAdding a UniversalFallback means that your model will now support all constraints, even if the inner-model does not! This can lead to unexpected behavior.","category":"page"},{"location":"moi/submodules/Utilities/overview/#Utilities.@model","page":"Overview","title":"Utilities.@model","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"For advanced use cases that need efficient support for functions and sets defined outside of MOI (but still known at compile time), we provide the Utilities.@model macro.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The @model macro takes a name (for a new type, which must not exist yet), eight tuples specifying the types of constraints that are supported, and then a Bool indicating the type should be a subtype of MOI.AbstractOptimizer (if true) or MOI.ModelLike (if false).","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The eight tuples are in the following order:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Un-typed scalar sets, e.g., Integer\nTyped scalar sets, e.g., LessThan\nUn-typed vector sets, e.g., Nonnegatives\nTyped vector sets, e.g., PowerCone\nUn-typed scalar functions, e.g., SingleVariable\nTyped scalar functions, e.g., ScalarAffineFunction\nUn-typed vector functions, e.g., VectorOfVariables\nTyped vector functions, e.g., VectorAffineFunction","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The tuples can contain more than one element. Typed-sets should be speficied without their type parameter, i.e., MOI.LessThan, not MOI.LessThan{Float64}.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Here is an example:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.@model(\n           MyNewModel,\n           (MOI.Integer,),                  # Un-typed scalar sets\n           (MOI.GreaterThan,),              # Typed scalar sets\n           (MOI.Nonnegatives,),             # Un-typed vector sets\n           (MOI.PowerCone,),                # Typed vector sets\n           (MOI.SingleVariable,),           # Un-typed scalar functions\n           (MOI.ScalarAffineFunction,),     # Typed scalar functions\n           (MOI.VectorOfVariables,),        # Un-typed vector functions\n           (MOI.VectorAffineFunction,),     # Typed vector functions\n           true,                            # <:MOI.AbstractOptimizer?\n       )\nMathOptInterface.Utilities.GenericOptimizer{T,MyNewModelFunctionConstraints{T}} where T\n\njulia> model = MyNewModel{Float64}()\nMOIU.GenericOptimizer{Float64,MyNewModelFunctionConstraints{Float64}}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"warning: Warning\nMyNewModel supports every SingleVariable-in-Set constraint, as well as SingleVariable, ScalarAffineFunction, and ScalarQuadraticFunction objective functions. Implement MOI.supports as needed to forbid constraint and objective function combinations.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"As another example, PATHSolver, which only supports VectorAffineFunction-in-Complements defines its optimizer as:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.@model(\n           PathOptimizer,\n           (),  # Scalar sets\n           (),  # Typed scalar sets\n           (MOI.Complements,),  # Vector sets\n           (),  # Typed vector sets\n           (),  # Scalar functions\n           (),  # Typed scalar functions\n           (),  # Vector functions\n           (MOI.VectorAffineFunction,),  # Typed vector functions\n           true,  # is_optimizer\n       )\nMathOptInterface.Utilities.GenericOptimizer{T,MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{T},MathOptInterface.Complements}} where T","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"However, PathOptimizer does not support some SingleVariable-in-Set constraints, so we must explicitly define:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> function MOI.supports_constraint(\n           ::PathOptimizer,\n           ::Type{MOI.SingleVariable},\n           ::Type{Union{<:MOI.Semiinteger,MOI.Semicontinuous,MOI.ZeroOne,MOI.Integer}}\n       )\n           return false\n       end","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Finally, PATH doesn't support an objective function, so we need to add:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.supports(::PathOptimizer, ::MOI.ObjectiveFunction) = false","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"warning: Warning\nThis macro creates a new type, so it must be called from the top-level of a module, e.g., it cannot be called from inside a function.","category":"page"},{"location":"moi/submodules/Utilities/overview/#Utilities.CachingOptimizer","page":"Overview","title":"Utilities.CachingOptimizer","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"A [Utilities.CachingOptimizer] is an MOI layer that abstracts the difference between solvers that support incremental modification (e.g., they support adding variables one-by-one), and solvers that require the entire problem in a single API call (e.g., they only accept the A, b and c matrices of a linear program).","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"It has two parts:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"A cache, where the model can be built and modified incrementally\nAn optimizer, which is used to solve the problem","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.Utilities.CachingOptimizer(\n           MOI.Utilities.Model{Float64}(),\n           PathOptimizer{Float64}(),\n       )\nMOIU.CachingOptimizer{MOIU.GenericOptimizer{Float64,MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64},MOI.Complements}},MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}}\nin state ATTACHED_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\nwith optimizer MOIU.GenericOptimizer{Float64,MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64},MOI.Complements}}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"A Utilities.CachingOptimizer may be in one of three possible states:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"NO_OPTIMIZER: The CachingOptimizer does not have any optimizer.\nEMPTY_OPTIMIZER: The CachingOptimizer has an empty optimizer, and it is not synchronized with the cached model. Modifications are forwarded to the cache, but not to the optimizer.\nATTACHED_OPTIMIZER: The CachingOptimizer has an optimizer, and it is synchronized with the cached model. Modifications are forwarded to the optimizer. If the optimizer does not support modifications, and error will be thrown.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Use Utilities.reset_optimizer to go from ATTACHED_OPTIMIZER to EMPTY_OPTIMIZER:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.reset_optimizer(model)\n\njulia> model\nMOIU.CachingOptimizer{MOIU.GenericOptimizer{Float64,MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64},MOI.Complements}},MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\nwith optimizer MOIU.GenericOptimizer{Float64,MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64},MOI.Complements}}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Use Utilities.attach_optimizer to go from EMPTY_OPTIMIZER to ATTACHED_OPTIMIZER:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.attach_optimizer(model)\n\njulia> model\nMOIU.CachingOptimizer{MOIU.GenericOptimizer{Float64,MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64},MOI.Complements}},MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}}\nin state ATTACHED_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\nwith optimizer MOIU.GenericOptimizer{Float64,MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64},MOI.Complements}}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"info: Info\nYou must be in ATTACHED_OPTIMIZER to use optimize!.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Use Utilities.drop_optimizer to go from any state to NO_OPTIMIZER:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.drop_optimizer(model)\n\njulia> model\nMOIU.CachingOptimizer{MOIU.GenericOptimizer{Float64,MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64},MOI.Complements}},MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}}\nin state NO_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\nwith optimizer nothing","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Pass an empty optimizer to Utilities.reset_optimizer to go from NO_OPTIMIZER to EMPTY_OPTIMIZER:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.reset_optimizer(model, PathOptimizer{Float64}())\n\njulia> model\nMOIU.CachingOptimizer{MOIU.GenericOptimizer{Float64,MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64},MOI.Complements}},MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\nwith optimizer MOIU.GenericOptimizer{Float64,MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64},MOI.Complements}}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Deciding when to attach and reset the optimizer is tedious, and you will often write code like this:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"try\n    # modification\ncatch\n    MOI.Utilities.reset_optimizer(model)\n    # Re-try modification\nend","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"To make this easier, Utilities.CachingOptimizer has two modes of operation:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"AUTOMATIC: The CachingOptimizer changes its state when necessary. Attempting to add a constraint or perform a modification not supported by the optimizer results in a drop to EMPTY_OPTIMIZER mode.\nMANUAL: The user must change the state of the CachingOptimizer. Attempting to perform an operation in the incorrect state results in an error.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"By default, AUTOMATIC mode is chosen. However, you can create a CachingOptimizer in MANUAL mode as follows:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.Utilities.CachingOptimizer(\n           MOI.Utilities.Model{Float64}(),\n           MOI.Utilities.MANUAL,\n       )\nMOIU.CachingOptimizer{MOI.AbstractOptimizer,MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}}\nin state NO_OPTIMIZER\nin mode MANUAL\nwith model cache MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\nwith optimizer nothing\n\njulia> MOI.Utilities.reset_optimizer(model, PathOptimizer{Float64}())\n\njulia> model\nMOIU.CachingOptimizer{MOI.AbstractOptimizer,MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}}\nin state EMPTY_OPTIMIZER\nin mode MANUAL\nwith model cache MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\nwith optimizer MOIU.GenericOptimizer{Float64,MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64},MOI.Complements}}","category":"page"},{"location":"moi/submodules/Utilities/overview/#Copy-utilities","page":"Overview","title":"Copy utilities","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"info: Info\nThis section is unfinished.","category":"page"},{"location":"moi/submodules/Utilities/overview/#Allocate-Load-API","page":"Overview","title":"Allocate-Load API","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The Allocate-Load API allows solvers that do not support loading the problem incrementally to implement copy_to in a way that still allows transformations to be applied in the copy between the cache and the model if the transformations are implemented as MOI layers implementing the Allocate-Load API.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Loading a model using the Allocate-Load interface consists of two passes through the model data:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"the allocate pass where the model typically records the necessary information about the constraints and attributes such as their number and size. This information may be used by the solver to allocate datastructures of appropriate size.\nthe load pass where the model typically loads the constraint and attribute data to the model.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The description above only gives a suggestion of what to achieve in each pass. In fact the exact same constraint and attribute data is provided to each pass, so an implementation of the Allocate-Load API is free to do whatever is more convenient in each pass.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The main difference between each pass, apart from the fact that one is executed before the other during a copy, is that the allocate pass needs to create and return new variable and constraint indices, while during the load pass the appropriate constraint indices are provided.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The Allocate-Load API is not meant to be used outside a copy operation, that is, the interface is not meant to be used to create new constraints with Utilities.allocate_constraint followed by Utilities.load_constraint after a solve. This means that the order in which the different functions of the API are called is fixed by Utilities.allocate_load and models implementing the API can rely on the fact that functions will be called in this order. That is, it can be assumed that the different functions will the called in the following order:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Utilities.allocate_variables\nUtilities.allocate and Utilities.allocate_constraint\nUtilities.load_variables\nUtilities.load and Utilities.load_constraint","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"If you choose to implement the Allocate-Load API, also implement;","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"function MOI.copy_to(dest::Optimizer, src::MOI.ModelLike; kwargs...)\n    return MOI.Utilities.automatic_copy_to(dest, src; kwargs...)\nend\n\nfunction MOI.Utilities.supports_allocate_load(\n    model::Optimizer,\n    copy_names::Bool,\n)\n    # If you support names...\n    return true\n    # Otherwise...\n    return !copy_names\nend","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"See Utilities.supports_allocate_load for more details.","category":"page"},{"location":"moi/submodules/Utilities/overview/#Fallbacks","page":"Overview","title":"Fallbacks","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The value of some attributes can be inferred from the value of other attributes.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"For example, the value of ObjectiveValue can be computed using ObjectiveFunction and VariablePrimal.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"When a solver gives direct access to an attribute, it is better to return this value. However, if this is not the case, Utilities.get_fallback can be used instead. For example:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"function MOI.get(model::Optimizer, attr::MOI.ObjectiveFunction)\n    return MOI.Utilities.get_fallback(model, attr)\nend","category":"page"},{"location":"reference/extensions/#ExtensionAPI","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"reference/extensions/","page":"Extensions","title":"Extensions","text":"More information can be found in the Extensions section of the manual.","category":"page"},{"location":"reference/extensions/#Define-a-new-set","page":"Extensions","title":"Define a new set","text":"","category":"section"},{"location":"reference/extensions/","page":"Extensions","title":"Extensions","text":"AbstractVectorSet","category":"page"},{"location":"reference/extensions/#JuMP.AbstractVectorSet","page":"Extensions","title":"JuMP.AbstractVectorSet","text":"AbstractVectorSet\n\nAn abstract type for defining new sets in JuMP.\n\nImplement moi_set(::AbstractVectorSet, dim::Int) to convert the type into an MOI set.\n\nSee also: moi_set.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#Extend-@variable","page":"Extensions","title":"Extend @variable","text":"","category":"section"},{"location":"reference/extensions/","page":"Extensions","title":"Extensions","text":"ScalarVariable\nVariableInfo\nadd_variable\nbuild_variable","category":"page"},{"location":"reference/extensions/#JuMP.ScalarVariable","page":"Extensions","title":"JuMP.ScalarVariable","text":"ScalarVariable{S,T,U,V} <: AbstractVariable\n\nA struct used when adding variables.\n\nSee also: add_variable.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.VariableInfo","page":"Extensions","title":"JuMP.VariableInfo","text":"VariableInfo{S,T,U,V}\n\nA struct by JuMP internally when creating variables. This may also be used by JuMP extensions to create new types of variables.\n\nSee also: ScalarVariable.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.add_variable","page":"Extensions","title":"JuMP.add_variable","text":"add_variable(m::Model, v::AbstractVariable, name::String=\"\")\n\nAdd a variable v to Model m and sets its name.\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.build_variable","page":"Extensions","title":"JuMP.build_variable","text":"build_variable(_error::Function, variables, ::SymMatrixSpace)\n\nReturn a VariablesConstrainedOnCreation of shape SymmetricMatrixShape creating variables in MOI.Reals, i.e. \"free\" variables unless they are constrained after their creation.\n\nThis function is used by the @variable macro as follows:\n\n@variable(model, Q[1:2, 1:2], Symmetric)\n\n\n\n\n\nbuild_variable(_error::Function, variables, ::SkewSymmetricMatrixSpace)\n\nReturn a VariablesConstrainedOnCreation of shape SkewSymmetricMatrixShape creating variables in MOI.Reals, i.e. \"free\" variables unless they are constrained after their creation.\n\nThis function is used by the @variable macro as follows:\n\n@variable(model, Q[1:2, 1:2] in SkewSymmetricMatrixSpace())\n\n\n\n\n\nbuild_variable(_error::Function, variables, ::PSDCone)\n\nReturn a VariablesConstrainedOnCreation of shape SymmetricMatrixShape constraining the variables to be positive semidefinite.\n\nThis function is used by the @variable macro as follows:\n\n@variable(model, Q[1:2, 1:2], PSD)\n\n\n\n\n\nbuild_variable(_error::Function, info::VariableInfo; extra_kw_args...)\n\nReturns a new variable.\n\nExtensions should define a method with additional positional arguments to dispatch the call to a different method. The return type should only depend on the positional arguments for variable_type to make sense.\n\nAs an example, @variable(model, x, foo) foo will call build_variable(_error, info, foo)\n\nSee the @variable macro doc for more details.\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#Extend-@constraint","page":"Extensions","title":"Extend @constraint","text":"","category":"section"},{"location":"reference/extensions/","page":"Extensions","title":"Extensions","text":"build_constraint\nadd_constraint\nsense_to_set\nAbstractShape\nshape\nreshape_vector\nreshape_set\ndual_shape\nScalarShape\nVectorShape\nSquareMatrixShape\nSymmetricMatrixShape","category":"page"},{"location":"reference/extensions/#JuMP.build_constraint","page":"Extensions","title":"JuMP.build_constraint","text":"build_constraint(_error::Function, Q::Symmetric{V, M},\n                 ::PSDCone) where {V <: AbstractJuMPScalar,\n                                   M <: AbstractMatrix{V}}\n\nReturn a VectorConstraint of shape SymmetricMatrixShape constraining the matrix Q to be positive semidefinite.\n\nThis function is used by the @constraint macros as follows:\n\n@constraint(model, Symmetric(Q) in PSDCone())\n\nThe form above is usually used when the entries of Q are affine or quadratic expressions, but it can also be used when the entries are variables to get the reference of the semidefinite constraint, e.g.,\n\n@variable model Q[1:2,1:2] Symmetric\n# The type of `Q` is `Symmetric{VariableRef, Matrix{VariableRef}}`\nvar_psd = @constraint model Q in PSDCone()\n# The `var_psd` variable contains a reference to the constraint\n\n\n\n\n\nbuild_constraint(_error::Function,\n                 Q::AbstractMatrix{<:AbstractJuMPScalar},\n                 ::PSDCone)\n\nReturn a VectorConstraint of shape SquareMatrixShape constraining the matrix Q to be symmetric and positive semidefinite.\n\nThis function is used by the @constraint and @SDconstraint macros as follows:\n\n@constraint(model, Q in PSDCone())\n@SDconstraint(model, P ‚™∞ Q)\n\nThe @constraint call above is usually used when the entries of Q are affine or quadratic expressions, but it can also be used when the entries are variables to get the reference of the semidefinite constraint, e.g.,\n\n@variable model Q[1:2,1:2]\n# The type of `Q` is `Matrix{VariableRef}`\nvar_psd = @constraint model Q in PSDCone()\n# The `var_psd` variable contains a reference to the constraint\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.add_constraint","page":"Extensions","title":"JuMP.add_constraint","text":"add_constraint(model::Model, con::AbstractConstraint, name::String=\"\")\n\nAdd a constraint con to Model model and sets its name.\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.sense_to_set","page":"Extensions","title":"JuMP.sense_to_set","text":"sense_to_set(_error::Function, ::Val{sense_symbol})\n\nConverts a sense symbol to a set set such that @constraint(model, func sense_symbol 0) is equivalent to @constraint(model, func in set) for any func::AbstractJuMPScalar.\n\nExample\n\nOnce a custom set is defined you can directly create a JuMP constraint with it:\n\njulia> struct CustomSet{T} <: MOI.AbstractScalarSet\n           value::T\n       end\n\njulia> Base.copy(x::CustomSet) = CustomSet(x.value)\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> cref = @constraint(model, x in CustomSet(1.0))\nx ‚àà CustomSet{Float64}(1.0)\n\nHowever, there might be an appropriate sign that could be used in order to provide a more convenient syntax:\n\njulia> JuMP.sense_to_set(::Function, ::Val{:‚ä∞}) = CustomSet(0.0)\n\njulia> MOIU.shift_constant(set::CustomSet, value) = CustomSet(set.value + value)\n\njulia> cref = @constraint(model, x ‚ä∞ 1)\nx ‚àà CustomSet{Float64}(1.0)\n\nNote that the whole function is first moved to the right-hand side, then the sign is transformed into a set with zero constant and finally the constant is moved to the set with MOIU.shift_constant.\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.AbstractShape","page":"Extensions","title":"JuMP.AbstractShape","text":"AbstractShape\n\nAbstract vectorizable shape. Given a flat vector form of an object of shape shape, the original object can be obtained by reshape_vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.shape","page":"Extensions","title":"JuMP.shape","text":"shape(c::AbstractConstraint)::AbstractShape\n\nReturn the shape of the constraint c.\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.reshape_vector","page":"Extensions","title":"JuMP.reshape_vector","text":"reshape_vector(vectorized_form::Vector, shape::AbstractShape)\n\nReturn an object in its original shape shape given its vectorized form vectorized_form.\n\nExamples\n\nGiven a SymmetricMatrixShape of vectorized form [1, 2, 3], the following code returns the matrix Symmetric(Matrix[1 2; 2 3]):\n\njulia> reshape_vector([1, 2, 3], SymmetricMatrixShape(2))\n2√ó2 LinearAlgebra.Symmetric{Int64,Array{Int64,2}}:\n 1  2\n 2  3\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.reshape_set","page":"Extensions","title":"JuMP.reshape_set","text":"reshape_set(vectorized_set::MOI.AbstractSet, shape::AbstractShape)\n\nReturn a set in its original shape shape given its vectorized form vectorized_form.\n\nExamples\n\nGiven a SymmetricMatrixShape of vectorized form [1, 2, 3] in MOI.PositiveSemidefinieConeTriangle(2), the following code returns the set of the original constraint Symmetric(Matrix[1 2; 2 3]) in PSDCone():\n\njulia> reshape_set(MOI.PositiveSemidefiniteConeTriangle(2), SymmetricMatrixShape(2))\nPSDCone()\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.dual_shape","page":"Extensions","title":"JuMP.dual_shape","text":"dual_shape(shape::AbstractShape)::AbstractShape\n\nReturns the shape of the dual space of the space of objects of shape shape. By default, the dual_shape of a shape is itself. See the examples section below for an example for which this is not the case.\n\nExamples\n\nConsider polynomial constraints for which the dual is moment constraints and moment constraints for which the dual is polynomial constraints. Shapes for polynomials can be defined as follows:\n\nstruct Polynomial\n    coefficients::Vector{Float64}\n    monomials::Vector{Monomial}\nend\nstruct PolynomialShape <: AbstractShape\n    monomials::Vector{Monomial}\nend\nJuMP.reshape_vector(x::Vector, shape::PolynomialShape) = Polynomial(x, shape.monomials)\n\nand a shape for moments can be defined as follows:\n\nstruct Moments\n    coefficients::Vector{Float64}\n    monomials::Vector{Monomial}\nend\nstruct MomentsShape <: AbstractShape\n    monomials::Vector{Monomial}\nend\nJuMP.reshape_vector(x::Vector, shape::MomentsShape) = Moments(x, shape.monomials)\n\nThen dual_shape allows the definition of the shape of the dual of polynomial and moment constraints:\n\ndual_shape(shape::PolynomialShape) = MomentsShape(shape.monomials)\ndual_shape(shape::MomentsShape) = PolynomialShape(shape.monomials)\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.ScalarShape","page":"Extensions","title":"JuMP.ScalarShape","text":"ScalarShape\n\nShape of scalar constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.VectorShape","page":"Extensions","title":"JuMP.VectorShape","text":"VectorShape\n\nVector for which the vectorized form corresponds exactly to the vector given.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.SquareMatrixShape","page":"Extensions","title":"JuMP.SquareMatrixShape","text":"SquareMatrixShape\n\nShape object for a square matrix of side_dimension rows and columns. The vectorized form contains the entries of the the matrix given column by column (or equivalently, the entries of the lower-left triangular part given row by row).\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.SymmetricMatrixShape","page":"Extensions","title":"JuMP.SymmetricMatrixShape","text":"SymmetricMatrixShape\n\nShape object for a symmetric square matrix of side_dimension rows and columns. The vectorized form contains the entries of the upper-right triangular part of the matrix given column by column (or equivalently, the entries of the lower-left triangular part given row by row).\n\n\n\n\n\n","category":"type"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Nonlinear programs/nlp_tricks.jl\"","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/#Nonlinear-tips-and-tricks","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"This example collates some tips and tricks you can use when formulating nonlinear programs. It uses the following packages:","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"using JuMP\nimport Ipopt\nimport Test","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/#User-defined-functions-with-vector-outputs","page":"Nonlinear tips and tricks","title":"User-defined functions with vector outputs","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"A common situation is to have a user-defined function like the following that returns multiple outputs (we define function_calls to keep track of how many times we call this method):","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"function_calls = 0\nfunction foo(x, y)\n    global function_calls += 1\n    common_term = x^2 + y^2\n    term_1 = sqrt(1 + common_term)\n    term_2 = common_term\n    return term_1, term_2\nend","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"For example, the first term might be used in the objective, and the second term might be used in a constraint, and often they share share work that is expensive to evaluate.","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"This is a problem for JuMP, because it requires user-defined functions to return a single number. One option is to define two separate functions, the first returning the first argument, and the second returning the second argument.","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"foo_1(x, y) = foo(x, y)[1]\nfoo_2(x, y) = foo(x, y)[2]","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"However, if the common term is expensive to compute, this approach is wasteful because it will evaluate the expensive term twice. Let's have a look at how many times we evaluate x^2 + y^2 during a solve:","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"model = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, x[1:2] >= 0, start = 0.1)\nregister(model, :foo_1, 2, foo_1; autodiff = true)\nregister(model, :foo_2, 2, foo_2; autodiff = true)\n@NLobjective(model, Max, foo_1(x[1], x[2]))\n@NLconstraint(model, foo_2(x[1], x[2]) <= 2)\nfunction_calls = 0\noptimize!(model)\nTest.@test objective_value(model) ‚âà ‚àö3 atol=1e-4\nTest.@test value.(x) ‚âà [1.0, 1.0] atol=1e-4\nprintln(\"Naive approach: function calls = $(function_calls)\")","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"An alternative approach is to use memoization, which uses a cache to store the result of function evaluations. We can write a memoization function as follows:","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"\"\"\"\n    memoize(foo::Function, n_outputs::Int)\n\nTake a function `foo` and return a vector of length `n_outputs`, where each\nelement is a function that returns the `i`'th output of `foo`.\n\nTo avoid duplication of work, cache the most-recent evaluations of `foo`.\nBecause `foo_i` is auto-differentiated with ForwardDiff, our cache needs to\nwork when `x` is a `Float64` and a `ForwardDiff.Dual`.\n\"\"\"\nfunction memoize(foo::Function, n_outputs::Int)\n    last_x, last_f = nothing, nothing\n    last_dx, last_dfdx = nothing, nothing\n    function foo_i(i, x::T...) where {T <: Real}\n        if T == Float64\n            if x != last_x\n                last_x, last_f = x, foo(x...)\n            end\n            return last_f[i]::T\n        else\n            if x != last_dx\n                last_dx, last_dfdx = x, foo(x...)\n            end\n            return last_dfdx[i]::T\n        end\n    end\n    return [(x...) -> foo_i(i, x...) for i = 1:n_outputs]\nend","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"Let's see how it works. First, construct the memoized versions of foo:","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"memoized_foo = memoize(foo, 2)","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"Now try evaluating the first element of memoized_foo.","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"function_calls = 0\nmemoized_foo[1](1.0, 1.0)\nprintln(\"function_calls = \", function_calls)","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"As expected, this evaluated the function once. However, if we call the function again, we hit the cache instead of needing to re-compute foo and function_calls is still 1!","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"memoized_foo[1](1.0, 1.0)\nprintln(\"function_calls = \", function_calls)","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"Now let's see how this works during a real solve:","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"model = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, x[1:2] >= 0, start = 0.1)\nregister(model, :foo_1, 2, memoized_foo[1]; autodiff = true)\nregister(model, :foo_2, 2, memoized_foo[2]; autodiff = true)\n@NLobjective(model, Max, foo_1(x[1], x[2]))\n@NLconstraint(model, foo_2(x[1], x[2]) <= 2)\nfunction_calls = 0\noptimize!(model)\nTest.@test objective_value(model) ‚âà ‚àö3 atol=1e-4\nTest.@test value.(x) ‚âà [1.0, 1.0] atol=1e-4\nprintln(\"Memoized approach: function_calls = $(function_calls)\")","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"Compared to the naive approach, the memoized approach requires half as many function evaluations!","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"View this file on Github.","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"manual/variables/#jump_variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"manual/variables/#What-is-a-JuMP-variable?","page":"Variables","title":"What is a JuMP variable?","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The term variable in mathematical optimization has many meanings. Here, we distinguish between the following three types of variables:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"optimization variables, which are the mathematical x in the problem maxf_0(x)  f_i(x) in S_i.\nJulia variables, which are bindings between a name and a value, for example x = 1. (See here for the Julia docs.)\nJuMP variables, which are instances of the VariableRef struct defined by JuMP that contains a reference to an optimization variable in a model. (Extra for experts: the VariableRef struct is a thin wrapper around a MOI.VariableIndex, and also contains a reference to the JuMP model.)","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"To illustrate these three types of variables, consider the following JuMP code (the full syntax is explained below):","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x[1:2])\n2-element Array{VariableRef,1}:\n x[1]\n x[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"This code does three things:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"It adds two optimization variables to model.\nIt creates two JuMP variables that act as references to those optimization variables.\nIt binds those JuMP variables as a vector with two elements to the Julia variable x.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"To reduce confusion, we will attempt, where possible, to always refer to variables with their corresponding prefix.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP variables can have attributes, such as names or an initial primal start value. We illustrate the name attribute in the following example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, y, base_name=\"decision variable\")\ndecision variable","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"This code does four things:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"It adds one optimization variable to model.\nIt creates one JuMP variable that acts as a reference to that optimization variable.\nIt binds the JuMP variable to the Julia variable y.\nIt tells JuMP that the name attribute of this JuMP variable is \"decision variable\". JuMP uses the value of base_name when it has to print the variable as a string.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For example, when we print y at the REPL we get:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> y\ndecision variable","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Because y is a Julia variable, we can bind it to a different value. For example, if we write:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> y = 1\n1","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"y is no longer a binding to a JuMP variable. This does not mean that the JuMP variable has been destroyed. It still exists and is still a reference to the same optimization variable. The binding can be reset by querying the model for the symbol as it was written in the @variable macro. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model[:y]\ndecision variable","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"This act of looking up the JuMP variable by using the symbol is most useful when composing JuMP models across multiple functions, as illustrated by the following example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"function add_component_to_model(model::JuMP.Model)\n    x = model[:x]\n    # ... code that uses x\nend\nfunction build_model()\n    model = Model()\n    @variable(model, x)\n    add_component_to_model(model)\nend","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Now that we understand the difference between optimization, JuMP, and Julia variables, we can introduce more of the functionality of the @variable macro.","category":"page"},{"location":"manual/variables/#Variable-bounds","page":"Variables","title":"Variable bounds","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We have already seen the basic usage of the @variable macro. The next extension is to add lower- and upper-bounds to each optimization variable. This can be done as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x_free)\nx_free\n\njulia> @variable(model, x_lower >= 0)\nx_lower\n\njulia> @variable(model, x_upper <= 1)\nx_upper\n\njulia> @variable(model, 2 <= x_interval <= 3)\nx_interval\n\njulia> @variable(model, x_fixed == 4)\nx_fixed","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"In the above examples, x_free represents an unbounded optimization variable, x_lower represents an optimization variable with a lower bound and so forth.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"note: Note\nWhen creating a variable with only a lower-bound or an upper-bound, and the value of the bound is not a numeric literal, the name of the variable must appear on the left-hand side. Putting the name on the right-hand side will result in an error. For example:@variable(model, 1 <= x)  # works\na = 1\n@variable(model, a <= x)  # errors\n@variable(model, x >= a)  # works","category":"page"},{"location":"manual/variables/#Check-if-a-variable-bound-exists","page":"Variables","title":"Check if a variable bound exists","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We can query whether an optimization variable has a lower- or upper-bound via the has_lower_bound and has_upper_bound functions. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> has_lower_bound(x_free)\nfalse\n\njulia> has_upper_bound(x_upper)\ntrue","category":"page"},{"location":"manual/variables/#Query-a-variable-bound","page":"Variables","title":"Query a variable bound","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"If a variable has a lower or upper bound, we can query the value of it via the lower_bound and upper_bound functions. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> lower_bound(x_interval)\n2.0\n\njulia> upper_bound(x_interval)\n3.0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Querying the value of a bound that does not exist will result in an error.","category":"page"},{"location":"manual/variables/#Set-variable-bounds-via-keyword","page":"Variables","title":"Set variable bounds via keyword","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Instead of using the <= and >= syntax, we can also use the lower_bound and upper_bound keyword arguments. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, lower_bound=1, upper_bound=2)\nx\n\njulia> lower_bound(x)\n1.0","category":"page"},{"location":"manual/variables/#Set-variable-bounds-bounds-via-functions","page":"Variables","title":"Set variable bounds bounds via functions","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Another option is to use the set_lower_bound and set_upper_bound functions. These can also be used to modify an existing variable bound. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x >= 1)\nx\n\njulia> lower_bound(x)\n1.0\n\njulia> set_lower_bound(x, 2)\n\njulia> lower_bound(x)\n2.0","category":"page"},{"location":"manual/variables/#Delete-a-variable-bound","page":"Variables","title":"Delete a variable bound","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We can delete variable bounds using delete_lower_bound and delete_upper_bound:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, 1 <= x <= 2)\nx\n\njulia> lower_bound(x)\n1.0\n\njulia> delete_lower_bound(x)\n\njulia> has_lower_bound(x)\nfalse\n\njulia> upper_bound(x)\n2.0\n\njulia> delete_upper_bound(x)\n\njulia> has_upper_bound(x)\nfalse","category":"page"},{"location":"manual/variables/#Create-a-fixed-variable","page":"Variables","title":"Create a fixed variable","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"In addition to upper and lower bounds, JuMP variables can also be fixed to a value using fix. See also is_fixed, fix_value, and unfix.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x == 1)\nx\n\njulia> is_fixed(x)\ntrue\n\njulia> fix_value(x)\n1.0\n\njulia> unfix(x)\n\njulia> is_fixed(x)\nfalse","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Fixing a variable with existing bounds will throw an error. To delete the bounds prior to fixing, use fix(variable, value; force = true).","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x >= 1)\nx\n\njulia> fix(x, 2)\nERROR: Unable to fix x to 2 because it has existing variable bounds. Consider calling `JuMP.fix(variable, value; force=true)` which will delete existing bounds before fixing the variable.\n\njulia> fix(x, 2; force = true)\n\n\njulia> fix_value(x)\n2.0","category":"page"},{"location":"manual/variables/#Variable-names","page":"Variables","title":"Variable names","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The name, i.e. the value of the MOI.VariableName attribute, of a variable can be obtained by JuMP.name(::JuMP.VariableRef) and set by JuMP.set_name(::JuMP.VariableRef, ::String).","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The variable can also be retrieved from its name using JuMP.variable_by_name.","category":"page"},{"location":"manual/variables/#Variable-containers","page":"Variables","title":"Variable containers","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"In the examples above, we have mostly created scalar variables. By scalar, we mean that the Julia variable is bound to exactly one JuMP variable. However, it is often useful to create collections of JuMP variables inside more complicated data structures.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP provides a mechanism for creating three types of these data structures, which we refer to as containers. The three types are Arrays, DenseAxisArrays, and SparseAxisArrays. We explain each of these in the following.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"tip: Tip\nYou can read more about containers in the Containers section.","category":"page"},{"location":"manual/variables/#Arrays","page":"Variables","title":"Arrays","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We have already seen the creation of an array of JuMP variables with the x[1:2] syntax. This can naturally be extended to create multi-dimensional arrays of JuMP variables. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2])\n2√ó2 Array{VariableRef,2}:\n x[1,1]  x[1,2]\n x[2,1]  x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Arrays of JuMP variables can be indexed and sliced as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x[1, 2]\nx[1,2]\n\njulia> x[2, :]\n2-element Array{VariableRef,1}:\n x[2,1]\n x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Variable bounds can depend upon the indices:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=1:2, j=1:2] >= 2i + j)\n2√ó2 Array{VariableRef,2}:\n x[1,1]  x[1,2]\n x[2,1]  x[2,2]\n\njulia> lower_bound.(x)\n2√ó2 Array{Float64,2}:\n 3.0  4.0\n 5.0  6.0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP will form an Array of JuMP variables when it can determine at compile time that the indices are one-based integer ranges. Therefore x[1:b] will create an Array of JuMP variables, but x[a:b] will not. If JuMP cannot determine that the indices are one-based integer ranges (e.g., in the case of x[a:b]), JuMP will create a DenseAxisArray instead.","category":"page"},{"location":"manual/variables/#variable_jump_arrays","page":"Variables","title":"DenseAxisArrays","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We often want to create arrays where the indices are not one-based integer ranges. For example, we may want to create a variable indexed by the name of a product or a location. The syntax is the same as that above, except with an arbitrary vector as an index as opposed to a one-based range. The biggest difference is that instead of returning an Array of JuMP variables, JuMP will return a DenseAxisArray. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, [:A,:B]])\n2-dimensional DenseAxisArray{VariableRef,2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, Symbol[:A, :B]\nAnd data, a 2√ó2 Array{VariableRef,2}:\n x[1,A]  x[1,B]\n x[2,A]  x[2,B]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"DenseAxisArrays can be indexed and sliced as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x[1, :A]\nx[1,A]\n\njulia> x[2, :]\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:A, :B]\nAnd data, a 2-element Array{VariableRef,1}:\n x[2,A]\n x[2,B]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Similarly to the Array case, bounds can depend upon indices. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=2:3, j=1:2:3] >= 0.5i + j)\n2-dimensional DenseAxisArray{VariableRef,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, 1:2:3\nAnd data, a 2√ó2 Array{VariableRef,2}:\n x[2,1]  x[2,3]\n x[3,1]  x[3,3]\n\njulia> lower_bound.(x)\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, 1:2:3\nAnd data, a 2√ó2 Array{Float64,2}:\n 2.0  4.0\n 2.5  4.5","category":"page"},{"location":"manual/variables/#variable_sparseaxisarrays","page":"Variables","title":"SparseAxisArrays","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The third container type that JuMP natively supports is SparseAxisArray. These arrays are created when the indices do not form a rectangular set. For example, this applies when indices have a dependence upon previous indices (called triangular indexing). JuMP supports this as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=1:2, j=i:2])\nJuMP.Containers.SparseAxisArray{VariableRef,2,Tuple{Int64,Int64}} with 3 entries:\n  [1, 2]  =  x[1,2]\n  [2, 2]  =  x[2,2]\n  [1, 1]  =  x[1,1]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We can also conditionally create variables via a JuMP-specific syntax. This syntax appends a comparison check that depends upon the named indices and is separated from the indices by a semi-colon (;). For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=1:4; mod(i, 2)==0])\nJuMP.Containers.SparseAxisArray{VariableRef,1,Tuple{Int64}} with 2 entries:\n  [4]  =  x[4]\n  [2]  =  x[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Note that with many index dimensions and a large amount of sparsity, variable construction may be unnecessarily slow if the semi-colon syntax is naively applied. When using the semi-colon as a filter, JuMP iterates over all indices and evaluates the conditional for each combination. When this is undesired, the recommended work-around is to work directly with a list of tuples or create a dictionary. Consider the following examples:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"# TODO: Reformat the code below as a doctest.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"N = 10\nS = [(1, 1, 1),(N, N, N)]\n# Slow. It evaluates conditional N^3 times.\n@variable(model, x1[i=1:N, j=1:N, k=1:N; (i, j, k) in S])\n# Fast.\n@variable(model, x2[S])\n# Fast. Manually constructs a dictionary and fills it.\nx3 = Dict()\nfor (i, j, k) in S\n    x3[i, j, k] = @variable(model)\n    # Optional, if you care about pretty printing:\n    set_name(x3[i, j, k], \"x[$i,$j,$k]\")\nend","category":"page"},{"location":"manual/variables/#variable_forcing","page":"Variables","title":"Forcing the container type","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"When creating a container of JuMP variables, JuMP will attempt to choose the tightest container type that can store the JuMP variables. Thus, it will prefer to create an Array before a DenseAxisArray and a DenseAxisArray before a SparseAxisArray. However, because this happens at compile time, it does not always make the best choice. To illustrate this, consider the following example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> A = 1:2\n1:2\n\njulia> @variable(model, x[A])\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, 1:2\nAnd data, a 2-element Array{VariableRef,1}:\n x[1]\n x[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Since the value (and type) of A is unknown at parsing time, JuMP is unable to infer that A is a one-based integer range. Therefore, JuMP creates a DenseAxisArray, even though it could store these two variables in a standard one-dimensional Array.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We can share our knowledge that it is possible to store these JuMP variables as an array by setting the container keyword:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, y[A], container=Array)\n2-element Array{VariableRef,1}:\n y[1]\n y[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP now creates a vector of JuMP variables instead of a DenseAxisArray. Note that choosing an invalid container type will throw an error.","category":"page"},{"location":"manual/variables/#Integrality-utilities","page":"Variables","title":"Integrality utilities","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Adding integrality constraints to a model such as @constraint(model, x in MOI.ZeroOne()) and @constraint(model, x in MOI.Integer()) is a common operation. Therefore, JuMP supports two shortcuts for adding such constraints.","category":"page"},{"location":"manual/variables/#Binary-(ZeroOne)-constraints","page":"Variables","title":"Binary (ZeroOne) constraints","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Binary optimization variables are constrained to the set x in 0 1. (The MOI.ZeroOne set in MathOptInterface.) Binary optimization variables can be created in JuMP by passing Bin as an optional positional argument:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, Bin)\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We can check if an optimization variable is binary by calling is_binary on the JuMP variable, and binary constraints can be removed with unset_binary.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> is_binary(x)\ntrue\n\njulia> unset_binary(x)\n\njulia> is_binary(x)\nfalse","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Binary optimization variables can also be created by setting the binary keyword to true.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, binary=true)\nx","category":"page"},{"location":"manual/variables/#Integer-constraints","page":"Variables","title":"Integer constraints","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Integer optimization variables are constrained to the set x in mathbbZ. (The MOI.Integer set in MathOptInterface.) Integer optimization variables can be created in JuMP by passing Int as an optional positional argument:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, Int)\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Integer optimization variables can also be created by setting the integer keyword to true.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, integer=true)\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We can check if an optimization variable is integer by calling is_integer on the JuMP variable, and integer constraints can be removed with unset_integer.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> is_integer(x)\ntrue\n\njulia> unset_integer(x)\n\njulia> is_integer(x)\nfalse","category":"page"},{"location":"manual/variables/#Relaxing-integrality","page":"Variables","title":"Relaxing integrality","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The relax_integrality function relaxes all integrality constraints in the model, returning a function that can be called to undo the operation later on.","category":"page"},{"location":"manual/variables/#Semidefinite-variables","page":"Variables","title":"Semidefinite variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP also supports modeling with semidefinite variables. A square symmetric matrix X is positive semidefinite if all eigenvalues are nonnegative. We can declare a matrix of JuMP variables to be positive semidefinite as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2], PSD)\n2√ó2 LinearAlgebra.Symmetric{VariableRef,Array{VariableRef,2}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"or using the syntax for Variables constrained on creation:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2] in PSDCone())\n2√ó2 LinearAlgebra.Symmetric{VariableRef,Array{VariableRef,2}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Note that x must be a square 2-dimensional Array of JuMP variables; it cannot be a DenseAxisArray or a SparseAxisArray. (See Variable containers, above, for more on this.)","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"You can also impose a weaker constraint that the square matrix is only symmetric (instead of positive semidefinite) as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2], Symmetric)\n2√ó2 LinearAlgebra.Symmetric{VariableRef,Array{VariableRef,2}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"You can impose a constraint that the square matrix is skew symmetric with SkewSymmetricMatrixSpace:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2] in SkewSymmetricMatrixSpace())\n2√ó2 Array{GenericAffExpr{Float64,VariableRef},2}:\n 0        x[1,2]\n -x[1,2]  0","category":"page"},{"location":"manual/variables/#Anonymous-JuMP-variables","page":"Variables","title":"Anonymous JuMP variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"In all of the above examples, we have created named JuMP variables. However, it is also possible to create so called anonymous JuMP variables. To create an anonymous JuMP variable, we drop the name of the variable from the macro call. This means dropping the second positional argument if the JuMP variable is a scalar, or dropping the name before the square bracket ([) if a container is being created. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x = @variable(model)\nnoname","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"This shows how @variable(model, x) is really short for:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x = model[:x] = @variable(model, base_name=\"x\")\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"An Array of anonymous JuMP variables can be created as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> y = @variable(model, [i=1:2])\n2-element Array{VariableRef,1}:\n noname\n noname","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"If necessary, you can store x in model as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model[:x] = x","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The <= and >= short-hand cannot be used to set bounds on anonymous JuMP variables. Instead, you should use the lower_bound and upper_bound keywords.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Passing the Bin and Int variable types are also invalid. Instead, you should use the binary and integer keywords.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Thus, the anonymous variant of @variable(model, x[i=1:2] >= i, Int) is:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x = @variable(model, [i=1:2], base_name=\"x\", lower_bound=i, integer=true)\n2-element Array{VariableRef,1}:\n x[1]\n x[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"warn: Warn\nCreating two named JuMP variables with the same name results in an error at runtime. Use anonymous variables as an alternative.","category":"page"},{"location":"manual/variables/#jump_variables_on_creation","page":"Variables","title":"Variables constrained on creation","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"info: Info\nWhen using JuMP in Direct mode, it may be required to constrain variables on creation instead of constraining free variables as the solver may only support variables constrained on creation. In Automatic and Manual modes, both ways of adding constraints on variables are equivalent. Indeed, during the copy of the cache to the optimizer, the choice of the constraints on variables that are copied as variables constrained on creation does not depend on how it was added to the cache.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"All uses of the @variable macro documented so far translate to a separate call for variable creation and adding of constraints.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For example, @variable(model, x >= 0, Int), is equivalent to:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"@variable(model, x)\nset_lower_bound(x, 0.0)\n@constraint(model, x in MOI.Integer())","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Importantly, the bound and integrality constraints are added after the variable has been created.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"However, some solvers require a constraining set at creation time. We say that these variables are constrained on creation.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Use in within @variable to access the special syntax for constraining variables on creation. For example, the following creates a vector of variables constrained on creation to belong to the SecondOrderCone:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, y[1:3] in SecondOrderCone())\n3-element Array{VariableRef,1}:\n y[1]\n y[2]\n y[3]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For contrast, the more standard approach is as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in SecondOrderCone())\n[x[1], x[2], x[3]] ‚àà MathOptInterface.SecondOrderCone(3)","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The technical difference between the former and the latter is that the former calls MOI.add_constrained_variables while the latter calls MOI.add_variables and then MOI.add_constraint. This distinction is important only in Direct mode, depending on the solver being used. It's often not possible to delete the SecondOrderCone constraint if it was specified at variable creation time.","category":"page"},{"location":"manual/variables/#The-set-keyword","page":"Variables","title":"The set keyword","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"An alternate syntax to x in Set is to use the set keyword of @variable. This is most useful when creating anonymous variables:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"x = @variable(model, [1:2, 1:2], set = PSDCone())","category":"page"},{"location":"manual/variables/#User-defined-containers","page":"Variables","title":"User-defined containers","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"In the section Variable containers, we explained how JuMP supports the efficient creation of collections of JuMP variables in three types of containers. However, users are also free to create collections of JuMP variables in their own data structures. For example, the following code creates a dictionary with symmetric matrices as the values:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> variables = Dict{Symbol, Array{VariableRef,2}}()\nDict{Symbol,Array{VariableRef,2}} with 0 entries\n\njulia> for key in [:A, :B]\n           global variables[key] = @variable(model, [1:2, 1:2])\n       end\n\njulia> variables\nDict{Symbol,Array{VariableRef,2}} with 2 entries:\n  :A => VariableRef[noname noname; noname noname]\n  :B => VariableRef[noname noname; noname noname]","category":"page"},{"location":"manual/variables/#Deleting-variables","page":"Variables","title":"Deleting variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Variables can be deleted from a model using delete.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Check if a variable reference is valid using is_valid.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x)\nx\n\njulia> is_valid(model, x)\ntrue\n\njulia> delete(model, x)\n\njulia> is_valid(model, x)\nfalse","category":"page"},{"location":"manual/variables/#Listing-all-variables","page":"Variables","title":"Listing all variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Use JuMP.all_variables to obtain a list of all variables present in the model. This is useful for performing operations like:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"relaxing all integrality constraints in the model\nsetting the starting values for variables to the result of the last solve","category":"page"},{"location":"manual/variables/#Start-values","page":"Variables","title":"Start values","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"There are two ways to provide a primal starting solution (also called MIP-start or a warmstart) for each variable:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"using the start keyword in the @variable macro\nusing set_start_value","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The starting value of a variable can be queried using start_value. If no start value has been set, start_value will return nothing.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x)\nx\n\njulia> start_value(x)\n\njulia> @variable(model, y, start = 1)\ny\n\njulia> start_value(y)\n1.0\n\njulia> set_start_value(y, 2)\n\njulia> start_value(y)\n2.0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"note: Note\nPrior to JuMP 0.19, the previous solution to a solve was automatically set as the new starting value. JuMP 0.19 no longer does this automatically. To reproduce the functionality, use:set_start_value.(all_variables(model), value.(all_variables(model)))","category":"page"},{"location":"manual/variables/#variables","page":"Variables","title":"The @variables macro","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"If you have many @variable calls, JuMP provides the macro @variables that can improve readability:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variables(model, begin\n           x\n           y[i=1:2] >= i, (start = i, base_name = \"Y_$i\")\n           z, Bin\n       end)\n\njulia> print(model)\nFeasibility\nSubject to\n Y_1[1] ‚â• 1.0\n Y_2[2] ‚â• 2.0\n z binary","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"note: Note\nKeyword arguments must be contained within parentheses. (See the example above.)","category":"page"},{"location":"moi/reference/constraints/","page":"Constraints","title":"Constraints","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/reference/constraints/","page":"Constraints","title":"Constraints","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/constraints/#constraints_ref","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"moi/reference/constraints/#Types","page":"Constraints","title":"Types","text":"","category":"section"},{"location":"moi/reference/constraints/","page":"Constraints","title":"Constraints","text":"ConstraintIndex","category":"page"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintIndex","page":"Constraints","title":"MathOptInterface.ConstraintIndex","text":"ConstraintIndex{F, S}\n\nA type-safe wrapper for Int64 for use in referencing F-in-S constraints in a model. The parameter F is the type of the function in the constraint, and the parameter S is the type of set in the constraint. To allow for deletion, indices need not be consecutive. Indices within a constraint type (i.e. F-in-S) must be unique, but non-unique indices across different constraint types are allowed. If F is SingleVariable then the index is equal to the index of the variable. That is for an index::ConstraintIndex{SingleVariable}, we always have\n\nindex.value == MOI.get(model, MOI.ConstraintFunction(), index).variable.value\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#Functions","page":"Constraints","title":"Functions","text":"","category":"section"},{"location":"moi/reference/constraints/","page":"Constraints","title":"Constraints","text":"is_valid(::ModelLike,::ConstraintIndex)\nadd_constraint\nadd_constraints\ntransform\nsupports_constraint","category":"page"},{"location":"moi/reference/constraints/#MathOptInterface.is_valid-Tuple{MathOptInterface.ModelLike,MathOptInterface.ConstraintIndex}","page":"Constraints","title":"MathOptInterface.is_valid","text":"is_valid(model::ModelLike, index::Index)::Bool\n\nReturn a Bool indicating whether this index refers to a valid object in the model model.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/constraints/#MathOptInterface.add_constraint","page":"Constraints","title":"MathOptInterface.add_constraint","text":"add_constraint(model::ModelLike, func::F, set::S)::ConstraintIndex{F,S} where {F,S}\n\nAdd the constraint f(x) in mathcalS where f is defined by func, and mathcalS is defined by set.\n\nadd_constraint(model::ModelLike, v::VariableIndex, set::S)::ConstraintIndex{SingleVariable,S} where {S}\nadd_constraint(model::ModelLike, vec::Vector{VariableIndex}, set::S)::ConstraintIndex{VectorOfVariables,S} where {S}\n\nAdd the constraint v in mathcalS where v is the variable (or vector of variables) referenced by v and mathcalS is defined by set.\n\nAn UnsupportedConstraint error is thrown if model does not support F-in-S constraints,\na AddConstraintNotAllowed error is thrown if it supports F-in-S constraints but it cannot add the constraint(s) in its current state and\na ScalarFunctionConstantNotZero error may be thrown if func is an AbstractScalarFunction with nonzero constant and set is EqualTo, GreaterThan, LessThan or Interval.\na LowerBoundAlreadySet error is thrown if F is a SingleVariable and a constraint was already added to this variable that sets a lower bound.\na UpperBoundAlreadySet error is thrown if F is a SingleVariable and a constraint was already added to this variable that sets an upper bound.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/constraints/#MathOptInterface.add_constraints","page":"Constraints","title":"MathOptInterface.add_constraints","text":"add_constraints(model::ModelLike, funcs::Vector{F}, sets::Vector{S})::Vector{ConstraintIndex{F,S}} where {F,S}\n\nAdd the set of constraints specified by each function-set pair in funcs and sets. F and S should be concrete types. This call is equivalent to add_constraint.(model, funcs, sets) but may be more efficient.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/constraints/#MathOptInterface.transform","page":"Constraints","title":"MathOptInterface.transform","text":"Transform Constraint Set\n\ntransform(model::ModelLike, c::ConstraintIndex{F,S1}, newset::S2)::ConstraintIndex{F,S2}\n\nReplace the set in constraint c with newset. The constraint index c will no longer be valid, and the function returns a new constraint index with the correct type.\n\nSolvers may only support a subset of constraint transforms that they perform efficiently (for example, changing from a LessThan to GreaterThan set). In addition, set modification (where S1 = S2) should be performed via the modify function.\n\nTypically, the user should delete the constraint and add a new one.\n\nExamples\n\nIf c is a ConstraintIndex{ScalarAffineFunction{Float64},LessThan{Float64}},\n\nc2 = transform(model, c, GreaterThan(0.0))\ntransform(model, c, LessThan(0.0)) # errors\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/constraints/#MathOptInterface.supports_constraint","page":"Constraints","title":"MathOptInterface.supports_constraint","text":"MOI.supports_constraint(BT::Type{<:AbstractBridge}, F::Type{<:MOI.AbstractFunction}, S::Type{<:MOI.AbstractSet})::Bool\n\nReturn a Bool indicating whether the bridges of type BT support bridging F-in-S constraints.\n\n\n\n\n\nsupports_constraint(model::ModelLike, ::Type{F}, ::Type{S})::Bool where {F<:AbstractFunction,S<:AbstractSet}\n\nReturn a Bool indicating whether model supports F-in-S constraints, that is, copy_to(model, src) does not throw UnsupportedConstraint when src contains F-in-S constraints. If F-in-S constraints are only not supported in specific circumstances, e.g. F-in-S constraints cannot be combined with another type of constraint, it should still return true.\n\nsupports_constraint(model::ModelLike, ::Type{VectorOfVariables}, ::Type{Reals})::Bool\n\nReturn a Bool indicating whether model supports free variables. That is, copy_to(model, src) does not error when src contains variables that are not constrained by any SingleVariable or VectorOfVariables constraint. By default, this method returns true so it should only be implemented if model does not support free variables. For instance, if a solver requires all variables to be nonnegative, it should implement this method and return false because free variables cannot be copied to the solver.\n\nNote that free variables are not explicitly set to be free by calling add_constraint with the set Reals, instead, free variables are created with add_variable and add_variables. If model does not support free variables, it should not implement add_variable nor add_variables but should implement this method and return false. This allows free variables to be bridged as the sum of a nonnegative and a nonpositive variables.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/constraints/#Attributes","page":"Constraints","title":"Attributes","text":"","category":"section"},{"location":"moi/reference/constraints/","page":"Constraints","title":"Constraints","text":"AbstractConstraintAttribute\nConstraintName\nConstraintPrimalStart\nConstraintDualStart\nConstraintPrimal\nConstraintDual\nConstraintBasisStatus\nBasisStatusCode\nConstraintFunction\nCanonicalConstraintFunction\nConstraintSet","category":"page"},{"location":"moi/reference/constraints/#MathOptInterface.AbstractConstraintAttribute","page":"Constraints","title":"MathOptInterface.AbstractConstraintAttribute","text":"AbstractConstraintAttribute\n\nAbstract supertype for attribute objects that can be used to set or get attributes (properties) of constraints in the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintName","page":"Constraints","title":"MathOptInterface.ConstraintName","text":"ConstraintName()\n\nA constraint attribute for a string identifying the constraint. It is valid for constraints variables to have the same name; however, constraints with duplicate names cannot be looked up using get regardless of if they have the same F-in-S type. It has a default value of \"\" if not set.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintPrimalStart","page":"Constraints","title":"MathOptInterface.ConstraintPrimalStart","text":"ConstraintPrimalStart()\n\nA constraint attribute for the initial assignment to some constraint's primal value(s) that the optimizer may use to warm-start the solve. May be a number or nothing (unset).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintDualStart","page":"Constraints","title":"MathOptInterface.ConstraintDualStart","text":"ConstraintDualStart()\n\nA constraint attribute for the initial assignment to some constraint's dual value(s) that the optimizer may use to warm-start the solve. May be a number or nothing (unset).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintPrimal","page":"Constraints","title":"MathOptInterface.ConstraintPrimal","text":"ConstraintPrimal(N)\nConstraintPrimal()\n\nA constraint attribute for the assignment to some constraint's primal value(s) in result N. If N is omitted, it is 1 by default.\n\nGiven a constraint function-in-set, the ConstraintPrimal is the value of the function evaluated at the primal solution of the variables. For example, given the constraint ScalarAffineFunction([x,y], [1, 2], 3)-in-Interval(0, 20) and a primal solution of (x,y) = (4,5), the ConstraintPrimal solution of the constraint is 1 * 4 + 2 * 5 + 3 = 17.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintDual","page":"Constraints","title":"MathOptInterface.ConstraintDual","text":"ConstraintDual(N)\nConstraintDual()\n\nA constraint attribute for the assignment to some constraint's dual value(s) in result N. If N is omitted, it is 1 by default.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintBasisStatus","page":"Constraints","title":"MathOptInterface.ConstraintBasisStatus","text":"ConstraintBasisStatus(result_index)\nConstraintBasisStatus()\n\nA constraint attribute for the BasisStatusCode of some constraint in result result_index, with respect to an available optimal solution basis. If result_index is omitted, it is 1 by default.\n\nFor the basis status of a variable, query the corresponding SingleVariable constraint that enforces the variable's bounds.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.BasisStatusCode","page":"Constraints","title":"MathOptInterface.BasisStatusCode","text":"BasisStatusCode\n\nAn Enum of possible values for the ConstraintBasisStatus attribute, explaining the status of a given element with respect to an optimal solution basis.\n\nPossible values are:\n\nBASIC: element is in the basis\nNONBASIC: element is not in the basis\nNONBASIC_AT_LOWER: element is not in the basis and is at its lower bound\nNONBASIC_AT_UPPER: element is not in the basis and is at its upper bound\nSUPER_BASIC: element is not in the basis but is also not at one of its bounds\n\nNotes\n\nNONBASIC_AT_LOWER and NONBASIC_AT_UPPER should be used only for constraints with the Interval set. In this case, they are necessary to distinguish which side of the constraint is active. One-sided constraints (e.g., LessThan and GreaterThan) should use NONBASIC instead of the NONBASIC_AT_* values.\nIn general, SUPER_BASIC usually occurs when the problem is nonlinear. For linear programs, SUPER_BASIC variables only occur if the solver returns a solution that is not at a vertex of the feasible region.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintFunction","page":"Constraints","title":"MathOptInterface.ConstraintFunction","text":"ConstraintFunction()\n\nA constraint attribute for the AbstractFunction object used to define the constraint. It is guaranteed to be equivalent but not necessarily identical to the function provided by the user.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.CanonicalConstraintFunction","page":"Constraints","title":"MathOptInterface.CanonicalConstraintFunction","text":"CanonicalConstraintFunction()\n\nA constraint attribute for a canonical representation of the AbstractFunction object used to define the constraint. Getting this attribute is guaranteed to return a function that is equivalent but not necessarily identical to the function provided by the user.\n\nBy default, MOI.get(model, MOI.CanonicalConstraintFunction(), ci) fallbacks to MOI.Utilities.canonical(MOI.get(model, MOI.ConstraintFunction(), ci)). However, if model knows that the constraint function is canonical then it can implement a specialized method that directly return the function without calling Utilities.canonical. Therefore, the value returned cannot be assumed to be a copy of the function stored in model. Moreover, Utilities.Model checks with Utilities.is_canonical whether the function stored internally is already canonical and if it's the case, then it returns the function stored internally instead of a copy.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintSet","page":"Constraints","title":"MathOptInterface.ConstraintSet","text":"ConstraintSet()\n\nA constraint attribute for the AbstractSet object used to define the constraint.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/Semidefinite programs/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Semidefinite programs/cluster.jl\"","category":"page"},{"location":"tutorials/Semidefinite programs/cluster/#K-means-clustering-via-SDP","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"From \"Approximating K-means-type clustering via semidefinite programming\" By Jiming Peng and Yu Wei.","category":"page"},{"location":"tutorials/Semidefinite programs/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"Given a set of points a_1 ldots a_m  in R_n, allocate them to k clusters.","category":"page"},{"location":"tutorials/Semidefinite programs/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"using JuMP\nimport LinearAlgebra\nimport SCS\n\nfunction example_cluster(; verbose = true)\n    # Data points\n    n = 2\n    m = 6\n    a = Any[\n        [2.0, 2.0], [2.5, 2.1], [7.0, 7.0], [2.2, 2.3], [6.8, 7.0], [7.2, 7.5]\n    ]\n    k = 2\n    # Weight matrix\n    W = zeros(m, m)\n    for i in 1:m\n        for j in i + 1:m\n            W[i, j] = W[j, i] = exp(-LinearAlgebra.norm(a[i] - a[j]) / 1.0)\n        end\n    end\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    # Z >= 0, PSD\n    @variable(model, Z[1:m, 1:m], PSD)\n    @constraint(model, Z .>= 0)\n    # min Tr(W(I-Z))\n    I = Matrix(1.0 * LinearAlgebra.I, m, m)\n    @objective(model, Min, LinearAlgebra.tr(W * (I - Z)))\n    # Z e = e\n    @constraint(model, Z * ones(m) .== ones(m))\n    # Tr(Z) = k\n    @constraint(model, LinearAlgebra.tr(Z) == k)\n    optimize!(model)\n    Z_val = value.(Z)\n    # A simple rounding scheme\n    which_cluster = zeros(Int, m)\n    num_clusters = 0\n    for i in 1:m\n        Z_val[i, i] <= 1e-6 && continue\n        if which_cluster[i] == 0\n            num_clusters += 1\n            which_cluster[i] = num_clusters\n            for j in i + 1:m\n                if LinearAlgebra.norm(Z_val[i, j] - Z_val[i, i]) <= 1e-6\n                    which_cluster[j] = num_clusters\n                end\n            end\n        end\n    end\n    if verbose\n        # Print results\n        for cluster in 1:k\n            println(\"Cluster $cluster\")\n            for i in 1:m\n                if which_cluster[i] == cluster\n                    println(a[i])\n                end\n            end\n        end\n    end\n    return\nend\n\nexample_cluster()","category":"page"},{"location":"tutorials/Semidefinite programs/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"View this file on Github.","category":"page"},{"location":"tutorials/Semidefinite programs/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"","category":"page"},{"location":"tutorials/Semidefinite programs/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"This page was generated using Literate.jl.","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/FileFormats/overview/#The-FileFormats-submodule","page":"Overview","title":"The FileFormats submodule","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The FileFormats module provides functionality for reading and writing MOI models using write_to_file and read_from_file.","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Supported-file-types","page":"Overview","title":"Supported file types","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"You must read and write files to a FileFormats.Model object. Specifc the file-type by passing a FileFormats.FileFormat enum. For example:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The Conic Benchmark Format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_CBF)\nA Conic Benchmark Format (CBF) model","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The LP file format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_LP)\nA .LP-file model","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The MathOptFormat file format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MOF)\nA MathOptFormat Model","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The MPS file format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MPS)\nA Mathematical Programming System (MPS) model","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The SDPA file format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_SDPA)\nA SemiDefinite Programming Algorithm Format (SDPA) model","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Write-to-file","page":"Overview","title":"Write to file","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"To write a model src to a MathOptFormat file, use:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> src = MOI.Utilities.Model{Float64}()\nMOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\n\njulia> MOI.add_variable(src)\nMathOptInterface.VariableIndex(1)\n\njulia> dest = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MOF)\nA MathOptFormat Model\n\njulia> MOI.copy_to(dest, src)\nMathOptInterface.Utilities.IndexMap with 1 entry:\n  VariableIndex(1) => VariableIndex(1)\n\njulia> MOI.write_to_file(dest, \"file.mof.json\")\n\njulia> print(read(\"file.mof.json\", String))\n{\n  \"name\": \"MathOptFormat Model\",\n  \"version\": {\n    \"major\": 0,\n    \"minor\": 5\n  },\n  \"variables\": [\n    {\n      \"name\": \"x1\"\n    }\n  ],\n  \"objective\": {\n    \"sense\": \"feasibility\"\n  },\n  \"constraints\": []\n}","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Read-from-file","page":"Overview","title":"Read from file","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"To read a MathOptFormat file, use:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> dest = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MOF)\nA MathOptFormat Model\n\njulia> MOI.read_from_file(dest, \"file.mof.json\")\n\njulia> MOI.get(dest, MOI.ListOfVariableIndices())\n1-element Array{MathOptInterface.VariableIndex,1}:\n MathOptInterface.VariableIndex(1)\n\njulia> rm(\"file.mof.json\")  # Clean up after ourselves.","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Detecing-the-filetype-automatically","page":"Overview","title":"Detecing the filetype automatically","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"Instead of the format keyword, you can also use the filename keyword argument to FileFormats.Model. This will attempt to automatically guess the format from the file extension. For example:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> src = MOI.Utilities.Model{Float64}()\nMOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\n\njulia> dest = MOI.FileFormats.Model(filename = \"file.cbf.gz\")\nA Conic Benchmark Format (CBF) model\n\njulia> MOI.copy_to(dest, src)\nMathOptInterface.Utilities.IndexMap with 0 entries\n\njulia> MOI.write_to_file(dest, \"file.cbf.gz\")\n\njulia> src_2 = MOI.FileFormats.Model(filename = \"file.cbf.gz\")\nA Conic Benchmark Format (CBF) model\n\njulia> src = MOI.Utilities.Model{Float64}()\nMOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\n\njulia> dest = MOI.FileFormats.Model(filename = \"file.cbf.gz\")\nA Conic Benchmark Format (CBF) model\n\njulia> MOI.copy_to(dest, src)\nMathOptInterface.Utilities.IndexMap with 0 entries\n\njulia> MOI.write_to_file(dest, \"file.cbf.gz\")\n\njulia> src_2 = MOI.FileFormats.Model(filename = \"file.cbf.gz\")\nA Conic Benchmark Format (CBF) model\n\njulia> MOI.read_from_file(src_2, \"file.cbf.gz\")\n\njulia> rm(\"file.cbf.gz\")  # Clean up after ourselves.","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"Note how the compression format (GZip) is also automatically detected from the filename.","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Unsupported-constraints","page":"Overview","title":"Unsupported constraints","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"In some cases src may contain constraints that are not supported by the file format (e.g., the CBF format supports integer variables but not binary). If so, you should copy src to a bridged model using Bridges.full_bridge_optimizer:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"src = MOI.Utilities.Model{Float64}()\nx = MOI.add_variable(model)\nMOI.add_constraint(model, MOI.SingleVariable(x), MOI.ZeroOne())\ndest = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_CBF)\nbridged = MOI.Bridges.full_bridge_optimizer(dest, Float64)\nMOI.copy_to(bridged, src)\nMOI.write_to_file(dest, \"my_model.cbf\")","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"You should also note that even after bridging, it may still not be possible to write the model to file because of unsupported constraints (e.g., PSD variables in the LP file format).","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Read-and-write-to-io","page":"Overview","title":"Read and write to io","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"In addition to write_to_file and read_from_file, you can read and write directly from IO streams using Base.write and Base.read!:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> src = MOI.Utilities.Model{Float64}()\nMOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\n\njulia> dest = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MPS)\nA Mathematical Programming System (MPS) model\n\njulia> MOI.copy_to(dest, src)\nMathOptInterface.Utilities.IndexMap with 0 entries\n\njulia> io = IOBuffer()\nIOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0, maxsize=Inf, ptr=1, mark=-1)\n\njulia> write(io, dest)\n\njulia> seekstart(io)\nIOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=61, maxsize=Inf, ptr=1, mark=-1)\n\njulia> src_2 = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MPS)\nA Mathematical Programming System (MPS) model\n\njulia> read!(io, src_2)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/urban_plan.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/urban_plan/#The-urban-planning-problem","page":"The urban planning problem","title":"The urban planning problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"An \"urban planning\" problem based on an example from puzzlor.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_urban_plan()\n    model = Model(GLPK.Optimizer)\n    # x is indexed by row and column\n    @variable(model, 0 <= x[1:5, 1:5] <= 1, Int)\n    # y is indexed by R or C, the points, and an index in 1:5. Note how JuMP\n    # allows indexing on arbitrary sets.\n    rowcol = [\"R\", \"C\"]\n    points = [5, 4, 3, -3, -4, -5]\n    @variable(model, 0 <= y[rowcol, points, 1:5] <= 1, Int)\n    # Objective - combine the positive and negative parts\n    @objective(model, Max, sum(\n          3 * (y[\"R\", 3, i] + y[\"C\", 3, i])\n        + 1 * (y[\"R\", 4, i] + y[\"C\", 4, i])\n        + 1 * (y[\"R\", 5, i] + y[\"C\", 5, i])\n        - 3 * (y[\"R\", -3, i] + y[\"C\", -3, i])\n        - 1 * (y[\"R\", -4, i] + y[\"C\", -4, i])\n        - 1 * (y[\"R\", -5, i] + y[\"C\", -5, i])\n        for i in 1:5)\n    )\n    # Constrain the number of residential lots\n    @constraint(model, sum(x) == 12)\n    # Add the constraints that link the auxiliary y variables to the x variables\n    for i = 1:5\n        @constraints(model, begin\n            # Rows\n            y[\"R\", 5, i] <= 1 / 5 * sum(x[i, :]) # sum = 5\n            y[\"R\", 4, i] <= 1 / 4 * sum(x[i, :]) # sum = 4\n            y[\"R\", 3, i] <= 1 / 3 * sum(x[i, :]) # sum = 3\n            y[\"R\", -3, i] >= 1 - 1 / 3 * sum(x[i, :]) # sum = 2\n            y[\"R\", -4, i] >= 1 - 1 / 2 * sum(x[i, :]) # sum = 1\n            y[\"R\", -5, i] >= 1 - 1 / 1 * sum(x[i, :]) # sum = 0\n            # Columns\n            y[\"C\", 5, i] <= 1 / 5 * sum(x[:, i]) # sum = 5\n            y[\"C\", 4, i] <= 1 / 4 * sum(x[:, i]) # sum = 4\n            y[\"C\", 3, i] <= 1 / 3 * sum(x[:, i]) # sum = 3\n            y[\"C\", -3, i] >= 1 - 1 / 3 * sum(x[:, i]) # sum = 2\n            y[\"C\", -4, i] >= 1 - 1 / 2 * sum(x[:, i]) # sum = 1\n            y[\"C\", -5, i] >= 1 - 1 / 1 * sum(x[:, i]) # sum = 0\n        end)\n    end\n    # Solve it\n    optimize!(model)\n    Test.@test termination_status(model) == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ‚âà 14.0\n    return\nend\n\nexample_urban_plan()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/tips_and_tricks.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Tips-and-tricks","page":"Tips and tricks","title":"Tips and tricks","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"tip: Tip\nA good source of tips is the Mosek Modeling Cookbook.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This tutorial collates some tips and tricks you can use when formulating mixed-integer programs. It uses the following packages:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"using JuMP","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Boolean-Operators-on-Binary-Variables","page":"Tips and tricks","title":"Boolean Operators on Binary Variables","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Binary variables can be used to construct logical operators. Here are some example.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#OR","page":"Tips and tricks","title":"OR","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x_3 = x_1 lor x_2","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:3], Bin)\n@constraints(model, begin\n    x[1] <= x[3]\n    x[2] <= x[3]\nend)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#And","page":"Tips and tricks","title":"And","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x_3 = x_1 land x_2","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:3], Bin)\n@constraints(model, begin\n    x[3] <= x[1]\n    x[3] <= x[2]\n    x[3] >= x[1] + x[2] - 1\nend)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Not","page":"Tips and tricks","title":"Not","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x_1 neg x_2","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2], Bin)\n@constraint(model, x[1] == 1 - x[2])","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Implies","page":"Tips and tricks","title":"Implies","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x_1 implies x_2","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2], Bin)\n@constraint(model, x[1] <= x[2])","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Big-M-Disjunctive-Constraints-(OR)","page":"Tips and tricks","title":"Big-M Disjunctive Constraints (OR)","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Problem Suppose that we have two constraints a^top x leq b and c^top x leq d, and we want at least one to hold.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Trick Introduce a \"big-M\" multiplied by a binary variable to relax one of the constraints.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example Either x_1 leq 1 and/or x_2 leq 2.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2])\n@variable(model, y, Bin)\nM = 100\n@constraint(model, x[1] <= 1 + M * y)\n@constraint(model, x[2] <= 2 + M * (1 - y))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"warning: Warning\nIf M is too small, the solution may be suboptimal. If M is too big, the solver may encounter numerical issues. Try to use domain knowledge to choose an M that is just right. Gurobi has a good documentation section on this topic.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Indicator-Constraints-(\\implies)","page":"Tips and tricks","title":"Indicator Constraints (implies)","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Problem","page":"Tips and tricks","title":"Problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Suppose we want to model that a certain linear inequality must be satisfied when some other event occurs, i.e., for a binary variable z, we want to model the implication:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"z = 1 implies a^Tx leq b","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Trick-1","page":"Tips and tricks","title":"Trick 1","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Some solvers have native support for indicator constraints.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x_1 + x_2 leq 1 if z = 1.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2])\n@variable(model, z, Bin)\n@constraint(model, z => {sum(x) <= 1})","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x_1 + x_2 leq 1 if z = 0.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2])\n@variable(model, z, Bin)\n@constraint(model, !z => {sum(x) <= 1})","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Trick-2","page":"Tips and tricks","title":"Trick 2","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"If the solver doesn't support indicator constraints, you an use the big-M trick.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x_1 + x_2 leq 1 if z = 1.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2])\n@variable(model, z, Bin)\nM = 100\n@constraint(model, sum(x) <=  1 + M * (1 - z))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x_1 + x_2 leq 1 if z = 0.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2])\n@variable(model, z, Bin)\nM = 100\n@constraint(model, sum(x) <=  1 + M * z)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Semi-Continuous-Variables","page":"Tips and tricks","title":"Semi-Continuous Variables","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A semi-continuous variable is a continuous variable between bounds lu that also can assume the value zero. ie. x in 0 cup lu","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x in 0cup 1 2","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x in MOI.Semicontinuous(1.0, 2.0))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Semi-Integer-Variables","page":"Tips and tricks","title":"Semi-Integer Variables","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A semi-integer variable is a variable which assumes integer values between bounds lu and can also assume the value zero: x in 0 cup l u cap mathbbZ","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x in MOI.Semiinteger(5.0, 10.0))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Special-Ordered-Sets-of-Type-I-(SOS1)","page":"Tips and tricks","title":"Special Ordered Sets of Type I (SOS1)","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A Special Ordered Set of Type I is a set of variables, at most one of which can take a non-zero value, all others being at 0.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"They most frequently apply where a set of variables are actually binary variables. In other words, we have to choose at most one from a set of possibilities.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:3], Bin)\n@constraint(model, x in SOS1())","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"You can optionally pass SOS1 a weight vector like","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"@constraint(model, x in SOS1([0.2, 0.5, 0.3]))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"If the decision variables are related and have a physical ordering, then the weight vector, although not used directly in the constraint, can help the solver make a better decision in the solution process.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#tip_sos2","page":"Tips and tricks","title":"Special Ordered Sets of Type II (SOS2)","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A Special Ordered Set of type 2 is a set of non-negative variables, of which at most two can be non-zero, and if two are non-zero these must be consecutive in their ordering.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:3])\n@constraint(model, x in MOI.SOS2([3.0, 1.0, 2.0]))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"The ordering provided by the weight vector is more important in this case as the variables need to be consecutive according to the ordering. For example, in the above constraint, the possible pairs are:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Consecutive\n(x[1] and x[3]) as they correspond to 3 and 2 resp. and thus can be non-zero\n(x[2] and x[3]) as they correspond to 1 and 2 resp. and thus can be non-zero\nNon-consecutive\n(x[1] and x[2]) as they correspond to 3 and 1 resp. and thus cannot be non-zero","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Piecewise-linear-approximations","page":"Tips and tricks","title":"Piecewise linear approximations","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"SOSII constraints are most often used to form piecewise linear approximations of a function.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Given a set of points for x:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"xÃÇ = -1:0.5:2","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"and a set of corresponding points for y:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"yÃÇ = xÃÇ.^2","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"the piecewise linear approximation is constructed by representing x and y as convex combinations of xÃÇ and yÃÇ.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"N = length(xÃÇ)\nmodel = Model()\n@variable(model, -1 <= x <= 2)\n@variable(model, y)\n@variable(model, 0 <= Œª[1:N] <= 1)\n@objective(model, Max, y)\n@constraints(model, begin\n    x == sum(xÃÇ[i] * Œª[i] for i = 1:N)\n    y == sum(yÃÇ[i] * Œª[i] for i = 1:N)\n    sum(Œª) == 1\n    Œª in SOS2()\nend)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Nonlinear programs/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Nonlinear programs/rosenbrock.jl\"","category":"page"},{"location":"tutorials/Nonlinear programs/rosenbrock/#The-Rosenbrock-function","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"A nonlinear example of the classical Rosenbrock function.","category":"page"},{"location":"tutorials/Nonlinear programs/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"using JuMP\nimport Ipopt\nimport Test\n\nfunction example_rosenbrock()\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, x)\n    @variable(model, y)\n    @NLobjective(model, Min, (1 - x)^2 + 100 * (y - x^2)^2)\n    optimize!(model)\n\n    Test.@test termination_status(model) == MOI.LOCALLY_SOLVED\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ‚âà 0.0 atol = 1e-10\n    Test.@test value(x) ‚âà 1.0\n    Test.@test value(y) ‚âà 1.0\n    return\nend\n\nexample_rosenbrock()","category":"page"},{"location":"tutorials/Nonlinear programs/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"View this file on Github.","category":"page"},{"location":"tutorials/Nonlinear programs/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"","category":"page"},{"location":"tutorials/Nonlinear programs/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"‚â§|<=\", r\"‚â•|>=\", r\" == | = \", r\" ‚àà | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/objective/#Objectives","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"This page describes macros and functions related to linear and quadratic objective functions only, unless otherwise indicated. For nonlinear objective functions, see Nonlinear Modeling.","category":"page"},{"location":"manual/objective/#Set-a-linear-objective","page":"Objectives","title":"Set a linear objective","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use the @objective macro to set a linear objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use Min to create a minimization objective:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x + 1)\n2 x + 1","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use Max to create a maximization objective:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Max, 2x + 1)\n2 x + 1","category":"page"},{"location":"manual/objective/#Set-a-quadratic-objective","page":"Objectives","title":"Set a quadratic objective","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use the @objective macro to set a quadratic objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use ^2 to have a variable squared:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, x^2 + 2x + 1)\nx¬≤ + 2 x + 1","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"You can also have bilinear terms between variables:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @objective(model, Max, x * y + x + y)\nx*y + x + y","category":"page"},{"location":"manual/objective/#Query-the-objective-function","page":"Objectives","title":"Query the objective function","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use objective_function to return the current objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x + 1)\n2 x + 1\n\njulia> objective_function(model)\n2 x + 1","category":"page"},{"location":"manual/objective/#Query-the-objective-sense","page":"Objectives","title":"Query the objective sense","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use objective_sense to return the current objective sense.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x + 1)\n2 x + 1\n\njulia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0","category":"page"},{"location":"manual/objective/#Modify-an-objective","page":"Objectives","title":"Modify an objective","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"To modify an objective, call @objective with the new objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x)\n2 x\n\njulia> @objective(model, Max, -2x)\n-2 x","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Alternatively, use set_objective_function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x)\n2 x\n\njulia> new_objective = @expression(model, -2 * x)\n-2 x\n\njulia> set_objective_function(model, new_objective)","category":"page"},{"location":"manual/objective/#Modify-an-objective-coefficient","page":"Objectives","title":"Modify an objective coefficient","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use set_objective_coefficient to modify an objective coefficient.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x)\n2 x\n\njulia> set_objective_coefficient(model, x, 3)\n\njulia> objective_function(model)\n3 x","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"info: Info\nThere is no way to modify the coefficient of a quadratic term. Set a new objective instead.","category":"page"},{"location":"manual/objective/#Modify-the-objective-sense","page":"Objectives","title":"Modify the objective sense","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use set_objective_sense to modify the objective sense.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x)\n2 x\n\njulia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0\n\njulia> set_objective_sense(model, MOI.MAX_SENSE);\n\njulia> objective_sense(model)\nMAX_SENSE::OptimizationSense = 1","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Alternatively, call @objective and pass the existing objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x)\n2 x\n\njulia> @objective(model, Max, objective_function(model))\n2 x","category":"page"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\n\n    # For compatibility with both Julia 1.0.5 and 1.5.2\n    # Upon the Julia LTS version becoming 1.6, these imports could be dropped,\n    # and all ScalarAffineTerm and VariableIndex instances in doctests below\n    # could be replaced with MOI.ScalarAffineTerm and MOI.VariableIndex\n    # Check discussion at PR 1184: https://github.com/jump-dev/MathOptInterface.jl/pull/1184#discussion_r515300914\n    import MathOptInterface.ScalarAffineTerm\n    import MathOptInterface.VariableIndex\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Bridges/reference/#Bridges","page":"API Reference","title":"Bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.AbstractBridge\nBridges.AbstractBridgeOptimizer\nBridges.LazyBridgeOptimizer\nBridges.add_bridge\nBridges.remove_bridge\nBridges.has_bridge\nBridges.full_bridge_optimizer\nBridges.debug_supports_constraint\nBridges.debug_supports\nBridges.bridged_variable_function\nBridges.unbridged_variable_function","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.AbstractBridge","page":"API Reference","title":"MathOptInterface.Bridges.AbstractBridge","text":"AbstractBridge\n\nRepresents a bridged constraint or variable in a MathOptInterface.Bridges.AbstractBridgeOptimizer. It contains the indices of the variables and constraints that it has created in the model. These can be obtained using MathOptInterface.NumberOfVariables, MathOptInterface.ListOfVariableIndices, MathOptInterface.NumberOfConstraints and MathOptInterface.ListOfConstraintIndices using MathOptInterface.get with the bridge in place of the MathOptInterface.ModelLike. Attributes of the bridged model such as MathOptInterface.ConstraintDual and MathOptInterface.ConstraintPrimal, can be obtained using MathOptInterface.get with the bridge in place of the constraint index. These calls are used by the MathOptInterface.Bridges.AbstractBridgeOptimizer to communicate with the bridge so they should be implemented by the bridge.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.AbstractBridgeOptimizer","page":"API Reference","title":"MathOptInterface.Bridges.AbstractBridgeOptimizer","text":"AbstractBridgeOptimizer\n\nA bridge optimizer applies given constraint bridges to a given optimizer thus extending the types of supported constraints. The attributes of the inner optimizer are automatically transformed to make the bridges transparent, e.g. the variables and constraints created by the bridges are hidden.\n\nBy convention, the inner optimizer should be stored in a model field and the dictionary mapping constraint indices to bridges should be stored in a bridges field. If a bridge optimizer deviates from these conventions, it should implement the functions MOI.optimize! and bridge respectively.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.LazyBridgeOptimizer","page":"API Reference","title":"MathOptInterface.Bridges.LazyBridgeOptimizer","text":"LazyBridgeOptimizer{OT<:MOI.ModelLike} <: AbstractBridgeOptimizer\n\nThe LazyBridgeOptimizer combines several bridges, which are added using the add_bridge function. Whenever a constraint is added, it only attempts to bridge it if it is not supported by the internal model (hence its name Lazy). When bridging a constraint, it selects the minimal number of bridges needed. For instance, a constraint F-in-S can be bridged into a constraint F1-in-S1 (supported by the internal model) using bridge 1 or bridged into a constraint F2-in-S2 (unsupported by the internal model) using bridge 2 which can then be bridged into a constraint F3-in-S3 (supported by the internal model) using bridge 3, it will choose bridge 1 as it allows to bridge F-in-S using only one bridge instead of two if it uses bridge 2 and 3.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.add_bridge","page":"API Reference","title":"MathOptInterface.Bridges.add_bridge","text":"add_bridge(b::LazyBridgeOptimizer, BT::Type{<:AbstractBridge})\n\nEnable the use of the bridges of type BT by b.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.remove_bridge","page":"API Reference","title":"MathOptInterface.Bridges.remove_bridge","text":"remove_bridge(b::LazyBridgeOptimizer, BT::Type{<:AbstractBridge})\n\nDisable the use of the bridges of type BT by b.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.has_bridge","page":"API Reference","title":"MathOptInterface.Bridges.has_bridge","text":"has_bridge(b::LazyBridgeOptimizer, BT::Type{<:AbstractBridge})\n\nReturn a Bool indicating whether the bridges of type BT are used by b.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.full_bridge_optimizer","page":"API Reference","title":"MathOptInterface.Bridges.full_bridge_optimizer","text":"full_bridge_optimizer(model::MOI.ModelLike, ::Type{T}) where T\n\nReturns a LazyBridgeOptimizer bridging model for every bridge defined in this package and for the coefficient type T.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.debug_supports_constraint","page":"API Reference","title":"MathOptInterface.Bridges.debug_supports_constraint","text":"debug_supports_constraint(\n    b::LazyBridgeOptimizer, F::Type{<:MOI.AbstractFunction},\n    S::Type{<:MOI.AbstractSet}; io::IO = Base.stdout)\n\nPrints to io explanations for the value of MOI.supports_constraint with the same arguments.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.debug_supports","page":"API Reference","title":"MathOptInterface.Bridges.debug_supports","text":"debug_supports(b::LazyBridgeOptimizer, ::MOI.ObjectiveFunction{F}; io::IO = Base.stdout) where F\n\nPrints to io explanations for the value of MOI.supports with the same arguments.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.bridged_variable_function","page":"API Reference","title":"MathOptInterface.Bridges.bridged_variable_function","text":"bridged_variable_function(b::AbstractBridgeOptimizer,\n                          vi::MOI.VariableIndex)\n\nReturn a MOI.AbstractScalarFunction of variables of b.model that equals vi. That is, if the variable vi is bridged, it returns its expression in terms of the variables of b.model. Otherwise, it returns MOI.SingleVariable(vi).\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.unbridged_variable_function","page":"API Reference","title":"MathOptInterface.Bridges.unbridged_variable_function","text":"unbridged_variable_function(b::AbstractBridgeOptimizer,\n                            vi::MOI.VariableIndex)\n\nReturn a MOI.AbstractScalarFunction of variables of b that equals vi. That is, if the variable vi is an internal variable of b.model created by a bridge but not visible to the user, it returns its expression in terms of the variables of bridged variables. Otherwise, it returns MOI.SingleVariable(vi).\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#Constraint-bridges","page":"API Reference","title":"Constraint bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.Constraint.AbstractBridge\nBridges.Constraint.SingleBridgeOptimizer\nBridges.Constraint.add_all_bridges","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.AbstractBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.AbstractBridge","text":"AbstractBridge\n\nSubtype of MathOptInterface.Bridges.AbstractBridge for constraint bridges.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer","text":"SingleBridgeOptimizer{BT<:AbstractBridge, OT<:MOI.ModelLike} <: AbstractBridgeOptimizer\n\nThe SingleBridgeOptimizer bridges any constraint supported by the bridge BT. This is in contrast with the MathOptInterface.Bridges.LazyBridgeOptimizer which only bridges the constraints that are unsupported by the internal model, even if they are supported by one of its bridges.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.add_all_bridges","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.add_all_bridges","text":"add_all_bridges(bridged_model, ::Type{T})\n\nAdd all bridges defined in the Bridges.Constraint submodule to bridged_model. The coefficient type used is T.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#constraint_bridges_ref","page":"API Reference","title":"Bridges implemented","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.Constraint.GreaterToIntervalBridge\nBridges.Constraint.LessToIntervalBridge\nBridges.Constraint.GreaterToLessBridge\nBridges.Constraint.LessToGreaterBridge\nBridges.Constraint.NonnegToNonposBridge\nBridges.Constraint.NonposToNonnegBridge\nBridges.Constraint.VectorizeBridge\nBridges.Constraint.ScalarizeBridge\nBridges.Constraint.ScalarSlackBridge\nBridges.Constraint.VectorSlackBridge\nBridges.Constraint.ScalarFunctionizeBridge\nBridges.Constraint.VectorFunctionizeBridge\nBridges.Constraint.SplitIntervalBridge\nBridges.Constraint.RSOCBridge\nBridges.Constraint.SOCRBridge\nBridges.Constraint.QuadtoSOCBridge\nBridges.Constraint.SOCtoNonConvexQuadBridge\nBridges.Constraint.RSOCtoNonConvexQuadBridge\nBridges.Constraint.NormInfinityBridge\nBridges.Constraint.NormOneBridge\nBridges.Constraint.GeoMeantoRelEntrBridge\nBridges.Constraint.GeoMeanBridge\nBridges.Constraint.RelativeEntropyBridge\nBridges.Constraint.NormSpectralBridge\nBridges.Constraint.NormNuclearBridge\nBridges.Constraint.SquareBridge\nBridges.Constraint.RootDetBridge\nBridges.Constraint.LogDetBridge\nBridges.Constraint.SOCtoPSDBridge\nBridges.Constraint.RSOCtoPSDBridge\nBridges.Constraint.IndicatorActiveOnFalseBridge\nBridges.Constraint.IndicatorSOS1Bridge\nBridges.Constraint.SemiToBinaryBridge\nBridges.Constraint.ZeroOneBridge","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge","text":"GreaterToIntervalBridge{T, F<:MOI.AbstractScalarFunction} <:\n    AbstractToIntervalBridge{T, MOI.GreaterThan{T}, F}\n\nTransforms a F-in-GreaterThan{T} constraint into an F-in-Interval{T} constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.LessToIntervalBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.LessToIntervalBridge","text":"LessToIntervalBridge{T, F<:MOI.AbstractScalarFunction} <:\n    AbstractToIntervalBridge{T, MOI.LessThan{T}, F}\n\nTransforms a F-in-LessThan{T} constraint into an F-in-Interval{T} constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.GreaterToLessBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.GreaterToLessBridge","text":"GreaterToLessBridge{T, F<:MOI.AbstractScalarFunction, G<:MOI.AbstractScalarFunction} <:\n    FlipSignBridge{T, MOI.GreaterThan{T}, MOI.LessThan{T}, F, G}\n\nTransforms a G-in-GreaterThan{T} constraint into an F-in-LessThan{T} constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.LessToGreaterBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.LessToGreaterBridge","text":"LessToGreaterBridge{T, F<:MOI.AbstractScalarFunction, G<:MOI.AbstractScalarFunction} <:\n    FlipSignBridge{T, MOI.LessThan{T}, MOI.GreaterThan{T}, F, G}\n\nTransforms a G-in-LessThan{T} constraint into an F-in-GreaterThan{T} constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.NonnegToNonposBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.NonnegToNonposBridge","text":"NonnegToNonposBridge{T, F<:MOI.AbstractVectorFunction, G<:MOI.AbstractVectorFunction} <:\n    FlipSignBridge{T, MOI.Nonnegatives, MOI.Nonpositives, F, G}\n\nTransforms a G-in-Nonnegatives constraint into a F-in-Nonpositives constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.NonposToNonnegBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.NonposToNonnegBridge","text":"NonposToNonnegBridge{T, F<:MOI.AbstractVectorFunction, G<:MOI.AbstractVectorFunction} <:\n    FlipSignBridge{T, MOI.Nonpositives, MOI.Nonnegatives, F, G}\n\nTransforms a G-in-Nonpositives constraint into a F-in-Nonnegatives constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.VectorizeBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.VectorizeBridge","text":"VectorizeBridge{T, F, S, G}\n\nTransforms a constraint G-in-scalar_set_type(S, T) where S <: VectorLinearSet to F-in-S.\n\nExamples\n\nThe constraint SingleVariable-in-LessThan{Float64} becomes VectorAffineFunction{Float64}-in-Nonpositives, where T = Float64, F = VectorAffineFunction{Float64}, S = Nonpositives, and G = SingleVariable.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.ScalarizeBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.ScalarizeBridge","text":"ScalarizeBridge{T, F, S}\n\nTransforms a constraint AbstractVectorFunction-in-vector_set_type(S) where S <: LPCone{T} to F-in-S.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.ScalarSlackBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.ScalarSlackBridge","text":"ScalarSlackBridge{T, F, S}\n\nThe ScalarSlackBridge converts a constraint G-in-S where G is a function different from SingleVariable into the constraints F-in-EqualTo{T} and SingleVariable-in-S. F is the result of subtracting a SingleVariable from G. Typically G is the same as F, but that is not mandatory.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.VectorSlackBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.VectorSlackBridge","text":"VectorSlackBridge{T, F, S}\n\nThe VectorSlackBridge converts a constraint G-in-S where G is a function different from VectorOfVariables into the constraints Fin-Zeros and VectorOfVariables-in-S. F is the result of subtracting a VectorOfVariables from G. Tipically G is the same as F, but that is not mandatory.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge","text":"ScalarFunctionizeBridge{T, S}\n\nThe ScalarFunctionizeBridge converts a constraint SingleVariable-in-S into the constraint ScalarAffineFunction{T}-in-S.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge","text":"VectorFunctionizeBridge{T, S}\n\nThe VectorFunctionizeBridge converts a constraint VectorOfVariables-in-S into the constraint VectorAffineFunction{T}-in-S.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.SplitIntervalBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.SplitIntervalBridge","text":"SplitIntervalBridge{T, F, S, LS, US}\n\nThe SplitIntervalBridge splits a F-in-S constraint into a F-in-LS and a F-in-US constraint where we have either:\n\nS = MOI.Interval{T}, LS = MOI.GreaterThan{T} and US = MOI.LessThan{T},\nS = MOI.EqualTo{T}, LS = MOI.GreaterThan{T} and US = MOI.LessThan{T}, or\nS = MOI.Zeros, LS = MOI.Nonnegatives and US = MOI.Nonpositives.\n\nFor instance, if F is MOI.ScalarAffineFunction and S is MOI.Interval, it transforms the constraint l  a x + Œ±  u into the constraints a x + Œ±  l and a x + Œ±  u.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.RSOCBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.RSOCBridge","text":"RSOCBridge{T, F, G}\n\nThe RotatedSecondOrderCone is SecondOrderCone representable; see [1, p. 104]. Indeed, we have 2tu = (t2 + u2)^2 - (t2 - u2)^2 hence\n\n2tu ge lVert x rVert_2^2\n\nis equivalent to\n\n(t2 + u2)^2 ge lVert x rVert_2^2 + (t2 - u2)^2\n\nWe can therefore use the transformation (t u x) mapsto (t2+u2 t2-u2 x). Note that the linear transformation is a symmetric involution (i.e. it is its own transpose and its own inverse). That means in particular that the norm is of constraint primal and duals are preserved by the tranformation.\n\n[1] Ben-Tal, Aharon, and Arkadi Nemirovski. Lectures on modern convex optimization: analysis, algorithms, and engineering applications. Society for Industrial and Applied Mathematics, 2001.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.SOCRBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.SOCRBridge","text":"SOCRBridge{T, F, G}\n\nWe simply do the inverse transformation of RSOCBridge. In fact, as the transformation is an involution, we do the same transformation.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.QuadtoSOCBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.QuadtoSOCBridge","text":"QuadtoSOCBridge{T}\n\nThe set of points x satisfying the constraint\n\nfrac12x^T Q x + a^T x + b le 0\n\nis a convex set if Q is positive semidefinite and is the union of two convex cones if a and b are zero (i.e. homogeneous case) and Q has only one negative eigenvalue. Currently, only the non-homogeneous transformation is implemented, see the Note section below for more details.\n\nNon-homogeneous case\n\nIf Q is positive semidefinite, there exists U such that Q = U^T U, the inequality can then be rewritten as\n\nU x_2^2 le 2 (-a^T x - b)\n\nwhich is equivalent to the membership of (1, -a^T x - b, Ux) to the rotated second-order cone.\n\nHomogeneous case\n\nIf Q has only one negative eigenvalue, the set of x such that x^T Q x le 0 is the union of a convex cone and its opposite. We can choose which one to model by checking the existence of bounds on variables as shown below.\n\nSecond-order cone\n\nIf Q is diagonal and has eigenvalues (1, 1, -1), the inequality x^2 + x^2 le z^2 combined with z ge 0 defines the Lorenz cone (i.e. the second-order cone) but when combined with z le 0, it gives the opposite of the second order cone. Therefore, we need to check if the variable z has a lower bound 0 or an upper bound 0 in order to determine which cone is\n\nRotated second-order cone\n\nThe matrix Q corresponding to the inequality x^2 le 2yz has one eigenvalue 1 with eigenvectors (1, 0, 0) and (0, 1, -1) and one eigenvalue -1 corresponding to the eigenvector (0, 1, 1). Hence if we intersect this union of two convex cone with the halfspace x + y ge 0, we get the rotated second-order cone and if we intersect it with the halfspace x + y le 0 we get the opposite of the rotated second-order cone. Note that y and z have the same sign since yz is nonnegative hence x + y ge 0 is equivalent to x ge 0 and y ge 0.\n\nNote\n\nThe check for existence of bound can be implemented (but inefficiently) with the current interface but if bound is removed or transformed (e.g. ‚â§ 0 transformed into ‚â• 0) then the bridge is no longer valid. For this reason the homogeneous version of the bridge is not implemented yet.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge","text":"SOCtoNonConvexQuadBridge{T}\n\nConstraints of the form VectorOfVariables-in-SecondOrderCone can be transformed into a ScalarQuadraticFunction-in-LessThan and a ScalarAffineFunction-in-GreaterThan. Indeed, the definition of the second-order cone\n\nt ge lVert x rVert_2   (1)\n\nis equivalent to\n\nsum x_i^2 le t^2  (2)\n\nwith t ge 0.  (3)\n\nWARNING This transformation starts from a convex constraint (1) and creates a non-convex constraint (2), because the Q matrix associated with the constraint 2 has one negative eigenvalue. This might be wrongly interpreted by a solver. Some solvers can look at (2) and understand that it is a second order cone, but this is not a general rule. For these reasons this bridge is not automatically added by MOI.Bridges.full_bridge_optimizer. Care is recommended when adding this bridge to a optimizer.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.RSOCtoNonConvexQuadBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.RSOCtoNonConvexQuadBridge","text":"RSOCtoNonConvexQuadBridge{T}\n\nConstraints of the form VectorOfVariables-in-SecondOrderCone can be transformed into a ScalarQuadraticFunction-in-LessThan and a ScalarAffineFunction-in-GreaterThan. Indeed, the definition of the second-order cone\n\n2tu ge lVert x rVert_2^2 tu ge 0  (1)\n\nis equivalent to\n\nsum x_i^2 le 2tu  (2)\n\nwith tu ge 0.  (3)\n\nWARNING This transformation starts from a convex constraint (1) and creates a non-convex constraint (2), because the Q matrix associated with the constraint 2 has two negative eigenvalues. This might be wrongly interpreted by a solver. Some solvers can look at (2) and understand that it is a rotated second order cone, but this is not a general rule. For these reasons, this bridge is not automatically added by MOI.Bridges.full_bridge_optimizer. Care is recommended when adding this bridge to an optimizer.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.NormInfinityBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.NormInfinityBridge","text":"NormInfinityBridge{T}\n\nThe NormInfinityCone is representable with LP constraints, since t ge max_i lvert x_i rvert if and only if t ge x_i and t ge -x_i for all i.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.NormOneBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.NormOneBridge","text":"NormOneBridge{T}\n\nThe NormOneCone is representable with LP constraints, since t ge sum_i lvert x_i rvert if and only if there exists a vector y such that t ge sum_i y_i and y_i ge x_i, y_i ge -x_i for all i.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge","text":"GeoMeantoRelEntrBridge{T}\n\nThe geometric mean cone is representable with a relative entropy constraint and a nonnegative auxiliary variable, since u le prod_i=1^n w_i^1n is equivalent to y ge 0 and 0 le u + y le prod_i=1^n w_i^1n, and the latter inequality is equivalent to 1 le prod_i=1^n (fracw_iu + y)^1n, which is equivalent to 0 le sum_i=1^n log (fracw_iu + y)^1n, which is equivalent to 0 ge sum_i=1^n (u + y) log (fracu + yw_i). Thus (u w) in GeometricMeanCone(1 + n) is representable as y ge 0, (0 w (u + y) e) in RelativeEntropyCone(1 + 2n), where e is a vector of ones.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.GeoMeanBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.GeoMeanBridge","text":"GeoMeanBridge{T, F, G, H}\n\nThe GeometricMeanCone is SecondOrderCone representable; see [1, p. 105]. The reformulation is best described in an example. Consider the cone of dimension 4\n\nt le sqrt3x_1 x_2 x_3\n\nThis can be rewritten as exists x_21 ge 0 such that\n\nbeginalign*\n  t  le x_21\n  x_21^4  le x_1 x_2 x_3 x_21\nendalign*\n\nNote that we need to create x_21 and not use t^4 directly as t is allowed to be negative. Now, this is equivalent to\n\nbeginalign*\n  t  le x_21sqrt4\n  x_21^2  le 2x_11 x_12\n  x_11^2  le 2x_1 x_2  x_12^2  le 2x_3(x_21sqrt4)\nendalign*\n\n[1] Ben-Tal, Aharon, and Arkadi Nemirovski. Lectures on modern convex optimization: analysis, algorithms, and engineering applications. Society for Industrial and Applied Mathematics, 2001.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.RelativeEntropyBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.RelativeEntropyBridge","text":"RelativeEntropyBridge{T}\n\nThe RelativeEntropyCone is representable with exponential cone and LP constraints, since u ge sum_i=1^n w_i log (fracw_iv_i) if and only if there exists a vector y such that u ge sum_i y_i and y_i ge w_i log (fracw_iv_i) or equivalently v_i ge w_i exp (frac-y_iw_i) or equivalently (-y_i w_i v_i) in ExponentialCone, for all i.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.NormSpectralBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.NormSpectralBridge","text":"NormSpectralBridge{T}\n\nThe NormSpectralCone is representable with a PSD constraint, since t ge sigma_1(X) if and only if tI X^top X tI succ 0.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.NormNuclearBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.NormNuclearBridge","text":"NormNuclearBridge{T}\n\nThe NormNuclearCone is representable with an SDP constraint and extra variables, since t ge sum_i sigma_i (X) if and only if there exists symmetric matrices U V such that U X^top X V succ 0 and t ge (tr(U) + tr(V))  2.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.SquareBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.SquareBridge","text":"SquareBridge{T, F<:MOI.AbstractVectorFunction,\n             G<:MOI.AbstractScalarFunction,\n             TT<:MOI.AbstractSymmetricMatrixSetTriangle,\n             ST<:MOI.AbstractSymmetricMatrixSetSquare} <: AbstractBridge\n\nThe SquareBridge reformulates the constraint of a square matrix to be in ST to a list of equality constraints for pair or off-diagonal entries with different expressions and a TT constraint the upper triangular part of the matrix.\n\nFor instance, the constraint for the matrix\n\nbeginpmatrix\n  1       1 + x  2 - 3x\n  1 +  x  2 + x  3 -  x\n  2 - 3x  2 + x      2x\nendpmatrix\n\nto be PSD can be broken down to the constraint of the symmetric matrix\n\nbeginpmatrix\n  1       1 + x  2 - 3x\n  cdot  2 + x  3 -  x\n  cdot  cdot     2x\nendpmatrix\n\nand the equality constraint between the off-diagonal entries (2, 3) and (3, 2) 2x == 1. Note that now symmetrization constraint need to be added between the off-diagonal entries (1, 2) and (2, 1) or between (1, 3) and (3, 1) since the expressions are the same.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.RootDetBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.RootDetBridge","text":"RootDetBridge{T}\n\nThe RootDetConeTriangle is representable by a PositiveSemidefiniteConeTriangle and an GeometricMeanCone constraints; see [1, p. 149]. Indeed, t le det(X)^1n if and only if there exists a lower triangular matrix Œî such that\n\nbeginalign*\n  beginpmatrix\n    X  Œî\n    Œî^top  mathrmDiag(Œî)\n  endpmatrix  succeq 0\n  t  le (Œî_11 Œî_22 cdots Œî_nn)^1n\nendalign*\n\n[1] Ben-Tal, Aharon, and Arkadi Nemirovski. Lectures on modern convex optimization: analysis, algorithms, and engineering applications. Society for Industrial and Applied Mathematics, 2001.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.LogDetBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.LogDetBridge","text":"LogDetBridge{T}\n\nThe LogDetConeTriangle is representable by a PositiveSemidefiniteConeTriangle and ExponentialCone constraints. Indeed, logdet(X) = log(delta_1) + cdots + log(delta_n) where delta_1, ..., delta_n are the eigenvalues of X. Adapting the method from [1, p. 149], we see that t le u log(det(Xu)) for u  0 if and only if there exists a lower triangular matrix Œî such that\n\nbeginalign*\n  beginpmatrix\n    X  Œî\n    Œî^top  mathrmDiag(Œî)\n  endpmatrix  succeq 0\n  t  le u log(Œî_11u) + u log(Œî_22u) + cdots + u log(Œî_nnu)\nendalign*\n\n[1] Ben-Tal, Aharon, and Arkadi Nemirovski. Lectures on modern convex optimization: analysis, algorithms, and engineering applications. Society for Industrial and Applied Mathematics, 2001. ```\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.SOCtoPSDBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.SOCtoPSDBridge","text":"The SOCtoPSDBridge transforms the second order cone constraint lVert x rVert le t into the semidefinite cone constraints\n\nbeginpmatrix\n  t  x^top\n  x  tI\nendpmatrix succeq 0\n\nIndeed by the Schur Complement, it is positive definite iff\n\nbeginalign*\n  tI  succ 0\n  t - x^top (tI)^-1 x  succ 0\nendalign*\n\nwhich is equivalent to\n\nbeginalign*\n  t   0\n  t^2   x^top x\nendalign*\n\nThis bridge is not added by default by MOI.Bridges.full_bridge_optimizer as bridging second order cone constraints to semidefinite constraints can be achieved by the SOCRBridge followed by the RSOCtoPSDBridge while creating a smaller semidefinite constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge","text":"The RSOCtoPSDBridge transforms the second order cone constraint lVert x rVert le 2tu with u ge 0 into the semidefinite cone constraints\n\nbeginpmatrix\n  t  x^top\n  x  2uI\nendpmatrix succeq 0\n\nIndeed by the Schur Complement, it is positive definite iff\n\nbeginalign*\n  uI  succ 0\n  t - x^top (2uI)^-1 x  succ 0\nendalign*\n\nwhich is equivalent to\n\nbeginalign*\n  u   0\n  2tu   x^top x\nendalign*\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge","text":"IndicatorActiveOnFalseBridge{T}\n\nThe IndicatorActiveOnFalseBridge replaces an indicator constraint activated on 0 with a variable z_0 with the constraint activated on 1, with a variable z_1. It stores the added variable_index and added constraints:\n\nz_1 in mathbbB in zero_one_cons\nz_0 + z_1 == 1 in `indisjunction_cons`\nThe added ACTIVATE_ON_ONE indicator constraint in indicator_cons_index.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge","text":"IndicatorSOS1Bridge{T, BC <: MOI.AbstractScalarSet}\n\nThe IndicatorSOS1Bridge replaces an indicator constraint of the following form: z in mathbbB z == 1 implies f(x) leq b with a SOS1 constraint: z in mathbbB w leq 0 f(x) + w leq b SOS1(w z). GreaterThan constraints are handled in a symmetric way: z in mathbbB z == 1 implies f(x) geq b is reformulated as: z in mathbbB w geq 0 f(x) + w geq b SOS1(w z). Other scalar sets are handled without a bound constraint: z in mathbbB z == 1 implies f(x) == b is reformulated as: z in mathbbB w text free f(x) + w == b SOS1(w z).\n\nIf BC !<: Union{LessThan, GreaterThan}, bound_constraint_index is nothing.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.SemiToBinaryBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.SemiToBinaryBridge","text":"SemiToBinaryBridge{T, S <: MOI.AbstractScalarSet}\n\nThe SemiToBinaryBridge replaces an Semicontinuous constraint: x in mathsfSemicontinuous(l u) is replaced by: z in 0 1, x leq z cdot u, x geq z cdot l.\n\nThe SemiToBinaryBridge replaces an Semiinteger constraint: x in Semiinteger(l u) is replaced by: z in 0 1, x in mathbbZ, x leq z cdot u, x geq z cdot l.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.ZeroOneBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.ZeroOneBridge","text":"ZeroOneBridge{T}\n\nThe ZeroOneBridge splits a MOI.SingleVariable-in-MOI.ZeroOne constraint into a MOI.SingleVariable-in-MOI.Integer constraint and a MOI.SingleVariable-in-MOI.Interval(0, 1) constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#ref_variable_bridges","page":"API Reference","title":"Variable bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.Variable.AbstractBridge\nBridges.Variable.SingleBridgeOptimizer\nBridges.Variable.add_all_bridges","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.AbstractBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.AbstractBridge","text":"AbstractBridge\n\nSubtype of MathOptInterface.Bridges.AbstractBridge for variable bridges.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.SingleBridgeOptimizer","page":"API Reference","title":"MathOptInterface.Bridges.Variable.SingleBridgeOptimizer","text":"SingleBridgeOptimizer{BT<:AbstractBridge, OT<:MOI.ModelLike} <: AbstractBridgeOptimizer\n\nThe SingleBridgeOptimizer bridges any constrained variables supported by the bridge BT. This is in contrast with the MathOptInterface.Bridges.LazyBridgeOptimizer which only bridges the constrained variables that are unsupported by the internal model, even if they are supported by one of its bridges.\n\nnote: Note\nTwo bridge optimizers using variable bridges cannot be used together as both of them assume that the underlying model only returns variable indices with nonnegative values.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.add_all_bridges","page":"API Reference","title":"MathOptInterface.Bridges.Variable.add_all_bridges","text":"add_all_bridges(bridged_model, T::Type)\n\nAdd all bridges defined in the Bridges.Variable submodule to bridged_model. The coefficient type used is T.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#variable_bridges_ref","page":"API Reference","title":"Bridges implemented","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.Variable.ZerosBridge\nBridges.Variable.FreeBridge\nBridges.Variable.NonposToNonnegBridge\nBridges.Variable.VectorizeBridge\nBridges.Variable.SOCtoRSOCBridge\nBridges.Variable.RSOCtoSOCBridge\nBridges.Variable.RSOCtoPSDBridge","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.ZerosBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.ZerosBridge","text":"ZerosBridge{T} <: Bridges.Variable.AbstractBridge\n\nTransforms constrained variables in MathOptInterface.Zeros to zeros, which ends up creating no variables in the underlying model. The bridged variables are therefore similar to parameters with zero values. Parameters with non-zero value can be created with constrained variables in MOI.EqualTo by combining a VectorizeBridge and this bridge. The functions cannot be unbridged, given a function, we cannot determine, if the bridged variables were used. The dual values cannot be determined by the bridge but they can be determined by the bridged optimizer using MathOptInterface.Utilities.get_fallback if a CachingOptimizer is used (since ConstraintFunction cannot be got as functions cannot be unbridged).\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.FreeBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.FreeBridge","text":"FreeBridge{T} <: Bridges.Variable.AbstractBridge\n\nTransforms constrained variables in MOI.Reals to the difference of constrained variables in MOI.Nonnegatives.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.NonposToNonnegBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.NonposToNonnegBridge","text":"NonposToNonnegBridge{T, F<:MOI.AbstractVectorFunction, G<:MOI.AbstractVectorFunction} <:\n    FlipSignBridge{T, MOI.Nonpositives, MOI.Nonnegatives, F, G}\n\nTransforms constrained variables in Nonpositives into constrained variables in Nonnegatives.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.VectorizeBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.VectorizeBridge","text":"VectorizeBridge{T, S}\n\nTransforms a constrained variable in scalar_set_type(S, T) where S <: VectorLinearSet into a constrained vector of one variable in S. For instance, VectorizeBridge{Float64, MOI.Nonnegatives} transforms a constrained variable in MOI.GreaterThan{Float64} into a constrained vector of one variable in MOI.Nonnegatives.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.SOCtoRSOCBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.SOCtoRSOCBridge","text":"SOCtoRSOCBridge{T} <: Bridges.Variable.AbstractBridge\n\nSame transformation as MOI.Bridges.Constraint.SOCRBridge.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.RSOCtoSOCBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.RSOCtoSOCBridge","text":"RSOCtoSOCBridge{T} <: Bridges.Variable.AbstractBridge\n\nSame transformation as MOI.Bridges.Constraint.RSOCBridge.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.RSOCtoPSDBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.RSOCtoPSDBridge","text":"RSOCtoPSDBridge{T} <: Bridges.Variable.AbstractBridge\n\nTransforms constrained variables in MathOptInterface.RotatedSecondOrderCone to constrained variables in MathOptInterface.PositiveSemidefiniteConeTriangle.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#Objective-bridges","page":"API Reference","title":"Objective bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.Objective.AbstractBridge\nBridges.Objective.SingleBridgeOptimizer\nBridges.Objective.add_all_bridges","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Objective.AbstractBridge","page":"API Reference","title":"MathOptInterface.Bridges.Objective.AbstractBridge","text":"AbstractBridge\n\nSubtype of MathOptInterface.Bridges.AbstractBridge for objective bridges.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Objective.SingleBridgeOptimizer","page":"API Reference","title":"MathOptInterface.Bridges.Objective.SingleBridgeOptimizer","text":"SingleBridgeOptimizer{BT<:AbstractBridge, OT<:MOI.ModelLike} <: AbstractBridgeOptimizer\n\nThe SingleBridgeOptimizer bridges any objective functions supported by the bridge BT. This is in contrast with the MathOptInterface.Bridges.LazyBridgeOptimizer which only bridges the objective functions that are unsupported by the internal model, even if they are supported by one of its bridges.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Objective.add_all_bridges","page":"API Reference","title":"MathOptInterface.Bridges.Objective.add_all_bridges","text":"add_all_bridges(bridged_model, T::Type)\n\nAdd all bridges defined in the Bridges.Objective submodule to bridged_model. The coefficient type used is T.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#objective_bridges_ref","page":"API Reference","title":"Bridges implemented","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.Objective.SlackBridge\nBridges.Objective.FunctionizeBridge","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Objective.SlackBridge","page":"API Reference","title":"MathOptInterface.Bridges.Objective.SlackBridge","text":"SlackBridge{T, F, G}\n\nThe SlackBridge converts an objective function of type G into a MOI.SingleVariable objective by creating a slack variable and a F-in-MOI.LessThan constraint for minimization or F-in-MOI.LessThan constraint for maximization where F is MOI.Utilities.promote_operation(-, T, G, MOI.SingleVariable}. Note that when using this bridge, changing the optimization sense is not supported. Set the sense to MOI.FEASIBILITY_SENSE first to delete the bridge in order to change the sense, then re-add the objective.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Objective.FunctionizeBridge","page":"API Reference","title":"MathOptInterface.Bridges.Objective.FunctionizeBridge","text":"FunctionizeBridge{T}\n\nThe FunctionizeBridge converts a SingleVariable objective into a ScalarAffineFunction{T} objective.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"AbstractCallback\nAbstractSubmittable\nsubmit","category":"page"},{"location":"moi/reference/callbacks/#MathOptInterface.AbstractCallback","page":"Callbacks","title":"MathOptInterface.AbstractCallback","text":"abstract type AbstractCallback <: AbstractModelAttribute end\n\nAbstract type for a model attribute representing a callback function. The value set to subtypes of AbstractCallback is a function that may be called during optimize!. As optimize! is in progress, the result attributes (i.e, the attributes attr such that is_set_by_optimize(attr)) may not be accessible from the callback, hence trying to get result attributes might throw a OptimizeInProgress error.\n\nAt most one callback of each type can be registered. If an optimizer already has a function for a callback type, and the user registers a new function, then the old one is replaced.\n\nThe value of the attribute should be a function taking only one argument, commonly called callback_data, that can be used for instance in LazyConstraintCallback, HeuristicCallback and UserCutCallback.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.AbstractSubmittable","page":"Callbacks","title":"MathOptInterface.AbstractSubmittable","text":"AbstractSubmittable\n\nAbstract supertype for objects that can be submitted to the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.submit","page":"Callbacks","title":"MathOptInterface.submit","text":"submit(optimizer::AbstractOptimizer, sub::AbstractSubmittable,\n       values...)::Nothing\n\nSubmit values to the submittable sub of the optimizer optimizer.\n\nAn UnsupportedSubmittable error is thrown if model does not support the attribute attr (see supports) and a SubmitNotAllowed error is thrown if it supports the submittable sub but it cannot be submitted.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/callbacks/#Attributes","page":"Callbacks","title":"Attributes","text":"","category":"section"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"CallbackNodeStatus\nCallbackNodeStatusCode\nCallbackVariablePrimal","category":"page"},{"location":"moi/reference/callbacks/#MathOptInterface.CallbackNodeStatus","page":"Callbacks","title":"MathOptInterface.CallbackNodeStatus","text":"CallbackNodeStatus(callback_data)\n\nAn optimizer attribute describing the (in)feasibility of the primal solution available from CallbackVariablePrimal during a callback identified by callback_data.\n\nReturns a CallbackNodeStatusCode Enum.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.CallbackNodeStatusCode","page":"Callbacks","title":"MathOptInterface.CallbackNodeStatusCode","text":"CallbackNodeStatusCode\n\nAn Enum of possible return values from calling get with CallbackNodeStatus.\n\nPossible values are:\n\nCALLBACK_NODE_STATUS_INTEGER: the primal solution available from CallbackVariablePrimal is integer feasible.\nCALLBACK_NODE_STATUS_FRACTIONAL: the primal solution available from CallbackVariablePrimal is integer infeasible.\nCALLBACK_NODE_STATUS_UNKNOWN: the primal solution available from CallbackVariablePrimal might be integer feasible or infeasible.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.CallbackVariablePrimal","page":"Callbacks","title":"MathOptInterface.CallbackVariablePrimal","text":"CallbackVariablePrimal(callback_data)\n\nA variable attribute for the assignment to some primal variable's value during the callback identified by callback_data.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#Lazy-constraints","page":"Callbacks","title":"Lazy constraints","text":"","category":"section"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"LazyConstraintCallback\nLazyConstraint","category":"page"},{"location":"moi/reference/callbacks/#MathOptInterface.LazyConstraintCallback","page":"Callbacks","title":"MathOptInterface.LazyConstraintCallback","text":"LazyConstraintCallback() <: AbstractCallback\n\nThe callback can be used to reduce the feasible set given the current primal solution by submitting a LazyConstraint. For instance, it may be called at an incumbent of a mixed-integer problem. Note that there is no guarantee that the callback is called at every feasible primal solution.\n\nThe current primal solution is accessed through CallbackVariablePrimal. Trying to access other result attributes will throw OptimizeInProgress as discussed in AbstractCallback.\n\nExamples\n\nx = MOI.add_variables(optimizer, 8)\nMOI.set(optimizer, MOI.LazyConstraintCallback(), callback_data -> begin\n    sol = MOI.get(optimizer, MOI.CallbackVariablePrimal(callback_data), x)\n    if # should add a lazy constraint\n        func = # computes function\n        set = # computes set\n        MOI.submit(optimizer, MOI.LazyConstraint(callback_data), func, set)\n    end\nend)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.LazyConstraint","page":"Callbacks","title":"MathOptInterface.LazyConstraint","text":"LazyConstraint(callback_data)\n\nLazy constraint func-in-set submitted as func, set. The optimal solution returned by VariablePrimal will satisfy all lazy constraints that have been submitted.\n\nThis can be submitted only from the LazyConstraintCallback. The field callback_data is a solver-specific callback type that is passed as the argument to the feasible solution callback.\n\nExamples\n\nSuppose fx = MOI.SingleVariable(x) and fx = MOI.SingleVariable(y) where x and y are VariableIndexs of optimizer. To add a LazyConstraint for 2x + 3y <= 1, write\n\nfunc = 2.0fx + 3.0fy\nset = MOI.LessThan(1.0)\nMOI.submit(optimizer, MOI.LazyConstraint(callback_data), func, set)\n\ninside a LazyConstraintCallback of data callback_data.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#User-cuts","page":"Callbacks","title":"User cuts","text":"","category":"section"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"UserCutCallback\nUserCut","category":"page"},{"location":"moi/reference/callbacks/#MathOptInterface.UserCutCallback","page":"Callbacks","title":"MathOptInterface.UserCutCallback","text":"UserCutCallback() <: AbstractCallback\n\nThe callback can be used to submit UserCut given the current primal solution. For instance, it may be called at fractional (i.e., non-integer) nodes in the branch and bound tree of a mixed-integer problem. Note that there is not guarantee that the callback is called everytime the solver has an infeasible solution.\n\nThe infeasible solution is accessed through CallbackVariablePrimal. Trying to access other result attributes will throw OptimizeInProgress as discussed in AbstractCallback.\n\nExamples\n\nx = MOI.add_variables(optimizer, 8)\nMOI.set(optimizer, MOI.UserCutCallback(), callback_data -> begin\n    sol = MOI.get(optimizer, MOI.CallbackVariablePrimal(callback_data), x)\n    if # can find a user cut\n        func = # computes function\n        set = # computes set\n        MOI.submit(optimizer, MOI.UserCut(callback_data), func, set)\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.UserCut","page":"Callbacks","title":"MathOptInterface.UserCut","text":"UserCut(callback_data)\n\nConstraint func-to-set suggested to help the solver detect the solution given by CallbackVariablePrimal as infeasible. The cut is submitted as func, set. Typically CallbackVariablePrimal will violate integrality constraints, and a cut would be of the form ScalarAffineFunction-in-LessThan or ScalarAffineFunction-in-GreaterThan. Note that, as opposed to LazyConstraint, the provided constraint cannot modify the feasible set, the constraint should be redundant, e.g., it may be a consequence of affine and integrality constraints.\n\nThis can be submitted only from the UserCutCallback. The field callback_data is a solver-specific callback type that is passed as the argument to the infeasible solution callback.\n\nNote that the solver may silently ignore the provided constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#Heuristic-solutions","page":"Callbacks","title":"Heuristic solutions","text":"","category":"section"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"HeuristicCallback\nHeuristicSolutionStatus\nHeuristicSolution","category":"page"},{"location":"moi/reference/callbacks/#MathOptInterface.HeuristicCallback","page":"Callbacks","title":"MathOptInterface.HeuristicCallback","text":"HeuristicCallback() <: AbstractCallback\n\nThe callback can be used to submit HeuristicSolution given the current primal solution. For instance, it may be called at fractional (i.e., non-integer) nodes in the branch and bound tree of a mixed-integer problem. Note that there is not guarantee that the callback is called everytime the solver has an infeasible solution.\n\nThe current primal solution is accessed through CallbackVariablePrimal. Trying to access other result attributes will throw OptimizeInProgress as discussed in AbstractCallback.\n\nExamples\n\nx = MOI.add_variables(optimizer, 8)\nMOI.set(optimizer, MOI.HeuristicCallback(), callback_data -> begin\n    sol = MOI.get(optimizer, MOI.CallbackVariablePrimal(callback_data), x)\n    if # can find a heuristic solution\n        values = # computes heuristic solution\n        MOI.submit(optimizer, MOI.HeuristicSolution(callback_data), x,\n                   values)\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.HeuristicSolutionStatus","page":"Callbacks","title":"MathOptInterface.HeuristicSolutionStatus","text":"HeuristicSolutionStatus\n\nAn Enum of possible return values for submit with HeuristicSolution. This informs whether the heuristic solution was accepted or rejected. Possible values are:\n\nHEURISTIC_SOLUTION_ACCEPTED: The heuristic solution was accepted.\nHEURISTIC_SOLUTION_REJECTED: The heuristic solution was rejected.\nHEURISTIC_SOLUTION_UNKNOWN: No information available on the acceptance.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.HeuristicSolution","page":"Callbacks","title":"MathOptInterface.HeuristicSolution","text":"HeuristicSolution(callback_data)\n\nHeuristically obtained feasible solution. The solution is submitted as variables, values where values[i] gives the value of variables[i], similarly to set. The submit call returns a HeuristicSolutionStatus indicating whether the provided solution was accepted or rejected.\n\nThis can be submitted only from the HeuristicCallback. The field callback_data is a solver-specific callback type that is passed as the argument to the heuristic callback.\n\nSome solvers require a complete solution, others only partial solutions.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Nonlinear programs/clnlbeam.jl\"","category":"page"},{"location":"tutorials/Nonlinear programs/clnlbeam/#The-clnlbeam-problem","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"Based on an AMPL model by Hande Y. Benson","category":"page"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"Copyright (C) 2001 Princeton University All Rights Reserved","category":"page"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that the copyright notice and this permission notice appear in all supporting documentation.","category":"page"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"Source: H. Maurer and H.D. Mittelman, \"The non-linear beam via optimal control with bound state variables\", Optimal Control Applications and Methods 12, pp. 19-31, 1991.","category":"page"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"using JuMP\nimport Ipopt\n\nfunction example_clnlbeam()\n    N = 1000\n    h = 1/N\n    alpha = 350\n    model = Model(Ipopt.Optimizer)\n    @variables(model, begin\n           -1 <= t[1:(N + 1)] <= 1\n        -0.05 <= x[1:(N + 1)] <= 0.05\n                 u[1:(N + 1)]\n    end)\n    @NLobjective(\n        model,\n        Min,\n        sum(\n            0.5 * h * (u[i + 1]^2 + u[i]^2) +\n            0.5 * alpha * h * (cos(t[i + 1]) + cos(t[i]))\n            for i = 1:N\n        ),\n    )\n    @NLconstraint(\n        model,\n        [i = 1:N],\n        x[i + 1] - x[i] - 0.5 * h * (sin(t[i + 1]) + sin(t[i])) == 0,\n    )\n    @constraint(\n        model,\n        [i = 1:N],\n        t[i + 1] - t[i] - 0.5 * h * u[i + 1] - 0.5 * h * u[i] == 0,\n    )\n    optimize!(model)\n    println(\"\"\"\n    termination_status = $(termination_status(model))\n    primal_status      = $(primal_status(model))\n    objective_value    = $(objective_value(model))\n    \"\"\")\n    return\nend\n\nexample_clnlbeam()","category":"page"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"","category":"page"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Optimization concepts/benders_lazy_constraints.jl\"","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/#benders_decomposition_lazy","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Originally Contributed by: Mathieu Besan√ßon","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"This notebook describes how to implement the Benders decomposition in JuMP using lazy constraints. We keep the same notation and problem form as the first notebook Benders decomposition.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"beginaligned\n textmaximize quad c_1^T x+c_2^T v \n textsubject to quad A_1 x+ A_2 v preceq b \n x succeq 0 x in mathbbZ^n \n v succeq 0 v in mathbbR^p \nendaligned","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"where b in mathbbR^m, A_1 in mathbbR^m times n, A_2 in mathbbR^m times p and mathbbZ is the set of integers.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Here the symbol succeq (preceq) stands for element-wise greater (less) than or equal to. Any mixed integer programming problem can be written in the form above.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"For a detailed explanation on the Benders decomposition algorithm, see the introduction notebook.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/#Lazy-constraints","page":"Benders Decomposition (Lazy Constraints)","title":"Lazy constraints","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Some optimization solvers allow users to interact with them during the solution process by providing user-defined functions which are triggered under certain conditions.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"The generic term for these functions is callback.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"In integer optimization, the main callback types are lazy constraints, user-cuts and heuristic solutions. See the Callbacks section for an introduction on how to use them.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Some callbacks define a new constraint which is only activated when necessary, i.e., when a current solution does not respect them. It can avoid building an optimization model with too many constraints up-front.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"This is the case for Benders decomposition, since the sub-problem defines an exponential number of primal vertices and therefore dual cuts.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"A detailed explanation on the distinction between user-cuts and lazy constraints is also available on Paul Rubin's blog. He also describes this approach to Benders Decomposition.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"We use the data from the original notebook and change the solution algorithm to leverage lazy constraints:","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Step 1 (Initialization)\nStep 2 (defining the subproblem model)\nStep 3 (registering the lazy constraint of the subproblem)","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/#Data-for-the-problem","page":"Benders Decomposition (Lazy Constraints)","title":"Data for the problem","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"The input data is from page 139, Integer programming by Garfinkel and Nemhauser[1].","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"c1 = [-1; -4]\nc2 = [-2; -3]\n\ndim_x = length(c1)\ndim_u = length(c2)\n\nb = [-2; -3]\n\nA1 = [1 -3;\n     -1 -3]\nA2 = [1 -2;\n     -1 -1]\n\nM = 1000;\nnothing #hide","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/#Loading-the-necessary-packages","page":"Benders Decomposition (Lazy Constraints)","title":"Loading the necessary packages","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"using JuMP\nimport GLPK\nimport Test","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Subproblem creation","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"function build_subproblem()\n    sub_problem_model = Model(GLPK.Optimizer)\n    @variable(sub_problem_model, u[1:dim_u] >= 0)\n    @constraint(\n        sub_problem_model,\n        constr_ref_subproblem[j = 1:size(A2, 2)],\n        A2[:, j]' * u >= c2[j],\n    )\n    return (sub_problem_model, u)\nend","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/#Master-Problem-Description","page":"Benders Decomposition (Lazy Constraints)","title":"Master Problem Description","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"master_problem_model = Model(GLPK.Optimizer);\n\n(sub_problem_model, u) = build_subproblem();\nnothing #hide","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Variable Definition","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"@variable(master_problem_model, 0 <= x[1:dim_x] <= 1e6, Int)\n@variable(master_problem_model, t <= 1e6)","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Objective Setting","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"@objective(master_problem_model, Max, t)\n\nprint(master_problem_model)","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Track the calls to the callback","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"iter_num = 0","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Define lazy constraints","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"function benders_lazy_constraint_callback(cb_data)\n    global iter_num\n    iter_num += 1\n    println(\"Iteration number = \", iter_num)\n\n    x_current = callback_value.(Ref(cb_data), x)\n    fm_current = callback_value(cb_data, t)\n\n    c_sub = b - A1 * x_current\n    @objective(sub_problem_model, Min, c1' * x_current + c_sub' * u)\n    optimize!(sub_problem_model)\n\n    print(\"\\nThe current subproblem model is \\n\")\n    print(sub_problem_model)\n\n    t_status_sub = termination_status(sub_problem_model)\n    p_status_sub = primal_status(sub_problem_model)\n\n    fs_x_current = objective_value(sub_problem_model)\n\n    u_current = value.(u)\n\n    Œ≥ = b' * u_current\n\n    if p_status_sub == MOI.FEASIBLE_POINT && fs_x_current  ‚âà  fm_current # we are done\n        @info(\"No additional constraint from the subproblem\")\n    end\n\n    if p_status_sub == MOI.FEASIBLE_POINT && fs_x_current < fm_current\n        println(\"\\nThere is a suboptimal vertex, add the corresponding constraint\")\n        cv = A1' * u_current - c1\n        new_optimality_cons = @build_constraint(t + cv' * x <= Œ≥)\n        MOI.submit(\n            master_problem_model,\n            MOI.LazyConstraint(cb_data),\n            new_optimality_cons,\n        )\n    end\n\n    if t_status_sub == MOI.INFEASIBLE_OR_UNBOUNDED\n        println(\"\\nThere is an  extreme ray, adding the corresponding constraint\")\n        ce = A1' * u_current\n        new_feasibility_cons = @build_constraint(dot(ce, x) <= Œ≥)\n        MOI.submit(\n            master_problem_model,\n            MOI.LazyConstraint(cb_data),\n            new_feasibility_cons,\n        )\n    end\nend\n\nMOI.set(\n    master_problem_model,\n    MOI.LazyConstraintCallback(),\n    benders_lazy_constraint_callback,\n)\n\noptimize!(master_problem_model)\n\nt_status = termination_status(master_problem_model)\np_status = primal_status(master_problem_model)\n\nif p_status == MOI.INFEASIBLE_POINT\n    println(\"The problem is infeasible :-(\")\nend\n\nif t_status == MOI.INFEASIBLE_OR_UNBOUNDED\n    fm_current = M\n    x_current = M * ones(dim_x)\nend\n\nif p_status == MOI.FEASIBLE_POINT\n    fm_current = value(t)\n    x_current = value.(x)\nend\n\nTest.@test value(t) ‚âà -4 #hide\n\nprintln(\"Status of the master problem is \", t_status,\n        \"\\nwith fm_current = \", fm_current,\n        \"\\nx_current = \", x_current)","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/#References","page":"Benders Decomposition (Lazy Constraints)","title":"References","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"<a id='c1'></a>","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Garfinkel, R. & Nemhauser, G. L. Integer programming. (Wiley, 1972).","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"View this file on Github.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/finance.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/#Finance","page":"Finance","title":"Finance","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Optimization models play an increasingly important role in financial decisions. Many computational finance problems can be solved efficiently using modern optimization techniques.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"In this tutorial we will discuss two such examples taken from the book Optimization Methods in Finance.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"This tutorial uses the following packages","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"using JuMP\nimport GLPK","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/#Short-Term-Financing","page":"Finance","title":"Short Term Financing","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Corporations routinely face the problem of financing short term cash commitments such as the following:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Month Jan Feb Mar Apr May Jun\nNet Cash Flow -150 -100 200 -200 50 300","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Net cash flow requirements are given in thousands of dollars. The company has the following sources of funds:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"A line of credit of up to $100K at an interest rate of 1% per month,\nIn any one of the first three months, it can issue 90-day commercial paper bearing a total interest of 2% for the 3-month period,\nExcess funds can be invested at an interest rate of 0.3% per month.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Our task is to find out the most economical way to use these 3 sources such that we end up with the most amount of money at the end of June.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"We model this problem in the following manner:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"We will use the following decision variables:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"the amount u_i drawn from the line of credit in month i\nthe amount v_i of commercial paper issued in month i\nthe excess funds w_i in month i","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Here we have three types of constraints:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"for every month, cash inflow = cash outflow for each month\nupper bounds on u_i\nnonnegativity of the decision variables u_i, v_i and w_i.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Our objective will be to simply maximize the company's wealth in June, which say we represent with the variable m.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"financing = Model(GLPK.Optimizer)\n\n@variables(financing, begin\n    0 <= u[1:5] <= 100\n    0 <= v[1:3]\n    0 <= w[1:5]\n    m\nend)\n\n@objective(financing, Max, m)\n\n@constraints(financing, begin\n    u[1] + v[1] - w[1] == 150 # January\n    u[2] + v[2] - w[2] - 1.01u[1] + 1.003w[1] == 100 # February\n    u[3] + v[3] - w[3] - 1.01u[2] + 1.003w[2] == -200 # March\n    u[4] - w[4] - 1.02v[1] - 1.01u[3] + 1.003w[3] == 200 # April\n    u[5] - w[5] - 1.02v[2] - 1.01u[4] + 1.003w[4] == -50 # May\n    -m - 1.02v[3] - 1.01u[5] + 1.003w[5] == -300 # June\nend)\n\noptimize!(financing)\n\nobjective_value(financing)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/#Combinatorial-Auctions","page":"Finance","title":"Combinatorial Auctions","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"In many auctions, the value that a bidder has for a set of items may not be the sum of the values that he has for individual items.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Examples are equity trading, electricity markets, pollution right auctions and auctions for airport landing slots.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"To take this into account, combinatorial auctions allow the bidders to submit bids on combinations of items.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Let M=12 ldots m be the set of items that the auctioneer has to sell. A bid is a pair B_j=left(S_j p_jright) where S_j subseteq M is a nonempty set of items and p_j is the price offer for this set.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Suppose that the auctioneer has received n bids B_1 B_2 ldots B_n The goal of this problem is to help an auctioneer determine the winners in order to maximize his revenue.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"We model this problem by taking a decision variable y_j for every bid. We add a constraint that each item i is sold at most once. This gives us the following model:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"beginaligned\nmax  sum_i=1^n p_j y_j \ntext  st    sum_j  i in S_j y_j leq 1  forall i=12 ldots m \n y_j in01  forall j in12 ldots n\nendaligned","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"bid_values = [6 3 12 12 8 16]\nbid_items = [[1], [2], [3 4], [1 3], [2 4], [1 3 4]]\n\nauction = Model(GLPK.Optimizer)\n@variable(auction, y[1:6], Bin)\n@objective(auction, Max, sum(y' .* bid_values))\nfor i in 1:6\n    @constraint(auction, sum(y[j] for j in 1:6 if i in bid_items[j]) <= 1)\nend\n\noptimize!(auction)\n\nobjective_value(auction)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"value.(y)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/prod.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/prod/#The-workforce-scheduling-problem","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"This model determines a set of workforce levels that will most economically meet demands and inventory requirements over time. The formulation is motivated by the experiences of a large producer in the United States. The data are for three products and 13 periods.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"Problem taken from the Appendix C of the expanded version of Fourer, Gay, and Kernighan, A Modeling Language for Mathematical Programming","category":"page"},{"location":"tutorials/Mixed-integer linear programs/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"Originally contributed by Louis Luangkesorn, February 26, 2015.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_prod(; verbose = true)\n    # PRODUCTION SETS AND PARAMETERS\n    prd = [\"18REG\"  \"24REG\" \"24PRO\"]\n    # Members of the product group\n    numprd = length(prd)\n    pt =\t[1.194,\t1.509,\t1.509]\n    # Crew-hours to produce 1000 units\n    pc =\t[2304,\t2920,\t2910]\n    # Nominal production cost per 1000, used\n    # to compute inventory and shortage costs\n    #\n    # TIME PERIOD SETS AND PARAMETERS\n    firstperiod = 1\n    # Index of first production period to be modeled\n    lastperiod  = 13\n    # Index of last production period to be modeled\n    numperiods = firstperiod:lastperiod\n    # 'planning horizon' := first..last;\n    # EMPLOYMENT PARAMETERS\n    # Workers per crew\n    cs = 18\n    # Regular-time hours per shift\n    sl =  8\n    # Wage per hour for regular-time labor\n    rtr = 16.00\n    # Wage per hour for overtime labor\n    otr = 43.85\n    # Crews employed at start of first period\n    iw =  8\n    # Regular working days in a production period\n    dpp =\t [19.5,\t19,\t20,\t19,\t19.5,\t19,\t19,\t20,\t19,\t20,\t20,\t18,\t18]\n    # Maximum crew-hours of overtime in a period\n    ol =\t [96,\t96,\t96,\t96,\t96,\t96,\t96,\t96,\t96,\t96,\t96,\t96,\t96]\n    # Lower limit on average employment in a period\n    cmin =\t[0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0]\n    # Upper limit on average employment in a period\n    cmax =\t[8,\t8,\t8,\t8,\t8,\t8,\t8,\t8,\t8,\t8,\t8,\t8,\t8]\n    # Penalty cost of hiring a crew\n    hc =\t [7500,\t7500,\t7500,\t7500,\t15000,\t15000,\t15000,\t15000,\t15000,\t15000,\t7500,\t7500,\t7500]\n    # Penalty cost of laying off a crew\n    lc =\t [7500,\t7500,\t7500,\t7500,\t15000,\t15000,\t15000,\t15000,\t15000,\t15000,\t7500,\t7500,\t7500]\n    # DEMAND PARAMETERS\n    d18REG = [63.8,\t76,\t88.4,\t913.8,\t115,\t133.8,\t79.6,\t111,\t121.6,\t470,\t78.4,\t99.4,\t140.4,\t63.8]\n    d24REG = [1212,\t306.2,\t319,\t208.4,\t298,\t328.2,\t959.6,\t257.6,\t335.6,\t118,\t284.8,\t970,\t343.8,\t1212]\n    d24PRO = [0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t1102,\t0,\t0,\t0,\t0]\n    # Requirements (in 1000s) to be met from current production and inventory\n    dem = Array[d18REG, d24REG, d24PRO]\n    # true if product will be the subject of a special promotion in the period\n    pro = Array[\n        [0,\t0,\t0,\t1,\t0,\t0,\t0,\t0,\t0,\t1,\t0,\t0,\t0,\t0],\n        [1,\t0,\t0,\t0,\t0,\t0,\t1,\t0,\t0,\t0,\t0,\t0,\t1,\t1],\n        [0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t1,\t0,\t0,\t0,\t0],\n    ]\n    # INVENTORY AND SHORTAGE PARAMETERS\n    # Proportion of non-promoted demand that must be in inventory the previous\n    # period\n    rir = 0.75\n    # Proportion of promoted demand that must be in inventory the previous\n    # period\n    pir = 0.80\n    # Upper limit on number of periods that any product may sit in inventory\n    life = 2\n    # Inventory cost per 1000 units is cri times nominal production cost\n    cri\t= [0.015,\t0.015,\t0.015]\n    # Shortage cost per 1000 units is crs times nominal production cost\n    crs\t= [1.1,\t1.1,\t1.1]\n    # Inventory at start of first period; age unknown\n    iinv = [82,\t792.2,\t0]\n    # Initial inventory still available for allocation at end of period t\n    iil = [\n        [\n            max(0, iinv[p] - sum(dem[p][v] for v in firstperiod:t))\n            for t in numperiods\n        ]\n        for p in 1:numprd\n    ]\n    # Lower limit on inventory at end of period t\n    function checkpro(\n        product, timeperiod, production, promotionalrate, regularrate\n    )\n        if production[product][timeperiod + 1] == 1\n            return promotionalrate\n        else\n            return regularrate\n        end\n    end\n    minv = [\n        [dem[p][t + 1] * checkpro(p, t, pro, pir, rir) for t in numperiods]\n        for p in 1:numprd\n    ]\n    # DEFINE MODEL\n    prod = Model(GLPK.Optimizer)\n    # VARIABLES\n    # Average number of crews employed in each period\n    @variable(prod, Crews[0:lastperiod] >= 0)\n    # Crews hired from previous to current period\n    @variable(prod, Hire[numperiods] >= 0)\n    # Crews laid off from previous to current period\n    @variable(prod, Layoff[numperiods]>= 0)\n    # Production using regular-time labor, in 1000s\n    @variable(prod, Rprd[1:numprd, numperiods] >= 0)\n    # Production using overtime labor, in 1000s\n    @variable(prod, Oprd[1:numprd, numperiods]>= 0)\n    # a numperiods old -- produced in period (t+1)-a --\n    # and still in storage at the end of period t\n    @variable(prod, Inv[1:numprd, numperiods, 1:life] >= 0)\n    # Accumulated unsatisfied demand at the end of period t\n    @variable(prod, Short[1:numprd, numperiods] >= 0)\n    # CONSTRAINTS\n    # Hours needed to accomplish all regular-time production in a period must\n    # not exceed hours available on all shifts\n    @constraint(\n        prod,\n        [t = numperiods],\n        sum(pt[p] * Rprd[p, t] for p in 1:numprd) <= sl * dpp[t] * Crews[t]\n    )\n    # Hours needed to accomplish all overtime production in a period must not\n    # exceed the specified overtime limit\n    @constraint(\n        prod,\n        [t = numperiods],\n        sum(pt[p] * Oprd[p, t] for p in 1:numprd)  <= ol[t]\n    )\n    # Use given initial workforce\n    @constraint(prod, Crews[firstperiod - 1] == iw)\n    # Workforce changes by hiring or layoffs\n    @constraint(\n        prod, [t in numperiods], Crews[t] == Crews[t - 1] + Hire[t] - Layoff[t]\n    )\n    # Workforce must remain within specified bounds\n    @constraint(prod, [t in numperiods], cmin[t] <= Crews[t])\n    @constraint(prod, [t in numperiods], Crews[t] <= cmax[t])\n    # 'first demand requirement\n    @constraint(\n        prod,\n        [p in 1:numprd],\n        Rprd[p, firstperiod] + Oprd[p, firstperiod] + Short[p, firstperiod] -\n            Inv[p, firstperiod, 1] == max(0, dem[p][firstperiod] - iinv[p])\n    )\n    # Production plus increase in shortage plus decrease in inventory must\n    # equal demand\n    for t in (firstperiod + 1):lastperiod\n        @constraint(\n            prod,\n            [p in 1:numprd],\n            Rprd[p, t] + Oprd[p, t] + Short[p,t] - Short[p,t-1] +\n                sum(Inv[p, t - 1, a] - Inv[p, t, a] for a in 1:life) ==\n                max(0, dem[p][t] - iil[p][t - 1])\n        )\n    end\n    # Inventory in storage at end of period t must meet specified minimum\n    @constraint(\n        prod,\n        [p in 1:numprd, t in numperiods],\n        sum(Inv[p, t, a] + iil[p][t] for a in 1:life) >= minv[p][t]\n    )\n    # In the vth period (starting from first) no inventory may be more than v\n    # numperiods old (initial inventories are handled separately)\n    @constraint(\n        prod,\n        [p in 1:numprd, v in 1:(life - 1), a in (v + 1):life],\n        Inv[p, firstperiod + v - 1, a] == 0\n    )\n    # New inventory cannot exceed production in the most recent period\n    @constraint(\n        prod,\n        [p in 1:numprd, t in numperiods],\n        Inv[p, t, 1] <= Rprd[p, t] + Oprd[p, t]\n    )\n    # Inventory left from period (t+1)-p can only decrease as time goes on\n    secondperiod = firstperiod + 1\n    @constraint(\n        prod,\n        [p in 1:numprd, t in 2:lastperiod, a in 2:life],\n        Inv[p, t, a] <= Inv[p, t - 1, a - 1]\n    )\n    # OBJECTIVE\n    # Full regular wages for all crews employed, plus penalties for hiring and\n    # layoffs, plus wages for any overtime worked, plus inventory and shortage\n    # costs. (All other production costs are assumed to depend on initial\n    # inventory and on demands, and so are not included explicitly.)\n    @objective(\n        prod,\n        Min,\n        sum(\n            rtr * sl * dpp[t] * cs * Crews[t] +\n            hc[t] * Hire[t] +\n            lc[t] * Layoff[t] +\n            sum(\n                otr * cs * pt[p] * Oprd[p, t] +\n                sum(cri[p] * pc[p] * Inv[p, t, a] for a in 1:life) +\n                crs[p] * pc[p] * Short[p, t]\n                for p in 1:numprd\n            )\n           for t in numperiods\n        )\n    )\n    # Obtain solution\n    optimize!(prod)\n    Test.@test termination_status(prod) == MOI.OPTIMAL\n    Test.@test primal_status(prod) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(prod) ‚âà 4_426_822.89 atol = 1e-2\n    if verbose\n        println(\"RESULTS:\")\n        println(\"Crews\")\n        for t = 0:length(Crews.data) - 1\n            print(\" $(value(Crews[t])) \")\n        end\n        println()\n        println(\"Hire\")\n        for t = 1:length(Hire.data)\n            print(\" $(value(Hire[t])) \")\n        end\n        println()\n        println(\"Layoff\")\n        for t = 1:length(Layoff.data)\n            print(\" $(value(Layoff[t])) \")\n        end\n        println()\n    end\n    return\nend\n\nexample_prod()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/constraints/#ConstraintAPI","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"More information can be found in the Constraints section of the manual.","category":"page"},{"location":"reference/constraints/#Macros","page":"Constraints","title":"Macros","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"@constraint\n@constraints\n@SDconstraint\n@SDconstraints\nConstraintRef\nAbstractConstraint\nScalarConstraint\nVectorConstraint","category":"page"},{"location":"reference/constraints/#JuMP.@constraint","page":"Constraints","title":"JuMP.@constraint","text":"@constraint(m::Model, expr)\n\nAdd a constraint described by the expression expr.\n\n@constraint(m::Model, ref[i=..., j=..., ...], expr)\n\nAdd a group of constraints described by the expression expr parametrized by i, j, ...\n\nThe expression expr can either be\n\nof the form func in set constraining the function func to belong to the set set which is either a MOI.AbstractSet or one of the JuMP shortcuts SecondOrderCone, RotatedSecondOrderCone and PSDCone, e.g. @constraint(model, [1, x-1, y-2] in SecondOrderCone()) constrains the norm of [x-1, y-2] be less than 1;\nof the form a sign b, where sign is one of ==, ‚â•, >=, ‚â§ and <= building the single constraint enforcing the comparison to hold for the expression a and b, e.g. @constraint(m, x^2 + y^2 == 1) constrains x and y to lie on the unit circle;\nof the form a ‚â§ b ‚â§ c or a ‚â• b ‚â• c (where ‚â§ and <= (resp. ‚â• and >=) can be used interchangeably) constraining the paired the expression b to lie between a and c;\nof the forms @constraint(m, a .sign b) or @constraint(m, a .sign b .sign c) which broadcast the constraint creation to each element of the vectors.\n\nNote for extending the constraint macro\n\nEach constraint will be created using add_constraint(m, build_constraint(_error, func, set)) where\n\n_error is an error function showing the constraint call in addition to the error message given as argument,\nfunc is the expression that is constrained\nand set is the set in which it is constrained to belong.\n\nFor expr of the first type (i.e. @constraint(m, func in set)), func and set are passed unchanged to build_constraint but for the other types, they are determined from the expressions and signs. For instance, @constraint(m, x^2 + y^2 == 1) is transformed into add_constraint(m, build_constraint(_error, x^2 + y^2, MOI.EqualTo(1.0))).\n\nTo extend JuMP to accept new constraints of this form, it is necessary to add the corresponding methods to build_constraint. Note that this will likely mean that either func or set will be some custom type, rather than e.g. a Symbol, since we will likely want to dispatch on the type of the function or set appearing in the constraint.\n\n\n\n\n\n","category":"macro"},{"location":"reference/constraints/#JuMP.@constraints","page":"Constraints","title":"JuMP.@constraints","text":"@constraints(model, args...)\n\nAdds groups of constraints at once, in the same fashion as the @constraint macro.\n\nThe model must be the first argument, and multiple constraints can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@constraints(model, begin\n    x >= 1\n    y - w <= 2\n    sum_to_one[i=1:3], z[i] + y == 1\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/constraints/#JuMP.@SDconstraint","page":"Constraints","title":"JuMP.@SDconstraint","text":"@SDconstraint(model::Model, expr)\n\nAdd a semidefinite constraint described by the expression expr.\n\n@SDconstraint(model::Model, ref[i=..., j=..., ...], expr)\n\nAdd a group of semidefinite constraints described by the expression expr parametrized by i, j, ...\n\nThe expression expr needs to be of the form a sign b where sign is ‚™∞, ‚â•, >=, ‚™Ø, ‚â§ or <= and a and b are square matrices. It constrains the square matrix x (or -x if the sign is ‚™Ø, ‚â§ or <=) to be symmetric and positive semidefinite where\n\nx = a, if b is the symbol 0,\nx = -b, if a is the symbol 0,\notherwise, x = a - b.\n\nBy default, we check numerical symmetry of the matrix x, and if symmetry is violated by some arbitrary amount, we add explicit equality constraints. You can use Symmetric(x) in PSDCone() with the @constraint macro to skip these checks if you know the matrix must be symmetric; see PSDCone for more information.\n\nExamples\n\nThe following constrains the matrix [x-1 2x-2; -3 x-4] to be symmetric and positive semidefinite, that is, it constrains 2x-2 to be equal to -3 and constrains all eigenvalues of the matrix to be nonnegative.\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> a = [x 2x\n            0  x];\n\njulia> b = [1 2\n            3 4];\n\njulia> cref = @SDconstraint(model, a ‚™∞ b)\n[x - 1  2 x - 2;\n -3     x - 4  ] ‚àà PSDCone()\n\njulia> jump_function(constraint_object(cref))\n4-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n -3\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeSquare(2)\n\nIn the set PositiveSemidefiniteConeSquare(2) in the last output, Square means that the matrix is passed as a square matrix as the corresponding off-diagonal entries need to be constrained to be equal. A similar set PositiveSemidefiniteConeTriangle exists which only uses the upper triangular part of the matrix assuming that it is symmetric, see PSDCone to see how to use it.\n\n\n\n\n\n","category":"macro"},{"location":"reference/constraints/#JuMP.@SDconstraints","page":"Constraints","title":"JuMP.@SDconstraints","text":"@SDconstraints(model, args...)\n\nAdds multiple semi-definite constraints to model at once, in the same fashion as the @SDconstraint macro.\n\nThe model must be the first argument, and multiple constraints can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@SDconstraints(model, begin\n    A * x >= b\n    b - C * y >= 0\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/constraints/#JuMP.ConstraintRef","page":"Constraints","title":"JuMP.ConstraintRef","text":"ConstraintRef\n\nHolds a reference to the model and the corresponding MOI.ConstraintIndex.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.AbstractConstraint","page":"Constraints","title":"JuMP.AbstractConstraint","text":"abstract type AbstractConstraint\n\nAn abstract base type for all constraint types. AbstractConstraints store the function and set directly, unlike ConstraintRefs that are merely references to constraints stored in a model. AbstractConstraints do not need to be attached to a model.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.ScalarConstraint","page":"Constraints","title":"JuMP.ScalarConstraint","text":"struct ScalarConstraint\n\nThe data for a scalar constraint. The func field contains a JuMP object representing the function and the set field contains the MOI set. See also the documentation on JuMP's representation of constraints for more background.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.VectorConstraint","page":"Constraints","title":"JuMP.VectorConstraint","text":"struct VectorConstraint\n\nThe data for a vector constraint. The func field contains a JuMP object representing the function and the set field contains the MOI set. The shape field contains an AbstractShape matching the form in which the constraint was constructed (e.g., by using matrices or flat vectors). See also the documentation on JuMP's representation of constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#Names","page":"Constraints","title":"Names","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"name(::ConstraintRef{Model,<:JuMP._MOICON})\nset_name(::ConstraintRef{Model,<:JuMP._MOICON}, ::String)\nconstraint_by_name","category":"page"},{"location":"reference/constraints/#JuMP.name-Tuple{ConstraintRef{Model,#s938,Shape} where Shape<:AbstractShape where #s938<:MathOptInterface.ConstraintIndex}","page":"Constraints","title":"JuMP.name","text":"name(con_ref::ConstraintRef)\n\nGet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"reference/constraints/#JuMP.set_name-Tuple{ConstraintRef{Model,#s938,Shape} where Shape<:AbstractShape where #s938<:MathOptInterface.ConstraintIndex,String}","page":"Constraints","title":"JuMP.set_name","text":"set_name(con_ref::ConstraintRef, s::AbstractString)\n\nSet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"reference/constraints/#JuMP.constraint_by_name","page":"Constraints","title":"JuMP.constraint_by_name","text":"constraint_by_name(model::AbstractModel,\n                   name::String)::Union{ConstraintRef, Nothing}\n\nReturn the reference of the constraint with name attribute name or Nothing if no constraint has this name attribute. Throws an error if several constraints have name as their name attribute.\n\nconstraint_by_name(model::AbstractModel,\n                   name::String,\n                   F::Type{<:Union{AbstractJuMPScalar,\n                                   Vector{<:AbstractJuMPScalar},\n                                   MOI.AbstactFunction}},\n                   S::Type{<:MOI.AbstractSet})::Union{ConstraintRef, Nothing}\n\nSimilar to the method above, except that it throws an error if the constraint is not an F-in-S contraint where F is either the JuMP or MOI type of the function, and S is the MOI type of the set. This method is recommended if you know the type of the function and set since its returned type can be inferred while for the method above (i.e. without F and S), the exact return type of the constraint index cannot be inferred.\n\njulia> using JuMP\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x^2 == 1)\ncon : x¬≤ = 1.0\n\njulia> constraint_by_name(model, \"kon\")\n\njulia> constraint_by_name(model, \"con\")\ncon : x¬≤ = 1.0\n\njulia> constraint_by_name(model, \"con\", AffExpr, MOI.EqualTo{Float64})\n\njulia> constraint_by_name(model, \"con\", QuadExpr, MOI.EqualTo{Float64})\ncon : x¬≤ = 1.0\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#Modification","page":"Constraints","title":"Modification","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"normalized_coefficient\nset_normalized_coefficient\n\nnormalized_rhs\nset_normalized_rhs\n\nadd_to_function_constant","category":"page"},{"location":"reference/constraints/#JuMP.normalized_coefficient","page":"Constraints","title":"JuMP.normalized_coefficient","text":"normalized_coefficient(con_ref::ConstraintRef, variable::VariableRef)\n\nReturn the coefficient associated with variable in constraint after JuMP has normalized the constraint into its standard form. See also set_normalized_coefficient.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.set_normalized_coefficient","page":"Constraints","title":"JuMP.set_normalized_coefficient","text":"set_normalized_coefficient(con_ref::ConstraintRef, variable::VariableRef, value)\n\nSet the coefficient of variable in the constraint constraint to value.\n\nNote that prior to this step, JuMP will aggregate multiple terms containing the same variable. For example, given a constraint 2x + 3x <= 2, set_normalized_coefficient(con, x, 4) will create the constraint 4x <= 2.\n\nmodel = Model()\n@variable(model, x)\n@constraint(model, con, 2x + 3x <= 2)\nset_normalized_coefficient(con, x, 4)\ncon\n\n# output\n\ncon : 4 x <= 2.0\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.normalized_rhs","page":"Constraints","title":"JuMP.normalized_rhs","text":"normalized_rhs(con_ref::ConstraintRef)\n\nReturn the right-hand side term of con_ref after JuMP has converted the constraint into its normalized form. See also set_normalized_rhs.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.set_normalized_rhs","page":"Constraints","title":"JuMP.set_normalized_rhs","text":"set_normalized_rhs(con_ref::ConstraintRef, value)\n\nSet the right-hand side term of constraint to value.\n\nNote that prior to this step, JuMP will aggregate all constant terms onto the right-hand side of the constraint. For example, given a constraint 2x + 1 <= 2, set_normalized_rhs(con, 4) will create the constraint 2x <= 4, not 2x + 1 <= 4.\n\njulia> @constraint(model, con, 2x + 1 <= 2)\ncon : 2 x <= 1.0\n\njulia> set_normalized_rhs(con, 4)\n\njulia> con\ncon : 2 x <= 4.0\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.add_to_function_constant","page":"Constraints","title":"JuMP.add_to_function_constant","text":"add_to_function_constant(constraint::ConstraintRef, value)\n\nAdd value to the function constant term.\n\nNote that for scalar constraints, JuMP will aggregate all constant terms onto the right-hand side of the constraint so instead of modifying the function, the set will be translated by -value. For example, given a constraint 2x <= 3, add_to_function_constant(c, 4) will modify it to 2x <= -1.\n\nExamples\n\nFor scalar constraints, the set is translated by -value:\n\njulia> @constraint(model, con, 0 <= 2x - 1 <= 2)\ncon : 2 x ‚àà [1.0, 3.0]\n\njulia> add_to_function_constant(con, 4)\n\njulia> con\ncon : 2 x ‚àà [-3.0, -1.0]\n\nFor vector constraints, the constant is added to the function:\n\njulia> @constraint(model, con, [x + y, x, y] in SecondOrderCone())\ncon : [x + y, x, y] ‚àà MathOptInterface.SecondOrderCone(3)\n\njulia> add_to_function_constant(con, [1, 2, 2])\n\njulia> con\ncon : [x + y + 1, x + 2, y + 2] ‚àà MathOptInterface.SecondOrderCone(3)\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#Deletion","page":"Constraints","title":"Deletion","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"JuMP.delete\nis_valid\nConstraintNotOwned","category":"page"},{"location":"reference/constraints/#JuMP.delete","page":"Constraints","title":"JuMP.delete","text":"delete(model::Model, con_ref::ConstraintRef)\n\nDelete the constraint associated with constraint_ref from the model model.\n\nSee also: unregister\n\n\n\n\n\ndelete(model::Model, con_refs::Vector{<:ConstraintRef})\n\nDelete the constraints associated with con_refs from the model model. Solvers may implement specialized methods for deleting multiple constraints of the same concrete type, i.e., when isconcretetype(eltype(con_refs)). These may be more efficient than repeatedly calling the single constraint delete method.\n\nSee also: unregister\n\n\n\n\n\ndelete(model::Model, variable_ref::VariableRef)\n\nDelete the variable associated with variable_ref from the model model.\n\nSee also: unregister\n\n\n\n\n\ndelete(model::Model, variable_refs::Vector{VariableRef})\n\nDelete the variables associated with variable_refs from the model model. Solvers may implement methods for deleting multiple variables that are more efficient than repeatedly calling the single variable delete method.\n\nSee also: unregister\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.is_valid","page":"Constraints","title":"JuMP.is_valid","text":"is_valid(model::Model, con_ref::ConstraintRef{<:AbstractModel})\n\nReturn true if constraint_ref refers to a valid constraint in model.\n\n\n\n\n\nis_valid(model::Model, variable_ref::VariableRef)\n\nReturn true if variable refers to a valid variable in model.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.ConstraintNotOwned","page":"Constraints","title":"JuMP.ConstraintNotOwned","text":"struct ConstraintNotOwned{C <: ConstraintRef} <: Exception\n    constraint_ref::C\nend\n\nThe constraint constraint_ref was used in a model different to owner_model(constraint_ref).\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#Query-constraints","page":"Constraints","title":"Query constraints","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"list_of_constraint_types\nall_constraints\nnum_constraints\nindex(::ConstraintRef)\noptimizer_index(::ConstraintRef{Model})\nconstraint_object","category":"page"},{"location":"reference/constraints/#JuMP.list_of_constraint_types","page":"Constraints","title":"JuMP.list_of_constraint_types","text":"list_of_constraint_types(model::Model)::Vector{Tuple{DataType, DataType}}\n\nReturn a list of tuples of the form (F, S) where F is a JuMP function type and S is an MOI set type such that all_constraints(model, F, S) returns a nonempty list.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> list_of_constraint_types(model)\n3-element Array{Tuple{DataType,DataType},1}:\n (GenericAffExpr{Float64,VariableRef}, MathOptInterface.LessThan{Float64})\n (VariableRef, MathOptInterface.GreaterThan{Float64})\n (VariableRef, MathOptInterface.ZeroOne)\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.all_constraints","page":"Constraints","title":"JuMP.all_constraints","text":"all_constraints(model::Model, function_type, set_type)::Vector{<:ConstraintRef}\n\nReturn a list of all constraints currently in the model where the function has type function_type and the set has type set_type. The constraints are ordered by creation time.\n\nSee also list_of_constraint_types and num_constraints.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> all_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}},ScalarShape},1}:\n x ‚â• 0.0\n\njulia> all_constraints(model, VariableRef, MOI.ZeroOne)\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.ZeroOne},ScalarShape},1}:\n x binary\n\njulia> all_constraints(model, AffExpr, MOI.LessThan{Float64})\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n 2 x ‚â§ 1.0\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.num_constraints","page":"Constraints","title":"JuMP.num_constraints","text":"num_constraints(model::Model, function_type, set_type)::Int64\n\nReturn the number of constraints currently in the model where the function has type function_type and the set has type set_type.\n\nSee also list_of_constraint_types and all_constraints.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @variable(model, y);\n\njulia> @constraint(model, y in MOI.GreaterThan(1.0));\n\njulia> @constraint(model, y <= 1.0);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> num_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n2\n\njulia> num_constraints(model, VariableRef, MOI.ZeroOne)\n1\n\njulia> num_constraints(model, AffExpr, MOI.LessThan{Float64})\n2\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.index-Tuple{ConstraintRef}","page":"Constraints","title":"JuMP.index","text":"index(cr::ConstraintRef)::MOI.ConstraintIndex\n\nReturn the index of the constraint that corresponds to cr in the MOI backend.\n\n\n\n\n\n","category":"method"},{"location":"reference/constraints/#JuMP.optimizer_index-Tuple{ConstraintRef{Model,C,Shape} where Shape<:AbstractShape where C}","page":"Constraints","title":"JuMP.optimizer_index","text":"optimizer_index(cr::ConstraintRef{Model})::MOI.ConstraintIndex\n\nReturn the index of the constraint that corresponds to cr in the optimizer model. It throws NoOptimizer if no optimizer is set and throws an ErrorException if the optimizer is set but is not attached or if the constraint is bridged.\n\n\n\n\n\n","category":"method"},{"location":"reference/constraints/#JuMP.constraint_object","page":"Constraints","title":"JuMP.constraint_object","text":"constraint_object(con_ref::ConstraintRef)\n\nReturn the underlying constraint data for the constraint referenced by ref.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#Start-values","page":"Constraints","title":"Start values","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"set_dual_start_value\ndual_start_value","category":"page"},{"location":"reference/constraints/#JuMP.set_dual_start_value","page":"Constraints","title":"JuMP.set_dual_start_value","text":"set_dual_start_value(con_ref::ConstraintRef, value)\n\nSet the dual start value (MOI attribute ConstraintDualStart) of the constraint con_ref to value. To remove a dual start value set it to nothing.\n\nSee also dual_start_value.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.dual_start_value","page":"Constraints","title":"JuMP.dual_start_value","text":"dual_start_value(con_ref::ConstraintRef)\n\nReturn the dual start value (MOI attribute ConstraintDualStart) of the constraint con_ref.\n\nNote: If no dual start value has been set, dual_start_value will return nothing.\n\nSee also set_dual_start_value.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#Special-sets","page":"Constraints","title":"Special sets","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"SecondOrderCone\nRotatedSecondOrderCone\nPSDCone\nSOS1\nSOS2\nSkewSymmetricMatrixSpace\nSkewSymmetricMatrixShape\nmoi_set","category":"page"},{"location":"reference/constraints/#JuMP.SecondOrderCone","page":"Constraints","title":"JuMP.SecondOrderCone","text":"SecondOrderCone\n\nSecond order cone object that can be used to constrain the euclidean norm of a vector x to be less than or equal to a nonnegative scalar t. This is a shortcut for the MOI.SecondOrderCone.\n\nExamples\n\nThe following constrains (x-1 x-2)_2 le t and t ge 0:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, t)\nt\n\njulia> @constraint(model, [t, x-1, x-2] in SecondOrderCone())\n[t, x - 1, x - 2] ‚àà MathOptInterface.SecondOrderCone(3)\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.RotatedSecondOrderCone","page":"Constraints","title":"JuMP.RotatedSecondOrderCone","text":"RotatedSecondOrderCone\n\nRotated second order cone object that can be used to constrain the square of the euclidean norm of a vector x to be less than or equal to 2tu where t and u are nonnegative scalars. This is a shortcut for the MOI.RotatedSecondOrderCone.\n\nExamples\n\nThe following constrains (x-1 x-2)_2 le 2tx and t x ge 0:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, t)\nt\n\njulia> @constraint(model, [t, x, x-1, x-2] in RotatedSecondOrderCone())\n[t, x, x - 1, x - 2] ‚àà MathOptInterface.RotatedSecondOrderCone(4)\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.PSDCone","page":"Constraints","title":"JuMP.PSDCone","text":"PSDCone\n\nPositive semidefinite cone object that can be used to constrain a square matrix to be positive semidefinite in the @constraint macro. If the matrix has type Symmetric then the columns vectorization (the vector obtained by concatenating the columns) of its upper triangular part is constrained to belong to the MOI.PositiveSemidefiniteConeTriangle set, otherwise its column vectorization is constrained to belong to the MOI.PositiveSemidefiniteConeSquare set.\n\nExamples\n\nConsider the following example:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> a = [ x 2x\n            2x  x];\n\njulia> b = [1 2\n            2 4];\n\njulia> cref = @SDconstraint(model, a ‚™∞ b)\n[x - 1    2 x - 2;\n 2 x - 2  x - 4  ] ‚àà PSDCone()\n\njulia> jump_function(constraint_object(cref))\n4-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n 2 x - 2\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeSquare(2)\n\nWe see in the output of the last command that the matrix the vectorization of the matrix is constrained to belong to the PositiveSemidefiniteConeSquare.\n\njulia> using LinearAlgebra # For Symmetric\n\njulia> cref = @constraint(model, Symmetric(a - b) in PSDCone())\n[x - 1    2 x - 2;\n 2 x - 2  x - 4  ] ‚àà PSDCone()\n\njulia> jump_function(constraint_object(cref))\n3-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeTriangle(2)\n\nAs we see in the output of the last command, the vectorization of only the upper triangular part of the matrix is constrained to belong to the PositiveSemidefiniteConeSquare.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SOS1","page":"Constraints","title":"JuMP.SOS1","text":"SOS1\n\nSOS1 (Special Ordered Sets type 1) object than can be used to constrain a vector x to a set where at most 1 variable can take a non-zero value, all others being at 0. The weights, when specified, induce an ordering of the variables; as such, they should be unique values. The kth element in the set corresponds to the kth weight in weights. See here for a description of SOS constraints and their potential uses. This is a shortcut for the MathOptInterface.SOS1 set.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SOS2","page":"Constraints","title":"JuMP.SOS2","text":"SOS2\n\nSOS1 (Special Ordered Sets type 2) object than can be used to constrain a vector x to a set where at most 2 variables can take a non-zero value, all others being at 0. In addition, if two are non-zero these must be consecutive in their ordering. The weights induce an ordering of the variables; as such, they should be unique values. The kth element in the set corresponds to the kth weight in weights. See here for a description of SOS constraints and their potential uses. This is a shortcut for the MathOptInterface.SOS2 set.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SkewSymmetricMatrixSpace","page":"Constraints","title":"JuMP.SkewSymmetricMatrixSpace","text":"SkewSymmetricMatrixSpace()\n\nUse in the @variable macro to constrain a matrix of variables to be skew-symmetric.\n\nExamples\n\n@variable(model, Q[1:2, 1:2] in SkewSymmetricMatrixSpace())\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SkewSymmetricMatrixShape","page":"Constraints","title":"JuMP.SkewSymmetricMatrixShape","text":"SkewSymmetricMatrixShape\n\nShape object for a skew symmetric square matrix of side_dimension rows and columns. The vectorized form contains the entries of the upper-right triangular part of the matrix (without the diagonal) given column by column (or equivalently, the entries of the lower-left triangular part given row by row). The diagonal is zero.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.moi_set","page":"Constraints","title":"JuMP.moi_set","text":"moi_set(constraint::AbstractConstraint)\n\nReturn the set of the constraint constraint in the function-in-set form as a MathOptInterface.AbstractSet.\n\nmoi_set(s::AbstractVectorSet, dim::Int)\n\nReturns the MOI set of dimension dim corresponding to the JuMP set s.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#Printing","page":"Constraints","title":"Printing","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"function_string\nconstraints_string\nin_set_string\nshow_constraints_summary","category":"page"},{"location":"reference/constraints/#JuMP.function_string","page":"Constraints","title":"JuMP.function_string","text":"function_string(print_mode::Type{<:JuMP.PrintMode},\n                func::Union{JuMP.AbstractJuMPScalar,\n                            Vector{<:JuMP.AbstractJuMPScalar}})\n\nReturn a String representing the function func using print mode print_mode.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.constraints_string","page":"Constraints","title":"JuMP.constraints_string","text":"constraints_string(print_mode, model::AbstractModel)::Vector{String}\n\nReturn a list of Strings describing each constraint of the model.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.in_set_string","page":"Constraints","title":"JuMP.in_set_string","text":"in_set_string(print_mode::Type{<:PrintMode}, set)\n\nReturn a String representing the membership to the set set using print mode print_mode.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.show_constraints_summary","page":"Constraints","title":"JuMP.show_constraints_summary","text":"show_constraints_summary(io::IO, model::AbstractModel)\n\nWrite to io a summary of the number of constraints.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/callbacks.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"This example uses the following packages:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"using JuMP\nimport GLPK\nimport Random","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/#Lazy-constraints","page":"Callbacks","title":"Lazy constraints","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using a lazy constraint callback.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_lazy_constraint()\n    model = Model(GLPK.Optimizer)\n    @variable(model, 0 <= x <= 2.5, Int)\n    @variable(model, 0 <= y <= 2.5, Int)\n    @objective(model, Max, y)\n    lazy_called = false\n    function my_callback_function(cb_data)\n        lazy_called = true\n        x_val = callback_value(cb_data, x)\n        y_val = callback_value(cb_data, y)\n        println(\"Called from (x, y) = ($x_val, $y_val)\")\n        status = callback_node_status(cb_data, model)\n        if status == MOI.CALLBACK_NODE_STATUS_FRACTIONAL\n            println(\" - Solution is integer infeasible!\")\n        elseif status == MOI.CALLBACK_NODE_STATUS_INTEGER\n            println(\" - Solution is integer feasible!\")\n        else\n            @assert status == MOI.CALLBACK_NODE_STATUS_UNKNOWN\n            println(\" - I don't know if the solution is integer feasible :(\")\n        end\n        if y_val - x_val > 1 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        elseif y_val + x_val > 3 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        end\n    end\n    MOI.set(model, MOI.LazyConstraintCallback(), my_callback_function)\n    optimize!(model)\n    println(\"Optimal solution (x, y) = ($(value(x)), $(value(y)))\")\n    return\nend\n\nexample_lazy_constraint()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/#User-cut","page":"Callbacks","title":"User-cut","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using a user-cut callback.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_user_cut_constraint()\n    Random.seed!(1)\n    N = 30\n    item_weights, item_values = rand(N), rand(N)\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:N], Bin)\n    @constraint(model, sum(item_weights[i] * x[i] for i = 1:N) <= 10)\n    @objective(model, Max, sum(item_values[i] * x[i] for i = 1:N))\n    callback_called = false\n    function my_callback_function(cb_data)\n        callback_called = true\n        x_vals = callback_value.(Ref(cb_data), x)\n        accumulated = sum(item_weights[i] for i = 1:N if x_vals[i] > 1e-4)\n        println(\"Called with accumulated = $(accumulated)\")\n        n_terms = sum(1 for i = 1:N if x_vals[i] > 1e-4)\n        if accumulated > 10\n            con = @build_constraint(\n                sum(x[i] for i = 1:N if x_vals[i] > 0.5) <= n_terms - 1\n            )\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.UserCut(cb_data), con)\n        end\n    end\n    MOI.set(model, MOI.UserCutCallback(), my_callback_function)\n    optimize!(model)\n    @show callback_called\n    return\nend\n\nexample_user_cut_constraint()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/#HeuristicCallback","page":"Callbacks","title":"HeuristicCallback","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using a heuristic solution callback.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_heuristic_solution()\n    Random.seed!(1)\n    N = 30\n    item_weights, item_values = rand(N), rand(N)\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:N], Bin)\n    @constraint(model, sum(item_weights[i] * x[i] for i = 1:N) <= 10)\n    @objective(model, Max, sum(item_values[i] * x[i] for i = 1:N))\n    callback_called = false\n    function my_callback_function(cb_data)\n        callback_called = true\n        x_vals = callback_value.(Ref(cb_data), x)\n        ret = MOI.submit(\n            model, MOI.HeuristicSolution(cb_data), x, floor.(x_vals)\n        )\n        println(\"Heuristic solution status = $(ret)\")\n    end\n    MOI.set(model, MOI.HeuristicCallback(), my_callback_function)\n    optimize!(model)\n    return\nend\n\nexample_heuristic_solution()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/#GLPK-solver-dependent-callback","page":"Callbacks","title":"GLPK solver-dependent callback","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using GLPK's solver-dependent callback.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_solver_dependent_callback()\n    model = Model(GLPK.Optimizer)\n    @variable(model, 0 <= x <= 2.5, Int)\n    @variable(model, 0 <= y <= 2.5, Int)\n    @objective(model, Max, y)\n    lazy_called = false\n    function my_callback_function(cb_data)\n        lazy_called = true\n        reason = GLPK.glp_ios_reason(cb_data.tree)\n        println(\"Called from reason = $(reason)\")\n        if reason != GLPK.GLP_IROWGEN\n            return\n        end\n        x_val = callback_value(cb_data, x)\n        y_val = callback_value(cb_data, y)\n        if y_val - x_val > 1 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        elseif y_val + x_val > 3 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        end\n    end\n    MOI.set(model, GLPK.CallbackFunction(), my_callback_function)\n    optimize!(model)\n    return\nend\n\nexample_solver_dependent_callback()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Nonlinear programs/rocket_control.jl\"","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Rocket-Control","page":"Rocket Control","title":"Rocket Control","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Originally Contributed by: Iain Dunning","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"This tutorial shows how to solve a nonlinear rocketry control problem. The problem was drawn from the COPS3 benchmark.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Our goal is to maximize the final altitude of a vertically launched rocket.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We can control the thrust of the rocket, and must take account of the rocket mass, fuel consumption rate, gravity, and aerodynamic drag.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Let us consider the basic description of the model (for the full description, including parameters for the rocket, see the COPS3 PDF)","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Overview","page":"Rocket Control","title":"Overview","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We will use a discretized model of time, with a fixed number of time steps, n.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We will make the time step size Delta t, and thus the final time t_f = n cdot Delta t, a variable in the problem. To approximate the derivatives in the problem we will use the trapezoidal rule.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#State-and-Control","page":"Rocket Control","title":"State and Control","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We will have three state variables:","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Velocity, v\nAltitude, h\nMass of rocket and remaining fuel, m","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"and a single control variable, thrust T.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Our goal is thus to maximize h(t_f).","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Each of these corresponds to a JuMP variable indexed by the time step.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Dynamics","page":"Rocket Control","title":"Dynamics","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We have three equations that control the dynamics of the rocket:","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Rate of ascent: h^prime = v Acceleration: v^prime = fracT - D(hv)m - g(h) Rate of mass loss: m^prime = -fracTc","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"where drag D(hv) is a function of altitude and velocity, and gravity g(h) is a function of altitude.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"These forces are defined as","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"D(hv) = D_c v^2 expleft( -h_c left( frach-h(0)h(0) right) right)","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"and g(h) = g_0 left( frach(0)h right)^2","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"The three rate equations correspond to JuMP constraints, and for convenience we will represent the forces with nonlinear expressions.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"using JuMP\nimport Ipopt\nimport Plots","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Create JuMP model, using Ipopt as the solver","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"rocket = Model(Ipopt.Optimizer)\nset_silent(rocket)","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Constants","page":"Rocket Control","title":"Constants","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Note that all parameters in the model have been normalized to be dimensionless. See the COPS3 paper for more info.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"h_0 = 1    # Initial height\nv_0 = 0    # Initial velocity\nm_0 = 1    # Initial mass\ng_0 = 1    # Gravity at the surface\n\nT_c = 3.5  # Used for thrust\nh_c = 500  # Used for drag\nv_c = 620  # Used for drag\nm_c = 0.6  # Fraction of initial mass left at end\n\nc     = 0.5 * sqrt(g_0 * h_0)  # Thrust-to-fuel mass\nm_f   = m_c * m_0              # Final mass\nD_c   = 0.5 * v_c * m_0 / g_0  # Drag scaling\nT_max = T_c * g_0 * m_0        # Maximum thrust\n\nn = 800    # Time steps","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Decision-variables","page":"Rocket Control","title":"Decision variables","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"@variables(rocket, begin\n    Œît ‚â• 0, (start = 1/n) # Time step\n    # State variables\n    v[1:n] ‚â• 0            # Velocity\n    h[1:n] ‚â• h_0          # Height\n    m_f ‚â§ m[1:n] ‚â§ m_0    # Mass\n    # Control variables\n    0 ‚â§ T[1:n] ‚â§ T_max    # Thrust\nend)","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Objective","page":"Rocket Control","title":"Objective","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"The objective is to maximize altitude at end of time of flight.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"@objective(rocket, Max, h[n])","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Initial-conditions","page":"Rocket Control","title":"Initial conditions","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"fix(v[1], v_0; force = true)\nfix(h[1], h_0; force = true)\nfix(m[1], m_0; force = true)\nfix(m[n], m_f; force = true)","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Forces","page":"Rocket Control","title":"Forces","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"@NLexpressions(rocket, begin\n    # Drag(h,v) = Dc v^2 exp( -hc * (h - h0) / h0 )\n    drag[j = 1:n], D_c * (v[j]^2) * exp(-h_c * (h[j] - h_0) / h_0)\n    # Grav(h)   = go * (h0 / h)^2\n    grav[j = 1:n], g_0 * (h_0 / h[j])^2\n    # Time of flight\n    t_f, Œît * n\nend)","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Dynamics-2","page":"Rocket Control","title":"Dynamics","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"for j in 2:n\n    # h' = v\n    # Rectangular integration\n    # @NLconstraint(rocket, h[j] == h[j - 1] + Œît * v[j - 1])\n    # Trapezoidal integration\n    @NLconstraint(rocket, h[j] == h[j - 1] + 0.5 * Œît * (v[j] + v[j - 1]))\n    # v' = (T-D(h,v))/m - g(h)\n    # Rectangular integration\n    # @NLconstraint(\n    #     rocket,\n    #     v[j] == v[j - 1] + Œît *((T[j - 1] - drag[j - 1]) / m[j - 1] - grav[j - 1])\n    # )\n    # Trapezoidal integration\n    @NLconstraint(\n        rocket,\n        v[j] == v[j-1] +\n            0.5 * Œît * (\n                (T[j] - drag[j] - m[j] * grav[j]) / m[j] +\n                (T[j - 1] - drag[j - 1] - m[j - 1] * grav[j - 1]) / m[j - 1]\n            )\n    )\n    # m' = -T/c\n    # Rectangular integration\n    # @NLconstraint(rocket, m[j] == m[j - 1] - Œît * T[j - 1] / c)\n    # Trapezoidal integration\n    @NLconstraint(rocket, m[j] == m[j - 1] - 0.5 * Œît * (T[j] + T[j-1]) / c)\nend","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Solve for the control and state","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"println(\"Solving...\")\nstatus = optimize!(rocket)","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Display-results","page":"Rocket Control","title":"Display results","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"println(\"Max height: \", objective_value(rocket))","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"function my_plot(y, ylabel)\n    return Plots.plot(\n        (1:n) * value.(Œît),\n        value.(y)[:];\n        xlabel = \"Time (s)\",\n        ylabel = ylabel,\n    )\nend\n\nPlots.plot(\n    my_plot(h, \"Altitude\"),\n    my_plot(m, \"Mass\"),\n    my_plot(v, \"Velocity\"),\n    my_plot(T, \"Thrust\");\n    layout = (2, 2),\n    legend = false,\n    margin = 1Plots.cm,\n)","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"View this file on Github.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"This page was generated using Literate.jl.","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/errors/#Errors","page":"Errors","title":"Errors","text":"","category":"section"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"When an MOI call fails on a model, precise errors should be thrown when possible instead of simply calling error with a message. The docstrings for the respective methods describe the errors that the implementation should thrown in certain situations. This error-reporting system allows code to distinguish between internal errors (that should be shown to the user) and unsupported operations which may have automatic workarounds.","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"When an invalid index is used in an MOI call, an InvalidIndex should be thrown:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"InvalidIndex","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.InvalidIndex","page":"Errors","title":"MathOptInterface.InvalidIndex","text":"struct InvalidIndex{IndexType<:Index} <: Exception\n    index::IndexType\nend\n\nAn error indicating that the index index is invalid.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"As discussed in JuMP mapping, for scalar constraint with a nonzero function constant, a ScalarFunctionConstantNotZero exception may be thrown:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"ScalarFunctionConstantNotZero","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.ScalarFunctionConstantNotZero","page":"Errors","title":"MathOptInterface.ScalarFunctionConstantNotZero","text":"struct ScalarFunctionConstantNotZero{T, F, S} <: Exception\n    constant::T\nend\n\nAn error indicating that the constant part of the function in the constraint F-in-S is nonzero.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"Some SingleVariable constraints cannot be combined on the same variable:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"LowerBoundAlreadySet\nUpperBoundAlreadySet","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.LowerBoundAlreadySet","page":"Errors","title":"MathOptInterface.LowerBoundAlreadySet","text":"LowerBoundAlreadySet{S1, S2}\n\nError thrown when setting a SingleVariable-in-S2 when a SingleVariable-in-S1 has already been added and the sets S1, S2 both set a lower bound, i.e. they are EqualTo, GreaterThan, Interval, Semicontinuous or Semiinteger.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.UpperBoundAlreadySet","page":"Errors","title":"MathOptInterface.UpperBoundAlreadySet","text":"UpperBoundAlreadySet{S1, S2}\n\nError thrown when setting a SingleVariable-in-S2 when a SingleVariable-in-S1 has already been added and the sets S1, S2 both set an upper bound, i.e. they are EqualTo, LessThan, Interval, Semicontinuous or Semiinteger.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"As discussed in AbstractCallback, trying to get attributes inside a callback may throw:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"OptimizeInProgress","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.OptimizeInProgress","page":"Errors","title":"MathOptInterface.OptimizeInProgress","text":"struct OptimizeInProgress{AttrType<:AnyAttribute} <: Exception\n    attr::AttrType\nend\n\nError thrown from optimizer when MOI.get(optimizer, attr) is called inside an AbstractCallback while it is only defined once optimize! has completed. This can only happen when is_set_by_optimize(attr) is true.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"Trying to submit the wrong type of AbstractSubmittable inside an AbstractCallback (e.g., a UserCut inside a LazyConstraintCallback) will throw:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"InvalidCallbackUsage","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.InvalidCallbackUsage","page":"Errors","title":"MathOptInterface.InvalidCallbackUsage","text":"struct InvalidCallbackUsage{C, S} <: Exception\n    callback::C\n    submittable::S\nend\n\nAn error indicating that submittable cannot be submitted inside callback.\n\nFor example, UserCut cannot be submitted inside LazyConstraintCallback.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"The rest of the errors defined in MOI fall in two categories represented by the following two abstract types:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"UnsupportedError\nNotAllowedError","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.UnsupportedError","page":"Errors","title":"MathOptInterface.UnsupportedError","text":"UnsupportedError <: Exception\n\nAbstract type for error thrown when an element is not supported by the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.NotAllowedError","page":"Errors","title":"MathOptInterface.NotAllowedError","text":"NotAllowedError <: Exception\n\nAbstract type for error thrown when an operation is supported but cannot be applied in the current state of the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"The different UnsupportedError and NotAllowedError are the following errors:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"UnsupportedAttribute\nSetAttributeNotAllowed\nAddVariableNotAllowed\nUnsupportedConstraint\nAddConstraintNotAllowed\nModifyConstraintNotAllowed\nModifyObjectiveNotAllowed\nDeleteNotAllowed\nUnsupportedSubmittable\nSubmitNotAllowed","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.UnsupportedAttribute","page":"Errors","title":"MathOptInterface.UnsupportedAttribute","text":"struct UnsupportedAttribute{AttrType} <: UnsupportedError\n    attr::AttrType\n    message::String\nend\n\nAn error indicating that the attribute attr is not supported by the model, i.e. that supports returns false.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.SetAttributeNotAllowed","page":"Errors","title":"MathOptInterface.SetAttributeNotAllowed","text":"struct SetAttributeNotAllowed{AttrType} <: NotAllowedError\n    attr::AttrType\n    message::String # Human-friendly explanation why the attribute cannot be set\nend\n\nAn error indicating that the attribute attr is supported (see supports) but cannot be set for some reason (see the error string).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.AddVariableNotAllowed","page":"Errors","title":"MathOptInterface.AddVariableNotAllowed","text":"struct AddVariableNotAllowed <: NotAllowedError\n    message::String # Human-friendly explanation why the attribute cannot be set\nend\n\nAn error indicating that variables cannot be added to the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.UnsupportedConstraint","page":"Errors","title":"MathOptInterface.UnsupportedConstraint","text":"struct UnsupportedConstraint{F<:AbstractFunction, S<:AbstractSet} <: UnsupportedError\n    message::String # Human-friendly explanation why the attribute cannot be set\nend\n\nAn error indicating that constraints of type F-in-S are not supported by the model, i.e. that supports_constraint returns false.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.AddConstraintNotAllowed","page":"Errors","title":"MathOptInterface.AddConstraintNotAllowed","text":"struct AddConstraintNotAllowed{F<:AbstractFunction, S<:AbstractSet} <: NotAllowedError\n    message::String # Human-friendly explanation why the attribute cannot be set\nend\n\nAn error indicating that constraints of type F-in-S are supported (see supports_constraint) but cannot be added.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.ModifyConstraintNotAllowed","page":"Errors","title":"MathOptInterface.ModifyConstraintNotAllowed","text":"struct ModifyConstraintNotAllowed{F<:AbstractFunction, S<:AbstractSet,\n                                  C<:AbstractFunctionModification} <: NotAllowedError\n    constraint_index::ConstraintIndex{F, S}\n    change::C\n    message::String\nend\n\nAn error indicating that the constraint modification change cannot be applied to the constraint of index ci.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.ModifyObjectiveNotAllowed","page":"Errors","title":"MathOptInterface.ModifyObjectiveNotAllowed","text":"struct ModifyObjectiveNotAllowed{C<:AbstractFunctionModification} <: NotAllowedError\n    change::C\n    message::String\nend\n\nAn error indicating that the objective modification change cannot be applied to the objective.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.DeleteNotAllowed","page":"Errors","title":"MathOptInterface.DeleteNotAllowed","text":"struct DeleteNotAllowed{IndexType <: Index} <: NotAllowedError\n    index::IndexType\n    message::String\nend\n\nAn error indicating that the index index cannot be deleted.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.UnsupportedSubmittable","page":"Errors","title":"MathOptInterface.UnsupportedSubmittable","text":"struct UnsupportedSubmittable{SubmitType} <: UnsupportedError\n    sub::SubmitType\n    message::String\nend\n\nAn error indicating that the submittable sub is not supported by the model, i.e. that supports returns false.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.SubmitNotAllowed","page":"Errors","title":"MathOptInterface.SubmitNotAllowed","text":"struct SubmitNotAllowed{SubmitTyp<:AbstractSubmittable} <: NotAllowedError\n    sub::SubmitType\n    message::String # Human-friendly explanation why the attribute cannot be set\nend\n\nAn error indicating that the submittable sub is supported (see supports) but cannot be added for some reason (see the error string).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"Note that setting the ConstraintFunction of a [SingleVariable] constraint is not allowed:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"SettingSingleVariableFunctionNotAllowed","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.SettingSingleVariableFunctionNotAllowed","page":"Errors","title":"MathOptInterface.SettingSingleVariableFunctionNotAllowed","text":"SettingSingleVariableFunctionNotAllowed()\n\nError type that should be thrown when the user calls set to change the ConstraintFunction of a SingleVariable constraint.\n\n\n\n\n\n","category":"type"},{"location":"installation/#Installation-Guide","page":"Installation Guide","title":"Installation Guide","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"info: Info\nInstallation troubles? Check the Common installation issues section below.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"JuMP is a package for Julia. To use JuMP, first download and install Julia.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nThis version of JuMP is compatible with Julia 1.0 and later.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"From Julia, JuMP is installed using the built-in package manager:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.add(\"JuMP\")","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"tip: Tip\nWe recommend you create a Pkg environment for each project you use JuMP for, instead of adding lots of packages to the global environment. The Pkg manager documentation has more information on this topic.","category":"page"},{"location":"installation/#Installing-a-solver","page":"Installation Guide","title":"Installing a solver","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"JuMP depends on solvers to solve optimization problems, and you will need to install one before you can solve problems with JuMP. The table below lists the currently available solvers.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Install a solver using the Julia package manager, replacing \"Clp\" by the Julia package name as appropriate.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.add(\"Clp\")","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Once installed, you can use Clp as a solver with JuMP as follows, using set_optimizer_attributes to set solver-specific options:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"using JuMP\nusing Clp\nmodel = Model(Clp.Optimizer)\nset_optimizer_attributes(model, \"LogLevel\" => 1, \"PrimalTolerance\" => 1e-7)","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nMost packages follow the ModuleName.Optimizer naming convention, but exceptions may exist. See the README of the Julia package's Github repository for more details on how to use a particular solver, including any solver-specific options.","category":"page"},{"location":"installation/#Supported-solvers","page":"Installation Guide","title":"Supported solvers","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Most solvers are not written in Julia, and some require commercial licenses to use, so installation is often more complex.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"If a solver has Manual in the Installation column, the solver requires a manual installation step, such as downloading and installing a binary, or obtaining a commercial license. Consult the README of the relevant Julia package for more information.\nIf the solver has Manual·¥π in the Installation column, the solver requires an installation of MATLAB.\nIf the Installation column is missing an entry, installing the Julia package will download and install any relevant solver binaries automatically, and you shouldn't need to do anything other than Pkg.add.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Solvers with a missing entry in the Julia Package column are written in Julia. The link in the Solver column is the corresponding Julia package.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Solver Julia Package Installation License Supports\nAlpine.jl   Triad NS (MI)NLP\nArtelys Knitro KNITRO.jl Manual Comm. (MI)LP, (MI)SOCP, (MI)NLP\nBARON BARON.jl Manual Comm. (MI)NLP\nBonmin AmplNLWriter.jl  EPL (MI)NLP\nCbc Cbc.jl  EPL (MI)LP\nCDCS CDCS.jl Manual·¥π GPL LP, SOCP, SDP\nCDD CDDLib.jl  GPL LP\nClp Clp.jl  EPL LP\nCOSMO.jl   Apache LP, QP, SOCP, SDP\nCouenne AmplNLWriter.jl  EPL (MI)NLP\nCPLEX CPLEX.jl Manual Comm. (MI)LP, (MI)SOCP\nCSDP CSDP.jl  EPL LP, SDP\nEAGO.jl   MIT NLP\nECOS ECOS.jl  GPL LP, SOCP\nFICO Xpress Xpress.jl Manual Comm. (MI)LP, (MI)SOCP\nGLPK GLPK.jl  GPL (MI)LP\nGurobi Gurobi.jl Manual Comm. (MI)LP, (MI)SOCP\nHiGHS HiGHS.jl  MIT LP\nHypatia.jl   MIT LP, SOCP, SDP\nIpopt Ipopt.jl  EPL LP, QP, NLP\nJuniper.jl   MIT (MI)SOCP, (MI)NLP\nMOSEK MosekTools.jl Manual Comm. (MI)LP, (MI)SOCP, SDP\nNLopt NLopt.jl  GPL LP, QP, NLP\nOSQP OSQP.jl  Apache LP, QP\nPATH PATHSolver.jl  MIT MCP\nPavito.jl   MPL-2 (MI)NLP\nProxSDP.jl   MIT LP, SOCP, SDP\nSCIP SCIP.jl  ZIB (MI)LP, (MI)NLP\nSCS SCS.jl  MIT LP, SOCP, SDP\nSDPA SDPA.jl, SDPAFamily.jl  GPL LP, SDP\nSDPNAL SDPNAL.jl Manual·¥π CC BY-SA LP, SDP\nSDPT3 SDPT3.jl Manual·¥π GPL LP, SOCP, SDP\nSeDuMi SeDuMi.jl Manual·¥π GPL LP, SOCP, SDP\nTulip.jl   MPL-2 LP","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Where:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"LP = Linear programming\nQP = Quadratic programming\nSOCP = Second-order conic programming (including problems with convex quadratic constraints and/or objective)\nMCP = Mixed-complementarity programming\nNLP = Nonlinear programming\nSDP = Semidefinite programming\n(MI)XXX = Mixed-integer equivalent of problem type XXX","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nDeveloped a solver or solver wrapper? This table is open for new contributions! Start by making a pull request to edit the installation.md file.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nDeveloping a solver or solver wrapper? See Models and the MathOptInterface docs for more details on how JuMP interacts with solvers. Please get in touch via the Developer Chatroom with any questions about connecting new solvers with JuMP.","category":"page"},{"location":"installation/#Solver-specific-notes","page":"Installation Guide","title":"Solver-specific notes","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Artelys Knitro","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a license.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"BARON","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a license. A trial version is available for small problem instances.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"CDD","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"CDD can solve the problem both using Float64 and Rational{BigInt} arithmetics. The arithmetic used the type T given in CDDLib.Optimizer{T}. Only CDDLib.Optimizer{Float64} can be used with JuMP as JuMP inputs the problem in Float64 arithmetics. Use MOI directly for CDDLib.Optimizer{Rational{BigInt}}.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"COIN-OR Cbc","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Cbc supports \"SOS\" constraints.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"COSMO","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"COSMO can solve LPs, QPs, SOCPs and SDPs. It can handle SDPs with quadratic objective functions and supports chordal decomposition of large structured PSD constraints. COSMO is a first order method that performs well on large problems but has a low accuracy by default (10^4). See the COSMO.jl documentation for more information.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"CPLEX","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a working installation of CPLEX with a license (free for faculty members and graduate teaching assistants). CPLEX supports \"SOS\" constraints.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"ECOS","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"ECOS can be used by JuMP to solve LPs and SOCPs. ECOS does not support general quadratic objectives or constraints, only second-order conic constraints specified by using the SecondOrderCone set.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Gurobi","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a working installation of Gurobi with an activated license (free for academic use). Gurobi supports \"SOS\" constraints.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"FICO Xpress","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a working installation of Xpress with an active license (it is possible to get a license for academic use, see FICO Academic Partner Program). Supports SOCP and \"SOS\" constraints.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"MOSEK","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a license (free for academic use). The Mosek interface is maintained by the Mosek team. (Thanks!) Note that even if the package implementing MathOptInterface is MosekTools, for consistency the MOI optimizer is called Mosek.Optimizer so do the following to create a model with the Mosek solver:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"using MosekTools\nmodel = Model(Mosek.Optimizer)","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"ProxSDP","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"ProxSDP solves general SDP problems by means of a first order proximal algorithm based on the primal-dual hybrid gradient, also known as Chambolle-Pock method. The main advantage of ProxSDP over other state-of-the-art solvers is the ability to exploit the low-rank property inherent to several SDP problems. ProxSDP is a first order solver and has low accuracy. See the ProxSDP.jl documentation for more information.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"SCS","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"SCS can be used by JuMP to solve LPs and SOCPs, and SDPs. SCS is a first order solver and has low accuracy (10^4) by default; see the SCS.jl documentation for more information.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"SDPA","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"SDPA is a second order solver which comes in several variants. The main version has a C++ interface which SDPA.jl uses for efficiently communicating the problem instance to the solver. The three high-precision variants, SDPA-GMP (arbitrary precision), SDPA-QD (\"quad-double\" precision) and SDPA-DD (\"double-double\" precision) do not expose a library interface, but can used via SDPAFamily.jl, which writes and reads files to interact with the solver binary.","category":"page"},{"location":"installation/#AMPL-based-solvers","page":"Installation Guide","title":"AMPL-based solvers","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Use AmplNLWriter to access solvers that support the nl format.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Some solvers, such as Bonmin and Couenne can be installed via the Julia package manager. Others need to be manually installed.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Consult the AMPL documentation for a complete list of supported solvers.","category":"page"},{"location":"installation/#GAMS-based-solvers","page":"Installation Guide","title":"GAMS-based solvers","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Use GAMS.jl to access solvers available through GAMS. Such solvers include: AlphaECP, Antigone, BARON, CONOPT, Couenne, LocalSolver, PATHNLP, SHOT, SNOPT, SoPlex. See a complete list here.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nGAMS.jl requires an installation of the commercial software GAMS for which a free community license exists.","category":"page"},{"location":"installation/#Previously-supported-solvers","page":"Installation Guide","title":"Previously supported solvers","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"The following solvers were compatible with JuMP up to release 0.18 but are not yet compatible with the latest version because they do not implement the new MathOptInterface API:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Pajarito","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Please join the Developer Chatroom if you have interest in reviving a previously supported solver.","category":"page"},{"location":"installation/#Common-installation-issues","page":"Installation Guide","title":"Common installation issues","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"tip: Tip\nWhen in doubt, run import Pkg; Pkg.update() to see if updating your packages fixes the issue. Remember you will need to exit Julia and start a new session for the changes to take effect.","category":"page"},{"location":"installation/#Check-the-version-of-your-packages","page":"Installation Guide","title":"Check the version of your packages","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Each package is versioned with a three-part number of the form vX.Y.Z. You can check which versions you have installed with import Pkg; Pkg.status().","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"This should almost always be the most-recent release. You can check the releases of a package by going to the relevant Github page, and navigating to the \"releases\" page. For example, the list of JuMP releases is available at: https://github.com/jump-dev/JuMP.jl/releases.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"If you post on the community forum, please include the output of Pkg.status()!","category":"page"},{"location":"installation/#Unsatisfiable-requirements-detected","page":"Installation Guide","title":"Unsatisfiable requirements detected","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Did you get an error like Unsatisfiable requirements detected for package JuMP? The Pkg documentation has a section on how to understand and manage these conflicts.","category":"page"},{"location":"installation/#Installing-new-packages-can-make-JuMP-downgrade-to-an-earlier-version","page":"Installation Guide","title":"Installing new packages can make JuMP downgrade to an earlier version","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Another common complaint is that after adding a new package, code that previously worked no longer works.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"This usually happens because the new package is not compatible with the latest version of JuMP. Therefore, the package manager rolls-back JuMP to an earlier version! Here's an example.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"First, we add JuMP:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"(jump_example) pkg> add JuMP\n  Resolving package versions...\nUpdating `~/jump_example/Project.toml`\n  [4076af6c] + JuMP v0.21.5\nUpdating `~/jump_example/Manifest.toml`\n  ... lines omitted ...","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"The + JuMP v0.21.5 line indicates that JuMP has been added at version 0.21.5. However, watch what happens when we add JuMPeR:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"(jump_example) pkg> add JuMPeR\n  Resolving package versions...\nUpdating `~/jump_example/Project.toml`\n  [4076af6c] ‚Üì JuMP v0.21.5 ‚áí v0.18.6\n  [707a9f91] + JuMPeR v0.6.0\nUpdating `~/jump_example/Manifest.toml`\n  ... lines omitted ...","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"JuMPeR gets added at version 0.6.0 (+ JuMPeR v0.6.0), but JuMP gets downgraded from 0.21.5 to 0.18.6 (‚Üì JuMP v0.21.5 ‚áí v0.18.6)! The reason for this is that JuMPeR doesn't support a version of JuMP newer than 0.18.6.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"tip: Tip\nPay careful attention to the output of the package manager when adding new packages, especially when you see a package being downgraded!","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Conic programs/logistic_regression.jl\"","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/#Logistic-Regression","page":"Logistic Regression","title":"Logistic Regression","text":"","category":"section"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"Originally Contributed by: Fran√ßois Pacaud","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"This tutorial shows how to solve a logistic regression problem with JuMP. Logistic regression is a well known method in machine learning, useful when we want to classify binary variables with the help of a given set of features. To this goal, we find the optimal combination of features maximizing the (log)-likelihood onto a training set. From a modern optimization glance, the resulting problem is convex and differentiable. On a modern optimization glance, it is even conic representable.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/#Formulating-the-logistic-regression-problem","page":"Logistic Regression","title":"Formulating the logistic regression problem","text":"","category":"section"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"Suppose we have a set of training data-point i = 1 cdots n, where for each i we have a vector of features x_i in mathbbR^p and a categorical observation y_i in -1 1.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"The log-likelihood is given by","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"l(theta) = sum_i=1^n log(dfrac11 + exp(-y_i theta^top x_i))","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"and the optimal theta minimizes the logistic loss function:","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"min_theta sum_i=1^n log(1 + exp(-y_i theta^top x_i))","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"Most of the time, instead of solving directly the previous optimization problem, we prefer to add a regularization term:","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"min_theta sum_i=1^n log(1 + exp(-y_i theta^top x_i)) + lambda  theta ","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"with lambda in mathbbR_+ a penalty and  a norm function. By adding such a regularization term, we avoid overfitting on the training set and usually achieve a greater score in cross-validation.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/#Reformulation-as-a-conic-optimization-problem","page":"Logistic Regression","title":"Reformulation as a conic optimization problem","text":"","category":"section"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"By introducing auxiliary variables t_1 cdots t_n and r, the optimization problem is equivalent to","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"beginaligned\nmin_t r theta  sum_i=1^n t_i + lambda r \ntextsubject to   quad t_i geq log(1 + exp(- y_i theta^top x_i)) \n                    quad r geq theta\nendaligned","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"Now, the trick is to reformulate the constraints t_i geq log(1 + exp(- y_i theta^top x_i)) with the help of the exponential cone","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"K_exp =  (x y z) in mathbbR^3   y exp(x  y) leq z  ","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"Indeed, by passing to the exponential, we see that for all i=1 cdots n, the constraint t_i geq log(1 + exp(- y_i theta^top x_i)) is equivalent to","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"exp(-t_i) + exp(u_i - t_i) leq 1","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"with u_i = -y_i theta^top x_i. Then, by adding two auxiliary variables z_i1 and z_i2 such that z_i1 geq exp(u_i-t_i) and z_i2 geq exp(-t_i), we get the equivalent formulation","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"left\nbeginaligned\n(u_i -t_i  1 z_i1)  in  K_exp  \n(-t_i  1 z_i2)  in  K_exp  \nz_i1 + z_i2  leq  1\nendaligned\nright","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"In this setting, the conic version of the logistic regression problems writes out","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"beginaligned\nmin_t z r theta   sum_i=1^n t_i + lambda r \ntextsubject to   quad  (u_i -t_i  1 z_i1)  in  K_exp  \n                    quad  (-t_i  1 z_i2)  in  K_exp  \n                    quad  z_i1 + z_i2  leq  1 \n                    quad u_i = -y_i x_i^top theta \n                    quad r geq theta\nendaligned","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"and thus encompasses 3n + p + 1 variables and 3n + 1 constraints (u_i = -y_i theta^top x_i is only a virtual constraint used to clarify the notation). Thus, if n gg 1, we get a large number of variables and constraints.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/#Fitting-logistic-regression-with-a-conic-solver","page":"Logistic Regression","title":"Fitting logistic regression with a conic solver","text":"","category":"section"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"It is now time to pass to the implementation. We choose SCS as a conic solver.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"using JuMP\nimport Random\nimport SCS\n\nRandom.seed!(2713);\nnothing #hide","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"We start by implementing a function to generate a fake dataset, and where we could tune the correlation between the feature variables. The function is a direct transcription of the one used in this blog post.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"function generate_dataset(n_samples=100, n_features=10; shift=0.0)\n    X = randn(n_samples, n_features)\n    w = randn(n_features)\n    y = sign.(X * w)\n    X .+= 0.8 * randn(n_samples, n_features) # add noise\n    X .+= shift # shift the points in the feature space\n    X = hcat(X, ones(n_samples, 1))\n    return X, y\nend","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"We write a softplus function to formulate each constraint t geq log(1 + exp(u)) with two exponential cones.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"function softplus(model, t, u)\n    z = @variable(model, [1:2], lower_bound=0.0)\n    @constraint(model, sum(z) <= 1.0)\n    @constraint(model, [u - t, 1, z[1]] in MOI.ExponentialCone())\n    @constraint(model, [-t, 1, z[2]] in MOI.ExponentialCone())\nend","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/#\\ell_2-regularized-logistic-regression","page":"Logistic Regression","title":"ell_2 regularized logistic regression","text":"","category":"section"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"Then, with the help of the softplus function, we could write our optimization model. In the ell_2 regularization case, the constraint r geq theta_2 rewrites as a second order cone constraint.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"function build_logit_model(X, y, Œª)\n    n, p = size(X)\n    model = Model()\n    @variable(model, Œ∏[1:p])\n    @variable(model, t[1:n])\n    for i in 1:n\n        u = - (X[i, :]' * Œ∏) * y[i]\n        softplus(model, t[i], u)\n    end\n    # Add ‚Ñì2 regularization\n    @variable(model, 0.0 <= reg)\n    @constraint(model, [reg; Œ∏] in MOI.SecondOrderCone(p+1))\n    # Define objective\n    @objective(model, Min, sum(t) + Œª * reg)\n    return model\nend","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"We generate the dataset.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"warning: Warning\nBe careful here, for large n and p SCS could fail to converge!","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"n, p = 200, 10\nX, y = generate_dataset(n, p, shift=10.0);\n\n# We could now solve the logistic regression problem\nŒª = 10.0\nmodel = build_logit_model(X, y, Œª)\nset_optimizer(model, SCS.Optimizer)\nJuMP.optimize!(model)","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"Œ∏‚ôØ = JuMP.value.(model[:Œ∏])","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"It appears that the speed of convergence is not that impacted by the correlation of the dataset, nor by the penalty lambda.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/#\\ell_1-regularized-logistic-regression","page":"Logistic Regression","title":"ell_1 regularized logistic regression","text":"","category":"section"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"We now formulate the logistic problem with a ell_1 regularization term. The ell_1 regularization ensures sparsity in the optimal solution of the resulting optimization problem. Luckily, the ell_1 norm is implemented as a set in MathOptInterface. Thus, we could easily formulate the sparse logistic regression problem with the help of a MOI.NormOneCone set.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"function build_sparse_logit_model(X, y, Œª)\n    n, p = size(X)\n    model = Model()\n    @variable(model, Œ∏[1:p])\n    @variable(model, t[1:n])\n    for i in 1:n\n        u = - (X[i, :]' * Œ∏) * y[i]\n        softplus(model, t[i], u)\n    end\n    # Add ‚Ñì1 regularization\n    @variable(model, 0.0 <= reg)\n    @constraint(model, [reg; Œ∏] in MOI.NormOneCone(p+1))\n    # Define objective\n    @objective(model, Min, sum(t) + Œª * reg)\n    return model\nend\n\n# Auxiliary function to count non-null components:\ncount_nonzero(v::Vector; tol=1e-6) = sum(abs.(v) .>= tol)\n\n# We solve the sparse logistic regression problem on the same dataset as before.\nŒª = 10.0\nsparse_model = build_sparse_logit_model(X, y, Œª)\nset_optimizer(sparse_model, SCS.Optimizer)\nJuMP.optimize!(sparse_model)","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"Œ∏‚ôØ = JuMP.value.(sparse_model[:Œ∏])\nprintln(\"Number of non-zero components: \", count_nonzero(Œ∏‚ôØ),\n        \" (out of \", p, \" features)\")","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/#Extensions","page":"Logistic Regression","title":"Extensions","text":"","category":"section"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"A direct extension would be to consider the sparse logistic regression with hard thresholding, which, on contrary to the soft version using a ell_1 regularization, adds an explicit cardinality constraint in its formulation:","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"beginaligned\nmin_theta   sum_i=1^n log(1 + exp(-y_i theta^top x_i)) + lambda  theta _2^2 \ntextsubject to   quad  theta _0 = k\nendaligned","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"where k is the maximum number of non-zero components in the vector theta, and _0 is the ell_0 pseudo-norm:","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":" x_0 = i   x_i neq 0","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"The cardinality constraint theta_0 leq k could be reformulated with binary variables. Thus the hard sparse regression problem could be solved by any solver supporting mixed integer conic problems.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"View this file on Github.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/n-queens.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/#N-Queens","page":"N-Queens","title":"N-Queens","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"Originally Contributed by: Matthew Helm (with help from @mtanneau on Julia Discourse)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"The N-Queens problem involves placing N queens on an N x N chessboard such that none of the queens attacks another. In chess, a queen can move vertically, horizontally, and diagonally so there cannot be more than one queen on any given row, column, or diagonal.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"(Image: Four Queens)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"Note that none of the queens above are able to attack any other as a result of their careful placement.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"using JuMP\nimport GLPK\nimport LinearAlgebra","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"N-Queens","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"N = 8\n\nmodel = Model(GLPK.Optimizer)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"Next, let's create an N x N chessboard of binary values. 0 will represent an empty space on the board and 1 will represent a space occupied by one of our queens:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"@variable(model, x[1:N, 1:N], Bin)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"Now we can add our constraints:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"There must be exactly one queen in a given row/column","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"for i = 1:N\n    @constraint(model, sum(x[i, :]) == 1)\n    @constraint(model, sum(x[:, i]) == 1)\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"There can only be one queen on any given diagonal","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"for i in -(N-1):(N-1)\n    @constraint(model, sum(LinearAlgebra.diag(x, i)) <= 1)\n    @constraint(model, sum(LinearAlgebra.diag(reverse(x, dims=1), i)) <= 1)\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"That's it! We are ready to put our model to work and see if it is able to find a feasible solution:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"optimize!(model)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"We can now review the solution that our model found:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"solution = convert.(Int, value.(x))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"(Image: Four Queens)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/solutions/#SolutionAPI","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"More information can be found in the Solutions section of the manual.","category":"page"},{"location":"reference/solutions/#Basic-utilities","page":"Solutions","title":"Basic utilities","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"JuMP.optimize!\nNoOptimizer\nOptimizeNotCalled\nsolution_summary","category":"page"},{"location":"reference/solutions/#JuMP.optimize!","page":"Solutions","title":"JuMP.optimize!","text":"optimize!(model::Model;\n          ignore_optimize_hook=(model.optimize_hook === nothing),\n          kwargs...)\n\nOptimize the model. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nKeyword arguments kwargs are passed to the optimize_hook. An error is thrown if optimize_hook is nothing and keyword arguments are provided.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.NoOptimizer","page":"Solutions","title":"JuMP.NoOptimizer","text":"struct NoOptimizer <: Exception end\n\nNo optimizer is set. The optimizer can be provided to the Model constructor or by calling set_optimizer.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#JuMP.OptimizeNotCalled","page":"Solutions","title":"JuMP.OptimizeNotCalled","text":"struct OptimizeNotCalled <: Exception end\n\nA result attribute cannot be queried before optimize! is called.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#JuMP.solution_summary","page":"Solutions","title":"JuMP.solution_summary","text":"solution_summary(model::Model; verbose::Bool = false)\n\nReturn a struct that can be used print a summary of the solution.\n\nIf verbose=true, write out the primal solution for every variable and the dual solution for every constraint, excluding those with empty names.\n\nExamples\n\nWhen called at the REPL, the summary is automatically printed:\n\njulia> solution_summary(model)\n[...]\n\nUse print to force the printing of the summary from inside a function:\n\nfunction foo(model)\n    print(solution_summary(model))\n    return\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#Termination-status","page":"Solutions","title":"Termination status","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"termination_status\nraw_status\nresult_count","category":"page"},{"location":"reference/solutions/#JuMP.termination_status","page":"Solutions","title":"JuMP.termination_status","text":"termination_status(model::Model)\n\nReturn the reason why the solver stopped (i.e., the MathOptInterface model attribute TerminationStatus).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.raw_status","page":"Solutions","title":"JuMP.raw_status","text":"raw_status(model::Model)\n\nReturn the reason why the solver stopped in its own words (i.e., the MathOptInterface model attribute RawStatusString).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.result_count","page":"Solutions","title":"JuMP.result_count","text":"result_count(model::Model)\n\nReturn the number of results available to query after a call to optimize!.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#Primal-solutions","page":"Solutions","title":"Primal solutions","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"primal_status\nhas_values\nvalue","category":"page"},{"location":"reference/solutions/#JuMP.primal_status","page":"Solutions","title":"JuMP.primal_status","text":"primal_status(model::Model; result::Int = 1)\n\nReturn the status of the most recent primal solution of the solver (i.e., the MathOptInterface model attribute PrimalStatus) associated with the result index result.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.has_values","page":"Solutions","title":"JuMP.has_values","text":"has_values(model::Model; result::Int = 1)\n\nReturn true if the solver has a primal solution in result index result available to query, otherwise return false.\n\nSee also value and result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.value","page":"Solutions","title":"JuMP.value","text":"value(con_ref::ConstraintRef; result::Int = 1)\n\nReturn the primal value of constraint con_ref associated with result index result of the most-recent solution returned by the solver.\n\nThat is, if con_ref is the reference of a constraint func-in-set, it returns the value of func evaluated at the value of the variables (given by value(::VariableRef)).\n\nUse has_values to check if a result exists before asking for values.\n\nSee also: result_count.\n\nNote\n\nFor scalar constraints, the constant is moved to the set so it is not taken into account in the primal value of the constraint. For instance, the constraint @constraint(model, 2x + 3y + 1 == 5) is transformed into 2x + 3y-in-MOI.EqualTo(4) so the value returned by this function is the evaluation of 2x + 3y. ```\n\n\n\n\n\nvalue(con_ref::ConstraintRef, var_value::Function)\n\nEvaluate the primal value of the constraint con_ref using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(v::VariableRef; result = 1)\n\nReturn the value of variable v associated with result index result of the most-recent returned by the solver.\n\nUse has_values to check if a result exists before asking for values.\n\nSee also: result_count.\n\n\n\n\n\nvalue(v::VariableRef, var_value::Function)\n\nEvaluate the value of the variable v as var_value(v).\n\n\n\n\n\nvalue(ex::GenericAffExpr, var_value::Function)\n\nEvaluate ex using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(v::GenericAffExpr; result::Int = 1)\n\nReturn the value of the GenericAffExpr v associated with result index result of the most-recent solution returned by the solver.\n\nReplaces getvalue for most use cases.\n\nSee also: result_count.\n\n\n\n\n\nvalue(v::GenericQuadExpr; result::Int = 1)\n\nReturn the value of the GenericQuadExpr v associated with result index result of the most-recent solution returned by the solver.\n\nReplaces getvalue for most use cases.\n\nSee also: result_count.\n\n\n\n\n\nvalue(p::NonlinearParameter)\n\nReturn the current value stored in the nonlinear parameter p.\n\nExample\n\nmodel = Model()\n@NLparameter(model, p == 10)\nvalue(p)\n\n# output\n10.0\n\n\n\n\n\nvalue(ex::NonlinearExpression, var_value::Function)\n\nEvaluate ex using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(ex::NonlinearExpression; result::Int = 1)\n\nReturn the value of the NonlinearExpression ex associated with result index result of the most-recent solution returned by the solver.\n\nReplaces getvalue for most use cases.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#Dual-solutions","page":"Solutions","title":"Dual solutions","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"dual_status\nhas_duals\ndual\nshadow_price\nreduced_cost","category":"page"},{"location":"reference/solutions/#JuMP.dual_status","page":"Solutions","title":"JuMP.dual_status","text":"dual_status(model::Model; result::Int = 1)\n\nReturn the status of the most recent dual solution of the solver (i.e., the MathOptInterface model attribute DualStatus) associated with the result index result.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.has_duals","page":"Solutions","title":"JuMP.has_duals","text":"has_duals(model::Model; result::Int = 1)\n\nReturn true if the solver has a dual solution in result index result available to query, otherwise return false.\n\nSee also dual, shadow_price, and result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.dual","page":"Solutions","title":"JuMP.dual","text":"dual(con_ref::ConstraintRef; result::Int = 1)\n\nReturn the dual value of constraint con_ref associated with result index result of the most-recent solution returned by the solver.\n\nUse has_dual to check if a result exists before asking for values.\n\nSee also: result_count, shadow_price.\n\n\n\n\n\ndual(c::ConstraintRef{Model,NonlinearConstraintIndex})\n\nReturn the dual of the nonlinear constraint c.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.shadow_price","page":"Solutions","title":"JuMP.shadow_price","text":"shadow_price(con_ref::ConstraintRef)\n\nReturn the change in the objective from an infinitesimal relaxation of the constraint.\n\nThis value is computed from dual and can be queried only when has_duals is true and the objective sense is MIN_SENSE or MAX_SENSE (not FEASIBILITY_SENSE). For linear constraints, the shadow prices differ at most in sign from the dual value depending on the objective sense.\n\nSee also reduced_cost.\n\nNotes\n\nThe function simply translates signs from dual and does not validate the conditions needed to guarantee the sensitivity interpretation of the shadow price. The caller is responsible, e.g., for checking whether the solver converged to an optimal primal-dual pair or a proof of infeasibility.\nThe computation is based on the current objective sense of the model. If this has changed since the last solve, the results will be incorrect.\nRelaxation of equality constraints (and hence the shadow price) is defined based on which sense of the equality constraint is active.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.reduced_cost","page":"Solutions","title":"JuMP.reduced_cost","text":"reduced_cost(x::VariableRef)::Float64\n\nReturn the reduced cost associated with variable x.\n\nEquivalent to querying the shadow price of the active variable bound (if one exists and is active).\n\nSee also: shadow_price.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#Basic-attributes","page":"Solutions","title":"Basic attributes","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"objective_value\nobjective_bound\ndual_objective_value\nsolve_time\nrelative_gap\nsimplex_iterations\nbarrier_iterations\nnode_count","category":"page"},{"location":"reference/solutions/#JuMP.objective_value","page":"Solutions","title":"JuMP.objective_value","text":"objective_value(model::Model; result::Int = 1)\n\nReturn the objective value associated with result index result of the most-recent solution returned by the solver.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.objective_bound","page":"Solutions","title":"JuMP.objective_bound","text":"objective_bound(model::Model)\n\nReturn the best known bound on the optimal objective value after a call to optimize!(model).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.dual_objective_value","page":"Solutions","title":"JuMP.dual_objective_value","text":"dual_objective_value(model::Model; result::Int = 1)\n\nReturn the value of the objective of the dual problem associated with result index result of the most-recent solution returned by the solver.\n\nThrows MOI.UnsupportedAttribute{MOI.DualObjectiveValue} if the solver does not support this attribute.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.solve_time","page":"Solutions","title":"JuMP.solve_time","text":"solve_time(model::Model)\n\nIf available, returns the solve time reported by the solver. Returns \"ArgumentError: ModelLike of type Solver.Optimizer does not support accessing the attribute MathOptInterface.SolveTime()\" if the attribute is not implemented.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.relative_gap","page":"Solutions","title":"JuMP.relative_gap","text":"relative_gap(model::Model)\n\nReturn the final relative optimality gap after a call to optimize!(model). Exact value depends upon implementation of MathOptInterface.RelativeGap() by the particular solver used for optimization.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.simplex_iterations","page":"Solutions","title":"JuMP.simplex_iterations","text":"simplex_iterations(model::Model)\n\nGets the cumulative number of simplex iterations during the most-recent optimization.\n\nSolvers must implement MOI.SimplexIterations() to use this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.barrier_iterations","page":"Solutions","title":"JuMP.barrier_iterations","text":"barrier_iterations(model::Model)\n\nGets the cumulative number of barrier iterations during the most recent optimization.\n\nSolvers must implement MOI.BarrierIterations() to use this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.node_count","page":"Solutions","title":"JuMP.node_count","text":"node_count(model::Model)\n\nGets the total number of branch-and-bound nodes explored during the most recent optimization in a Mixed Integer Program.\n\nSolvers must implement MOI.NodeCount() to use this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#ref_conflicts","page":"Solutions","title":"Conflicts","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"compute_conflict!\ncopy_conflict","category":"page"},{"location":"reference/solutions/#JuMP.compute_conflict!","page":"Solutions","title":"JuMP.compute_conflict!","text":"compute_conflict!(model::Model)\n\nCompute a conflict if the model is infeasible. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nThe status of the conflict can be checked with the MOI.ConflictStatus model attribute. Then, the status for each constraint can be queried with the MOI.ConstraintConflictStatus attribute.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.copy_conflict","page":"Solutions","title":"JuMP.copy_conflict","text":"copy_conflict(model::Model)\n\nReturn a copy of the current conflict for the model model and a ReferenceMap that can be used to obtain the variable and constraint reference of the new model corresponding to a given model's reference.\n\nThis is a convenience function that provides a filtering function for copy_model.\n\nNote\n\nModel copy is not supported in DIRECT mode, i.e. when a model is constructed using the direct_model constructor instead of the Model constructor. Moreover, independently on whether an optimizer was provided at model construction, the new model will have no optimizer, i.e., an optimizer will have to be provided to the new model in the optimize! call.\n\nExamples\n\nIn the following example, a model model is constructed with a variable x and two constraints cref and cref2. This model has no solution, as the two constraints are mutually exclusive. The solver is asked to compute a conflict with compute_conflict!. The parts of model participating in the conflict are then copied into a model new_model.\n\nmodel = Model() # You must use a solver that supports conflict refining/IIS\n# computation, like CPLEX or Gurobi\n@variable(model, x)\n@constraint(model, cref, x >= 2)\n@constraint(model, cref2, x <= 1)\n\ncompute_conflict!(model)\nif MOI.get(model, MOI.ConflictStatus()) != MOI.CONFLICT_FOUND\n    error(\"No conflict could be found for an infeasible model.\")\nend\n\nnew_model, reference_map = copy_conflict(model)\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#Sensitivity","page":"Solutions","title":"Sensitivity","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"lp_sensitivity_report\nSensitivityReport\nlp_objective_perturbation_range\nlp_rhs_perturbation_range","category":"page"},{"location":"reference/solutions/#JuMP.lp_sensitivity_report","page":"Solutions","title":"JuMP.lp_sensitivity_report","text":"lp_sensitivity_report(model::Model; atol::Float64 = 1e-8)::SensitivityReport\n\nGiven a linear program model with a current optimal basis, return a SensitivityReport object, which maps:\n\nEvery variable reference to a tuple (d_lo, d_hi)::Tuple{Float64,Float64}, explaining how much the objective coefficient of the corresponding variable can change by, such that the original basis remains optimal.\nEvery constraint reference to a tuple (d_lo, d_hi)::Tuple{Float64,Float64}, explaining how much the right-hand side of the corresponding constraint can change by, such that the basis remains optimal.\n\nBoth tuples are relative, rather than absolute. So given a objective coefficient of 1.0 and a tuple (-0.5, 0.5), the objective coefficient can range between 1.0 - 0.5 an 1.0 + 0.5.\n\natol is the primal/dual optimality tolerance, and should match the tolerance of the solver used to compute the basis.\n\nNote: interval constraints are NOT supported.\n\nExample\n\nmodel = Model(GLPK.Optimizer)\n@variable(model, -1 <= x <= 2)\n@objective(model, Min, x)\noptimize!(model)\nreport = lp_sensitivity_report(model; atol = 1e-7)\ndx_lo, dx_hi = report[x]\nprintln(\n    \"The objective coefficient of `x` can decrease by $dx_lo or \" *\n    \"increase by $dx_hi.\"\n)\nc = LowerBoundRef(x)\ndRHS_lo, dRHS_hi = report[c]\nprintln(\n    \"The lower bound of `x` can decrease by $dRHS_lo or increase \" *\n    \"by $dRHS_hi.\"\n)\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.SensitivityReport","page":"Solutions","title":"JuMP.SensitivityReport","text":"SensitivityReport\n\nSee lp_sensitivity_report.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#JuMP.lp_objective_perturbation_range","page":"Solutions","title":"JuMP.lp_objective_perturbation_range","text":"lp_objective_perturbation_range(var::VariableRef;\n                                optimality_tolerance::Float64)\n                                ::Tuple{Float64, Float64}\n\nGives the range by which the cost coefficient can change and the current LP basis remains optimal, i.e., the reduced costs remain valid.\n\nNotes\n\nThe range denotes valid changes, Œî ‚àà [l, u], for which cost[var] += Œî do not violate the current optimality conditions.\noptimality_tolerance is the dual feasibility tolerance, this should preferably match the tolerance used by the solver. The default tolerance should however apply in most situations (c.f. \"Computational Techniques of the Simplex Method\" by Istv√°n Maros, section 9.3.4).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.lp_rhs_perturbation_range","page":"Solutions","title":"JuMP.lp_rhs_perturbation_range","text":"lp_rhs_perturbation_range(constraint::ConstraintRef;\n                          feasibility_tolerance::Float64)\n                          ::Tuple{Float64, Float64}\n\nGives the range by which the rhs coefficient can change and the current LP basis remains feasible, i.e., where the shadow prices apply.\n\nNotes\n\nThe rhs coefficient is the value right of the relation, i.e., b for the constraint when of the form a*x ‚ñ° b, where ‚ñ° is ‚â§, =, or ‚â•.\nThe range denotes valid changes, e.g., for a*x <= b + Œî, the LP basis remains feasible for all Œî ‚àà [l, u].\nfeasibility_tolerance is the primal feasibility tolerance, this should preferably match the tolerance used by the solver. The default tolerance should however apply in most situations (c.f. \"Computational Techniques of the Simplex Method\" by Istv√°n Maros, section 9.3.4).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#Feasibility","page":"Solutions","title":"Feasibility","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"primal_feasibility_report","category":"page"},{"location":"reference/solutions/#JuMP.primal_feasibility_report","page":"Solutions","title":"JuMP.primal_feasibility_report","text":"primal_feasibility_report(\n    model::Model,\n    point::AbstractDict{VariableRef,Float64} = _last_primal_solution(model),\n    atol::Float64 = 0.0,\n    skip_missing::Bool = false,\n)::Dict{Any,Float64}\n\nGiven a dictionary point, which maps variables to primal values, return a dictionary whose keys are the constraints with an infeasibility greater than the supplied tolerance atol. The value corresponding to each key is the respective infeasibility. Infeasibility is defined as the distance between the primal value of the constraint (see MOI.ConstraintPrimal) and the nearest point by Euclidean distance in the corresponding set.\n\nNotes\n\nIf skip_missing = true, constraints containing variables that are not in point will be ignored.\nIf skip_missing = false and a partial primal solution is provided, an error will be thrown.\nIf no point is provided, the primal solution from the last time the model was solved is used.\n\nExamples\n\njulia> model = Model();\n\njulia> @variable(model, 0.5 <= x <= 1);\n\njulia> primal_feasibility_report(model, Dict(x => 0.2))\nDict{Any,Float64} with 1 entry:\n  x ‚â• 0.5 => 0.3\n\n\n\n\n\n","category":"function"},{"location":"tutorials/Mixed-integer linear programs/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/multi.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/multi/#The-multi-commodity-flow-problem","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"JuMP implementation of the multicommodity transportation model AMPL: A Modeling Language for Mathematical Programming, 2nd ed by Robert Fourer, David Gay, and Brian W. Kernighan 4-1.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"Originally contributed by Louis Luangkesorn, February 26, 2015.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_multi(; verbose = true)\n    orig = [\"GARY\", \"CLEV\", \"PITT\"]\n    dest = [\"FRA\", \"DET\", \"LAN\", \"WIN\", \"STL\", \"FRE\", \"LAF\"]\n    prod = [\"bands\", \"coils\", \"plate\"]\n    numorig = length(orig)\n    numdest = length(dest)\n    numprod = length(prod)\n    # supply(prod, orig) amounts available at origins\n    supply = [\n        400    700    800;\n        800   1600   1800;\n        200    300    300\n    ]\n    # demand(prod, dest) amounts required at destinations\n    demand = [\n        300   300   100    75   650   225   250;\n        500   750   400   250   950   850   500;\n        100   100     0    50   200   100   250\n    ]\n    # limit(orig, dest) of total units from any origin to destination\n    limit = [625.0 for j in 1:numorig, i in 1:numdest]\n    # cost(dest, orig, prod) Shipment cost per unit\n    cost = reshape([\n        [\n            [  30,   10,    8,   10,   11,   71,    6];\n            [  22,    7,   10,    7,   21,   82,   13];\n            [  19,   11,   12,   10,   25,   83,   15]\n        ];\n        [\n            [  39,   14,   11,   14,   16,   82,    8];\n            [  27,    9,   12,    9,   26,   95,   17];\n            [  24,   14,   17,   13,   28,   99,   20]\n        ];\n        [\n            [  41,   15,   12,   16,   17,   86,    8];\n            [  29,    9,   13,    9,   28,   99,   18];\n            [  26,   14,   17,   13,   31,  104,   20]\n        ]\n    ], 7, 3, 3)\n    # DECLARE MODEL\n    multi = Model(GLPK.Optimizer)\n    # VARIABLES\n    @variable(multi, trans[1:numorig, 1:numdest, 1:numprod] >= 0)\n    # OBJECTIVE\n    @objective(\n        multi,\n        Max,\n        sum(\n            cost[j, i, p] * trans[i, j, p]\n            for i in 1:numorig, j in 1:numdest, p in 1:numprod\n        )\n    )\n    # CONSTRAINTS\n    # Supply constraint\n    @constraint(\n        multi,\n        supply_con[i in 1:numorig, p in 1:numprod],\n        sum(trans[i, j, p] for j in 1:numdest) == supply[p, i]\n    )\n    # Demand constraint\n    @constraint(\n        multi,\n        demand_con[j in 1:numdest, p in 1:numprod],\n        sum(trans[i, j, p] for i in 1:numorig) == demand[p, j]\n    )\n    # Total shipment constraint\n    @constraint(\n        multi,\n        total_con[i in 1:numorig, j in 1:numdest],\n        sum(trans[i, j, p] for p in 1:numprod) - limit[i, j] <= 0\n    )\n    optimize!(multi)\n    Test.@test termination_status(multi) == MOI.OPTIMAL\n    Test.@test primal_status(multi) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(multi) == 225_700.0\n    if verbose\n        println(\"RESULTS:\")\n        for i in 1:length(orig)\n            for j in 1:length(dest)\n                for p in 1:length(prod)\n                    print(\" $(prod[p]) $(orig[i]) $(dest[j]) = $(value(trans[i, j, p]))\\t\")\n                end\n                println()\n            end\n        end\n    end\n    return\nend\n\n\nexample_multi()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Getting started/getting_started_with_JuMP.jl\"","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/#Getting-started-with-JuMP","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"","category":"section"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"This tutorial is aimed at providing a quick introduction to writing JuMP code. If you're new to Julia, you should start with Getting started with Julia.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/#What-is-JuMP?","page":"Getting started with JuMP","title":"What is JuMP?","text":"","category":"section"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP (\"Julia for Mathematical Programming\") is an open-source modeling language that is embedded in Julia. It allows users to users formulate various classes of optimization problems (linear, mixed-integer, quadratic, conic quadratic, semidefinite, and nonlinear) with easy-to-read code. These problems can then be solved using state-of-the-art open-source and commercial solvers.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP also makes advanced optimization techniques easily accessible from a high-level language.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/#Installation","page":"Getting started with JuMP","title":"Installation","text":"","category":"section"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP is a package for Julia. From Julia, JuMP is installed by using the built-in package manager.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"import Pkg\nPkg.add(\"JuMP\")","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"You also need to include a Julia package which provides an appropriate solver. One such solver is GLPK.Optimizer, which is provided by the GLPK.jl package.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"import Pkg\nPkg.add(\"GLPK\")","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"See Installation Guide for a list of other solvers you can use.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/#An-example","page":"Getting started with JuMP","title":"An example","text":"","category":"section"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Let's try to solve the following linear programming problem by using JuMP and GLPK. We will first look at the complete code to solve the problem and then go through it step by step.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"beginaligned\n min  12x + 20y \n textst  6x + 8y geq 100 \n  7x + 12y geq 120 \n  x geq 0 \n  y in 0 3 \nendaligned","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"using JuMP\nusing GLPK\nmodel = Model(GLPK.Optimizer)\n@variable(model, x >= 0)\n@variable(model, 0 <= y <= 3)\n@objective(model, Min, 12x + 20y)\n@constraint(model, c1, 6x + 8y >= 100)\n@constraint(model, c2, 7x + 12y >= 120)\nprint(model)\noptimize!(model)\n@show termination_status(model)\n@show primal_status(model)\n@show dual_status(model)\n@show objective_value(model)\n@show value(x)\n@show value(y)\n@show shadow_price(c1)\n@show shadow_price(c2)\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/#Step-by-step","page":"Getting started with JuMP","title":"Step-by-step","text":"","category":"section"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Once JuMP is installed, to use JuMP in your programs, we just need to write:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"using JuMP","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We also need to include a Julia package which provides an appropriate solver. We want to use GLPK.Optimizer here which is provided by the GLPK.jl package.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"using GLPK","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"A model object is a container for variables, constraints, solver options, etc. Models are created with the Model function. The model can be created with an optimizer attached with default arguments by calling the constructor with the optimizer type, as follows:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = Model(GLPK.Optimizer)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Variables are modeled using @variable:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, x >= 0)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"They can have lower and upper bounds.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, 0 <= y <= 30)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"The objective is set using @objective:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@objective(model, Min, 12x + 20y)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Constraints are modeled using @constraint. Here c1 and c2 are the names of our constraint.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@constraint(model, c1, 6x + 8y >= 100)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@constraint(model, c2, 7x + 12y >= 120)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"print(model)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"To solve the optimization problem, call the [optimize!] function.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"optimize!(model)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"info: Info\nThe ! after optimize is just part of the name. It's nothing special. Julia has a convention that functions which mutate their arguments should end in !. A common example is push!.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Now let's see what information we can query about the solution.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"termination_status tells us why the solver stopped:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"termination_status(model)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"In this case, the solver found an optimal solution. We should also check primal_status to see if the solver found a primal feasible point:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"primal_status(model)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"and dual_status to see if the solver found a dual feasible point:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"dual_status(model)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Now we know that our solver found an optimal solution, and has a primal and a dual solution to query.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Query the objective value using objective_value:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"objective_value(model)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"The primal solution using value:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"value(x)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"value(y)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"and the dual solution using shadow_price:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"shadow_price(c1)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"shadow_price(c2)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"View this file on Github.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"‚â§|<=\", r\"‚â•|>=\", r\" == | = \", r\" ‚àà | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/callbacks/#callbacks_manual","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"Many mixed-integer (linear, conic, and nonlinear) programming solvers offer the ability to modify the solve process. Examples include changing branching decisions in branch-and-bound, adding custom cutting planes, providing custom heuristics to find feasible solutions, or implementing on-demand separators to add new constraints only when they are violated by the current solution (also known as lazy constraints).","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"While historically this functionality has been limited to solver-specific interfaces, JuMP provides solver-independent support for three types of callbacks:","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"lazy constraints\nuser-cuts\nheuristic solutions","category":"page"},{"location":"manual/callbacks/#Available-solvers","page":"Callbacks","title":"Available solvers","text":"","category":"section"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"Callback support is limited to a few solvers. This includes CPLEX, GLPK, and Gurobi.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"warning: Warning\nWhile JuMP provides a solver-independent way of accessing callbacks, you should not assume that you will see identical behavior when running the same code on different solvers. For example, some solvers may ignore user-cuts for various reasons, while other solvers may add every user-cut. Read the underlying solver's callback documentation to understand details specific to each solver.","category":"page"},{"location":"manual/callbacks/#Things-you-can-and-cannot-do-during-callbacks","page":"Callbacks","title":"Things you can and cannot do during callbacks","text":"","category":"section"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"There is a very limited range of things you can do during a callback. Only use the functions and macros explicitly stated in this page of the documentation, or in the Callbacks example.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"Using any other part of the JuMP API (e.g., adding a constraint with @constraint or modifying a variable bound with set_lower_bound) is undefined behavior, and your solver may throw an error, return an incorrect solution, or result in a segfault that aborts Julia.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"In each of the three solver-independent callbacks, there are two things you may query:","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"callback_node_status returns an MOI.CallbackNodeStatusCode enum indicating if the current primal solution is integer feasible.\ncallback_value returns the current primal solution of a variable.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"If you need to query any other information, use a solver-dependent callback instead. Each solver supporting a solver-dependent callback has information on how to use it in the README of their Github repository.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"If you want to modify the problem in a callback, you must use a lazy constraint.","category":"page"},{"location":"manual/callbacks/#Lazy-constraints","page":"Callbacks","title":"Lazy constraints","text":"","category":"section"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"Lazy constraints are useful when the full set of constraints is too large to explicitly include in the initial formulation. When a MIP solver reaches a new solution, for example with a heuristic or by solving a problem at a node in the branch-and-bound tree, it will give the user the chance to provide constraint(s) that would make the current solution infeasible. For some more information about lazy constraints, see this blog post by Paul Rubin.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"A lazy constraint callback can be set using the following syntax:","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"model = Model(GLPK.Optimizer)\n@variable(model, x <= 10, Int)\n@objective(model, Max, x)\nfunction my_callback_function(cb_data)\n    status = callback_node_status(cb_data, model)\n    if status == MOI.CALLBACK_NODE_STATUS_FRACTIONAL\n        # `callback_value(cb_data, x)` is not integer (to some tolerance).\n        # If, for example, your lazy constraint generator requires an\n        # integer-feasible primal solution, you can add a `return` here.\n        return\n    elseif status == MOI.CALLBACK_NODE_STATUS_INTEGER\n        # `callback_value(cb_data, x)` is integer (to some tolerance).\n    else\n        @assert status == MOI.CALLBACK_NODE_STATUS_UNKNOWN\n        # `callback_value(cb_data, x)` might be fractional or integer.\n    end\n    x_val = callback_value(cb_data, x)\n    if x_val > 2 + 1e-6\n        con = @build_constraint(x <= 2)\n        MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n    end\nend\nMOI.set(model, MOI.LazyConstraintCallback(), my_callback_function)","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"info: Info\nThe lazy constraint callback may be called at fractional or integer nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every primal solution.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"warning: Warning\nOnly add a lazy constraint if your primal solution violates the constraint. Adding the lazy constraint irrespective of feasibility may result in the solver returning an incorrect solution, or lead to a large number of constraints being added, slowing down the solution process.model = Model(GLPK.Optimizer)\n@variable(model, x <= 10, Int)\n@objective(model, Max, x)\nfunction bad_callback_function(cb_data)\n    # Don't do this!\n    con = @build_constraint(x <= 2)\n    MOI.submit(model, MOI.LazyConstraint(cb_data), con)\nend\nfunction good_callback_function(cb_data)\n    if callback_value(x) > 2\n        con = @build_constraint(x <= 2)\n        MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n    end\nend\nMOI.set(model, MOI.LazyConstraintCallback(), good_callback_function)","category":"page"},{"location":"manual/callbacks/#User-cuts","page":"Callbacks","title":"User cuts","text":"","category":"section"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"User cuts, or simply cuts, provide a way for the user to tighten the LP relaxation using problem-specific knowledge that the solver cannot or is unable to infer from the model. Just like with lazy constraints, when a MIP solver reaches a new node in the branch-and-bound tree, it will give the user the chance to provide cuts to make the current relaxed (fractional) solution infeasible in the hopes of obtaining an integer solution. For more details about the difference between user cuts and lazy constraints see the aforementioned blog post.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"A user-cut callback can be set using the following syntax:","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"model = Model(GLPK.Optimizer)\n@variable(model, x <= 10.5, Int)\n@objective(model, Max, x)\nfunction my_callback_function(cb_data)\n    x_val = callback_value(cb_data, x)\n    con = @build_constraint(x <= floor(x_val))\n    MOI.submit(model, MOI.UserCut(cb_data), con)\nend\nMOI.set(model, MOI.UserCutCallback(), my_callback_function)","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"warning: Warning\nYour user cuts should not change the set of integer feasible solutions. Equivalently, your cuts can only remove fractional solutions. If you add a cut that removes an integer solution, the solver may return an incorrect solution.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"info: Info\nThe user-cut callback may be called at fractional nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every fractional primal solution.","category":"page"},{"location":"manual/callbacks/#Heuristic-solutions","page":"Callbacks","title":"Heuristic solutions","text":"","category":"section"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"Integer programming solvers frequently include heuristics that run at the nodes of the branch-and-bound tree. They aim to find integer solutions quicker than plain branch-and-bound would to tighten the bound, allowing us to fathom nodes quicker and to tighten the integrality gap.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"Some heuristics take integer solutions and explore their \"local neighborhood\" (e.g., flipping binary variables, fix some variables and solve a smaller MILP) and others take fractional solutions and attempt to round them in an intelligent way.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"You may want to add a heuristic of your own if you have some special insight into the problem structure that the solver is not aware of, e.g. you can consistently take fractional solutions and intelligently guess integer solutions from them.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"A heuristic solution callback can be set using the following syntax:","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"model = Model(GLPK.Optimizer)\n@variable(model, x <= 10.5, Int)\n@objective(model, Max, x)\nfunction my_callback_function(cb_data)\n    x_val = callback_value(cb_data, x)\n    status = MOI.submit(\n        model, MOI.HeuristicSolution(cb_data), [x], [floor(Int, x_val)]\n    )\n    println(\"I submitted a heuristic solution, and the status was: \", status)\nend\nMOI.set(model, MOI.HeuristicCallback(), my_callback_function)","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"The third argument to submit should be a vector of JuMP variables, and the fourth argument should be a vector of values corresponding to each variable.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"MOI.submit returns an enum that depends on whether the solver accepted the solution. The possible return codes are:","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"MOI.HEURISTIC_SOLUTION_ACCEPTED\nMOI.HEURISTIC_SOLUTION_REJECTED\nMOI.HEURISTIC_SOLUTION_UNKNOWN","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"warning: Warning\nSome solvers may accept partial solutions. Others require a feasible integer solution for every variable. If in doubt, provide a complete solution.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"info: Info\nThe heuristic solution callback may be called at fractional nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every fractional primal solution.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"DocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"manual/expressions/#Expressions","page":"Expressions","title":"Expressions","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"JuMP has three types of expressions: affine, quadratic, and nonlinear. These expressions can be inserted into constraints or into the objective. This is particularly useful if an expression is used in multiple places in the model.","category":"page"},{"location":"manual/expressions/#Affine-expressions","page":"Expressions","title":"Affine expressions","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"There are four ways of constructing an affine expression in JuMP: with the @expression macro, with operator overloading, with the AffExpr constructor, and with add_to_expression!.","category":"page"},{"location":"manual/expressions/#Macros","page":"Expressions","title":"Macros","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"The recommended way to create an affine expression is via the @expression macro.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = @expression(model, 2x + y - 1)\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"This expression can be used in the objective or added to a constraint. For example:","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"@objective(model, Min, 2 * ex - 1)\nobjective_function(model)\n\n# output\n\n4 x + 2 y - 3","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Just like variables and constraints, named expressions can also be created. For example","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x[i = 1:3])\n@expression(model, expr[i = 1:3], i * sum(x[j] for j in i:3))\nexpr\n\n# output\n\n3-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x[1] + x[2] + x[3]\n 2 x[2] + 2 x[3]\n 3 x[3]","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"tip: Tip\nYou can read more about containers in the Containers section.","category":"page"},{"location":"manual/expressions/#Operator-overloading","page":"Expressions","title":"Operator overloading","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Expressions can also be created without macros. However, note that in some cases, this can be much slower that constructing an expression using macros.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = 2x + y - 1\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"manual/expressions/#Constructors","page":"Expressions","title":"Constructors","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"A third way to create an affine expression is by the AffExpr constructor. The first argument is the constant term, and the remaining arguments are variable-coefficient pairs.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = AffExpr(-1.0, x => 2.0, y => 1.0)\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"manual/expressions/#add_to_expression!","page":"Expressions","title":"add_to_expression!","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"The fourth way to create an affine expression is by using add_to_expression!. Compared to the operator overloading method, this approach is faster because it avoids constructing temporary objects. The @expression macro uses add_to_expression! behind-the-scenes.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = AffExpr(-1.0)\nadd_to_expression!(ex, 2.0, x)\nadd_to_expression!(ex, 1.0, y)\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"manual/expressions/#Removing-zero-terms","page":"Expressions","title":"Removing zero terms","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Use drop_zeros! to remove terms from an affine expression with a 0 coefficient.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @expression(model, ex, x + 1 - x)\n0 x + 1\n\njulia> drop_zeros!(ex)\n\njulia> ex\n1","category":"page"},{"location":"manual/expressions/#Coefficients","page":"Expressions","title":"Coefficients","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Use coefficient to return the coefficient associated with a variable in an affine expression.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @expression(model, ex, 2x + 1)\n2 x + 1\n\njulia> coefficient(ex, x)\n2.0\n\njulia> coefficient(ex, y)\n0.0","category":"page"},{"location":"manual/expressions/#Quadratic-expressions","page":"Expressions","title":"Quadratic expressions","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Like affine expressions, there are four ways of constructing a quadratic expression in JuMP: macros, operator overloading, constructors, and add_to_expression!.","category":"page"},{"location":"manual/expressions/#Macros-2","page":"Expressions","title":"Macros","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"The @expression macro can be used to create quadratic expressions by including quadratic terms.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = @expression(model, x^2 + 2 * x * y + y^2 + x + y - 1)\n\n# output\n\nx¬≤ + 2 y*x + y¬≤ + x + y - 1","category":"page"},{"location":"manual/expressions/#Operator-overloading-2","page":"Expressions","title":"Operator overloading","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Operator overloading can also be used to create quadratic expressions. The same performance warning (discussed in the affine expression section) applies.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = x^2 + 2 * x * y + y^2 + x + y - 1\n\n# output\n\nx¬≤ + 2 x*y + y¬≤ + x + y - 1","category":"page"},{"location":"manual/expressions/#Constructors-2","page":"Expressions","title":"Constructors","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Quadratic expressions can also be created using the QuadExpr constructor. The first argument is an affine expression, and the remaining arguments are pairs, where the first term is a JuMP.UnorderedPair and the second term is the coefficient.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\naff_expr = AffExpr(-1.0, x => 1.0, y => 1.0)\nquad_expr = QuadExpr(aff_expr, UnorderedPair(x, x) => 1.0,\n                     UnorderedPair(x, y) => 2.0, UnorderedPair(y, y) => 1.0)\n\n# output\n\nx¬≤ + 2 x*y + y¬≤ + x + y - 1","category":"page"},{"location":"manual/expressions/#add_to_expression!-2","page":"Expressions","title":"add_to_expression!","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Finally, add_to_expression! can also be used to add quadratic terms.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = QuadExpr(x + y - 1.0)\nadd_to_expression!(ex, 1.0, x, x)\nadd_to_expression!(ex, 2.0, x, y)\nadd_to_expression!(ex, 1.0, y, y)\n\n# output\n\nx¬≤ + 2 x*y + y¬≤ + x + y - 1","category":"page"},{"location":"manual/expressions/#Removing-zero-terms-2","page":"Expressions","title":"Removing zero terms","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Use drop_zeros! to remove terms from a quadratic expression with a 0 coefficient.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @expression(model, ex, x^2 + x + 1 - x^2)\n0 x¬≤ + x + 1\n\njulia> drop_zeros!(ex)\n\njulia> ex\nx + 1","category":"page"},{"location":"manual/expressions/#Coefficients-2","page":"Expressions","title":"Coefficients","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Use coefficient to return the coefficient associated with a pair of variables in a quadratic expression.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @expression(model, ex, 2*x*y + 3*x)\n2 x*y + 3 x\n\njulia> coefficient(ex, x, y)\n2.0\n\njulia> coefficient(ex, x, x)\n0.0\n\njulia> coefficient(ex, y, x)\n2.0\n\njulia> coefficient(ex, x)\n3.0","category":"page"},{"location":"manual/expressions/#Nonlinear-expressions","page":"Expressions","title":"Nonlinear expressions","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Nonlinear expressions can be constructed only using the @NLexpression macro and can be used only in @NLobjective, @NLconstraint, and other @NLexpressions. Moreover, quadratic and affine expressions cannot be used in the nonlinear macros. For more details, see the Nonlinear Modeling section.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Getting started/variables_constraints_objective.jl\"","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Variables,-constraints,-and-objective-functions","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"While the last tutorial introduced you to basics of of JuMP code, this tutorial will go in depth focusing on how to work with different parts of a JuMP program.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"using JuMP\nmodel = Model();\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Variable-basics","page":"Variables, constraints, and objective functions","title":"Variable basics","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/#Variable-bounds","page":"Variables, constraints, and objective functions","title":"Variable bounds","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"All of the variables we have created till now have had a bound. We can also create a free variable.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, free_x)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"While creating a variable, instead of using the <= and >= syntax, we can also use the lower_bound and upper_bound keyword arguments.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, keyword_x, lower_bound = 1, upper_bound = 2)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"We can query whether a variable has a bound using the has_lower_bound and has_upper_bound functions. The values of the bound can be obtained using the lower_bound and upper_bound functions.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"has_upper_bound(keyword_x)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"upper_bound(keyword_x)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"Note querying the value of a bound that does not exist will result in an error.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"try #hide\nlower_bound(free_x)\ncatch err; showerror(stderr, err); end  #hide","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"JuMP also allows us to change the bounds on variable. We will learn this in the problem modification tutorial.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#tutorial_variable_container","page":"Variables, constraints, and objective functions","title":"Containers","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"We have already seen how to add a single variable to a model using the @variable macro. Let's now look at more ways to add variables to a JuMP model.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"JuMP provides data structures for adding collections of variables to a model. These data structures are referred to as Containers and are of three types: Arrays, DenseAxisArrays, and SparseAxisArrays.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Arrays","page":"Variables, constraints, and objective functions","title":"Arrays","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"JuMP arrays are created in a similar syntax to Julia arrays with the addition of specifying that the indices start with 1. If we do not tell JuMP that the indices start at 1, it will create a DenseAxisArray instead.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, a[1:2, 1:2])","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"An n-dimensional variable x in R^n having a bound l preceq x preceq u (l u in R^n) is added in the following manner.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"n = 10\nl = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\nu = [10; 11; 12; 13; 14; 15; 16; 17; 18; 19]\n\n@variable(model, l[i] <= x[i = 1:n] <= u[i])","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"Note that while working with Containers, we can also create variable bounds depending upon the indices:","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, y[i = 1:2, j = 1:2] >= 2i + j)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#DenseAxisArrays","page":"Variables, constraints, and objective functions","title":"DenseAxisArrays","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"DenseAxisArrays are used when the required indices are not one-based integer ranges. The syntax is similar except with an arbitrary vector as an index as opposed to a one-based range.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"An example where the indices are integers but do not start with one.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, z[i = 2:3, j = 1:2:3] >= 0)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"Another example where the indices are an arbitrary vector.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, w[1:5,[\"red\", \"blue\"]] <= 1)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#SparseAxisArrays","page":"Variables, constraints, and objective functions","title":"SparseAxisArrays","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"SparseAxisArrays are created when the indices do not form a rectangular set. For example, this applies when indices have a dependence upon previous indices (called triangular indexing).","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, u[i = 1:3, j = i:5])","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"We can also conditionally create variables by adding a comparison check that depends upon the named indices and is separated from the indices by a semi-colon (;).","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, v[i = 1:9; mod(i, 3) == 0])","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Variable-types","page":"Variables, constraints, and objective functions","title":"Variable types","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"The last argument to the @variable macro is usually the variable type. Here we'll look at how to specify the variable type.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Integer-variables","page":"Variables, constraints, and objective functions","title":"Integer variables","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"Integer optimization variables are constrained to the set x in Z","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, integer_x, Int)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"or","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, integer_z, integer = true)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Binary-variables","page":"Variables, constraints, and objective functions","title":"Binary variables","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"Binary optimization variables are constrained to the set x in 0 1.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, binary_x, Bin)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"or","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, binary_z, binary = true)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Semidefinite-variables","page":"Variables, constraints, and objective functions","title":"Semidefinite variables","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"JuMP also supports modeling with semidefinite variables. A square symmetric matrix X is positive semidefinite if all eigenvalues are nonnegative.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, psd_x[1:2, 1:2], PSD)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"We can also impose a weaker constraint that the square matrix is only symmetric (instead of positive semidefinite) as follows:","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, sym_x[1:2, 1:2], Symmetric)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Constraint-basics","page":"Variables, constraints, and objective functions","title":"Constraint basics","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\n@variable(model, z[1:10]);\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Constraint-references","page":"Variables, constraints, and objective functions","title":"Constraint references","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"While calling the @constraint macro, we can also set up a constraint reference. Such a reference is useful for obtaining additional information about the constraint, such as its dual solution.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@constraint(model, con, x <= 4)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#tutorial_constraint_container","page":"Variables, constraints, and objective functions","title":"Containers","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"Just as we had containers for variables, JuMP also provides Arrays, DenseAxisArrays, and SparseAxisArrays for storing collections of constraints. Examples for each container type are given below.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Arrays-2","page":"Variables, constraints, and objective functions","title":"Arrays","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@constraint(model, [i = 1:3], i * x <= i + 1)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#DenseAxisArrays-2","page":"Variables, constraints, and objective functions","title":"DenseAxisArrays","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@constraint(model, [i = 1:2, j = 2:3], i * x <= j + 1)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#SparseAxisArrays-2","page":"Variables, constraints, and objective functions","title":"SparseAxisArrays","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@constraint(model, [i = 1:2, j = 1:2; i != j], i * x <= j + 1)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Constraints-in-a-loop","page":"Variables, constraints, and objective functions","title":"Constraints in a loop","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"We can add constraints using regular Julia loops","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"for i in 1:3\n    @constraint(model, 6x + 4y >= 5i)\nend","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"or use for each loops inside the @constraint macro.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@constraint(model, [i in 1:3], 6x + 4y >= 5i)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"We can also create constraints such as sum _i = 1^10 z_i leq 1","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@constraint(model, sum(z[i] for i in 1:10) <= 1)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Objective-functions","page":"Variables, constraints, and objective functions","title":"Objective functions","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"While the recommended way to set the objective is with the @objective macro, the functions set_objective_sense and set_objective_function provide an equivalent lower-level interface.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"using GLPK\n\nmodel = Model(GLPK.Optimizer)\n@variable(model, x >= 0)\n@variable(model, y >= 0)\nset_objective_sense(model, MOI.MIN_SENSE)\nset_objective_function(model, x + y)\n\noptimize!(model)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"objective_value(model)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"To query the objective function from a model, we use the objective_sense, objective_function, and objective_function_type functions.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"objective_sense(model)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"objective_function(model)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"objective_function_type(model)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Vectorized-syntax","page":"Variables, constraints, and objective functions","title":"Vectorized syntax","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"We can also add constraints and an objective to JuMP using vectorized linear algebra. We'll illustrate this by solving an LP in standard form i.e.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"beginaligned\n min  c^T x \n textst  A x = b \n  x succeq 0 \n  x in mathbbR^n\nendaligned","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"vector_model = Model(GLPK.Optimizer)\n\nA= [ 1 1 9  5;\n     3 5 0  8;\n     2 0 6 13]\n\nb = [7; 3; 5]\n\nc = [1; 3; 5; 2]\n\n@variable(vector_model, x[1:4] >= 0)\n@constraint(vector_model, A * x .== b)\n@objective(vector_model, Min, c' * x)\n\noptimize!(vector_model)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"objective_value(vector_model)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"View this file on Github.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"‚â§|<=\", r\"‚â•|>=\", r\" == | = \", r\" ‚àà | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"background/algebraic_modeling_languages/#algebraic-modeling-language","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/#What-is-an-algebraic-modeling-language?","page":"Algebraic modeling languages","title":"What is an algebraic modeling language?","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"If you have taken a class in mixed-integer linear programming, you will have seen a formulation like:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"beginaligned\nmin       c^top x \ntextst  A x = b  \n             x ge 0  \n             x_i in mathbbZ quad forall i in mathcalI\nendaligned","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"where c, A, and b are appropriately sized vectors and matrices of data, and mathcalI denotes the set of variables that are integer.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Solvers expect problems in a standard form like this because it limits the types of constraints that they need to consider. This makes writing a solver much easier.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"info: What is a solver?\nA solver is a software package that computes solutions to one or more classes of problems.For example, GLPK is a solver for linear programming (LP) and mixed integer programming (MIP) problems. It incorporates algorithms such as the simplex method and the interior-point method.JuMP currently supports a number of open-source and commercial solvers, which can be viewed in the Supported-solvers table.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"However, you probably formulated problems algebraically like so:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"beginaligned\nmin       sumlimits_i = 1^n c_i x_i                   \ntextst  sumlimits_i = 1^n w_i x_i le b             \n             x_i ge 0 quad forall i = 1ldotsn          \n             x_i in mathbbZ quad forall i = 1ldotsn\nendaligned","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"info: Info\nDo you recognize this formulation? It's the knapsack problem.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Users prefer to write problems in algebraic form because it is more convenient. For example, we just used le b, even though the standard form only supported constraints of the form Ax = b.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"We could convert our knapsack problem into the standard form by adding a new slack variable x_0 like so:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"beginaligned\nmin       sumlimits_i = 1^n c_i x_i            \ntextst  x_0 + sumlimits_i = 1^n w_i x_i = b  \n             x_i ge 0 quad forall i = 0ldotsn   \n             x_i in mathbbZ quad forall i = 1ldotsn\nendaligned","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"However, as models get more complicated, this manual conversion becomes more and more error-prone.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"An algebraic modeling language is a tool that simplifies the translation between the algebraic form of the modeler, and the standard form of the solver.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Each algebraic modeling language has two main parts:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"A domain specific language for the user to write down problems in algebraic form.\nA converter from the algebraic form into a standard form supported by the solver (and back again).","category":"page"},{"location":"background/algebraic_modeling_languages/#Part-I:-writing-in-algebraic-form","page":"Algebraic modeling languages","title":"Part I: writing in algebraic form","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"JuMP provides the first part of an algebraic modeling language using the @variable, @objective, and @constraint macros.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"For example, here's how we would write the knapsack problem in JuMP:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"julia> function algebraic_knapsack(c, w, b)\n           n = length(c)\n           model = Model()\n           @variable(model, x[1:n] >= 0, Int)\n           @objective(model, Min, sum(c[i] * x[i] for i = 1:n))\n           @constraint(model, sum(w[i] * x[i] for i = 1:n) <= b)\n           return print(model)\n       end\nalgebraic_knapsack (generic function with 1 method)\n\njulia> algebraic_knapsack([1, 2], [0.5, 0.5], 1.25)\nMin x[1] + 2 x[2]\nSubject to\n 0.5 x[1] + 0.5 x[2] ‚â§ 1.25\n x[1] ‚â• 0.0\n x[2] ‚â• 0.0\n x[1] integer\n x[2] integer","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"This formulation is compact, and it closely matches the algebraic formulation of the model we wrote out above.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Here's what the JuMP code would look like if we didn't use macros:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"julia> function nonalgebraic_knapsack(c, w, b)\n           n = length(c)\n           model = Model()\n           x = [VariableRef(model) for i = 1:n]\n           for i = 1:n\n               set_lower_bound(x[i], 0)\n               set_integer(x[i])\n               set_name(x[i], \"x[$i]\")\n           end\n           obj = AffExpr(0.0)\n           for i = 1:n\n               add_to_expression!(obj, c[i], x[i])\n           end\n           set_objective(model, MOI.MIN_SENSE, obj)\n           lhs = AffExpr(0.0)\n           for i = 1:n\n               add_to_expression!(lhs, w[i], x[i])\n           end\n           con = build_constraint(error, lhs, MOI.LessThan(b))\n           add_constraint(model, con)\n           return print(model)\n       end\nnonalgebraic_knapsack (generic function with 1 method)\n\njulia> nonalgebraic_knapsack([1, 2], [0.5, 0.5], 1.25)\nMin x[1] + 2 x[2]\nSubject to\n 0.5 x[1] + 0.5 x[2] ‚â§ 1.25\n x[1] ‚â• 0.0\n x[2] ‚â• 0.0\n x[1] integer\n x[2] integer","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Hopefully you agree that the macro version is much easier to read!","category":"page"},{"location":"background/algebraic_modeling_languages/#Part-II:-talking-to-solvers","page":"Algebraic modeling languages","title":"Part II: talking to solvers","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Now that we have the algebraic problem from the user, we need a way of communicating the problem to the solver, and a way of returning the solution from the solver back to the user.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"This is less trivial than it might seem, because each solver has a unique application programming interface (API) and data structures for representing optimization models and obtaining results.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"JuMP uses the MathOptInterface.jl package to abstract these differences between solvers.","category":"page"},{"location":"background/algebraic_modeling_languages/#What-is-MathOptInterface?","page":"Algebraic modeling languages","title":"What is MathOptInterface?","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"MathOptInterface (MOI) is an abstraction layer designed to provide an interface to mathematical optimization solvers so that users do not need to understand multiple solver-specific APIs. MOI can be used directly, or through a higher-level modeling interface like JuMP.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"There are three main parts to MathOptInterface:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"A solver-independent API that abstracts concepts such as adding and deleting variables and constraints, setting and getting parameters, and querying results. For more information on the MathOptInterface API, read the documentation\nAn automatic rewriting system based on equivalent formulations of a constraint. For more information on this rewriting system, read the LazyBridgeOptimizer section of the manual, and our paper on arXiv.\nUtilities for managing how and when models are copied to solvers. For more information on this, read the CachingOptimizer section of the manual.","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/standard_form/#Standard-form-problem","page":"Standard form problem","title":"Standard form problem","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"MathOptInterface represents optimization problems in the standard form:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"beginalign\n     min_x in mathbbR^n  f_0(x)\n    \n     textst  f_i(x)  in mathcalS_i  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"where:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"the functions f_0 f_1 ldots f_m are specified by AbstractFunction objects\nthe sets mathcalS_1 ldots mathcalS_m are specified by AbstractSet objects","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"tip: Tip\nFor more information on this standard form, read our paper.","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"MOI defines some commonly used functions and sets, but the interface is extensible to other sets recognized by the solver.","category":"page"},{"location":"moi/manual/standard_form/#Functions","page":"Standard form problem","title":"Functions","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"The function types implemented in MathOptInterface.jl are:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"SingleVariable: x_j, i.e., projection onto a single coordinate defined by a variable index j.\nVectorOfVariables: projection onto multiple coordinates (i.e., extracting a subvector).\nScalarAffineFunction: a^T x + b, where a is a vector and b scalar.\nVectorAffineFunction: A x + b, where A is a matrix and b is a vector.\nScalarQuadraticFunction: frac12 x^T Q x + a^T x + b, where Q is a symmetric matrix, a is a vector, and b is a constant.\nVectorQuadraticFunction: a vector of scalar-valued quadratic functions.","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"Extensions for nonlinear programming are present but not yet well documented.","category":"page"},{"location":"moi/manual/standard_form/#One-dimensional-sets","page":"Standard form problem","title":"One-dimensional sets","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"The one-dimensional set types implemented in MathOptInterface.jl are:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"LessThan(upper):  x in mathbbR  x le mboxupper \nGreaterThan(lower):  x in mathbbR  x ge mboxlower \nEqualTo(value):  x in mathbbR  x = mboxvalue \nInterval(lower, upper):  x in mathbbR  x in mboxlowermboxupper \nInteger(): mathbbZ\nZeroOne():  0 1 \nSemicontinuous(lower,upper):  0 cup lowerupper\nSemiinteger(lower,upper):  0 cup lowerlower+1ldotsupper-1upper","category":"page"},{"location":"moi/manual/standard_form/#Vector-cones","page":"Standard form problem","title":"Vector cones","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"The vector-valued set types implemented in MathOptInterface.jl are:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"Reals(dimension): mathbbR^mboxdimension\nZeros(dimension): 0^mboxdimension\nNonnegatives(dimension):  x in mathbbR^mboxdimension  x ge 0 \nNonpositives(dimension):  x in mathbbR^mboxdimension  x le 0 \nSecondOrderCone(dimension):  (tx) in mathbbR^mboxdimension  t ge lVert x rVert_2 \nRotatedSecondOrderCone(dimension):  (tux) in mathbbR^mboxdimension  2tu ge lVert x rVert_2^2 tu ge 0 \nExponentialCone():  (xyz) in mathbbR^3  y exp (xy) le z y  0 \nDualExponentialCone():  (uvw) in mathbbR^3  -u exp (vu) le exp(1) w u  0 \nGeometricMeanCone(dimension):  (tx) in mathbbR^n+1  x ge 0 t le sqrtnx_1 x_2 cdots x_n  where n is dimension - 1\nPowerCone(exponent):  (xyz) in mathbbR^3  x^mboxexponent y^1-mboxexponent ge z xy ge 0 \nDualPowerCone(exponent):  (uvw) in mathbbR^3  fracumboxexponent^mboxexponentfracv1-mboxexponent^1-mboxexponent ge w uv ge 0 \nNormOneCone(dimension):","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":" (tx) in mathbbR^mboxdimension  t ge lVert x rVert_1 = sum_i lvert x_i rvert ","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"NormInfinityCone(dimension):  (tx) in mathbbR^mboxdimension  t ge lVert x rVert_infty = max_i lvert x_i rvert \nRelativeEntropyCone(dimension):  (u v w) in mathbbR^mboxdimension  u ge sum_i w_i log (fracw_iv_i) v_i ge 0 w_i ge 0 ","category":"page"},{"location":"moi/manual/standard_form/#Matrix-cones","page":"Standard form problem","title":"Matrix cones","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"The matrix-valued set types implemented in MathOptInterface.jl are:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"RootDetConeTriangle(dimension):  (tX) in mathbbR^1+mboxdimension(1+mboxdimension)2  t le det(X)^1mboxdimension X mboxis the upper triangle of a PSD matrix \nRootDetConeSquare(dimension):  (tX) in mathbbR^1+mboxdimension^2  t le det(X)^1mboxdimension X mboxis a PSD matrix \nPositiveSemidefiniteConeTriangle(dimension):  X in mathbbR^mboxdimension(mboxdimension+1)2  X mboxis the upper triangle of a PSD matrix \nPositiveSemidefiniteConeSquare(dimension):  X in mathbbR^mboxdimension^2  X mboxis a PSD matrix \nLogDetConeTriangle(dimension):  (tuX) in mathbbR^2+mboxdimension(1+mboxdimension)2  t le ulog(det(Xu)) X mboxis the upper triangle of a PSD matrix u  0 \nLogDetConeSquare(dimension):  (tuX) in mathbbR^2+mboxdimension^2  t le u log(det(Xu)) X mboxis a PSD matrix u  0 \nNormSpectralCone(row_dim, column_dim):  (t X) in mathbbR^1 + mboxrow_dim times mboxcolumn_dim  t ge sigma_1(X) X mboxis a matrix with row_dim rows and column_dim columns \nNormNuclearCone(row_dim, column_dim):  (t X) in mathbbR^1 + mboxrow_dim times mboxcolumn_dim  t ge sum_i sigma_i(X) X mboxis a matrix with row_dim rows and column_dim columns ","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"Some of these cones can take two forms: XXXConeTriangle and XXXConeSquare.","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"In XXXConeTriangle sets, the matrix is assumed to be symmetric, and the elements are provided by a vector, in which the entries of the upper-right triangular part of the matrix are given column by column (or equivalently, the entries of the lower-left triangular part are given row by row).","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"In XXXConeSquare sets, the entries of the matrix are given column by column (or equivalently, row by row), and the matrix is constrained to be symmetric. As an example, given a 2-by-2 matrix of variables X and a one-dimensional variable t, we can specify a root-det constraint as [t, X11, X12, X22] ‚àà RootDetConeTriangle or [t, X11, X12, X21, X22] ‚àà RootDetConeSquare.","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"We provide both forms to enable flexibility for solvers who may natively support one or the other. Transformations between XXXConeTriangle and XXXConeSquare are handled by bridges, which removes the chance of conversion mistakes by users or solver developers.","category":"page"},{"location":"moi/manual/standard_form/#Multi-dimensional-sets-with-combinatorial-structure","page":"Standard form problem","title":"Multi-dimensional sets with combinatorial structure","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"SOS1(weights): A special ordered set of Type I.\nSOS2(weights): A special ordered set of Type II.\nIndicatorSet(set): A set to specify indicator constraints.\nComplements: A set for mixed complementarity constraints.","category":"page"},{"location":"moi/reference/variables/","page":"Variables","title":"Variables","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/reference/variables/","page":"Variables","title":"Variables","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"moi/reference/variables/#Types","page":"Variables","title":"Types","text":"","category":"section"},{"location":"moi/reference/variables/","page":"Variables","title":"Variables","text":"VariableIndex","category":"page"},{"location":"moi/reference/variables/#MathOptInterface.VariableIndex","page":"Variables","title":"MathOptInterface.VariableIndex","text":"VariableIndex\n\nA type-safe wrapper for Int64 for use in referencing variables in a model. To allow for deletion, indices need not be consecutive.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/variables/#Functions","page":"Variables","title":"Functions","text":"","category":"section"},{"location":"moi/reference/variables/","page":"Variables","title":"Variables","text":"add_variable\nadd_variables\nadd_constrained_variable\nadd_constrained_variables\nsupports_add_constrained_variable\nsupports_add_constrained_variables\nis_valid(::ModelLike,::VariableIndex)\ndelete(::ModelLike, ::VariableIndex)\ndelete(::ModelLike, ::Vector{VariableIndex})","category":"page"},{"location":"moi/reference/variables/#MathOptInterface.add_variable","page":"Variables","title":"MathOptInterface.add_variable","text":"add_variable(model::ModelLike)::VariableIndex\n\nAdd a scalar variable to the model, returning a variable index.\n\nA AddVariableNotAllowed error is thrown if adding variables cannot be done in the current state of the model model.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.add_variables","page":"Variables","title":"MathOptInterface.add_variables","text":"add_variables(model::ModelLike, n::Int)::Vector{VariableIndex}\n\nAdd n scalar variables to the model, returning a vector of variable indices.\n\nA AddVariableNotAllowed error is thrown if adding variables cannot be done in the current state of the model model.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.add_constrained_variable","page":"Variables","title":"MathOptInterface.add_constrained_variable","text":"add_constrained_variable(\n    model::ModelLike,\n    set::AbstractScalarSet\n)::Tuple{MOI.VariableIndex,\n         MOI.ConstraintIndex{MOI.SingleVariable, typeof(set)}}\n\nAdd to model a scalar variable constrained to belong to set, returning the index of the variable created and the index of the constraint constraining the variable to belong to set.\n\nBy default, this function falls back to creating a free variable with add_variable and then constraining it to belong to set with add_constraint.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.add_constrained_variables","page":"Variables","title":"MathOptInterface.add_constrained_variables","text":"add_constrained_variables(\n    model::ModelLike,\n    sets::AbstractVector{<:AbstractScalarSet}\n)::Tuple{Vector{MOI.VariableIndex},\n         Vector{MOI.ConstraintIndex{MOI.SingleVariable, eltype(sets)}}}\n\nAdd to model scalar variables constrained to belong to sets, returning the indices of the variables created and the indices of the constraints constraining the variables to belong to each set in sets. That is, if it returns variables and constraints, constraints[i] is the index of the constraint constraining variable[i] to belong to sets[i].\n\nBy default, this function falls back to calling add_constrained_variable on each set.\n\n\n\n\n\nadd_constrained_variables(\n    model::ModelLike,\n    set::AbstractVectorSet\n)::Tuple{Vector{MOI.VariableIndex},\n         MOI.ConstraintIndex{MOI.VectorOfVariables, typeof(set)}}\n\nAdd to model a vector of variables constrained to belong to set, returning the indices of the variables created and the index of the constraint constraining the vector of variables to belong to set.\n\nBy default, this function falls back to creating free variables with add_variables and then constraining it to belong to set with add_constraint.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.supports_add_constrained_variable","page":"Variables","title":"MathOptInterface.supports_add_constrained_variable","text":"supports_add_constrained_variable(\n    model::ModelLike,\n    S::Type{<:AbstractScalarSet}\n)::Bool\n\nReturn a Bool indicating whether model supports constraining a variable to belong to a set of type S either on creation of the variable with add_constrained_variable or after the variable is created with add_constraint.\n\nBy default, this function falls back to supports_add_constrained_variables(model, Reals) && supports_constraint(model, MOI.SingleVariable, S) which is the correct definition for most models.\n\nExample\n\nSuppose that a solver supports only two kind of variables: binary variables and continuous variables with a lower bound. If the solver decides not to support SingleVariable-in-Binary and SingleVariable-in-GreaterThan constraints, it only has to implement add_constrained_variable for these two sets which prevents the user to add both a binary constraint and a lower bound on the same variable. Moreover, if the user adds a SingleVariable-in-GreaterThan constraint, implementing this interface (i.e., supports_add_constrained_variables) enables the constraint to be transparently bridged into a supported constraint.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.supports_add_constrained_variables","page":"Variables","title":"MathOptInterface.supports_add_constrained_variables","text":"supports_add_constrained_variables(\n    model::ModelLike,\n    S::Type{<:AbstractVectorSet}\n)::Bool\n\nReturn a Bool indicating whether model supports constraining a vector of variables to belong to a set of type S either on creation of the vector of variables with add_constrained_variables or after the variable is created with add_constraint.\n\nBy default, if S is Reals then this function returns true and otherwise, it falls back to supports_add_constrained_variables(model, Reals) && supports_constraint(model, MOI.VectorOfVariables, S) which is the correct definition for most models.\n\nExample\n\nIn the standard conic form (see Duality), the variables are grouped into several cones and the constraints are affine equality constraints. If Reals is not one of the cones supported by the solvers then it needs to implement supports_add_constrained_variables(::Optimizer, ::Type{Reals}) = false as free variables are not supported. The solvers should then implement supports_add_constrained_variables(::Optimizer, ::Type{<:SupportedCones}) = true where SupportedCones is the union of all cone types that are supported; it does not have to implement the method supports_constraint(::Type{VectorOfVariables}, Type{<:SupportedCones}) as it should return false and it's the default. This prevents the user to constrain the same variable in two different cones. When a VectorOfVariables-in-S is added, the variables of the vector have already been created so they already belong to given cones. If bridges are enabled, the constraint will therefore be bridged by adding slack variables in S and equality constraints ensuring that the slack variables are equal to the corresponding variables of the given constraint function.\n\nNote that there may also be sets for which !supports_add_constrained_variables(model, S) and supports_constraint(model, MOI.VectorOfVariables, S). For instance, suppose a solver supports positive semidefinite variable constraints and two types of variables: binary variables and nonnegative variables. Then the solver should support adding VectorOfVariables-in-PositiveSemidefiniteConeTriangle constraints, but it should not support creating variables constrained to belong to the PositiveSemidefiniteConeTriangle because the variables in PositiveSemidefiniteConeTriangle should first be created as either binary or non-negative.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.is_valid-Tuple{MathOptInterface.ModelLike,MathOptInterface.VariableIndex}","page":"Variables","title":"MathOptInterface.is_valid","text":"is_valid(model::ModelLike, index::Index)::Bool\n\nReturn a Bool indicating whether this index refers to a valid object in the model model.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/variables/#MathOptInterface.delete-Tuple{MathOptInterface.ModelLike,MathOptInterface.VariableIndex}","page":"Variables","title":"MathOptInterface.delete","text":"delete(model::ModelLike, index::Index)\n\nDelete the referenced object from the model. Throw DeleteNotAllowed if if index cannot be deleted.\n\nThe following modifications also take effect if Index is VariableIndex:\n\nIf index used in the objective function, it is removed from the function, i.e., it is substituted for zero.\nFor each func-in-set constraint of the model:\nIf func isa SingleVariable and func.variable == index then the constraint is deleted.\nIf func isa VectorOfVariables and index in func.variable then\nif length(func.variable) == 1 is one, the constraint is deleted;\nif length(func.variable) > 1 and supports_dimension_update(set) then then the variable is removed from func and set is replaced by update_dimension(set, MOI.dimension(set) - 1).\nOtherwise, a DeleteNotAllowed error is thrown.\nOtherwise, the variable is removed from func, i.e., it is substituted for zero.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/variables/#MathOptInterface.delete-Tuple{MathOptInterface.ModelLike,Array{MathOptInterface.VariableIndex,1}}","page":"Variables","title":"MathOptInterface.delete","text":"delete(model::ModelLike, indices::Vector{R<:Index}) where {R}\n\nDelete the referenced objects in the vector indices from the model. It may be assumed that R is a concrete type. The default fallback sequentially deletes the individual items in indices, although specialized implementations may be more efficient.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/variables/#Attributes","page":"Variables","title":"Attributes","text":"","category":"section"},{"location":"moi/reference/variables/","page":"Variables","title":"Variables","text":"AbstractVariableAttribute\nVariableName\nVariablePrimalStart\nVariablePrimal","category":"page"},{"location":"moi/reference/variables/#MathOptInterface.AbstractVariableAttribute","page":"Variables","title":"MathOptInterface.AbstractVariableAttribute","text":"AbstractVariableAttribute\n\nAbstract supertype for attribute objects that can be used to set or get attributes (properties) of variables in the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/variables/#MathOptInterface.VariableName","page":"Variables","title":"MathOptInterface.VariableName","text":"VariableName()\n\nA variable attribute for a string identifying the variable. It is valid for two variables to have the same name; however, variables with duplicate names cannot be looked up using get. It has a default value of \"\" if not set`.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/variables/#MathOptInterface.VariablePrimalStart","page":"Variables","title":"MathOptInterface.VariablePrimalStart","text":"VariablePrimalStart()\n\nA variable attribute for the initial assignment to some primal variable's value that the optimizer may use to warm-start the solve. May be a number or nothing (unset).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/variables/#MathOptInterface.VariablePrimal","page":"Variables","title":"MathOptInterface.VariablePrimal","text":"VariablePrimal(N)\nVariablePrimal()\n\nA variable attribute for the assignment to some primal variable's value in result N. If N is omitted, it is 1 by default.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Nonlinear programs/space_shuttle_reentry_trajectory.jl\"","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/#Space-Shuttle-Reentry-Trajectory","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"Originally Contributed by: Henrique Ferrolho","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"This tutorial demonstrates how to compute a reentry trajectory for the Space Shuttle, by formulating and solving a nonlinear programming problem. The problem was drawn from Chapter 6 of \"Practical Methods for Optimal Control and Estimation Using Nonlinear Programming\", by John T. Betts.","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"tip: Tip\nThis tutorial is a more-complicated version of the Rocket Control example. If you are new to solving nonlinear programs in JuMP, you may want to start there instead.","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"The motion of the vehicle is defined by the following set of DAEs:","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"beginaligned\ndoth  = v sin gamma  \ndotphi  = fracvr cos gamma sin psi  cos theta  \ndottheta  = fracvr cos gamma cos psi  \ndotv  = -fracDm - g sin gamma  \ndotgamma  = fracLm v cos(beta) + cos gamma left ( fracvr - fracgv right )  \ndotpsi  = frac1m v cos gamma L sin(beta) + fracvr cos theta cos gamma sin psi sin theta  \nq  le q_U  \nendaligned","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"where the aerodynamic heating on the vehicle wing leading edge is q = q_a q_r and the dynamic variables are","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"beginaligned\n     h  quad textaltitude (ft)     qquad   gamma quad textflight path angle (rad) \n  phi  quad textlongitude (rad)   qquad   psi   quad textazimuth (rad)           \ntheta  quad textlatitude (rad)    qquad   alpha quad textangle of attack (rad)   \n     v  quad textvelocity (ftsec) qquad   beta  quad textbank angle (rad)\nendaligned","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"The aerodynamic and atmospheric forces on the vehicle are specified by the following quantities (English units):","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"beginaligned\n           D  = frac12 c_D S rho v^2                  qquad  a_0  = -020704 \n           L  = frac12 c_L S rho v^2                  qquad  a_1  =  0029244 \n           g  = mu  r^2                                   qquad  mu  =  014076539 times 10^17 \n           r  = R_e + h                                     qquad  b_0  =  007854 \n        rho  = rho_0 exp-hh_r                         qquad  b_1  = -061592  times 10^-2 \n      rho_0  = 0002378                                    qquad  b_2  =  0621408 times 10^-3 \n         h_r  = 23800                                       qquad  q_r  =  17700 sqrtrho (00001 v)^307 \n         c_L  = a_0 + a_1 hatalpha                      qquad  q_a  =  c_0 + c_1 hatalpha + c_2 hatalpha^2 + c_3 hatalpha^3 \n         c_D  = b_0 + b_1 hatalpha + b_2 hatalpha^2 qquad  c_0  =  10672181 \nhatalpha  = 180 alpha  pi                            qquad  c_1  = -019213774 times 10^-1 \n         R_e  = 20902900                                    qquad  c_2  =  021286289 times 10^-3 \n           S  = 2690                                        qquad  c_3  = -010117249 times 10^-5\nendaligned","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"The reentry trajectory begins at an altitude where the aerodynamic forces are quite small with a weight of w = 203000 (lb) and mass m = w  g_0 (slug), where g_0 = 32174 (ft/sec^2). The initial conditions are as follows:","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"beginaligned\n     h  = 260000 text ft  qquad  v       = 25600 text ftsec \n  phi  = 0      text deg qquad  gamma  = -1    text deg    \ntheta  = 0      text deg qquad  psi    = 90    text deg\nendaligned","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"The final point on the reentry trajectory occurs at the unknown (free) time t_F, at the so-called terminal area energy management (TAEM) interface, which is defined by the conditions","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"h = 80000 text ft qquad v = 2500 text ftsec qquad gamma = -5 text deg","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"As explained in the book, our goal is to maximize the final crossrange, which is equivalent to maximizing the final latitude of the vehicle, i.e., J = theta(t_F).","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"(Image: Max crossrange shuttle reentry)","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/#Approach","page":"Space Shuttle Reentry Trajectory","title":"Approach","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"We will use a discretized model of time, with a fixed number of discretized points, n. The decision variables at each point are going to be the state of the vehicle and the controls commanded to it. In addition, we will also make each time step size Delta t a decision variable; that way, we can either fix the time step size easily, or allow the solver to fine-tune the duration between each adjacent pair of points. Finally, in order to approximate the derivatives of the problem dynamics, we will use either rectangular or trapezoidal integration.","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"DisclaimerDo not try to actually land a Space Shuttle using this notebook! üòõ There's no mesh refinement going on, which can lead to unrealistic trajectories having position and velocity errors with orders of magnitude 10^4 ft and 10^2 ft/sec, respectively.","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"using JuMP\nimport Interpolations\nimport Ipopt\n\n# Global variables\nconst w  = 203000.0  # weight (lb)\nconst g‚ÇÄ = 32.174    # acceleration (ft/sec^2)\nconst m  = w / g‚ÇÄ    # mass (slug)\n\n# Aerodynamic and atmospheric forces on the vehicle\nconst œÅ‚ÇÄ =  0.002378\nconst h·µ£ =  23800.0\nconst R‚Çë =  20902900.0\nconst Œº  =  0.14076539e17\nconst S  =  2690.0\nconst a‚ÇÄ = -0.20704\nconst a‚ÇÅ =  0.029244\nconst b‚ÇÄ =  0.07854\nconst b‚ÇÅ = -0.61592e-2\nconst b‚ÇÇ =  0.621408e-3\nconst c‚ÇÄ =  1.0672181\nconst c‚ÇÅ = -0.19213774e-1\nconst c‚ÇÇ =  0.21286289e-3\nconst c‚ÇÉ = -0.10117249e-5\n\n# Initial conditions\nconst h_s = 2.6          # altitude (ft) / 1e5\nconst œï_s = deg2rad(0)   # longitude (rad)\nconst Œ∏_s = deg2rad(0)   # latitude (rad)\nconst v_s = 2.56         # velocity (ft/sec) / 1e4\nconst Œ≥_s = deg2rad(-1)  # flight path angle (rad)\nconst œà_s = deg2rad(90)  # azimuth (rad)\nconst Œ±_s = deg2rad(0)   # angle of attack (rad)\nconst Œ≤_s = deg2rad(0)   # bank angle (rad)\nconst t_s = 1.00         # time step (sec)\n\n# Final conditions, the so-called Terminal Area Energy Management (TAEM)\nconst h_t = 0.8          # altitude (ft) / 1e5\nconst v_t = 0.25         # velocity (ft/sec) / 1e4\nconst Œ≥_t = deg2rad(-5)  # flight path angle (rad)\n\n# Number of mesh points (knots) to be used\nconst n = 503\n\n# Integration scheme to be used for the dynamics\nconst integration_rule = \"rectangular\"\nnothing #hide","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"tip: Choose a good linear solver\nPicking a good linear solver is extremely important to maximize the performance of nonlinear solvers. For the best results, it is advised to experiment different linear solvers.For example, the linear solver MA27 is outdated and can be quite slow. MA57 is a much better alternative, especially for highly-sparse problems (such as trajectory optimization problems).","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"# Uncomment the lines below to pass user options to the solver\nuser_options = (\n    # \"mu_strategy\" => \"monotone\",\n    # \"linear_solver\" => \"ma27\",\n)\n\n# Create JuMP model, using Ipopt as the solver\nmodel = Model(optimizer_with_attributes(Ipopt.Optimizer, user_options...))\n\n@variables(model, begin\n               0 ‚â§ scaled_h[1:n]                # altitude (ft) / 1e5\n                          œï[1:n]                # longitude (rad)\n    deg2rad(-89) ‚â§        Œ∏[1:n] ‚â§ deg2rad(89)  # latitude (rad)\n            1e-4 ‚â§ scaled_v[1:n]                # velocity (ft/sec) / 1e4\n    deg2rad(-89) ‚â§        Œ≥[1:n] ‚â§ deg2rad(89)  # flight path angle (rad)\n                          œà[1:n]                # azimuth (rad)\n    deg2rad(-90) ‚â§        Œ±[1:n] ‚â§ deg2rad(90)  # angle of attack (rad)\n    deg2rad(-89) ‚â§        Œ≤[1:n] ‚â§ deg2rad( 1)  # bank angle (rad)\n    #        3.5 ‚â§       Œît[1:n] ‚â§ 4.5          # time step (sec)\n                         Œît[1:n] == 4.0         # time step (sec)\nend)","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"info: Info\nAbove you can find two alternatives for the Œît variables.The first one, 3.5 ‚â§ Œît[1:n] ‚â§ 4.5 (currently commented), allows some wiggle room for the solver to adjust the time step size between pairs of mesh points. This is neat because it allows the solver to figure out which parts of the flight require more dense discretization than others. (Remember, the number of discretized points is fixed, and this example does not implement mesh refinement.) However, this makes the problem more complex to solve, and therefore leads to a longer computation time.The second line, Œît[1:n] == 4.0, fixes the duration of every time step to exactly 4.0 seconds. This allows the problem to be solved faster. However, to do this we need to know beforehand that the close-to-optimal total duration of the flight is ~2009 seconds. Therefore, if we split the total duration in slices of 4.0 seconds, we know that we require n = 503 knots to discretize the whole trajectory.","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"# Fix initial conditions\nfix(scaled_h[1], h_s; force=true)\nfix(       œï[1], œï_s; force=true)\nfix(       Œ∏[1], Œ∏_s; force=true)\nfix(scaled_v[1], v_s; force=true)\nfix(       Œ≥[1], Œ≥_s; force=true)\nfix(       œà[1], œà_s; force=true)\n\n# Fix final conditions\nfix(scaled_h[n], h_t; force=true)\nfix(scaled_v[n], v_t; force=true)\nfix(       Œ≥[n], Œ≥_t; force=true)\n\n# Initial guess: linear interpolation between boundary conditions\nx_s = [h_s, œï_s, Œ∏_s, v_s, Œ≥_s, œà_s, Œ±_s, Œ≤_s, t_s]\nx_t = [h_t, œï_s, Œ∏_s, v_t, Œ≥_t, œà_s, Œ±_s, Œ≤_s, t_s]\ninterp_linear = Interpolations.LinearInterpolation([1, n], [x_s, x_t])\ninitial_guess = mapreduce(transpose, vcat, interp_linear.(1:n))\nset_start_value.(all_variables(model), vec(initial_guess))\n\n# Functions to restore `h` and `v` to their true scale\n@NLexpression(model, h[j = 1:n], scaled_h[j] * 1e5)\n@NLexpression(model, v[j = 1:n], scaled_v[j] * 1e4)\n\n# Helper functions\n@NLexpression(model, c_L[j = 1:n], a‚ÇÄ + a‚ÇÅ * rad2deg(Œ±[j]))\n@NLexpression(model, c_D[j = 1:n], b‚ÇÄ + b‚ÇÅ * rad2deg(Œ±[j]) + b‚ÇÇ * rad2deg(Œ±[j])^2)\n@NLexpression(model,   œÅ[j = 1:n], œÅ‚ÇÄ * exp(-h[j] / h·µ£))\n@NLexpression(model,   D[j = 1:n], 0.5 * c_D[j] * S * œÅ[j] * v[j]^2)\n@NLexpression(model,   L[j = 1:n], 0.5 * c_L[j] * S * œÅ[j] * v[j]^2)\n@NLexpression(model,   r[j = 1:n], R‚Çë + h[j])\n@NLexpression(model,   g[j = 1:n], Œº / r[j]^2)\n\n# Motion of the vehicle as a differential-algebraic system of equations (DAEs)\n@NLexpression(model, Œ¥h[j = 1:n], v[j] * sin(Œ≥[j]))\n@NLexpression(model, Œ¥œï[j = 1:n], (v[j] / r[j]) * cos(Œ≥[j]) * sin(œà[j]) / cos(Œ∏[j]))\n@NLexpression(model, Œ¥Œ∏[j = 1:n], (v[j] / r[j]) * cos(Œ≥[j]) * cos(œà[j]))\n@NLexpression(model, Œ¥v[j = 1:n], -(D[j] / m) - g[j] * sin(Œ≥[j]))\n@NLexpression(model, Œ¥Œ≥[j = 1:n], (L[j] / (m * v[j])) * cos(Œ≤[j]) + cos(Œ≥[j]) * ((v[j] / r[j]) - (g[j] / v[j])))\n@NLexpression(model, Œ¥œà[j = 1:n], (1 / (m * v[j] * cos(Œ≥[j]))) * L[j] * sin(Œ≤[j]) + (v[j] / (r[j] * cos(Œ∏[j]))) * cos(Œ≥[j]) * sin(œà[j]) * sin(Œ∏[j]))\n\n# System dynamics\nfor j in 2:n\n    i = j - 1  # index of previous knot\n\n    if integration_rule == \"rectangular\"\n        # Rectangular integration\n        @NLconstraint(model, h[j] == h[i] + Œît[i] * Œ¥h[i])\n        @NLconstraint(model, œï[j] == œï[i] + Œît[i] * Œ¥œï[i])\n        @NLconstraint(model, Œ∏[j] == Œ∏[i] + Œît[i] * Œ¥Œ∏[i])\n        @NLconstraint(model, v[j] == v[i] + Œît[i] * Œ¥v[i])\n        @NLconstraint(model, Œ≥[j] == Œ≥[i] + Œît[i] * Œ¥Œ≥[i])\n        @NLconstraint(model, œà[j] == œà[i] + Œît[i] * Œ¥œà[i])\n    elseif integration_rule == \"trapezoidal\"\n        # Trapezoidal integration\n        @NLconstraint(model, h[j] == h[i] + 0.5 * Œît[i] * (Œ¥h[j] + Œ¥h[i]))\n        @NLconstraint(model, œï[j] == œï[i] + 0.5 * Œît[i] * (Œ¥œï[j] + Œ¥œï[i]))\n        @NLconstraint(model, Œ∏[j] == Œ∏[i] + 0.5 * Œît[i] * (Œ¥Œ∏[j] + Œ¥Œ∏[i]))\n        @NLconstraint(model, v[j] == v[i] + 0.5 * Œît[i] * (Œ¥v[j] + Œ¥v[i]))\n        @NLconstraint(model, Œ≥[j] == Œ≥[i] + 0.5 * Œît[i] * (Œ¥Œ≥[j] + Œ¥Œ≥[i]))\n        @NLconstraint(model, œà[j] == œà[i] + 0.5 * Œît[i] * (Œ¥œà[j] + Œ¥œà[i]))\n    else\n        @error \"Unexpected integration rule '$(integration_rule)'\"\n    end\nend\n\n# Objective: Maximize crossrange\n@objective(model, Max, Œ∏[n])\n\nset_silent(model)  # Hide solver's verbose output\noptimize!(model)  # Solve for the control and state\n@assert termination_status(model) == MOI.LOCALLY_SOLVED\n\n# Show final crossrange of the solution\nprintln(\"Final latitude Œ∏ = \", round(objective_value(model) |> rad2deg, digits = 2), \"¬∞\")","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/#Plotting-the-results","page":"Space Shuttle Reentry Trajectory","title":"Plotting the results","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"using Plots","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"ts = cumsum([0; value.(Œît)])[1:end-1]\nnothing #hide","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"plt_altitude = plot(ts, value.(scaled_h), legend = nothing, title = \"Altitude (100,000 ft)\")\nplt_longitude = plot(ts, rad2deg.(value.(œï)), legend = nothing, title = \"Longitude (deg)\")\nplt_latitude = plot(ts, rad2deg.(value.(Œ∏)), legend = nothing, title = \"Latitude (deg)\")\nplt_velocity = plot(ts, value.(scaled_v), legend = nothing, title = \"Velocity (1000 ft/sec)\")\nplt_flight_path = plot(ts, rad2deg.(value.(Œ≥)), legend = nothing, title = \"Flight Path (deg)\")\nplt_azimuth = plot(ts, rad2deg.(value.(œà)), legend = nothing, title = \"Azimuth (deg)\")\n\nplt = plot(plt_altitude,  plt_velocity, plt_longitude, plt_flight_path, plt_latitude,\n           plt_azimuth, layout=grid(3, 2), linewidth=2, size=(700, 700))","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"function q(h, v, a)\n    œÅ(h) = œÅ‚ÇÄ * exp(-h / h·µ£)\n    q·µ£(h, v) = 17700 * ‚àöœÅ(h) * (0.0001 * v)^3.07\n    q‚Çê(a) = c‚ÇÄ + c‚ÇÅ * rad2deg(a) + c‚ÇÇ * rad2deg(a)^2 + c‚ÇÉ * rad2deg(a)^3\n    # Aerodynamic heating on the vehicle wing leading edge\n    q‚Çê(a) * q·µ£(h, v)\nend\n\nplt_attack_angle = plot(ts[1:end-1], rad2deg.(value.(Œ±)[1:end-1]), legend=nothing, title=\"Angle of Attack (deg)\")\nplt_bank_angle = plot(ts[1:end-1], rad2deg.(value.(Œ≤)[1:end-1]), legend=nothing, title=\"Bank Angle (deg)\")\nplt_heating = plot(ts, q.(value.(scaled_h)*1e5, value.(scaled_v)*1e4, value.(Œ±)), legend=nothing, title=\"Heating (BTU/ft/ft/sec)\")\n\nplt = plot(plt_attack_angle, plt_bank_angle, plt_heating, layout=grid(3, 1), linewidth=2, size=(700, 700))","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"plt = plot(rad2deg.(value.(œï)), rad2deg.(value.(Œ∏)), value.(scaled_h),\n           linewidth=2, legend=nothing, title=\"Space Shuttle Reentry Trajectory\",\n           xlabel=\"Longitude (deg)\", ylabel=\"Latitude (deg)\", zlabel=\"Altitude (100,000 ft)\")","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"View this file on Github.","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/callbacks/#CallbackAPI","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"More information can be found in the Callbacks section of the manual.","category":"page"},{"location":"reference/callbacks/#Macros","page":"Callbacks","title":"Macros","text":"","category":"section"},{"location":"reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"@build_constraint","category":"page"},{"location":"reference/callbacks/#JuMP.@build_constraint","page":"Callbacks","title":"JuMP.@build_constraint","text":"@build_constraint(constraint_expr)\n\nConstructs a ScalarConstraint or VectorConstraint using the same machinery as @constraint but without adding the constraint to a model.\n\nConstraints using broadcast operators like x .<= 1 are also supported and will create arrays of ScalarConstraint or VectorConstraint.\n\nExamples\n\nmodel = Model();\n@variable(model, x);\n@build_constraint(2x >= 1)\n\n# output\nScalarConstraint{GenericAffExpr{Float64,VariableRef},MathOptInterface.GreaterThan{Float64}}(2 x, MathOptInterface.GreaterThan{Float64}(1.0))\n\n\n\n\n\n","category":"macro"},{"location":"reference/callbacks/#Callback-variable-primal","page":"Callbacks","title":"Callback variable primal","text":"","category":"section"},{"location":"reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"callback_value","category":"page"},{"location":"reference/callbacks/#JuMP.callback_value","page":"Callbacks","title":"JuMP.callback_value","text":"callback_value(cb_data, x::VariableRef)\n\nReturn the primal solution of a variable inside a callback.\n\ncb_data is the argument to the callback function, and the type is dependent on the solver.\n\n\n\n\n\ncallback_value(cb_data, expr::Union{GenericAffExpr, GenericQuadExpr})\n\nReturn the primal solution of an affine or quadratic expression inside a callback by getting the value for each variable appearing in the expression.\n\ncb_data is the argument to the callback function, and the type is dependent on the solver.\n\n\n\n\n\n","category":"function"},{"location":"reference/callbacks/#Callback-node-status","page":"Callbacks","title":"Callback node status","text":"","category":"section"},{"location":"reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"callback_node_status","category":"page"},{"location":"reference/callbacks/#JuMP.callback_node_status","page":"Callbacks","title":"JuMP.callback_node_status","text":"callback_node_status(cb_data, model::Model)\n\nReturn an MOI.CallbackNodeStatusCode enum, indicating if the current primal solution available from callback_value is integer feasible.\n\n\n\n\n\n","category":"function"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"‚â§|<=\", r\"‚â•|>=\", r\" == | = \", r\" ‚àà | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/constraints/#jump_constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"This page explains how to write various types of constraints in JuMP. Before reading further, please make sure you are familiar with JuMP models, and JuMP Variables. For nonlinear constraints, see Nonlinear Modeling instead.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP is based on the MathOptInterface (MOI) API. Because of this, JuMP thinks of a constraint as the restriction that the output of a function belongs to a set. For example, instead of representing a constraint a^top x le b as a less-than-or-equal-to constraint, JuMP models this as the scalar affine function a^top x belonging to the less-than set (-infty b. Thus, instead of a less-than-or-equal-to constraint, we consider this constraint to be a scalar affine -in- less than constraint. More generally, we use the shorthand function-in-set to refer to constraints composed of different types of functions and sets. In the rest of this page, we will introduce the different types of functions and sets that JuMP knows about as needed. You can read more details about this function-in-set concept in the MOI documentation.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nThe examples use MOI as an alias for the MathOptInterface module. This alias is defined by using JuMP. You may also define it in your code byimport MathOptInterface\nconst MOI = MathOptInterface","category":"page"},{"location":"manual/constraints/#The-@constraint-macro","page":"Constraints","title":"The @constraint macro","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Constraints are added to a JuMP model using the @constraint macro. Here is an example of how to add the constraint 2x le 1 to a JuMP model:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Wasn't that easy! Let's unpack what happened, because just like @variable there are a few subtle things going on.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The mathematical constraint 2x le 1 was added to the model.\nA Julia variable called con was created that is a reference to the constraint.\nThis Julia variable was stored in model and can be accessed by model[:con].\nJuMP set the name attribute (the one that is shown when printing) of the constraint to \"con\".","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Just like the Julia variables created in @variable, con can be bound to a different value. For example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> con\ncon : 2 x <= 1.0\n\njulia> con = 1\n1\n\njulia> con\n1","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"However, the reference can be retrieved by querying the model using the symbolic name:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> con = model[:con]\ncon : 2 x <= 1.0\n\njulia> con\ncon : 2 x <= 1.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Because the named variables and constraints are stored in the same namespace, creating a constraint with the same name as a variable or an existing constraint will result in an error. To overcome this limitation, it is possible to create anonymous constraints, just like it is possible to create Anonymous JuMP variables. This is done by dropping the second argument to @constraint:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> con = @constraint(model, 2x <= 1)\n2 x <= 1.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"It is also possible use different comparison operators (e.g., >= and ==) to create the following types of constraints:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, 2x >= 1)\n2 x >= 1.0\n\njulia> @constraint(model, 2x == 1)\n2 x = 1.0\n\njulia> @constraint(model, 1 <= 2x <= 3)\n2 x ‚àà [1.0, 3.0]","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note that JuMP normalizes the constraints by moving all of the terms containing variables to the left-hand side, and all of the constant terms to the right-hand side. Thus, we get:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, 2x + 1 <= 4x + 4)\n-2 x <= 3.0","category":"page"},{"location":"manual/constraints/#The-@constraints-macro","page":"Constraints","title":"The @constraints macro","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Like @variables, there is a \"plural\" version of the @constraint macro:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraints(model, begin\n           2x <=  1\n            x >= -1\n       end)\n\njulia> print(model)\nFeasibility\nSubject to\n x ‚â• -1.0\n 2 x ‚â§ 1.0","category":"page"},{"location":"manual/constraints/#constraint_duality","page":"Constraints","title":"Duality","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP adopts the notion of conic duality from MOI. For linear programs, a feasible dual on a >= constraint is nonnegative and a feasible dual on a <= constraint is nonpositive. If the constraint is an equality constraint, it depends on which direction is binding.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nJuMP's definition of duality is independent of the objective sense. That is, the sign of feasible duals associated with a constraint depends on the direction of the constraint and not whether the problem is maximization or minimization. This is a different convention from linear programming duality in some common textbooks. If you have a linear program, and you want the textbook definition, you probably want to use shadow_price and reduced_cost instead.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The dual value associated with a constraint in the most recent solution can be accessed using the dual function. You can use the has_duals function to check whether the model has a dual solution available to query. For example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x <= 1)\ncon : x <= 1.0\n\njulia> has_duals(model)\nfalse","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"DocTestSetup = quote\n    using JuMP\n    model = Model(() -> MOIU.MockOptimizer(\n                            MOIU.Model{Float64}(),\n                            eval_objective_value = false,\n                            eval_variable_constraint_dual = false));\n    @variable(model, x);\n    @constraint(model, con, x <= 1);\n    @objective(model, Max, -2x);\n    optimize!(model);\n    mock = backend(model).optimizer.model;\n    MOI.set(mock, MOI.TerminationStatus(), MOI.OPTIMAL)\n    MOI.set(mock, MOI.DualStatus(), MOI.FEASIBLE_POINT)\n    MOI.set(mock, MOI.ConstraintDual(), optimizer_index(con), -2.0)\nend","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @objective(model, Min, -2x)\n-2 x\n\njulia> optimize!(model)\n\njulia> has_duals(model)\ntrue\n\njulia> dual(con)\n-2.0\n\njulia> @objective(model, Max, 2x)\n2 x\n\njulia> optimize!(model)\n\njulia> dual(con)\n-2.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To help users who may be less familiar with conic duality, JuMP provides the shadow_price function which returns a value that can be interpreted as the improvement in the objective in response to an infinitesimal relaxation (on the scale of one unit) in the right-hand side of the constraint. shadow_price can be used only on linear constraints with a <=, >=, or == comparison operator.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In the example above, dual(con) returned -2.0 regardless of the optimization sense. However, in the second case when the optimization sense is Max, shadow_price returns:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> shadow_price(con)\n2.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To query the dual variables associated with a variable bound, first obtain a constraint reference using one of UpperBoundRef, LowerBoundRef, or FixRef, and then call dual on the returned constraint reference. The reduced_cost function may simplify this process as it returns the shadow price of an active bound of a variable (or zero, if no active bound exists).","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"DocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"manual/constraints/#Constraint-names","page":"Constraints","title":"Constraint names","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The name, i.e. the value of the MOI.ConstraintName attribute, of a constraint can be obtained by name(::JuMP.ConstraintRef) and set by set_name(::JuMP.ConstraintRef, ::String).","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The constraint can also be retrieved from its name using constraint_by_name.","category":"page"},{"location":"manual/constraints/#Start-Values","page":"Constraints","title":"Start Values","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Provide a starting value (also called warmstart) for a constraint's dual using set_dual_start_value.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The start value of a constraint's dual can be queried using dual_start_value. If no start value has been set, dual_start_value will return nothing.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x >= 10)\ncon : x ‚â• 10.0\n\njulia> dual_start_value(con)\n\njulia> set_dual_start_value(con, 2)\n\njulia> dual_start_value(con)\n2.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A vector constraint will require a vector warmstart:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, con, x in SecondOrderCone())\ncon : [x[1], x[2], x[3]] in MathOptInterface.SecondOrderCone(3)\n\njulia> dual_start_value(con)\n\njulia> set_dual_start_value(con, [1.0, 2.0, 3.0])\n\njulia> dual_start_value(con)\n3-element Array{Float64,1}:\n 1.0\n 2.0\n 3.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To take the dual solution from the last solve and use it as the starting point for a new solve, use:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"for (F, S) in list_of_constraint_types(model)\n    for con in all_constraints(model, F, S)\n        set_dual_start_value(con, dual(con))\n    end\nend","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nSome constraints might not have well defined duals, hence one might need to filter (F, S) pairs.","category":"page"},{"location":"manual/constraints/#Constraint-containers","page":"Constraints","title":"Constraint containers","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"So far, we've added constraints one-by-one. However, just like Variable containers, JuMP provides a mechanism for building groups of constraints compactly. References to these groups of constraints are returned in containers. Three types of constraint containers are supported: Arrays, DenseAxisArrays, and SparseAxisArrays. We explain each of these in the following.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"tip: Tip\nYou can read more about containers in the Containers section.","category":"page"},{"location":"manual/constraints/#constraint_arrays","page":"Constraints","title":"Arrays","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"One way of adding a group of constraints compactly is the following:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con[i = 1:3], i * x <= i + 1)\n3-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n con[1] : x <= 2.0\n con[2] : 2 x <= 3.0\n con[3] : 3 x <= 4.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP returns references to the three constraints in an Array that is bound to the Julia variable con. This array can be accessed and sliced as you would with any Julia array:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> con[1]\ncon[1] : x <= 2.0\n\njulia> con[2:3]\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n con[2] : 2 x <= 3.0\n con[3] : 3 x <= 4.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Anonymous containers can also be constructed by dropping the name (e.g. con) before the square brackets:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, [i = 1:2], i * x <= i + 1)\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n x <= 2.0\n 2 x <= 3.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Just like @variable, JuMP will form an Array of constraints when it can determine at parse time that the indices are one-based integer ranges. Therefore con[1:b] will create an Array, but con[a:b] will not. A special case is con[Base.OneTo(n)] which will produce an Array. If JuMP cannot determine that the indices are one-based integer ranges (e.g., in the case of con[a:b]), JuMP will create a DenseAxisArray instead.","category":"page"},{"location":"manual/constraints/#DenseAxisArrays","page":"Constraints","title":"DenseAxisArrays","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The syntax for constructing a DenseAxisArray of constraints is very similar to the syntax for constructing a DenseAxisArray of variables.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con[i = 1:2, j = 2:3], i * x <= j + 1)\n2-dimensional DenseAxisArray{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, 2:3\nAnd data, a 2√ó2 Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},2}:\n con[1,2] : x <= 3.0    con[1,3] : x <= 4.0\n con[2,2] : 2 x <= 3.0  con[2,3] : 2 x <= 4.0","category":"page"},{"location":"manual/constraints/#SparseAxisArrays","page":"Constraints","title":"SparseAxisArrays","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The syntax for constructing a SparseAxisArray of constraints is very similar to the syntax for constructing a SparseAxisArray of variables.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con[i = 1:2, j = 1:2; i != j], i * x <= j + 1)\nJuMP.Containers.SparseAxisArray{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},2,Tuple{Int64,Int64}} with 2 entries:\n  [1, 2]  =  con[1,2] : x <= 3.0\n  [2, 1]  =  con[2,1] : 2 x <= 2.0","category":"page"},{"location":"manual/constraints/#Forcing-the-container-type","page":"Constraints","title":"Forcing the container type","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"When creating a container of constraints, JuMP will attempt to choose the tightest container type that can store the constraints. However, because this happens at parse time, it does not always make the best choice. Just like in @variable, we can force the type of container using the container keyword. For syntax and the reason behind this, take a look at the variable docs.","category":"page"},{"location":"manual/constraints/#Vectorized-constraints","page":"Constraints","title":"Vectorized constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"We can also add constraints to JuMP using vectorized linear algebra. For example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[i=1:2])\n2-element Array{VariableRef,1}:\n x[1]\n x[2]\n\njulia> A = [1 2; 3 4]\n2√ó2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> b = [5, 6]\n2-element Array{Int64,1}:\n 5\n 6\n\njulia> @constraint(model, con, A * x .== b)\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}},ScalarShape},1}:\n x[1] + 2 x[2] == 5.0\n 3 x[1] + 4 x[2] == 6.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nMake sure to use Julia's dot syntax in front of the comparison operators (e.g. .==, .>=, and .<=). If you use a comparison without the dot, an error will be thrown.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Instead of adding an array of ScalarAffineFunction-in-EqualTo constraints, we can instead construct a VectorAffineFunction-in-Nonnegatives constraint as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, A * x - b in MOI.Nonnegatives(2))\n[x[1] + 2 x[2] - 5, 3 x[1] + 4 x[2] - 6] in MathOptInterface.Nonnegatives(2)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In addition to the Nonnegatives set, MOI defines a number of other vector-valued sets such as Nonpositives. See the MOI documentation for more information.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note also that for the first time we have used an explicit function-in-set description of the constraint. Read more about this representation for constraints in the MOI documentation.","category":"page"},{"location":"manual/constraints/#Constraints-on-a-single-variable","page":"Constraints","title":"Constraints on a single variable","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In Variables, we saw how to modify the variable bounds, as well as add binary and integer restrictions to the domain of each variable. This can also be achieved using the @constraint macro. For example, MOI.ZeroOne() restricts the domain to 0 1:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.ZeroOne())\nx binary","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"and MOI.Integer() restricts to the domain to the integers mathbbZ:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.Integer())\nx integer","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP also supports modeling semi-continuous variables, whose domain is 0  l u, using the MOI.Semicontinuous set:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.Semicontinuous(1.5, 3.5))\nx in MathOptInterface.Semicontinuous{Float64}(1.5, 3.5)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"as well as semi-integer variables, whose domain is 0  l l+1 dots u, using the MOI.Semiinteger set:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.Semiinteger(1.0, 3.0))\nx in MathOptInterface.Semiinteger{Float64}(1.0, 3.0)","category":"page"},{"location":"manual/constraints/#quad_constraints","page":"Constraints","title":"Quadratic constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In addition to affine functions, JuMP also supports constraints with quadratic terms. (For more general nonlinear functions, see Nonlinear Modeling.) For example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[i=1:2])\n2-element Array{VariableRef,1}:\n x[1]\n x[2]\n\njulia> @variable(model, t >= 0)\nt\n\njulia> @constraint(model, x[1]^2 + x[2]^2 <= t^2)\nx[1]¬≤ + x[2]¬≤ - t¬≤ <= 0.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note that this quadratic constraint (including the lower bound on t) is equivalent to a second order cone constraint where ||x[1]^2 + x[2]^2||\\_2 ‚â§ t and t ‚â• 0. Instead of writing out the quadratic expansion, we can pass JuMP the constraint in function-in-set form. To do so, we need to define the function and the set.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The function is a vector of variables:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> [t, x[1], x[2]]\n3-element Array{VariableRef,1}:\n t\n x[1]\n x[2]","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note that the variable t comes first, followed by the x arguments. The set is an instance of SecondOrderCone: SecondOrderCone(). Thus, we can add the second order cone constraint as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, [t, x[1], x[2]] in SecondOrderCone())\n[t, x[1], x[2]] in MathOptInterface.SecondOrderCone(3)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP also supports the RotatedSecondOrderCone which requires the addition of a perspective variable u. The rotated second order cone constraints the variables t, u, and x such that: ||x[1]^2 + x[2]^2||\\_2 ‚â§ t √ó u and t, u ‚â• 0. It can be added as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, u)\nu\n\njulia> @constraint(model, [t, u, x[1], x[2]] in RotatedSecondOrderCone())\n[t, u, x[1], x[2]] in MathOptInterface.RotatedSecondOrderCone(4)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In addition to the second order cone and rotated second order cone, MOI defines a number of other conic sets such as the exponential and power cones. See the MathOptInterface documentation for more information.","category":"page"},{"location":"manual/constraints/#Constraints-on-a-collection-of-variables","page":"Constraints","title":"Constraints on a collection of variables","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In addition to constraining the domain of a single variable, JuMP supports placing constraints of a subset of the variables. We already saw an example of this in the Quadratic constraints section when we constrained a vector of variables to belong to the second order cone.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In a special ordered set of type I (often denoted SOS-I), at most one variable can take a non-zero value. We can construct SOS-I constraints using the MOI.SOS1 set:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in MOI.SOS1([1.0, 2.0, 3.0]))\n[x[1], x[2], x[3]] in MathOptInterface.SOS1{Float64}([1.0, 2.0, 3.0])","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note that we have to pass MOI.SOS1 a weight vector. This vector implies an ordering on the variables. If the decision variables are related and have a physical ordering (e.g., they correspond to the size of a factory to be built, and the SOS-I constraint enforces that only one factory can be built), then the weight vector, although not used directly in the constraint, can help the solver make a better decision in the solution process.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"This ordering is more important in a special ordered set of type II (SOS-II), in which at most two values can be non-zero, and if there are two non-zeros, they must be consecutive according to the ordering. For example, in the following constraint, the possible non-zero pairs are (x[1] and x[3]) and (x[2] and x[3]):","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.SOS2([3.0, 1.0, 2.0]))\n[x[1], x[2], x[3]] in MathOptInterface.SOS2{Float64}([3.0, 1.0, 2.0])","category":"page"},{"location":"manual/constraints/#Indicator-constraints","page":"Constraints","title":"Indicator constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP provides a special syntax for creating indicator constraints, that is, enforce a constraint to hold depending on the value of a binary variable. In order to constrain the constraint x + y <= 1 to hold when a binary variable a is one, use the following syntax:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @variable(model, a, Bin)\na\n\njulia> @constraint(model, a => {x + y <= 1})\na => {x + y ‚â§ 1.0}","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If instead the constraint should hold when a is zero, simply add a ! or ¬¨ before the binary variable.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, !a => {x + y <= 1})\n!a => {x + y ‚â§ 1.0}","category":"page"},{"location":"manual/constraints/#Semidefinite-constraints","page":"Constraints","title":"Semidefinite constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP provides a special syntax for constraining a matrix to be symmetric positive semidefinite (PSD) with the @SDconstraint macro. In the context of this macro, the inequality A >= B between two square matrices A and B is understood as constraining A - B to be symmetric positive semidefinite.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x)\nx\n\njulia> @SDconstraint(model, [x 2x; 3x 4x] >= ones(2, 2))\n[x - 1    2 x - 1;\n 3 x - 1  4 x - 1] ‚àà PSDCone()","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Solvers supporting such constraints usually expect to be given a matrix that is symbolically symmetric, that is, for which the expression in corresponding off-diagonal entries are the same. In our example, the expressions of entries (1, 2) and (2, 1) are respectively 2x - 1 and 3x - 1 which are different. To bridge the gap between the constraint modeled and what the solver expects, JuMP creates an equality constraint 3x - 1 == 2x - 1 and constrains the symmetric matrix [x - 1, 2 x - 1, 2 x - 1, 4 x - 1] to be positive semidefinite.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nIf the matrix provided is already symbolically symmetric, the equality constrains are equivalent to 0 = 0 and are not added. In practice, if all coefficients are smaller than 1e-10, the constraint is ignored, if all coefficients are smaller than 1e-8 but some are larger than 1e-10, it is ignored but a warning is displayed, otherwise if at least one coefficient is larger than 1e-8, the constraint is added.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If the matrix is known to be symmetric, the PSD constraint can be added as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> using LinearAlgebra\n\njulia> @constraint(model, Symmetric([x 2x; 2x 4x] - ones(2, 2)) in PSDCone())\n[x - 1    2 x - 1;\n 2 x - 1  4 x - 1] ‚àà PSDCone()","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note that the lower triangular entries are silently ignored even if they are different so use it with caution:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> cref = @constraint(model, Symmetric([x 2x; 3x 4x]) in PSDCone())\n[x    2 x;\n 2 x  4 x] ‚àà PSDCone()\n\njulia> jump_function(constraint_object(cref))\n3-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x\n 2 x\n 4 x\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeTriangle(2)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note that as @SDconstraint(model, A >= B) constrains A - B to be symmetric positive semidefinite, even if A is a matrix of variables and B is a matrix of zeros, A - B will be a matrix of affine expressions. For instance, in the example below, the function is VectorAffineFunction instead of VectorOfVariables.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> typeof(@SDconstraint(model, [x x; x x] >= zeros(2, 2)))\nConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64},MathOptInterface.PositiveSemidefiniteConeSquare},SquareMatrixShape}","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Moreover, the Symmetric structure can be lost in the operation A - B. For instance, in the example below, the set is PositiveSemidefiniteConeSquare instead of PositiveSemidefiniteConeTriangle.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> typeof(@SDconstraint(model, Symmetric([x x; x x]) >= zeros(2, 2)))\nConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64},MathOptInterface.PositiveSemidefiniteConeSquare},SquareMatrixShape}","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To create a constraint on the vector of variables with the @SDconstraint macro, use the 0 symbol. The following three syntax are equivalent:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"@SDconstraint(model, A >= 0),\n@SDconstraint(model, 0 <= A) and\n@constraint(model, A in PSDCone()).","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> typeof(@SDconstraint(model, [x x; x x] >= 0))\nConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables,MathOptInterface.PositiveSemidefiniteConeSquare},SquareMatrixShape}\n\njulia> typeof(@SDconstraint(model, 0 <= Symmetric([x x; x x])))\nConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables,MathOptInterface.PositiveSemidefiniteConeTriangle},SymmetricMatrixShape}","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"As the syntax is recognized at parse time, using a variable with value zero does not work:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> a = 0\n0\n\njulia> @SDconstraint(model, [x x; x x] >= a)\nERROR: Operation `-` between `Array{VariableRef,2}` and `Int64` is not allowed. You should use broadcast.\n[...]","category":"page"},{"location":"manual/constraints/#Modify-a-constraint","page":"Constraints","title":"Modify a constraint","text":"","category":"section"},{"location":"manual/constraints/#Modifying-a-constant-term-(Option-1)","page":"Constraints","title":"Modifying a constant term (Option 1)","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Use set_normalized_rhs to modify the right-hand side (constant) term of a constraint. Use normalized_rhs to query the right-hand side term.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0\n\njulia> set_normalized_rhs(con, 3)\n\njulia> con\ncon : 2 x <= 3.0\n\njulia> normalized_rhs(con)\n3.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nJuMP normalizes constraints into a standard form by moving all constant terms onto the right-hand side of the constraint.@constraint(model, 2x - 1 <= 2)will be normalized to@constraint(model, 2x <= 3)set_normalized_rhs sets the right-hand side term of the normalized constraint.","category":"page"},{"location":"manual/constraints/#Modifying-a-constant-term-(Option-2)","page":"Constraints","title":"Modifying a constant term (Option 2)","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If constraints are complicated, e.g., they are composed of a number of components, each of which has a constant term, then it may be difficult to calculate what the right-hand side term should be in the standard form.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For this situation, JuMP includes the ability to fix variables to a value using the fix function. Fixing a variable sets its lower and upper bound to the same value. Thus, changes in a constant term can be simulated by adding a dummy variable and fixing it to different values. Here is an example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, const_term)\nconst_term\n\njulia> @constraint(model, con, 2x <= const_term + 1)\ncon : 2 x - const_term <= 1.0\n\njulia> fix(const_term, 1.0)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The constraint con is now equivalent to 2x <= 2.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nEven though const_term is fixed, it is still a decision variable. Thus, const_term * x is bilinear. Fixed variables are not replaced with constants when communicating the problem to a solver.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Another option is to use add_to_function_constant. The constant given is added to the function of a func-in-set constraint. In the following example, adding 2 to the function has the effect of removing 2 to the right-hand side:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0\n\njulia> add_to_function_constant(con, 2)\n\njulia> con\ncon : 2 x <= -1.0\n\njulia> normalized_rhs(con)\n-1.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In the case of interval constraints, the constant is removed in each bounds.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 0 <= 2x + 1 <= 2)\ncon : 2 x ‚àà [-1.0, 1.0]\n\njulia> add_to_function_constant(con, 3)\n\njulia> con\ncon : 2 x ‚àà [-4.0, -2.0]","category":"page"},{"location":"manual/constraints/#Modifying-a-variable-coefficient","page":"Constraints","title":"Modifying a variable coefficient","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To modify the coefficients for a linear term in a constraint (but notably not yet the coefficients on a quadratic term), use set_normalized_coefficient. To query the current coefficient, use normalized_coefficient.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x[1] + x[2] <= 1)\ncon : 2 x[1] + x[2] ‚â§ 1.0\n\njulia> set_normalized_coefficient(con, x[2], 0)\n\njulia> con\ncon : 2 x[1] ‚â§ 1.0\n\njulia> normalized_coefficient(con, x[2])\n0.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nJuMP normalizes constraints into a standard form by moving all terms involving variables onto the left-hand side of the constraint.@constraint(model, 2x <= 1 - x)will be normalized to@constraint(model, 3x <= 1)set_normalized_coefficient sets the coefficient of the normalized constraint.","category":"page"},{"location":"manual/constraints/#Deleting-constraints","page":"Constraints","title":"Deleting constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Constraints can be deleted from a model using delete.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Check if a constraint reference is valid using is_valid.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0\n\njulia> is_valid(model, con)\ntrue\n\njulia> delete(model, con)\n\njulia> is_valid(model, con)\nfalse","category":"page"},{"location":"manual/constraints/#Accessing-constraints-from-a-model","page":"Constraints","title":"Accessing constraints from a model","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"You can query the types of constraints currently present in the model by calling list_of_constraint_types. Then, given a function and set type, use num_constraints to access the number of constraints of this type and all_constraints to access a list of their references. Then use constraint_object to get an instance of an AbstractConstraint object, either ScalarConstraint or VectorConstraint, that stores the constraint data.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[i=1:2] >= i, Int);\n\njulia> @constraint(model, x[1] + x[2] <= 1);\n\njulia> list_of_constraint_types(model)\n3-element Array{Tuple{DataType,DataType},1}:\n (GenericAffExpr{Float64,VariableRef}, MathOptInterface.LessThan{Float64})\n (VariableRef, MathOptInterface.GreaterThan{Float64})\n (VariableRef, MathOptInterface.Integer)\n\njulia> num_constraints(model, VariableRef, MOI.Integer)\n2\n\njulia> all_constraints(model, VariableRef, MOI.Integer)\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.Integer},ScalarShape},1}:\n x[1] integer\n x[2] integer\n\njulia> num_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n2\n\njulia> all_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}},ScalarShape},1}:\n x[1] ‚â• 1.0\n x[2] ‚â• 2.0\n\njulia> num_constraints(model, GenericAffExpr{Float64,VariableRef}, MOI.LessThan{Float64})\n1\n\njulia> less_than_constraints = all_constraints(model, GenericAffExpr{Float64,VariableRef}, MOI.LessThan{Float64})\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n x[1] + x[2] ‚â§ 1.0\n\njulia> con = constraint_object(less_than_constraints[1])\nScalarConstraint{GenericAffExpr{Float64,VariableRef},MathOptInterface.LessThan{Float64}}(x[1] + x[2], MathOptInterface.LessThan{Float64}(1.0))\n\njulia> con.func\nx[1] + x[2]\n\njulia> con.set\nMathOptInterface.LessThan{Float64}(1.0)","category":"page"},{"location":"manual/constraints/#Complementarity-constraints","page":"Constraints","title":"Complementarity constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A mixed complementarity constraint F(x) ‚üÇ x consists of finding x in the interval [lb, ub], such that the following holds:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"F(x) == 0 if lb < x < ub\nF(x) >= 0 if lb == x\nF(x) <= 0 if x == ub","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For more information, see the MOI.Complements documentation.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP supports mixed complementarity constraints via complements(F(x), x) or F(x) ‚üÇ x in the @constraint macro. The interval set [lb, ub] is obtained from the variable bounds on x.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For example, to define the problem 2x - 1 ‚üÇ x with x ‚àà [0, ‚àû), do:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x >= 0)\nx\n\njulia> @constraint(model, 2x - 1 ‚üÇ x)\n[2 x - 1, x] ‚àà MathOptInterface.Complements(1)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"This problem has a unique solution at x = 0.5.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The perp operator ‚üÇ can be entered in most editors (and the Julia REPL) by typing \\perp<tab>.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"An alternative approach that does not require the ‚üÇ symbol uses the complements function as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, complements(2x - 1, x))\n[2 x - 1, x] ‚àà MathOptInterface.Complements(1)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In both cases, the mapping F(x) is supplied as the first argument, and the matching variable x is supplied as the second.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Vector-valued complementarity constraints are also supported:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, -2 <= y[1:2] <= 2)\n2-element Array{VariableRef,1}:\n y[1]\n y[2]\n\njulia> M = [1 2; 3 4]\n2√ó2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> q = [5, 6]\n2-element Array{Int64,1}:\n 5\n 6\n\njulia> @constraint(model, M * y + q ‚üÇ y)\n[y[1] + 2 y[2] + 5, 3 y[1] + 4 y[2] + 6, y[1], y[2]] ‚àà MathOptInterface.Complements(2)","category":"page"},{"location":"manual/constraints/#Special-Ordered-Sets-(SOS1-and-SOS2)","page":"Constraints","title":"Special Ordered Sets (SOS1 and SOS2)","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A Special Ordered Set (SOS) is an ordered set of variables with the following characteristics.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If a vector of variables x is in a Special Ordered Set of Type I (SOS1), then at most one element of x can take a non-zero value, and all other elements must be zero.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Although not required for feasibility, solvers can benefit from an ordering of the variables (e.g., the variables represent different factories to build, at most one factory can be built, and the factories can be ordered according to cost). To induce an ordering, weights can be provided; as such, they should be unique values. The kth element in the ordered set corresponds to the kth weight in weights when the weights are sorted.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A SOS1 constraint is equivalent to:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"x[i] >= 0 for some i\nx[j] == 0 for all j != i","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If a vector of variables x is in a Special Ordered Set of Type II (SOS2), then at most two elements can be non-zero, and if two elements are non-zero, they must be adjacent.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Because of the adjacency requirement, you should supply a weight vector (with unique elements) to induce an ordering of the variables. The kth element in the ordered set corresponds to the kth weight in weights when the weights are sorted.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A SOS2 constraint is equivalent to:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"x[i] >= 0, x[i+1] >= 0  for some i\nx[j] == 0 for all j != i, j != i+1","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Create an SOS constraint as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in SOS2([3,5,2]))\n[x[1], x[2], x[3]] ‚àà MathOptInterface.SOS2{Float64}([3.0, 5.0, 2.0])","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In the case above, x[3] is the first variable and x[2] the last variable under the induced ordering. When no ordering vector is provided, JuMP induces an ordering from 1:length(x).","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in SOS2())\n[x[1], x[2], x[3]] ‚àà MathOptInterface.SOS2{Float64}([1.0, 2.0, 3.0])","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/power_systems.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Power-Systems","page":"Power Systems","title":"Power Systems","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Originally Contributed by: Yury Dvorkin and Miles Lubin","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"This tutorial demonstrates how to formulate basic power systems engineering models in JuMP using a 3 bus example.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"We will consider basic \"economic dispatch\" and \"unit commitment\" models without taking into account transmission constraints.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Illustrative-example","page":"Power Systems","title":"Illustrative example","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"In the following notes for the sake of simplicity, we are going to use a three bus example mirroring the interface between Western and Eastern Texas. This example is taken from R. Baldick, \"Wind and Energy Markets: A Case Study of Texas,\" IEEE Systems Journal, vol. 6, pp. 27-34, 2012.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"(Image: Power Systems)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"For this example, we set the following characteristics of generators, transmission lines, wind farms and demands:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Quantity Generator 1 Generator 2\ng_min, MW 0 300\ng_max, MW 1000 1000\nc^g, $/MWh 50 100\nc^g0, $/MWh 1000 0","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Quantity Line 1 Line 2\nf^max, MW 100 1000\nx, p.u. 0.001 0.001","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Quantity Wind farm 1 Wind farm 2\nw^f, MW 150 50\nc^w, $/MWh 50 50","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Quantity Bus 1 Bus 2 Bus 3\nd, MW 0 0 15000","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Economic-dispatch","page":"Power Systems","title":"Economic dispatch","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Economic dispatch (ED) is an optimization problem that minimizes the cost of supplying energy demand subject to operational constraints on power system assets. In its simplest modification, ED is an LP problem solved for an aggregated load and wind forecast and for a single infinitesimal moment.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Mathematically, the ED problem can be written as follows:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"min sum_i in I c^g_i cdot g_i + c^w cdot w","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"where c_i and g_i are the incremental cost ($/MWh) and power output (MW) of the i^th generator, respectively, and c^w and w are the incremental cost ($/MWh) and wind power injection (MW), respectively.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Subject to the constraints:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Minimum (g^min) and maximum (g^max) limits on power outputs of generators: g^min_i leq g_i leq g^max_i\nConstraint on the wind power injection: 0 leq w leq w^f where w and w^f are the wind power injection and wind power forecast, respectively.\nPower balance constraint: sum_i in I g_i + w = d^f where d^f is the demand forecast.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Further reading on ED models can be found in A. J. Wood, B. F. Wollenberg, and G. B. Shebl√©, \"Power Generation, Operation and Control\", Wiley, 2013.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#JuMP-Implementation-of-Economic-Dispatch","page":"Power Systems","title":"JuMP Implementation of Economic Dispatch","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"using JuMP\nimport DataFrames\nimport GLPK","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Define some input data about the test system.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"# Maximum power output of generators\ng_max = [1000, 1000]\n# Minimum power output of generators\ng_min = [0, 300]\n# Incremental cost of generators\nc_g = [50, 100]\n# Fixed cost of generators\nc_g0 = [1000, 0]\n# Incremental cost of wind generators\nc_w = 50\n# Total demand\nd = 1500\n# Wind forecast\nw_f = 200\nnothing #hide","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Create a function solve_ed, which solves the economic dispatch problem for a given set of input parameters.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"function solve_ed(g_max, g_min, c_g, c_w, d, w_f)\n    # Define the economic dispatch (ED) model\n    ed = Model(GLPK.Optimizer)\n    # Define decision variables\n    @variable(ed, 0 <= g[i = 1:2] <= g_max[i]) ## power output of generators\n    @variable(ed, 0 <= w <= w_f) ## wind power injection\n    # Define the objective function\n    @objective(ed, Min, c_g' * g + c_w * w)\n    # Define the constraint on the maximum and minimum power output of each\n    # generator\n    @constraint(ed, [i = 1:2], g[i] <= g_max[i]) ## maximum\n    @constraint(ed, [i = 1:2], g[i] >= g_min[i]) ## minimum\n    # Define the constraint on the wind power injection\n    @constraint(ed, w <= w_f)\n    # Define the power balance constraint\n    @constraint(ed, sum(g) + w == d)\n    # Solve statement\n    optimize!(ed)\n    # return the optimal value of the objective function and its minimizers\n    return value.(g), value(w), w_f - value(w), objective_value(ed)\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Solve the economic dispatch problem","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"(g_opt, w_opt, ws_opt, obj) = solve_ed(g_max, g_min, c_g, c_w, d, w_f);\n\nprintln(\"Dispatch of Generators: \", g_opt, \" MW\")\nprintln(\"Dispatch of Wind: \", w_opt, \" MW\")\nprintln(\"Wind spillage: \", w_f - w_opt, \" MW\")\nprintln(\"\\n\")\nprintln(\"Total cost: \", obj, \"\\$\")","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Economic-dispatch-with-adjustable-incremental-costs","page":"Power Systems","title":"Economic dispatch with adjustable incremental costs","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"In the following exercise we adjust the incremental cost of generator G1 and observe its impact on the total cost.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"c_g_scale_df = DataFrames.DataFrame(\n    Symbol(\"Dispatch of Generator 1(MW)\") => Float64[],\n    Symbol(\"Dispatch of Generator 2(MW)\") => Float64[],\n    Symbol(\"Dispatch of Wind(MW)\") => Float64[],\n    Symbol(\"Spillage of Wind(MW)\") => Float64[],\n    Symbol(\"Total cost(\\$)\") => Float64[],\n)\nfor c_g1_scale = 0.5:0.1:3.0\n    # Update the incremental cost of the first generator at every iteration.\n    c_g_scale = [c_g[1] * c_g1_scale, c_g[2]]\n    # Solve the ed problem with the updated incremental cost\n    g_opt, w_opt, ws_opt, obj = solve_ed(g_max, g_min, c_g_scale, c_w, d, w_f)\n    push!(c_g_scale_df, (g_opt[1], g_opt[2], w_opt, ws_opt, obj))\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"ENV[\"COLUMNS\"]=250 #hide\n\nc_g_scale_df","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Modifying-the-JuMP-model-in-place","page":"Power Systems","title":"Modifying the JuMP model in place","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Note that in the previous exercise we entirely rebuilt the optimization model at every iteration of the internal loop, which incurs an additional computational burden. This burden can be alleviated if instead of re-building the entire model, we modify a specific constraint(s) or the objective function, as it shown in the example below.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Compare the computing time in case of the above and below models.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"function solve_ed_inplace(c_w_scale)\n    start = time()\n    obj_out = Float64[]\n    w_out = Float64[]\n    g1_out = Float64[]\n    g2_out = Float64[]\n    ed = Model(GLPK.Optimizer)\n    # Define decision variables\n    @variable(ed, 0 <= g[i = 1:2] <= g_max[i]) ## power output of generators\n    @variable(ed, 0 <= w <= w_f ) ## wind power injection\n    # Define the objective function\n    @objective(ed, Min, c_g' * g + c_w * w)\n    # Define the constraint on the maximum and minimum power output of each generator\n    @constraint(ed, [i = 1:2], g[i] <= g_max[i]) ## maximum\n    @constraint(ed, [i = 1:2], g[i] >= g_min[i]) ## minimum\n    # Define the constraint on the wind power injection\n    @constraint(ed, w <= w_f)\n    # Define the power balance constraint\n    @constraint(ed, sum(g) + w == d)\n    optimize!(ed)\n    for c_g1_scale = 0.5:0.01:3.0\n        @objective(\n            ed,\n            Min,\n            c_g1_scale * c_g[1] * g[1] + c_g[2] * g[2] + c_w_scale * c_w * w,\n        )\n        optimize!(ed)\n        push!(obj_out, objective_value(ed))\n        push!(w_out, value(w))\n        push!(g1_out, value(g[1]))\n        push!(g2_out, value(g[2]))\n    end\n    elapsed = time() - start\n    print(string(\"elapsed time: \", elapsed, \" seconds\"))\n    return obj_out, w_out, g1_out, g2_out\nend\n\nsolve_ed_inplace(2.0)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Adjusting specific constraints and/or the objective function is faster than re-building the entire model.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#A-few-practical-limitations-of-the-economic-dispatch-model","page":"Power Systems","title":"A few practical limitations of the economic dispatch model","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Inefficient-usage-of-wind-generators","page":"Power Systems","title":"Inefficient usage of wind generators","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"The economic dispatch problem does not perform commitment decisions and, thus, assumes that all generators must be dispatched at least at their minimum power output limit. This approach is not cost efficient and may lead to absurd decisions. For example, if $ d = \\sum{i \\in I} g^{\\min}{i}$, the wind power injection must be zero, i.e. all available wind generation is spilled, to meet the minimum power output constraints on generators.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"In the following example, we adjust the total demand and observed how it affects wind spillage.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"demandscale_df = DataFrames.DataFrame(\n    Symbol(\"Dispatch of Generators(MW)\") => Float64[],\n    Symbol(\"Dispatch of Generator 2(MW)\") => Float64[],\n    Symbol(\"Dispatch of Wind(MW)\") => Float64[],\n    Symbol(\"Spillage of Wind(MW)\") => Float64[],\n    Symbol(\"Total cost(\\$)\") => Float64[],\n)\n\nfor demandscale = 0.2:0.1:1.5\n    g_opt,w_opt,ws_opt,obj = solve_ed(g_max, g_min, c_g, c_w, demandscale*d, w_f)\n    push!(demandscale_df, (g_opt[1], g_opt[2], w_opt, ws_opt, obj))\nend\n\ndemandscale_df","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"This particular drawback can be overcome by introducing binary decisions on the \"on/off\" status of generators. This model is called unit commitment and considered later in these notes.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"For further reading on the interplay between wind generation and the minimum power output constraints of generators, we refer interested readers to R. Baldick, \"Wind and Energy Markets: A Case Study of Texas,\" IEEE Systems Journal, vol. 6, pp. 27-34, 2012.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Transmission-infeasible-solution","page":"Power Systems","title":"Transmission-infeasible solution","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"The ED solution is entirely market-based and disrespects limitations of the transmission network. Indeed, the flows in transmission lines would attain the following values:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"f_1-2 = 150 MW leq f_1-2^max = 100 MW","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"f_2-3 = 1200 MW leq f_2-3^max = 1000 MW","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Thus, if this ED solution was enforced in practice, the power flow limits on both lines would be violated. Therefore, in the following section we consider the optimal power flow model, which amends the ED model with network constraints.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"The importance of the transmission-aware decisions is emphasized in E. Lannoye, D. Flynn, and M. O'Malley, \"Transmission, Variable Generation, and Power System Flexibility,\" IEEE Transactions on Power Systems, vol. 30, pp. 57-66, 2015.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Unit-Commitment-model","page":"Power Systems","title":"Unit Commitment model","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"The Unit Commitment (UC) model can be obtained from ED model by introducing binary variable associated with each generator. This binary variable can attain two values: if it is \"1\", the generator is synchronized and, thus, can be dispatched, otherwise, i.e. if the binary variable is \"0\", that generator is not synchronized and its power output is set to 0.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"To obtain the mathematical formulation of the UC model, we will modify the constraints of the ED model as follows:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"g^min_i cdot u_ti leq g_i leq g^max_i cdot u_ti","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"where u_i in 01 In this constraint, if u_i = 0, then g_i  = 0. On the other hand, if u_i = 1, then g^max_i leq g_i leq g^min_i.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"For further reading on the UC problem we refer interested readers to G. Morales-Espana, J. M. Latorre, and A. Ramos, \"Tight and Compact MILP Formulation for the Thermal Unit Commitment Problem,\" IEEE Transactions on Power Systems, vol. 28, pp. 4897-4908, 2013.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"In the following example we convert the ED model explained above to the UC model.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"function solve_uc(g_max, g_min, c_g, c_w, d, w_f)\n    # Define the unit commitment (UC) model\n    uc = Model(GLPK.Optimizer)\n    # Define decision variables\n    @variable(uc, 0 <= g[i=1:2] <= g_max[i]) ## power output of generators\n    @variable(uc, u[i = 1:2], Bin) ## Binary status of generators\n    @variable(uc, 0 <= w <= w_f) ## wind power injection\n    # Define the objective function\n    @objective(uc, Min, c_g' * g + c_w * w)\n    # Define the constraint on the maximum and minimum power output of each\n    # generator.\n    @constraint(uc, [i = 1:2], g[i] <= g_max[i] * u[i]) ## maximum\n    @constraint(uc, [i = 1:2], g[i] >= g_min[i] * u[i]) ## minimum\n    # Define the constraint on the wind power injection\n    @constraint(uc, w <= w_f)\n    # Define the power balance constraint\n    @constraint(uc, sum(g) + w == d)\n    # Solve statement\n    optimize!(uc)\n    status = termination_status(uc)\n    if status != MOI.OPTIMAL\n        return status, zeros(length(g)), 0.0, 0.0, zeros(length(u)), Inf\n    end\n    return status, value.(g), value(w), w_f - value(w), value.(u), objective_value(uc)\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Solve the economic dispatch problem","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"status, g_opt, w_opt, ws_opt, u_opt, obj =\n    solve_uc(g_max, g_min, c_g, c_w, d, w_f)\n\nprintln(\"Dispatch of Generators: \", g_opt[:], \" MW\")\nprintln(\"Commitments of Generators: \", u_opt[:])\nprintln(\"Dispatch of Wind: \", w_opt, \" MW\")\nprintln(\"Wind spillage: \", w_f - w_opt, \" MW\")\nprintln(\"\\n\")\nprintln(\"Total cost: \", obj, \"\\$\")","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Unit-Commitment-as-a-function-of-demand","page":"Power Systems","title":"Unit Commitment as a function of demand","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"After implementing the UC model, we can now assess the interplay between the minimum power output constraints on generators and wind generation.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"uc_df = DataFrames.DataFrame(\n    Symbol(\"Commitment of Generator 1(MW)\") => Float64[],\n    Symbol(\"Commitment of Generator 2(MW)\") => Float64[],\n    Symbol(\"Dispatch of Generator 1(MW)\") => Float64[],\n    Symbol(\"Dispatch of Generator 2(MW)\") => Float64[],\n    Symbol(\"Dispatch of Wind(MW)\") => Float64[],\n    Symbol(\"Spillage of Wind(MW)\") => Float64[],\n    Symbol(\"Total cost(\\$)\") => Float64[],\n)\n\nfor demandscale = 0.2:0.1:1.5\n    status, g_opt, w_opt, ws_opt, u_opt, obj =\n        solve_uc(g_max, g_min, c_g, c_w, demandscale*d, w_f)\n    if status == MOI.OPTIMAL\n        push!(uc_df, (u_opt[1], u_opt[2], g_opt[1], g_opt[2], w_opt, ws_opt, obj))\n    else\n        println(\"Status: $status for demandscale = $demandscale \\n\")\n    end\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"uc_df","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Quadratic programs/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Quadratic programs/qcp.jl\"","category":"page"},{"location":"tutorials/Quadratic programs/qcp/#Quadratically-constrained-programs","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"","category":"section"},{"location":"tutorials/Quadratic programs/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"A simple quadratically constrained program based on an example from Gurobi.","category":"page"},{"location":"tutorials/Quadratic programs/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"using JuMP\nimport Ipopt\nimport Test\n\nfunction example_qcp(; verbose = true)\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, x)\n    @variable(model, y >= 0)\n    @variable(model, z >= 0)\n    @objective(model, Max, x)\n    @constraint(model, x + y + z == 1)\n    @constraint(model, x * x + y * y - z * z <= 0)\n    @constraint(model, x * x - y * z <= 0)\n    optimize!(model)\n    if verbose\n        print(model)\n        println(\"Objective value: \", objective_value(model))\n        println(\"x = \", value(x))\n        println(\"y = \", value(y))\n    end\n    Test.@test termination_status(model) == MOI.LOCALLY_SOLVED\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ‚âà 0.32699 atol = 1e-5\n    Test.@test value(x) ‚âà 0.32699 atol = 1e-5\n    Test.@test value(y) ‚âà 0.25707 atol = 1e-5\n    return\nend\n\nexample_qcp()","category":"page"},{"location":"tutorials/Quadratic programs/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"View this file on Github.","category":"page"},{"location":"tutorials/Quadratic programs/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"","category":"page"},{"location":"tutorials/Quadratic programs/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#![JuMP-logo](assets/jump-logo-with-text.svg)","page":"Introduction","title":"(Image: JuMP logo)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Powered by NumFOCUS)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"# These comments do not display in the HTML output.\n# See https://github.com/JuliaDocs/Documenter.jl/issues/674.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nBetween versions 0.18 and 0.19, JuMP underwent a major transition in its underlying solver abstraction API, from MathProgBase to MathOptInterface. See NEWS.md for a comprehensive list of changes between the two versions, many of which are breaking. This documentation is for JuMP/MathOptInterface. For the documentation of JuMP 0.18, see here.","category":"page"},{"location":"#What-is-JuMP?","page":"Introduction","title":"What is JuMP?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP is a domain-specific modeling language for mathematical optimization embedded in Julia. It currently supports a number of open-source and commercial solvers for a variety of problem classes, including linear, mixed-integer, second-order conic, semidefinite, and nonlinear programming.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Tip\nIf you aren't sure if you should use JuMP, read Should I use JuMP?.","category":"page"},{"location":"#Resources-for-getting-started","page":"Introduction","title":"Resources for getting started","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Read the Installation Guide.\nRead the introductory tutorials Getting started with Julia and Getting started with JuMP.\nBrowse some of our modeling tutorials, including classics such as The diet problem, or the Maximum likelihood estimation problem using nonlinear programming.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Tip\nNeed help? Join the community forum to search for questions to commonly asked questions.Before asking a question, make sure to read the post make it easier to help you, which contains a number of tips on how to ask a good question.","category":"page"},{"location":"#How-the-documentation-is-structured","page":"Introduction","title":"How the documentation is structured","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Having a high-level overview of how this documentation is structured will help you know where to look for certain things.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Tutorials contain worked examples of solving problems with JuMP. Start here if you are new to JuMP, or you have a particular problem class you want to model.\nThe Manual contains short code-snippets that explain how to achieve specific tasks in JuMP. Look here if you want to know how to achieve a particular task, such as how to delete a variable or how to modify an objective coefficient.\nThe API Reference contains a complete list of the functions you can use in JuMP. Look here if you want to know how to use a particular function.\nThe Background information section contains background reading material to provide context to JuMP. Look here if you want an understanding of what JuMP is and why we created it, rather than how to use it.\nThe Developer docs section contains information for people contributing to JuMP development or writing JuMP extensions. Don't worry about this section if you are just using JuMP to formulate and solve problems as a user.\nThe MathOptInterface section is a self-contained copy of the documentation for MathOptInterface. Look here for functions and constants beginning with MOI., as well as for general information on how MathOptInterface works.","category":"page"},{"location":"#Citing-JuMP","page":"Introduction","title":"Citing JuMP","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you find JuMP useful in your work, we kindly request that you cite the following paper (pdf):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@article{DunningHuchetteLubin2017,\nauthor = {Iain Dunning and Joey Huchette and Miles Lubin},\ntitle = {JuMP: A Modeling Language for Mathematical Optimization},\njournal = {SIAM Review},\nvolume = {59},\nnumber = {2},\npages = {295-320},\nyear = {2017},\ndoi = {10.1137/15M1020575},\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For an earlier work where we presented a prototype implementation of JuMP, see here:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@article{LubinDunningIJOC,\nauthor = {Miles Lubin and Iain Dunning},\ntitle = {Computing in Operations Research Using Julia},\njournal = {INFORMS Journal on Computing},\nvolume = {27},\nnumber = {2},\npages = {238-248},\nyear = {2015},\ndoi = {10.1287/ijoc.2014.0623},\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A preprint of this paper is freely available.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: NumFOCUS logo)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP is a Sponsored Project of NumFOCUS, a 501(c)(3) nonprofit charity in the United States. NumFOCUS provides JuMP with fiscal, legal, and administrative support to help ensure the health and sustainability of the project. Visit numfocus.org for more information.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can support JuMP by donating.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Donations to JuMP are managed by NumFOCUS. For donors in the United States, your gift is tax-deductible to the extent provided by law. As with any donation, you should consult with your tax adviser about your particular tax situation.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP's largest expense is the annual JuMP-dev workshop. Donations will help us provide travel support for JuMP-dev attendees and take advantage of other opportunities that arise to support JuMP development.","category":"page"},{"location":"moi/background/motivation/","page":"Motivation","title":"Motivation","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/background/motivation/#Motivation","page":"Motivation","title":"Motivation","text":"","category":"section"},{"location":"moi/background/motivation/","page":"Motivation","title":"Motivation","text":"MOI has been designed to replace MathProgBase, which was been used by modeling packages such as JuMP and Convex.jl.","category":"page"},{"location":"moi/background/motivation/","page":"Motivation","title":"Motivation","text":"This second-generation abstraction layer addresses a number of limitations of MathProgBase.","category":"page"},{"location":"moi/background/motivation/","page":"Motivation","title":"Motivation","text":"MOI is designed to:","category":"page"},{"location":"moi/background/motivation/","page":"Motivation","title":"Motivation","text":"Be simple and extensible, unifying linear, quadratic, and conic optimization, and seamlessly facilitate extensions to essentially arbitrary constraints and functions (e.g., indicator constraints, complementarity constraints, and piecewise-linear functions)\nBe fast by allowing access to a solver's in-memory representation of a problem without writing intermediate files (when possible) and by using multiple dispatch and avoiding requiring containers of nonconcrete types\nAllow a solver to return multiple results (e.g., a pool of solutions)\nAllow a solver to return extra arbitrary information via attributes (e.g., variable- and constraint-wise membership in an irreducible inconsistent subset for infeasibility analysis)\nProvide a greatly expanded set of status codes explaining what happened during the optimization procedure\nEnable a solver to more precisely specify which problem classes it supports\nEnable both primal and dual warm starts\nEnable adding and removing both variables and constraints by indices that are not required to be consecutive\nEnable any modification that the solver supports to an existing model\nAvoid requiring the solver wrapper to store an additional copy of the problem data","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"‚â§|<=\", r\"‚â•|>=\", r\" == | = \", r\" ‚àà | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"developers/extensions/#extensions_manual","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"JuMP provides a variety of ways to extend the basic modeling functionality.","category":"page"},{"location":"developers/extensions/#Define-a-new-set","page":"Extensions","title":"Define a new set","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"To define a new set for JuMP, subtype MOI.AbstractScalarSet or MOI.AbstractVectorSet and implement Base.copy for the set. That's it!","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"struct _NewVectorSet <: MOI.AbstractVectorSet\n    dimension::Int\nend\nBase.copy(x::_NewVectorSet) = x\n\nmodel = Model()\n@variable(model, x[1:2])\n@constraint(model, x in _NewVectorSet(2))\n\n# output\n\n[x[1], x[2]] ‚àà _NewVectorSet(2)","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"However, for vector-sets, this requires the user to specify the dimension argument to their set, even though we could infer it from the length of x!","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"You can make a more user-friendly set by subtyping AbstractVectorSet and implementing moi_set.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"struct NewVectorSet <: JuMP.AbstractVectorSet end\nJuMP.moi_set(::NewVectorSet, dim::Int) = _NewVectorSet(dim)\n\nmodel = Model()\n@variable(model, x[1:2])\n@constraint(model, x in NewVectorSet())\n\n# output\n\n[x[1], x[2]] ‚àà _NewVectorSet(2)","category":"page"},{"location":"developers/extensions/#Extend-[@variable](@ref)","page":"Extensions","title":"Extend @variable","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Just as Bin and Int create binary and integer variables, you can extend the @variable macro to create new types of variables. Here is an explanation by example, where we create a AddTwice type, that creates a tuple of two JuMP variables instead of a single variable.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"First, create a new struct. This can be anything. Our struct holds a VariableInfo object that stores bound information, and whether the variable is binary or integer.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> struct AddTwice\n           info::JuMP.VariableInfo\n       end","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Second, implement build_variable, which takes ::Type{AddTwice} as an argument, and returns an instance of AddTwice. Note that you can also receive keyword arguments.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> function JuMP.build_variable(\n           _err::Function,\n           info::JuMP.VariableInfo,\n           ::Type{AddTwice};\n           kwargs...\n       )\n           println(\"Can also use $kwargs here.\")\n           return AddTwice(info)\n       end","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Third, implement add_variable, which takes the instance of AddTwice from the previous step, and returns something. Typically, you will want to call add_variable here. For example, our AddTwice call is going to add two JuMP variables.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> function JuMP.add_variable(\n           model::JuMP.Model,\n           duplicate::AddTwice,\n           name::String,\n       )\n           a = JuMP.add_variable(\n               model,\n               JuMP.ScalarVariable(duplicate.info),\n               name * \"_a\",\n            )\n           b = JuMP.add_variable(\n               model,\n               JuMP.ScalarVariable(duplicate.info),\n               name * \"_b\",\n            )\n           return (a, b)\n       end","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Now AddTwice can be passed to @variable just like Bin or Int. However, now it adds two variables instead of one!","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> model = Model();\n\njulia> @variable(model, x[i=1:2], AddTwice, kw=i)\nCan also use Base.Iterators.Pairs(:kw=>1) here.\nCan also use Base.Iterators.Pairs(:kw=>2) here.\n2-element Array{Tuple{VariableRef,VariableRef},1}:\n (x[1]_a, x[1]_b)\n (x[2]_a, x[2]_b)\n\njulia> num_variables(model)\n4\n\njulia> first(x[1])\nx[1]_a\n\njulia> last(x[2])\nx[2]_b","category":"page"},{"location":"developers/extensions/#Extend-[@constraint](@ref)","page":"Extensions","title":"Extend @constraint","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"The @constraint macro always calls the same three functions:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"parse_constraint: is called at parsing time, it parses the constraint expression and returns a build_constraint call expression;\nbuild_constraint: given the functions and sets involved in the constraints, it returns a AbstractConstraint;\nadd_constraint: given the model, the AbstractConstraint constructed in build_constraint and the constraint name, it stores them in the model and returns a ConstraintRef.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Adding methods to these functions is the recommended way to extend the @constraint macro.","category":"page"},{"location":"developers/extensions/#Adding-parse_constraint-methods","page":"Extensions","title":"Adding parse_constraint methods","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Work in progress.","category":"page"},{"location":"developers/extensions/#Adding-build_constraint-methods","page":"Extensions","title":"Adding build_constraint methods","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"There are typically two choices when creating a build_constraint method, either return an AbstractConstraint already supported by the model, i.e. ScalarConstraint or VectorConstraint, or a custom AbstractConstraint with a corresponding add_constraint method (see Adding add_constraint methods).","category":"page"},{"location":"developers/extensions/#Adding-add_constraint-methods","page":"Extensions","title":"Adding add_constraint methods","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Work in progress.","category":"page"},{"location":"developers/extensions/#Shapes","page":"Extensions","title":"Shapes","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Shapes allow vector constraints, which are represented as flat vectors in MOI, to retain a matrix shape at the JuMP level. There is a shape field in VectorConstraint that can be set in build_constraint and that is used to reshape the result computed in value and dual.","category":"page"},{"location":"developers/extensions/#Extend-[@objective](@ref)","page":"Extensions","title":"Extend @objective","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Work in progress.","category":"page"},{"location":"developers/extensions/#Adding-a-bridge","page":"Extensions","title":"Adding a bridge","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Work in progress.","category":"page"},{"location":"developers/extensions/#Defining-new-JuMP-models","page":"Extensions","title":"Defining new JuMP models","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Work in progress.","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Semidefinite programs/min_ellipse.jl\"","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/#Minimum-ellipses","page":"Minimum ellipses","title":"Minimum ellipses","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"This example is from the Boyd & Vandenberghe book \"Convex Optimization\". Given a set of ellipses centered on the origin","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"E(A) = { u | u^T inv(A) u <= 1 }","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"find a \"minimal\" ellipse that contains the provided ellipses.","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"We can formulate this as an SDP:","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"minimize    trace(WX)\nsubject to  X >= A_i,    i = 1,...,m\n            X PSD","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"where W is a PD matrix of weights to choose between different solutions.","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"using JuMP\nimport LinearAlgebra\nimport SCS\nimport Test\n\nfunction example_min_ellipse()\n    # We will use three ellipses: two \"simple\" ones, and a random one.\n    As = [\n        [2.0  0.0; 0.0  1.0],\n        [1.0  0.0; 0.0  3.0],\n        [2.86715 1.60645; 1.60645 1.12639]\n    ]\n    # We change the weights to see different solutions, if they exist\n    weights = [1.0 0.0; 0.0 1.0]\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, X[i=1:2, j=1:2], PSD)\n    @objective(model, Min, LinearAlgebra.tr(weights * X))\n    for As_i in As\n        @SDconstraint(model, X >= As_i)\n    end\n    optimize!(model)\n    Test.@test termination_status(model) == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ‚âà 6.46233 atol = 1e-5\n    Test.@test value.(X) ‚âà [3.1651 0.8022; 0.8022 3.2972] atol = 1e-4\n    return\nend\n\nexample_min_ellipse()","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"View this file on Github.","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"This page was generated using Literate.jl.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/implementing/#Implementing-a-solver-interface","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"This guide outlines the basic steps to implement an interface to MathOptInterface for a new solver.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"warning: Warning\nImplementing an interface to MathOptInterface for a new solver is a lot of work. Before starting, we recommend that you join the Developer chatroom and explain a little bit about the solver you are wrapping. If you have questions that are not answered by this guide, please ask them in the Developer chatroom so we can improve this guide!","category":"page"},{"location":"moi/manual/implementing/#Preliminaries","page":"Implementing a solver interface","title":"Preliminaries","text":"","category":"section"},{"location":"moi/manual/implementing/#Decide-if-MathOptInterface-is-right-for-you","page":"Implementing a solver interface","title":"Decide if MathOptInterface is right for you","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The first step in writing a wrapper is to decide whether implementing an interface is the right thing to do.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"MathOptInterface is an abstraction layer for unifying constrained mathematical optimization solvers. If your solver doesn't fit in the category, i.e., it implements a derivative-free algorithm for unconstrained objective functions, MathOptInterface may not be the right tool for the job.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nIf you're not sure whether you should write an interface, ask in the Developer chatroom.","category":"page"},{"location":"moi/manual/implementing/#Find-a-similar-solver-already-wrapped","page":"Implementing a solver interface","title":"Find a similar solver already wrapped","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The next step is to find (if possible) a similar solver that is already wrapped. Although not strictly necessary, this will be a good place to look for inspiration when implementing your wrapper.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The JuMP documentation has a good list of solvers, along with the problem classes they support.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nIf you're not sure which solver is most similar, ask in the Developer chatroom.","category":"page"},{"location":"moi/manual/implementing/#Create-a-low-level-interface","page":"Implementing a solver interface","title":"Create a low-level interface","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Before writing a MathOptInterface, you first need to be able to call the solver from Julia.","category":"page"},{"location":"moi/manual/implementing/#Wrapping-solvers-written-in-Julia","page":"Implementing a solver interface","title":"Wrapping solvers written in Julia","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If your solver is written in Julia, there's nothing to do here! Go to the next section.","category":"page"},{"location":"moi/manual/implementing/#Wrapping-solvers-written-in-C","page":"Implementing a solver interface","title":"Wrapping solvers written in C","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Julia is well suited to wrapping solvers written in C.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"info: Info\nThis is not true for C++. If you have a solver written in C++, first write a C interface, then wrap the C interface.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Before writing a MathOptInterface wrapper, there are a few extra steps.","category":"page"},{"location":"moi/manual/implementing/#Create-a-JLL","page":"Implementing a solver interface","title":"Create a JLL","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If the C code is publicly available under an open-source license, create a JLL package via Yggdrasil. The easiest way to do this is to copy an existing solver. Good examples to follow are the COIN-OR solvers.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"warning: Warning\nBuilding the solver via Yggdrasil is non-trivial. please ask the Developer chatroom for help.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If the code is commercial or not publicly available, the user will need to manually install the solver. See Gurobi.jl or CPLEX.jl for examples of how to structure this.","category":"page"},{"location":"moi/manual/implementing/#implement_clang","page":"Implementing a solver interface","title":"Use Clang.jl to wrap the C API","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The next step is to use Clang.jl to automatically wrap the C API. The easiest way to do this is to follow an example. Good examples to follow are Cbc.jl and HiGHS.jl.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Sometimes, you will need to make manual modifications to the resulting files.","category":"page"},{"location":"moi/manual/implementing/#Solvers-written-in-other-languages","page":"Implementing a solver interface","title":"Solvers written in other languages","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Ask the Developer chatroom for advice. You may be able to use one of the JuliaInterop packages to call out to the solver.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For example, SeDuMi.jl uses MATLAB.jl to call the SeDuMi solver written in MATLAB.","category":"page"},{"location":"moi/manual/implementing/#Structuring-the-package","page":"Implementing a solver interface","title":"Structuring the package","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Structure your wrapper as a Julia package. Consult the Julia documentation if you haven't done this before.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"MOI solver interfaces may be in the same package as the solver itself (either the C wrapper if the solver is accessible through C, or the Julia code if the solver is written in Julia, for example), or in a separate package which depends on the solver package.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"note: Note\nThe JuMP core contributors request that you do not use \"JuMP\" in the name of your package without prior consent.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Your package should have the following structure:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"/.github\n    /workflows\n        ci.yml\n        format_check.yml\n        TagBot.yml\n/gen\n    gen.jl  # Code to wrap the C API\n/src\n    NewSolver.jl\n    /gen\n        libnewsolver_api.jl\n        libnewsolver_common.jl\n    /MOI_wrapper\n        MOI_wrapper.jl\n        other_files.jl\n/test\n    runtests.jl\n    /MOI_wrapper\n        MOI_wrapper.jl\n.gitignore\n.JuliaFormatter.toml\nREADME.md\nLICENSE.md\nProject.toml","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The /.github folder contains the scripts for GitHub actions. The easiest way to write these is to copy the ones from an existing solver.\nThe /gen and /src/gen folders are only needed if you are wrapping a solver written in C.\nThe /src/MOI_wrapper folder contains the Julia code for the MOI wrapper.\nThe /test folder contains code for testing your package. See Setup tests for more information.\nThe .JuliaFormatter.toml and .github/workflows/format_check.yml enforce code formatting using JuliaFormatter.jl. Check existing solvers or JuMP.jl for details.","category":"page"},{"location":"moi/manual/implementing/#Setup-tests","page":"Implementing a solver interface","title":"Setup tests","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The best way to implement an interface to MathOptInterface is via test-driven development.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The MOI.Test submodule contains a large test suite to help check that you have implemented things correctly.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Follow the guide How to test a solver to set up the tests for your package.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nRun the tests frequently when developing. However, at the start there is going to be a lot of errors! Comment out all the test_ functions but one, run the tests, implement any missing methods until the test passes, then uncomment another test and repeat.","category":"page"},{"location":"moi/manual/implementing/#Initial-code","page":"Implementing a solver interface","title":"Initial code","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"By this point, you should have a package setup with tests, formatting, and access to the underlying solver. Now it's time to start writing the wrapper.","category":"page"},{"location":"moi/manual/implementing/#The-Optimizer-object","page":"Implementing a solver interface","title":"The Optimizer object","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The first object to create is a subtype of AbstractOptimizer. This type is going to store everything related to the problem.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"By convention, these optimizers should not be exported and should be named PackageName.Optimizer.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"import MathOptInterface\nconst MOI = MathOptInterface\n\nstruct Optimizer <: MOI.AbstractOptimizer\n    # Fields go here\nend","category":"page"},{"location":"moi/manual/implementing/#Optimizer-objects-for-C-solvers","page":"Implementing a solver interface","title":"Optimizer objects for C solvers","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"warning: Warning\nThis section is important if you wrap a solver written in C.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Wrapping a solver written in C will require the use of pointers, and for you to manually free the solver's memory when the Optimizer is garbage collected by Julia.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Never pass a pointer directly to a Julia ccall function.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Instead, store the pointer as a field in your Optimizer, and implement Base.cconvert and Base.unsafe_convert. Then you can pass Optimizer to any ccall function that expects the pointer.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"In addition, make sure you implement a finalizer for each model you create.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If newsolver_createProblem() is the low-level function that creates the problem pointer in C, and newsolver_freeProblem(::Ptr{Cvoid}) is the low-level function that frees memory associated with the pointer, your Optimizer() function should look like this:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"struct Optimizer <: MOI.AbstractOptimizer\n    ptr::Ptr{Cvoid}\n\n    function Optimizer()\n        ptr = newsolver_createProblem()\n        model = Optimizer(ptr)\n        finalizer(model) do m\n            newsolver_freeProblem(m)\n            return\n        end\n        return model\n    end\nend\n\nBase.cconvert(::Type{Ptr{Cvoid}}, model::Optimizer) = model\nBase.unsafe_convert(::Type{Ptr{Cvoid}}, model::Optimizer) = model.ptr","category":"page"},{"location":"moi/manual/implementing/#Implement-methods-for-Optimizer","page":"Implementing a solver interface","title":"Implement methods for Optimizer","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Now that we have an Optimizer, we need to implement a few basic methods.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"empty! and is_empty","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nFor this and all future methods, read the docstrings to understand what each method does, what it expects as input, and what it produces as output. If it isn't clear, let us know and we will improve the docstrings! It is also very helpful to look at an existing wrapper for a similar solver.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"You should also implement Base.show(::IO, ::Optimizer) to print a nice string when some prints your model. For example","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"function Base.show(io::IO, model::Optimizer)\n    return print(io, \"NewSolver with the pointer $(model.ptr)\")\nend","category":"page"},{"location":"moi/manual/implementing/#Implement-attributes","page":"Implementing a solver interface","title":"Implement attributes","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"You also need to implement the model and optimizer attributes in the following table.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For each attribute","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"get gets the current value of the attribute\nset sets a new value of the attribute. Not all attributes can be set. For example, the user can't modify the SolverName.\nsupports returns a Bool indicating whether the solver supports the attribute.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Each column in the table indicates whether you need to implement the particular method for each attribute.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Attribute get set supports\nSolverName Yes No No\nRawSolver Yes No No\nName Yes Yes Yes\nSilent Yes Yes Yes\nTimeLimitSec Yes Yes Yes\nRawParameter Yes Yes Yes\nNumberOfThreads Yes Yes Yes","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For example:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"function MOI.get(model::Optimizer, ::MOI.Silent)\n    return # true if MOI.Silent is set\nend\n\nfunction MOI.set(model::Optimizer, ::MOI.Silent, v::Bool)\n    if v\n        # Set a parameter to turn off printing\n    else\n        # Restore the default printing\n    end\n    return\nend\n\nMOI.supports(::Optimizer, ::MOI.Silent) = true","category":"page"},{"location":"moi/manual/implementing/#Define-supports_constraint","page":"Implementing a solver interface","title":"Define supports_constraint","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The next step is to define which constraints and objective functions you plan to support.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For each function-set constraint pair, define supports_constraint:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"function MOI.supports_constraint(\n    ::Optimizer,\n    ::Type{MOI.SingleVariable},\n    ::Type{MOI.ZeroOne},\n)\n    return true\nend","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"To make this easier, you may want to use Unions:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"function MOI.supports_constraint(\n    ::Optimizer,\n    ::Type{MOI.SingleVariable},\n    ::Type{<:Union{MOI.LessThan,MOI.GreaterThan,MOI.EqualTo}},\n)\n    return true\nend","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nOnly support a constraint if your solver has native support for it.","category":"page"},{"location":"moi/manual/implementing/#The-big-decision:-copy-to-or-incremental-modifications?","page":"Implementing a solver interface","title":"The big decision: copy-to or incremental modifications?","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Now you need to decide whether to support incremental modification or not.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Incremental modification means that the user can add variables and constraints one-by-one without needing to rebuild the entire problem, and they can modify the problem data after an optimize! call. Supporting incremental modification means implementing functions like add_variable and add_constraint.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The alternative is to accept the problem data in a single copy_to function call, afterwhich it cannot be modified. Because copy_to sees all of the data at once, it can typically call a more efficient function to load data into the underlying solver.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Good examples of solvers supporting incremental modification are MILP solvers like GLPK.jl and Gurobi.jl. Examples of copy_to solvers are AmplNLWriter.jl and SCS.jl","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"It is possible to implement both approaches, but you should probably start with one for simplicity.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nOnly support incremental modification if your solver has native support for it.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"In general, supporting incremental modification is more work, and it usually requires some extra book-keeping. However, it provides a more efficient interface to the solver if the problem is going to be resolved multiple times with small modifications. Moreover, once you've implemented incremental modification, it's usually not much extra work to add a copy_to interface. The converse is not true.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nIf this is your first time writing an interface, start with copy_to.","category":"page"},{"location":"moi/manual/implementing/#The-copy_to-interface","page":"Implementing a solver interface","title":"The copy_to interface","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"To implement the copy_to interface, implement the following function:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"copy_to","category":"page"},{"location":"moi/manual/implementing/#The-incremental-interface","page":"Implementing a solver interface","title":"The incremental interface","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"warning: Warning\nWriting this interface is a lot of work. The easiest way is to consult the source code of a similar solver!","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"To implement the incremental interface, implement the following functions:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"add_variable\nadd_variables\nadd_constraint\nadd_constraints\nis_valid\ndelete","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"info: Info\nSolvers do not have to support AbstractScalarFunction in GreaterThan, LessThan, EqualTo, or Interval with a nonzero constant in the function. Throw ScalarFunctionConstantNotZero if the function constant is not zero.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"In addition, you should implement the following model attributes:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Attribute get set supports\nListOfModelAttributesSet Yes No No\nObjectiveFunctionType Yes No No\nObjectiveFunction Yes Yes Yes\nObjectiveSense Yes Yes Yes","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Variable-related attributes:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Attribute get set supports\nListOfVariableAttributesSet Yes No No\nNumberOfVariables Yes No No\nListOfVariableIndices Yes No No","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Constraint-related attributes:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Attribute get set supports\nListOfConstraintAttributesSet Yes No No\nNumberOfConstraints Yes No No\nListOfConstraints Yes No No\nConstraintFunction Yes Yes No\nConstraintSet Yes Yes No","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If your solver supports modifying data in-place, implement:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"modify\nScalarConstantChange\nScalarCoefficientChange\nVectorConstantChange\nMultirowChange","category":"page"},{"location":"moi/manual/implementing/#Variables-constrained-on-creation","page":"Implementing a solver interface","title":"Variables constrained on creation","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Some solvers require variables be associated with a set when they are created. This conflicts with the incremental modification approach, since you cannot first add a free variable and then constrain it to the set.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If this is the case, implement:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"add_constrained_variable\nadd_constrained_variables\nsupports_add_constrained_variables","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"By default, MathOptInterface assumes solvers support free variables. If your solver does not support free variables, define:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"MOI.supports_add_constrained_variables(::Optimizer, ::Type{Reals}) = false","category":"page"},{"location":"moi/manual/implementing/#Incremental-and-copy_to","page":"Implementing a solver interface","title":"Incremental and copy_to","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If you implement the incremental interface, you have the option of also implementing copy_to. If you don't want to implement copy_to, e.g., because the solver has no API for building the problem in a single function call, define the following fallback:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"function MOI.copy_to(dest::Optimizer, src::MOI.ModelLike; kwargs...)\n    return MOI.Utilities.automatic_copy_to(dest, src; kwargs...)\nend\n\nfunction MOI.Utilities.supports_default_copy_to(\n    model::Optimizer,\n    copy_names::Bool,\n)\n    # If you support names...\n    return true\n    # Otherwise...\n    return !copy_names\nend","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"See Utilities.supports_default_copy_to for more details.","category":"page"},{"location":"moi/manual/implementing/#implement_names","page":"Implementing a solver interface","title":"Names","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Regardless of which interface you implement, you have the option of implementing the Name attribute for variables and constraints:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Attribute get set supports\nVariableName Yes Yes Yes\nConstraintName Yes Yes Yes","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If you implement names, you should also implement the following three methods:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"function MOI.get(model::Optimizer, ::Type{MOI.VariableIndex}, name::String)\n    return # The variable named `name`.\nend\n\nfunction MOI.get(model::Optimizer, ::Type{MOI.ConstraintIndex}, name::String)\n    return # The constraint any type named `name`.\nend\n\nfunction MOI.get(\n    model::Optimizer,\n    ::Type{MOI.ConstraintIndex{F,S}},\n    name::String,\n) where {F,S}\n    return # The constraint of type F-in-S named `name`.\nend","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"These methods have the following rules:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If there is no variable or constraint with the name, return nothing\nIf there is a single variable or constraint with that name, return the variable or constraint\nIf there are multiple variables or constraints with the name, throw an error.","category":"page"},{"location":"moi/manual/implementing/#Solutions","page":"Implementing a solver interface","title":"Solutions","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Implement optimize! to solve the model:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"optimize!","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"At a minimum, implement the following attributes to allow the user to access solution information.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"TerminationStatus\nPrimalStatus\nDualStatus\nRawStatusString\nResultCount\nObjectiveValue\nVariablePrimal\nSolveTime","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"info: Info\nYou only need to implement get for solution attributes. Don't implement set or supports.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"note: Note\nSolver wrappers should document how the low-level statuses map to the MOI statuses. Statuses like NEARLY_FEASIBLE_POINT and INFEASIBLE_POINT, are designed to be used when the solver explicitly indicates that relaxed tolerances are satisfied or the returned point is infeasible, respectively.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nAttributes like VariablePrimal and ObjectiveValue are indexed by the result count. Use MOI.check_result_index_bounds(model, attr) to throw an error if the attribute is not available.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If your solver returns dual solutions, implement:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"ConstraintDual\nDualObjectiveValue","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For integer solvers, implement:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"ObjectiveBound\nRelativeGap","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If applicable, implement:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"SimplexIterations\nBarrierIterations\nNodeCount","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If your solver uses the Simplex method, implement:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"ConstraintBasisStatus","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If your solver accepts primal or dual warm-starts, implement:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"VariablePrimalStart\nConstraintDualStart","category":"page"},{"location":"moi/manual/implementing/#Other-tips","page":"Implementing a solver interface","title":"Other tips","text":"","category":"section"},{"location":"moi/manual/implementing/#Unsupported-constraints-at-runtime","page":"Implementing a solver interface","title":"Unsupported constraints at runtime","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"In some cases, your solver may support a particular type of constraint (e.g., quadratic constraints), but only if the data meets some condition (e.g., it is convex).","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"In this case, declare that you support the constraint, and throw AddConstraintNotAllowed.","category":"page"},{"location":"moi/manual/implementing/#Dealing-with-multiple-variable-bounds","page":"Implementing a solver interface","title":"Dealing with multiple variable bounds","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"MathOptInterface uses SingleVariable constraints to represent variable bounds. Defining multiple variable bounds on a single variable is not allowed.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Throw LowerBoundAlreadySet or UpperBoundAlreadySet if the user adds a constraint that results in multiple bounds.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Only throw if the constraints conflict. It is okay to add SingleVariable-in-GreaterThan and then SingleVariable-in-LessThan, but not SingleVariable-in-Interval and then SingleVariable-in-LessThan,","category":"page"},{"location":"moi/manual/implementing/#Expect-duplicate-coefficients","page":"Implementing a solver interface","title":"Expect duplicate coefficients","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Solvers should expect that functions such as ScalarAffineFunction and VectorQuadraticFunction may contain duplicate coefficents.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For example, ScalarAffineFunction([ScalarAffineTerm(x, 1), ScalarAffineTerm(x, 1)], 0.0).","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Use Utilities.canonical to return a new function with the duplicate coefficients aggregated together.","category":"page"},{"location":"moi/manual/implementing/#Don't-modify-user-data","page":"Implementing a solver interface","title":"Don't modify user-data","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"All data passed to the solver should be copied immediately to internal data structures. Solvers may not modify any input vectors and should assume that input vectors may be modified by users in the future.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"This applies, for example, to the terms vector in ScalarAffineFunction. Vectors returned to the user, e.g., via ObjectiveFunction or ConstraintFunction attributes, should not be modified by the solver afterwards. The in-place version of get! can be used by users to avoid extra copies in this case.","category":"page"},{"location":"moi/manual/implementing/#Column-Generation","page":"Implementing a solver interface","title":"Column Generation","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"There is no special interface for column generation. If the solver has a special API for setting coefficients in existing constraints when adding a new variable, it is possible to queue modifications and new variables and then call the solver's API once all of the new coefficients are known.","category":"page"},{"location":"moi/manual/implementing/#Extra:-solver-specific-attributes","page":"Implementing a solver interface","title":"Extra: solver-specific attributes","text":"","category":"section"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"You don't need to restrict yourself to the attributes defined in the MathOptInterface.jl package.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Solver-specific attributes should be specified by creating an appropriate subtype of AbstractModelAttribute, AbstractOptimizerAttribute, AbstractVariableAttribute, or AbstractConstraintAttribute.","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For example, Gurobi.jl adds attributes for multiobjective optimization by defining:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"struct NumberOfObjectives <: MOI.AbstractModelAttribute end\n\nfunction MOI.set(model::Optimizer, ::NumberOfObjectives, n::Integer)\n    # Code to set NumberOfOBjectives\n    return\nend\n\nfunction MOI.get(model::Optimizer, ::NumberOfObjectives)\n    n = # Code to get NumberOfobjectives\n    return n\nend","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Then, the user can write:","category":"page"},{"location":"moi/manual/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"model = Gurobi.Optimizer()\nMOI.set(model, Gurobi.NumberofObjectives(), 3)","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Bridges/overview/#The-Bridges-submodule","page":"Overview","title":"The Bridges submodule","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"The Bridges module simplifies the process of converting models between equivalent formulations.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"tip: Tip\nRead our paper for more details on how bridges are implemented.","category":"page"},{"location":"moi/submodules/Bridges/overview/#Why-bridges?","page":"Overview","title":"Why bridges?","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"A constraint can often be written in a number of equivalent formulations. For example, the constraint l le a^top x le u (ScalarAffineFunction-in-Interval) could be re-formulated as two constraints: a^top x ge l (ScalarAffineFunction-in-GreaterThan) and a^top x le u (ScalarAffineFunction-in-LessThan). An alternative re-formulation is to add a dummy variable y with the constraints l le y le u (SingleVariable-in-Interval) and a^top x - y = 0 (ScalarAffineFunction-in-EqualTo).","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"To avoid each solver having to code these transformations manually, MathOptInterface provides bridges.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"A bridge is a small transformation from one constraint type to another (potentially collection of) constraint type.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Because these bridges are included in MathOptInterface, they can be re-used by any optimizer. Some bridges also implement constraint modifications and constraint primal and dual translations.","category":"page"},{"location":"moi/submodules/Bridges/overview/#The-three-types-of-bridges","page":"Overview","title":"The three types of bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"There are three types of bridges in MathOptInterface:","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Constraint bridges\nVariable bridges\nObjective bridges","category":"page"},{"location":"moi/submodules/Bridges/overview/#Constraint-bridges","page":"Overview","title":"Constraint bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Constraint bridges convert constraints formulated by the user into an equivalent form supported by the solver.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"The equivalent formulation may add constraints (and possibly also variables) in the underlying model.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Read the list of implemented constraint bridges for more details on the types of transformations that are available.","category":"page"},{"location":"moi/submodules/Bridges/overview/#variable_bridges","page":"Overview","title":"Variable bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Variable bridges convert variables added by the user, either free with add_variable/add_variables, or constrained with add_constrained_variable/add_constrained_variables, into an equivalent form supported by the solver.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Te equivalent formulation may add constraints (and possibly also variables) in the underlying model.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Read the list of implemented variable bridges for more details on the types of transformations that are available.","category":"page"},{"location":"moi/submodules/Bridges/overview/#Objective-bridges","page":"Overview","title":"Objective bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Objective bridges convert the ObjectiveFunction set by the user into an equivalent form supported by the solver.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Te equivalent formulation may add constraints (and possibly also variables) in the underlying model.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Read the list of implemented objective bridges for more details on the types of transformations that are available.","category":"page"},{"location":"moi/submodules/Bridges/overview/#Bridges.full_bridge_optimizer","page":"Overview","title":"Bridges.full_bridge_optimizer","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"tip: Tip\nUnless you have an advanced use-case, this is probably the only function you need to care about.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"To enable the full power of MathOptInterface's bridges, wrap an optimizer in a Bridges.full_bridge_optimizer.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"julia> inner_optimizer = MOI.Utilities.Model{Float64}()\nMOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\n\njulia> optimizer = MOI.Bridges.full_bridge_optimizer(inner_optimizer, Float64)\nMOIB.LazyBridgeOptimizer{MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}}\nwith 0 variable bridges\nwith 0 constraint bridges\nwith 0 objective bridges\nwith inner model MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"That's all you have to do! Use optimizer as normal, and bridging will happen lazily behind the scenes. By lazily, we mean that bridging will only happen if the constraint is not supported by the inner_optimizer.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"info: Info\nMost bridges are added by default in Bridges.full_bridge_optimizer. However, for technical reasons, some bridges are not added by default. Three examples include Bridges.Constraint.SOCtoPSDBridge, Bridges.Constraint.SOCtoNonConvexQuadBridge and Bridges.Constraint.RSOCtoNonConvexQuadBridge. See the docs of those bridges for more information.","category":"page"},{"location":"moi/submodules/Bridges/overview/#Add-a-single-bridge","page":"Overview","title":"Add a single bridge","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"If you don't want to use Bridges.full_bridge_optimizer, you can wrap an optimizer in a single bridge.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"However, this will force the constraint to be bridged, even if the inner_optimizer supports it.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"julia> inner_optimizer = MOI.Utilities.Model{Float64}()\nMOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\n\njulia> optimizer = MOI.Bridges.Constraint.SplitInterval{Float64}(inner_optimizer)\nMOIB.Constraint.SingleBridgeOptimizer{MOIB.Constraint.SplitIntervalBridge{Float64,F,S,LS,US} where US<:MOI.AbstractSet where LS<:MOI.AbstractSet where S<:MOI.AbstractSet where F<:MOI.AbstractFunction,MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}}\nwith 0 constraint bridges\nwith inner model MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\n\njulia> x = MOI.add_variable(optimizer)\nMOI.VariableIndex(1)\n\njulia> MOI.add_constraint(optimizer, MOI.SingleVariable(x), MOI.Interval(0.0, 1.0))\nMathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.Interval{Float64}}(1)\n\njulia> MOI.get(optimizer, MOI.ListOfConstraints())\n1-element Array{Tuple{DataType,DataType},1}:\n (MathOptInterface.SingleVariable, MathOptInterface.Interval{Float64})\n\njulia> MOI.get(inner_optimizer, MOI.ListOfConstraints())\n2-element Array{Tuple{DataType,DataType},1}:\n (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64})\n (MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64})","category":"page"},{"location":"moi/submodules/Bridges/overview/#Bridges.LazyBridgeOptimizer","page":"Overview","title":"Bridges.LazyBridgeOptimizer","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"If you don't want to use Bridges.full_bridge_optimizer, but you need more than a single bridge (or you want the bridging to happen lazily), you can manually construct a Bridges.LazyBridgeOptimizer.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"First, wrap an inner optimizer:","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"julia> inner_optimizer = MOI.Utilities.Model{Float64}()\nMOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\n\njulia> optimizer = MOI.Bridges.LazyBridgeOptimizer(inner_optimizer)\nMOIB.LazyBridgeOptimizer{MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}}\nwith 0 variable bridges\nwith 0 constraint bridges\nwith 0 objective bridges\nwith inner model MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Then use Bridges.add_bridge to add individual bridges:","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Bridges.add_bridge(optimizer, MOI.Bridges.Constraint.SplitIntervalBridge{Float64})\nDict{Any,DataType} with 0 entries\n\njulia> MOI.Bridges.add_bridge(optimizer, MOI.Bridges.Objective.FunctionizeBridge{Float64})\nDict{Any,DataType} with 0 entries","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Now the constraints will be bridged only if needed:","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"julia> x = MOI.add_variable(optimizer)\nMOI.VariableIndex(1)\n\njulia> MOI.add_constraint(optimizer, MOI.SingleVariable(x), MOI.Interval(0.0, 1.0))\nMathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.Interval{Float64}}(1)\n\njulia> MOI.get(optimizer, MOI.ListOfConstraints())\n1-element Array{Tuple{DataType,DataType},1}:\n (MathOptInterface.SingleVariable, MathOptInterface.Interval{Float64})\n\njulia> MOI.get(inner_optimizer, MOI.ListOfConstraints())\n1-element Array{Tuple{DataType,DataType},1}:\n (MathOptInterface.SingleVariable, MathOptInterface.Interval{Float64})","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/network_flows.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/#Network-Flows","page":"Network Flows","title":"Network Flows","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"In graph theory, a flow network (also known as a transportation network) is a directed graph where each edge has a capacity and each edge receives a flow. The amount of flow on an edge cannot exceed the capacity of the edge.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Often in operations research, a directed graph is called a network, the vertices are called nodes and the edges are called arcs.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"A flow must satisfy the restriction that the amount of flow into a node equals the amount of flow out of it,  unless it is a source, which has only outgoing flow, or sink, which has only incoming flow.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"A network can be used to model traffic in a computer network, circulation with demands, fluids in pipes,  currents in an electrical circuit, or anything similar in which something travels through a network of nodes.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"using JuMP\nimport GLPK\nimport LinearAlgebra","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/#The-Shortest-Path-Problem","page":"Network Flows","title":"The Shortest Path Problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Suppose that each arc (i j) of a graph is assigned a scalar cost a_ij, and suppose that we define the cost of a forward path to be the sum of the costs of its arcs.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Given a pair of nodes, the shortest path problem is to find a forward path that connects these nodes and has minimum cost.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"beginaligned\nmin  sum_forall e(ij) in E a_ij times x_ij \nst  b(i) = sum_j x_ij - sum_k x_ki = begincases\n1 mboxif i is the starting node \n-1 mboxif i is the ending node \n0 mboxotherwise endcases \n x_e in 01  forall e in E\nendaligned","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"(Image: Flow Network 1)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"G = [\n    0 100 30  0  0;\n    0   0 20  0  0;\n    0   0  0 10 60;\n    0  15  0  0 50;\n    0   0  0  0  0;\n]\n\nn = size(G)[1]\n\nshortest_path = Model(GLPK.Optimizer)\n\n@variable(shortest_path, x[1:n,1:n], Bin)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Arcs with zero cost are not a part of the path as they do no exist","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"@constraint(shortest_path, [i = 1:n, j = 1:n; G[i,j] == 0], x[i,j] == 0)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Flow conservation constraint","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"@constraint(shortest_path, [i = 1:n; i != 1 && i != 2], sum(x[i,:]) == sum(x[:,i]))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Flow coming out of source = 1","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"@constraint(shortest_path, sum(x[1,:]) - sum(x[:,1]) == 1)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Flowing coming out of destination = -1 i.e. Flow entering destination = 1","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"@constraint(shortest_path, sum(x[2,:]) - sum(x[:,2]) == -1)\n@objective(shortest_path, Min, LinearAlgebra.dot(G, x))\n\noptimize!(shortest_path)\nobjective_value(shortest_path)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"value.(x)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/#The-Assignment-Problem","page":"Network Flows","title":"The Assignment Problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Suppose that there are n persons and n objects that we have to match on a one-to-one basis. There is a benefit or value a_ij for matching person i with object j, and we want to assign persons to objects so as to maximize the total benefit.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"There is also a restriction that person i can be assigned to object j only if (i j) belongs to a given set of pairs A.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Mathematically, we want to find a set of person-object pairs (1 j_1) (n j_n) from A such that the objects j_1j_n are all distinct, and the total benefit sum_i=1^y a_ij_i is maximized.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"beginaligned\nmax  sum_(ij) in A a_ij times y_ij \nst  sum_j(ij) in A y_ij = 1  forall i = 12n \n sum_i(ij) in A y_ij = 1  forall j = 12n \n y_ij in 01  forall (ij) in 12k\nendaligned","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"(Image: Flow Network 2)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"G = [\n    6 4 5 0;\n    0 3 6 0;\n    5 0 4 3;\n    7 5 5 5;\n]\n\nn = size(G)[1]\n\nassignment = Model(GLPK.Optimizer)\n@variable(assignment, y[1:n,1:n], Bin)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"One person can only be assigned to one object","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"@constraint(assignment, [i = 1:n], sum(y[:,i]) == 1)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"One object can only be assigned to one person","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"@constraint(assignment, [j = 1:n], sum(y[j,:]) == 1)\n@objective(assignment, Max, LinearAlgebra.dot(G, y))\n\noptimize!(assignment)\nobjective_value(assignment)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"value.(y)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/#The-Max-Flow-Problem","page":"Network Flows","title":"The Max-Flow Problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"In the max-flow problem, we have a graph with two special nodes: the source, denoted by s, and the sink, denoted by t.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"The objective is to move as much flow as possible from s into t while observing the capacity constraints.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"beginaligned\nmax  sum_v(sv) in E f(sv) \nst  sum_u(uv) in E f(uv)  = sum_w(vw) in E f(vw)  forall v in V - st \n f(uv) leq c(uv)  forall (uv) in E \n f(uv) geq 0  forall (uv) in E\nendaligned","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"(Image: Flow Network 3)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"G = [\n    0 3 2 2 0 0 0 0;\n    0 0 0 0 5 1 0 0;\n    0 0 0 0 1 3 1 0;\n    0 0 0 0 0 1 0 0;\n    0 0 0 0 0 0 0 4;\n    0 0 0 0 0 0 0 2;\n    0 0 0 0 0 0 0 4;\n    0 0 0 0 0 0 0 0;\n]\n\nn = size(G)[1]\n\nmax_flow = Model(GLPK.Optimizer)\n\n@variable(max_flow, f[1:n,1:n] >= 0)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Capacity constraints","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"@constraint(max_flow, [i = 1:n, j = 1:n], f[i,j] <= G[i,j])","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Flow conservation constraints","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"@constraint(max_flow, [i = 1:n; i != 1 && i != 8], sum(f[i,:]) == sum(f[:,i]))\n@objective(max_flow, Max, sum(f[1, :]))\n\noptimize!(max_flow)\nobjective_value(max_flow)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"value.(f)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"This page was generated using Literate.jl.","category":"page"},{"location":"developers/style/#Style-guide-and-design-principles","page":"Style Guide","title":"Style guide and design principles","text":"","category":"section"},{"location":"developers/style/#Style-guide","page":"Style Guide","title":"Style guide","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"This section describes the coding style rules that apply to JuMP code and that we recommend for JuMP models and surrounding Julia code. The motivations for a style guide include:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"conveying best practices for writing readable and maintainable code\nreducing the amount of time spent on bike-shedding by establishing basic naming and formatting conventions\nlowering the barrier for new contributors by codifying the existing practices (e.g., you can be more confident your code will pass review if you follow the style guide)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"In some cases, the JuMP style guide diverges from the Julia style guide. All such cases will be explicitly noted and justified.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"The JuMP style guide adopts many recommendations from the Google style guides.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"info: Info\nThe style guide is always a work in progress, and not all JuMP code follows the rules. When modifying JuMP, please fix the style violations of the surrounding code (i.e., leave the code tidier than when you started). If large changes are needed, consider separating them into another PR.","category":"page"},{"location":"developers/style/#JuliaFormatter","page":"Style Guide","title":"JuliaFormatter","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"JuMP uses JuliaFormatter.jl as an autoformatting tool.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"We use the options contained in .JuliaFormatter.toml.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"To format code, cd to the JuMP directory, then run:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"] add JuliaFormatter@0.13.2\nusing JuliaFormatter\nformat(\"src\")\nformat(\"test\")","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"info: Info\nA continuous integration check verifies that all PRs made to JuMP have passed the formatter.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"The following sections outline extra style guide points that are not fixed automatically by JuliaFormatter.","category":"page"},{"location":"developers/style/#Whitespace","page":"Style Guide","title":"Whitespace","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For conciseness, never use more than one blank line within a function, and never begin a function with a blank line.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"function foo(x)\n    y = 2 * x\n\n\n    return y\nend\n\nfunction foo(x)\n\n    y = 2 * x\n    return y\nend","category":"page"},{"location":"developers/style/#Juxtaposed-multiplication","page":"Style Guide","title":"Juxtaposed multiplication","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Only use juxtaposed multiplication when the right-hand side is a symbol.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"2x  # Acceptable if there are space constraints.\n2 * x  # This is preferred if space is not an issue.\n2 * (x + 1)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"2(x + 1)","category":"page"},{"location":"developers/style/#Empty-vectors","page":"Style Guide","title":"Empty vectors","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For a type T, T[] and Vector{T}() are equivalent ways to create an empty vector with element type T. Prefer T[] because it is more concise.","category":"page"},{"location":"developers/style/#Comments","page":"Style Guide","title":"Comments","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For non-native speakers and for general clarity, comments in code must be proper English sentences with appropriate punctuation.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"# This is a comment demonstrating a good comment.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"# a bad comment","category":"page"},{"location":"developers/style/#JuMP-macro-syntax","page":"Style Guide","title":"JuMP macro syntax","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For consistency, always use parentheses.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable model x >= 0","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For consistency, always use constant * variable as opposed to variable * constant. This makes it easier to read models in ambiguous cases like a * x.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"a = 4\n@constraint(model, 3 * x <= 1)\n@constraint(model, a * x <= 1)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"a = 4\n@constraint(model, x * 3 <= 1)\n@constraint(model, x * a <= 1)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"In order to reduce boilerplate code, prefer the plural form of macros over lots of repeated calls to singular forms.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variables(model, begin\n    x >= 0\n    y >= 1\n    z <= 2\nend)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0)\n@variable(model, y >= 1)\n@variable(model, z <= 2)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"An exception is made for calls with many keyword arguments, since these need to be enclosed in parentheses in order to parse properly.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Acceptable:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0, start = 0.0, base_name = \"my_x\")\n@variable(model, y >= 1, start = 2.0)\n@variable(model, z <= 2, start = -1.0)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Also acceptable:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variables(model, begin\n    x >= 0, (start = 0.0, base_name = \"my_x\")\n    y >= 1, (start = 2.0)\n    z <= 2, (start = -1.0)\nend)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"While we always use in for for-loops, it is acceptable to use = in the container declarations of JuMP macros.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Okay:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x[i=1:3])","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Also okay:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x[i in 1:3])","category":"page"},{"location":"developers/style/#Naming","page":"Style Guide","title":"Naming","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"module SomeModule end\nfunction some_function end\nconst SOME_CONSTANT = ...\nstruct SomeStruct\n  some_field::SomeType\nend\n@enum SomeEnum ENUM_VALUE_A ENUM_VALUE_B\nsome_local_variable = ...\nsome_file.jl # Except for ModuleName.jl.","category":"page"},{"location":"developers/style/#Exported-and-non-exported-names","page":"Style Guide","title":"Exported and non-exported names","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Begin private module level functions and constants with an underscore. All other objects in the scope of a module should be exported. (See JuMP.jl for an example of how to do this.)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Names beginning with an underscore should only be used for distinguishing between exported (public) and non-exported (private) objects. Therefore, never begin the name of a local variable with an underscore.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"module MyModule\n\nexport public_function, PUBLIC_CONSTANT\n\nfunction _private_function()\n    local_variable = 1\n    return\nend\n\nfunction public_function end\n\nconst _PRIVATE_CONSTANT = 3.14159\nconst PUBLIC_CONSTANT = 1.41421\n\nend","category":"page"},{"location":"developers/style/#Use-of-underscores-within-names","page":"Style Guide","title":"Use of underscores within names","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"The Julia style guide recommends avoiding underscores \"when readable\", for example, haskey, isequal, remotecall, and remotecall_fetch. This convention creates the potential for unnecessary bikeshedding and also forces the user to recall the presence/absence of an underscore, e.g., \"was that argument named basename or base_name?\". For consistency, always use underscores in variable names and function names to separate words.","category":"page"},{"location":"developers/style/#Use-of-!","page":"Style Guide","title":"Use of !","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Julia has a convention of appending ! to a function name if the function modifies its arguments. We recommend to:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Omit ! when the name itself makes it clear that modification is taking place, e.g., add_constraint and set_name. We depart from the Julia style guide because ! does not provide a reader with any additional information in this case, and adherence to this convention is not uniform even in base Julia itself (consider Base.println and Base.finalize).\nUse ! in all other cases. In particular it can be used to distinguish between modifying and non-modifying variants of the same function like scale and scale!.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Note that ! is not a self-documenting feature because it is still ambiguous which arguments are modified when multiple arguments are present. Be sure to document which arguments are modified in the method's docstring.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"See also the Julia style guide recommendations for ordering of function arguments.","category":"page"},{"location":"developers/style/#Abbreviations","page":"Style Guide","title":"Abbreviations","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Abbreviate names to make the code more readable, not to save typing. Don't arbitrarily delete letters from a word to abbreviate it (e.g., indx). Use abbreviations consistently within a body of code (e.g., do not mix con and constr, idx and indx).","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Common abbreviations:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"num for number\ncon for constraint","category":"page"},{"location":"developers/style/#No-one-letter-variable-names","page":"Style Guide","title":"No one-letter variable names","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Where possible, avoid one-letter variable names.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Use model = Model() instead of m = Model()","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Exceptions are made for indices in loops.","category":"page"},{"location":"developers/style/#User-facing-MethodError","page":"Style Guide","title":"User-facing MethodError","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Specifying argument types for methods is mostly optional in Julia, which means that it's possible to find out that you are working with unexpected types deep in the call chain. Avoid this situation or handle it with a helpful error message. A user should see a MethodError only for methods that they called directly.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"_internal_function(x::Integer) = x + 1\n# The user sees a MethodError for _internal_function when calling\n# public_function(\"a string\"). This is not very helpful.\npublic_function(x) = _internal_function(x)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"_internal_function(x::Integer) = x + 1\n# The user sees a MethodError for public_function when calling\n# public_function(\"a string\"). This is easy to understand.\npublic_function(x::Integer) = _internal_function(x)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"If it is hard to provide an error message at the top of the call chain, then the following pattern is also ok:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"_internal_function(x::Integer) = x + 1\nfunction _internal_function(x)\n    error(\n        \"Internal error. This probably means that you called \" *\n        \"public_function() with the wrong type.\",\n    )\nend\npublic_function(x) = _internal_function(x)","category":"page"},{"location":"developers/style/#@enum-vs.-Symbol","page":"Style Guide","title":"@enum vs. Symbol","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"The @enum macro lets you define types with a finite number of values that are explicitly enumerated (like enum in C/C++). Symbols are lightweight strings that are used to represent identifiers in Julia (for example, :x).","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@enum provides type safety and can have docstrings attached to explain the possible values. Use @enums when applicable, e.g., for reporting statuses. Use strings to provide long-form additional information like error messages.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Use of Symbol should typically be reserved for identifiers, e.g., for lookup in the JuMP model (model[:my_variable]).","category":"page"},{"location":"developers/style/#using-vs.-import","page":"Style Guide","title":"using vs. import","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"using ModuleName brings all symbols exported by the module ModuleName into scope, while import ModuleName brings only the module itself into scope. (See the Julia manual) for examples and more details.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For the same reason that from <module> import * is not recommended in python (PEP 8), avoid using ModuleName except in throw-away scripts or at the REPL. The using statement makes it harder to track where symbols come from and exposes the code to ambiguities when two modules export the same symbol.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Prefer using ModuleName: x, p to import ModuleName.x, ModuleName.p and import MyModule: x, p because the import versions allow method extension without qualifying with the module name.","category":"page"},{"location":"developers/style/#Documentation","page":"Style Guide","title":"Documentation","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"This section describes the writing style that should be used when writing documentation for JuMP (and supporting packages).","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"We can recommend the documentation style guides by Divio, Google, and Write the Docs as general reading for those writing documentation. This guide delegates a thorough handling of the topic to those guides and instead elaborates on the points more specific to Julia and documentation that use Documenter.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Be concise\nUse lists instead of long sentences\nUse numbered lists when describing a sequence, e.g., (1) do X, (2) then Y\nUse bullet points when the items are not ordered\nExample code should be covered by doctests\nWhen a word is a Julia symbol and not an English word, enclose it with backticks. In addition, if it has a docstring in this doc add a link using @ref. If it is a plural, add the \"s\" after the closing backtick. For example,\n[`VariableRef`](@ref)s\nUse @meta blocks for TODOs and other comments that shouldn't be visible to readers. For example,\n```@meta\n# TODO: Mention also X, Y, and Z.\n```","category":"page"},{"location":"developers/style/#Docstrings","page":"Style Guide","title":"Docstrings","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Every exported object needs a docstring\nAll examples in docstrings should be jldoctests\nAlways use complete English sentences with proper punctuation\nDo not terminate lists with punctuation (e.g., as in this doc)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Here is an example:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"\"\"\"\n    signature(args; kwargs...)\n\nShort sentence describing the function.\n\nOptional: add a slightly longer paragraph describing the function.\n\n## Notes\n\n - List any notes that the user should be aware of\n\n## Examples\n\n```jldoctest\njulia> 1 + 1\n2\n```\n\"\"\"","category":"page"},{"location":"developers/style/#Testing","page":"Style Guide","title":"Testing","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Use a module to encapsulate tests, and structure all tests as functions. This avoids leaking local variables between tests.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Here is a basic skeleton:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"module TestPkg\n\nusing Test\n\n_helper_function() = 2\n\nfunction test_addition()\n    @test 1 + 1 == _helper_function()\nend\n\nfunction runtests()\n    for name in names(@__MODULE__; all = true)\n        if startswith(\"$(name)\", \"test_\")\n            @testset \"$(name)\" begin\n                getfield(@__MODULE__, name)()\n            end\n        end\n    end\nend\n\nend # TestPkg\n\nTestPkg.runtests()","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Break the tests into multiple files, with one module per file, so that subsets of the codebase can be tested by calling include with the relevant file.","category":"page"},{"location":"developers/style/#Design-principles","page":"Style Guide","title":"Design principles","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"TODO: How to structure and test large JuMP models, libraries that use JuMP.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For how to write a solver, see MOI.","category":"page"},{"location":"developers/roadmap/#Development-roadmap","page":"Roadmap","title":"Development roadmap","text":"","category":"section"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"This page is not JuMP documentation per se but are notes for the JuMP community. The JuMP developers have compiled this roadmap document to share their plans and goals. Contributions to roadmap issues are especially invited.","category":"page"},{"location":"developers/roadmap/#JuMP-1.0","page":"Roadmap","title":"JuMP 1.0","text":"","category":"section"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"JuMP 1.0 will be ready to release roughly when all of these tasks are completed. Some but not all of these tasks are summarized in the JuMP 1.0 milestone.","category":"page"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"Create a website for JuMP (Done: jump.dev)\nDeprecate the JuliaOpt organization and move repositories to the JuMP-dev organization (Done)\nAddress major regressions from JuMP 0.18\nPerformance (#1403,              #1654,              #1607)\nCallbacks (Done: see examples/callbacks.jl)\nColumn generation syntax (Done: see examples/cutting_stock_column_generation.jl)\nSupport for second-order cones in Gurobi, CPLEX, and Xpress (Done)\nFix issues that we promised MOI would fix\nChecking feasibility of solutions (Done: #2466)\nAccessing IIS (Done: see Conflicts)\nAccessing multiple results from solvers (Done: Gurobi#392)\nDual warm-starts (Done: #2214)\nAddress \"easy\" usability issues\nLine numbers in error messages (Done: #2276)\nLP sensitivity summary (Done: see Sensitivity analysis for LP)\nInferred element types for collections in macros (Done: #2070)\nExpose solver-independent options from JuMP (Done: see set_silent etc.)\nImprove the documentation (#1062)\nSeparate how-to, concept explanation, and technical reference following the Divio recommendations (Done)\nFully integrate JuMPTutorials with JuMP's documentation (Done)\nDeveloper experience\nGet JuMP's unit tests running faster. See #1745. (Done)\nAll solvers should complete the transition to MOI (Done)\nProvide packages for installing Bonmin and Couenne (Done)\nMathOptFormat 1.0 (Done)","category":"page"},{"location":"developers/roadmap/#MOI-1.0","page":"Roadmap","title":"MOI 1.0","text":"","category":"section"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"# TODO: List MOI 1.0 items here.","category":"page"},{"location":"developers/roadmap/#Beyond-JuMP-1.0","page":"Roadmap","title":"Beyond JuMP 1.0","text":"","category":"section"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"# TODO: Copy over list of items not tied to JuMP 1.0. These should have more\n# elaborate explanations so that potential contributors know what we mean,\n# i.e., a few sentences each or a link to a document/issue.","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Bridges/implementation/#Bridge-interface","page":"Implementation","title":"Bridge interface","text":"","category":"section"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"A bridge should implement the following functions to be usable by a bridge optimizer:","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"Bridges.added_constrained_variable_types\nBridges.added_constraint_types","category":"page"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.added_constrained_variable_types","page":"Implementation","title":"MathOptInterface.Bridges.added_constrained_variable_types","text":"added_constrained_variable_types(BT::Type{<:Variable.AbstractBridge})::Vector{Tuple{DataType}}\n\nReturn a list of the types of constrained variables that bridges of concrete type BT add. This is used by the LazyBridgeOptimizer.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.added_constraint_types","page":"Implementation","title":"MathOptInterface.Bridges.added_constraint_types","text":"added_constraint_types(BT::Type{<:Constraint.AbstractBridge})::Vector{Tuple{DataType, DataType}}\n\nReturn a list of the types of constraints that bridges of concrete type BT add. This is used by the LazyBridgeOptimizer.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"Additionally, variable bridges should implement:","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"Bridges.Variable.supports_constrained_variable\nBridges.Variable.concrete_bridge_type\nBridges.Variable.bridge_constrained_variable","category":"page"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.Variable.supports_constrained_variable","page":"Implementation","title":"MathOptInterface.Bridges.Variable.supports_constrained_variable","text":"supports_constrained_variable(::Type{<:AbstractBridge},\n                               ::Type{<:MOI.AbstractSet})::Bool\n\nReturn a Bool indicating whether the bridges of type BT support bridging constrained variables in S.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.Variable.concrete_bridge_type","page":"Implementation","title":"MathOptInterface.Bridges.Variable.concrete_bridge_type","text":"concrete_bridge_type(\n    BT::Type{<:AbstractBridge},\n    S::Type{<:MOI.AbstractSet},\n)::DataType\n\nReturn the concrete type of the bridge supporting variables in S constraints. This function can only be called if MOI.supports_constrained_variable(BT, S) is true.\n\nExamples\n\nAs a variable in MathOptInterface.GreaterThan is bridged into variables in MathOptInterface.Nonnegatives by the VectorizeBridge:\n\nMOI.Bridges.Variable.concrete_bridge_type(\n    MOI.Bridges.Variable.VectorizeBridge{Float64},\n    MOI.GreaterThan{Float64},\n)\n\n# output\n\nMathOptInterface.Bridges.Variable.VectorizeBridge{Float64,MathOptInterface.Nonnegatives}\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.Variable.bridge_constrained_variable","page":"Implementation","title":"MathOptInterface.Bridges.Variable.bridge_constrained_variable","text":"bridge_constrained_variable(BT::Type{<:AbstractBridge}, model::MOI.ModelLike,\n                            set::MOI.AbstractSet)\n\nBridge the constrained variable in set using bridge BT to model and returns a bridge object of type BT. The bridge type BT should be a concrete type, that is, all the type parameters of the bridge should be set. Use concrete_bridge_type to obtain a concrete type for given set types.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"constraint bridges should implement:","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"supports_constraint(::Type{<:Bridges.Constraint.AbstractBridge}, ::Type{<:AbstractFunction}, ::Type{<:AbstractSet})\nBridges.Constraint.concrete_bridge_type\nBridges.Constraint.bridge_constraint","category":"page"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.supports_constraint-Tuple{Type{#s938} where #s938<:MathOptInterface.Bridges.Constraint.AbstractBridge,Type{#s937} where #s937<:MathOptInterface.AbstractFunction,Type{#s936} where #s936<:MathOptInterface.AbstractSet}","page":"Implementation","title":"MathOptInterface.supports_constraint","text":"MOI.supports_constraint(BT::Type{<:AbstractBridge}, F::Type{<:MOI.AbstractFunction}, S::Type{<:MOI.AbstractSet})::Bool\n\nReturn a Bool indicating whether the bridges of type BT support bridging F-in-S constraints.\n\n\n\n\n\n","category":"method"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.Constraint.concrete_bridge_type","page":"Implementation","title":"MathOptInterface.Bridges.Constraint.concrete_bridge_type","text":"concrete_bridge_type(\n    BT::Type{<:AbstractBridge},\n    F::Type{<:MOI.AbstractFunction},\n    S::Type{<:MOI.AbstractSet}\n)::DataType\n\nReturn the concrete type of the bridge supporting F-in-S constraints. This function can only be called if MOI.supports_constraint(BT, F, S) is true.\n\nExamples\n\nAs a MathOptInterface.SingleVariable-in-MathOptInterface.Interval constraint is bridged into a MathOptInterface.SingleVariable-in-MathOptInterface.GreaterThan and a MathOptInterface.SingleVariable-in-MathOptInterface.LessThan by the SplitIntervalBridge:\n\nMOI.Bridges.Constraint.concrete_bridge_type(\n    MOI.Bridges.Constraint.SplitIntervalBridge{Float64},\n    MOI.SingleVariable,\n    MOI.Interval{Float64},\n)\n\n# output\n\nMathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64,MathOptInterface.SingleVariable,MathOptInterface.Interval{Float64},MathOptInterface.GreaterThan{Float64},MathOptInterface.LessThan{Float64}}\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.Constraint.bridge_constraint","page":"Implementation","title":"MathOptInterface.Bridges.Constraint.bridge_constraint","text":"bridge_constraint(BT::Type{<:AbstractBridge}, model::MOI.ModelLike,\n                  func::AbstractFunction, set::MOI.AbstractSet)\n\nBridge the constraint func-in-set using bridge BT to model and returns a bridge object of type BT. The bridge type BT should be a concrete type, that is, all the type parameters of the bridge should be set. Use concrete_bridge_type to obtain a concrete type for given function and set types.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"and objective bridges should implement:","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"Bridges.set_objective_function_type\nBridges.Objective.concrete_bridge_type\nBridges.Objective.bridge_objective","category":"page"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.set_objective_function_type","page":"Implementation","title":"MathOptInterface.Bridges.set_objective_function_type","text":"set_objective_function_type(BT::Type{<:Objective.AbstractBridge})::Type{<:MOI.AbstractScalarFunction}\n\nReturn the type of objective function that bridges of concrete type BT set. This is used by the LazyBridgeOptimizer.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.Objective.concrete_bridge_type","page":"Implementation","title":"MathOptInterface.Bridges.Objective.concrete_bridge_type","text":"concrete_bridge_type(BT::Type{<:MOI.Bridges.Objective.AbstractBridge},\n                     F::Type{<:MOI.AbstractScalarFunction})::DataType\n\nReturn the concrete type of the bridge supporting objective functions of type F. This function can only be called if MOI.supports_objective_function(BT, F) is true.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.Objective.bridge_objective","page":"Implementation","title":"MathOptInterface.Bridges.Objective.bridge_objective","text":"bridge_objective(BT::Type{<:MOI.Bridges.Objective.AbstractBridge},\n                 model::MOI.ModelLike,\n                 func::MOI.AbstractScalarFunction)\n\nBridge the objective function func using bridge BT to model and returns a bridge object of type BT. The bridge type BT should be a concrete type, that is, all the type parameters of the bridge should be set. Use concrete_bridge_type to obtain a concrete type for a given function type.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"When querying the NumberOfVariables, NumberOfConstraints and ListOfConstraintIndices, the variables and constraints created by the bridges in the underlying model are hidden by the bridge optimizer. For this purpose, the bridge should provide access to the variables and constraints it has creates by implemented the following methods of get:","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"get(::Bridges.Constraint.AbstractBridge, ::NumberOfVariables)\nget(::Bridges.Constraint.AbstractBridge, ::ListOfVariableIndices)\nget(::Bridges.AbstractBridge, ::NumberOfConstraints)\nget(::Bridges.AbstractBridge, ::ListOfConstraintIndices)","category":"page"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.get-Tuple{MathOptInterface.Bridges.Constraint.AbstractBridge,MathOptInterface.NumberOfVariables}","page":"Implementation","title":"MathOptInterface.get","text":"MOI.get(b::AbstractBridge, ::MOI.NumberOfVariables)\n\nThe number of variables created by the bridge b in the model.\n\n\n\n\n\n","category":"method"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.get-Tuple{MathOptInterface.Bridges.Constraint.AbstractBridge,MathOptInterface.ListOfVariableIndices}","page":"Implementation","title":"MathOptInterface.get","text":"MOI.get(b::AbstractBridge, ::MOI.NumberOfVariables)\n\nThe list of variables created by the bridge b in the model.\n\n\n\n\n\n","category":"method"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.get-Tuple{MathOptInterface.Bridges.AbstractBridge,MathOptInterface.NumberOfConstraints}","page":"Implementation","title":"MathOptInterface.get","text":"MOI.get(b::AbstractBridge, ::MOI.NumberOfConstraints{F, S}) where {F, S}\n\nThe number of constraints of the type F-in-S created by the bridge b in the model.\n\n\n\n\n\n","category":"method"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.get-Tuple{MathOptInterface.Bridges.AbstractBridge,MathOptInterface.ListOfConstraintIndices}","page":"Implementation","title":"MathOptInterface.get","text":"MOI.get(b::AbstractBridge, ::MOI.ListOfConstraintIndices{F, S}) where {F, S}\n\nA Vector{ConstraintIndex{F,S}} with indices of all constraints of type F-inS created by the bride b in the model (i.e., of length equal to the value of NumberOfConstraints{F,S}()).\n\n\n\n\n\n","category":"method"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Benchmarks/overview/#The-Benchmarks-submodule","page":"Overview","title":"The Benchmarks submodule","text":"","category":"section"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"To aid the development of efficient solver wrappers, MathOptInterface provides benchmarking functionality. Benchmarking a wrapper follows a two-step process.","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"First, prior to making changes, run and save the benchmark results on a given benchmark suite as follows:","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"using SolverPackage  # Replace with your choice of solver.\n\nusing MathOptInterface\nconst MOI = MathOptInterface\n\nsuite = MOI.Benchmarks.suite() do\n    SolverPackage.Optimizer()\nend\n\nMOI.Benchmarks.create_baseline(\n    suite, \"current\"; directory = \"/tmp\", verbose = true\n)","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"Use the exclude argument to Benchmarks.suite to exclude benchmarks that the solver doesn't support.","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"Second, after making changes to the package, re-run the benchmark suite and compare to the prior saved results:","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"using SolverPackage, MathOptInterface\n\nconst MOI = MathOptInterface\n\nsuite = MOI.Benchmarks.suite() do\n    SolverPackage.Optimizer()\nend\n\nMOI.Benchmarks.compare_against_baseline(\n    suite, \"current\"; directory = \"/tmp\", verbose = true\n)","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"This comparison will create a report detailing improvements and regressions.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Test/overview/#test_module","page":"Overview","title":"The Test submodule","text":"","category":"section"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"The Test submodule provides tools to help solvers implement unit tests in order to ensure they implement the MathOptInterface API correctly, and to check for solver-correctness.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"We use a centralized repository of tests, so that if we find a bug in one solver, instead of adding a test to that particular repository, we add it here so that all solvers can benefit.","category":"page"},{"location":"moi/submodules/Test/overview/#How-to-test-a-solver","page":"Overview","title":"How to test a solver","text":"","category":"section"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"The skeleton below can be used for the wrapper test file of a solver named FooBar. Remove unnecessary tests as appropriate, for example tests for features that the solver does not support (tests are not skipped depending on the value of supports). ","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"# ============================ /test/MOI_wrapper.jl ============================\nmodule TestFoobar\n\nimport FooBar\nusing MathOptInterface\nusing Test\n\nconst MOI = MathOptInterface\n\nconst OPTIMIZER_CONSTRUCTOR = MOI.OptimizerWithAttributes(\n    FooBar.Optimizer,\n    MOI.Silent() => true\n)\nconst OPTIMIZER = MOI.instantiate(OPTIMIZER_CONSTRUCTOR)\n\nconst BRIDGED = MOI.instantiate(\n    OPTIMIZER_CONSTRUCTOR, with_bridge_type = Float64\n)\nconst CONFIG = MOI.Test.TestConfig(\n    # Modify tolerances as necessary.\n    atol = 1e-6,\n    rtol = 1e-6,\n    # Set false if dual solutions are not generated\n    duals = true,\n    # Set false if infeasibility certificates are not generated\n    infeas_certificates = true,\n    # Use MOI.LOCALLY_SOLVED for local solvers.\n    optimal_status = MOI.OPTIMAL,\n    # Set true if basis information is available\n    basis = false,\n)\n\nfunction test_SolverName()\n    @test MOI.get(OPTIMIZER, MOI.SolverName()) == \"FooBar\"\nend\n\nfunction test_supports_default_copy_to()\n    @test MOI.Utilities.supports_default_copy_to(OPTIMIZER, false)\n    # Use `@test !...` if names are not supported\n    @test MOI.Utilities.supports_default_copy_to(OPTIMIZER, true)\nend\n\nfunction test_unittest()\n    # Test all the functions included in dictionary `MOI.Test.unittests`,\n    # except functions \"number_threads\" and \"solve_qcp_edge_cases.\"\n    MOI.Test.unittest(\n        BRIDGED,\n        CONFIG,\n        [\"number_threads\", \"solve_qcp_edge_cases\"]\n    )\nend\n\nfunction test_modification()\n    MOI.Test.modificationtest(BRIDGED, CONFIG)\nend\n\nfunction test_contlinear()\n    MOI.Test.contlineartest(BRIDGED, CONFIG)\nend\n\nfunction test_contquadratictest()\n    MOI.Test.contquadratictest(OPTIMIZER, CONFIG)\nend\n\nfunction test_contconic()\n    MOI.Test.contlineartest(BRIDGED, CONFIG)\nend\n\nfunction test_intconic()\n    MOI.Test.intconictest(BRIDGED, CONFIG)\nend\n\nfunction test_default_objective_test()\n    MOI.Test.default_objective_test(OPTIMIZER)\nend\n\nfunction test_default_status_test()\n    MOI.Test.default_status_test(OPTIMIZER)\nend\n\nfunction test_nametest()\n    MOI.Test.nametest(OPTIMIZER)\nend\n\nfunction test_validtest()\n    MOI.Test.validtest(OPTIMIZER)\nend\n\nfunction test_emptytest()\n    MOI.Test.emptytest(OPTIMIZER)\nend\n\nfunction test_orderedindicestest()\n    MOI.Test.orderedindicestest(OPTIMIZER)\nend\n\nfunction test_scalar_function_constant_not_zero()\n    MOI.Test.scalar_function_constant_not_zero(OPTIMIZER)\nend\n\n# This function runs all functions in this module starting with `test_`.\nfunction runtests()\n    for name in names(@__MODULE__; all = true)\n        if startswith(\"$(name)\", \"test_\")\n            @testset \"$(name)\" begin\n                getfield(@__MODULE__, name)()\n            end\n        end\n    end\nend\n\nend # module TestFooBar\n\nTestFooBar.runtests()","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Test functions like MOI.Test.unittest and MOI.Test.modificationtest are wrappers around corresponding dictionaries MOI.Test.unittests and MOI.Test.modificationtests. Exclude tests by passing a vector of strings corresponding to the test keys you want to exclude as the third positional argument to the test function.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"tip: Tip\nPrint a list of all keys using println.(keys(MOI.Test.unittests))","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"The optimizer BRIDGED constructed with instantiate automatically bridges constraints that are not supported by OPTIMIZER using the bridges listed in Bridges. It is recommended for an implementation of MOI to only support constraints that are natively supported by the solver and let bridges transform the constraint to the appropriate form. For this reason it is expected that tests may not pass if OPTIMIZER is used instead of BRIDGED.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"To test that a specific problem can be solved without bridges, a specific test can be added with OPTIMIZER instead of BRIDGED. For example:","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"function test_interval_constraints()\n    MOI.Test.linear10test(OPTIMIZER, CONFIG)\nend","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"checks that OPTIMIZER implements support for ScalarAffineFunction-in-Interval.","category":"page"},{"location":"moi/submodules/Test/overview/#How-to-add-a-test","page":"Overview","title":"How to add a test","text":"","category":"section"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"To give an example, ECOS errored calling optimize! twice in a row. (See ECOS.jl PR #72.)","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"We could add a test to ECOS.jl, but that would only stop us from re-introducing the bug to ECOS.jl in the future.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Instead, if we add a test to MOI.Test, then all solvers will also check that they handle a double optimize call!","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"For this test, we care about correctness, rather than performance. therefore, we don't expect solvers to efficiently decide that they have already solved the problem, only that calling optimize! twice doesn't throw an error or give the wrong answer.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"To resolve this issue, follow these steps (tested on Julia v1.5):","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Install the MathOptInterface julia package in dev mode (ref):\njulia> ]\n(@v1.5) pkg> dev ECOS\n(@v1.5) pkg> dev MathOptInterface\nFrom here on, proceed with making the following changes in the ~/.julia/dev/MathOptInterface folder (or equivalent dev path on your machine).\nSince the double-optimize error involves solving an optimization problem, add a new test to src/Test/UnitTests/solve.jl. The test should be something like\nfunction solve_twice(model::MOI.ModelLike, config::TestConfig)\n    MOI.empty!(model)\n    x = MOI.add_variable(model)\n    c = MOI.add_constraint(model, MOI.SingleVariable(x), MOI.GreaterThan(1.0))\n    MOI.set(model, MOI.ObjectiveSense(), MOI.MIN_SENSE)\n    MOI.set(model, MOI.ObjectiveFunction{MOI.SingleVariable}(), MOI.SingleVariable(x))\n    if config.solve\n        MOI.optimize!(model)\n        MOI.optimize!(model)\n        MOI.get(model, MOI.TerminationStatus()) == MOI.OPTIMAL\n        MOI.get(model, MOI.VariablePrimal(), x) == 1.0\n    end\nend\nunittests[\"solve_twice\"] = solve_twice\nAdd a test for the test you just wrote. (We test the tests!) a. Add the name of the test (\"solve_twice\") to the end of the array in    MOI.Test.unittest(...) (link).  b. Add a test for the test towards the end of the \"Unit Tests\" test set     (link).     The test should look something like     julia     @testset \"solve_twice\" begin      MOI.Utilities.set_mock_optimize!(mock,          (mock::MOI.Utilities.MockOptimizer) -> MOI.Utilities.mock_optimize!(              mock,              MOI.OPTIMAL,              (MOI.FEASIBLE_POINT, [1.0]),          ),          (mock::MOI.Utilities.MockOptimizer) -> MOI.Utilities.mock_optimize!(              mock,              MOI.OPTIMAL,              (MOI.FEASIBLE_POINT, [1.0]),              )          )          MOI.Test.solve_twice(mock, config)      end      In the above mock is a MOI.Utilities.MockOptimizer that is defined      tesearlier in the file. In this test, MOI.Utilities.set_mock_optimize! loads      mock with two results. Each says that the      TerminationStatus is MOI.OPTIMAL, that the      PrimalStatus is MOI.FEASIBLE_POINT, and that there is one      variable with a MOI.VariableValue or 1.0\nRun the tests:\n(@v1.5) pkg> test ECOS\nFinally, commit the changes to git from ~/.julia/dev/MathOptInterface and submit the PR for review.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/knapsack.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/knapsack/#The-knapsack-problem","page":"The knapsack problem","title":"The knapsack problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"Formulate and solve a simple knapsack problem:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"max sum(p_j x_j)\n st sum(w_j x_j) <= C\n    x binary","category":"page"},{"location":"tutorials/Mixed-integer linear programs/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_knapsack(; verbose = true)\n    profit = [5, 3, 2, 7, 4]\n    weight = [2, 8, 4, 2, 5]\n    capacity = 10\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:5], Bin)\n    # Objective: maximize profit\n    @objective(model, Max, profit' * x)\n    # Constraint: can carry all\n    @constraint(model, weight' * x <= capacity)\n    # Solve problem using MIP solver\n    optimize!(model)\n    if verbose\n        println(\"Objective is: \", objective_value(model))\n        println(\"Solution is:\")\n        for i in 1:5\n            print(\"x[$i] = \", value(x[i]))\n            println(\", p[$i]/w[$i] = \", profit[i] / weight[i])\n        end\n    end\n    Test.@test termination_status(model) == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) == 16.0\n    return\nend\n\nexample_knapsack()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"‚â§|<=\", r\"‚â•|>=\", r\" == | = \", r\" ‚àà | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/nlp/#Nonlinear-Modeling","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP has support for general smooth nonlinear (convex and nonconvex) optimization problems. JuMP is able to provide exact, sparse second-order derivatives to solvers. This information can improve solver accuracy and performance.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"There are three main changes to solve nonlinear programs in JuMP.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use @NLobjective instead of @objective\nUse @NLconstraint instead of @constraint\nUse @NLexpression instead of @expression","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"info: Info\nThere are some restrictions on what syntax you can use in the @NLxxx macros. Make sure to read the Syntax notes.","category":"page"},{"location":"manual/nlp/#Set-a-nonlinear-objective","page":"Nonlinear Modeling","title":"Set a nonlinear objective","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use @NLobjective to set a nonlinear objective.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLobjective(model, Min, exp(x[1]) - sqrt(x[2]))","category":"page"},{"location":"manual/nlp/#Add-a-nonlinear-constraint","page":"Nonlinear Modeling","title":"Add a nonlinear constraint","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use @NLconstraint to add a nonlinear constraint.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLconstraint(model, exp(x[1]) <= 1)\nexp(x[1]) - 1.0 ‚â§ 0\n\njulia> @NLconstraint(model, [i = 1:2], x[i]^i >= i)\n2-element Array{ConstraintRef{Model,NonlinearConstraintIndex,ScalarShape},1}:\n x[1] ^ 1.0 - 1.0 ‚â• 0\n x[2] ^ 2.0 - 2.0 ‚â• 0\n\njulia> @NLconstraint(model, con[i = 1:2], prod(x[j] for j = 1:i) == i)\n2-element Array{ConstraintRef{Model,NonlinearConstraintIndex,ScalarShape},1}:\n (*)(x[1]) - 1.0 = 0\n x[1] * x[2] - 2.0 = 0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"info: Info\nYou can only create nonlinear constraints with <=, >=, and ==. More general Nonlinear-in-Set constraints are not supported.","category":"page"},{"location":"manual/nlp/#Create-a-nonlinear-expression","page":"Nonlinear Modeling","title":"Create a nonlinear expression","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use @NLexpression to create nonlinear expression objects. The syntax is identical to @expression, except that the expression can contain nonlinear terms.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> expr = @NLexpression(model, exp(x[1]) + sqrt(x[2]))\n\"Reference to nonlinear expression #1\"\n\njulia> my_anon_expr = @NLexpression(model, [i = 1:2], sin(x[i]))\n2-element Array{NonlinearExpression,1}:\n \"Reference to nonlinear expression #2\"\n \"Reference to nonlinear expression #3\"\n\njulia> @NLexpression(model, my_expr[i = 1:2], sin(x[i]))\n2-element Array{NonlinearExpression,1}:\n \"Reference to nonlinear expression #4\"\n \"Reference to nonlinear expression #5\"","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear expression can be used in @NLobjective, @NLconstraint, and even nested in other @NLexpressions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLobjective(model, Min, expr^2 + 1)\n\njulia> @NLconstraint(model, [i = 1:2], my_expr[i] <= i)\n2-element Array{ConstraintRef{Model,NonlinearConstraintIndex,ScalarShape},1}:\n subexpression[4] - 1.0 ‚â§ 0\n subexpression[5] - 2.0 ‚â§ 0\n\njulia> @NLexpression(model, nested[i = 1:2], sin(my_expr[i]))\n2-element Array{NonlinearExpression,1}:\n \"Reference to nonlinear expression #6\"\n \"Reference to nonlinear expression #7\"","category":"page"},{"location":"manual/nlp/#Create-a-nonlinear-parameter","page":"Nonlinear Modeling","title":"Create a nonlinear parameter","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For nonlinear models only, JuMP offers a syntax for explicit \"parameter\" objects, which are constants in the model that can be efficiently updated between solves.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear parameters are declared by using the @NLparameter macro and may be indexed by arbitrary sets analogously to JuMP variables and expressions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The initial value of the parameter must be provided on the right-hand side of the == sign.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLparameter(model, p[i = 1:2] == i)\n2-element Array{NonlinearParameter,1}:\n \"Reference to nonlinear parameter #1\"\n \"Reference to nonlinear parameter #2\"","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"info: Info\nA parameter is not an optimization variable. It must be fixed to a value with ==. If you want a parameter that is <= or >=, create a variable instead using @variable.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use value and set_value to query or update the value of a parameter.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> value.(p)\n2-element Array{Float64,1}:\n 1.0\n 2.0\n\njulia> set_value(p[2], 3.0)\n3.0\n\njulia> value.(p)\n2-element Array{Float64,1}:\n 1.0\n 3.0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"info: Info\nThere is no anonymous syntax for creating parameters.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear parameters can be used within nonlinear macros only:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @objective(model, Max, p[1] * x)\nERROR: MethodError: no method matching *(::NonlinearParameter, ::VariableRef)\n[...]\n\njulia> @NLobjective(model, Max, p[1] * x)\n\njulia> @expression(model, my_expr, p[1] * x^2)\nERROR: MethodError: no method matching *(::NonlinearParameter, ::GenericQuadExpr{Float64,VariableRef})\n[...]\n\njulia> @NLexpression(model, my_nl_expr, p[1] * x^2)\n\"Reference to nonlinear expression #1\"","category":"page"},{"location":"manual/nlp/#When-to-use-a-parameter","page":"Nonlinear Modeling","title":"When to use a parameter","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear parameters are useful when solving nonlinear models in a sequence:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP, Ipopt\nmodel = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, z)\n@NLparameter(model, x == 1.0)\n@NLobjective(model, Min, (z - x)^2)\noptimize!(model)\n@show value(z) # Equals 1.0.\n\n# Now, update the value of x to solve a different problem.\nset_value(x, 5.0)\noptimize!(model)\n@show value(z) # Equals 5.0\nnothing #hide","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"info: Info\nUsing nonlinear parameters can be faster than creating a new model from scratch with updated data because JuMP is able to avoid repeating a number of steps in processing the model before handing it off to the solver.","category":"page"},{"location":"manual/nlp/#Syntax-notes","page":"Nonlinear Modeling","title":"Syntax notes","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The syntax accepted in nonlinear macros is more restricted than the syntax for linear and quadratic macros. We note some important points below.","category":"page"},{"location":"manual/nlp/#No-operator-overloading","page":"Nonlinear Modeling","title":"No operator overloading","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"There is no operator overloading provided to build up nonlinear expressions. For example, if x is a JuMP variable, the code 3x will return an AffExpr object that can be used inside of future expressions and linear constraints. However, the code sin(x) is an error. All nonlinear expressions must be inside of macros.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> expr = sin(x) + 1\nERROR: sin is not defined for type AbstractVariableRef. Are you trying to build a nonlinear problem? Make sure you use @NLconstraint/@NLobjective.\n[...]\n\njulia> expr = @NLexpression(model, sin(x) + 1)\n\"Reference to nonlinear expression #1\"","category":"page"},{"location":"manual/nlp/#Scalar-operations-only","page":"Nonlinear Modeling","title":"Scalar operations only","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"With the exception of the splatting syntax discussed below, all expressions must be simple scalar operations. You cannot use dot, matrix-vector products, vector slices, etc. ","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLobjective(model, Min, c' * x + 3y)\nERROR: Unexpected array [1 2] in nonlinear expression. Nonlinear expressions may contain only scalar expressions.\n[...]","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Translate vector operations into explicit sum() operations:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLobjective(model, Min, sum(c[i] * x[i] for i = 1:2) + 3y)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Or use an @expression:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @expression(model, expr, c' * x)\nx[1] + 2 x[2]\n\njulia> @NLobjective(model, Min, expr + 3y)\n","category":"page"},{"location":"manual/nlp/#Splatting","page":"Nonlinear Modeling","title":"Splatting","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The splatting operator   ... is recognized in a very restricted setting for expanding function   arguments. The expression splatted can be only a symbol. More complex   expressions are not recognized.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x[1:3]);\n\njulia> @NLconstraint(model, *(x...) <= 1.0)\nx[1] * x[2] * x[3] - 1.0 ‚â§ 0\n\njulia> @NLconstraint(model, *((x / 2)...) <= 0.0)\nERROR: LoadError: Unexpected expression in (*)(x / 2...). JuMP supports splatting only symbols. For example, x... is ok, but (x + 1)..., [x; y]... and g(f(y)...) are not.","category":"page"},{"location":"manual/nlp/#User-defined-Functions","page":"Nonlinear Modeling","title":"User-defined Functions","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP's library of recognized univariate functions is derived from the Calculus.jl package.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"In addition to this list of functions, it is possible to register custom user-defined nonlinear functions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"tip: Tip\nUser-defined functions can be used anywhere in @NLobjective, @NLconstraint, and @NLexpression.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"tip: Tip\nJuMP will attempt to automatically register functions it detects in your nonlinear expressions, which means that in most cases, manually registering a function is not needed. Two exceptions are if you want to provide custom derivatives, or if the function is not available in the scope of the nonlinear expression.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nUser-defined functions must return a scalar output. For a work-around, see User-defined functions with vector outputs.","category":"page"},{"location":"manual/nlp/#Automatic-differentiation","page":"Nonlinear Modeling","title":"Automatic differentiation","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP does not support black-box optimization, so all user-defined functions must provide derivatives in some form.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Fortunately, JuMP supports automatic differentiation of user-defined functions, a feature to our knowledge not available in any comparable modeling systems.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"info: Info\nAutomatic differentiation is not finite differencing. JuMP's automatically computed derivatives are not subject to approximation error.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP uses ForwardDiff.jl to perform automatic differentiation; see the ForwardDiff.jl documentation for a description of how to write a function suitable for automatic differentiation.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nGet an error like No method matching Float64(::ForwardDiff.Dual)? Read this section, and see the guidelines at ForwardDiff.jl.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The most common error is that your user-defined function is not generic with respect to the number type, i.e., don't assume that the input to the function is Float64.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"f(x::Float64) = 2 * x  # This will not work.\nf(x::Real)    = 2 * x  # This is good.\nf(x)          = 2 * x  # This is also good.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Another reason you may encounter this error is if you create arrays inside your function which are Float64.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"function bad_f(x...)\n    y = zeros(length(x))  # This constructs an array of `Float64`!\n    for i = 1:length(x)\n        y[i] = x[i]^i\n    end\n    return sum(y)\nend\n\nfunction good_f(x::T...) where {T<:Real}\n    y = zeros(T, length(x))  # Construct an array of type `T` instead!\n    for i = 1:length(x)\n        y[i] = x[i]^i\n    end\n    return sum(y)\nend","category":"page"},{"location":"manual/nlp/#Register-a-function","page":"Nonlinear Modeling","title":"Register a function","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"To register a user-defined function with derivatives computed by automatic differentiation, use the register method as in the following example:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP #hide\nsquare(x) = x^2\nf(x, y) = (x - 1)^2 + (y - 2)^2\n\nmodel = Model()\n\nregister(model, :square, 1, square; autodiff = true)\nregister(model, :my_f, 2, f; autodiff = true)\n\n@variable(model, x[1:2] >= 0.5)\n@NLobjective(model, Min, my_f(x[1], square(x[2])))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The above code creates a JuMP model with the objective function (x[1] - 1)^2 + (x[2]^2 - 2)^2. The arguments to register are:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The model for which the functions are registered.\nA Julia symbol object which serves as the name of the user-defined function in JuMP expressions.\nThe number of input arguments that the function takes.\nThe Julia method which computes the function\nA flag to instruct JuMP to compute exact gradients automatically.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"tip: Tip\nThe symbol :my_f doesn't have to match the name of the function f. However, it's generally more readable if it does. Make sure you use my_f and not f in the macros.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nIf you use multi-variate user-defined functions, JuMP will disable second-derivative information. This can lead to significant slow-downs in some cases. Only use a user-defined function if you cannot write out the expression algebraically in the macro.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nUser-defined functions cannot be re-registered and will not update if you modify the underlying Julia function. If you want to change a user-defined function between solves, rebuild the model or use a different name. To use a different name programmatically, see Raw expression input.","category":"page"},{"location":"manual/nlp/#Register-a-function-and-gradient","page":"Nonlinear Modeling","title":"Register a function and gradient","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Forward-mode automatic differentiation as implemented by ForwardDiff.jl has a computational cost that scales linearly with the number of input dimensions. As such, it is not the most efficient way to compute gradients of user-defined functions if the number of input arguments is large. In this case, users may want to provide their own routines for evaluating gradients.","category":"page"},{"location":"manual/nlp/#Univariate-functions","page":"Nonlinear Modeling","title":"Univariate functions","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For univariate functions, the gradient function ‚àáf should return a number that represents the first-order derivative:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP #hide\nf(x) = x^2\n‚àáf(x) = 2x\nmodel = Model()\nregister(model, :my_square, 1, f, ‚àáf; autodiff = true)\n@variable(model, x >= 0)\n@NLobjective(model, Min, my_square(x))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"If autodiff = true, JuMP will use automatic differentiation to compute the hessian.","category":"page"},{"location":"manual/nlp/#Multivariate-functions","page":"Nonlinear Modeling","title":"Multivariate functions","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For multivariate functions, the gradient function ‚àáf must take a gradient vector as the first argument that is filled in-place:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP #hide\nf(x, y) = (x - 1)^2 + (y - 2)^2\nfunction ‚àáf(g::Vector{T}, x::T, y::T) where {T}\n    g[1] = 2 * (x - 1)\n    g[2] = 2 * (y - 2)\n    return\nend\n\nmodel = Model()\nregister(model, :my_square, 2, f, ‚àáf)\n@variable(model, x[1:2] >= 0)\n@NLobjective(model, Min, my_square(x[1], x[2]))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Hessian information is not supported for multivariate functions.","category":"page"},{"location":"manual/nlp/#Register-a-function,-gradient,-and-hessian","page":"Nonlinear Modeling","title":"Register a function, gradient, and hessian","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nThe ability to explicitly register a hessian is only available for univariate functions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Instead of automatically differentiating the hessian, you can instead pass a function which returns a number representing the second-order derivative.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP #hide\nf(x) = x^2\n‚àáf(x) = 2x\n‚àá¬≤f(x) = 2\nmodel = Model()\nregister(model, :my_square, 1, f, ‚àáf, ‚àá¬≤f)\n@variable(model, x >= 0)\n@NLobjective(model, Min, my_square(x))","category":"page"},{"location":"manual/nlp/#User-defined-functions-with-vector-inputs","page":"Nonlinear Modeling","title":"User-defined functions with vector inputs","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"User-defined functions which take vectors as input arguments (e.g. f(x::Vector)) are not supported. Instead, use Julia's splatting syntax to create a function with scalar arguments. For example, instead of","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"f(x::Vector) = sum(x[i]^i for i in 1:length(x))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"define:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"f(x...) = sum(x[i]^i for i in 1:length(x))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This function f can be used in a JuMP model as follows:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP #hide\nmodel = Model()\n@variable(model, x[1:5] >= 0)\nf(x...) = sum(x[i]^i for i in 1:length(x))\nregister(model, :f, 5, f; autodiff = true)\n@NLobjective(model, Min, f(x...))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"tip: Tip\nMake sure to read the syntax restrictions of Splatting.","category":"page"},{"location":"manual/nlp/#Factors-affecting-solution-time","page":"Nonlinear Modeling","title":"Factors affecting solution time","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The execution time when solving a nonlinear programming problem can be divided into two parts, the time spent in the optimization algorithm (the solver) and the time spent evaluating the nonlinear functions and corresponding derivatives. Ipopt explicitly displays these two timings in its output, for example:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Total CPU secs in IPOPT (w/o function evaluations)   =      7.412\nTotal CPU secs in NLP function evaluations           =      2.083","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For Ipopt in particular, one can improve the performance by installing advanced sparse linear algebra packages, see Installation Guide. For other solvers, see their respective documentation for performance tips.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The function evaluation time, on the other hand, is the responsibility of the modeling language. JuMP computes derivatives by using reverse-mode automatic differentiation with graph coloring methods for exploiting sparsity of the Hessian matrix [1]. As a conservative bound, JuMP's performance here currently may be expected to be within a factor of 5 of AMPL's.","category":"page"},{"location":"manual/nlp/#Querying-derivatives-from-a-JuMP-model","page":"Nonlinear Modeling","title":"Querying derivatives from a JuMP model","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For some advanced use cases, one may want to directly query the derivatives of a JuMP model instead of handing the problem off to a solver. Internally, JuMP implements the AbstractNLPEvaluator interface from MathOptInterface. To obtain an NLP evaluator object from a JuMP model, use NLPEvaluator. index returns the MOI.VariableIndex corresponding to a JuMP variable. MOI.VariableIndex itself is a type-safe wrapper for Int64 (stored in the .value field.)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For example:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"raw_index(v::MOI.VariableIndex) = v.value\nmodel = Model()\n@variable(model, x)\n@variable(model, y)\n@NLobjective(model, Min, sin(x) + sin(y))\nvalues = zeros(2)\nx_index = raw_index(JuMP.index(x))\ny_index = raw_index(JuMP.index(y))\nvalues[x_index] = 2.0\nvalues[y_index] = 3.0\nd = NLPEvaluator(model)\nMOI.initialize(d, [:Grad])\nMOI.eval_objective(d, values) # == sin(2.0) + sin(3.0)\n\n# output\n1.0504174348855488","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"‚àáf = zeros(2)\nMOI.eval_objective_gradient(d, ‚àáf, values)\n(‚àáf[x_index], ‚àáf[y_index]) # == (cos(2.0), cos(3.0))\n\n# output\n(-0.4161468365471424, -0.9899924966004454)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Only nonlinear constraints (those added with @NLconstraint), and nonlinear objectives (added with @NLobjective) exist in the scope of the NLPEvaluator.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The NLPEvaluator does not evaluate derivatives of linear or quadratic constraints or objectives.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The index method applied to a nonlinear constraint reference object returns its index as a NonlinearConstraintIndex. The .value field of NonlinearConstraintIndex stores the raw integer index. For example:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @NLconstraint(model, cons1, sin(x) <= 1);\n\njulia> @NLconstraint(model, cons2, x + 5 == 10);\n\njulia> typeof(cons1)\nConstraintRef{Model,NonlinearConstraintIndex,ScalarShape}\n\njulia> index(cons1)\nNonlinearConstraintIndex(1)\n\njulia> index(cons2)\nNonlinearConstraintIndex(2)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"# TODO: Provide a link for how to access the linear and quadratic parts of the\n# model.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Note that for one-sided nonlinear constraints, JuMP subtracts any values on the right-hand side when computing expressions. In other words, one-sided nonlinear constraints are always transformed to have a right-hand side of zero.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This method of querying derivatives directly from a JuMP model is convenient for interacting with the model in a structured way, e.g., for accessing derivatives of specific variables. For example, in statistical maximum likelihood estimation problems, one is often interested in the Hessian matrix at the optimal solution, which can be queried using the NLPEvaluator.","category":"page"},{"location":"manual/nlp/#Raw-expression-input","page":"Nonlinear Modeling","title":"Raw expression input","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nThis section requires advanced knowledge of Julia's Expr. You should read the Expressions and evaluation section of the Julia documentation first.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"In addition to the @NLobjective and @NLconstraint macros, it is also possible to provide Julia Expr objects directly by using set_NL_objective and add_NL_constraint.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This input form may be useful if the expressions are generated programmatically.","category":"page"},{"location":"manual/nlp/#Set-the-objective-function","page":"Nonlinear Modeling","title":"Set the objective function","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use set_NL_objective to set a nonlinear objective.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> expr = :($(x) + $(x)^2)\n:(x + x ^ 2)\n\njulia> set_NL_objective(model, MOI.MIN_SENSE, expr)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This is equivalent to","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLobjective(model, Min, x + x^2)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"note: Note\nYou must interpolate the variables directly into the expression expr.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"note: Note\nYou must use MOI.MIN_SENSE or MOI.MAX_SENSE instead of Min and Max.","category":"page"},{"location":"manual/nlp/#Add-a-constraint","page":"Nonlinear Modeling","title":"Add a constraint","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use add_NL_constraint to add a nonlinear constraint.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> expr = :($(x) + $(x)^2)\n:(x + x ^ 2)\n\njulia> add_NL_constraint(model, :($(expr) <= 1))\n(x + x ^ 2.0) - 1.0 ‚â§ 0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This is equivalent to","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLconstraint(model, Min, x + x^2 <= 1)\n(x + x ^ 2.0) - 1.0 ‚â§ 0","category":"page"},{"location":"manual/nlp/#More-complicated-examples","page":"Nonlinear Modeling","title":"More complicated examples","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Raw expression input is most useful when the expressions are generated programmatically, often in conjunction with user-defined functions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"As an example, we construct a model with the nonlinear constraints f(x) <= 1, where f(x) = x^2 and f(x) = sin(x)^2:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> function main(functions::Vector{Function})\n           model = Model()\n           @variable(model, x)\n           for (i, f) in enumerate(functions)\n               f_sym = Symbol(\"f_$(i)\")\n               register(model, f_sym, 1, f; autodiff = true)\n               add_NL_constraint(model, :($(f_sym)($(x)) <= 1))\n           end\n           print(model)\n           return\n       end\nmain (generic function with 1 method)\n\njulia> main([x -> x^2, x -> sin(x)^2])\nFeasibility\nSubject to\n f_1(x) - 1.0 ‚â§ 0\n f_2(x) - 1.0 ‚â§ 0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"As another example, we construct a model with the constraint x^2 + sin(x)^2 <= 1:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> function main(functions::Vector{Function})\n           model = Model()\n           @variable(model, x)\n           expr = Expr(:call, :+)\n           for (i, f) in enumerate(functions)\n               f_sym = Symbol(\"f_$(i)\")\n               register(model, f_sym, 1, f; autodiff = true)\n               push!(expr.args, :($(f_sym)($(x))))\n           end\n           add_NL_constraint(model, :($(expr) <= 1))\n           print(model)\n           return\n       end\nmain (generic function with 1 method)\n\njulia> main([x -> x^2, x -> sin(x)^2])\nFeasibility\nSubject to\n (f_1(x) + f_2(x)) - 1.0 ‚â§ 0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"[1]: Dunning, Huchette, and Lubin, \"JuMP: A Modeling Language for Mathematical Optimization\", SIAM Review, PDF.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Semidefinite programs/experiment_design.jl\"","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/#Experiment-Design","page":"Experiment Design","title":"Experiment Design","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"Originally Contributed by: Arpit Bhatia, Chris Coey","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"This tutorial covers experiment design examples (D-optimal, A-optimal, and E-optimal) from section 7.5 of the book Convex Optimization by Boyd and Vandenberghe.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"The tutorial uses the following packages","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"using JuMP\nimport SCS\nimport LinearAlgebra\nimport Random","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"We set a seed so the random numbers are repeatable:","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"Random.seed!(1234)","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/#Relaxed-Experiment-Design-Problem","page":"Experiment Design","title":"Relaxed Experiment Design Problem","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"The basic experiment design problem is as follows.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"Given the menu of possible choices for experiments, v_1 ldots v_p, and the total number m of experiments to be carried out, choose the numbers of each type of experiment, i.e., m_1 ldots m_p to make the error covariance E small (in  some sense).","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"The variables m_1 ldots m_p must, of course, be integers and sum to m the given total number of experiments. This leads to the optimization problem:","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"beginaligned\nminleft(mathrmwrt mathbfS_+^nright)  E=left(sum_j=1^p m_j v_j v_j^Tright)^-1 \ntextsubject to  m_i geq 0 \n sumlimits_i=1^p m_i = m \n m_i in mathbbZquad i=1ldotsp\nendaligned","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"The basic experiment design problem can be a hard combinatorial problem when m, the total number of experiments, is comparable to n, since in this case the m_i are all small integers.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"In the case when m is large compared to n, however, a good approximate solution can be found by ignoring, or relaxing, the constraint that the m_i are integers.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"Let lambda_i=m_i  m which is the fraction of the total number of experiments for which a_j=v_i or the relative frequency of experiment i. We can express the error covariance in terms of lambda_i as:","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"E=frac1mleft(sum_i=1^p lambda_i v_i v_i^Tright)^-1","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"The vector lambda in mathbfR^p satisfies lambda succeq 0 mathbf1^T lambda=1 and also, each lambda_i is an integer multiple of 1  m. By ignoring this last constraint, we arrive at the problem:","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"beginaligned\nminleft(mathrmwrt mathbfS_+^nright)  E=(1  m)left(sum_i=1^p lambda_i v_i v_i^Tright)^-1 \ntextsubject toquad  lambda succeq 0 \n mathbf1^T lambda=1\nendaligned","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"Several scalarizations have been proposed for the experiment design problem, which is a vector optimization problem over the positive semidefinite cone.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"q = 4 # dimension of estimate space\np = 8 # number of experimental vectors\nnmax = 3 # upper bound on lambda\nn = 12\n\nV = randn(q, p)\n\neye = Matrix{Float64}(LinearAlgebra.I, q, q);\nnothing #hide","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/#A-optimal-design","page":"Experiment Design","title":"A-optimal design","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"In A-optimal experiment design, we minimize tr E, the trace of the covariance matrix. This objective is simply the mean of the norm of the error squared:","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"mathbfEe_2^2=mathbfE operatornametrleft(e e^Tright)=operatornametr E","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"The A-optimal experiment design problem in SDP form is","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"beginaligned\nmin  mathbf1^T u \ntextsubject to  leftbeginalignedsum_i=1^p lambda_i v_i v_i^T  e_k  e_k^T  u_kendalignedright succeq 0 quad k=1 ldots n \n lambda succeq 0 \n  mathbf1^T lambda=1\nendaligned","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"aOpt = Model(SCS.Optimizer)\nset_silent(aOpt)\n@variable(aOpt, np[1:p], lower_bound = 0, upper_bound = nmax)\n@variable(aOpt, u[1:q], lower_bound = 0)\n@constraint(aOpt, sum(np) <= n)\nfor i = 1:q\n    matrix = [\n        V * LinearAlgebra.diagm(0 => np ./ n) * V' eye[:, i];\n        eye[i, :]' u[i]\n    ]\n    @SDconstraint(aOpt, matrix >= 0)\nend\n@objective(aOpt, Min, sum(u))\noptimize!(aOpt)\nobjective_value(aOpt)","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"value.(np)","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/#E-optimal-design","page":"Experiment Design","title":"E-optimal design","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"In E -optimal design, we minimize the norm of the error covariance matrix, i.e. the maximum eigenvalue of E.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"Since the diameter (twice the longest semi-axis) of the confidence ellipsoid mathcalE is proportional to E_2^1  2, minimizing E_2 can be interpreted geometrically as minimizing the diameter of the confidence ellipsoid.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"E-optimal design can also be interpreted as minimizing the maximum variance of q^T e, over all q with q_2=1. The E-optimal experiment design problem in SDP form is:","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"beginaligned\nmin  t \ntextsubject to  sum_i=1^p lambda_i v_i v_i^T succeq t I \n lambda succeq 0 \n mathbf1^T lambda=1\nendaligned","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"eOpt = Model(SCS.Optimizer)\nset_silent(eOpt)\n@variable(eOpt, 0 <= np[1:p] <= nmax)\n@variable(eOpt, t)\n@SDconstraint(eOpt, V * LinearAlgebra.diagm(0 => np ./ n) * V' - (t .* eye) >= 0)\n@constraint(eOpt, sum(np) <= n)\n@objective(eOpt, Max, t)\noptimize!(eOpt)\nobjective_value(eOpt)","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"value.(np)","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/#D-optimal-design","page":"Experiment Design","title":"D-optimal design","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"The most widely used scalarization is called D -optimal design, in which we minimize the determinant of the error covariance matrix E. This corresponds to designing the experiment to minimize the volume of the resulting confidence ellipsoid (for a fixed confidence level). Ignoring the constant factor 1  m in E, and taking the logarithm of the objective, we can pose this problem as convex optimization problem:","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"beginaligned\nmin  log operatornamedetleft(sum_i=1^p lambda_i v_i v_i^Tright)^-1 \ntextsubject to  lambda succeq 0 \n mathbf1^T lambda=1\nendaligned","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"dOpt = Model(SCS.Optimizer)\nset_silent(dOpt)\n@variable(dOpt, np[1:p], lower_bound = 0, upper_bound = nmax)\n@variable(dOpt, t)\n@objective(dOpt, Max, t)\n@constraint(dOpt, sum(np) <= n)\nE = V * LinearAlgebra.diagm(0 => np ./ n) * V'\n@constraint(\n    dOpt,\n    [t, 1, (E[i, j] for i in 1:q for j in 1:i)...] in MOI.LogDetConeTriangle(q)\n)\noptimize!(dOpt)\nobjective_value(dOpt)","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"value.(np)","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"View this file on Github.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Optimization concepts/benders_decomposition.jl\"","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#Benders-Decomposition","page":"Benders Decomposition","title":"Benders Decomposition","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Originally Contributed by: Shuvomoy Das Gupta","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"This notebook describes how to implement Benders decomposition in JuMP, which is a large scale optimization scheme.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"We only discuss the classical approach (using loops) here. The approach using lazy constraints is showed in the corresponding tutorial.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"To illustrate an implementation of the Benders decomposition in JuMP, we apply it to the following general mixed integer problem:","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"beginaligned\n textmaximize quad c_1^T x+c_2^T v \n textsubject to quad A_1 x+ A_2 v preceq b \n x succeq 0 x in mathbbZ^n \n v succeq 0 v in mathbbR^p \nendaligned","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"where b in mathbbR^m, A_1 in mathbbR^m times n, A_2 in mathbbR^m times p and mathbbZ is the set of integers.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Here the symbol succeq (preceq) stands for element-wise greater (less) than or equal to. Any mixed integer programming problem can be written in the form above.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"We want to write the Benders decomposition algorithm for the problem above. Consider the polyhedron u in mathbbR^m A_2^T u succeq 0 u succeq 0. Assume the set of vertices and extreme rays of the polyhedron is denoted by P and Q respectively.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Assume on the kth iteration the subset of vertices of the polyhedron mentioned is denoted by T(k) and the subset of extreme rays are denoted by Q(k), which will be generated by the Benders decomposition problem below.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#Benders-decomposition-algorithm","page":"Benders Decomposition","title":"Benders decomposition algorithm","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Step 1 (Initialization)","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"We start with T(1)=Q(1)=emptyset. Let f_m^(1) be arbitrarily large and x^(1) be any non-negative integer vector and go to Step 2.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Step 2 (Solving the master problem)","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Solve the master problem, f_textm^(k) =","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"beginaligned\ntextmaximize quad t \ntextsubject to quad forall baru in T(k) qquad t + (A_1^T baru - c_1)^T x leq b^T baru \n  forall bary in Q(k) qquad (A_1 ^T bary)^T x leq b^T bary \n  qquad qquad qquad  x succeq 0 x in mathbbZ^n\nendaligned","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Let the maximizer corresponding to the objective value f_textm^(k) be denoted by x^(k). Now there are three possibilities:","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"If f_textm^(k)=-infty, i.e., the master problem is infeasible, then the original proble is infeasible and sadly, we are done.\nIf f_textm^(k)=infty, i.e. the master problem is unbounded above, then we take f_textm^(k) to be arbitrarily large and x^(k) to be a corresponding feasible solution. Go to Step 3.\nIf f_textm^(k) is finite, then we collect t^(k) and x^(k) and go to Step 3.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Step 3 (Solving the subproblem and add Benders cut when needed)","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Solve the subproblem, f_s(x^(k)) =","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"beginaligned\n  c_1^T x^(k) +  textminimize   (b-A_1 x^(k))^T u \n   textsubject to  A_2^T u succeq c_2 \n    u succeq 0 u in mathbbR^m\nendaligned","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Let the minimizer corresponding to the objective value f_s(x^(k)) be denoted by u^(k). There are three possibilities:","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"If f_s(x^(k)) = infty, the original problem is either infeasible or unbounded. We quit from Benders algorithm and use special purpose algorithm to find a feasible solution if there exists one.\nIf f_s(x^(k)) = - infty, we arrive at an extreme ray y^(k). We add the Benders cut corresponding to this extreme ray (A_1 ^T y^(k))^T x leq b^T y^(k) to the master problem, i.e., Q(k+1)= Q(k) cup y^(k). Take k=k+1 and go to Step 3.\nIf f_s(x^(k)) is finite, then\nIf f_s(x^(k))=f_m^(k) we arrive at the optimal solution.  The optimum objective value of the original problem is f_s(x^(k))=f_m^(k),  an optimal x is x^(k) and an optimal v is the dual values for the  second constraints of the subproblem. We are happily done!\nIf f_s(x^(k))  f_m^(k) we get an suboptimal vertex u^(k). We add  the corresponding Benders cut u_0 + (A_1^T u^(k) - c_1)^T x leq b^T u^(k)  to the master problem, i.e., T(k+1) = T(k) cup u^(k). Take k=k+1  and go to Step 3.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"For a more general approach to Bender's Decomposition you can have a look at Mathieu Besan√ßon's blog.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#Data-for-the-problem","page":"Benders Decomposition","title":"Data for the problem","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"The input data is from page 139, Integer programming by Garfinkel and Nemhauser[1].","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"c1 = [-1; -4]\nc2 = [-2; -3]\n\ndim_x = length(c1)\ndim_u = length(c2)\n\nb = [-2; -3]\n\nA1 = [1 -3;\n     -1 -3]\nA2 = [1 -2;\n     -1 -1]\n\nM = 1000;\nnothing #hide","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#How-to-implement-the-Benders-decomposition-algorithm-in-JuMP","page":"Benders Decomposition","title":"How to implement the Benders decomposition algorithm in JuMP","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"There are two ways we can implement Benders decomposition in JuMP:","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Classical approach: Adding the Benders cuts in a loop,  and\nModern approach: Adding the Benders cuts as lazy constraints.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"The classical approach might be inferior to the modern one, as the solver","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"might revisit previously eliminated solution, and\nmight discard the optimal solution to the original problem in favor of a better but ultimately infeasible solution to the relaxed one.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"For more details on the comparison between the two approaches, see Paul Rubin's blog on Benders Decomposition.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#Classical-Approach:-Adding-the-Benders-Cuts-in-a-Loop","page":"Benders Decomposition","title":"Classical Approach: Adding the Benders Cuts in a Loop","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Let's describe the master problem first. Note that there are no constraints, which we will added later using Benders decomposition.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#Loading-the-necessary-packages","page":"Benders Decomposition","title":"Loading the necessary packages","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"using JuMP\nimport GLPK\nimport Test","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#Master-Problem-Description","page":"Benders Decomposition","title":"Master Problem Description","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"master_problem_model = Model(GLPK.Optimizer);\nnothing #hide","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#Variable-Definition","page":"Benders Decomposition","title":"Variable Definition","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"@variable(master_problem_model, 0 <= x[1:dim_x] <= 1e6, Int)\n@variable(master_problem_model, t <= 1e6)","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#Objective-Setting","page":"Benders Decomposition","title":"Objective Setting","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"@objective(master_problem_model, Max, t)\nglobal iter_num = 1\n\nprint(master_problem_model)","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Here is the loop that checks the status of the master problem and the subproblem and then adds necessary Benders cuts accordingly.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"iter_num = 1\n\nwhile true\n    println(\"\\n-----------------------\")\n    println(\"Iteration number = \", iter_num)\n    println(\"-----------------------\\n\")\n    println(\"The current master problem is\")\n    print(master_problem_model)\n\n    optimize!(master_problem_model)\n\n    t_status = termination_status(master_problem_model)\n    p_status = primal_status(master_problem_model)\n\n    if p_status == MOI.INFEASIBLE_POINT\n        println(\"The problem is infeasible :-(\")\n        break\n    end\n\n    (fm_current, x_current) = if t_status == MOI.INFEASIBLE_OR_UNBOUNDED\n        (M, M * ones(dim_x))\n    elseif p_status == MOI.FEASIBLE_POINT\n        (value(t), value.(x))\n    else\n        error(\"Unexpected status: $((t_status, p_status))\")\n    end\n\n    println(\"Status of the master problem is \", t_status,\n            \"\\nwith fm_current = \", fm_current,\n            \"\\nx_current = \", x_current)\n\n    sub_problem_model = Model(GLPK.Optimizer)\n\n    c_sub = b - A1 * x_current\n\n    local u = @variable(sub_problem_model, u[1:dim_u] >= 0)\n\n    @constraint(\n        sub_problem_model,\n        constr_ref_subproblem[j = 1:size(A2, 2)],\n        A2[:, j]' * u >= c2[j],\n    )\n    # The second argument of @constraint macro,\n    # constr_ref_subproblem[j=1:size(A2,2)] means that the j-th constraint is\n    # referenced by constr_ref_subproblem[j].\n\n    @objective(sub_problem_model, Min, c1' * x_current + c_sub' * u)\n\n    print(\"\\nThe current subproblem model is \\n\")\n    print(sub_problem_model)\n\n    optimize!(sub_problem_model)\n\n    t_status_sub = termination_status(sub_problem_model)\n    p_status_sub = primal_status(sub_problem_model)\n\n    fs_x_current = objective_value(sub_problem_model)\n\n    u_current = value.(u)\n\n    Œ≥ = b' * u_current\n\n    println(\"Status of the subproblem is \", t_status_sub,\n        \"\\nwith fs_x_current = \", fs_x_current,\n        \"\\nand fm_current = \", fm_current)\n\n    if p_status_sub == MOI.FEASIBLE_POINT && fs_x_current == fm_current # we are done\n        Test.@test value(t) ‚âà -4 #hide\n        println(\"\\n################################################\")\n        println(\"Optimal solution of the original problem found\")\n        println(\"The optimal objective value t is \", fm_current)\n        println(\"The optimal x is \", x_current)\n                println(\"The optimal v is \", dual.(constr_ref_subproblem))\n        println(\"################################################\\n\")\n        break\n    end\n\n    if p_status_sub == MOI.FEASIBLE_POINT && fs_x_current < fm_current\n        println(\"\\nThere is a suboptimal vertex, add the corresponding constraint\")\n        cv = A1' * u_current - c1\n        @constraint(master_problem_model, t + cv' * x <= Œ≥)\n        println(\"t + \", cv, \"·µÄ x <= \", Œ≥)\n    end\n\n    if t_status_sub == MOI.INFEASIBLE_OR_UNBOUNDED\n        println(\"\\nThere is an  extreme ray, adding the corresponding constraint\")\n        ce = A1'* u_current\n        @constraint(master_problem_model, ce' * x <= Œ≥)\n        println(ce, \"·µÄ x <= \", Œ≥)\n    end\n\n    global iter_num += 1\nend","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#References","page":"Benders Decomposition","title":"References","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"<a id='c1'></a>","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Garfinkel, R. & Nemhauser, G. L. Integer programming. (Wiley, 1972).","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"View this file on Github.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"This page was generated using Literate.jl.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"moi/manual/variables/#Add-a-variable","page":"Variables","title":"Add a variable","text":"","category":"section"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"Use add_variable to add a single variable.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"julia> x = MOI.add_variable(model)\nMathOptInterface.VariableIndex(1)","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"add_variable returns a VariableIndex type, which should be used to refer to the added variable in other calls.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"Check if a VariableIndex is valid using is_valid.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"julia> MOI.is_valid(model, x)\ntrue","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"Use add_variables to add a number of variables.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"julia> y = MOI.add_variables(model, 2)\n2-element Array{MathOptInterface.VariableIndex,1}:\n MathOptInterface.VariableIndex(2)\n MathOptInterface.VariableIndex(3)","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"warning: Warning\nThe integer does not necessarily corresond to the column inside an optimizer!","category":"page"},{"location":"moi/manual/variables/#Delete-a-variable","page":"Variables","title":"Delete a variable","text":"","category":"section"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"Delete a variable using delete.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"julia> MOI.delete(model, x)\n\njulia> MOI.is_valid(model, x)\nfalse","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"warning: Warning\nNot all ModelLike models support deleting variables. A DeleteNotAllowed error is thrown if this is not supported.","category":"page"},{"location":"moi/manual/variables/#Variable-attributes","page":"Variables","title":"Variable attributes","text":"","category":"section"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"The following attributes are available for variables:","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"VariableName\nVariablePrimalStart\nVariablePrimal","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"Get and set these attributes using [get(@ref) and set.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"julia> MOI.set(model, MOI.VariableName(), x, \"var_x\")\n\njulia> MOI.get(model, MOI.VariableName(), x)\n\"var_x\"","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\n\n    # For compatibility with both Julia 1.0.5 and 1.5.2\n    # Upon the Julia LTS version becoming 1.6, these imports could be dropped,\n    # and all ScalarAffineTerm and VariableIndex instances in doctests below\n    # could be replaced with MOI.ScalarAffineTerm and MOI.VariableIndex\n    # Check discussion at PR 1184: https://github.com/jump-dev/MathOptInterface.jl/pull/1184#discussion_r515300914\n    import MathOptInterface.ScalarAffineTerm\n    import MathOptInterface.VariableIndex\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Utilities/reference/#Utilities.Model","page":"API Reference","title":"Utilities.Model","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.Model","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.Model","page":"API Reference","title":"MathOptInterface.Utilities.Model","text":"An implementation of ModelLike that supports all functions and sets defined in MOI. It is parameterized by the coefficient type.\n\nExamples\n\nmodel = Model{Float64}()\nx = add_variable(model)\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#Utilities.UniversalFallback","page":"API Reference","title":"Utilities.UniversalFallback","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.UniversalFallback","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.UniversalFallback","page":"API Reference","title":"MathOptInterface.Utilities.UniversalFallback","text":"UniversalFallback\n\nThe UniversalFallback can be applied on a MathOptInterface.ModelLike model to create the model UniversalFallback(model) supporting any constraint and attribute. This allows to have a specialized implementation in model for performance critical constraints and attributes while still supporting other attributes with a small performance penalty. Note that model is unaware of constraints and attributes stored by UniversalFallback so this is not appropriate if model is an optimizer (for this reason, MathOptInterface.optimize! has not been implemented). In that case, optimizer bridges should be used instead.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#Utilities.@macro","page":"API Reference","title":"Utilities.@macro","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.@model\nUtilities.GenericModel\nUtilities.GenericOptimizer\nUtilities.struct_of_constraint_code","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.@model","page":"API Reference","title":"MathOptInterface.Utilities.@model","text":"macro model(\n    model_name,\n    scalar_sets,\n    typed_scalar_sets,\n    vector_sets,\n    typed_vector_sets,\n    scalar_functions,\n    typed_scalar_functions,\n    vector_functions,\n    typed_vector_functions,\n    is_optimizer = false\n)\n\nCreates a type model_name implementing the MOI model interface and containing scalar_sets scalar sets typed_scalar_sets typed scalar sets, vector_sets vector sets, typed_vector_sets typed vector sets, scalar_functions scalar functions, typed_scalar_functions typed scalar functions, vector_functions vector functions and typed_vector_functions typed vector functions. To give no set/function, write (), to give one set S, write (S,).\n\nThe function MathOptInterface.SingleVariable should not be given in scalar_functions. The model supports MathOptInterface.SingleVariable-in-S constraints where S is MathOptInterface.EqualTo, MathOptInterface.GreaterThan, MathOptInterface.LessThan, MathOptInterface.Interval, MathOptInterface.Integer, MathOptInterface.ZeroOne, MathOptInterface.Semicontinuous or MathOptInterface.Semiinteger. The sets supported with the MathOptInterface.SingleVariable cannot be controlled from the macro, use the UniversalFallback to support more sets.\n\nThis macro creates a model specialized for specific types of constraint, by defining specialized structures and methods. To create a model that, in addition to be optimized for specific constraints, also support arbitrary constraints and attributes, use UniversalFallback.\n\nIf is_optimizer = true, the resulting struct is a of GenericOptimizer, which is a subtype of MathOptInterface.AbstractOptimizer, otherwise, it is a GenericModel, which is a subtype of MathOptInterface.ModelLike.\n\nExamples\n\nThe model describing an linear program would be:\n\n@model(LPModel,                                                   # Name of model\n      (),                                                         # untyped scalar sets\n      (MOI.EqualTo, MOI.GreaterThan, MOI.LessThan, MOI.Interval), #   typed scalar sets\n      (MOI.Zeros, MOI.Nonnegatives, MOI.Nonpositives),            # untyped vector sets\n      (),                                                         #   typed vector sets\n      (),                                                         # untyped scalar functions\n      (MOI.ScalarAffineFunction,),                                #   typed scalar functions\n      (MOI.VectorOfVariables,),                                   # untyped vector functions\n      (MOI.VectorAffineFunction,),                                #   typed vector functions\n      false\n    )\n\nLet MOI denote MathOptInterface, MOIU denote MOI.Utilities. The macro would create the following types with struct_of_constraint_code:\n\nstruct LPModelScalarConstraints{T, C1, C2, C3, C4} <: MOIU.StructOfConstraints\n    moi_equalto::C1\n    moi_greaterthan::C2\n    moi_lessthan::C3\n    moi_interval::C4\nend\nstruct LPModelVectorConstraints{T, C1, C2, C3} <: MOIU.StructOfConstraints\n    moi_zeros::C1\n    moi_nonnegatives::C2\n    moi_nonpositives::C3\nend\nstruct LPModelFunctionConstraints{T} <: MOIU.StructOfConstraints\n    moi_scalaraffinefunction::LPModelScalarConstraints{\n        T,\n        MOIU.VectorOfConstraints{MOI.ScalarAffineFunction{T}, MOI.EqualTo{T}},\n        MOIU.VectorOfConstraints{MOI.ScalarAffineFunction{T}, MOI.GreaterThan{T}},\n        MOIU.VectorOfConstraints{MOI.ScalarAffineFunction{T}, MOI.LessThan{T}},\n        MOIU.VectorOfConstraints{MOI.ScalarAffineFunction{T}, MOI.Interval{T}}\n    }\n    moi_vectorofvariables::LPModelVectorConstraints{\n        T,\n        MOIU.VectorOfConstraints{MOI.VectorOfVariables, MOI.Zeros},\n        MOIU.VectorOfConstraints{MOI.VectorOfVariables, MOI.Nonnegatives},\n        MOIU.VectorOfConstraints{MOI.VectorOfVariables, MOI.Nonpositives}\n    }\n    moi_vectoraffinefunction::LPModelVectorConstraints{\n        T,\n        MOIU.VectorOfConstraints{MOI.VectorAffineFunction{T}, MOI.Zeros},\n        MOIU.VectorOfConstraints{MOI.VectorAffineFunction{T}, MOI.Nonnegatives},\n        MOIU.VectorOfConstraints{MOI.VectorAffineFunction{T}, MOI.Nonpositives}\n    }\nend\nconst LPModel{T} = MOIU.GenericModel{T, LPModelFunctionConstraints{T}}\n\nThe type LPModel implements the MathOptInterface API except methods specific to optimizers like optimize! or get with VariablePrimal.\n\n\n\n\n\n","category":"macro"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.GenericModel","page":"API Reference","title":"MathOptInterface.Utilities.GenericModel","text":"mutable struct GenericModel{T,C} <: AbstractModelLike{T}\n\nImplements a models supporting\n\nan objective function of type MOI.SingleVariable, MOI.ScalarAffineFunction{T} and MOI.ScalarQuadraticFunction{T},\nMathOptInterface.SingleVariable-in-S constraints where S is MathOptInterface.EqualTo, MathOptInterface.GreaterThan, MathOptInterface.LessThan, MathOptInterface.Interval, MathOptInterface.Integer, MathOptInterface.ZeroOne, MathOptInterface.Semicontinuous or MathOptInterface.Semiinteger.\nF-in-S constraints that are supported by C.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.GenericOptimizer","page":"API Reference","title":"MathOptInterface.Utilities.GenericOptimizer","text":"mutable struct GenericOptimizer{T,C} <: AbstractOptimizer{T}\n\nImplements a models supporting\n\nan objective function of type MOI.SingleVariable, MOI.ScalarAffineFunction{T} and MOI.ScalarQuadraticFunction{T},\nMathOptInterface.SingleVariable-in-S constraints where S is MathOptInterface.EqualTo, MathOptInterface.GreaterThan, MathOptInterface.LessThan, MathOptInterface.Interval, MathOptInterface.Integer, MathOptInterface.ZeroOne, MathOptInterface.Semicontinuous or MathOptInterface.Semiinteger.\nF-in-S constraints that are supported by C.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.struct_of_constraint_code","page":"API Reference","title":"MathOptInterface.Utilities.struct_of_constraint_code","text":"struct_of_constraint_code(struct_name, types, field_types = nothing)\n\nGiven a vector of n SymbolFun or SymbolSet in types, creates a struct of name struct_name that is a subtype of StructOfConstraint{T, C1, C2, ..., Cn} if field_types is nothing and a subtype of StructOfConstraint{T} otherwise. It contains n field where the ith field has type Ci if field_types is nothing and type field_types[i] otherwise. If types is vector of SymbolFun (resp. SymbolSet) then the constraints of that function (resp. set) type are stored in the corresponding field.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#Caching-optimizer","page":"API Reference","title":"Caching optimizer","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.CachingOptimizer\nUtilities.attach_optimizer\nUtilities.reset_optimizer\nUtilities.drop_optimizer\nUtilities.state\nUtilities.mode","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.CachingOptimizer","page":"API Reference","title":"MathOptInterface.Utilities.CachingOptimizer","text":"CachingOptimizer\n\nCachingOptimizer is an intermediate layer that stores a cache of the model and links it with an optimizer. It supports incremental model construction and modification even when the optimizer doesn't.\n\nA CachingOptimizer may be in one of three possible states (CachingOptimizerState):\n\nNO_OPTIMIZER: The CachingOptimizer does not have any optimizer.\nEMPTY_OPTIMIZER: The CachingOptimizer has an empty optimizer. The optimizer is not synchronized with the cached model.\nATTACHED_OPTIMIZER: The CachingOptimizer has an optimizer, and it is synchronized with the cached model.\n\nA CachingOptimizer has two modes of operation (CachingOptimizerMode):\n\nMANUAL: The only methods that change the state of the CachingOptimizer are Utilities.reset_optimizer, Utilities.drop_optimizer, and Utilities.attach_optimizer. Attempting to perform an operation in the incorrect state results in an error.\nAUTOMATIC: The CachingOptimizer changes its state when necessary. For example, optimize! will automatically call attach_optimizer (an optimizer must have been previously set). Attempting to add a constraint or perform a modification not supported by the optimizer results in a drop to EMPTY_OPTIMIZER mode.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.attach_optimizer","page":"API Reference","title":"MathOptInterface.Utilities.attach_optimizer","text":"attach_optimizer(model::CachingOptimizer)\n\nAttaches the optimizer to model, copying all model data into it. Can be called only from the EMPTY_OPTIMIZER state. If the copy succeeds, the CachingOptimizer will be in state ATTACHED_OPTIMIZER after the call, otherwise an error is thrown; see MathOptInterface.copy_to for more details on which errors can be thrown.\n\n\n\n\n\nMOIU.attach_optimizer(model::Model)\n\nCall MOIU.attach_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.reset_optimizer","page":"API Reference","title":"MathOptInterface.Utilities.reset_optimizer","text":"reset_optimizer(m::CachingOptimizer, optimizer::MOI.AbstractOptimizer)\n\nSets or resets m to have the given empty optimizer optimizer.\n\nCan be called from any state. An assertion error will be thrown if optimizer is not empty.\n\nThe CachingOptimizer m will be in state EMPTY_OPTIMIZER after the call.\n\n\n\n\n\nreset_optimizer(m::CachingOptimizer)\n\nDetaches and empties the current optimizer. Can be called from ATTACHED_OPTIMIZER or EMPTY_OPTIMIZER state. The CachingOptimizer will be in state EMPTY_OPTIMIZER after the call.\n\n\n\n\n\nMOIU.reset_optimizer(model::Model, optimizer::MOI.AbstractOptimizer)\n\nCall MOIU.reset_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\nMOIU.reset_optimizer(model::Model)\n\nCall MOIU.reset_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.drop_optimizer","page":"API Reference","title":"MathOptInterface.Utilities.drop_optimizer","text":"drop_optimizer(m::CachingOptimizer)\n\nDrops the optimizer, if one is present. Can be called from any state. The CachingOptimizer will be in state NO_OPTIMIZER after the call.\n\n\n\n\n\nMOIU.drop_optimizer(model::Model)\n\nCall MOIU.drop_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.state","page":"API Reference","title":"MathOptInterface.Utilities.state","text":"state(m::CachingOptimizer)::CachingOptimizerState\n\nReturns the state of the CachingOptimizer m. See Utilities.CachingOptimizer.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.mode","page":"API Reference","title":"MathOptInterface.Utilities.mode","text":"mode(m::CachingOptimizer)::CachingOptimizerMode\n\nReturns the operating mode of the CachingOptimizer m. See Utilities.CachingOptimizer.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#Copy-utilities","page":"API Reference","title":"Copy utilities","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.automatic_copy_to\nUtilities.default_copy_to\nUtilities.supports_default_copy_to","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.automatic_copy_to","page":"API Reference","title":"MathOptInterface.Utilities.automatic_copy_to","text":"automatic_copy_to(dest::MOI.ModelLike, src::MOI.ModelLike;\n                  copy_names::Bool=true,\n                  filter_constraints::Union{Nothing, Function}=nothing)\n\nUse Utilities.supports_default_copy_to and Utilities.supports_allocate_load to automatically choose between Utilities.default_copy_to or Utilities.allocate_load to apply the copy operation.\n\nIf the filter_constraints arguments is given, only the constraints for which this function returns true will be copied. This function is given a constraint index as argument.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.default_copy_to","page":"API Reference","title":"MathOptInterface.Utilities.default_copy_to","text":"default_copy_to(dest::MOI.ModelLike, src::MOI.ModelLike, copy_names::Bool,\n                filter_constraints::Union{Nothing, Function}=nothing)\n\nImplements MOI.copy_to(dest, src) by adding the variables and then the constraints and attributes incrementally. The function supports_default_copy_to can be used to check whether dest supports the copying a model incrementally.\n\nIf the filter_constraints arguments is given, only the constraints for which this function returns true will be copied. This function is given a constraint index as argument.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.supports_default_copy_to","page":"API Reference","title":"MathOptInterface.Utilities.supports_default_copy_to","text":"supports_default_copy_to(model::ModelLike, copy_names::Bool)\n\nReturn a Bool indicating whether the model model supports default_copy_to(model, src, copy_names=copy_names) if all the attributes set to src and constraints added to src are supported by model.\n\nThis function can be used to determine whether a model can be loaded into model incrementally or whether it should be cached and copied at once instead. This is used by JuMP to determine whether to add a cache or not in two situations:\n\nA first cache can be used to store the model as entered by the user as well as the names of variables and constraints. This cache is created if this function returns false when copy_names is true.\nIf bridges are used, then a second cache can be used to store the bridged model with unnamed variables and constraints. This cache is created if this function returns false when copy_names is false.\n\nExamples\n\nIf MathOptInterface.set, MathOptInterface.add_variable and MathOptInterface.add_constraint are implemented for a model of type MyModel and names are supported, then MathOptInterface.copy_to can be implemented as\n\nMOI.Utilities.supports_default_copy_to(model::MyModel, copy_names::Bool) = true\nfunction MOI.copy_to(dest::MyModel, src::MOI.ModelLike; kws...)\n    return MOI.Utilities.automatic_copy_to(dest, src; kws...)\nend\n\nThe Utilities.automatic_copy_to function automatically redirects to Utilities.default_copy_to.\n\nIf names are not supported, simply change the first line by\n\nMOI.supports_default_copy_to(model::MyModel, copy_names::Bool) = !copy_names\n\nThe Utilities.default_copy_to function automatically throws an helpful error in case copy_to is called with copy_names equal to true.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#allocate_load_api_ref","page":"API Reference","title":"Allocate-Load API","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.allocate_load\nUtilities.supports_allocate_load\nUtilities.allocate_variables\nUtilities.allocate\nUtilities.allocate_constraint\nUtilities.load_variables\nUtilities.load\nUtilities.load_constraint","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.allocate_load","page":"API Reference","title":"MathOptInterface.Utilities.allocate_load","text":"allocate_load(dest::MOI.ModelLike, src::MOI.ModelLike,\n              filter_constraints::Union{Nothing, Function}=nothing\n              )\n\nImplements MOI.copy_to(dest, src) using the Allocate-Load API. The function supports_allocate_load can be used to check whether dest supports the Allocate-Load API.\n\nIf the filter_constraints arguments is given, only the constraints for which this function returns true will be copied. This function is given a constraint index as argument.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.supports_allocate_load","page":"API Reference","title":"MathOptInterface.Utilities.supports_allocate_load","text":"supports_allocate_load(model::MOI.ModelLike, copy_names::Bool)::Bool\n\nReturn a Bool indicating whether model supports allocate_load(model, src, copy_names=copy_names) if all the attributes set to src and constraints added to src are supported by model.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.allocate_variables","page":"API Reference","title":"MathOptInterface.Utilities.allocate_variables","text":"allocate_variables(model::MOI.ModelLike, nvars::Integer)\n\nCreates nvars variables and returns a vector of nvars variable indices.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.allocate","page":"API Reference","title":"MathOptInterface.Utilities.allocate","text":"allocate(model::ModelLike, attr::ModelLikeAttribute, value)\nallocate(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex, value)\nallocate(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex, value)\n\nInforms model that load will be called with the same arguments after load_variables is called.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.allocate_constraint","page":"API Reference","title":"MathOptInterface.Utilities.allocate_constraint","text":"allocate_constraint(model::MOI.ModelLike, f::MOI.AbstractFunction, s::MOI.AbstractSet)\n\nReturns the index for the constraint to be used in load_constraint that will be called after load_variables is called.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.load_variables","page":"API Reference","title":"MathOptInterface.Utilities.load_variables","text":"load_variables(model::MOI.ModelLike, nvars::Integer)\n\nPrepares model for load and load_constraint.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.load","page":"API Reference","title":"MathOptInterface.Utilities.load","text":"load(model::ModelLike, attr::ModelLikeAttribute, value)\nload(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex, value)\nload(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex, value)\n\nThis has the same effect that set with the same arguments except that allocate should be called first before load_variables.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.load_constraint","page":"API Reference","title":"MathOptInterface.Utilities.load_constraint","text":"load_constraint(model::MOI.ModelLike, ci::MOI.ConstraintIndex, f::MOI.AbstractFunction, s::MOI.AbstractSet)\n\nSets the constraint function and set for the constraint of index ci.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#Fallbacks","page":"API Reference","title":"Fallbacks","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.get_fallback","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.get_fallback","page":"API Reference","title":"MathOptInterface.Utilities.get_fallback","text":"get_fallback(model::MOI.ModelLike, ::MOI.ObjectiveValue)\n\nCompute the objective function value using the VariablePrimal results and the ObjectiveFunction value.\n\n\n\n\n\nget_fallback(model::MOI.ModelLike, ::MOI.DualObjectiveValue, T::Type)::T\n\nCompute the dual objective value of type T using the ConstraintDual results and the ConstraintFunction and ConstraintSet values. Note that the nonlinear part of the model is ignored.\n\n\n\n\n\nget_fallback(model::MOI.ModelLike, ::MOI.ConstraintPrimal,\n             constraint_index::MOI.ConstraintIndex)\n\nCompute the value of the function of the constraint of index constraint_index using the VariablePrimal results and the ConstraintFunction values.\n\n\n\n\n\nget_fallback(model::MOI.ModelLike, attr::MOI.ConstraintDual,\n             ci::MOI.ConstraintIndex{Union{MOI.SingleVariable,\n                                           MOI.VectorOfVariables}})\n\nCompute the dual of the constraint of index ci using the ConstraintDual of other constraints and the ConstraintFunction values. Throws an error if some constraints are quadratic or if there is one another MOI.SingleVariable-in-S or MOI.VectorOfVariables-in-S constraint with one of the variables in the function of the constraint ci.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#Function-utilities","page":"API Reference","title":"Function utilities","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following utilities are available for functions:","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.eval_variables\nUtilities.map_indices\nUtilities.substitute_variables\nUtilities.filter_variables\nUtilities.remove_variable\nUtilities.all_coefficients\nUtilities.unsafe_add\nUtilities.isapprox_zero\nUtilities.modify_function","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.eval_variables","page":"API Reference","title":"MathOptInterface.Utilities.eval_variables","text":"eval_variables(varval::Function, f::AbstractFunction)\n\nReturns the value of function f if each variable index vi is evaluated as varval(vi). Note that varval should return a number, see substitute_variables for a similar function where varval returns a function.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.map_indices","page":"API Reference","title":"MathOptInterface.Utilities.map_indices","text":"map_indices(index_map::Function, x)\n\nSubstitute any MOI.VariableIndex (resp. MOI.ConstraintIndex) in x by the MOI.VariableIndex (resp. MOI.ConstraintIndex) of the same type given by index_map(x).\n\nThis function is used by implementations of MOI.copy_to on constraint functions, attribute values and submittable values hence it needs to be implemented for custom types that are meant to be used as attribute or submittable value.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.substitute_variables","page":"API Reference","title":"MathOptInterface.Utilities.substitute_variables","text":"substitute_variables(variable_map::Function, x)\n\nSubstitute any MOI.VariableIndex in x by variable_map(x). The variable_map function returns either MOI.SingleVariable or MOI.ScalarAffineFunction, see eval_variables for a similar function where variable_map returns a number.\n\nThis function is used by bridge optimizers on constraint functions, attribute values and submittable values when at least one variable bridge is used hence it needs to be implemented for custom types that are meant to be used as attribute or submittable value.\n\nWARNING: Don't use substitude_variables(::Function, ...) because Julia will not specialize on this. Use instead substitude_variables(::F, ...) where {F<:Function}.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.filter_variables","page":"API Reference","title":"MathOptInterface.Utilities.filter_variables","text":"filter_variables(keep::Function, f::AbstractFunction)\n\nReturn a new function f with the variable vi such that !keep(vi) removed.\n\nWARNING: Don't define filter_variables(::Function, ...) because Julia will not specialize on this. Define instead filter_variables(::F, ...) where {F<:Function}.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.remove_variable","page":"API Reference","title":"MathOptInterface.Utilities.remove_variable","text":"remove_variable(f::AbstractFunction, vi::VariableIndex)\n\nReturn a new function f with the variable vi removed.\n\n\n\n\n\nremove_variable(f::MOI.AbstractFunction, s::MOI.AbstractSet, vi::MOI.VariableIndex)\n\nReturn a tuple (g, t) representing the constraint f-in-s with the variable vi removed. That is, the terms containing the variable vi in the function f are removed and the dimension of the set s is updated if needed (e.g. when f is a VectorOfVariables with vi being one of the variables).\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.all_coefficients","page":"API Reference","title":"MathOptInterface.Utilities.all_coefficients","text":"all_coefficients(p::Function, f::MOI.AbstractFunction)\n\nDetermine whether predicate p returns true for all coefficients of f, returning false as soon as the first coefficient of f for which p returns false is encountered (short-circuiting). Similar to all.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.unsafe_add","page":"API Reference","title":"MathOptInterface.Utilities.unsafe_add","text":"unsafe_add(t1::MOI.ScalarAffineTerm, t2::MOI.ScalarAffineTerm)\n\nSums the coefficients of t1 and t2 and returns an output MOI.ScalarAffineTerm. It is unsafe because it uses the variable_index of t1 as the variable_index of the output without checking that it is equal to that of t2.\n\n\n\n\n\nunsafe_add(t1::MOI.ScalarQuadraticTerm, t2::MOI.ScalarQuadraticTerm)\n\nSums the coefficients of t1 and t2 and returns an output MOI.ScalarQuadraticTerm. It is unsafe because it uses the variable_index's of t1 as the variable_index's of the output without checking that they are the same (up to permutation) to those of t2.\n\n\n\n\n\nunsafe_add(t1::MOI.VectorAffineTerm, t2::MOI.VectorAffineTerm)\n\nSums the coefficients of t1 and t2 and returns an output MOI.VectorAffineTerm. It is unsafe because it uses the output_index and variable_index of t1 as the output_index and variable_index of the output term without checking that they are equal to those of t2.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.isapprox_zero","page":"API Reference","title":"MathOptInterface.Utilities.isapprox_zero","text":"isapprox_zero(f::MOI.AbstractFunction, tol)\n\nReturn a Bool indicating whether the function f is approximately zero using tol as a tolerance.\n\nImportant note\n\nThis function assumes that f does not contain any duplicate terms, you might want to first call canonical if that is not guaranteed. For instance, given\n\nf = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([1, -1], [x, x]), 0)`.\n\nthen isapprox_zero(f) is false but isapprox_zero(MOIU.canonical(f)) is true.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.modify_function","page":"API Reference","title":"MathOptInterface.Utilities.modify_function","text":"modify_function(f::AbstractFunction, change::AbstractFunctionModification)\n\nReturn a new function f modified according to change.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following functions can be used to canonicalize a function:","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.is_canonical\nUtilities.canonical\nUtilities.canonicalize!","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.is_canonical","page":"API Reference","title":"MathOptInterface.Utilities.is_canonical","text":"is_canonical(f::Union{ScalarAffineFunction, VectorAffineFunction})\n\nReturns a Bool indicating whether the function is in canonical form. See canonical.\n\n\n\n\n\nis_canonical(f::Union{ScalarQuadraticFunction, VectorQuadraticFunction})\n\nReturns a Bool indicating whether the function is in canonical form. See canonical.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.canonical","page":"API Reference","title":"MathOptInterface.Utilities.canonical","text":"canonical(f::Union{ScalarAffineFunction, VectorAffineFunction,\n                   ScalarQuadraticFunction, VectorQuadraticFunction})\n\nReturns the function in a canonical form, i.e.\n\nA term appear only once.\nThe coefficients are nonzero.\nThe terms appear in increasing order of variable where there the order of the variables is the order of their value.\nFor a AbstractVectorFunction, the terms are sorted in ascending order of output index.\n\nThe output of canonical can be assumed to be a copy of f, even for VectorOfVariables.\n\nExamples\n\nIf x (resp. y, z) is VariableIndex(1) (resp. 2, 3). The canonical representation of ScalarAffineFunction([y, x, z, x, z], [2, 1, 3, -2, -3], 5) is ScalarAffineFunction([x, y], [-1, 2], 5).\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.canonicalize!","page":"API Reference","title":"MathOptInterface.Utilities.canonicalize!","text":"canonicalize!(f::Union{ScalarAffineFunction, VectorAffineFunction})\n\nConvert a function to canonical form in-place, without allocating a copy to hold the result. See canonical.\n\n\n\n\n\ncanonicalize!(f::Union{ScalarQuadraticFunction, VectorQuadraticFunction})\n\nConvert a function to canonical form in-place, without allocating a copy to hold the result. See canonical.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following functions can be used to manipulate functions with basic algebra:","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.scalar_type\nUtilities.promote_operation\nUtilities.operate\nUtilities.operate!\nUtilities.operate_output_index!\nUtilities.vectorize","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.scalar_type","page":"API Reference","title":"MathOptInterface.Utilities.scalar_type","text":"scalar_type(F::Type{<:MOI.AbstractVectorFunction})\n\nType of functions obtained by indexing objects obtained by calling eachscalar on functions of type F.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.promote_operation","page":"API Reference","title":"MathOptInterface.Utilities.promote_operation","text":"promote_operation(op::Function, ::Type{T},\n                  ArgsTypes::Type{<:Union{T, MOI.AbstractFunction}}...) where T\n\nReturns the type of the MOI.AbstractFunction returned to the call operate(op, T, args...) where the types of the arguments args are ArgsTypes.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.operate","page":"API Reference","title":"MathOptInterface.Utilities.operate","text":"operate(op::Function, ::Type{T},\n        args::Union{T, MOI.AbstractFunction}...)::MOI.AbstractFunction where T\n\nReturns an MOI.AbstractFunction representing the function resulting from the operation op(args...) on functions of coefficient type T. No argument can be modified.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.operate!","page":"API Reference","title":"MathOptInterface.Utilities.operate!","text":"operate!(op::Function, ::Type{T},\n         args::Union{T, MOI.AbstractFunction}...)::MOI.AbstractFunction where T\n\nReturns an MOI.AbstractFunction representing the function resulting from the operation op(args...) on functions of coefficient type T. The first argument can be modified. The return type is the same than the method operate(op, T, args...) without !.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.operate_output_index!","page":"API Reference","title":"MathOptInterface.Utilities.operate_output_index!","text":"operate_output_index!(\n    op::Function, ::Type{T}, output_index::Integer,\n    func::MOI.AbstractVectorFunction\n    args::Union{T, MOI.AbstractScalarFunction}...)::MOI.AbstractFunction where T\n\nReturns an MOI.AbstractVectorFunction where the function at output_index is the result of the operation op applied to the function at output_index of func and args. The functions at output index different to output_index are the same as the functions at the same output index in func. The first argument can be modified.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.vectorize","page":"API Reference","title":"MathOptInterface.Utilities.vectorize","text":"vectorize(funcs::AbstractVector{MOI.SingleVariable})\n\nReturns the vector of scalar affine functions in the form of a MOI.VectorAffineFunction{T}.\n\n\n\n\n\nvectorize(funcs::AbstractVector{MOI.ScalarAffineFunction{T}}) where T\n\nReturns the vector of scalar affine functions in the form of a MOI.VectorAffineFunction{T}.\n\n\n\n\n\nvectorize(funcs::AbstractVector{MOI.ScalarQuadraticFunction{T}}) where T\n\nReturns the vector of scalar quadratic functions in the form of a MOI.VectorQuadraticFunction{T}.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#Constraint-utilities","page":"API Reference","title":"Constraint utilities","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following utilities are available for moving the function constant to the set for scalar constraints:","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.shift_constant\nUtilities.supports_shift_constant\nUtilities.normalize_and_add_constraint\nUtilities.normalize_constant","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.shift_constant","page":"API Reference","title":"MathOptInterface.Utilities.shift_constant","text":"shift_constant(set::MOI.AbstractScalarSet, offset)\n\nReturns a new scalar set new_set such that func-in-set is equivalent to func + offset-in-new_set.\n\nOnly define this function if it makes sense to!\n\nUse supports_shift_constant to check if the set supports shifting:\n\nif supports_shift_constant(typeof(old_set))\n    new_set = shift_constant(old_set, offset)\n    f.constant = 0\n    add_constraint(model, f, new_set)\nelse\n    add_constraint(model, f, old_set)\nend\n\nSee also supports_shift_constant.\n\nExamples\n\nThe call shift_constant(MOI.Interval(-2, 3), 1) is equal to MOI.Interval(-1, 4).\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.supports_shift_constant","page":"API Reference","title":"MathOptInterface.Utilities.supports_shift_constant","text":"supports_shift_constant(::Type{S}) where {S<:MOI.AbstractSet}\n\nReturn true if shift_constant is defined for set S.\n\nSee also shift_constant.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.normalize_and_add_constraint","page":"API Reference","title":"MathOptInterface.Utilities.normalize_and_add_constraint","text":"normalize_and_add_constraint(model::MOI.ModelLike,\n                             func::MOI.AbstractScalarFunction,\n                             set::MOI.AbstractScalarSet;\n                             allow_modify_function::Bool=false)\n\nAdds the scalar constraint obtained by moving the constant term in func to the set in model. If allow_modify_function is true then the function func can be modified.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.normalize_constant","page":"API Reference","title":"MathOptInterface.Utilities.normalize_constant","text":"normalize_constant(func::MOI.AbstractScalarFunction,\n                   set::MOI.AbstractScalarSet;\n                   allow_modify_function::Bool=false)\n\nReturn the func-in-set constraint in normalized form. That is, if func is MOI.ScalarQuadraticFunction or MOI.ScalarAffineFunction, the constant is moved to the set. If allow_modify_function is true then the function func can be modified.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following utility identifies those constraints imposing bounds on a given variable, and returns those bound values:","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.get_bounds","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.get_bounds","page":"API Reference","title":"MathOptInterface.Utilities.get_bounds","text":"get_bounds(model::MOI.ModelLike, ::Type{T}, x::MOI.VariableIndex)\n\nReturn a tuple (lb, ub) of type Tuple{T, T}, where lb and ub are lower  and upper bounds, respectively, imposed on x in model.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following utilities are useful when working with symmetric matrix cones.","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.is_diagonal_vectorized_index\nUtilities.side_dimension_for_vectorized_dimension","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.is_diagonal_vectorized_index","page":"API Reference","title":"MathOptInterface.Utilities.is_diagonal_vectorized_index","text":"is_diagonal_vectorized_index(index::Base.Integer)\n\nReturn whether index is the index of a diagonal element in a MOI.AbstractSymmetricMatrixSetTriangle set.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.side_dimension_for_vectorized_dimension","page":"API Reference","title":"MathOptInterface.Utilities.side_dimension_for_vectorized_dimension","text":"side_dimension_for_vectorized_dimension(n::Integer)\n\nReturn the dimension d such that MOI.dimension(MOI.PositiveSemidefiniteConeTriangle(d)) is n.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#ObjectiveAPI","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"reference/objectives/","page":"Objectives","title":"Objectives","text":"More information can be found in the Objectives section of the manual.","category":"page"},{"location":"reference/objectives/#Objective-functions","page":"Objectives","title":"Objective functions","text":"","category":"section"},{"location":"reference/objectives/","page":"Objectives","title":"Objectives","text":"@objective\nobjective_function\nset_objective_function\nset_objective_coefficient\nset_objective\nobjective_function_type\nobjective_function_string\nshow_objective_function_summary","category":"page"},{"location":"reference/objectives/#JuMP.@objective","page":"Objectives","title":"JuMP.@objective","text":"@objective(model::Model, sense, func)\n\nSet the objective sense to sense and objective function to func. The objective sense can be either Min, Max, MathOptInterface.MIN_SENSE, MathOptInterface.MAX_SENSE or MathOptInterface.FEASIBILITY_SENSE; see MathOptInterface.ObjectiveSense. In order to set the sense programmatically, i.e., when sense is a Julia variable whose value is the sense, one of the three MathOptInterface.ObjectiveSense values should be used. The function func can be a single JuMP variable, an affine expression of JuMP variables or a quadratic expression of JuMP variables.\n\nExamples\n\nTo minimize the value of the variable x, do as follows:\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @objective(model, Min, x)\nx\n\nTo maximize the value of the affine expression 2x - 1, do as follows:\n\njulia> @objective(model, Max, 2x - 1)\n2 x - 1\n\nTo set a quadratic objective and set the objective sense programmatically, do as follows:\n\njulia> sense = MOI.MIN_SENSE\nMIN_SENSE::OptimizationSense = 0\n\njulia> @objective(model, sense, x^2 - 2x + 1)\nx¬≤ - 2 x + 1\n\n\n\n\n\n","category":"macro"},{"location":"reference/objectives/#JuMP.objective_function","page":"Objectives","title":"JuMP.objective_function","text":"objective_function(model::Model,\n               T::Type{<:AbstractJuMPScalar}=objective_function_type(model))\n\nReturn an object of type T representing the objective function. Error if the objective is not convertible to type T.\n\nExamples\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @objective(model, Min, 2x + 1)\n2 x + 1\n\njulia> objective_function(model, AffExpr)\n2 x + 1\n\njulia> objective_function(model, QuadExpr)\n2 x + 1\n\njulia> typeof(objective_function(model, QuadExpr))\nGenericQuadExpr{Float64,VariableRef}\n\nWe see with the last two commands that even if the objective function is affine, as it is convertible to a quadratic function, it can be queried as a quadratic function and the result is quadratic.\n\nHowever, it is not convertible to a variable.\n\njulia> objective_function(model, VariableRef)\nERROR: InexactError: convert(MathOptInterface.SingleVariable, MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 1.0))\n[...]\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.set_objective_function","page":"Objectives","title":"JuMP.set_objective_function","text":"set_objective_function(\n    model::Model,\n    func::Union{AbstractJuMPScalar, MathOptInterface.AbstractScalarFunction})\n\nSets the objective function of the model to the given function. See set_objective_sense to set the objective sense. These are low-level functions; the recommended way to set the objective is with the @objective macro.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.set_objective_coefficient","page":"Objectives","title":"JuMP.set_objective_coefficient","text":"set_objective_coefficient(model::Model, variable::VariableRef, coefficient::Real)\n\nSet the linear objective coefficient associated with Variable to coefficient.\n\nNote: this function will throw an error if a nonlinear objective is set.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.set_objective","page":"Objectives","title":"JuMP.set_objective","text":"set_objective(model::AbstractModel, sense::MOI.OptimizationSense, func)\n\nThe functional equivalent of the @objective macro.\n\nSets the objective sense and objective function simultaneously, and is equivalent to:\n\nset_objective_sense(model, sense)\nset_objective_function(model, func)\n\nExamples\n\nmodel = Model()\n@variable(model, x)\nset_objective(model, MOI.MIN_SENSE, x)\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.objective_function_type","page":"Objectives","title":"JuMP.objective_function_type","text":"objective_function_type(model::Model)::AbstractJuMPScalar\n\nReturn the type of the objective function.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.objective_function_string","page":"Objectives","title":"JuMP.objective_function_string","text":"objective_function_string(print_mode, model::AbstractModel)::String\n\nReturn a String describing the objective function of the model.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.show_objective_function_summary","page":"Objectives","title":"JuMP.show_objective_function_summary","text":"show_objective_function_summary(io::IO, model::AbstractModel)\n\nWrite to io a summary of the objective function type.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#Objective-sense","page":"Objectives","title":"Objective sense","text":"","category":"section"},{"location":"reference/objectives/","page":"Objectives","title":"Objectives","text":"objective_sense\nset_objective_sense","category":"page"},{"location":"reference/objectives/#JuMP.objective_sense","page":"Objectives","title":"JuMP.objective_sense","text":"objective_sense(model::Model)::MathOptInterface.OptimizationSense\n\nReturn the objective sense.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.set_objective_sense","page":"Objectives","title":"JuMP.set_objective_sense","text":"set_objective_sense(model::Model, sense::MathOptInterface.OptimizationSense)\n\nSets the objective sense of the model to the given sense. See set_objective_function to set the objective function. These are low-level functions; the recommended way to set the objective is with the @objective macro.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Getting started/an_introduction_to_julia.jl\"","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Getting-started-with-Julia","page":"Getting started with Julia","title":"Getting started with Julia","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Since JuMP is embedded in Julia, knowing some basic Julia is important for learning JuMP. This tutorial is designed to provide a minimalist crash course in the basics of Julia. You can find resources that provide a more comprehensive introduction to Julia here.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Installing-Julia","page":"Getting started with Julia","title":"Installing Julia","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"To install Julia, download the latest stable release, then follow the platform specific install instructions.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nUnless you know otherwise, you probably want the 64-bit version.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Next, you need an IDE to develop in. VS Code is a popular choice, so follow these install instructions.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Numbers-and-arithmetic","page":"Getting started with Julia","title":"Numbers and arithmetic","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Since we want to solve optimization problems, we're going to be using a lot of math. Luckily, Julia is great for math, with all the usual operators:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"@show 1 + 1\n@show 1 - 2\n@show 2 * 2\n@show 4 / 5\n@show 3^2\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nThe @ in front of something indicates that it is a macro, which is just a special type of function. In this case, @show prints the expression as typed (e.g., 1 - 2), as well as the evaluation of the expression (-1).","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Did you notice how Julia didn't print .0 after some of the numbers? Julia is a dynamic language, which means you never have to explicitly declare the type of a variable. However, in the background, Julia is giving each variable a type. Check the type of something using the typeof function:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"@show typeof(1)\n@show typeof(1.0)\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Here 1 is an Int64, which is an integer with 64 bits of precision, and 1.0 is a Float64, which is a floating point number with 64-bits of precision.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nIf you aren't familiar with floating point numbers, make sure to read the Floating point numbers section.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"We create complex numbers using im:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"x = 2 + 1im\n@show real(x)\n@show imag(x)\n@show typeof(x)\n@show x * (1 - 2im)\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nThe curly brackets surround what we call the parameters of a type. You can read Complex{Int64}  as \"a complex number, where the real and imaginary parts are represented by Int64.\" If we call typeof(1.0 + 2.0im) it will be Complex{Float64}, which a complex number with the parts represented by Float64.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"There are also some cool things like an irrational representation of œÄ.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"œÄ","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nTo make œÄ (and most other Greek letters), type \\pi and then press [TAB].","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(œÄ)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"However, if we do math with irrational numbers, they get converted to Float64:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(2œÄ / 3)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Floating-point-numbers","page":"Getting started with Julia","title":"Floating point numbers","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"warning: Warning\nIf you aren't familiar with floating point numbers, make sure to read this section carefully.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A Float64 is a floating point approximation of a real number using 64-bits of information.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Because it is an approximation, things we know hold true in mathematics don't hold true in a computer! For example:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"0.1 * 3 == 0.3","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"sin(2œÄ / 3) == ‚àö3 / 2","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nGet ‚àö by typing \\sqrt then press [TAB].","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Let's see what the differences are:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"0.1 * 3 - 0.3","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"sin(2œÄ / 3) - ‚àö3 / 2","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"They are small, but not zero!","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"One way of explaining this difference is to consider how we would write 1 / 3 and 2 / 3 using only four digits after the decimal point. We would write 1 / 3 as 0.3333, and 2 / 3 as 0.6667. So, despite the fact that 2 * (1 / 3) == 2 / 3, 2 * 0.3333 == 0.6666 != 0.6667.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Let's try that again using ‚âà (\\approx + [TAB]) instead of ==:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"0.1 * 3 ‚âà 0.3","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"sin(2œÄ / 3) ‚âà ‚àö3 / 2","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"‚âà is just a clever way of calling the isapprox function:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"isapprox(sin(2œÄ / 3), ‚àö3 / 2; atol = 1e-8)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"warning: Warning\nFloating point is the reason solvers use tolerances when they solve optimization models. A common mistake you're likely to make is checking whether a binary variable is 0 using value(z) == 0. Always remember to use something like isapprox when comparing floating point numbers.Gurobi has a good series of articles on the implications of floating point in optimization if you want to read more.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"If you aren't careful, floating point arithmetic can throw up all manner of issues. For example:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"1 + 1e-16 == 1","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"It even turns out that floating point numbers aren't associative!","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"(1 + 1e-16) - 1e-16 == 1 + (1e-16 - 1e-16)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"It's important to note that this issue isn't Julia-specific. It happens in every programming language (try it out in Python).","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Vectors,-matrices-and-arrays","page":"Getting started with Julia","title":"Vectors, matrices and arrays","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Similar to Matlab, Julia has native support for vectors, matrices and tensors; all of which are represented by arrays of different dimensions. Vectors are constructed by comma-separated elements surrounded by square brackets:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"b = [5, 6]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nArray{Int64, 1} means that this is an Array, with Int64 elements, and it has 1 dimension.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Matrices can by constructed with spaces separating the columns, and semicolons separating the rows:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A = [1.0 2.0; 3.0 4.0]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Note how this time the type is Array{Float64, 2}; the elements are Float64 and there are 2 dimensions.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"We can do linear algebra:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"x = A \\ b","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nHere is floating point at work again! x is approximately [-4, 4.5].","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A * x","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A * x ‚âà b","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Note that when multiplying vectors and matrices, dimensions matter. For example, you can't multiply a vector by a vector:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"try  #hide\nb * b\ncatch err; showerror(stderr, err); end  #hide","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"But multiplying transposes works:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"b' * b","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"b * b'","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Other-common-types","page":"Getting started with Julia","title":"Other common types","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Strings","page":"Getting started with Julia","title":"Strings","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Double quotes are used for strings:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(\"This is Julia\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Unicode is fine in strings:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(\"œÄ is about 3.1415\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Use println to print a string:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"println(\"Hello, World!\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"We can use $() to interpolate values into a string:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"x = 123\nprintln(\"The value of x is: $(x)\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Symbols","page":"Getting started with Julia","title":"Symbols","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Julia Symbols provide a way to make human readable unique identifiers:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":":my_id","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(:my_id)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"You can think of a Symbol as a String that takes up less memory, and that can't be modified.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Tuples","page":"Getting started with Julia","title":"Tuples","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Julia makes extensive use of a simple data structure called Tuples. Tuples are immutable collections of values. For example:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"t = (\"hello\", 1.2, :foo)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(t)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Tuples can be accessed by index, similar to arrays:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"t[2]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"And they be \"unpacked\" like so:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"a, b, c = t\nb","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The values can also be given names, which is a convenient way of making light-weight data structures.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"t = (word = \"hello\", num = 1.2, sym = :foo)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Values can be accessed using dot syntax:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"t.word","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Dictionaries","page":"Getting started with Julia","title":"Dictionaries","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Similar to Python, Julia has native support for dictionaries. Dictionaries provide a very generic way of mapping keys to values.  For example, a map of integers to strings:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d1 = Dict(1 => \"A\", 2 => \"B\", 4 => \"D\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nType-stuff again: Dict{Int64,String} is a dictionary with Int64 keys and String values.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Looking up a values uses the bracket syntax:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d1[2]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dictionaries support non-integer keys and can mix data types:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dict(\"A\" => 1, \"B\" => 2.5, \"D\" => 2 - 3im)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nJulia types form a hierarchy. Here the value type of the dictionary is Number, which is a generalization of Int64, Float64, and Complex{Int}. In general, having variables with \"Abstract\" types like Number can lead to slower code, so you should try to make sure every element in a dictionary or vector is the same type. For example, in this case we could represent every element as a Complex{Float64}:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dict(\"A\" => 1.0 + 0.0im, \"B\" => 2.5 + 0.0im, \"D\" => 2.0 - 3.0im)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dictionaries can be nested:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d2 = Dict(\"A\" => 1, \"B\" => 2, \"D\" => Dict(:foo => 3, :bar => 4))","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d2[\"B\"]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d2[\"D\"][:foo]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Loops","page":"Getting started with Julia","title":"Loops","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Julia has native support for for-each style loops with the syntax for <value> in <collection> end:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"for i in 1:5\n    println(i)\nend","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nRanges are constructed as start:stop, or start:step:stop.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"for i in [1.2, 2.3, 3.4, 4.5, 5.6]\n    println(i)\nend","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"This for-each loop also works with dictionaries:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"for (key, value) in Dict(\"A\" => 1, \"B\" => 2.5, \"D\" => 2 - 3im)\n    println(\"$(key): $(value)\")\nend","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Note that in contrast to vector languages like Matlab and R, loops do not result in a significant performance degradation in Julia.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Control-Flow","page":"Getting started with Julia","title":"Control Flow","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Julia control flow is similar to Matlab, using the keywords if-elseif-else-end, and the logical operators || and && for or and and respectively:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"for i in 0:3:15\n    if i < 5\n        println(\"$(i) is less than 5\")\n    elseif i < 10\n        println(\"$(i) is less than 10\")\n    else\n        if i == 10\n            println(\"the value is 10\")\n        else\n            println(\"$(i) is bigger than 10\")\n        end\n    end\nend","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Comprehensions","page":"Getting started with Julia","title":"Comprehensions","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Similar to languages like Haskell and Python, Julia supports the use of simple loops in the construction of arrays and dictionaries, called comprehensions.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A list of increasing integers:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"[i for i in 1:5]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Matrices can be built by including multiple indices:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"[i * j for i in 1:5, j in 5:10]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Conditional statements can be used to filter out some values:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"[i for i in 1:10 if i % 2 == 1]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A similar syntax can be used for building dictionaries:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dict(\"$(i)\" => i for i in 1:10 if i % 2 == 1)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Functions","page":"Getting started with Julia","title":"Functions","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A simple function is defined as follows:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function print_hello()\n    println(\"hello\")\nend\nprint_hello()","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Arguments can be added to a function:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function print_it(x)\n    println(x)\nend\nprint_it(\"hello\")\nprint_it(1.234)\nprint_it(:my_id)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Optional keyword arguments are also possible:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function print_it(x; prefix = \"value:\")\n    println(\"$(prefix) $(x)\")\nend\nprint_it(1.234)\nprint_it(1.234, prefix = \"val:\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The keyword return is used to specify the return values of a function:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function mult(x; y = 2.0)\n    return x * y\nend\n\nmult(4.0)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"mult(4.0, y = 5.0)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Anonymous-functions","page":"Getting started with Julia","title":"Anonymous functions","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The syntax input -> output creates an anonymous function. These are most useful when passed to other functions. For example:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"f = x -> x^2\nf(2)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"map(x -> x^2, 1:4)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Type-parameters","page":"Getting started with Julia","title":"Type parameters","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"We can constrain the inputs to a function using type parameters, which are :: followed by the type of the input we want. For example:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function foo(x::Int)\n    return x^2\nend\n\nfunction foo(x::Float64)\n    return exp(x)\nend\n\nfunction foo(x::Number)\n    return x + 1\nend\n\n@show foo(2)\n@show foo(2.0)\n@show foo(1 + 1im)\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"But what happens if we call foo with something we haven't defined it for?","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"try  #hide\nfoo([1, 2, 3])\ncatch err; showerror(stdout, err) end  #hide","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"We get a dreaded MethodError! A MethodError means that you passed a function something that didn't match the type that it was expecting. In this case, the error message says that it doesn't know how to handle an Array{Int64, 1}, but it does know how to handle Float64, Int64, and Number.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nRead the \"Closest candidates\" part of the error message carefully to get a hint as to what was expected.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Broadcasting","page":"Getting started with Julia","title":"Broadcasting","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"In the example above, we didn't define what to do if f was passed an Array. Luckily, Julia provides a convenient syntax for mapping f element-wise over arrays! Just add a . between the name of the function and the opening (. This works for any function, including functions with multiple arguments. For example:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"f.([1, 2, 3])","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nGet a MethodError when calling a function that takes an Array? Try broadcasting it!","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Mutable-vs-immutable-objects","page":"Getting started with Julia","title":"Mutable vs immutable objects","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Some types in Julia are mutable, which means you can change the values inside them. A good example is an array. You can modify the contents of an array without having to make a new array.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"In contrast, types like Float64 are immutable. You can't modify the contents of a Float64.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"This is something to be aware of when passing types into functions. For example:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function mutability_example(mutable_type::Vector{Int}, immutable_type::Int)\n    mutable_type[1] += 1\n    immutable_type += 1\n    return\nend\n\nmutable_type = [1, 2, 3]\nimmutable_type = 1\n\nmutability_example(mutable_type, immutable_type)\n\nprintln(\"mutable_type: $(mutable_type)\")\nprintln(\"immutable_type: $(immutable_type)\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Because Vector{Int} is a mutable type, modifying the variable inside the function changed the value outside of the function. In contrast, the change to immutable_type didn't modify the value outside the function.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"You can check mutability with the isimmutable function:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"isimmutable([1, 2, 3])","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"isimmutable(1)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#The-package-manager","page":"Getting started with Julia","title":"The package manager","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Installing-packages","page":"Getting started with Julia","title":"Installing packages","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"No matter how wonderful Julia's base language is, at some point you will want to use an extension package.  Some of these are built-in, for example random number generation is available in the Random package in the standard library. These packages are loaded with the commands using and import.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"using Random  # The equivalent of Python's `from Random import *`\nimport Random  # The equivalent of Python's `import Random`\n\nRandom.seed!(33)\n\n[rand() for i in 1:10]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The Package Manager is used to install packages that are not part of Julia's standard library.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"For example the following can be used to install JuMP,","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"using Pkg\nPkg.add(\"JuMP\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"For a complete list of registered Julia packages see the package listing at JuliaHub.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"From time to you may wish to use a Julia package that is not registered.  In this case a git repository URL can be used to install the package.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"using Pkg\nPkg.add(\"https://github.com/user-name/MyPackage.jl.git\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Package-environments","page":"Getting started with Julia","title":"Package environments","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"By default, Pkg.add will add packages to Julia's global environment. However, Julia also has built-in support for virtual environments.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Activate a virtual environment with:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"import Pkg; Pkg.activate(\"/path/to/environment\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"You can see what packages are installed in the current environment with Pkg.status().","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nWe strongly recommend you create a Pkg environment for each project that you create in Julia, and add only the packages that you need, instead of adding lots of packages to the global environment. The Pkg manager documentation has more information on this topic.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"View this file on Github.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"This page was generated using Literate.jl.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"moi/manual/constraints/#Add-a-constraint","page":"Constraints","title":"Add a constraint","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Use add_constraint to add a single constraint.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> c = MOI.add_constraint(model, MOI.VectorOfVariables(x), MOI.Nonnegatives(2))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables,MathOptInterface.Nonnegatives}(1)","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"add_constraint returns a ConstraintIndex type, which should be used to refer to the added constraint in other calls.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Check if a ConstraintIndex is valid using is_valid.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> MOI.is_valid(model, c)\ntrue","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Use add_constraints to add a number of constraints of the same type.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> c = MOI.add_constraints(\n           model,\n           [MOI.SingleVariable(x[1]), MOI.SingleVariable(x[2])],\n           [MOI.GreaterThan(0.0), MOI.GreaterThan(1.0)]\n       )\n2-element Array{MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}},1}:\n MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1)\n MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2)","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"This time, a vector of ConstraintIndex are returned.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Use supports_constraint to check if the model supports adding a constraint type.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> MOI.supports_constraint(\n           model,\n           MOI.SingleVariable,\n           MOI.GreaterThan{Float64},\n       )\ntrue","category":"page"},{"location":"moi/manual/constraints/#Delete-a-constraint","page":"Constraints","title":"Delete a constraint","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Use delete to delete a constraint.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> MOI.delete(model, c)\n\njulia> MOI.is_valid(model, c)\nfalse","category":"page"},{"location":"moi/manual/constraints/#Constraint-attributes","page":"Constraints","title":"Constraint attributes","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"The following attributes are available for constraints:","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"ConstraintName\nConstraintPrimalStart\nConstraintDualStart\nConstraintPrimal\nConstraintDual\nConstraintBasisStatus\nConstraintFunction\nCanonicalConstraintFunction\nConstraintSet","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Get and set these attributes using get and set.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> MOI.set(model, MOI.ConstraintName(), c, \"con_c\")\n\njulia> MOI.get(model, MOI.ConstraintName(), c)\n\"con_c\"","category":"page"},{"location":"moi/manual/constraints/#Constraints-by-function-set-pairs","page":"Constraints","title":"Constraints by function-set pairs","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Below is a list of common constraint types and how they are represented as function-set pairs in MOI. In the notation below, x is a vector of decision variables, x_i is a scalar decision variable, alpha beta are scalar constants, a b are constant vectors, A is a constant matrix and mathbbR_+ (resp. mathbbR_-) is the set of nonnegative (resp. nonpositive) real numbers.","category":"page"},{"location":"moi/manual/constraints/#Linear-constraints","page":"Constraints","title":"Linear constraints","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Mathematical Constraint MOI Function MOI Set\na^Tx le beta ScalarAffineFunction LessThan\na^Tx ge alpha ScalarAffineFunction GreaterThan\na^Tx = beta ScalarAffineFunction EqualTo\nalpha le a^Tx le beta ScalarAffineFunction Interval\nx_i le beta SingleVariable LessThan\nx_i ge alpha SingleVariable GreaterThan\nx_i = beta SingleVariable EqualTo\nalpha le x_i le beta SingleVariable Interval\nAx + b in mathbbR_+^n VectorAffineFunction Nonnegatives\nAx + b in mathbbR_-^n VectorAffineFunction Nonpositives\nAx + b = 0 VectorAffineFunction Zeros","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"By convention, solvers are not expected to support nonzero constant terms in the ScalarAffineFunctions the first four rows above, because they are redundant with the parameters of the sets. For example, 2x + 1 le 2 should be encoded as 2x le 1.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Constraints with SingleVariable in LessThan, GreaterThan, EqualTo, or Interval sets have a natural interpretation as variable bounds. As such, it is typically not natural to impose multiple lower- or upper-bounds on the same variable, and the solver interfaces should throw respectively LowerBoundAlreadySet or UpperBoundAlreadySet.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Moreover, adding two SingleVariable constraints on the same variable with the same set is impossible because they share the same index as it is the index of the variable, see ConstraintIndex.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"It is natural, however, to impose upper- and lower-bounds separately as two different constraints on a single variable. The difference between imposing bounds by using a single Interval constraint and by using separate LessThan and GreaterThan constraints is that the latter will allow the solver to return separate dual multipliers for the two bounds, while the former will allow the solver to return only a single dual for the interval constraint.","category":"page"},{"location":"moi/manual/constraints/#Conic-constraints","page":"Constraints","title":"Conic constraints","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Mathematical Constraint MOI Function MOI Set\nlVert Ax + brVert_2 le c^Tx + d VectorAffineFunction SecondOrderCone\ny ge lVert x rVert_2 VectorOfVariables SecondOrderCone\n2yz ge lVert x rVert_2^2 yz ge 0 VectorOfVariables RotatedSecondOrderCone\n(a_1^Tx + b_1a_2^Tx + b_2a_3^Tx + b_3) in mathcalE VectorAffineFunction ExponentialCone\nA(x) in mathcalS_+ VectorAffineFunction PositiveSemidefiniteConeTriangle\nB(x) in mathcalS_+ VectorAffineFunction PositiveSemidefiniteConeSquare\nx in mathcalS_+ VectorOfVariables PositiveSemidefiniteConeTriangle\nx in mathcalS_+ VectorOfVariables PositiveSemidefiniteConeSquare","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"where mathcalE is the exponential cone (see ExponentialCone), mathcalS_+ is the set of positive semidefinite symmetric matrices, A is an affine map that outputs symmetric matrices and B is an affine map that outputs square matrices.","category":"page"},{"location":"moi/manual/constraints/#Quadratic-constraints","page":"Constraints","title":"Quadratic constraints","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Mathematical Constraint MOI Function MOI Set\nx^TQx + a^Tx + b ge 0 ScalarQuadraticFunction GreaterThan\nx^TQx + a^Tx + b le 0 ScalarQuadraticFunction LessThan\nx^TQx + a^Tx + b = 0 ScalarQuadraticFunction EqualTo\nBilinear matrix inequality VectorQuadraticFunction PositiveSemidefiniteCone...","category":"page"},{"location":"moi/manual/constraints/#Discrete-and-logical-constraints","page":"Constraints","title":"Discrete and logical constraints","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Mathematical Constraint MOI Function MOI Set\nx_i in mathbbZ SingleVariable Integer\nx_i in 01 SingleVariable ZeroOne\nx_i in 0 cup lu SingleVariable Semicontinuous\nx_i in 0 cup ll+1ldotsu-1u SingleVariable Semiinteger\nAt most one component of x can be nonzero VectorOfVariables SOS1\nAt most two components of x can be nonzero, and if so they must be adjacent components VectorOfVariables SOS2\ny = 1 implies a^T x in S VectorAffineFunction IndicatorSet","category":"page"},{"location":"moi/manual/constraints/#JuMP-mapping","page":"Constraints","title":"JuMP mapping","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"The following bullet points show examples of how JuMP constraints are translated into MOI function-set pairs:","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"@constraint(m, 2x + y <= 10) becomes ScalarAffineFunction-in-LessThan\n@constraint(m, 2x + y >= 10) becomes ScalarAffineFunction-in-GreaterThan\n@constraint(m, 2x + y == 10) becomes ScalarAffineFunction-in-EqualTo\n@constraint(m, 0 <= 2x + y <= 10) becomes ScalarAffineFunction-in-Interval\n@constraint(m, 2x + y in ArbitrarySet()) becomes ScalarAffineFunction-in-ArbitrarySet.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Variable bounds are handled in a similar fashion:","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"@variable(m, x <= 1) becomes SingleVariable-in-LessThan\n@variable(m, x >= 1) becomes SingleVariable-in-GreaterThan","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"One notable difference is that a variable with an upper and lower bound is translated into two constraints, rather than an interval. i.e.:","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"@variable(m, 0 <= x <= 1) becomes SingleVariable-in-LessThan and  SingleVariable-in-GreaterThan.","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Semidefinite programs/min_distortion.jl\"","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/#The-minimum-distortion-problem","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"This example arises from computational geometry, in particular the problem of embedding a general finite metric space into a euclidean space.","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"It is known that the 4-point metric space defined by the star graph:","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"x\n \\\\\n  x ‚Äî x\n /\nx","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"where distances are computed by length of the shortest path between vertices, cannot be exactly embedded into a euclidean space of any dimension.","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"Here we will formulate and solve an SDP to compute the best possible embedding, that is, the embedding f() that minimizes the distortion c such that","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"(1 / c) * D(a, b) ‚â§ ||f(a) - f(b)|| ‚â§ D(a, b)","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"for all points (a, b), where D(a, b) is the distance in the metric space.","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"Any embedding can be characterized by its Gram matrix Q, which is PSD, and","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"||f(a) - f(b)||^2 = Q[a, a] + Q[b, b] - 2 * Q[a, b]","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"We can therefore constrain","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"D[i, j]^2 ‚â§ Q[i, i] + Q[j, j] - 2 * Q[i, j] ‚â§ c^2 * D[i, j]^2","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"and minimize c^2, which gives us the SDP formulation below.","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"For more detail, see \"Lectures on discrete geometry\" by J. Matou≈°ek, Springer, 2002, pp. 378-379.","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"using JuMP\nimport SCS\nimport Test\n\nfunction example_min_distortion()\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    D = [\n        0.0 1.0 1.0 1.0;\n        1.0 0.0 2.0 2.0;\n        1.0 2.0 0.0 2.0;\n        1.0 2.0 2.0 0.0\n    ]\n    @variable(model, c¬≤ >= 1.0)\n    @variable(model, Q[1:4, 1:4], PSD)\n    for i in 1:4\n        for j in (i + 1):4\n            @constraint(model, D[i, j]^2 <= Q[i, i] + Q[j, j] - 2 * Q[i, j])\n            @constraint(model, Q[i, i] + Q[j, j] - 2 * Q[i, j] <= c¬≤ * D[i, j]^2)\n        end\n    end\n    @objective(model, Min, c¬≤)\n    optimize!(model)\n    Test.@test termination_status(model) == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ‚âà 4/3 atol = 1e-4\n    return\nend\n\nexample_min_distortion()","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/diet/","page":"The diet problem","title":"The diet problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/diet.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/diet/#The-diet-problem","page":"The diet problem","title":"The diet problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/diet/","page":"The diet problem","title":"The diet problem","text":"Solve the classic \"diet problem\", also known as the Stigler diet. The code is based on an example from Gurobi.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/diet/","page":"The diet problem","title":"The diet problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction print_solution(is_optimal, foods, buy)\n    println(\"RESULTS:\")\n    if is_optimal\n        for food in foods\n            println(\"  $(food) = $(value(buy[food]))\")\n        end\n    else\n        println(\"The solver did not find an optimal solution.\")\n    end\nend\n\nfunction example_diet(; verbose = true)\n    # Nutrition guidelines\n    categories = [\"calories\", \"protein\", \"fat\", \"sodium\"]\n    category_data = Containers.DenseAxisArray([\n        1800 2200;\n        91   Inf;\n        0    65;\n        0    1779\n        ], categories, [\"min\", \"max\"]\n    )\n    Test.@test category_data[\"protein\", \"min\"] == 91.0\n    Test.@test category_data[\"sodium\", \"max\"] == 1779.0\n    # Foods\n    foods = [\n        \"hamburger\", \"chicken\", \"hot dog\", \"fries\", \"macaroni\", \"pizza\",\n        \"salad\", \"milk\", \"ice cream\",\n    ]\n    cost = Containers.DenseAxisArray(\n        [2.49, 2.89, 1.50, 1.89, 2.09, 1.99, 2.49, 0.89, 1.59],\n        foods\n    )\n    food_data = Containers.DenseAxisArray(\n        [\n            410 24 26 730;\n            420 32 10 1190;\n            560 20 32 1800;\n            380  4 19 270;\n            320 12 10 930;\n            320 15 12 820;\n            320 31 12 1230;\n            100  8 2.5 125;\n            330  8 10 180\n        ], foods, categories\n    )\n    Test.@test food_data[\"hamburger\", \"calories\"] == 410.0\n    Test.@test food_data[\"milk\", \"fat\"] == 2.5\n    # Build model\n    model = Model(GLPK.Optimizer)\n    @variables(model, begin\n        # Variables for nutrition info\n        category_data[c, \"min\"] <= nutrition[c = categories] <= category_data[c, \"max\"]\n        # Variables for which foods to buy\n        buy[foods] >= 0\n    end)\n    # Objective - minimize cost\n    @objective(model, Min, sum(cost[f] * buy[f] for f in foods))\n    # Nutrition constraints\n    @constraint(model, [c in categories],\n        sum(food_data[f, c] * buy[f] for f in foods) == nutrition[c]\n    )\n    # Solve\n    if verbose\n        println(\"Solving original problem...\")\n    end\n    optimize!(model)\n    term_status = termination_status(model)\n    is_optimal = term_status == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ‚âà 11.8288 atol = 1e-4\n    if verbose\n        print_solution(is_optimal, foods, buy)\n    end\n    # Limit dairy (note that the problem will become infeasible).\n    @constraint(model, buy[\"milk\"] + buy[\"ice cream\"] <= 6)\n    if verbose\n        println(\"Solving dairy-limited problem...\")\n    end\n    optimize!(model)\n    Test.@test termination_status(model) == MOI.INFEASIBLE\n    Test.@test primal_status(model) == MOI.NO_SOLUTION\n    if verbose\n        print_solution(false, foods, buy)\n    end\n    return\nend\n\nexample_diet()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/diet/","page":"The diet problem","title":"The diet problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/diet/","page":"The diet problem","title":"The diet problem","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/diet/","page":"The diet problem","title":"The diet problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/geographic_clustering.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/#Geographical-Clustering","page":"Geographical Clustering","title":"Geographical Clustering","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"Originally Contributed by: Matthew Helm (with help from Mathieu Tanneau on Julia Discourse)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"The goal of this exercise is to cluster n cities into k groups, minimizing the total pairwise distance between cities and ensuring that the variance in the total populations of each group is relatively small.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"using JuMP\nimport DataFrames\nimport GLPK\nimport LinearAlgebra","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"For this example, we'll use the 20 most populous cities in the United States.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"cities = DataFrames.DataFrame(\n    city = [\"New York, NY\", \"Los Angeles, CA\", \"Chicago, IL\", \"Houston, TX\", \"Philadelphia, PA\", \"Phoenix, AZ\", \"San Antonio, TX\", \"San Diego, CA\", \"Dallas, TX\", \"San Jose, CA\", \"Austin, TX\", \"Indianapolis, IN\", \"Jacksonville, FL\", \"San Francisco, CA\", \"Columbus, OH\", \"Charlotte, NC\", \"Fort Worth, TX\", \"Detroit, MI\", \"El Paso, TX\", \"Memphis, TN\"],\n    population = [8.405,3.884,2.718,2.195,1.553,1.513,1.409,1.355,1.257,0.998,0.885,0.843,0.842,0.837,0.822,0.792,0.792,0.688,0.674,0.653],\n    lat = [40.7127,34.0522,41.8781,29.7604,39.9525,33.4483,29.4241,32.7157,32.7766,37.3382,30.2671,39.7684,30.3321,37.7749,39.9611,35.2270,32.7554,42.3314,31.7775,35.1495],\n    lon = [-74.0059,-118.2436,-87.6297,-95.3698,-75.1652,-112.0740,-98.4936,-117.1610,-96.7969,-121.8863,-97.7430,-86.1580,-81.6556,-122.4194,-82.9987,-80.8431,-97.3307,-83.0457,-106.4424,-90.0489],\n)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/#Model-Specifics","page":"Geographical Clustering","title":"Model Specifics","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"We will cluster these 20 cities into 3 different groups and we will assume that the ideal or target population P for a group is simply the total population of the 20 cities divided by 3:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"n = size(cities,1)\nk = 3\nP = sum(cities.population) / k","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/#Obtaining-the-distances-between-each-city","page":"Geographical Clustering","title":"Obtaining the distances between each city","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"Let's compute the pairwise Haversine distance between each of the cities in our data set and store the result in a variable we'll call dm:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"\"\"\"\n    haversine(lat1, long1, lat2, long2, r = 6372.8)\n\nCompute the haversine distance between two points on a sphere of radius `r`,\nwhere the points are given by the latitude/longitude pairs `lat1/long1` and\n`lat2/long2` (in degrees).\n\"\"\"\nfunction haversine(lat1, long1, lat2, long2, r = 6372.8)\n    lat1, long1 = deg2rad(lat1), deg2rad(long1)\n    lat2, long2 = deg2rad(lat2), deg2rad(long2)\n    hav(a, b) = sin((b - a) / 2)^2\n    inner_term = hav(lat1, lat2) + cos(lat1) * cos(lat2) * hav(long1, long2)\n    d = 2 * r * asin(sqrt(inner_term))\n    # Round distance to nearest kilometer.\n    return round(Int, d)\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"Our distance matrix is symmetric so we'll convert it to a LowerTriangular matrix so that we can better interpret the objective value of our model:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"dm = LinearAlgebra.LowerTriangular([\n    haversine(cities.lat[i], cities.lon[i], cities.lat[j], cities.lon[j])\n    for i = 1:n, j = 1:n\n])","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/#Build-the-model","page":"Geographical Clustering","title":"Build the model","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"Now that we have the basics taken  care of, we can set up our model, create decision variables, add constraints, and then solve.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"First, we'll set up a model that leverages the Cbc solver. Next, we'll set up a binary variable x_ik that takes the value 1 if city i is in group k and 0 otherwise. Each city must be in a group, so we'll add the constraint sum_kx_ik = 1 for every i.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"model = Model(GLPK.Optimizer)\nset_silent(model)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"@variable(model, x[1:n, 1:k], Bin)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"@constraint(model, [i = 1:n], sum(x[i, :]) == 1)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"To reduce symmetry, we fix the first city to belong to the first group.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"fix(x[1, 1], 1; force = true)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"The total population of a group k is Q_k = sum_ix_ikq_i where q_i is simply the ith value from the population column in our cities DataFrame. Let's add constraints so that alpha leq (Q_k - P) leq beta. We'll set alpha equal to -3 million and beta equal to 3. By adjusting these thresholds you'll find that there is a tradeoff between having relatively even populations between groups and having geographically close cities within each group. In other words, the larger the absolute values of alpha and beta, the closer together the cities in a group will be but the variance between the group populations will be higher.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"@variable(model, -3 <= population_diff[1:k] <= 3)\n@constraint(model, population_diff .== x' * cities.population .- P)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"Now we need to add one last binary variable z_ij to our model that we'll use to compute the total distance between the cities in our groups, defined as sum_ijd_ijz_ij. Variable z_ij will equal 1 if cities i and j are in the same group, and 0 if they are not in the same group.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"To ensure that z_ij = 1 if and only if cities i and j are in the same group, we add the constraints z_ij geq x_ik + x_jk - 1 for every pair ij and every k:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"@variable(model, z[i = 1:n, j = 1:i], Bin)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"for k in 1:k, i in 1:n, j in 1:i\n    @constraint(model, z[i, j] >= x[i, k] + x[j, k] - 1)\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"We can now add an objective to our model which will simply be to minimize the dot product of z and our distance matrix, dm.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"@objective(model, Min, sum(dm[i, j] * z[i, j] for i = 1:n, j = 1:i))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"We can then call optimize! and review the results.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"optimize!(model)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/#Reviewing-the-Results","page":"Geographical Clustering","title":"Reviewing the Results","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"Now that we have results, we can add a column to our cities DataFrame for the group and then loop through our x variable to assign each city to its group. Once we have that, we can look at the total population for each group and also look at the cities in each group to verify that they are grouped by geographic proximity.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"cities.group = zeros(n)\n\nfor i = 1:n, j = 1:k\n    if round(Int, value(x[i, j])) == 1\n        cities.group[i] = j\n    end\nend\n\nfor group in DataFrames.groupby(cities, :group)\n    @show group\n    println(\"\")\n    @show sum(group.population)\n    println(\"\")\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/factory_schedule.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/#The-factory-schedule-example","page":"The factory schedule example","title":"The factory schedule example","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"This is a Julia translation of part 5 from \"Introduction to to Linear Programming with Python\" available at https://github.com/benalexkeen/Introduction-to-linear-programming","category":"page"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"For 2 factories (A, B), minimize the cost of production over the course of 12 months while meeting monthly demand. Factory B has a planned outage during month 5.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"It was originally contributed by @Crghilardi.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_factory_schedule()\n   # Sets in the problem:\n   months, factories = 1:12, [:A, :B]\n   # This function takes a matrix and converts it to a JuMP container so we can\n   # refer to elements such as `d_max_cap[1, :A]`.\n   containerize(A::Matrix) = Containers.DenseAxisArray(A, months, factories)\n   # Maximum production capacity in (month, factory) [units/month]:\n   d_max_cap = containerize([\n         100000\t50000;\n         110000\t55000;\n         120000\t60000;\n         145000\t100000;\n         160000\t0;\n         140000\t70000;\n         155000\t60000;\n         200000\t100000;\n         210000\t100000;\n         197000\t100000;\n         80000\t120000;\n         150000\t150000;\n   ])\n   # Minimum production capacity in (month, factory) [units/month]:\n   d_min_cap = containerize([\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t0;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n   ])\n   # Variable cost of production in (month, factory) [$/unit]:\n   d_var_cost = containerize([\n         10\t5;\n         11\t4;\n         12\t3;\n         9\t5;\n         8\t0;\n         8\t6;\n         5\t4;\n         7\t6;\n         9\t8;\n         10\t11;\n         8\t10;\n         8\t12\n   ])\n   # Fixed cost of production in (month, factory) # [$/month]:\n   d_fixed_cost = containerize([\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t0;\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t600\n   ])\n   # Demand in each month [units/month]:\n   d_demand = [\n      120_000,\n      100_000,\n      130_000,\n      130_000,\n      140_000,\n      130_000,\n      150_000,\n      170_000,\n      200_000,\n      190_000,\n      140_000,\n      100_000,\n   ]\n   # The model!\n   model = Model(GLPK.Optimizer)\n   # Decision variables\n   @variables(model, begin\n      status[m in months, f in factories], Bin\n      production[m in months, f in factories], Int\n   end)\n   # The production cannot be less than minimum capacity.\n   @constraint(\n      model,\n      [m in months, f in factories],\n      production[m, f] >= d_min_cap[m, f] * status[m, f],\n   )\n   # The production cannot be more that maximum capacity.\n   @constraint(\n      model,\n      [m in months, f in factories],\n      production[m, f] <= d_max_cap[m, f] * status[m, f],\n   )\n   # The production must equal demand in a given month.\n   @constraint(model, [m in months], sum(production[m, :]) == d_demand[m])\n   # Factory B is shut down during month 5, so production and status are both\n   # zero.\n   fix(status[5, :B], 0.0)\n   fix(production[5, :B], 0.0)\n   # The objective is to minimize the cost of production across all time\n   ##periods.\n   @objective(\n      model,\n      Min,\n      sum(\n         d_fixed_cost[m, f] * status[m, f] + d_var_cost[m, f] * production[m, f]\n         for m in months, f in factories\n      )\n   )\n   # Optimize the problem\n   optimize!(model)\n   # Check the solution!\n   Test.@testset \"Check the solution against known optimal\" begin\n      Test.@test termination_status(model) == MOI.OPTIMAL\n      Test.@test objective_value(model) == 12_906_400.0\n      Test.@test value.(production)[1, :A] == 70_000\n      Test.@test value.(status)[1, :A] == 1\n      Test.@test value.(status)[5, :B] == 0\n      Test.@test value.(production)[5, :B] == 0\n   end\n   println(\"The production schedule is:\")\n   println(value.(production))\n   return\nend\n\nexample_factory_schedule()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/example/#A-complete-example:-solving-a-knapsack-problem","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"","category":"section"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"In this example, we want to solve a binary-constrained knapsack problem:","category":"page"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"beginaligned\nmax   c^top x       \nst   w^top x le C \n         x_i in 01quad forall i=1ldotsn\nendaligned","category":"page"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"As an optimizer, we choose GLPK:","category":"page"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"using GLPK\noptimizer = GLPK.Optimizer()","category":"page"},{"location":"moi/manual/example/#Define-the-data","page":"A complete example: solving a knapsack problem","title":"Define the data","text":"","category":"section"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"We first define the constants of the problem:","category":"page"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"julia> c = [1.0, 2.0, 3.0]\n3-element Array{Float64,1}:\n 1.0\n 2.0\n 3.0\n\njulia> w = [0.3, 0.5, 1.0]\n3-element Array{Float64,1}:\n 0.3\n 0.5\n 1.0\n\njulia> C = 3.2\n3.2","category":"page"},{"location":"moi/manual/example/#Add-the-variables","page":"A complete example: solving a knapsack problem","title":"Add the variables","text":"","category":"section"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"julia> x = MOI.add_variables(optimizer, length(c));","category":"page"},{"location":"moi/manual/example/#set_objective_example","page":"A complete example: solving a knapsack problem","title":"Set the objective","text":"","category":"section"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"julia> MOI.set(\n           optimizer,\n           MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n           MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(c, x), 0.0),\n       );\n\njulia> MOI.set(optimizer, MOI.ObjectiveSense(), MOI.MAX_SENSE)","category":"page"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"tip: Tip\nMOI.ScalarAffineTerm.(c, x) is a shortcut for [MOI.ScalarAffineTerm(c[i], x[i]) for i = 1:3]. This is Julia's broadcast syntax in action, and is used quite often throughout MOI.","category":"page"},{"location":"moi/manual/example/#Add-the-constraints","page":"A complete example: solving a knapsack problem","title":"Add the constraints","text":"","category":"section"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"We add the knapsack constraint and integrality constraints:","category":"page"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"julia> MOI.add_constraint(\n           optimizer,\n           MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(w, x), 0.0),\n           MOI.LessThan(C),\n       );","category":"page"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"Add integrality constraints:","category":"page"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"julia> for x_i in x\n           MOI.add_constraint(optimizer, MOI.SingleVariable(x_i), MOI.ZeroOne())\n       end","category":"page"},{"location":"moi/manual/example/#Optimize-the-model","page":"A complete example: solving a knapsack problem","title":"Optimize the model","text":"","category":"section"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"julia> MOI.optimize!(optimizer)","category":"page"},{"location":"moi/manual/example/#Understand-why-the-solver-stopped","page":"A complete example: solving a knapsack problem","title":"Understand why the solver stopped","text":"","category":"section"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"The first thing to check after optimization is why the solver stopped, e.g., did it stop because of a time limit or did it stop because it found the optimal solution?","category":"page"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"julia> MOI.get(optimizer, MOI.TerminationStatus())\nOPTIMAL::TerminationStatusCode = 1","category":"page"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"Looks like we found an optimal solution!","category":"page"},{"location":"moi/manual/example/#Understand-what-solution-was-returned","page":"A complete example: solving a knapsack problem","title":"Understand what solution was returned","text":"","category":"section"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"julia> MOI.get(optimizer, MOI.ResultCount())\n1\n\njulia> MOI.get(optimizer, MOI.PrimalStatus())\nFEASIBLE_POINT::ResultStatusCode = 1\n\njulia> MOI.get(optimizer, MOI.DualStatus())\nNO_SOLUTION::ResultStatusCode = 0","category":"page"},{"location":"moi/manual/example/#Query-the-objective","page":"A complete example: solving a knapsack problem","title":"Query the objective","text":"","category":"section"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"What is its objective value?","category":"page"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"julia> MOI.get(optimizer, MOI.ObjectiveValue())\n6.0","category":"page"},{"location":"moi/manual/example/#Query-the-primal-solution","page":"A complete example: solving a knapsack problem","title":"Query the primal solution","text":"","category":"section"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"And what is the value of the variables x?","category":"page"},{"location":"moi/manual/example/","page":"A complete example: solving a knapsack problem","title":"A complete example: solving a knapsack problem","text":"julia> MOI.get(optimizer, MOI.VariablePrimal(), x)\n3-element Array{Float64,1}:\n 1.0\n 1.0\n 1.0","category":"page"},{"location":"moi/submodules/Benchmarks/reference/","page":"API Reference","title":"API Reference","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/submodules/Benchmarks/reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\n\n    # For compatibility with both Julia 1.0.5 and 1.5.2\n    # Upon the Julia LTS version becoming 1.6, these imports could be dropped,\n    # and all ScalarAffineTerm and VariableIndex instances in doctests below\n    # could be replaced with MOI.ScalarAffineTerm and MOI.VariableIndex\n    # Check discussion at PR 1184: https://github.com/jump-dev/MathOptInterface.jl/pull/1184#discussion_r515300914\n    import MathOptInterface.ScalarAffineTerm\n    import MathOptInterface.VariableIndex\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Benchmarks/reference/#Benchmarks","page":"API Reference","title":"Benchmarks","text":"","category":"section"},{"location":"moi/submodules/Benchmarks/reference/","page":"API Reference","title":"API Reference","text":"Functions to help benchmark the performance of solver wrappers. See The Benchmarks submodule for more details.","category":"page"},{"location":"moi/submodules/Benchmarks/reference/","page":"API Reference","title":"API Reference","text":"Benchmarks.suite\nBenchmarks.create_baseline\nBenchmarks.compare_against_baseline","category":"page"},{"location":"moi/submodules/Benchmarks/reference/#MathOptInterface.Benchmarks.suite","page":"API Reference","title":"MathOptInterface.Benchmarks.suite","text":"suite(\n    new_model::Function;\n    exclude::Vector{Regex} = Regex[]\n)\n\nCreate a suite of benchmarks. new_model should be a function that takes no arguments, and returns a new instance of the optimizer you wish to benchmark.\n\nUse exclude to exclude a subset of benchmarks.\n\nExamples\n\nsuite() do\n    GLPK.Optimizer()\nend\nsuite(exclude = [r\"delete\"]) do\n    Gurobi.Optimizer(OutputFlag=0)\nend\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Benchmarks/reference/#MathOptInterface.Benchmarks.create_baseline","page":"API Reference","title":"MathOptInterface.Benchmarks.create_baseline","text":"create_baseline(suite, name::String; directory::String = \"\"; kwargs...)\n\nRun all benchmarks in suite and save to files called name in directory.\n\nExtra kwargs are based to BenchmarkTools.run.\n\nExamples\n\nmy_suite = suite(() -> GLPK.Optimizer())\ncreate_baseline(my_suite, \"glpk_master\"; directory = \"/tmp\", verbose = true)\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Benchmarks/reference/#MathOptInterface.Benchmarks.compare_against_baseline","page":"API Reference","title":"MathOptInterface.Benchmarks.compare_against_baseline","text":"compare_against_baseline(\n    suite, name::String; directory::String = \"\",\n    report_filename::String = \"report.txt\"\n)\n\nRun all benchmarks in suite and compare against files called name in directory that were created by a call to create_baseline.\n\nA report summarizing the comparison is written to report_filename in directory.\n\nExtra kwargs are based to BenchmarkTools.run.\n\nExamples\n\nmy_suite = suite(() -> GLPK.Optimizer())\ncompare_against_baseline(\n    my_suite, \"glpk_master\"; directory = \"/tmp\", verbose = true\n)\n\n\n\n\n\n","category":"function"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"warning: Warning\nThis documentation is still under construction. If you need help with JuMP, read the JuMP documentation instead. If you are writing a solver interface and need help with MOI, join the developer chatroom and ask away!","category":"page"},{"location":"moi/#MathOptInterface","page":"Introduction","title":"MathOptInterface","text":"","category":"section"},{"location":"moi/#What-is-MathOptInterface?","page":"Introduction","title":"What is MathOptInterface?","text":"","category":"section"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"MathOptInterface.jl (MOI) is an abstraction layer designed to provide a unified interface to mathematical optimization solvers so that users do not need to understand multiple solver-specific APIs.","category":"page"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"tip: Tip\nThis documentation is aimed at developers writing software interfaces to solvers and modeling languages using the MathOptInterface API. If you are a user interested in solving optimization problems, we encourage you instead to use MOI through a higher-level modeling interface like JuMP or Convex.jl.","category":"page"},{"location":"moi/#How-the-documentation-is-structured","page":"Introduction","title":"How the documentation is structured","text":"","category":"section"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"Having a high-level overview of how this documentation is structured will help you know where to look for certain things.","category":"page"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"The Background section contains articles on the motivation and theory behind MathOptInterface. Look here if you want to understand why, rather than how.\nThe Manual contains short code-snippets that explain how to use the MOI API. Look here if you want to write a model in MOI.\nThe API Reference contains a complete list of functions and types that comprise the MOI API. Look here is you want to know how to use (or implement) a particular function.\nThe Submodules section contains stand-alone documentation for each of the submodules within MOI. These submodules are not required to interface a solver with MOI, but they make the job much easier.","category":"page"},{"location":"moi/#Citing-MathOptInterface","page":"Introduction","title":"Citing MathOptInterface","text":"","category":"section"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"A paper describing the design and features of MathOptInterface is available on arXiv.","category":"page"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"If you find MathOptInterface useful in your work, we kindly request that you cite the following paper:","category":"page"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"@misc{\n    legat2020mathoptinterface,\n    title = {MathOptInterface: a data structure for mathematical optimization problems},\n    author = {Beno{\\^i}t Legat and Oscar Dowson and Joaquim Dias Garcia and Miles Lubin},\n    year = {2020},\n    eprint = {2002.03447},\n    archivePrefix = {arXiv},\n    primaryClass = {math.OC},\n    url = {https://arxiv.org/abs/2002.03447},\n}","category":"page"},{"location":"background/should_i_use/#Should-I-use-JuMP?","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"","category":"section"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"JuMP is an algebraic modeling language for mathematical optimization written in the Julia language.","category":"page"},{"location":"background/should_i_use/#When-should-I-use-JuMP?","page":"Should I use JuMP?","title":"When should I use JuMP?","text":"","category":"section"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"You should use JuMP if you have a constrained optimization problem for which you can formulate a set of decision variables, a scalar objective function, and a set of constraints.","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Key reasons to use JuMP include:","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"User friendliness\nSyntax that mimics natural mathematical expressions. (See the section on algebraic modeling languages.)\nSpeed\nBenchmarking has shown that JuMP can create problems at similar speeds to special-purpose modeling languages such as AMPL.\nJuMP communicates with most solvers in memory, avoiding the need to write intermediary files.\nSolver independence\nJuMP uses a generic solver-independent interface provided by the MathOptInterface package, making it easy to change between a number of open-source and commercial optimization software packages (\"solvers\"). The Supported solvers section contains a table of the currently supported solvers.\nAccess to advanced algorithmic techniques\nEfficient in-memory LP re-solves which previously required using solver-specific and/or low-level C++ libraries.\nAccess to solver-independent and solver-dependent Callbacks.\nEase of embedding\nJuMP itself is written purely in Julia. Solvers are the only binary dependencies.\nAutomated install of many solver dependencies.\nJuMP provides automatic installation of many open-source solvers. This is different to modeling languages in Python which require you to download and install a solver yourself.\nBeing embedded in a general-purpose programming language makes it easy to solve optimization problems as part of a larger workflow (e.g., inside a simulation, behind a web server, or as a subproblem in a decomposition algorithm).\nAs a trade-off, JuMP's syntax is constrained by the syntax available in Julia.\nJuMP is MPL licensed, meaning that it can be embedded in commercial software that complies with the terms of the license.","category":"page"},{"location":"background/should_i_use/#When-should-I-not-use-JuMP?","page":"Should I use JuMP?","title":"When should I not use JuMP?","text":"","category":"section"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"JuMP supports a broad range of optimization classes. However, there are still some that it doesn't support, or that are better supported by other software packages.","category":"page"},{"location":"background/should_i_use/#Black-box,-derivative-free,-or-unconstrained-optimization","page":"Should I use JuMP?","title":"Black-box, derivative free, or unconstrained optimization","text":"","category":"section"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"JuMP does support nonlinear programs with constraints and objectives containing user-defined functions. However, the functions must be automatically differentiable, or need to provide explicit derivatives. (See User-defined Functions for more information.)","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"If your function is a black-box that is non-differentiable (e.g., the output of a simulation written in C++), JuMP is not the right tool for the job. This also applies if you want to use a derivative free method.","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Even if your problem is differentiable, if it is unconstrained there is limited benefit (and downsides in the form of more overhead) to using JuMP over tools which are only concerned with function minimization.","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Alternatives to consider are:","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Optim.jl\nNLopt.jl","category":"page"},{"location":"background/should_i_use/#Multiobjective-programs","page":"Should I use JuMP?","title":"Multiobjective programs","text":"","category":"section"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"If your problem has more than one objective, JuMP is not the right tool for the job. However, we're working on fixing this!.","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Alternatives to consider are:","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"vOptGeneric.jl","category":"page"},{"location":"background/should_i_use/#Disciplined-convex-programming","page":"Should I use JuMP?","title":"Disciplined convex programming","text":"","category":"section"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"JuMP does not support disciplined convex programming (DCP).","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Alternatives to consider are:","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Convex.jl","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"note: Note\nConvex.jl is also built on MathOptInterface, and shares the same set of underlying solvers. However, you input problems differently, and Convex.jl checks that the problem is DCP.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/modification/#Problem-modification","page":"Problem modification","title":"Problem modification","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"In addition to adding and deleting constraints and variables, MathOptInterface supports modifying, in-place, coefficients in the constraints and the objective function of a model.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"These modifications can be grouped into two categories:","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"modifications which replace the set of function of a constraint with a new set or function\nmodifications which change, in-place, a component of a function","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"warning: Warning\nSolve ModelLike objects do not support problem modification.","category":"page"},{"location":"moi/manual/modification/#Modify-the-set-of-a-constraint","page":"Problem modification","title":"Modify the set of a constraint","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use set and ConstraintSet to modify the set of a constraint by replacing it with a new instance of the same type.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 0.0),\n           MOI.EqualTo(1.0),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}(1)\n\njulia> MOI.set(model, MOI.ConstraintSet(), c, MOI.EqualTo(2.0));\n\njulia> MOI.get(model, MOI.ConstraintSet(), c) == MOI.EqualTo(2.0)\ntrue","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"However, the following will fail as the new set is of a different type to the original set:","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> MOI.set(model, MOI.ConstraintSet(), c, MOI.GreaterThan(2.0))\nERROR: [...]","category":"page"},{"location":"moi/manual/modification/#Special-cases:-set-transforms","page":"Problem modification","title":"Special cases: set transforms","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"If our constraint is an affine inequality, then this corresponds to modifying the right-hand side of a constraint in linear programming.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"In some special cases, solvers may support efficiently changing the set of a constraint (for example, from LessThan to GreaterThan). For these cases, MathOptInterface provides the transform method.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"The transform function returns a new constraint index, and the old constraint index (i.e., c) is no longer valid.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 0.0),\n           MOI.LessThan(1.0),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)\n\njulia> new_c = MOI.transform(model, c, MOI.GreaterThan(2.0));\n\njulia> MOI.is_valid(model, c)\nfalse\n\njulia> MOI.is_valid(model, new_c)\ntrue","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"note: Note\ntransform cannot be called with a set of the same type. Use set instead.","category":"page"},{"location":"moi/manual/modification/#Modify-the-function-of-a-constraint","page":"Problem modification","title":"Modify the function of a constraint","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use set and ConstraintFunction to modify the function of a constraint by replacing it with a new instance of the same type.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 0.0),\n           MOI.EqualTo(1.0),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}(1)\n\njulia> new_f = MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(2.0, x)], 1.0);\n\njulia> MOI.set(model, MOI.ConstraintFunction(), c, new_f);\n\njulia> MOI.get(model, MOI.ConstraintFunction(), c) ‚âà new_f\ntrue","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"However, the following will fail as the new function is of a different type to the original function:","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> MOI.set(model, MOI.ConstraintFunction(), c, MOI.SingleVariable(x))\nERROR: [...]","category":"page"},{"location":"moi/manual/modification/#Modify-constant-term-in-a-scalar-function","page":"Problem modification","title":"Modify constant term in a scalar function","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use modify and ScalarConstantChange to modify the constant term in a ScalarAffineFunction or ScalarQuadraticFunction.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 0.0),\n           MOI.EqualTo(1.0),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}(1)\n\njulia> MOI.modify(model, c, MOI.ScalarConstantChange(1.0));\n\njulia> new_f = MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 1.0);\n\njulia> MOI.get(model, MOI.ConstraintFunction(), c) ‚âà new_f\ntrue","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"tip: Tip\nScalarConstantChange can also be used to modify the objective function by passing an instance of ObjectiveFunction instead of the constraint index c as we saw above.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> MOI.set(\n           model,\n           MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n           new_f,\n       );\n\njulia> MOI.modify(\n           model,\n           MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n           MOI.ScalarConstantChange(-1.0)\n       );\n\njulia> MOI.get(\n           model,\n           MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n       ) ‚âà MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], -1.0)\ntrue","category":"page"},{"location":"moi/manual/modification/#Modify-constant-terms-in-a-vector-function","page":"Problem modification","title":"Modify constant terms in a vector function","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use modify and VectorConstantChange to modify the constant vector in a VectorAffineFunction or VectorQuadraticFunction.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.VectorAffineFunction([\n                   MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(1.0, x)),\n                   MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(2.0, x)),\n               ],\n               [0.0, 0.0],\n           ),\n           MOI.Nonnegatives(2),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64},MathOptInterface.Nonnegatives}(1)\n\njulia> MOI.modify(model, c, MOI.VectorConstantChange([3.0, 4.0]));\n\njulia> new_f = MOI.VectorAffineFunction(\n           [\n        MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(1.0, x)),\n        MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(2.0, x)),\n           ],\n           [3.0, 4.0],\n       );\n\njulia> MOI.get(model, MOI.ConstraintFunction(), c) ‚âà new_f\ntrue","category":"page"},{"location":"moi/manual/modification/#Modify-affine-coefficients-in-a-scalar-function","page":"Problem modification","title":"Modify affine coefficients in a scalar function","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use modify and ScalarCoefficientChange to modify the affine coefficient of a ScalarAffineFunction or ScalarQuadraticFunction.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 0.0),\n           MOI.EqualTo(1.0),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}(1)\n\njulia> MOI.modify(model, c, MOI.ScalarCoefficientChange(x, 2.0));\n\njulia> new_f = MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(2.0, x)], 0.0);\n\njulia> MOI.get(model, MOI.ConstraintFunction(), c) ‚âà new_f\ntrue","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"tip: Tip\nScalarCoefficientChange can also be used to modify the objective function by passing an instance of ObjectiveFunction instead of the constraint index c as we saw above.","category":"page"},{"location":"moi/manual/modification/#Modify-affine-coefficients-in-a-vector-function","page":"Problem modification","title":"Modify affine coefficients in a vector function","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use modify and MultirowChange to modify a vector of affine coefficients in a VectorAffineFunction or a VectorQuadraticFunction.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.VectorAffineFunction([\n                   MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(1.0, x)),\n                   MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(2.0, x)),\n               ],\n               [0.0, 0.0],\n           ),\n           MOI.Nonnegatives(2),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64},MathOptInterface.Nonnegatives}(1)\n\njulia> MOI.modify(model, c, MOI.MultirowChange(x, [(1, 3.0), (2, 4.0)]));\n\njulia> new_f = MOI.VectorAffineFunction(\n           [\n        MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(3.0, x)),\n        MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(4.0, x)),\n           ],\n           [0.0, 0.0],\n       );\n\njulia> MOI.get(model, MOI.ConstraintFunction(), c) ‚âà new_f\ntrue","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP, GLPK\nend\nDocTestFilters = [r\"‚â§|<=\", r\"‚â•|>=\", r\" == | = \", r\" ‚àà | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/models/#jump_models","page":"Models","title":"Models","text":"","category":"section"},{"location":"manual/models/#Create-a-model","page":"Models","title":"Create a model","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Create a model by passing an optimizer to Model:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(GLPK.Optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: GLPK","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"or by calling set_optimizer on an empty Model:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> set_optimizer(model, GLPK.Optimizer)","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"info: Info\nJuMP uses \"optimizer\" as a synonym for \"solver.\" Our convention is to use \"solver\" to refer to the underlying software, and use \"optimizer\" to refer to the Julia object that wraps the solver. For example, GLPK is a solver, and GLPK.Optimizer is an optimizer.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"tip: Tip\nDon't know what the fields Model mode, CachingOptimizer state mean? Read the Backends section.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use optimizer_with_attributes to create an optimizer with some attributes initialized:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 0))\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: GLPK","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Alternatively, you can create a function which takes no arguments and returns an initialized Optimizer object:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> function my_optimizer()\n           model = GLPK.Optimizer()\n           MOI.set(model, MOI.RawParameter(\"msg_lev\"), 0)\n           return model\n       end\nmy_optimizer (generic function with 1 method)\n\njulia> model = Model(my_optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: GLPK","category":"page"},{"location":"manual/models/#Print-the-model","page":"Models","title":"Print the model","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"By default, show(model) will print a summary of the problem.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(); @variable(model, x >= 0); @objective(model, Max, x);\n\njulia> model\nA JuMP Model\nMaximization problem with:\nVariable: 1\nObjective function type: VariableRef\n`VariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: x","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use print to print the formulation of the model (in IJulia, this will render as LaTeX.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> print(model)\nMax x\nSubject to\n x ‚â• 0.0","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"warning: Warning\nThis format is specific to JuMP. To write the model to a file, use write_to_file instead.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use latex_formulation to display the model in LaTeX form.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> latex_formulation(model)\n$$ \\begin{aligned}\n\\max\\quad & x\\\\\n\\text{Subject to} \\quad & x \\geq 0.0\\\\\n\\end{aligned} $$","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"In IJulia (and Documenter), ending a cell in with latex_formulation will render the model in LaTeX!","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"using JuMP                # hide\nmodel = Model()           # hide\n@variable(model, x >= 0)  # hide\n@objective(model, Max, x) # hide\nlatex_formulation(model)","category":"page"},{"location":"manual/models/#Turn-off-output","page":"Models","title":"Turn off output","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use set_silent and unset_silent to disable or enable printing output from the solver.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(GLPK.Optimizer);\n\njulia> set_silent(model)\ntrue\n\njulia> unset_silent(model)\nfalse","category":"page"},{"location":"manual/models/#Set-a-time-limit","page":"Models","title":"Set a time limit","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use set_time_limit_sec, unset_time_limit_sec, and time_limit_sec to manage time limits.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(GLPK.Optimizer);\n\njulia> set_time_limit_sec(model, 60.0)\n60.0\n\njulia> time_limit_sec(model)\n60.0\n\njulia> unset_time_limit_sec(model)\n\njulia> time_limit_sec(model)\n2.147483647e6","category":"page"},{"location":"manual/models/#Write-a-model-to-file","page":"Models","title":"Write a model to file","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"JuMP can write models to a variety of file-formats using write_to_file and Base.write.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> write_to_file(model, \"model.mps\")\n\njulia> write(io, model; format = MOI.FileFormats.FORMAT_MPS)","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"info: Info\nThe supported file formats are defined by the MOI.FileFormats.FileFormat enum.julia> MOI.FileFormats.FileFormat\nEnum MathOptInterface.FileFormats.FileFormat:\nFORMAT_AUTOMATIC = 0\nFORMAT_CBF = 1\nFORMAT_LP = 2\nFORMAT_MOF = 3\nFORMAT_MPS = 4\nFORMAT_SDPA = 5","category":"page"},{"location":"manual/models/#Read-a-model-from-file","page":"Models","title":"Read a model from file","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"JuMP models can be created from file formats using read_from_file and Base.read.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = read_from_file(\"model.mps\")\nA JuMP Model\nMinimization problem with:\nVariables: 0\nObjective function type: GenericAffExpr{Float64,VariableRef}\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> seekstart(io);\n\njulia> model2 = read(io, Model; format = MOI.FileFormats.FORMAT_MPS)\nA JuMP Model\nMinimization problem with:\nVariables: 0\nObjective function type: GenericAffExpr{Float64,VariableRef}\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.","category":"page"},{"location":"manual/models/#Backends","page":"Models","title":"Backends","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"A JuMP Model is a thin layer around a backend of type MOI.ModelLike that stores the optimization problem and acts as the optimization solver.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"From JuMP, the MOI backend can be accessed using the backend function. Let's see what the backend of a JuMP Model is:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(GLPK.Optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: GLPK\n\njulia> b = backend(model)\nMOIU.CachingOptimizer{MOI.AbstractOptimizer,MOIU.UniversalFallback{MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.UniversalFallback{MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}}\n  fallback for MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\nwith optimizer MOIB.LazyBridgeOptimizer{GLPK.Optimizer}\n  with 0 variable bridges\n  with 0 constraint bridges\n  with 0 objective bridges\n  with inner model A GLPK model","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"The backend is a MOIU.CachingOptimizer in the state EMPTY_OPTIMIZER and mode AUTOMATIC.","category":"page"},{"location":"manual/models/#CachingOptimizer","page":"Models","title":"CachingOptimizer","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"A MOIU.CachingOptimizer is an MOI layer that abstracts the difference between solvers that support incremental modification (e.g., they support adding variables one-by-one), and solvers that require the entire problem in a single API call (e.g., they only accept the A, b and c matrices of a linear program).","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"It has two parts:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A cache, where the model can be built and modified incrementally\njulia> b.model_cache\nMOIU.UniversalFallback{MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}}\nfallback for MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\nAn optimizer, which is used to solve the problem\njulia> b.optimizer\nMOIB.LazyBridgeOptimizer{GLPK.Optimizer}\nwith 0 variable bridges\nwith 0 constraint bridges\nwith 0 objective bridges\nwith inner model A GLPK model","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"info: Info\nThe LazyBridgeOptimizer section explains what a LazyBridgeOptimizer is.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"The CachingOptimizer has logic to decide when to copy the problem from the cache to the optimizer, and when it can efficiently update the optimizer in-place.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A CachingOptimizer may be in one of three possible states:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"NO_OPTIMIZER: The CachingOptimizer does not have any optimizer.\nEMPTY_OPTIMIZER: The CachingOptimizer has an empty optimizer, and it is not synchronized with the cached model.\nATTACHED_OPTIMIZER: The CachingOptimizer has an optimizer, and it is synchronized with the cached model.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A CachingOptimizer has two modes of operation:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"AUTOMATIC: The CachingOptimizer changes its state when necessary. For example, optimize! will automatically call attach_optimizer (an optimizer must have been previously set). Attempting to add a constraint or perform a modification not supported by the optimizer results in a drop to EMPTY_OPTIMIZER mode.\nMANUAL: The user must change the state of the CachingOptimizer using MOIU.reset_optimizer(::JuMP.Model), MOIU.drop_optimizer(::JuMP.Model), and MOIU.attach_optimizer(::JuMP.Model). Attempting to perform an operation in the incorrect state results in an error.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"By default Model will create a CachingOptimizer in AUTOMATIC mode. Use the caching_mode keyword to create a model in MANUAL mode:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> Model(GLPK.Optimizer; caching_mode = MOI.Utilities.MANUAL)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: MANUAL\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: GLPK","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"tip: Tip\nOnly use MANUAL mode if you have a very good reason. If you want to reduce the overhead between JuMP and the underlying solver, consider Direct mode instead.","category":"page"},{"location":"manual/models/#LazyBridgeOptimizer","page":"Models","title":"LazyBridgeOptimizer","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"The second layer that JuMP applies automatically is a LazyBridgeOptimizer. A LazyBridgeOptimizer is an MOI layer that attempts to transform constraints added by the user into constraints supported by the solver. This may involve adding new variables and constraints to the optimizer. The transformations are selected from a set of known recipes called bridges.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A common example of a bridge is one that splits an interval constrait like @constraint(model, 1 <= x + y <= 2) into two constraints, @constraint(model, x + y >= 1) and @constraint(model, x + y <= 2).","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use the bridge_constraints=false keyword to remove the bridging layer:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(GLPK.Optimizer; bridge_constraints = false)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: GLPK\n\njulia> backend(model)\nMOIU.CachingOptimizer{MOI.AbstractOptimizer,MOIU.UniversalFallback{MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.UniversalFallback{MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}}\n  fallback for MOIU.GenericModel{Float64,MOIU.ModelFunctionConstraints{Float64}}\nwith optimizer A GLPK model","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"tip: Tip\nOnly disable bridges if you have a very good reason. If you want to reduce the overhead between JuMP and the underlying solver, consider Direct mode instead.","category":"page"},{"location":"manual/models/#Direct-mode","page":"Models","title":"Direct mode","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Using a CachingOptimizer results in an additional copy of the model being stored by JuMP in the .model_cache field. To avoid this overhead, create a JuMP model using direct_model:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = direct_model(GLPK.Optimizer())\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: DIRECT\nSolver name: GLPK","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"warning: Warning\nSolvers that do not support incremental modification do not support direct_model. An error will be thrown, telling you to use a CachingOptimizer instead.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"The benefit of using direct_model is that there are no extra layers (e.g., Cachingoptimizer or LazyBridgeOptimizer) between model and the provided optimizer:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> typeof(backend(model))\nGLPK.Optimizer","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A downside of direct mode is that there is no bridging layer. Therefore, only constraints which are natively supported by the solver are supported. For example, GLPK.jl does not implement constraints of the form l <= a' x <= u.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> @variable(model, x[1:2]);\n\njulia> @constraint(model, 1 <= x[1] + x[2] <= 2)\nERROR: Constraints of type MathOptInterface.ScalarAffineFunction{Float64}-in-MathOptInterface.Interval{Float64} are not supported by the solver.\n[...]","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/background/duality/#Duality","page":"Duality","title":"Duality","text":"","category":"section"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"Conic duality is the starting point for MOI's duality conventions. When all functions are affine (or coordinate projections), and all constraint sets are closed convex cones, the model may be called a conic optimization problem.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"For a minimization problem in geometric conic form, the primal is:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n min_x in mathbbR^n  a_0^T x + b_0\n\n textst  A_i x + b_i  in mathcalC_i  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"and the dual is a maximization problem in standard conic form:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n max_y_1 ldots y_m  -sum_i=1^m b_i^T y_i + b_0\n\n textst  a_0 - sum_i=1^m A_i^T y_i  = 0\n\n  y_i  in mathcalC_i^*  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"where each mathcalC_i is a closed convex cone and mathcalC_i^* is its dual cone.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"For a maximization problem in geometric conic form, the primal is:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n max_x in mathbbR^n  a_0^T x + b_0\n\n textst  A_i x + b_i  in mathcalC_i  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"and the dual is a minimization problem in standard conic form:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n min_y_1 ldots y_m  sum_i=1^m b_i^T y_i + b_0\n\n textst  a_0 + sum_i=1^m A_i^T y_i  = 0\n\n  y_i  in mathcalC_i^*  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"A linear inequality constraint a^T x + b ge c should be interpreted as a^T x + b - c in mathbbR_+, and similarly a^T x + b le c should be interpreted as a^T x + b - c in mathbbR_-. Variable-wise constraints should be interpreted as affine constraints with the appropriate identity mapping in place of A_i.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"For the special case of minimization LPs, the MOI primal form can be stated as:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n min_x in mathbbR^n  a_0^T x + b_0\n\n textst\nA_1 x  ge b_1\n A_2 x  le b_2\n A_3 x  = b_3\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"By applying the stated transformations to conic form, taking the dual, and transforming back into linear inequality form, one obtains the following dual:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n max_y_1y_2y_3  b_1^Ty_1 + b_2^Ty_2 + b_3^Ty_3 + b_0\n\n textst\nA_1^Ty_1 + A_2^Ty_2 + A_3^Ty_3  = a_0\n y_1 ge 0\n y_2 le 0\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"For maximization LPs, the MOI primal form can be stated as:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n max_x in mathbbR^n  a_0^T x + b_0\n\n textst\nA_1 x  ge b_1\n A_2 x  le b_2\n A_3 x  = b_3\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"and similarly, the dual is:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n min_y_1y_2y_3  -b_1^Ty_1 - b_2^Ty_2 - b_3^Ty_3 + b_0\n\n textst\nA_1^Ty_1 + A_2^Ty_2 + A_3^Ty_3  = -a_0\n y_1 ge 0\n y_2 le 0\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"warning: Warning\nFor the LP case is that the signs of the feasible duals depend only on the sense of the inequality and not on the objective sense.","category":"page"},{"location":"moi/background/duality/#Duality-and-scalar-product","page":"Duality","title":"Duality and scalar product","text":"","category":"section"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"The scalar product is different from the canonical one for the sets PositiveSemidefiniteConeTriangle, LogDetConeTriangle, RootDetConeTriangle.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"If the set C_i of the section Duality is one of these three cones, then the rows of the matrix A_i corresponding to off-diagonal entries are twice the value of the coefficients field in the VectorAffineFunction for the corresponding rows. See PositiveSemidefiniteConeTriangle for details.","category":"page"},{"location":"moi/background/duality/#Dual-for-problems-with-quadratic-functions","page":"Duality","title":"Dual for problems with quadratic functions","text":"","category":"section"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"Given a problem with quadratic functions:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign*\n min_x in mathbbR^n  frac12x^TQ_0x + a_0^T x + b_0\n\n textst  frac12x^TQ_ix + a_i^T x + b_i  in mathcalC_i  i = 1 ldots m\nendalign*","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"Consider the Lagrangian function","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"L(x y) = frac12x^TQ_0x + a_0^T x + b_0 - sum_i = 1^m y_i (frac12x^TQ_ix + a_i^T x + b_i)","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"A pair of primal-dual variables (x^star y^star) is optimal if","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"x^star is a minimizer of\nmin_x in mathbbR^n L(x y^star)\nThat is,\n0 = nabla_x L(x y^star) = Q_0x + a_0 - sum_i = 1^m y_i^star (Q_ix + a_i)\nand y^star is a maximizer of\nmax_y_i in mathcalC_i^* L(x^star y)\nThat is, for all i = 1 ldots m, frac12x^TQ_ix + a_i^T x + b_i is either zero or in the normal cone of mathcalC_i^* at y^star. For instance, if mathcalC_i is  x in mathbbR  x le 0 , it means that if frac12x^TQ_ix + a_i^T x + b_i is nonzero then lambda_i = 0, this is the classical complementary slackness condition.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"If mathcalC_i is a vector set, the discussion remains valid with y_i(frac12x^TQ_ix + a_i^T x + b_i) replaced with the scalar product between y_i and the vector of scalar-valued quadratic functions.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"note: Note\nFor quadratic programs with only affine constraints, the optimality condition nabla_x L(x y^star) = 0 can be simplified as follows0 = nabla_x L(x y^star) = Q_0x + a_0 - sum_i = 1^m y_i^star a_iwhich givesQ_0x = sum_i = 1^m y_i^star a_i - a_0The Lagrangian functionL(x y) = frac12x^TQ_0x + a_0^T x + b_0 - sum_i = 1^m y_i (a_i^T x + b_i)can be rewritten asL(x y) = frac12x^TQ_0x - (sum_i = 1^m y_i a_i^T - a_0^T) x + b_0 - sum_i = 1^m y_i (a_i^T x + b_i)which, using the optimality condition nabla_x L(x y^star) = 0, can be simplified asL(x y) = -frac12x^TQ_0x + b_0 - sum_i = 1^m y_i (a_i^T x + b_i)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/steelT3.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/steelT3/#The-SteelT3-problem","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"The steelT3 model from AMPL: A Modeling Language for Mathematical Programming, 2nd ed by Robert Fourer, David Gay, and Brian W. Kernighan.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"Originally contributed by Louis Luangkesorn, April 3, 2015.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_steelT3(; verbose = true)\n    T = 4\n    prod = [\"bands\", \"coils\"]\n    area = Dict(\n        \"bands\" => (\"east\", \"north\"),\n        \"coils\" => (\"east\", \"west\", \"export\")\n    )\n    avail = [40, 40, 32, 40]\n    rate = Dict(\"bands\" => 200, \"coils\" => 140)\n    inv0 = Dict(\"bands\" => 10, \"coils\" => 0)\n    prodcost = Dict(\"bands\" => 10, \"coils\" => 11)\n    invcost = Dict(\"bands\" => 2.5, \"coils\" => 3)\n    revenue = Dict(\n        \"bands\" => Dict(\n            \"east\" => [25.0, 26.0, 27.0, 27.0],\n            \"north\" => [26.5, 27.5, 28.0, 28.5],\n        ),\n        \"coils\" => Dict(\n            \"east\" =>[30, 35, 37, 39],\n            \"west\" => [29, 32, 33, 35],\n            \"export\" => [25, 25, 25, 28],\n        )\n    )\n    market = Dict(\n        \"bands\" => Dict(\n            \"east\" => [2000, 2000, 1500, 2000],\n            \"north\" => [4000, 4000, 2500, 4500],\n        ),\n        \"coils\" => Dict(\n            \"east\" => [1000, 800, 1000, 1100],\n            \"west\" => [2000, 1200, 2000, 2300],\n            \"export\" => [1000, 500, 500, 800],\n        )\n    )\n    # Model\n    model = Model(GLPK.Optimizer)\n    # Decision Variables\n    @variables(model, begin\n        make[p in prod, t in 1:T] >= 0\n        inventory[p in prod, t in 0:T] >= 0\n        0 <= sell[p in prod, a in area[p], t in 1:T] <= market[p][a][t]\n    end)\n    @constraints(model, begin\n        [p = prod, a = area[p], t = 1:T], sell[p, a, t] <= market[p][a][t]\n        # Total of hours used by all products may not exceed hours available,\n        # in each week\n        [t in 1:T], sum(1 / rate[p] * make[p, t] for p in prod) <= avail[t]\n        # Initial inventory must equal given value\n        [p in prod], inventory[p, 0] == inv0[p]\n        # Tons produced and taken from inventory must equal tons sold and put\n        # into inventory.\n        [p in prod, t in 1:T], make[p, t] + inventory[p, t - 1] == sum(sell[p, a, t] for a in area[p]) + inventory[p, t]\n    end)\n    # Maximize total profit: total revenue less costs for all products in all\n    # weeks.\n    @objective(\n        model,\n        Max,\n        sum(\n            revenue[p][a][t] * sell[p, a, t] -\n            prodcost[p] * make[p, t] -\n            invcost[p] * inventory[p, t]\n            for p in prod, a in area[p], t in 1:T\n        )\n    )\n    optimize!(model)\n    Test.@test termination_status(model) == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) == 172850.0\n    if verbose\n        println(\"RESULTS:\")\n        for p in prod\n            println(\"make $(p)\")\n            for t in 1:T\n                print(value(make[p, t]), \"\\t\")\n            end\n            println()\n            println(\"Inventory $(p)\")\n            for t in 1:T\n                print(value(inventory[p, t]), \"\\t\")\n            end\n            println()\n            for a in area[p]\n                println(\"sell $(p) $(a)\")\n            for t in 1:T\n                print(value(sell[p, a, t]), \"\\t\")\n            end\n            println()\n            end\n        end\n    end\n    return\nend\n\nexample_steelT3()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/nlp/#NonlinearAPI","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"More information can be found in the Nonlinear Modeling section of the manual.","category":"page"},{"location":"reference/nlp/#ref_nl_constraints","page":"Nonlinear Modeling","title":"Constraints","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLconstraint\n@NLconstraints\nNonlinearConstraintIndex\nnum_nl_constraints\nadd_NL_constraint","category":"page"},{"location":"reference/nlp/#JuMP.@NLconstraint","page":"Nonlinear Modeling","title":"JuMP.@NLconstraint","text":"@NLconstraint(m::Model, expr)\n\nAdd a constraint described by the nonlinear expression expr. See also @constraint. For example:\n\n@NLconstraint(model, sin(x) <= 1)\n@NLconstraint(model, [i = 1:3], sin(i * x) <= 1 / i)\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.@NLconstraints","page":"Nonlinear Modeling","title":"JuMP.@NLconstraints","text":"@NLconstraints(model, args...)\n\nAdds multiple nonlinear constraints to model at once, in the same fashion as the @NLconstraint macro.\n\nThe model must be the first argument, and multiple variables can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@NLconstraints(model, begin\n    t >= sqrt(x^2 + y^2)\n    [i = 1:2], z[i] <= log(a[i])\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.NonlinearConstraintIndex","page":"Nonlinear Modeling","title":"JuMP.NonlinearConstraintIndex","text":"NonlinearConstraintIndex(index::Int64)\n\nA struct to refer to the 1-indexed nonlinear constraint index.\n\n\n\n\n\n","category":"type"},{"location":"reference/nlp/#JuMP.num_nl_constraints","page":"Nonlinear Modeling","title":"JuMP.num_nl_constraints","text":"num_nl_constraints(model::Model)\n\nReturns the number of nonlinear constraints associated with the model.\n\n\n\n\n\n","category":"function"},{"location":"reference/nlp/#JuMP.add_NL_constraint","page":"Nonlinear Modeling","title":"JuMP.add_NL_constraint","text":"add_NL_constraint(model::Model, expr::Expr)\n\nAdd a nonlinear constraint described by the Julia expression ex to model.\n\nThis function is most useful if the expression ex is generated programmatically, and you cannot use @NLconstraint.\n\nNotes\n\nYou must interpolate the variables directly into the expression expr.\n\nExamples\n\njulia> add_NL_constraint(model, :($(x) + $(x)^2 <= 1))\n(x + x ^ 2.0) - 1.0 ‚â§ 0\n\n\n\n\n\n","category":"function"},{"location":"reference/nlp/#ref_nl_expressions","page":"Nonlinear Modeling","title":"Expressions","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLexpression\n@NLexpressions\nNonlinearExpression","category":"page"},{"location":"reference/nlp/#JuMP.@NLexpression","page":"Nonlinear Modeling","title":"JuMP.@NLexpression","text":"@NLexpression(args...)\n\nEfficiently build a nonlinear expression which can then be inserted in other nonlinear constraints and the objective. See also [@expression]. For example:\n\n@NLexpression(model, my_expr, sin(x)^2 + cos(x^2))\n@NLconstraint(model, my_expr + y >= 5)\n@NLobjective(model, Min, my_expr)\n\nIndexing over sets and anonymous expressions are also supported:\n\n@NLexpression(m, my_expr_1[i=1:3], sin(i * x))\nmy_expr_2 = @NLexpression(m, log(1 + sum(exp(x[i])) for i in 1:2))\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.@NLexpressions","page":"Nonlinear Modeling","title":"JuMP.@NLexpressions","text":"@NLexpressions(model, args...)\n\nAdds multiple nonlinear expressions to model at once, in the same fashion as the @NLexpression macro.\n\nThe model must be the first argument, and multiple variables can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@NLexpressions(model, begin\n    my_expr, sqrt(x^2 + y^2)\n    my_expr_1[i = 1:2], log(a[i]) - z[i]\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.NonlinearExpression","page":"Nonlinear Modeling","title":"JuMP.NonlinearExpression","text":"NonlinearExpression\n\nA struct to represent a nonlinear expression.\n\nCreate an expression using @NLexpression.\n\n\n\n\n\n","category":"type"},{"location":"reference/nlp/#ref_nl_objectives","page":"Nonlinear Modeling","title":"Objectives","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLobjective\nset_NL_objective","category":"page"},{"location":"reference/nlp/#JuMP.@NLobjective","page":"Nonlinear Modeling","title":"JuMP.@NLobjective","text":"@NLobjective(model, sense, expression)\n\nAdd a nonlinear objective to model with optimization sense sense. sense must be Max or Min.\n\nExample\n\n@NLobjective(model, Max, 2x + 1 + sin(x))\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.set_NL_objective","page":"Nonlinear Modeling","title":"JuMP.set_NL_objective","text":"set_NL_objective(model::Model, sense::MOI.OptimizationSense, expr::Expr)\n\nSet the nonlinear objective of model to the expression expr, with the optimization sense sense.\n\nThis function is most useful if the expression expr is generated programmatically, and you cannot use @NLobjective.\n\nNotes\n\nYou must interpolate the variables directly into the expression expr.\nYou must use MOI.MIN_SENSE or MOI.MAX_SENSE instead of Min and Max.\n\nExamples\n\njulia> set_NL_objective(model, MOI.MIN_SENSE, :($(x) + $(x)^2))\n\n\n\n\n\n","category":"function"},{"location":"reference/nlp/#ref_nl_parameters","page":"Nonlinear Modeling","title":"Parameters","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLparameter\nNonlinearParameter\nvalue(::JuMP.NonlinearParameter)\nset_value(::JuMP.NonlinearParameter, ::Number)","category":"page"},{"location":"reference/nlp/#JuMP.@NLparameter","page":"Nonlinear Modeling","title":"JuMP.@NLparameter","text":"@NLparameter(model, param == value)\n\nCreate and return a nonlinear parameter param attached to the model model with initial value set to value. Nonlinear parameters may be used only in nonlinear expressions.\n\nExample\n\nmodel = Model()\n@NLparameter(model, x == 10)\nvalue(x)\n\n# output\n10.0\n\n@NLparameter(model, param_collection[...] == value_expr)\n\nCreate and return a collection of nonlinear parameters param_collection attached to the model model with initial value set to value_expr (may depend on index sets). Uses the same syntax for specifying index sets as @variable.\n\nExample\n\nmodel = Model()\n@NLparameter(model, y[i = 1:10] == 2 * i)\nvalue(y[9])\n\n# output\n18.0\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.NonlinearParameter","page":"Nonlinear Modeling","title":"JuMP.NonlinearParameter","text":"NonlinearParameter\n\nA struct to represent a nonlinear parameter.\n\nCreate a parameter using @NLparameter.\n\n\n\n\n\n","category":"type"},{"location":"reference/nlp/#JuMP.value-Tuple{NonlinearParameter}","page":"Nonlinear Modeling","title":"JuMP.value","text":"value(p::NonlinearParameter)\n\nReturn the current value stored in the nonlinear parameter p.\n\nExample\n\nmodel = Model()\n@NLparameter(model, p == 10)\nvalue(p)\n\n# output\n10.0\n\n\n\n\n\n","category":"method"},{"location":"reference/nlp/#JuMP.set_value-Tuple{NonlinearParameter,Number}","page":"Nonlinear Modeling","title":"JuMP.set_value","text":"set_value(p::NonlinearParameter, v::Number)\n\nStore the value v in the nonlinear parameter p.\n\nExample\n\nmodel = Model()\n@NLparameter(model, p == 0)\nset_value(p, 5)\nvalue(p)\n\n# output\n5.0\n\n\n\n\n\n","category":"method"},{"location":"reference/nlp/#User-defined-functions","page":"Nonlinear Modeling","title":"User-defined functions","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"register","category":"page"},{"location":"reference/nlp/#JuMP.register","page":"Nonlinear Modeling","title":"JuMP.register","text":"register(\n    model::Model,\n    s::Symbol,\n    dimension::Integer,\n    f::Function;\n    autodiff:Bool = false,\n)\n\nRegister the user-defined function f that takes dimension arguments in model as the symbol s.\n\nThe function f must support all subtypes of Real as arguments. Do not assume that the inputs are Float64.\n\nNotes\n\nFor this method, you must explicitly set autodiff = true, because no user-provided gradient function ‚àáf is given.\nSecond-derivative information is only computed if dimension == 1.\ns does not have to be the same symbol as f, but it is generally more readable if it is.\n\nExamples\n\nmodel = Model()\n@variable(model, x)\nf(x::T) where {T<:Real} = x^2\nregister(model, :foo, 1, f; autodiff = true)\n@NLobjective(model, Min, foo(x))\n\nmodel = Model()\n@variable(model, x[1:2])\ng(x::T, y::T) where {T<:Real} = x * y\nregister(model, :g, 2, g; autodiff = true)\n@NLobjective(model, Min, g(x[1], x[2]))\n\n\n\n\n\nregister(\n    model::Model,\n    s::Symbol,\n    dimension::Integer,\n    f::Function,\n    ‚àáf::Function;\n    autodiff:Bool = false,\n)\n\nRegister the user-defined function f that takes dimension arguments in model as the symbol s. In addition, provide a gradient function ‚àáf.\n\nThe functions fand ‚àáf must support all subtypes of Real as arguments. Do not assume that the inputs are Float64.\n\nNotes\n\nIf the function f is univariate (i.e., dimension == 1), ‚àáf must return a number which represents the first-order derivative of the function f.\nIf the function f is multi-variate, ‚àáf must have a signature matching ‚àáf(g::Vector{T}, args::T...) where {T<:Real}, where the first argument is a vector g that is modified in-place with the gradient.\nIf autodiff = true and dimension == 1, use automatic differentiation to compute the second-order derivative information. If autodiff = false, only first-order derivative information will be used.\ns does not have to be the same symbol as f, but it is generally more readable if it is.\n\nExamples\n\nmodel = Model()\n@variable(model, x)\nf(x::T) where {T<:Real} = x^2\n‚àáf(x::T) where {T<:Real} = 2 * x\nregister(model, :foo, 1, f, ‚àáf; autodiff = true)\n@NLobjective(model, Min, foo(x))\n\nmodel = Model()\n@variable(model, x[1:2])\ng(x::T, y::T) where {T<:Real} = x * y\nfunction ‚àág(g::Vector{T}, x::T, y::T) where {T<:Real}\n    g[1] = y\n    g[2] = x\n    return\nend\nregister(model, :g, 2, g, ‚àág; autodiff = true)\n@NLobjective(model, Min, g(x[1], x[2]))\n\n\n\n\n\nregister(\n    model::Model,\n    s::Symbol,\n    dimension::Integer,\n    f::Function,\n    ‚àáf::Function,\n    ‚àá¬≤f::Function,\n)\n\nRegister the user-defined function f that takes dimension arguments in model as the symbol s. In addition, provide a gradient function ‚àáf and a hessian function ‚àá¬≤f.\n\n‚àáf and ‚àá¬≤f must return numbers corresponding to the first- and second-order derivatives of the function f respectively.\n\nNotes\n\nBecause automatic differentiation is not used, you can assume the inputs are all Float64.\nThis method will throw an error if dimension > 1.\ns does not have to be the same symbol as f, but it is generally more readable if it is.\n\nExamples\n\nmodel = Model()\n@variable(model, x)\nf(x::Float64) = x^2\n‚àáf(x::Float64) = 2 * x\n‚àá¬≤f(x::Float64) = 2.0\nregister(model, :foo, 1, f, ‚àáf, ‚àá¬≤f)\n@NLobjective(model, Min, foo(x))\n\n\n\n\n\n","category":"function"},{"location":"reference/nlp/#Derivatives","page":"Nonlinear Modeling","title":"Derivatives","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"NLPEvaluator","category":"page"},{"location":"reference/nlp/#JuMP.NLPEvaluator","page":"Nonlinear Modeling","title":"JuMP.NLPEvaluator","text":"NLPEvaluator(m::Model)\n\nReturn an MOI.AbstractNLPEvaluator constructed from the model model.\n\nBefore using, you must initialize the evaluator using MOI.initialize.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/Nonlinear programs/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Nonlinear programs/mle.jl\"","category":"page"},{"location":"tutorials/Nonlinear programs/mle/#Maximum-likelihood-estimation","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"Use nonlinear optimization to compute the maximum likelihood estimate (MLE) of the parameters of a normal distribution, a.k.a., the sample mean and variance.","category":"page"},{"location":"tutorials/Nonlinear programs/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"using JuMP\nimport Ipopt\nimport Random\nimport Statistics\nimport Test\n\nfunction example_mle(; verbose = true)\n    n = 1_000\n    Random.seed!(1234)\n    data = randn(n)\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, Œº, start = 0.0)\n    @variable(model, œÉ >= 0.0, start = 1.0)\n    @NLobjective(\n        model,\n        Max,\n        n / 2 * log(1 / (2 * œÄ * œÉ^2)) - sum((data[i] - Œº)^2 for i = 1:n) / (2 * œÉ^2)\n    )\n    optimize!(model)\n    if verbose\n        println(\"Œº             = \", value(Œº))\n        println(\"mean(data)    = \", Statistics.mean(data))\n        println(\"œÉ^2           = \", value(œÉ)^2)\n        println(\"var(data)     = \", Statistics.var(data))\n        println(\"MLE objective = \", objective_value(model))\n    end\n    Test.@test value(Œº) ‚âà Statistics.mean(data) atol = 1e-3\n    Test.@test value(œÉ)^2 ‚âà Statistics.var(data) atol = 1e-2\n    # You can even do constrained MLE!\n    @NLconstraint(model, Œº == œÉ^2)\n    optimize!(model)\n    Test.@test value(Œº) ‚âà value(œÉ)^2\n    if verbose\n        println()\n        println(\"With constraint Œº == œÉ^2:\")\n        println(\"Œº                         = \", value(Œº))\n        println(\"œÉ^2                       = \", value(œÉ)^2)\n        println(\"Constrained MLE objective = \", objective_value(model))\n    end\n    return\nend\n\nexample_mle()","category":"page"},{"location":"tutorials/Nonlinear programs/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"View this file on Github.","category":"page"},{"location":"tutorials/Nonlinear programs/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"","category":"page"},{"location":"tutorials/Nonlinear programs/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Quadratic programs/portfolio.jl\"","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/#Portfolio-Optimization","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"","category":"section"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Optimization models play an increasingly important role in financial decisions. Many computational finance problems can be solved efficiently using modern optimization techniques.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"This tutorial solves the famous Markowitz Portfolio Optimization problem with data from lecture notes from a course taught at Georgia Tech by Shabir Ahmed.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"This tutorial uses the following packages","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"using JuMP\nimport Ipopt\nimport Statistics","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Suppose we are considering investing 1000 dollars in three non-dividend paying stocks, IBM (IBM), Walmart (WMT), and Southern Electric (SEHI), for a one-month period.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"This means we will use the money to buy shares of the three stocks at the current market prices, hold these for one month, and sell the shares off at the prevailing market prices at the end of the month.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"As a rational investor, we hope to make some profit out of this endeavor, i.e., the return on our investment should be positive.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Suppose we bought a stock at p dollars per share in the beginning of the month, and sold it off at s dollars per share at the end of the month. Then the one-month return on a share of the stock is $ \\frac{s-p}{p} $.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Since the stock prices are quite uncertain, so is the end-of-month return on our investment. Our goal is to invest in such a way that the expected end-of-month return is at least $50 or 5%. Furthermore, we want to make sure that the ‚Äúrisk‚Äù of not achieving our desired return is minimum.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Note that we are solving the problem under the following assumptions:","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"We can trade any continuum of shares.\nNo short-selling is allowed.\nThere are no transaction costs.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"We model this problem by taking decision variables x_i i=123 denoting the dollars invested in each of the 3 stocks.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Let us denote by tilder_i the random variable corresponding to the monthly return (increase in the stock price) per dollar for stock i.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Then, the return (or profit) on x_i dollars invested in stock i is tilder_i x_i and the total (random) return on our investment is sum_i=1^3 tilder_i x_i The expected return on our investment is then mathbbEleftsum_i=1^3 tilder_i x_iright=sum_i=1^3 overliner_i x_i where overliner_i is the expected value of the tilder_i","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Now we need to quantify the notion of ‚Äúrisk‚Äù in our investment.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Markowitz, in his Nobel prize winning work, showed that a rational investor‚Äôs notion of minimizing risk can be closely approximated by minimizing the variance of the return of the investment portfolio. This variance is given by:","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"operatornameVarleftsum_i=1^3 tilder_i x_iright = sum_i=1^3 sum_j=1^3 x_i x_j sigma_i j","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"where sigma_i j is the covariance of the return of stock i with stock j.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Note that the right hand side of the equation is the most reduced form of the expression and we have not shown the intermediate steps involved in getting to this form. We can also write this equation as:","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"operatornameVarleftsum_i=1^3 tilder_i x_iright =x^T Q x","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Where Q is the covariance matrix for the random vector tilder.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Finally, we can write the model as:","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"beginaligned\nmin x^T Q x \ntext  st  sum_i=1^3 x_i leq 100000 \noverliner^T x geq 5000 \nx geq 0\nendaligned","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"After that long discussion, lets now use JuMP to solve the portfolio optimization problem for the data given below.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Month IBM WMT SEHI\nNovember-00 93.043 51.826 1.063\nDecember-00 84.585 52.823 0.938\nJanuary-01 111.453 56.477 1.000\nFebruary-01 99.525 49.805 0.938\nMarch-01 95.819 50.287 1.438\nApril-01 114.708 51.521 1.700\nMay-01 111.515 51.531 2.540\nJune-01 113.211 48.664 2.390\nJuly-01 104.942 55.744 3.120\nAugust-01 99.827 47.916 2.980\nSeptember-01 91.607 49.438 1.900\nOctober-01 107.937 51.336 1.750\nNovember-01 115.590 55.081 1.800","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"stock_data = [\n    93.043 51.826 1.063;\n    84.585 52.823 0.938;\n    111.453 56.477 1.000;\n    99.525 49.805 0.938;\n    95.819 50.287 1.438;\n    114.708 51.521 1.700;\n    111.515 51.531 2.540;\n    113.211 48.664 2.390;\n    104.942 55.744 3.120;\n    99.827 47.916 2.980;\n    91.607 49.438 1.900;\n    107.937 51.336 1.750;\n    115.590 55.081 1.800;\n]","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Calculating stock returns","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"stock_returns = Array{Float64}(undef, 12, 3)\nfor i in 1:12\n    stock_returns[i, :] = (stock_data[i + 1, :] .- stock_data[i, :]) ./ stock_data[i, :]\nend\nstock_returns","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Calculating the expected value of monthly return:","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"r = Statistics.mean(stock_returns, dims = 1)","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Calculating the covariance matrix Q","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Q = Statistics.cov(stock_returns)","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"JuMP Model","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"portfolio = Model(Ipopt.Optimizer)\nset_silent(portfolio)\n@variable(portfolio, x[1:3] >= 0)\n@objective(portfolio, Min, x' * Q * x)\n@constraint(portfolio, sum(x) <= 1000)\n@constraint(portfolio, sum(r[i] * x[i] for i = 1:3) >= 50)\noptimize!(portfolio)\n\nobjective_value(portfolio)","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"value.(x)","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"View this file on Github.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/standard_form/#Standard-form","page":"Standard form","title":"Standard form","text":"","category":"section"},{"location":"moi/reference/standard_form/#Functions","page":"Standard form","title":"Functions","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"AbstractFunction\nAbstractVectorFunction\nSingleVariable\nVectorOfVariables\nScalarAffineTerm\nScalarAffineFunction\nVectorAffineTerm\nVectorAffineFunction\nScalarQuadraticTerm\nScalarQuadraticFunction\nVectorQuadraticTerm\nVectorQuadraticFunction","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractFunction","page":"Standard form","title":"MathOptInterface.AbstractFunction","text":"AbstractFunction\n\nAbstract supertype for function objects.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractVectorFunction","page":"Standard form","title":"MathOptInterface.AbstractVectorFunction","text":"AbstractVectorFunction\n\nAbstract supertype for vector-valued function objects.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.SingleVariable","page":"Standard form","title":"MathOptInterface.SingleVariable","text":"SingleVariable(variable)\n\nThe function that extracts the scalar variable referenced by variable, a VariableIndex. This function is naturally be used for single variable bounds or integrality constraints.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VectorOfVariables","page":"Standard form","title":"MathOptInterface.VectorOfVariables","text":"VectorOfVariables(variables)\n\nThe function that extracts the vector of variables referenced by variables, a Vector{VariableIndex}. This function is naturally be used for constraints that apply to groups of variables, such as an \"all different\" constraint, an indicator constraint, or a complementarity constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ScalarAffineTerm","page":"Standard form","title":"MathOptInterface.ScalarAffineTerm","text":"struct ScalarAffineTerm{T}\n    coefficient::T\n    variable_index::VariableIndex\nend\n\nRepresents c x_i where c is coefficient and x_i is the variable identified by variable_index.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ScalarAffineFunction","page":"Standard form","title":"MathOptInterface.ScalarAffineFunction","text":"ScalarAffineFunction{T}(terms, constant)\n\nThe scalar-valued affine function a^T x + b, where:\n\na is a sparse vector specified by a list of ScalarAffineTerm structs.\nb is a scalar specified by constant::T\n\nDuplicate variable indices in terms are accepted, and the corresponding coefficients are summed together.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VectorAffineTerm","page":"Standard form","title":"MathOptInterface.VectorAffineTerm","text":"struct VectorAffineTerm{T}\n    output_index::Int64\n    scalar_term::ScalarAffineTerm{T}\nend\n\nA ScalarAffineTerm plus its index of the output component of a VectorAffineFunction or VectorQuadraticFunction. output_index can also be interpreted as a row index into a sparse matrix, where the scalar_term contains the column index and coefficient.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VectorAffineFunction","page":"Standard form","title":"MathOptInterface.VectorAffineFunction","text":"VectorAffineFunction{T}(terms, constants)\n\nThe vector-valued affine function A x + b, where:\n\nA is a sparse matrix specified by a list of VectorAffineTerm objects.\nb is a vector specified by constants\n\nDuplicate indices in the A are accepted, and the corresponding coefficients are summed together.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ScalarQuadraticTerm","page":"Standard form","title":"MathOptInterface.ScalarQuadraticTerm","text":"struct ScalarQuadraticTerm{T}\n    coefficient::T\n    variable_index_1::VariableIndex\n    variable_index_2::VariableIndex\nend\n\nRepresents c x_i x_j where c is coefficient, x_i is the variable identified by variable_index_1 and x_j is the variable identified by variable_index_2.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ScalarQuadraticFunction","page":"Standard form","title":"MathOptInterface.ScalarQuadraticFunction","text":"ScalarQuadraticFunction{T}(affine_terms, quadratic_terms, constant)\n\nThe scalar-valued quadratic function frac12x^TQx + a^T x + b, where:\n\na is a sparse vector specified by a list of ScalarAffineTerm structs.\nb is a scalar specified by constant.\nQ is a symmetric matrix specified by a list of ScalarQuadraticTerm structs.\n\nDuplicate indices in a or Q are accepted, and the corresponding coefficients are summed together. \"Mirrored\" indices (q,r) and (r,q) (where r and q are VariableIndexes) are considered duplicates; only one need be specified.\n\nFor example, for two scalar variables y z, the quadratic expression yz + y^2 is represented by the terms ScalarQuadraticTerm.([1.0, 2.0], [y, y], [z, y]).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VectorQuadraticTerm","page":"Standard form","title":"MathOptInterface.VectorQuadraticTerm","text":"struct VectorQuadraticTerm{T}\n    output_index::Int64\n    scalar_term::ScalarQuadraticTerm{T}\nend\n\nA ScalarQuadraticTerm plus its index of the output component of a VectorQuadraticFunction. Each output component corresponds to a distinct sparse matrix Q_i.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VectorQuadraticFunction","page":"Standard form","title":"MathOptInterface.VectorQuadraticFunction","text":"VectorQuadraticFunction{T}(affine_terms, quadratic_terms, constants)\n\nThe vector-valued quadratic function with ith component (\"output index\") defined as frac12x^TQ_ix + a_i^T x + b_i, where:\n\na_i is a sparse vector specified by the VectorAffineTerms with output_index == i.\nb_i is a scalar specified by constants[i]\nQ_i is a symmetric matrix specified by the VectorQuadraticTerm with output_index == i.\n\nDuplicate indices in a_i or Q_i are accepted, and the corresponding coefficients are summed together. \"Mirrored\" indices (q,r) and (r,q) (where r and q are VariableIndexes) are considered duplicates; only one need be specified.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#Utilities","page":"Standard form","title":"Utilities","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"output_dimension\nconstant(f::Union{ScalarAffineFunction, ScalarQuadraticFunction})\nconstant(f::Union{VectorAffineFunction, VectorQuadraticFunction})\nconstant(f::SingleVariable, ::DataType)\nconstant(f::VectorOfVariables, T::DataType)","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.output_dimension","page":"Standard form","title":"MathOptInterface.output_dimension","text":"output_dimension(f::AbstractFunction)\n\nReturn 1 if f has a scalar output and the number of output components if f has a vector output.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.constant-Tuple{Union{ScalarAffineFunction, ScalarQuadraticFunction}}","page":"Standard form","title":"MathOptInterface.constant","text":"constant(f::Union{ScalarAffineFunction, ScalarQuadraticFunction})\n\nReturns the constant term of the scalar function\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/standard_form/#MathOptInterface.constant-Tuple{Union{VectorAffineFunction, VectorQuadraticFunction}}","page":"Standard form","title":"MathOptInterface.constant","text":"constant(f::Union{VectorAffineFunction, VectorQuadraticFunction})\n\nReturns the vector of constant terms of the vector function\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/standard_form/#MathOptInterface.constant-Tuple{MathOptInterface.SingleVariable,DataType}","page":"Standard form","title":"MathOptInterface.constant","text":"constant(f::SingleVariable, T::DataType)\n\nThe constant term of a SingleVariable function is the zero value of the specified type T.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/standard_form/#MathOptInterface.constant-Tuple{MathOptInterface.VectorOfVariables,DataType}","page":"Standard form","title":"MathOptInterface.constant","text":"constant(f::VectorOfVariables, T::DataType)\n\nThe constant term of a VectorOfVariables function is a vector of zero values of the specified type T.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/standard_form/#Sets","page":"Standard form","title":"Sets","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"AbstractSet\nAbstractScalarSet\nAbstractVectorSet","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractSet","page":"Standard form","title":"MathOptInterface.AbstractSet","text":"AbstractSet\n\nAbstract supertype for set objects used to encode constraints. A set object should not contain any VariableIndex or ConstraintIndex as the set is passed unmodifed during copy_to.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractScalarSet","page":"Standard form","title":"MathOptInterface.AbstractScalarSet","text":"AbstractScalarSet\n\nAbstract supertype for subsets of mathbbR.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractVectorSet","page":"Standard form","title":"MathOptInterface.AbstractVectorSet","text":"AbstractVectorSet\n\nAbstract supertype for subsets of mathbbR^n for some n.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#Utilities-2","page":"Standard form","title":"Utilities","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"dimension\ndual_set\ndual_set_type\nconstant(s::EqualTo)\nsupports_dimension_update\nupdate_dimension","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.dimension","page":"Standard form","title":"MathOptInterface.dimension","text":"dimension(s::AbstractSet)\n\nReturn the output_dimension that an AbstractFunction should have to be used with the set s.\n\nExamples\n\njulia> dimension(Reals(4))\n4\n\njulia> dimension(LessThan(3.0))\n1\n\njulia> dimension(PositiveSemidefiniteConeTriangle(2))\n3\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.dual_set","page":"Standard form","title":"MathOptInterface.dual_set","text":"dual_set(s::AbstractSet)\n\nReturn the dual set of s, that is the dual cone of the set. This follows the definition of duality discussed in Duality.\n\nSee Dual cone for more information.\n\nIf the dual cone is not defined it returns an error.\n\nExamples\n\njulia> dual_set(Reals(4))\nZeros(4)\n\njulia> dual_set(SecondOrderCone(5))\nSecondOrderCone(5)\n\njulia> dual_set(ExponentialCone())\nDualExponentialCone()\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.dual_set_type","page":"Standard form","title":"MathOptInterface.dual_set_type","text":"dual_set_type(S::Type{<:AbstractSet})\n\nReturn the type of dual set of sets of type S, as returned by dual_set. If the dual cone is not defined it returns an error.\n\nExamples\n\njulia> dual_set_type(Reals)\nZeros\n\njulia> dual_set_type(SecondOrderCone)\nSecondOrderCone\n\njulia> dual_set_type(ExponentialCone)\nDualExponentialCone\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.constant-Tuple{MathOptInterface.EqualTo}","page":"Standard form","title":"MathOptInterface.constant","text":"constant(s::Union{EqualTo, GreaterThan, LessThan})\n\nReturns the constant of the set.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/standard_form/#MathOptInterface.supports_dimension_update","page":"Standard form","title":"MathOptInterface.supports_dimension_update","text":"supports_dimension_update(S::Type{<:MOI.AbstractVectorSet})\n\nReturn a Bool indicating whether the elimination of any dimension of n-dimensional sets of type S give an n-1-dimensional set S. By default, this function returns false so it should only be implemented for sets that supports dimension update.\n\nFor instance, supports_dimension_update(MOI.Nonnegatives} is true because the elimination of any dimension of the n-dimensional nonnegative orthant gives the n-1-dimensional nonnegative orthant. However supports_dimension_update(MOI.ExponentialCone} is false.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.update_dimension","page":"Standard form","title":"MathOptInterface.update_dimension","text":"update_dimension(s::AbstractVectorSet, new_dim)\n\nReturns a set with the dimension modified to new_dim.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#Scalar-sets","page":"Standard form","title":"Scalar sets","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"List of recognized scalar sets.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"GreaterThan\nLessThan\nEqualTo\nInterval\nInteger\nZeroOne\nSemicontinuous\nSemiinteger","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.GreaterThan","page":"Standard form","title":"MathOptInterface.GreaterThan","text":"GreaterThan{T <: Real}(lower::T)\n\nThe set lowerinfty) subseteq mathbbR.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.LessThan","page":"Standard form","title":"MathOptInterface.LessThan","text":"LessThan{T <: Real}(upper::T)\n\nThe set (-inftyupper subseteq mathbbR.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.EqualTo","page":"Standard form","title":"MathOptInterface.EqualTo","text":"EqualTo{T <: Number}(value::T)\n\nThe set containing the single point x in mathbbR where x is given by value.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Interval","page":"Standard form","title":"MathOptInterface.Interval","text":"Interval{T <: Real}(lower::T,upper::T)\n\nThe interval lower upper subseteq mathbbR. If lower or upper is -Inf or Inf, respectively, the set is interpreted as a one-sided interval.\n\nInterval(s::GreaterThan{<:AbstractFloat})\n\nConstruct a (right-unbounded) Interval equivalent to the given GreaterThan set.\n\nInterval(s::LessThan{<:AbstractFloat})\n\nConstruct a (left-unbounded) Interval equivalent to the given LessThan set.\n\nInterval(s::EqualTo{<:Real})\n\nConstruct a (degenerate) Interval equivalent to the given EqualTo set.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Integer","page":"Standard form","title":"MathOptInterface.Integer","text":"Integer()\n\nThe set of integers mathbbZ.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ZeroOne","page":"Standard form","title":"MathOptInterface.ZeroOne","text":"ZeroOne()\n\nThe set  0 1 .\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Semicontinuous","page":"Standard form","title":"MathOptInterface.Semicontinuous","text":"Semicontinuous{T <: Real}(lower::T,upper::T)\n\nThe set 0 cup lowerupper.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Semiinteger","page":"Standard form","title":"MathOptInterface.Semiinteger","text":"Semiinteger{T <: Real}(lower::T,upper::T)\n\nThe set 0 cup lowerlower+1ldotsupper-1upper.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#Vector-sets","page":"Standard form","title":"Vector sets","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"List of recognized vector sets.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"Reals\nZeros\nNonnegatives\nNonpositives\nNormInfinityCone\nNormOneCone\nSecondOrderCone\nRotatedSecondOrderCone\nGeometricMeanCone\nExponentialCone\nDualExponentialCone\nPowerCone\nDualPowerCone\nRelativeEntropyCone\nNormSpectralCone\nNormNuclearCone\nSOS1\nSOS2\nIndicatorSet\nComplements","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.Reals","page":"Standard form","title":"MathOptInterface.Reals","text":"Reals(dimension)\n\nThe set mathbbR^dimension (containing all points) of dimension dimension.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Zeros","page":"Standard form","title":"MathOptInterface.Zeros","text":"Zeros(dimension)\n\nThe set  0 ^dimension (containing only the origin) of dimension dimension.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Nonnegatives","page":"Standard form","title":"MathOptInterface.Nonnegatives","text":"Nonnegatives(dimension)\n\nThe nonnegative orthant  x in mathbbR^dimension  x ge 0  of dimension dimension.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Nonpositives","page":"Standard form","title":"MathOptInterface.Nonpositives","text":"Nonpositives(dimension)\n\nThe nonpositive orthant  x in mathbbR^dimension  x le 0  of dimension dimension.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.NormInfinityCone","page":"Standard form","title":"MathOptInterface.NormInfinityCone","text":"NormInfinityCone(dimension)\n\nThe ell_infty-norm cone  (tx) in mathbbR^dimension  t ge lVert x rVert_infty = max_i lvert x_i rvert  of dimension dimension.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.NormOneCone","page":"Standard form","title":"MathOptInterface.NormOneCone","text":"NormOneCone(dimension)\n\nThe ell_1-norm cone  (tx) in mathbbR^dimension  t ge lVert x rVert_1 = sum_i lvert x_i rvert  of dimension dimension.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.SecondOrderCone","page":"Standard form","title":"MathOptInterface.SecondOrderCone","text":"SecondOrderCone(dimension)\n\nThe second-order cone (or Lorenz cone or ell_2-norm cone)  (tx) in mathbbR^dimension  t ge lVert x rVert_2  of dimension dimension.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.RotatedSecondOrderCone","page":"Standard form","title":"MathOptInterface.RotatedSecondOrderCone","text":"RotatedSecondOrderCone(dimension)\n\nThe rotated second-order cone  (tux) in mathbbR^dimension  2tu ge lVert x rVert_2^2 tu ge 0  of dimension dimension.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.GeometricMeanCone","page":"Standard form","title":"MathOptInterface.GeometricMeanCone","text":"GeometricMeanCone(dimension)\n\nThe geometric mean cone  (tx) in mathbbR^n+1  x ge 0 t le sqrtnx_1 x_2 cdots x_n  of dimension dimension=n+1.\n\nDuality note\n\nThe dual of the geometric mean cone is  (u v) in mathbbR^n+1  u le 0 v ge 0 -u le n sqrtnprod_i v_i  of dimension dimension=n+1.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ExponentialCone","page":"Standard form","title":"MathOptInterface.ExponentialCone","text":"ExponentialCone()\n\nThe 3-dimensional exponential cone  (xyz) in mathbbR^3  y exp (xy) le z y  0 .\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.DualExponentialCone","page":"Standard form","title":"MathOptInterface.DualExponentialCone","text":"DualExponentialCone()\n\nThe 3-dimensional dual exponential cone  (uvw) in mathbbR^3  -u exp (vu) le exp(1) w u  0 .\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.PowerCone","page":"Standard form","title":"MathOptInterface.PowerCone","text":"PowerCone{T <: Real}(exponent::T)\n\nThe 3-dimensional power cone  (xyz) in mathbbR^3  x^exponent y^1-exponent ge z x ge 0 y ge 0  with parameter exponent.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.DualPowerCone","page":"Standard form","title":"MathOptInterface.DualPowerCone","text":"DualPowerCone{T <: Real}(exponent::T)\n\nThe 3-dimensional power cone  (uvw) in mathbbR^3  (fracuexponent)^exponent (fracv1-exponent)^1-exponent ge w u ge 0 v ge 0  with parameter exponent.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.RelativeEntropyCone","page":"Standard form","title":"MathOptInterface.RelativeEntropyCone","text":"RelativeEntropyCone(dimension)\n\nThe relative entropy cone  (u v w) in mathbbR^1+2n  u ge sum_i=1^n w_i log (fracw_iv_i) v_i ge 0 w_i ge 0  of dimension dimension=2n+1.\n\nDuality note\n\nThe dual of the relative entropy cone is  (u v w) in mathbbR^1+2n  forall i w_i ge u (log (fracuv_i) - 1) v_i ge 0 u  0  of dimension dimension=2n+1.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.NormSpectralCone","page":"Standard form","title":"MathOptInterface.NormSpectralCone","text":"NormSpectralCone(row_dim, column_dim)\n\nThe epigraph of the matrix spectral norm (maximum singular value function)  (t X) in mathbbR^1 + row_dim times column_dim  t ge sigma_1(X)  where sigma_i is the ith singular value of the matrix X of row dimension row_dim and column dimension column_dim. The matrix X is vectorized by stacking the columns, matching the behavior of Julia's vec function.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.NormNuclearCone","page":"Standard form","title":"MathOptInterface.NormNuclearCone","text":"NormNuclearCone(row_dim, column_dim)\n\nThe epigraph of the matrix nuclear norm (sum of singular values function)  (t X) in mathbbR^1 + row_dim times column_dim  t ge sum_i sigma_i(X)  where sigma_i is the ith singular value of the matrix X of row dimension row_dim and column dimension column_dim. The matrix X is vectorized by stacking the columns, matching the behavior of Julia's vec function.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.SOS1","page":"Standard form","title":"MathOptInterface.SOS1","text":"SOS1{T <: Real}(weights::Vector{T})\n\nThe set corresponding to the special ordered set (SOS) constraint of type 1. Of the variables in the set, at most one can be nonzero. The weights induce an ordering of the variables; as such, they should be unique values. The kth element in the set corresponds to the kth weight in weights. See here for a description of SOS constraints and their potential uses.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.SOS2","page":"Standard form","title":"MathOptInterface.SOS2","text":"SOS2{T <: Real}(weights::Vector{T})\n\nThe set corresponding to the special ordered set (SOS) constraint of type 2. Of the variables in the set, at most two can be nonzero, and if two are nonzero, they must be adjacent in the ordering of the set. The weights induce an ordering of the variables; as such, they should be unique values. The kth element in the set corresponds to the kth weight in weights. See here for a description of SOS constraints and their potential uses.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.IndicatorSet","page":"Standard form","title":"MathOptInterface.IndicatorSet","text":"IndicatorSet{A, S <: AbstractScalarSet}(set::S)\n\n(y x) in 0 1 times mathbbR^n  y = 0 implies x in set when A is ACTIVATE_ON_ZERO and (y x) in 0 1 times mathbbR^n  y = 1 implies x in set when A is ACTIVATE_ON_ONE.\n\nS has to be a sub-type of AbstractScalarSet. A is one of the value of the ActivationCond enum. IndicatorSet is used with a VectorAffineFunction holding the indicator variable first.\n\nExample: (y x) in 0 1 times mathbbR^2  y = 1 implies x_1 + x_2 leq 9 \n\nf = MOI.VectorAffineFunction(\n    [MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(1.0, y)),\n     MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(1.0, x1)),\n     MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(1.0, x2)),\n    ],\n    [0.0, 0.0],\n)\n\nindicator_set = MOI.IndicatorSet{MOI.ACTIVATE_ON_ONE}(MOI.LessThan(9.0))\n\nMOI.add_constraint(model, f, indicator_set)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Complements","page":"Standard form","title":"MathOptInterface.Complements","text":"Complements(dimension::Int)\n\nThe set corresponding to a mixed complementarity constraint.\n\nComplementarity constraints should be specified with an AbstractVectorFunction-in-Complements(dimension) constraint.\n\nThe dimension of the vector-valued function F must be 2 * dimension. This defines a complementarity constraint between the scalar function F[i] and the variable in F[i + dimension]. Thus, F[i + dimension] must be interpretable as a single variable x_i (e.g., 1.0 * x + 0.0).\n\nThe mixed complementarity problem consists of finding x_i in the interval [lb, ub] (i.e., in the set Interval(lb, ub)), such that the following holds:\n\nF_i(x) == 0 if lb_i < x_i < ub_i\nF_i(x) >= 0 if lb_i == x_i\nF_i(x) <= 0 if x_i == ub_i\n\nClassically, the bounding set for x_i is Interval(0, Inf), which recovers: 0 <= F_i(x) ‚üÇ x_i >= 0, where the ‚üÇ operator implies F_i(x) * x_i = 0.\n\nExamples\n\nThe problem:\n\nx -in- Interval(-1, 1)\n[-4 * x - 3, x] -in- Complements(1)\n\ndefines the mixed complementarity problem where the following holds:\n\n-4 * x - 3 == 0 if -1 < x < 1\n-4 * x - 3 >= 0 if x == -1\n-4 * x - 3 <= 0 if x == 1\n\nThere are three solutions:\n\nx = -3/4 with F(x) = 0\nx = -1 with F(x) = 1\nx = 1 with F(x) = -7\n\nThe function F can also be defined in terms of single variables. For example, the problem:\n\n[x_3, x_4] -in- Nonnegatives(2)\n[x_1, x_2, x_3, x_4] -in- Complements(2)\n\ndefines the complementarity problem where 0 <= x_1 ‚üÇ x_3 >= 0 and 0 <= x_2 ‚üÇ x_4 >= 0.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#Matrix-sets","page":"Standard form","title":"Matrix sets","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"Matrix sets are vectorized in order to be subtypes of AbstractVectorSet. For sets of symmetric matrices, storing both the (i, j) and (j, i) elements is redundant so there exists the AbstractSymmetricMatrixSetTriangle set to represent only the vectorization of the upper triangular part of the matrix. When the matrix of expressions constrained to be in the set is not symmetric and hence the (i, j) and (j, i) elements should be constrained to be symmetric, the AbstractSymmetricMatrixSetSquare set can be used. The Bridges.Constraint.SquareBridge can transform a set from the square form to the triangular_form by adding appropriate constraints if the (i, j) and (j, i) expressions are different.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"AbstractSymmetricMatrixSetTriangle\nAbstractSymmetricMatrixSetSquare\nside_dimension\ntriangular_form","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractSymmetricMatrixSetTriangle","page":"Standard form","title":"MathOptInterface.AbstractSymmetricMatrixSetTriangle","text":"abstract type AbstractSymmetricMatrixSetTriangle <: AbstractVectorSet end\n\nAbstract supertype for subsets of the (vectorized) cone of symmetric matrices, with side_dimension rows and columns. The entries of the upper-right triangular part of the matrix are given column by column (or equivalently, the entries of the lower-left triangular part are given row by row). A vectorized cone of dimension n corresponds to a square matrix with side dimension sqrt14 + 2 n - 12. (Because a d times d matrix has d(d + 1)  2 elements in the upper or lower triangle.)\n\nExamples\n\nThe matrix\n\nbeginbmatrix\n  1  2  4\n  2  3  5\n  4  5  6\nendbmatrix\n\nhas side_dimension 3 and vectorization (1 2 3 4 5 6).\n\nNote\n\nTwo packed storage formats exist for symmetric matrices, the respective orders of the entries are:\n\nupper triangular column by column (or lower triangular row by row);\nlower triangular column by column (or upper triangular row by row).\n\nThe advantage of the first format is the mapping between the (i, j) matrix indices and the k index of the vectorized form. It is simpler and does not depend on the side dimension of the matrix. Indeed,\n\nthe entry of matrix indices (i, j) has vectorized index k = div((j - 1) * j, 2) + i if i leq j and k = div((i - 1) * i, 2) + j if j leq i;\nand the entry with vectorized index k has matrix indices i = div(1 + isqrt(8k - 7), 2) and j = k - div((i - 1) * i, 2) or j = div(1 + isqrt(8k - 7), 2) and i = k - div((j - 1) * j, 2).\n\nDuality note\n\nThe scalar product for the symmetric matrix in its vectorized form is the sum of the pairwise product of the diagonal entries plus twice the sum of the pairwise product of the upper diagonal entries; see [p. 634, 1]. This has important consequence for duality.\n\nConsider for example the following problem (PositiveSemidefiniteConeTriangle is a subtype of AbstractSymmetricMatrixSetTriangle)\n\nbeginalign*\n     max_x in mathbbR  x\n    \n     textst \n    (1 -x 1)  in textPositiveSemidefiniteConeTriangle(2)\nendalign*\n\nThe dual is the following problem\n\nbeginalign*\n     min_x in mathbbR^3  y_1 + y_3\n    \n     textst  2y_2  = 1\n      y  in textPositiveSemidefiniteConeTriangle(2)\nendalign*\n\nWhy do we use 2y_2 in the dual constraint instead of y_2 ? The reason is that 2y_2 is the scalar product between y and the symmetric matrix whose vectorized form is (0 1 0). Indeed, with our modified scalar products we have\n\nlangle\n(0 1 0)\n(y_1 y_2 y_3)\nrangle\n=\nmathrmtrace\nbeginpmatrix\n  0  1\n  1  0\nendpmatrix\nbeginpmatrix\n  y_1  y_2\n  y_2  y_3\nendpmatrix\n= 2y_2\n\nReferences\n\n[1] Boyd, S. and Vandenberghe, L.. Convex optimization. Cambridge university press, 2004.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractSymmetricMatrixSetSquare","page":"Standard form","title":"MathOptInterface.AbstractSymmetricMatrixSetSquare","text":"abstract type AbstractSymmetricMatrixSetSquare <: AbstractVectorSet end\n\nAbstract supertype for subsets of the (vectorized) cone of symmetric matrices, with side_dimension rows and columns. The entries of the matrix are given column by column (or equivalently, row by row). The matrix is both constrained to be symmetric and to have its triangular_form belong to the corresponding set. That is, if the functions in entries (i j) and (j i) are different, then a constraint will be added to make sure that the entries are equal.\n\nExamples\n\nPositiveSemidefiniteConeSquare is a subtype of AbstractSymmetricMatrixSetSquare and constraining the matrix\n\nbeginbmatrix\n  1  -y\n  -z  0\nendbmatrix\n\nto be symmetric positive semidefinite can be achieved by constraining the vector (1 -z -y 0) (or (1 -y -z 0)) to belong to the PositiveSemidefiniteConeSquare(2). It both constrains y = z and (1 -y 0) (or (1 -z 0)) to be in PositiveSemidefiniteConeTriangle(2), since triangular_form(PositiveSemidefiniteConeSquare) is PositiveSemidefiniteConeTriangle.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.side_dimension","page":"Standard form","title":"MathOptInterface.side_dimension","text":"side_dimension(set::Union{AbstractSymmetricMatrixSetTriangle,\n                          AbstractSymmetricMatrixSetSquare})\n\nSide dimension of the matrices in set. By convention, it should be stored in the side_dimension field but if it is not the case for a subtype of AbstractSymmetricMatrixSetTriangle, the method should be implemented for this subtype.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.triangular_form","page":"Standard form","title":"MathOptInterface.triangular_form","text":"triangular_form(S::Type{<:AbstractSymmetricMatrixSetSquare})\ntriangular_form(set::AbstractSymmetricMatrixSetSquare)\n\nReturn the AbstractSymmetricMatrixSetTriangle corresponding to the vectorization of the upper triangular part of matrices in the AbstractSymmetricMatrixSetSquare set.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"List of recognized matrix sets.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"PositiveSemidefiniteConeTriangle\nPositiveSemidefiniteConeSquare\nLogDetConeTriangle\nLogDetConeSquare\nRootDetConeTriangle\nRootDetConeSquare","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeTriangle","page":"Standard form","title":"MathOptInterface.PositiveSemidefiniteConeTriangle","text":"PositiveSemidefiniteConeTriangle(side_dimension) <: AbstractSymmetricMatrixSetTriangle\n\nThe (vectorized) cone of symmetric positive semidefinite matrices, with side_dimension rows and columns. See AbstractSymmetricMatrixSetTriangle for more details on the vectorized form.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeSquare","page":"Standard form","title":"MathOptInterface.PositiveSemidefiniteConeSquare","text":"PositiveSemidefiniteConeSquare(side_dimension) <: AbstractSymmetricMatrixSetSquare\n\nThe cone of symmetric positive semidefinite matrices, with side length side_dimension.  See AbstractSymmetricMatrixSetSquare for more details on the vectorized form.\n\nThe entries of the matrix are given column by column (or equivalently, row by row). The matrix is both constrained to be symmetric and to be positive semidefinite. That is, if the functions in entries (i j) and (j i) are different, then a constraint will be added to make sure that the entries are equal.\n\nExamples\n\nConstraining the matrix\n\nbeginbmatrix\n  1  -y\n  -z  0\nendbmatrix\n\nto be symmetric positive semidefinite can be achieved by constraining the vector (1 -z -y 0) (or (1 -y -z 0)) to belong to the PositiveSemidefiniteConeSquare(2). It both constrains y = z and (1 -y 0) (or (1 -z 0)) to be in PositiveSemidefiniteConeTriangle(2).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.LogDetConeTriangle","page":"Standard form","title":"MathOptInterface.LogDetConeTriangle","text":"LogDetConeTriangle(side_dimension)\n\nThe log-determinant cone  (t u X) in mathbbR^2 + d(d+1)2  t le u log(det(Xu)) u  0  where the matrix X is represented in the same symmetric packed format as in the PositiveSemidefiniteConeTriangle. The argument side_dimension is the side dimension of the matrix X, i.e., its number of rows or columns.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.LogDetConeSquare","page":"Standard form","title":"MathOptInterface.LogDetConeSquare","text":"LogDetConeSquare(side_dimension)\n\nThe log-determinant cone  (t u X) in mathbbR^2 + d^2  t le u log(det(Xu)) X text symmetric u  0  where the matrix X is represented in the same format as in the PositiveSemidefiniteConeSquare. Similarly to PositiveSemidefiniteConeSquare, constraints are added to ensures that X is symmetric. The argument side_dimension is the side dimension of the matrix X, i.e., its number of rows or columns.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.RootDetConeTriangle","page":"Standard form","title":"MathOptInterface.RootDetConeTriangle","text":"RootDetConeTriangle(side_dimension)\n\nThe root-determinant cone  (t X) in mathbbR^1 + d(d+1)2  t le det(X)^1d  where the matrix X is represented in the same symmetric packed format as in the PositiveSemidefiniteConeTriangle. The argument side_dimension is the side dimension of the matrix X, i.e., its number of rows or columns.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.RootDetConeSquare","page":"Standard form","title":"MathOptInterface.RootDetConeSquare","text":"RootDetConeSquare(side_dimension)\n\nThe root-determinant cone  (t X) in mathbbR^1 + d^2  t le det(X)^1d X text symmetric  where the matrix X is represented in the same format as in the PositiveSemidefiniteConeSquare. Similarly to PositiveSemidefiniteConeSquare, constraints are added to ensure that X is symmetric. The argument side_dimension is the side dimension of the matrix X, i.e., its number of rows or columns.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/sudoku.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/#Sudoku","page":"Sudoku","title":"Sudoku","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Originally Contributed by: Iain Dunning","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Sudoku is a popular number puzzle. The goal is to place the digits 1,...,9 on a nine-by-nine grid, with some of the digits already filled in. Your solution must satisfy the following rules:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"The numbers 1 to 9 must appear in each 3x3 square\nThe numbers 1 to 9 must appear in each row\nThe numbers 1 to 9 must appear in each column","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Here is a partially solved Sudoku problem:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"(Image: Partially solved Sudoku)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Solving a Sudoku isn't an optimization problem with an objective; its actually a feasibility problem: we wish to find a feasible solution that satisfies these rules. You can think of it as an optimization problem with an objective of 0.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"We can model this problem using 0-1 integer programming: a problem where all the decision variables are binary. We'll use JuMP to create the model, and then we can solve it with any integer programming solver.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"using JuMP\nusing GLPK","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"We will define a binary variable (a variable that is either 0 or 1) for each possible number in each possible cell. The meaning of each variable is as follows: x[i,j,k] = 1  if and only if cell (i,j) has number k, where i is the row and j is the column.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Create a model","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"sudoku = Model(GLPK.Optimizer)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Create our variables","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"@variable(sudoku, x[i=1:9, j=1:9, k=1:9], Bin)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Now we can begin to add our constraints. We'll actually start with something obvious to us as humans, but what we need to enforce: that there can be only one number per cell.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"for i = 1:9  ## For each row\n    for j = 1:9  ## and each column\n        # Sum across all the possible digits. One and only one of the digits\n        # can be in this cell, so the sum must be equal to one.\n        @constraint(sudoku, sum(x[i, j, k] for k = 1:9) == 1)\n    end\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Next we'll add the constraints for the rows and the columns. These constraints are all very similar, so much so that we can actually add them at the same time.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"for ind = 1:9  ## Each row, OR each column\n    for k = 1:9  ## Each digit\n        # Sum across columns (j) - row constraint\n        @constraint(sudoku, sum(x[ind, j, k] for j = 1:9) == 1)\n        # Sum across rows (i) - column constraint\n        @constraint(sudoku, sum(x[i, ind, k] for i = 1:9) == 1)\n    end\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Finally, we have the to enforce the constraint that each digit appears once in each of the nine 3x3 sub-grids. Our strategy will be to index over the top-left corners of each 3x3 square with for loops, then sum over the squares.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"for i = 1:3:7\n    for j = 1:3:7\n        for k = 1:9\n            # i is the top left row, j is the top left column.\n            # We'll sum from i to i+2, e.g. i=4, r=4, 5, 6.\n            @constraint(\n                sudoku,\n                sum(x[r, c, k] for r in i:(i+2), c in j:(j+2)) == 1\n            )\n        end\n    end\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"The final step is to add the initial solution as a set of constraints. We'll solve the problem that is in the picture at the start of the tutorial. We'll put a 0 if there is no digit in that location.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"The given digits","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"init_sol = [\n    5 3 0 0 7 0 0 0 0\n    6 0 0 1 9 5 0 0 0\n    0 9 8 0 0 0 0 6 0\n    8 0 0 0 6 0 0 0 3\n    4 0 0 8 0 3 0 0 1\n    7 0 0 0 2 0 0 0 6\n    0 6 0 0 0 0 2 8 0\n    0 0 0 4 1 9 0 0 5\n    0 0 0 0 8 0 0 7 9\n]\nfor i = 1:9\n    for j = 1:9\n        # If the space isn't empty\n        if init_sol[i, j] != 0\n            # Then the corresponding variable for that digit and location must\n            # be 1.\n            fix(x[i, j, init_sol[i, j]], 1; force = true)\n        end\n    end\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"solve problem","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"optimize!(sudoku)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Extract the values of x","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"x_val = value.(x)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Create a matrix to store the solution","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"sol = zeros(Int, 9, 9)  # 9x9 matrix of integers\nfor i = 1:9\n    for j = 1:9\n        for k = 1:9\n            # Integer programs are solved as a series of linear programs so the\n            # values might not be precisely 0 and 1. We can just round them to\n            # the nearest integer to make it easier.\n            if round(Int, x_val[i, j, k]) == 1\n                sol[i, j] = k\n            end\n        end\n    end\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Display the solution","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"sol","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Which is the correct solution:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"(Image: Solved Sudoku)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Semidefinite programs/corr_sdp.jl\"","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/#The-correlation-problem","page":"The correlation problem","title":"The correlation problem","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"Given three random variables A, B, C and given bounds on two of the three correlation coefficients:","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"-0.2 <= œÅ_AB <= -0.1\n0.4 <= œÅ_BC <=  0.5","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"We can use the following property of the correlations to determine bounds on œÅ_AC by solving a SDP:","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"|  1    œÅ_AB  œÅ_AC |\n| œÅ_AB   1    œÅ_BC |  ‚âΩ 0\n| œÅ_AC  œÅ_BC   1   |","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"using JuMP\nimport SCS\n\nfunction example_corr_sdp()\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, X[1:3, 1:3], PSD)\n    # Diagonal is 1s\n    @constraint(model, X[1, 1] == 1)\n    @constraint(model, X[2, 2] == 1)\n    @constraint(model, X[3, 3] == 1)\n    # Bounds on the known correlations\n    @constraint(model, X[1, 2] >= -0.2)\n    @constraint(model, X[1, 2] <= -0.1)\n    @constraint(model, X[2, 3] >=  0.4)\n    @constraint(model, X[2, 3] <=  0.5)\n    # Find upper bound\n    @objective(model, Max, X[1, 3])\n    optimize!(model)\n    println(\"An upper bound for X[1, 3] is $(value(X[1, 3]))\")\n    # Find lower bound\n    @objective(model, Min, X[1, 3])\n    optimize!(model)\n    println(\"A lower bound for X[1, 3] is $(value(X[1, 3]))\")\n    return\nend\n\nexample_corr_sdp()","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/variables/#VariableAPI","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"More information can be found in the Variables section of the manual.","category":"page"},{"location":"reference/variables/#Macros","page":"Variables","title":"Macros","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"@variable\n@variables","category":"page"},{"location":"reference/variables/#JuMP.@variable","page":"Variables","title":"JuMP.@variable","text":"@variable(model, kw_args...)\n\nAdd an anonymous variable to the model model described by the keyword arguments kw_args and returns the variable.\n\n@variable(model, expr, args..., kw_args...)\n\nAdd a variable to the model model described by the expression expr, the positional arguments args and the keyword arguments kw_args. The expression expr can either be (note that in the following the symbol <= can be used instead of ‚â§ and the symbol >=can be used instead of ‚â•)\n\nof the form varexpr creating variables described by varexpr;\nof the form varexpr ‚â§ ub (resp. varexpr ‚â• lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb);\nof the form varexpr == value creating variables described by varexpr with fixed values given by value; or\nof the form lb ‚â§ varexpr ‚â§ ub or ub ‚â• varexpr ‚â• lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub.\nof the form varexpr in set creating variables described by varexpr constrained to belong to set, see Variables constrained on creation.\n\nThe expression varexpr can either be\n\nof the form varname creating a scalar real variable of name varname;\nof the form varname[...] or [...] creating a container of variables.\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\nSymmetric: Only available when creating a square matrix of variables, i.e. when varexpr is of the form varname[1:n,1:n] or varname[i=1:n,j=1:n]. It creates a symmetric matrix of variable, that is, it only creates a new variable for varname[i,j] with i ‚â§ j and sets varname[j,i] to the same variable as varname[i,j]. It is equivalent to using varexpr in SymMatrixSpace() as expr.\nPSD: The square matrix of variable is both Symmetric and constrained to be positive semidefinite. It is equivalent to using varexpr in PSDCone() as expr.\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes.\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\nvariable_type: See the \"Note for extending the variable macro\" section below.\nset: Equivalent to using varexpr in value as expr where value is the value of the keyword argument.\ncontainer: Specify the container type.\n\nExamples\n\nThe following are equivalent ways of creating a variable x of name x with lower bound 0:\n\n# Specify everything in `expr`\n@variable(model, x >= 0)\n# Specify the lower bound using a keyword argument\n@variable(model, x, lower_bound=0)\n# Specify everything in `kw_args`\nx = @variable(model, base_name=\"x\", lower_bound=0)\n\nThe following are equivalent ways of creating a DenseAxisArray of index set [:a, :b] and with respective upper bounds 2 and 3 and names x[a] and x[b]. The upper bound can either be specified in expr:\n\nub = Dict(:a => 2, :b => 3)\n@variable(model, x[i=keys(ub)] <= ub[i])\n\n# output\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{VariableRef,1}:\n x[a]\n x[b]\n\nor it can be specified with the upper_bound keyword argument:\n\n@variable(model, y[i=keys(ub)], upper_bound=ub[i])\n\n# output\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{VariableRef,1}:\n y[a]\n y[b]\n\n\n\n\n\n","category":"macro"},{"location":"reference/variables/#JuMP.@variables","page":"Variables","title":"JuMP.@variables","text":"@variables(model, args...)\n\nAdds multiple variables to model at once, in the same fashion as the @variable macro.\n\nThe model must be the first argument, and multiple variables can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@variables(model, begin\n    x\n    y[i = 1:2] >= 0, (start = i)\n    z, Bin, (start = 0, base_name = \"Z\")\nend)\n\nnote: Note\nKeyword arguments must be contained within parentheses (refer to the example above).\n\n\n\n\n\n","category":"macro"},{"location":"reference/variables/#Basic-utilities","page":"Variables","title":"Basic utilities","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"VariableRef\nnum_variables\nall_variables\nowner_model\nindex(::VariableRef)\noptimizer_index(::VariableRef)\ncheck_belongs_to_model\nVariableNotOwned\nVariableConstrainedOnCreation\nVariablesConstrainedOnCreation","category":"page"},{"location":"reference/variables/#JuMP.VariableRef","page":"Variables","title":"JuMP.VariableRef","text":"VariableRef <: AbstractVariableRef\n\nHolds a reference to the model and the corresponding MOI.VariableIndex.\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.num_variables","page":"Variables","title":"JuMP.num_variables","text":"num_variables(model::Model)::Int64\n\nReturns number of variables in model.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.all_variables","page":"Variables","title":"JuMP.all_variables","text":"all_variables(model::Model)::Vector{VariableRef}\n\nReturns a list of all variables currently in the model. The variables are ordered by creation time.\n\nExample\n\nmodel = Model()\n@variable(model, x)\n@variable(model, y)\nall_variables(model)\n\n# output\n\n2-element Array{VariableRef,1}:\n x\n y\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.owner_model","page":"Variables","title":"JuMP.owner_model","text":"owner_model(s::AbstractJuMPScalar)\n\nReturn the model owning the scalar s.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.index-Tuple{VariableRef}","page":"Variables","title":"JuMP.index","text":"index(v::VariableRef)::MOI.VariableIndex\n\nReturn the index of the variable that corresponds to v in the MOI backend.\n\n\n\n\n\n","category":"method"},{"location":"reference/variables/#JuMP.optimizer_index-Tuple{VariableRef}","page":"Variables","title":"JuMP.optimizer_index","text":"optimizer_index(v::VariableRef)::MOI.VariableIndex\n\nReturn the index of the variable that corresponds to v in the optimizer model. It throws NoOptimizer if no optimizer is set and throws an ErrorException if the optimizer is set but is not attached.\n\n\n\n\n\n","category":"method"},{"location":"reference/variables/#JuMP.check_belongs_to_model","page":"Variables","title":"JuMP.check_belongs_to_model","text":"check_belongs_to_model(func::AbstractJuMPScalar, model::AbstractModel)\n\nThrow VariableNotOwned if the owner_model of one of the variables of the function func is not model.\n\ncheck_belongs_to_model(constraint::AbstractConstraint, model::AbstractModel)\n\nThrow VariableNotOwned if the owner_model of one of the variables of the constraint constraint is not model.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.VariableNotOwned","page":"Variables","title":"JuMP.VariableNotOwned","text":"struct VariableNotOwned{V <: AbstractVariableRef} <: Exception\n    variable::V\nend\n\nThe variable variable was used in a model different to owner_model(variable).\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.VariableConstrainedOnCreation","page":"Variables","title":"JuMP.VariableConstrainedOnCreation","text":"VariablesConstrainedOnCreation <: AbstractVariable\n\nVariable scalar_variables constrained to belong to set. Adding this variable can be understood as doing:\n\nfunction JuMP.add_variable(model::Model, variable::JuMP.VariableConstrainedOnCreation, names)\n    var_ref = JuMP.add_variable(model, variable.scalar_variable, name)\n    JuMP.add_constraint(model, JuMP.VectorConstraint(var_ref, variable.set))\n    return var_ref\nend\n\nbut adds the variables with MOI.add_constrained_variable(model, variable.set) instead. See the MOI documentation for the difference between adding the variables with MOI.add_constrained_variable and adding them with MOI.add_variable and adding the constraint separately.\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.VariablesConstrainedOnCreation","page":"Variables","title":"JuMP.VariablesConstrainedOnCreation","text":"VariablesConstrainedOnCreation <: AbstractVariable\n\nVector of variables scalar_variables constrained to belong to set. Adding this variable can be thought as doing:\n\nfunction JuMP.add_variable(model::Model, variable::JuMP.VariablesConstrainedOnCreation, names)\n    var_refs = JuMP.add_variable.(model, variable.scalar_variables,\n                                  JuMP.vectorize(names, variable.shape))\n    JuMP.add_constraint(model, JuMP.VectorConstraint(var_refs, variable.set))\n    return JuMP.reshape_vector(var_refs, variable.shape)\nend\n\nbut adds the variables with MOI.add_constrained_variables(model, variable.set) instead. See the MOI documentation for the difference between adding the variables with MOI.add_constrained_variables and adding them with MOI.add_variables and adding the constraint separately.\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#Names","page":"Variables","title":"Names","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"name(::JuMP.VariableRef)\nset_name(::JuMP.VariableRef, ::String)\nvariable_by_name","category":"page"},{"location":"reference/variables/#JuMP.name-Tuple{VariableRef}","page":"Variables","title":"JuMP.name","text":"name(v::VariableRef)::String\n\nGet a variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"reference/variables/#JuMP.set_name-Tuple{VariableRef,String}","page":"Variables","title":"JuMP.set_name","text":"set_name(v::VariableRef, s::AbstractString)\n\nSet a variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"reference/variables/#JuMP.variable_by_name","page":"Variables","title":"JuMP.variable_by_name","text":"variable_by_name(model::AbstractModel,\n                 name::String)::Union{AbstractVariableRef, Nothing}\n\nReturns the reference of the variable with name attribute name or Nothing if no variable has this name attribute. Throws an error if several variables have name as their name attribute.\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> variable_by_name(model, \"x\")\nx\n\njulia> @variable(model, base_name=\"x\")\nx\n\njulia> variable_by_name(model, \"x\")\nERROR: Multiple variables have the name x.\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] get(::MOIU.Model{Float64}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/model.jl:222\n [3] get at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/universalfallback.jl:201 [inlined]\n [4] get(::MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.AbstractOptimizer,MathOptInterface.Utilities.UniversalFallback{MOIU.Model{Float64}}}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/cachingoptimizer.jl:490\n [5] variable_by_name(::Model, ::String) at /home/blegat/.julia/dev/JuMP/src/variables.jl:268\n [6] top-level scope at none:0\n\njulia> var = @variable(model, base_name=\"y\")\ny\n\njulia> variable_by_name(model, \"y\")\ny\n\njulia> set_name(var, \"z\")\n\njulia> variable_by_name(model, \"y\")\n\njulia> variable_by_name(model, \"z\")\nz\n\njulia> @variable(model, u[1:2])\n2-element Array{VariableRef,1}:\n u[1]\n u[2]\n\njulia> variable_by_name(model, \"u[2]\")\nu[2]\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Start-values","page":"Variables","title":"Start values","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"set_start_value\nstart_value","category":"page"},{"location":"reference/variables/#JuMP.set_start_value","page":"Variables","title":"JuMP.set_start_value","text":"set_start_value(variable::VariableRef, value::Union{Real,Nothing})\n\nSet the start value (MOI attribute VariablePrimalStart) of the variable to value.\n\nPass nothing to unset the start value.\n\nNote: VariablePrimalStarts are sometimes called \"MIP-starts\" or \"warmstarts\".\n\nSee also start_value.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.start_value","page":"Variables","title":"JuMP.start_value","text":"start_value(v::VariableRef)\n\nReturn the start value (MOI attribute VariablePrimalStart) of the variable v.\n\nNote: VariablePrimalStarts are sometimes called \"MIP-starts\" or \"warmstarts\".\n\nSee also set_start_value.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Lower-bounds","page":"Variables","title":"Lower bounds","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"has_lower_bound\nlower_bound\nset_lower_bound\ndelete_lower_bound\nLowerBoundRef","category":"page"},{"location":"reference/variables/#JuMP.has_lower_bound","page":"Variables","title":"JuMP.has_lower_bound","text":"has_lower_bound(v::VariableRef)\n\nReturn true if v has a lower bound. If true, the lower bound can be queried with lower_bound.\n\nSee also LowerBoundRef, lower_bound, set_lower_bound, delete_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.lower_bound","page":"Variables","title":"JuMP.lower_bound","text":"lower_bound(v::VariableRef)\n\nReturn the lower bound of a variable. Error if one does not exist.\n\nSee also LowerBoundRef, has_lower_bound, set_lower_bound, delete_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.set_lower_bound","page":"Variables","title":"JuMP.set_lower_bound","text":"set_lower_bound(v::VariableRef, lower::Number)\n\nSet the lower bound of a variable. If one does not exist, create a new lower bound constraint.\n\nSee also LowerBoundRef, has_lower_bound, lower_bound, delete_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.delete_lower_bound","page":"Variables","title":"JuMP.delete_lower_bound","text":"delete_lower_bound(v::VariableRef)\n\nDelete the lower bound constraint of a variable.\n\nSee also LowerBoundRef, has_lower_bound, lower_bound, set_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.LowerBoundRef","page":"Variables","title":"JuMP.LowerBoundRef","text":"LowerBoundRef(v::VariableRef)\n\nReturn a constraint reference to the lower bound constraint of v. Errors if one does not exist.\n\nSee also has_lower_bound, lower_bound, set_lower_bound, delete_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Upper-bounds","page":"Variables","title":"Upper bounds","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"has_upper_bound\nupper_bound\nset_upper_bound\ndelete_upper_bound\nUpperBoundRef","category":"page"},{"location":"reference/variables/#JuMP.has_upper_bound","page":"Variables","title":"JuMP.has_upper_bound","text":"has_upper_bound(v::VariableRef)\n\nReturn true if v has a upper bound. If true, the upper bound can be queried with upper_bound.\n\nSee also UpperBoundRef, upper_bound, set_upper_bound, delete_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.upper_bound","page":"Variables","title":"JuMP.upper_bound","text":"upper_bound(v::VariableRef)\n\nReturn the upper bound of a variable. Error if one does not exist.\n\nSee also UpperBoundRef, has_upper_bound, set_upper_bound, delete_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.set_upper_bound","page":"Variables","title":"JuMP.set_upper_bound","text":"set_upper_bound(v::VariableRef,upper::Number)\n\nSet the upper bound of a variable. If one does not exist, create an upper bound constraint.\n\nSee also UpperBoundRef, has_upper_bound, upper_bound, delete_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.delete_upper_bound","page":"Variables","title":"JuMP.delete_upper_bound","text":"delete_upper_bound(v::VariableRef)\n\nDelete the upper bound constraint of a variable.\n\nSee also UpperBoundRef, has_upper_bound, upper_bound, set_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.UpperBoundRef","page":"Variables","title":"JuMP.UpperBoundRef","text":"UpperBoundRef(v::VariableRef)\n\nReturn a constraint reference to the upper bound constraint of v. Errors if one does not exist.\n\nSee also has_upper_bound, upper_bound, set_upper_bound, delete_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Fixed-bounds","page":"Variables","title":"Fixed bounds","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"is_fixed\nfix_value\nfix\nunfix\nFixRef","category":"page"},{"location":"reference/variables/#JuMP.is_fixed","page":"Variables","title":"JuMP.is_fixed","text":"is_fixed(v::VariableRef)\n\nReturn true if v is a fixed variable. If true, the fixed value can be queried with fix_value.\n\nSee also FixRef, fix_value, fix, unfix.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.fix_value","page":"Variables","title":"JuMP.fix_value","text":"fix_value(v::VariableRef)\n\nReturn the value to which a variable is fixed. Error if one does not exist.\n\nSee also FixRef, is_fixed, fix, unfix.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.fix","page":"Variables","title":"JuMP.fix","text":"fix(v::VariableRef, value::Number; force::Bool = false)\n\nFix a variable to a value. Update the fixing constraint if one exists, otherwise create a new one.\n\nIf the variable already has variable bounds and force=false, calling fix will throw an error. If force=true, existing variable bounds will be deleted, and the fixing constraint will be added. Note a variable will have no bounds after a call to unfix.\n\nSee also FixRef, is_fixed, fix_value, unfix.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.unfix","page":"Variables","title":"JuMP.unfix","text":"unfix(v::VariableRef)\n\nDelete the fixing constraint of a variable.\n\nSee also FixRef, is_fixed, fix_value, fix.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.FixRef","page":"Variables","title":"JuMP.FixRef","text":"FixRef(v::VariableRef)\n\nReturn a constraint reference to the constraint fixing the value of v. Errors if one does not exist.\n\nSee also is_fixed, fix_value, fix, unfix.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Integer-variables","page":"Variables","title":"Integer variables","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"is_integer\nset_integer\nunset_integer\nIntegerRef","category":"page"},{"location":"reference/variables/#JuMP.is_integer","page":"Variables","title":"JuMP.is_integer","text":"is_integer(v::VariableRef)\n\nReturn true if v is constrained to be integer.\n\nSee also IntegerRef, set_integer, unset_integer.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.set_integer","page":"Variables","title":"JuMP.set_integer","text":"set_integer(variable_ref::VariableRef)\n\nAdd an integrality constraint on the variable variable_ref.\n\nSee also IntegerRef, is_integer, unset_integer.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.unset_integer","page":"Variables","title":"JuMP.unset_integer","text":"unset_integer(variable_ref::VariableRef)\n\nRemove the integrality constraint on the variable variable_ref.\n\nSee also IntegerRef, is_integer, set_integer.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.IntegerRef","page":"Variables","title":"JuMP.IntegerRef","text":"IntegerRef(v::VariableRef)\n\nReturn a constraint reference to the constraint constraining v to be integer. Errors if one does not exist.\n\nSee also is_integer, set_integer, unset_integer.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Binary-variables","page":"Variables","title":"Binary variables","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"is_binary\nset_binary\nunset_binary\nBinaryRef","category":"page"},{"location":"reference/variables/#JuMP.is_binary","page":"Variables","title":"JuMP.is_binary","text":"is_binary(v::VariableRef)\n\nReturn true if v is constrained to be binary.\n\nSee also BinaryRef, set_binary, unset_binary.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.set_binary","page":"Variables","title":"JuMP.set_binary","text":"set_binary(v::VariableRef)\n\nAdd a constraint on the variable v that it must take values in the set 01.\n\nSee also BinaryRef, is_binary, unset_binary.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.unset_binary","page":"Variables","title":"JuMP.unset_binary","text":"unset_binary(variable_ref::VariableRef)\n\nRemove the binary constraint on the variable variable_ref.\n\nSee also BinaryRef, is_binary, set_binary.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.BinaryRef","page":"Variables","title":"JuMP.BinaryRef","text":"BinaryRef(v::VariableRef)\n\nReturn a constraint reference to the constraint constraining v to be binary. Errors if one does not exist.\n\nSee also is_binary, set_binary, unset_binary.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Integrality-utilities","page":"Variables","title":"Integrality utilities","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"relax_integrality","category":"page"},{"location":"reference/variables/#JuMP.relax_integrality","page":"Variables","title":"JuMP.relax_integrality","text":"relax_integrality(model::Model)\n\nModifies model to \"relax\" all binary and integrality constraints on variables. Specifically,\n\nBinary constraints are deleted, and variable bounds are tightened if necessary to ensure the variable is constrained to the interval 0 1.\nIntegrality constraints are deleted without modifying variable bounds.\nAn error is thrown if semi-continuous or semi-integer constraints are present (support may be added for these in the future).\nAll other constraints are ignored (left in place). This includes discrete constraints like SOS and indicator constraints.\n\nReturns a function that can be called without any arguments to restore the original model. The behavior of this function is undefined if additional changes are made to the affected variables in the meantime.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x, Bin);\n\njulia> @variable(model, 1 <= y <= 10, Int);\n\njulia> @objective(model, Min, x + y);\n\njulia> undo_relax = relax_integrality(model);\n\njulia> print(model)\nMin x + y\nSubject to\n x ‚â• 0.0\n y ‚â• 1.0\n x ‚â§ 1.0\n y ‚â§ 10.0\n\njulia> undo_relax()\n\njulia> print(model)\nMin x + y\nSubject to\n y ‚â• 1.0\n y ‚â§ 10.0\n y integer\n x binary\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Extensions","page":"Variables","title":"Extensions","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"AbstractVariable\nAbstractVariableRef\nparse_one_operator_variable","category":"page"},{"location":"reference/variables/#JuMP.AbstractVariable","page":"Variables","title":"JuMP.AbstractVariable","text":"AbstractVariable\n\nVariable returned by build_variable. It represents a variable that has not been added yet to any model. It can be added to a given model with add_variable.\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.AbstractVariableRef","page":"Variables","title":"JuMP.AbstractVariableRef","text":"AbstractVariableRef\n\nVariable returned by add_variable. Affine (resp. quadratic) operations with variables of type V<:AbstractVariableRef and coefficients of type T     create a GenericAffExpr{T,V} (resp. GenericQuadExpr{T,V}).\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.parse_one_operator_variable","page":"Variables","title":"JuMP.parse_one_operator_variable","text":"parse_one_operator_variable(_error::Function, infoexpr::_VariableInfoExpr, sense::Val{S}, value) where S\n\nUpdate infoexr for a variable expression in the @variable macro of the form variable name S value.\n\n\n\n\n\n","category":"function"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"The most significant part of MOI is the definition of the model API that is used to specify an instance of an optimization problem (e.g., by adding variables and constraints). Objects that implement the model API should inherit from the ModelLike abstract type.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"Notably missing from the model API is the method to solve an optimization problem. ModelLike objects may store an instance (e.g., in memory or backed by a file format) without being linked to a particular solver. In addition to the model API, MOI defines AbstractOptimizer.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"Optimizers (or solvers) implement the model API (inheriting from ModelLike) and additionally provide methods to solve the model.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"info: Info\nThroughout the rest of the manual, model is used as a generic ModelLike, and optimizer is used as a generic AbstractOptimizer.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"tip: Tip\nMOI does not export functions, but for brevity we often omit qualifying names with the MOI module. Best practice is to haveusing MathOptInterface\nconst MOI = MathOptInterfaceand prefix all MOI methods with MOI. in user code. If a name is also available in base Julia, we always explicitly use the module prefix, for example, with MOI.get.","category":"page"},{"location":"moi/manual/models/#Attributes","page":"Models","title":"Attributes","text":"","category":"section"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"Attributes can be set in different ways:","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"it is either set when the model is created like SolverName and RawSolver,\nor explicitly when the model is copied like ObjectiveSense,\nor implicitly, e.g., NumberOfVariables is implicitly set by add_variable and ConstraintFunction is implicitly set by add_constraint.\nor it is set to contain the result of the optimization during optimize! like VariablePrimal.","category":"page"},{"location":"reference/models/#ModelAPI","page":"Models","title":"Models","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"More information can be found in the Models section of the manual.","category":"page"},{"location":"reference/models/#Constructors","page":"Models","title":"Constructors","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"Model\ndirect_model","category":"page"},{"location":"reference/models/#JuMP.Model","page":"Models","title":"JuMP.Model","text":"Model\n\nA mathematical model of an optimization problem.\n\n\n\n\n\n","category":"type"},{"location":"reference/models/#JuMP.direct_model","page":"Models","title":"JuMP.direct_model","text":"direct_model(backend::MOI.ModelLike)\n\nReturn a new JuMP model using backend to store the model and solve it.\n\nAs opposed to the Model constructor, no cache of the model is stored outside of backend and no bridges are automatically applied to backend.\n\nNotes\n\nThe absence of a cache reduces the memory footprint but, it is important to bear in mind the following implications of creating models using this direct mode:\n\nWhen backend does not support an operation, such as modifying constraints or adding variables/constraints after solving, an error is thrown. For models created using the Model constructor, such situations can be dealt with by storing the modifications in a cache and loading them into the optimizer when optimize! is called.\nNo constraint bridging is supported by default.\nThe optimizer used cannot be changed the model is constructed.\nThe model created cannot be copied.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Enums","page":"Models","title":"Enums","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"ModelMode\nAUTOMATIC\nMANUAL\nDIRECT","category":"page"},{"location":"reference/models/#JuMP.ModelMode","page":"Models","title":"JuMP.ModelMode","text":"ModelMode\n\nAn enum to describe the state of the CachingOptimizer inside a JuMP model.\n\n\n\n\n\n","category":"type"},{"location":"reference/models/#JuMP.AUTOMATIC","page":"Models","title":"JuMP.AUTOMATIC","text":"moi_backend field holds a CachingOptimizer in AUTOMATIC mode.\n\n\n\n\n\n","category":"constant"},{"location":"reference/models/#JuMP.MANUAL","page":"Models","title":"JuMP.MANUAL","text":"moi_backend field holds a CachingOptimizer in MANUAL mode.\n\n\n\n\n\n","category":"constant"},{"location":"reference/models/#JuMP.DIRECT","page":"Models","title":"JuMP.DIRECT","text":"moi_backend field holds an AbstractOptimizer. No extra copy of the model is stored. The moi_backend must support add_constraint etc.\n\n\n\n\n\n","category":"constant"},{"location":"reference/models/#Basic-functions","page":"Models","title":"Basic functions","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"backend\nsolver_name\nBase.empty!(::Model)\nmode\nobject_dictionary\nunregister\nlatex_formulation","category":"page"},{"location":"reference/models/#JuMP.backend","page":"Models","title":"JuMP.backend","text":"backend(model::Model)\n\nReturn the lower-level MathOptInterface model that sits underneath JuMP. This model depends on which operating mode JuMP is in (see mode), and whether there are any bridges in the model.\n\nIf JuMP is in DIRECT mode (i.e., the model was created using direct_model), the backend will be the optimizer passed to direct_model.\n\nIf JuMP is in MANUAL or AUTOMATIC mode, the backend is a MOI.Utilities.CachingOptimizer.\n\nThis function should only be used by advanced users looking to access low-level MathOptInterface or solver-specific functionality.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.solver_name","page":"Models","title":"JuMP.solver_name","text":"solver_name(model::Model)\n\nIf available, returns the SolverName property of the underlying optimizer.\n\nReturns \"No optimizer attached\" in AUTOMATIC or MANUAL modes when no optimizer is attached.\n\nReturns \"SolverName() attribute not implemented by the optimizer.\" if the attribute is not implemented.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Base.empty!-Tuple{Model}","page":"Models","title":"Base.empty!","text":"empty!(model::Model)::Model\n\nEmpty the model, that is, remove all variables, constraints and model attributes but not optimizer attributes. Always return the argument.\n\nNote: removes extensions data.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#JuMP.mode","page":"Models","title":"JuMP.mode","text":"mode(model::Model)\n\nReturn the ModelMode (DIRECT, AUTOMATIC, or MANUAL) of model.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.object_dictionary","page":"Models","title":"JuMP.object_dictionary","text":"object_dictionary(model::Model)\n\nReturn the dictionary that maps the symbol name of a variable, constraint, or expression to the corresponding object.\n\nObjects are registered to a specific symbol in the macros. For example, @variable(model, x[1:2, 1:2]) registers the array of variables x to the symbol :x.\n\nThis method should be defined for any subtype of AbstractModel.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.unregister","page":"Models","title":"JuMP.unregister","text":"unregister(model::Model, key::Symbol)\n\nUnregister the name key from model so that a new variable, constraint, or expression can be created with the same key.\n\nNote that this will not delete the object model[key]; it will just remove the reference at model[key]. To delete the object, use\n\ndelete(model, model[key])\nunregister(model, key)\n\nSee also: object_dictionary.\n\nExamples\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, x)\nERROR: An object of name x is already attached to this model. If\nthis is intended, consider using the anonymous construction syntax,\ne.g., `x = @variable(model, [1:N], ...)` where the name of the object\ndoes not appear inside the macro.\n\nAlternatively, use `unregister(model, :x)` to first unregister the\nexisting name from the model. Note that this will not delete the object;\nit will just remove the reference at `model[:x]`.\n[...]\n\njulia> num_variables(model)\n1\n\njulia> unregister(model, :x)\n\njulia> @variable(model, x)\nx\n\njulia> num_variables(model)\n2\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.latex_formulation","page":"Models","title":"JuMP.latex_formulation","text":"latex_formulation(model::AbstractModel)\n\nWrap model in a type so that it can be pretty-printed as text/latex in a notebook like IJulia, or in Documenter.\n\nTo render the model, end the cell with latex_formulation(model), or call display(latex_formulation(model)) in to force the display of the model from inside a function.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Working-with-attributes","page":"Models","title":"Working with attributes","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"set_optimizer\noptimizer_with_attributes\nget_optimizer_attribute\nset_optimizer_attribute\nset_optimizer_attributes\nset_silent\nunset_silent\nset_time_limit_sec\nunset_time_limit_sec\ntime_limit_sec","category":"page"},{"location":"reference/models/#JuMP.set_optimizer","page":"Models","title":"JuMP.set_optimizer","text":"set_optimizer(model::Model, optimizer_factory;\n              bridge_constraints::Bool=true)\n\nCreates an empty MathOptInterface.AbstractOptimizer instance by calling optimizer_factory() and sets it as the optimizer of model. Specifically, optimizer_factory must be callable with zero arguments and return an empty MathOptInterface.AbstractOptimizer.\n\nIf bridge_constraints is true, constraints that are not supported by the optimizer are automatically bridged to equivalent supported constraints when an appropriate transformation is defined in the MathOptInterface.Bridges module or is defined in another module and is explicitly added.\n\nSee set_optimizer_attributes and set_optimizer_attribute for setting solver-specific parameters of the optimizer.\n\nExamples\n\nmodel = Model()\nset_optimizer(model, GLPK.Optimizer)\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.optimizer_with_attributes","page":"Models","title":"JuMP.optimizer_with_attributes","text":"optimizer_with_attributes(optimizer_constructor, attrs::Pair...)\n\nGroups an optimizer constructor with the list of attributes attrs. Note that it is equivalent to MOI.OptimizerWithAttributes.\n\nWhen provided to the Model constructor or to set_optimizer, it creates an optimizer by calling optimizer_constructor(), and then sets the attributes using set_optimizer_attribute.\n\nExample\n\nmodel = Model(\n    optimizer_with_attributes(\n        Gurobi.Optimizer, \"Presolve\" => 0, \"OutputFlag\" => 1\n    )\n)\n\nis equivalent to:\n\nmodel = Model(Gurobi.Optimizer)\nset_optimizer_attribute(model, \"Presolve\", 0)\nset_optimizer_attribute(model, \"OutputFlag\", 1)\n\nNote\n\nThe string names of the attributes are specific to each solver. One should consult the solver's documentation to find the attributes of interest.\n\nSee also: set_optimizer_attribute, set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.get_optimizer_attribute","page":"Models","title":"JuMP.get_optimizer_attribute","text":"get_optimizer_attribute(model, name::String)\n\nReturn the value associated with the solver-specific attribute named name.\n\nNote that this is equivalent to get_optimizer_attribute(model, MOI.RawParameter(name)).\n\nExample\n\nget_optimizer_attribute(model, \"SolverSpecificAttributeName\")\n\nSee also: set_optimizer_attribute, set_optimizer_attributes.\n\n\n\n\n\nget_optimizer_attribute(\n    model::Model, attr::MOI.AbstractOptimizerAttribute\n)\n\nReturn the value of the solver-specific attribute attr in model.\n\nExample\n\nget_optimizer_attribute(model, MOI.Silent())\n\nSee also: set_optimizer_attribute, set_optimizer_attributes.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.set_optimizer_attribute","page":"Models","title":"JuMP.set_optimizer_attribute","text":"set_optimizer_attribute(model::Model, name::String, value)\n\nSets solver-specific attribute identified by name to value.\n\nNote that this is equivalent to set_optimizer_attribute(model, MOI.RawParameter(name), value).\n\nExample\n\nset_optimizer_attribute(model, \"SolverSpecificAttributeName\", true)\n\nSee also: set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\nset_optimizer_attribute(\n    model::Model, attr::MOI.AbstractOptimizerAttribute, value\n)\n\nSet the solver-specific attribute attr in model to value.\n\nExample\n\nset_optimizer_attribute(model, MOI.Silent(), true)\n\nSee also: set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.set_optimizer_attributes","page":"Models","title":"JuMP.set_optimizer_attributes","text":"set_optimizer_attributes(model::Model, pairs::Pair...)\n\nGiven a list of attribute => value pairs, calls set_optimizer_attribute(model, attribute, value) for each pair.\n\nExample\n\nmodel = Model(Ipopt.Optimizer)\nset_optimizer_attributes(model, \"tol\" => 1e-4, \"max_iter\" => 100)\n\nis equivalent to:\n\nmodel = Model(Ipopt.Optimizer)\nset_optimizer_attribute(model, \"tol\", 1e-4)\nset_optimizer_attribute(model, \"max_iter\", 100)\n\nSee also: set_optimizer_attribute, get_optimizer_attribute.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.set_silent","page":"Models","title":"JuMP.set_silent","text":"set_silent(model::Model)\n\nTakes precedence over any other attribute controlling verbosity and requires the solver to produce no output.\n\nSee also: unset_silent.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.unset_silent","page":"Models","title":"JuMP.unset_silent","text":"unset_silent(model::Model)\n\nNeutralize the effect of the set_silent function and let the solver attributes control the verbosity.\n\nSee also: set_silent.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.set_time_limit_sec","page":"Models","title":"JuMP.set_time_limit_sec","text":"set_time_limit_sec(model::Model, limit)\n\nSet the time limit (in seconds) of the solver.\n\nCan be unset using unset_time_limit_sec or with limit set to nothing.\n\nSee also: unset_time_limit_sec, time_limit_sec.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.unset_time_limit_sec","page":"Models","title":"JuMP.unset_time_limit_sec","text":"unset_time_limit_sec(model::Model)\n\nUnset the time limit of the solver.\n\nSee also: set_time_limit_sec, time_limit_sec.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.time_limit_sec","page":"Models","title":"JuMP.time_limit_sec","text":"time_limit_sec(model::Model)\n\nReturn the time limit (in seconds) of the model.\n\nReturns nothing if unset.\n\nSee also: set_time_limit_sec, unset_time_limit_sec.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Copying","page":"Models","title":"Copying","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"ReferenceMap\ncopy_model\ncopy_extension_data\nBase.copy(::AbstractModel)","category":"page"},{"location":"reference/models/#JuMP.ReferenceMap","page":"Models","title":"JuMP.ReferenceMap","text":"ReferenceMap\n\nMapping between variable and constraint reference of a model and its copy. The reference of the copied model can be obtained by indexing the map with the reference of the corresponding reference of the original model.\n\n\n\n\n\n","category":"type"},{"location":"reference/models/#JuMP.copy_model","page":"Models","title":"JuMP.copy_model","text":"copy_model(model::Model; filter_constraints::Union{Nothing, Function}=nothing)\n\nReturn a copy of the model model and a ReferenceMap that can be used to obtain the variable and constraint reference of the new model corresponding to a given model's reference. A Base.copy(::AbstractModel) method has also been implemented, it is similar to copy_model but does not return the reference map.\n\nIf the filter_constraints argument is given, only the constraints for which this function returns true will be copied. This function is given a constraint reference as argument.\n\nNote\n\nModel copy is not supported in DIRECT mode, i.e. when a model is constructed using the direct_model constructor instead of the Model constructor. Moreover, independently on whether an optimizer was provided at model construction, the new model will have no optimizer, i.e., an optimizer will have to be provided to the new model in the optimize! call.\n\nExamples\n\nIn the following example, a model model is constructed with a variable x and a constraint cref. It is then copied into a model new_model with the new references assigned to x_new and cref_new.\n\nmodel = Model()\n@variable(model, x)\n@constraint(model, cref, x == 2)\n\nnew_model, reference_map = copy_model(model)\nx_new = reference_map[x]\ncref_new = reference_map[cref]\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.copy_extension_data","page":"Models","title":"JuMP.copy_extension_data","text":"copy_extension_data(data, new_model::AbstractModel, model::AbstractModel)\n\nReturn a copy of the extension data data of the model model to the extension data of the new model new_model. A method should be added for any JuMP extension storing data in the ext field.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Base.copy-Tuple{AbstractModel}","page":"Models","title":"Base.copy","text":"copy(model::AbstractModel)\n\nReturn a copy of the model model. It is similar to copy_model except that it does not return the mapping between the references of model and its copy.\n\nNote\n\nModel copy is not supported in DIRECT mode, i.e. when a model is constructed using the direct_model constructor instead of the Model constructor. Moreover, independently on whether an optimizer was provided at model construction, the new model will have no optimizer, i.e., an optimizer will have to be provided to the new model in the optimize! call.\n\nExamples\n\nIn the following example, a model model is constructed with a variable x and a constraint cref. It is then copied into a model new_model with the new references assigned to x_new and cref_new.\n\nmodel = Model()\n@variable(model, x)\n@constraint(model, cref, x == 2)\n\nnew_model = copy(model)\nx_new = model[:x]\ncref_new = model[:cref]\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#I/O","page":"Models","title":"I/O","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"write_to_file\nBase.write(::IO, ::Model; ::MOI.FileFormats.FileFormat)\nread_from_file\nBase.read(::IO, ::Type{Model}; ::MOI.FileFormats.FileFormat)","category":"page"},{"location":"reference/models/#JuMP.write_to_file","page":"Models","title":"JuMP.write_to_file","text":"write_to_file(\n    model::Model,\n    filename::String;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_AUTOMATIC\n)\n\nWrite the JuMP model model to filename in the format format.\n\nIf the filename ends in .gz, it will be compressed using Gzip. If the filename ends in .bz2, it will be compressed using BZip2.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Base.write-Tuple{IO,Model}","page":"Models","title":"Base.write","text":"Base.write(\n    io::IO,\n    model::Model;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_MOF\n)\n\nWrite the JuMP model model to io in the format format.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#JuMP.read_from_file","page":"Models","title":"JuMP.read_from_file","text":"read_from_file(\n    filename::String;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_AUTOMATIC\n)\n\nReturn a JuMP model read from filename in the format format.\n\nIf the filename ends in .gz, it will be uncompressed using Gzip. If the filename ends in .bz2, it will be uncompressed using BZip2.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Base.read-Tuple{IO,Type{Model}}","page":"Models","title":"Base.read","text":"Base.read(io::IO, ::Type{Model}; format::MOI.FileFormats.FileFormat)\n\nReturn a JuMP model read from io in the format format.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#Caching-Optimizer","page":"Models","title":"Caching Optimizer","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"MOIU.reset_optimizer(::JuMP.Model)\nMOIU.drop_optimizer(::JuMP.Model)\nMOIU.attach_optimizer(::JuMP.Model)","category":"page"},{"location":"reference/models/#MathOptInterface.Utilities.reset_optimizer-Tuple{Model}","page":"Models","title":"MathOptInterface.Utilities.reset_optimizer","text":"MOIU.reset_optimizer(model::Model)\n\nCall MOIU.reset_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#MathOptInterface.Utilities.drop_optimizer-Tuple{Model}","page":"Models","title":"MathOptInterface.Utilities.drop_optimizer","text":"MOIU.drop_optimizer(model::Model)\n\nCall MOIU.drop_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#MathOptInterface.Utilities.attach_optimizer-Tuple{Model}","page":"Models","title":"MathOptInterface.Utilities.attach_optimizer","text":"MOIU.attach_optimizer(model::Model)\n\nCall MOIU.attach_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#Bridge-tools","page":"Models","title":"Bridge tools","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"bridge_constraints\nprint_bridge_graph","category":"page"},{"location":"reference/models/#JuMP.bridge_constraints","page":"Models","title":"JuMP.bridge_constraints","text":"bridge_constraints(model::Model)\n\nWhen in direct mode, return false. When in manual or automatic mode, return a Bool indicating whether the optimizer is set and unsupported constraints are automatically bridged to equivalent supported constraints when an appropriate transformation is available.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.print_bridge_graph","page":"Models","title":"JuMP.print_bridge_graph","text":" print_bridge_graph([io::IO,] model::Model)\n\nPrint the hyper-graph containing all variable, constraint, and objective types that could be obtained by bridging the variables, constraints, and objectives that are present in the model.\n\nEach node in the hyper-graph corresponds to a variable, constraint, or objective type.\n\nVariable nodes are indicated by [ ]\nConstraint nodes are indicated by ( )\nObjective nodes are indicated by | |\n\nThe number inside each pair of brackets is an index of the node in the hyper-graph.\n\nNote that this hyper-graph is the full list of possible transformations. When the bridged model is created, we select the shortest hyper-path(s) from this graph, so many nodes may be un-used.\n\nFor more information, see Legat, B., Dowson, O., Garcia, J., and Lubin, M. (2020).  \"MathOptInterface: a data structure for mathematical optimization problems.\" URL: https://arxiv.org/abs/2002.03447\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Extension-tools","page":"Models","title":"Extension tools","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"operator_warn\nerror_if_direct_mode","category":"page"},{"location":"reference/models/#JuMP.operator_warn","page":"Models","title":"JuMP.operator_warn","text":"operator_warn(model::AbstractModel)\noperator_warn(model::Model)\n\nThis function is called on the model whenever two affine expressions are added together without using destructive_add!, and at least one of the two expressions has more than 50 terms.\n\nFor the case of Model, if this function is called more than 20,000 times then a warning is generated once.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.error_if_direct_mode","page":"Models","title":"JuMP.error_if_direct_mode","text":"error_if_direct_mode(model::Model, func::Symbol)\n\nErrors if model is in direct mode during a call from the function named func.\n\nUsed internally within JuMP, or by JuMP extensions who do not want to support models in direct mode.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/cutting_stock_column_generation.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/#Cutting-stock","page":"Cutting stock","title":"Cutting stock","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"This example solves the cutting stock problem (sometimes also called the cutting rod problem) using a column-generation technique. It is based on https://doi.org/10.5281/zenodo.3329388.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"Intuitively, this problem is about cutting large rolls of paper into smaller pieces. There is an exact demand of pieces to meet, and all rolls have the same size. The goal is to meet the demand while maximizing the profits (each paper roll has a fixed cost, each sold piece allows earning some money), which is roughly equivalent to using the smallest amount of rolls to cut (or, equivalently, to minimize the amount of paper waste).","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"This function takes five parameters:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"maxwidth: the maximum width of a roll (or length of a rod)\nwidths: an array of the requested widths\nrollcost: the cost of a complete roll\ndemand: the demand, in number of pieces, for each width\nprices: the selling price for each width","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"Mathematically, this problem might be formulated with two variables:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"x[i, j] ‚àà ‚Ñï: the number of times the width i is cut out of the roll j\ny[j] ‚àà ùîπ: whether the roll j is used","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"Several constraints are needed:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"the demand must be satisfied, for each width i: ‚àëj x[i, j] = demand[i]\nthe roll size cannot be exceed, for each roll j that is used: ‚àëi x[i, j] width[i] ‚â§ maxwidth y[j]","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"If you want to implement this na√Øve model, you will need an upper bound on the number of rolls to use: the simplest one is to consider that each required width is cut from its own roll, i.e. j varies from 1 to ‚àëi demand[i].","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"This example prefers a more advanced technique to solve this problem: column generation.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"It considers a different set of variables: patterns of width to cut a roll. The decisions then become the number of times each pattern is used (i.e. the number of rolls that are cut following this pattern).","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"The intelligence comes from the way these patterns are chosen: not all of them are considered, but only the \"interesting\" ones, within the master problem.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"A \"pricing\" problem is used to decide whether a new pattern should be generated or not (it is implemented in the function solve_pricing). \"Interesting\" means, for a pattern, that the optimal solution may use this cutting pattern.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"In more detail, the solving process is the following. First, a series of dumb patterns are generated (just one width per roll, repeated until the roll is completely cut). Then, the master problem is solved with these first patterns and its dual solution is passed on to the pricing problem. The latter decides if there is a new pattern to include in the formulation or not; if so, it returns it to the master problem. The master is solved again, the new dual variables are given to the pricing problem, until there is no more pattern to generate from the pricing problem: all \"interesting\" patterns have been generated, and the master can take its optimal decision.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"In the implementation, the variables deciding how many times a pattern is chosen are called Œ∏.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"For more information on column-generation techniques applied on the cutting stock problem, you can see:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"Integer programming column generation strategies for the cutting stock problem and its variants\nTackling the cutting stock problem","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"This example uses the following packages:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"using JuMP\nimport GLPK\nimport SparseArrays","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"The function solve_pricing implements the pricing problem for the function example_cutting_stock.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"It takes, as input, the dual solution from the master problem and the cutting stock instance.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"It outputs either a new cutting pattern, or nothing if no pattern could improve the current cost.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"function solve_pricing(\n    dual_demand_satisfaction, maxwidth, widths, rollcost, demand, prices\n)\n    reduced_costs = dual_demand_satisfaction + prices\n    n = length(reduced_costs)\n    # The actual pricing model.\n    submodel = Model(GLPK.Optimizer)\n    set_silent(submodel)\n    @variable(submodel, xs[1:n] >= 0, Int)\n    @constraint(submodel, sum(xs .* widths) <= maxwidth)\n    @objective(submodel, Max, sum(xs .* reduced_costs))\n    optimize!(submodel)\n    new_pattern = round.(Int, value.(xs))\n    net_cost = rollcost - sum(new_pattern .* (dual_demand_satisfaction .+ prices))\n    # If the net cost of this new pattern is nonnegative, no more patterns to add.\n    return net_cost >= 0 ? nothing : new_pattern\nend\n\nfunction example_cutting_stock(; max_gen_cols::Int = 5_000)\n    maxwidth = 100.0\n    rollcost = 500.0\n    prices = [\n        167.0, 197.0, 281.0, 212.0, 225.0, 111.0, 93.0, 129.0, 108.0, 106.0,\n        55.0, 85.0, 66.0, 44.0, 47.0, 15.0, 24.0, 13.0, 16.0, 14.0,\n    ]\n    widths = [\n        75.0, 75.0, 75.0, 75.0, 75.0, 53.8, 53.0, 51.0, 50.2, 32.2,\n        30.8, 29.8, 20.1, 16.2, 14.5, 11.0, 8.6, 8.2, 6.6, 5.1,\n    ]\n    demand = [\n        38, 44, 30, 41, 36, 33, 36, 41, 35, 37,\n        44, 49, 37, 36, 42, 33, 47, 35, 49, 42,\n    ]\n    nwidths = length(prices)\n    n = length(widths)\n    ncols = length(widths)\n    # Initial set of patterns (stored in a sparse matrix: a pattern won't\n    # include many different cuts).\n    patterns = SparseArrays.spzeros(UInt16, n, ncols)\n    for i = 1:n\n        patterns[i, i] = min(\n            floor(Int, maxwidth / widths[i]), round(Int, demand[i])\n        )\n    end\n    # Write the master problem with this \"reduced\" set of patterns.\n    # Not yet integer variables: otherwise, the dual values may make no sense\n    # (actually, GLPK will yell at you if you're trying to get duals for\n    # integer problems).\n    m = Model(GLPK.Optimizer)\n    set_silent(m)\n    @variable(m, Œ∏[1:ncols] >= 0)\n    @objective(\n        m,\n        Min,\n        sum(\n            Œ∏[p] * (rollcost - sum(patterns[j, p] * prices[j] for j = 1:n))\n            for p = 1:ncols\n        )\n    )\n    @constraint(\n        m,\n        demand_satisfaction[j=1:n],\n        sum(patterns[j, p] * Œ∏[p] for p = 1:ncols) >= demand[j]\n    )\n    # First solve of the master problem.\n    optimize!(m)\n    if termination_status(m) != MOI.OPTIMAL\n        warn(\"Master not optimal ($ncols patterns so far)\")\n    end\n    # Then, generate new patterns, based on the dual information.\n    while ncols - n <= max_gen_cols ## Generate at most max_gen_cols columns.\n        if ! has_duals(m)\n            break\n        end\n        new_pattern = solve_pricing(\n            dual.(demand_satisfaction),\n            maxwidth,\n            widths,\n            rollcost,\n            demand,\n            prices,\n        )\n        # No new pattern to add to the formulation: done!\n        if new_pattern === nothing\n            break\n        end\n        # Otherwise, add the new pattern to the master problem, recompute the\n        # duals, and go on waltzing one more time with the pricing problem.\n        ncols += 1\n        patterns = hcat(patterns, new_pattern)\n        # One new variable.\n        new_var = @variable(m, [ncols], base_name = \"Œ∏\", lower_bound = 0)\n        push!(Œ∏, new_var[ncols])\n        # Update the objective function.\n        set_objective_coefficient(\n            m,\n            Œ∏[ncols],\n            rollcost - sum(patterns[j, ncols] * prices[j] for j = 1:n)\n        )\n        # Update the constraint number j if the new pattern impacts this production.\n        for j = 1:n\n            if new_pattern[j] > 0\n                set_normalized_coefficient(\n                    demand_satisfaction[j], new_var[ncols], new_pattern[j]\n                )\n            end\n        end\n        # Solve the new master problem to update the dual variables.\n        optimize!(m)\n        if termination_status(m) != MOI.OPTIMAL\n            @warn(\"Master not optimal ($ncols patterns so far)\")\n        end\n    end\n    # Finally, impose the master variables to be integer and resolve.\n    # To be exact, at each node in the branch-and-bound tree, we would need to\n    # restart the column generation process (just in case a new column would be\n    # interesting to add). This way, we only get an upper bound (a feasible\n    # solution).\n    set_integer.(Œ∏)\n    optimize!(m)\n    if termination_status(m) != MOI.OPTIMAL\n        @warn(\"Final master not optimal ($ncols patterns)\")\n        return\n    end\n    println(\"Final solution:\")\n    for i = 1:length(Œ∏)\n        if value(Œ∏[i]) > 0.5\n            println(\"$(round(Int, value(Œ∏[i]))) units of pattern $(i)\")\n        end\n    end\n    return\nend\n\nexample_cutting_stock()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"This page was generated using Literate.jl.","category":"page"},{"location":"moi/reference/modification/","page":"Modifications","title":"Modifications","text":"info: Info\nThis documentation is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.9.21. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/reference/modification/","page":"Modifications","title":"Modifications","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/modification/#Modifications","page":"Modifications","title":"Modifications","text":"","category":"section"},{"location":"moi/reference/modification/","page":"Modifications","title":"Modifications","text":"modify\nAbstractFunctionModification\nScalarConstantChange\nVectorConstantChange\nScalarCoefficientChange\nMultirowChange","category":"page"},{"location":"moi/reference/modification/#MathOptInterface.modify","page":"Modifications","title":"MathOptInterface.modify","text":"Constraint Function\n\nmodify(model::ModelLike, ci::ConstraintIndex, change::AbstractFunctionModification)\n\nApply the modification specified by change to the function of constraint ci.\n\nAn ModifyConstraintNotAllowed error is thrown if modifying constraints is not supported by the model model.\n\nExamples\n\nmodify(model, ci, ScalarConstantChange(10.0))\n\nObjective Function\n\nmodify(model::ModelLike, ::ObjectiveFunction, change::AbstractFunctionModification)\n\nApply the modification specified by change to the objective function of model. To change the function completely, call set instead.\n\nAn ModifyObjectiveNotAllowed error is thrown if modifying objectives is not supported by the model model.\n\nExamples\n\nmodify(model, ObjectiveFunction{ScalarAffineFunction{Float64}}(), ScalarConstantChange(10.0))\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/modification/#MathOptInterface.AbstractFunctionModification","page":"Modifications","title":"MathOptInterface.AbstractFunctionModification","text":"AbstractFunctionModification\n\nAn abstract supertype for structs which specify partial modifications to functions, to be used for making small modifications instead of replacing the functions entirely.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/modification/#MathOptInterface.ScalarConstantChange","page":"Modifications","title":"MathOptInterface.ScalarConstantChange","text":"ScalarConstantChange{T}(new_constant::T)\n\nA struct used to request a change in the constant term of a scalar-valued function. Applicable to ScalarAffineFunction and ScalarQuadraticFunction.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/modification/#MathOptInterface.VectorConstantChange","page":"Modifications","title":"MathOptInterface.VectorConstantChange","text":"VectorConstantChange{T}(new_constant::Vector{T})\n\nA struct used to request a change in the constant vector of a vector-valued function. Applicable to VectorAffineFunction and VectorQuadraticFunction.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/modification/#MathOptInterface.ScalarCoefficientChange","page":"Modifications","title":"MathOptInterface.ScalarCoefficientChange","text":"ScalarCoefficientChange{T}(variable::VariableIndex, new_coefficient::T)\n\nA struct used to request a change in the linear coefficient of a single variable in a scalar-valued function. Applicable to ScalarAffineFunction and ScalarQuadraticFunction.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/modification/#MathOptInterface.MultirowChange","page":"Modifications","title":"MathOptInterface.MultirowChange","text":"MultirowChange{T}(variable::VariableIndex, new_coefficients::Vector{Tuple{Int64, T}})\n\nA struct used to request a change in the linear coefficients of a single variable in a vector-valued function. New coefficients are specified by (output_index, coefficient) tuples. Applicable to VectorAffineFunction and VectorQuadraticFunction.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Conic programs/tips_and_tricks.jl\"","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Tips-and-Tricks","page":"Tips and Tricks","title":"Tips and Tricks","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"This tutorial is aimed at providing a simplistic introduction to conic programming using JuMP.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"It uses the following packages:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"using JuMP\nimport SCS\nimport LinearAlgebra\n\nimport Random      # hide\nRandom.seed!(1234) # hide\nnothing            # hide","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"tip: Tip\nA good resource for learning more about functions which can be modeled using cones is the MOSEK Modeling Cookbook.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#What-is-a-cone?","page":"Tips and Tricks","title":"What is a cone?","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A subset C of a vector space V is a cone if forall x in C and positive scalars lambda  0, the product lambda x in C.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A cone C is a convex cone if lambda x + (1 - lambda) y in C, for any lambda in 0 1, and any x y in C.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#What-is-a-conic-program?","page":"Tips and Tricks","title":"What is a conic program?","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Conic programming problems are convex optimization problems in which a convex function is minimized over the intersection of an affine subspace and a convex cone. An example of a conic-form minimization problems, in the primal form is:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\n min_x in mathbbR^n  a_0^T x + b_0 \n textst  A_i x + b_i  in mathcalC_i  i = 1 ldots m\nendaligned","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The corresponding dual problem is:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\n max_y_1 ldots y_m  -sum_i=1^m b_i^T y_i + b_0 \n textst  a_0 - sum_i=1^m A_i^T y_i  = 0 \n  y_i  in mathcalC_i^*  i = 1 ldots m\nendaligned","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"where each mathcalC_i is a closed convex cone and mathcalC_i^* is its dual cone.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Second-Order-Cone","page":"Tips and Tricks","title":"Second-Order Cone","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The Second-Order Cone (or Lorentz Cone) of dimension n is of the form:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Q^n =  (t x) in mathbbR^n  t ge x_2 ","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Example","page":"Tips and Tricks","title":"Example","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Minimize the L2 norm of a vector x.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"model = Model()\n@variable(model, x[1:3])\n@variable(model, norm_x)\n@constraint(model, [norm_x; x] in SecondOrderCone())\n@objective(model, Min, norm_x)","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Rotated-Second-Order-Cone","page":"Tips and Tricks","title":"Rotated Second-Order Cone","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A Second-Order Cone rotated by pi4 in the (x_1x_2) plane is called a Rotated Second-Order Cone. It is of the form:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Q_r^n =  (tux) in mathbbR^n  2tu ge x_2^2 tu ge 0 ","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Example-2","page":"Tips and Tricks","title":"Example","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Given a set of predictors x, and observations y, find the parameter theta that minimizes the sum of squares loss between y_i and theta x_i.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"x = [1.0, 2.0, 3.0, 4.0]\ny = [0.45, 1.04, 1.51, 1.97]\nmodel = Model()\n@variable(model, Œ∏)\n@variable(model, loss)\n@constraint(model, [loss; 0.5; Œ∏ .* x .- y] in RotatedSecondOrderCone())\n@objective(model, Min, loss)","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Exponential-Cone","page":"Tips and Tricks","title":"Exponential Cone","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"An Exponential Cone is a set of the form:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"K_exp =  (xyz) in mathbbR^3  y exp (xy) le z y  0 ","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"model = Model()\n@variable(model, x[1:3] >= 0)\n@constraint(model, x in MOI.ExponentialCone())\n@objective(model, Min, x[3])","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Example:-Entropy-Maximization","page":"Tips and Tricks","title":"Example: Entropy Maximization","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The entropy maximization problem consists of maximizing the entropy function, H(x) = -xlogx subject to linear inequality constraints.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\n max  - sum_i=1^n x_i log x_i \n textst  mathbf1 x = 1 \n  Ax leq b\nendaligned","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"We can model this problem using an exponential cone by using the following transformation:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"tleq -xlogx iff tleq xlog(1x)  iff (t x 1) in K_exp","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Thus, our problem becomes,","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\n max  1^Tt \n textst  Ax leq b \n  1^T x = 1 \n  (t_i x_i 1) in K_exp  forall i = 1 ldots n \nendaligned","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"n = 15\nm = 10\nA = randn(m, n)\nb = rand(m, 1)\n\nmodel = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, t[1:n])\n@variable(model, x[1:n])\n@objective(model, Max, sum(t))\n@constraint(model, sum(x) == 1)\n@constraint(model, A * x .<= b)\n@constraint(model, con[i = 1:n], [t[i], x[i], 1] in MOI.ExponentialCone())\noptimize!(model)","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"objective_value(model)","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Positive-Semidefinite-Cone","page":"Tips and Tricks","title":"Positive Semidefinite Cone","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The set of positive semidefinite matrices (PSD) of dimension n form a cone in mathbbR^n. We write this set mathematically as:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"mathcalS_+^n =  X in mathcalS^n mid z^T X z geq 0  forall zin mathbbR^n ","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A PSD cone is represented in JuMP using the MOI sets PositiveSemidefiniteConeTriangle (for upper triangle of a PSD matrix) and PositiveSemidefiniteConeSquare (for a complete PSD matrix). However, it is preferable to use the PSDCone shortcut as illustrated below.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Example:-largest-eigenvalue-of-a-symmetric-matrix","page":"Tips and Tricks","title":"Example: largest eigenvalue of a symmetric matrix","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Suppose A has eigenvalues lambda_1 geq lambda_2 ldots geq lambda_n. Then the matrix t I-A has eigenvalues t-lambda_1 t-lambda_2 ldots t-lambda_n. Note that t I-A is PSD exactly when all these eigenvalues are non-negative, and this happens for values t geq lambda_1. Thus, we can model the problem of finding the largest eigenvalue of a symmetric matrix as:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\nlambda_1 = min t \ntext  st  t I-A succeq 0\nendaligned","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A = [3 2 4; 2 0 2; 4 2 3]\nI = Matrix{Float64}(LinearAlgebra.I, 3, 3)\nmodel = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, t)\n@objective(model, Min, t)\n@constraint(model, t .* I - A in PSDCone())\n\noptimize!(model)","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"objective_value(model)","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Other-Cones-and-Functions","page":"Tips and Tricks","title":"Other Cones and Functions","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"For other cones supported by JuMP, check out the MathOptInterface Manual.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"View this file on Github.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"DocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"manual/containers/#Containers","page":"Containers","title":"Containers","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"JuMP provides specialized containers similar to AxisArrays that enable multi-dimensional arrays with non-integer indices.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"These containers are created automatically by JuMP's macros. Each macro has the same basic syntax:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"@macroname(model, name[key1=index1, index2; optional_condition], other stuff)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"The containers are generated by the name[key1=index1, index2; optional_condition] syntax. Everything else is specific to the particular macro.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Containers can be named, e.g., name[key=index], or unnamed, e.g., [key=index]. We call unnamed containers anonymous.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"We call the bits inside the square brackets and before the ; the index sets. The index sets can be named, e.g., [i = 1:4], or they can be unnamed, e.g., [1:4].","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"We call the bit inside the square brackets and after the ; the condition. Conditions are optional.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"In addition to the standard JuMP macros like @variable and @constraint, which construct containers of variables and constraints respectively, you can use Containers.@container to construct containers with arbitrary elements.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"We will use this macro to explain the three types of containers that are natively supported by JuMP: Array, Containers.DenseAxisArray, and Containers.SparseAxisArray.","category":"page"},{"location":"manual/containers/#Array","page":"Containers","title":"Array","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"An Array is created when the index sets are rectangular and the index sets are of the form 1:n.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container(x[i = 1:2, j = 1:3], (i, j))\n2√ó3 Array{Tuple{Int64,Int64},2}:\n (1, 1)  (1, 2)  (1, 3)\n (2, 1)  (2, 2)  (2, 3)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"The result is just a normal Julia array, so you can do all the usual things.","category":"page"},{"location":"manual/containers/#Slicing","page":"Containers","title":"Slicing","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Arrays can be sliced","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x[:, 1]\n2-element Array{Tuple{Int64,Int64},1}:\n (1, 1)\n (2, 1)\n\njulia> x[2, :]\n3-element Array{Tuple{Int64,Int64},1}:\n (2, 1)\n (2, 2)\n (2, 3)","category":"page"},{"location":"manual/containers/#Looping","page":"Containers","title":"Looping","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use eachindex to loop over the elements:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> for key in eachindex(x)\n           println(x[key])\n       end\n(1, 1)\n(2, 1)\n(1, 2)\n(2, 2)\n(1, 3)\n(2, 3)","category":"page"},{"location":"manual/containers/#Get-the-index-sets","page":"Containers","title":"Get the index sets","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use axes to obtain the index sets:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> axes(x)\n(Base.OneTo(2), Base.OneTo(3))","category":"page"},{"location":"manual/containers/#Broadcasting","page":"Containers","title":"Broadcasting","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Broadcasting over an Array returns an Array","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> swap(x::Tuple) = (last(x), first(x))\nswap (generic function with 1 method)\n\njulia> swap.(x)\n2√ó3 Array{Tuple{Int64,Int64},2}:\n (1, 1)  (2, 1)  (3, 1)\n (1, 2)  (2, 2)  (3, 2)","category":"page"},{"location":"manual/containers/#DenseAxisArray","page":"Containers","title":"DenseAxisArray","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"A Containers.DenseAxisArray is created when the index sets are rectangular, but not of the form 1:n. The index sets can be of any type.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x = Containers.@container([i = 1:2, j = [:A, :B]], (i, j))\n2-dimensional DenseAxisArray{Tuple{Int64,Symbol},2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, Symbol[:A, :B]\nAnd data, a 2√ó2 Array{Tuple{Int64,Symbol},2}:\n (1, :A)  (1, :B)\n (2, :A)  (2, :B)","category":"page"},{"location":"manual/containers/#Slicing-2","page":"Containers","title":"Slicing","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"DenseAxisArrays can be sliced","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x[:, :A]\n1-dimensional DenseAxisArray{Tuple{Int64,Symbol},1,...} with index sets:\n    Dimension 1, Base.OneTo(2)\nAnd data, a 2-element Array{Tuple{Int64,Symbol},1}:\n (1, :A)\n (2, :A)\n\njulia> x[1, :]\n1-dimensional DenseAxisArray{Tuple{Int64,Symbol},1,...} with index sets:\n    Dimension 1, Symbol[:A, :B]\nAnd data, a 2-element Array{Tuple{Int64,Symbol},1}:\n (1, :A)\n (1, :B)","category":"page"},{"location":"manual/containers/#Looping-2","page":"Containers","title":"Looping","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use eachindex to loop over the elements:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> for key in eachindex(x)\n           println(x[key])\n       end\n(1, :A)\n(2, :A)\n(1, :B)\n(2, :B)","category":"page"},{"location":"manual/containers/#Get-the-index-sets-2","page":"Containers","title":"Get the index sets","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use axes to obtain the index sets:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> axes(x)\n(Base.OneTo(2), Symbol[:A, :B])","category":"page"},{"location":"manual/containers/#Broadcasting-2","page":"Containers","title":"Broadcasting","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Broadcasting over a DenseAxisArray returns a DenseAxisArray","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> swap(x::Tuple) = (last(x), first(x))\nswap (generic function with 1 method)\n\njulia> swap.(x)\n2-dimensional DenseAxisArray{Tuple{Symbol,Int64},2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, Symbol[:A, :B]\nAnd data, a 2√ó2 Array{Tuple{Symbol,Int64},2}:\n (:A, 1)  (:B, 1)\n (:A, 2)  (:B, 2)","category":"page"},{"location":"manual/containers/#SparseAxisArray","page":"Containers","title":"SparseAxisArray","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"A Containers.SparseAxisArray is created when the index sets are non-rectangular. This occurs in two circumstances:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"An index depends on a prior index:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i = 1:2, j = i:2], (i, j))\nJuMP.Containers.SparseAxisArray{Tuple{Int64,Int64},2,Tuple{Int64,Int64}} with 3 entries:\n  [1, 2]  =  (1, 2)\n  [2, 2]  =  (2, 2)\n  [1, 1]  =  (1, 1)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"The [indices; condition] syntax is used:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x = Containers.@container([i = 1:3, j = [:A, :B]; i > 1 && j == :B], (i, j))\nJuMP.Containers.SparseAxisArray{Tuple{Int64,Symbol},2,Tuple{Int64,Symbol}} with 2 entries:\n  [2, B]  =  (2, :B)\n  [3, B]  =  (3, :B)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Here we have the index sets i = 1:3, j = [:A, :B], followed by ;, and then a condition, which evaluates to true or false: i > 1 && j == :B.","category":"page"},{"location":"manual/containers/#Slicing-3","page":"Containers","title":"Slicing","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"# TODO: This is included so we know to update the documentation when this is fixed.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Slicing is not supported.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x[:, :B]\nERROR: ArgumentError: Indexing with `:` is not supported by Containers.SparseAxisArray\n[...]","category":"page"},{"location":"manual/containers/#Looping-3","page":"Containers","title":"Looping","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use eachindex to loop over the elements:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> for key in eachindex(x)\n           println(x[key])\n       end\n(2, :B)\n(3, :B)","category":"page"},{"location":"manual/containers/#Broadcasting-3","page":"Containers","title":"Broadcasting","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Broadcasting over a SparseAxisArray returns a SparseAxisArray","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> swap(x::Tuple) = (last(x), first(x))\nswap (generic function with 1 method)\n\njulia> swap.(x)\nJuMP.Containers.SparseAxisArray{Tuple{Symbol,Int64},2,Tuple{Int64,Symbol}} with 2 entries:\n  [2, B]  =  (:B, 2)\n  [3, B]  =  (:B, 3)","category":"page"},{"location":"manual/containers/#How-different-container-types-are-chosen","page":"Containers","title":"How different container types are chosen","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"If the compiler can prove at compile time that the index sets are rectangular, and indexed by a compact set of integers that start at 1, Containers.@container will return an array. This is the case if your index sets are visible to the macro as 1:n:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i=1:3, j=1:5], i + j)\n3√ó5 Array{Int64,2}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"or an instance of Base.OneTo:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> set = Base.OneTo(3)\nBase.OneTo(3)\n\njulia> Containers.@container([i=set, j=1:5], i + j)\n3√ó5 Array{Int64,2}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"If the compiler can prove that the index set is rectangular, but not necessarily of the form 1:n at compile time, then a Containers.DenseAxisArray will be constructed instead:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> set = 1:3\n1:3\n\njulia> Containers.@container([i=set, j=1:5], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, Base.OneTo(5)\nAnd data, a 3√ó5 Array{Int64,2}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"info: Info\nWhat happened here? Although we know that set contains 1:3, at compile time the typeof(set) is a UnitRange{Int}. Therefore, Julia can't prove that the range starts at 1 (it only finds this out at runtime), and it defaults to a  DenseAxisArray. The case where we explicitly wrote i = 1:3 worked because the macro can \"see\" the 1 at compile time.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"However, if you know that the indices really do form an Array, you can force the container type with container = Array:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> set = 1:3\n1:3\n\njulia> Containers.@container([i=set, j=1:5], i + j, container = Array)\n3√ó5 Array{Int64,2}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Here's another example with something similar:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> a = 1\n1\n\njulia> Containers.@container([i=a:3, j=1:5], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, Base.OneTo(5)\nAnd data, a 3√ó5 Array{Int64,2}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8\n\njulia> Containers.@container([i=1:a, j=1:5], i + j)\n1√ó5 Array{Int64,2}:\n 2  3  4  5  6","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Finally, if the compiler cannot prove that the index set is rectangular, a Containers.SparseAxisArray will be created.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"This occurs when some indices depend on a previous one:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i=1:3, j=1:i], i + j)\nJuMP.Containers.SparseAxisArray{Int64,2,Tuple{Int64,Int64}} with 6 entries:\n  [3, 1]  =  4\n  [3, 2]  =  5\n  [3, 3]  =  6\n  [2, 2]  =  4\n  [1, 1]  =  2\n  [2, 1]  =  3","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"or if there is a condition on the index sets:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i = 1:5; isodd(i)], i^2)\nJuMP.Containers.SparseAxisArray{Int64,1,Tuple{Int64}} with 3 entries:\n  [3]  =  9\n  [5]  =  25\n  [1]  =  1","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"The condition can depend on multiple indices; it just needs to be a function that returns true or false:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> condition(i, j) = isodd(i) && iseven(j)\ncondition (generic function with 1 method)\n\njulia> Containers.@container([i = 1:2, j = 1:4; condition(i, j)], i + j)\nJuMP.Containers.SparseAxisArray{Int64,2,Tuple{Int64,Int64}} with 2 entries:\n  [1, 2]  =  3\n  [1, 4]  =  5","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP, GLPK\nend\nDocTestFilters = [r\"‚â§|<=\", r\"‚â•|>=\", r\" == | = \", r\" ‚àà | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/solutions/#jump_solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"This section of the manual describes how to access a solved solution to a problem. It uses the following model as an example:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"model = Model(GLPK.Optimizer)\n@variable(model, x >= 0)\n@variable(model, y[[:a, :b]] <= 1)\n@objective(model, Max, -12x - 20y[:a])\n@expression(model, my_expr, 6x + 8y[:a])\n@constraint(model, my_expr >= 100)\n@constraint(model, c1, 7x + 12y[:a] >= 120)\noptimize!(model)\nprint(model)\n\n# output\n\nMax -12 x - 20 y[a]\nSubject to\n 6 x + 8 y[a] ‚â• 100.0\n c1 : 7 x + 12 y[a] ‚â• 120.0\n x ‚â• 0.0\n y[a] ‚â§ 1.0\n y[b] ‚â§ 1.0","category":"page"},{"location":"manual/solutions/#Solutions-summary","page":"Solutions","title":"Solutions summary","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"solution_summary can be used for checking the summary of the optimization solutions.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> solution_summary(model)\n* Solver : GLPK\n\n* Status\n  Termination status : OPTIMAL\n  Primal status      : FEASIBLE_POINT\n  Dual status        : FEASIBLE_POINT\n  Message from the solver:\n  \"Solution is optimal\"\n\n* Candidate solution\n  Objective value      : -205.14285714285714\n  Objective bound      : Inf\n  Dual objective value : -205.1428571428571\n\n* Work counters\n  Solve time (sec)   : 0.00008\n\njulia> solution_summary(model, verbose=true)\n* Solver : GLPK\n\n* Status\n  Termination status : OPTIMAL\n  Primal status      : FEASIBLE_POINT\n  Dual status        : FEASIBLE_POINT\n  Result count       : 1\n  Has duals          : true\n  Message from the solver:\n  \"Solution is optimal\"\n\n* Candidate solution\n  Objective value      : -205.14285714285714\n  Objective bound      : Inf\n  Dual objective value : -205.1428571428571\n  Primal solution :\n    x : 15.428571428571429\n    y[a] : 1.0\n    y[b] : 1.0\n  Dual solution :\n    c1 : 1.7142857142857142\n\n* Work counters\n  Solve time (sec)   : 0.00008","category":"page"},{"location":"manual/solutions/#Why-did-the-solver-stop?","page":"Solutions","title":"Why did the solver stop?","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Usetermination_status to understand why the solver stopped.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> termination_status(model)\nOPTIMAL::TerminationStatusCode = 1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The MOI.TerminationStatusCode enum describes the full list of statuses that could be returned.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Common return values include MOI.OPTIMAL, MOI.LOCALLY_SOLVED, MOI.INFEASIBLE, MOI.DUAL_INFEASIBLE, and MOI.TIME_LIMIT.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"info: Info\nA return status of MOI.OPTIMAL means the solver found (and proved) a globally optimal solution. A return status of MOI.LOCALLY_SOLVED means the solver found a locally optimal solution (which may also be globally optimal, but it could not prove so).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nA return status of MOI.DUAL_INFEASIBLE does not guarantee that the primal is unbounded. When the dual is infeasible, the primal is unbounded if there exists a feasible primal solution.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Use raw_status to get a solver-specific string explaining why the optimization stopped:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> raw_status(model)\n\"Solution is optimal\"","category":"page"},{"location":"manual/solutions/#Primal-solutions","page":"Solutions","title":"Primal solutions","text":"","category":"section"},{"location":"manual/solutions/#Primal-solution-status","page":"Solutions","title":"Primal solution status","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Use primal_status to return an MOI.ResultStatusCode enum describing the status of the primal solution.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> primal_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Other common returns are MOI.NO_SOLUTION, and MOI.INFEASIBILITY_CERTIFICATE. The first means that the solver doesn't have a solution to return, and the second means that the primal solution is a certificate of dual infeasbility (a primal unbounded ray).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"You can also use has_values, which returns true if there is a solution that can be queried, and false otherwise.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> has_values(model)\ntrue","category":"page"},{"location":"manual/solutions/#Objective-values","page":"Solutions","title":"Objective values","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The objective value of a solved problem can be obtained via objective_value. The best known bound on the optimal objective value can be obtained via objective_bound. If the solver supports it, the value of the dual objective can be obtained via dual_objective_value.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> objective_value(model)\n-205.14285714285714\n\njulia> objective_bound(model)  # GLPK only implements objective bound for MIPs\nInf\n\njulia> dual_objective_value(model)\n-205.1428571428571","category":"page"},{"location":"manual/solutions/#Primal-solution-values","page":"Solutions","title":"Primal solution values","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If the solver has a primal solution to return, use value to access it:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> value(x)\n15.428571428571429","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Broadcast [value](@ref) over containers:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> value.(y)\n1-dimensional DenseAxisArray{Float64,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{Float64,1}:\n 1.0\n 1.0","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"value also works on expressions:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> value(my_expr)\n100.57142857142857","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"and constraints:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> value(c1)\n120.0","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"info: Info\nCalling value on a constraint returns the constraint function evaluated at the solution.","category":"page"},{"location":"manual/solutions/#Dual-solutions","page":"Solutions","title":"Dual solutions","text":"","category":"section"},{"location":"manual/solutions/#Dual-solution-status","page":"Solutions","title":"Dual solution status","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Use dual_status to return an MOI.ResultStatusCode enum describing the status of the dual solution.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> dual_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Other common returns are MOI.NO_SOLUTION, and MOI.INFEASIBILITY_CERTIFICATE. The first means that the solver doesn't have a solution to return, and the second means that the dual solution is a certificate of primal infeasbility (a dual unbounded ray).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"You can also use has_duals, which returns true if there is a solution that can be queried, and false otherwise.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> has_duals(model)\ntrue","category":"page"},{"location":"manual/solutions/#Dual-solution-values","page":"Solutions","title":"Dual solution values","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If the solver has a dual solution to return, use dual to access it:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> dual(c1)\n1.7142857142857142","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Query the duals of variable bounds using LowerBoundRef, UpperBoundRef, and FixRef:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> dual(LowerBoundRef(x))\n0.0\n\njulia> dual.(UpperBoundRef.(y))\n1-dimensional DenseAxisArray{Float64,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{Float64,1}:\n -0.5714285714285694\n  0.0","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nJuMP's definition of duality is independent of the objective sense. That is, the sign of feasible duals associated with a constraint depends on the direction of the constraint and not whether the problem is maximization or minimization. This is a different convention from linear programming duality in some common textbooks. If you have a linear program, and you want the textbook definition, you probably want to use shadow_price and reduced_cost instead.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> shadow_price(c1)\n1.7142857142857142\n\njulia> reduced_cost(x)\n0.0\n\njulia> reduced_cost.(y)\n1-dimensional DenseAxisArray{Float64,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{Float64,1}:\n  0.5714285714285694\n -0.0","category":"page"},{"location":"manual/solutions/#Recommended-workflow","page":"Solutions","title":"Recommended workflow","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The recommended workflow for solving a model and querying the solution is something like the following:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"if termination_status(model) == MOI.OPTIMAL\n    println(\"Solution is optimal\")\nelseif termination_status(model) == MOI.TIME_LIMIT && has_values(model)\n    println(\"Solution is suboptimal due to a time limit, but a primal solution is available\")\nelse\n    error(\"The model was not solved correctly.\")\nend\nprintln(\"  objective value = \", objective_value(model))\nif primal_status(model) == MOI.FEASIBLE_POINT\n    println(\"  primal solution: x = \", value(x))\nend\nif dual_status(model) == MOI.FEASIBLE_POINT\n    println(\"  dual solution: c1 = \", dual(c1))\nend\n\n# output\n\nSolution is optimal\n  objective value = -205.14285714285714\n  primal solution: x = 15.428571428571429\n  dual solution: c1 = 1.7142857142857142","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nQuerying solution information after modifying a solved model is undefined behavior, and solvers may throw an error or return incorrect results. Modifications include adding, deleting, or modifying any variable, objective, or constraint. Instead of modify-then-query, query the results first, then modify the problem. For example:model = Model(GLPK.Optimizer)\n@variable(model, x >= 0)\noptimize!(model)\n# Bad:\nset_lower_bound(x, 1)\n@show value(x)\n# Good:\nx_val = value(x)\nset_lower_bound(x, 1)\n@show x_val","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"# TODO: How to accurately measure the solve time.","category":"page"},{"location":"manual/solutions/#Accessing-attributes","page":"Solutions","title":"Accessing attributes","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"MathOptInterface defines a large number of model attributes that can be queried. Some attributes can be directly accessed by getter functions. These include:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"solve_time\nrelative_gap\nsimplex_iterations\nbarrier_iterations\nnode_count","category":"page"},{"location":"manual/solutions/#Sensitivity-analysis-for-LP","page":"Solutions","title":"Sensitivity analysis for LP","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Given an LP problem and an optimal solution corresponding to a basis, we can question how much an objective coefficient or standard form right-hand side coefficient (c.f., normalized_rhs) can change without violating primal or dual feasibility of the basic solution.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Note that not all solvers compute the basis, and for sensitivity analysis, the solver interface must implement MOI.ConstraintBasisStatus.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To give a simple example, we could analyze the sensitivity of the optimal solution to the following (non-degenerate) LP problem:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"model = Model(GLPK.Optimizer)\n@variable(model, x[1:2])\nset_lower_bound(x[2], -0.5)\nset_upper_bound(x[2], 0.5)\n@constraint(model, c1, x[1] + x[2] <= 1)\n@constraint(model, c2, x[1] - x[2] <= 1)\n@objective(model, Max, x[1])\nprint(model)\n\n# output\n\nMax x[1]\nSubject to\n c1 : x[1] + x[2] ‚â§ 1.0\n c2 : x[1] - x[2] ‚â§ 1.0\n x[2] ‚â• -0.5\n x[2] ‚â§ 0.5","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To analyze the sensitivity of the problem we could check the allowed perturbation ranges of, e.g., the cost coefficients and the right-hand side coefficient of the constraint c1 as follows:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> optimize!(model)\n\njulia> value.(x)\n2-element Array{Float64,1}:\n 1.0\n 0.0\n\njulia> report = lp_sensitivity_report(model);\n\njulia> x1_lo, x1_hi = report[x[1]]\n(-1.0, Inf)\n\njulia> println(\"The objective coefficient of x[1] could decrease by $(x1_lo) or increase by $(x1_hi).\")\nThe objective coefficient of x[1] could decrease by -1.0 or increase by Inf.\n\njulia> x2_lo, x2_hi = report[x[2]]\n(-1.0, 1.0)\n\njulia> println(\"The objective coefficient of x[2] could decrease by $(x2_lo) or increase by $(x2_hi).\")\nThe objective coefficient of x[2] could decrease by -1.0 or increase by 1.0.\n\njulia> c_lo, c_hi = report[c1]\n(-1.0, 1.0)\n\njulia> println(\"The RHS of c1 could decrease by $(c_lo) or increase by $(c_hi).\")\nThe RHS of c1 could decrease by -1.0 or increase by 1.0.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The range associated with a variable is the range of the allowed perturbation of the corresponding objective coefficient. Note that the current primal solution remains optimal within this range; however the corresponding dual solution might change since a cost coefficient is perturbed. Similarly, the range associated with a constraint is the range of the allowed perturbation of the corresponding right-hand side coefficient. In this range the current dual solution remains optimal, but the optimal primal solution might change.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If the problem is degenerate, there are multiple optimal bases and hence these ranges might not be as intuitive and seem too narrow. E.g., a larger cost coefficient perturbation might not invalidate the optimality of the current primal solution. Moreover, if a problem is degenerate, due to finite precision, it can happen that, e.g., a perturbation seems to invalidate a basis even though it doesn't (again providing too narrow ranges). To prevent this, increase the atol keyword argument to lp_sensitivity_report. Note that this might make the ranges too wide for numerically challenging instances. Thus, do not blindly trust these ranges, especially not for highly degenerate or numerically unstable instances.","category":"page"},{"location":"manual/solutions/#Conflicts","page":"Solutions","title":"Conflicts","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"When the model you input is infeasible, some solvers can help you find the cause of this infeasibility by offering a conflict, i.e., a subset of the constraints that create this infeasibility. Depending on the solver, this can also be called an IIS (irreducible inconsistent subsystem).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The function compute_conflict! is used to trigger the computation of a conflict. Once this process is finished, the attribute MOI.ConflictStatus returns a MOI.ConflictStatusCode.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If there is a conflict, you can query from each constraint whether it participates in the conflict or not using the attribute MOI.ConstraintConflictStatus, which returns a MOI.ConflictParticipationStatusCode.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To create a new model containing only the constraints that participate in the conflict, use copy_conflict. It may be helpful to write this model to a file for easier debugging using write_to_file.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"For instance, this is how you can use this functionality:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"using JuMP\nmodel = Model() # You must use a solver that supports conflict refining/IIS\n# computation, like CPLEX or Gurobi\n@variable(model, x >= 0)\n@constraint(model, c1, x >= 2)\n@constraint(model, c2, x <= 1)\noptimize!(model)\n\n# termination_status(model) will likely be MOI.INFEASIBLE,\n# depending on the solver\n\ncompute_conflict!(model)\nif MOI.get(model, MOI.ConflictStatus()) != MOI.CONFLICT_FOUND\n    error(\"No conflict could be found for an infeasible model.\")\nend\n\n# Both constraints should participate in the conflict.\nMOI.get(model, MOI.ConstraintConflictStatus(), c1)\nMOI.get(model, MOI.ConstraintConflictStatus(), c2)\n\n# Get a copy of the model with only the constraints in the conflict.\nnew_model, reference_map = copy_conflict(model)","category":"page"},{"location":"manual/solutions/#Multiple-solutions","page":"Solutions","title":"Multiple solutions","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Some solvers support returning multiple solutions. You can check how many solutions are available to query using result_count.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Functions for querying the solutions, e.g., primal_status and value, all take an additional keyword argument result which can be used to specify which result to return.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nEven if termination_status is MOI.OPTIMAL, some of the returned solutions may be suboptimal! However, if the solver found at least one optimal solution, then result = 1 will always return an optimal solution. Use objective_value to assess the quality of the remaining solutions.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"using JuMP\nmodel = Model()\n@variable(model, x[1:10] >= 0)\n# ... other constraints ...\noptimize!(model)\n\nif termination_status(model) != MOI.OPTIMAL\n    error(\"The model was not solved correctly.\")\nend\n\nan_optimal_solution = value.(x; result = 1)\noptimal_objective = objective_value(model; result = 1)\nfor i in 2:result_count(model)\n    @assert has_values(model; result = i)\n    println(\"Solution $(i) = \", value.(x; result = i))\n    obj = objective_value(model; result = i)\n    println(\"Objective $(i) = \", obj)\n    if isapprox(obj, optimal_objective; atol = 1e-8)\n        print(\"Solution $(i) is also optimal!\")\n    end\nend","category":"page"},{"location":"manual/solutions/#Checking-feasibility-of-solutions","page":"Solutions","title":"Checking feasibility of solutions","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To check the feasibility of a primal solution, use primal_feasibility_report, which takes a model, a dictionary mapping each variable to a primal solution value (defaults to the last solved solution), and a tolerance atol (defaults to 0.0).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The function returns a dictionary which maps the infeasible constraint references to the distance between the primal value of the constraint and the nearest point in the corresponding set. A point is classed as infeasible if the distance is greater than the supplied tolerance atol.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"# Add a filter here because the output of the dictionary is not ordered, and\n# changes in printing order will cause the doctest to fail.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> model = Model(GLPK.Optimizer);\n\njulia> @variable(model, x >= 1, Int);\n\njulia> @variable(model, y);\n\njulia> @constraint(model, c1, x + y <= 1.95);\n\njulia> point = Dict(x => 1.9, y => 0.06);\n\njulia> primal_feasibility_report(model, point)\nDict{Any,Float64} with 2 entries:\n  c1 : x + y ‚â§ 1.95 => 0.01\n  x integer         => 0.1\n\njulia> primal_feasibility_report(model, point; atol = 0.02)\nDict{Any,Float64} with 1 entry:\n  x integer => 0.1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If the point is feasible, an empty dictionary is returned:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> primal_feasibility_report(model, Dict(x => 1.0, y => 0.0))\nDict{Any,Float64} with 0 entries","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To use the primal solution from a solve, omit the point argument:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> optimize!(model)\n\njulia> primal_feasibility_report(model)\nDict{Any,Float64} with 0 entries","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Pass skip_mising = true to skip constraints which contain variables that are not in point:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> primal_feasibility_report(model, Dict(x => 2.1); skip_missing = true)\nDict{Any,Float64} with 1 entry:\n  x integer => 0.1","category":"page"},{"location":"reference/expressions/#ExpressionAPI","page":"Expressions","title":"Expressions","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"More information can be found in the Expressions section of the manual.","category":"page"},{"location":"reference/expressions/#Macros","page":"Expressions","title":"Macros","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"@expression\n@expressions","category":"page"},{"location":"reference/expressions/#JuMP.@expression","page":"Expressions","title":"JuMP.@expression","text":"@expression(args...)\n\nEfficiently builds a linear or quadratic expression but does not add to model immediately. Instead, returns the expression which can then be inserted in other constraints. For example:\n\n@expression(m, shared, sum(i*x[i] for i=1:5))\n@constraint(m, shared + y >= 5)\n@constraint(m, shared + z <= 10)\n\nThe ref accepts index sets in the same way as @variable, and those indices can be used in the construction of the expressions:\n\n@expression(m, expr[i=1:3], i*sum(x[j] for j=1:3))\n\nAnonymous syntax is also supported:\n\nexpr = @expression(m, [i=1:3], i*sum(x[j] for j=1:3))\n\n\n\n\n\n","category":"macro"},{"location":"reference/expressions/#JuMP.@expressions","page":"Expressions","title":"JuMP.@expressions","text":"@expressions(model, args...)\n\nAdds multiple expressions to model at once, in the same fashion as the @expression macro.\n\nThe model must be the first argument, and multiple variables can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@expressions(model, begin\n    my_expr, x^2 + y^2\n    my_expr_1[i = 1:2], a[i] - z[i]\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/expressions/#Affine-expressions","page":"Expressions","title":"Affine expressions","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"GenericAffExpr\nAffExpr\nlinear_terms","category":"page"},{"location":"reference/expressions/#JuMP.GenericAffExpr","page":"Expressions","title":"JuMP.GenericAffExpr","text":"mutable struct GenericAffExpr{CoefType,VarType} <: AbstractJuMPScalar\n    constant::CoefType\n    terms::OrderedDict{VarType,CoefType}\nend\n\nAn expression type representing an affine expression of the form: sum a_i x_i + c.\n\nFields\n\n.constant: the constant c in the expression.\n.terms: an OrderedDict, with keys of VarType and values of CoefType describing the sparse vector a.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.AffExpr","page":"Expressions","title":"JuMP.AffExpr","text":"AffExpr\n\nAlias for GenericAffExpr{Float64,VariableRef}, the specific GenericAffExpr used by JuMP.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.linear_terms","page":"Expressions","title":"JuMP.linear_terms","text":"linear_terms(aff::GenericAffExpr{C, V})\n\nProvides an iterator over coefficient-variable tuples (a_i::C, x_i::V) in the linear part of the affine expression.\n\n\n\n\n\nlinear_terms(quad::GenericQuadExpr{C, V})\n\nProvides an iterator over tuples (coefficient::C, variable::V) in the linear part of the quadratic expression.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#Quadratic-expressions","page":"Expressions","title":"Quadratic expressions","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"GenericQuadExpr\nQuadExpr\nUnorderedPair\nquad_terms","category":"page"},{"location":"reference/expressions/#JuMP.GenericQuadExpr","page":"Expressions","title":"JuMP.GenericQuadExpr","text":"mutable struct GenericQuadExpr{CoefType,VarType} <: AbstractJuMPScalar\n    aff::GenericAffExpr{CoefType,VarType}\n    terms::OrderedDict{UnorderedPair{VarType}, CoefType}\nend\n\nAn expression type representing an quadratic expression of the form: sum q_ij x_i x_j + sum a_i x_i + c.\n\nFields\n\n.aff: an GenericAffExpr representing the affine portion of the expression.\n.terms: an OrderedDict, with keys of UnorderedPair{VarType} and values of CoefType, describing the sparse list of terms q.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.QuadExpr","page":"Expressions","title":"JuMP.QuadExpr","text":"QuadExpr\n\nAn alias for GenericQuadExpr{Float64,VariableRef}, the specific     GenericQuadExpr used by JuMP.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.UnorderedPair","page":"Expressions","title":"JuMP.UnorderedPair","text":"UnorderedPair(a::T, b::T)\n\nA wrapper type used by GenericQuadExpr with fields .a and .b.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.quad_terms","page":"Expressions","title":"JuMP.quad_terms","text":"quad_terms(quad::GenericQuadExpr{C, V})\n\nProvides an iterator over tuples (coefficient::C, var_1::V, var_2::V) in the quadratic part of the quadratic expression.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#Utilities-and-modifications","page":"Expressions","title":"Utilities and modifications","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"constant\ncoefficient\nisequal_canonical\nadd_to_expression!\ndrop_zeros!\nmap_coefficients\nmap_coefficients_inplace!","category":"page"},{"location":"reference/expressions/#JuMP.constant","page":"Expressions","title":"JuMP.constant","text":"constant(aff::GenericAffExpr{C, V})::C\n\nReturn the constant of the affine expression.\n\n\n\n\n\nconstant(aff::GenericQuadExpr{C, V})::C\n\nReturn the constant of the quadratic expression.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.coefficient","page":"Expressions","title":"JuMP.coefficient","text":"coefficient(v1::VariableRef, v2::VariableRef)\n\nReturn 1.0 if v1 == v2, and 0.0 otherwise.\n\nThis is a fallback for other coefficient methods to simplify code in which the expression may be a single variable.\n\n\n\n\n\ncoefficient(a::GenericAffExpr{C,V}, v::V) where {C,V}\n\nReturn the coefficient associated with variable v in the affine expression a.\n\n\n\n\n\ncoefficient(a::GenericAffExpr{C,V}, v1::V, v2::V) where {C,V}\n\nReturn the coefficient associated with the term v1 * v2 in the quadratic expression a.\n\nNote that coefficient(a, v1, v2) is the same as coefficient(a, v2, v1).\n\n\n\n\n\ncoefficient(a::GenericQuadExpr{C,V}, v::V) where {C,V}\n\nReturn the coefficient associated with variable v in the affine component of a.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.isequal_canonical","page":"Expressions","title":"JuMP.isequal_canonical","text":"isequal_canonical(\n    aff::GenericAffExpr{C,V},\n    other::GenericAffExpr{C,V}\n) where {C,V}\n\nReturn true if aff is equal to other after dropping zeros and disregarding the order. Mainly useful for testing.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.add_to_expression!","page":"Expressions","title":"JuMP.add_to_expression!","text":"add_to_expression!(expression, terms...)\n\nUpdates expression in place to expression + (*)(terms...). This is typically much more efficient than expression += (*)(terms...). For example, add_to_expression!(expression, a, b) produces the same result as expression += a*b, and add_to_expression!(expression, a) produces the same result as expression += a.\n\nOnly a few methods are defined, mostly for internal use, and only for the cases when (1) they can be implemented efficiently and (2) expression is capable of storing the result. For example, add_to_expression!(::AffExpr, ::VariableRef, ::VariableRef) is not defined because a GenericAffExpr cannot store the product of two variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.drop_zeros!","page":"Expressions","title":"JuMP.drop_zeros!","text":"drop_zeros!(expr::GenericAffExpr)\n\nRemove terms in the affine expression with 0 coefficients.\n\n\n\n\n\ndrop_zeros!(expr::GenericQuadExpr)\n\nRemove terms in the quadratic expression with 0 coefficients.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.map_coefficients","page":"Expressions","title":"JuMP.map_coefficients","text":"map_coefficients(f::Function, a::GenericAffExpr)\n\nApply f to the coefficients and constant term of an GenericAffExpr a and return a new expression.\n\nSee also: map_coefficients_inplace!\n\nExample\n\njulia> a = GenericAffExpr(1.0, x => 1.0)\nx + 1\n\njulia> map_coefficients(c -> 2 * c, a)\n2 x + 2\n\njulia> a\nx + 1\n\n\n\n\n\nmap_coefficients(f::Function, a::GenericQuadExpr)\n\nApply f to the coefficients and constant term of an GenericQuadExpr a and return a new expression.\n\nSee also: map_coefficients_inplace!\n\nExample\n\njulia> a = @expression(model, x^2 + x + 1)\nx¬≤ + x + 1\n\njulia> map_coefficients(c -> 2 * c, a)\n2 x¬≤ + 2 x + 2\n\njulia> a\nx¬≤ + x + 1\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.map_coefficients_inplace!","page":"Expressions","title":"JuMP.map_coefficients_inplace!","text":"map_coefficients_inplace!(f::Function, a::GenericAffExpr)\n\nApply f to the coefficients and constant term of an GenericAffExpr a and update them in-place.\n\nSee also: map_coefficients\n\nExample\n\njulia> a = GenericAffExpr(1.0, x => 1.0)\nx + 1\n\njulia> map_coefficients_inplace!(c -> 2 * c, a)\n2 x + 2\n\njulia> a\n2 x + 2\n\n\n\n\n\nmap_coefficients_inplace!(f::Function, a::GenericQuadExpr)\n\nApply f to the coefficients and constant term of an GenericQuadExpr a and update them in-place.\n\nSee also: map_coefficients\n\nExample\n\njulia> a = @expression(model, x^2 + x + 1)\nx¬≤ + x + 1\n\njulia> map_coefficients_inplace!(c -> 2 * c, a)\n2 x¬≤ + 2 x + 2\n\njulia> a\n2 x¬≤ + 2 x + 2\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP-to-MOI-converters","page":"Expressions","title":"JuMP-to-MOI converters","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"variable_ref_type\njump_function\njump_function_type\nmoi_function\nmoi_function_type","category":"page"},{"location":"reference/expressions/#JuMP.variable_ref_type","page":"Expressions","title":"JuMP.variable_ref_type","text":"variable_ref_type(::GenericAffExpr{C, V}) where {C, V}\n\nA helper function used internally by JuMP and some JuMP extensions. Returns the variable type V from a GenericAffExpr\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.jump_function","page":"Expressions","title":"JuMP.jump_function","text":"jump_function(x)\n\nGiven an MathOptInterface object x, return the JuMP equivalent.\n\nSee also: moi_function.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.jump_function_type","page":"Expressions","title":"JuMP.jump_function_type","text":"jump_function_type(::Type{T}) where {T}\n\nGiven an MathOptInterface object type T, return the JuMP equivalent.\n\nSee also: moi_function_type.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.moi_function","page":"Expressions","title":"JuMP.moi_function","text":"moi_function(x)\n\nGiven a JuMP object x, return the MathOptInterface equivalent.\n\nSee also: jump_function.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.moi_function_type","page":"Expressions","title":"JuMP.moi_function_type","text":"moi_function_type(::Type{T}) where {T}\n\nGiven a JuMP object type T, return the MathOptInterface equivalent.\n\nSee also: jump_function_type.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Getting started/performance_tips.jl\"","category":"page"},{"location":"tutorials/Getting started/performance_tips/#Performance-tips","page":"Performance tips","title":"Performance tips","text":"","category":"section"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"This tutorial explains how to write performant JuMP code.","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"tip: Tip\nRead the Performance tips section of the Julia manual. The most important rule is to avoid global variables!","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"using JuMP  # hide","category":"page"},{"location":"tutorials/Getting started/performance_tips/#Use-macros-to-build-expressions","page":"Performance tips","title":"Use macros to build expressions","text":"","category":"section"},{"location":"tutorials/Getting started/performance_tips/#What","page":"Performance tips","title":"What","text":"","category":"section"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Use JuMP's macros (or add_to_expression! to build expressions. Avoid constructing expressions outside the macros.","category":"page"},{"location":"tutorials/Getting started/performance_tips/#Why","page":"Performance tips","title":"Why","text":"","category":"section"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Constructing an expression outside the macro results in intermediate copies of the expression. For example,","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"x[1] + x[2] + x[3]","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"is equivalent to","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"a = x[1]\nb = a + x[2]\nc = b + x[3]","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Since we only care about c, the a and b expressions are not needed and constructing them slows the program down!","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"JuMP's macros rewrite the expressions to operate in-place and avoid these extra copies. Because they allocate less memory, they are faster, particularly for large expressions.","category":"page"},{"location":"tutorials/Getting started/performance_tips/#Example","page":"Performance tips","title":"Example","text":"","category":"section"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"model = Model()\n@variable(model, x[1:3])","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Here's what happens if we construct the expression outside the macro:","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"@allocated x[1] + x[2] + x[3]","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"info: Info\nThe @allocated measures how many bytes were allocated during the evaluation of an expression. Fewer is better.","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"If we use the @expression macro, we get many fewer allocations:","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"@allocated @expression(model, x[1] + x[2] + x[3])","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"View this file on Github.","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Getting started/working_with_data_files.jl\"","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#Working-with-Data-Files","page":"Working with Data Files","title":"Working with Data Files","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"In many cases we might need to read data available in an external file rather than type it into Julia ourselves.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"This tutorial is concerned with reading tabular data into Julia and using it for a JuMP model.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"We'll be reading data using the DataFrames.jl package and some other packages specific to file types.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The data are stored in the /docs/src/tutorials/Getting started/data directory of the JuMP source code.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"const DATA_DIR = joinpath(@__DIR__, \"data\");\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"note: Note\nThere are multiple ways to read the same kind of data into Julia. This tutorial focuses on DataFrames.jl because it provides the ecosystem to work with most of the required file types in a straightforward manner.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#DataFrames.jl","page":"Working with Data Files","title":"DataFrames.jl","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The DataFrames package provides a set of tools for working with tabular data. It is available through the Julia package system.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"using Pkg\nPkg.add(\"DataFrames\")","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"import DataFrames","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#What-is-a-DataFrame?","page":"Working with Data Files","title":"What is a DataFrame?","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"A DataFrame is a data structure like a table or spreadsheet. You can use it for storing and exploring a set of related data values. Think of it as a smarter array for holding tabular data.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#Reading-Tabular-Data-into-a-DataFrame","page":"Working with Data Files","title":"Reading Tabular Data into a DataFrame","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"We will begin by reading data from different file formats into a DataFrame object.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#Excel-Sheets","page":"Working with Data Files","title":"Excel Sheets","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Excel files can be read using the XLSX.jl package.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Pkg.add(\"XLSX\")","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"import XLSX","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"To read a Excel file into a DataFrame, we use the following julia code. The first argument to the readtable function is the file to be read and the second argument is the name of the sheet.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"excel_df = DataFrames.DataFrame(\n    XLSX.readtable(joinpath(DATA_DIR, \"SalesData.xlsx\"), \"SalesOrders\")...\n)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#CSV-files","page":"Working with Data Files","title":"CSV files","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"CSV and other delimited text files can be read by the CSV.jl package.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Pkg.add(\"CSV\")","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"import CSV","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"To read a CSV file into a DataFrame, we use the CSV.read function.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"csv_df = CSV.read(joinpath(DATA_DIR, \"StarWars.csv\"), DataFrames.DataFrame)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#Other-Delimited-Files","page":"Working with Data Files","title":"Other Delimited Files","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"We can also use the CSV.jl package to read any other delimited text file format.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"By default, CSV.File will try to detect a file's delimiter from the first 10 lines of the file.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Candidate delimiters include ',', '\\t', ' ', '|', ';', and ':'. If it can't auto-detect the delimiter, it will assume ','.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Let's take the example of space separated data.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"ss_df = CSV.read(joinpath(DATA_DIR, \"Cereal.txt\"), DataFrames.DataFrame)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"We can also specify the delimiter by passing the delim argument.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"delim_df = CSV.read(\n    joinpath(DATA_DIR, \"Soccer.txt\"), DataFrames.DataFrame, delim = \"::\"\n)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Note that by default, are read-only. If we wish to make changes to the data read, we pass the copycols = true argument in the function call.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"ss_df = CSV.read(\n    joinpath(DATA_DIR, \"Cereal.txt\"), DataFrames.DataFrame, copycols = true\n)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#Working-with-DataFrames","page":"Working with Data Files","title":"Working with DataFrames","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Now that we have read the required data into a DataFrame, let us look at some basic operations we can perform on it.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#Querying-Basic-Information","page":"Working with Data Files","title":"Querying Basic Information","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The size function gets us the dimensions of the DataFrame.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"DataFrames.size(ss_df)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"We can also us the nrow and ncol functions to get the number of rows and columns respectively.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"DataFrames.nrow(ss_df), DataFrames.ncol(ss_df)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The describe function gives basic summary statistics of data in a DataFrame.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"DataFrames.describe(ss_df)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Names of every column can be obtained by the names function.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"DataFrames.names(ss_df)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Corresponding data types are obtained using the broadcasted eltype function.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"eltype.(ss_df)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#Accessing-the-Data","page":"Working with Data Files","title":"Accessing the Data","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Similar to regular arrays, we use numerical indexing to access elements of a DataFrame.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"csv_df[1, 1]","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The following are different ways to access a column.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"csv_df[!, 1]","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"csv_df[!, :Name]","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"csv_df.Name","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"csv_df[:, 1] # Note that this creates a copy.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The following are different ways to access a row.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"csv_df[1:1, :]","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"csv_df[1, :] # This produces a DataFrameRow.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"We can change the values just as we normally assign values.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Assign a range to scalar.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"excel_df[1:3, 5] .= 1","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Vector to equal length vector.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"excel_df[4:6, 5] = [4, 5, 6]","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Subset of the DataFrame to another data frame of matching size.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"excel_df[1:2, 6:7] =  DataFrames.DataFrame(\n    [-2 -2; -2 -2], [Symbol(\"Unit Cost\"), :Total]\n)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"excel_df","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"tip: Tip\nThere are a lot more things which can be done with a DataFrame. Read the docs for more information.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#A-Complete-Modelling-Example-Passport-Problem","page":"Working with Data Files","title":"A Complete Modelling Example - Passport Problem","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Let's now apply what we have learnt to solve a real modelling problem.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The Passport Index Dataset lists travel visa requirements for 199 countries, in .csv format. Our task is to find out the minimum number of passports required to visit all countries.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"In this dataset, the first column represents a passport (=from) and each remaining column represents a foreign country (=to).","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The values in each cell are as follows:","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"3 = visa-free travel\n2 = eTA is required\n1 = visa can be obtained on arrival\n0 = visa is required\n-1 is for all instances where passport and destination are the same","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Our task is to find out the minimum number of passports needed to visit every country without requiring a visa.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Thus, the values we are interested in are -1 and 3. Let us modify the data in the following manner:","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"passport_data = CSV.read(\n    joinpath(DATA_DIR, \"passport-index-matrix.csv\"),\n    DataFrames.DataFrame;\n    copycols = true,\n)\n\nfor i in 1:DataFrames.nrow(passport_data)\n    for j in 2:DataFrames.ncol(passport_data)\n        if passport_data[i, j] == -1 || passport_data[i, j] == 3\n            passport_data[i, j] = 1\n        else\n            passport_data[i, j] = 0\n        end\n    end\nend","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The values in the cells now represent:","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"1 = no visa required for travel\n0 = visa required for travel","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Let us associate each passport with a decision variable pass_cntr for each country. We want to minimize the sum sum pass_cntr over all countries.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Since we wish to visit all the countries, for every country, we should own at least one passport that lets us travel to that country visa free. For one destination, this can be mathematically represented as sum_cntr in world passportdata_cntrdest cdot pass_cntr geq 1.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Thus, we can represent this problem using the following model:","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"beginaligned\nmin  sum_cntr in World pass_cntr \ntextst  sum_cntr in World passportdata_cntrdest cdot pass_cntr geq 1  forall dest in World \n pass_cntr in 01  forall cntr in World\nendaligned","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"We'll now solve the problem using JuMP.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"using JuMP\nimport GLPK","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"First, create the set of countries:","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"World = names(passport_data)[2:end]","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Then, create the model and initialize the decision variables:","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"model = Model(GLPK.Optimizer)\n@variable(model, pass[cntr in World], Bin)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Define the objective function","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"@objective(model, Min, sum(pass[cntr] for cntr in World))","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"@constraint(model, [dest in World], passport_data[:, dest]' * pass >= 1)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Now optimize!","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"optimize!(model)\nprintln(\"Minimum number of passports needed: \", objective_value(model))","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"optimal_passports = [cntr for cntr in World if value(pass[cntr]) > 0.5]\nprintln(\"Countries:\")\nfor p in optimal_passports\n    println(\" \", p)\nend","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"note: Note\nWe use value(pass[i]) > 0.5 rather than value(pass[i]) == 1 to avoid excluding solutions like pass[i] = 0.99999 that are \"1\" to some tolerance.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"View this file on Github.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cannery/","page":"The cannery problem","title":"The cannery problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/cannery.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cannery/#The-cannery-problem","page":"The cannery problem","title":"The cannery problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/cannery/","page":"The cannery problem","title":"The cannery problem","text":"A JuMP implementation of the cannery problem from:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Dantzig, Linear Programming and Extensions, Princeton University Press, Princeton, NJ, 1963.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cannery/","page":"The cannery problem","title":"The cannery problem","text":"It was originally contributed by Louis Luangkesorn, January 30, 2015.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cannery/","page":"The cannery problem","title":"The cannery problem","text":"using JuMP\nimport GLPK\n\nfunction example_cannery()\n    # Origin plants.\n    plants = [\"Seattle\", \"San-Diego\"]\n    num_plants = length(plants)\n    # Destination markets.\n    markets = [\"New-York\", \"Chicago\", \"Topeka\"]\n    num_markets = length(markets)\n    # Capacity and demand in cases.\n    capacity = [350, 600]\n    demand = [300, 300, 300]\n    # Distance in thousand miles.\n    distance = [2.5 1.7 1.8; 2.5 1.8 1.4]\n    # Cost per case per thousand miles.\n    freight = 90\n    cannery = Model()\n    set_optimizer(cannery, GLPK.Optimizer)\n    # Create decision variables.\n    @variable(cannery, ship[1:num_plants, 1:num_markets] >= 0)\n    # Ship no more than plant capacity\n    @constraint(\n        cannery, capacity_con[i = 1:num_plants], sum(ship[i, :]) <= capacity[i]\n    )\n    # Ship at least market demand\n    @constraint(\n        cannery, demand_con[j = 1:num_markets], sum(ship[:, j]) >= demand[j]\n    )\n    # Minimize transportation cost\n    @objective(\n        cannery,\n        Min,\n        sum(\n            distance[i, j] * freight * ship[i, j]\n            for i = 1:num_plants, j = 1:num_markets\n        )\n    )\n    optimize!(cannery)\n    println(\"RESULTS:\")\n    for i = 1:num_plants\n        for j = 1:num_markets\n            println(\"  $(plants[i]) $(markets[j]) = $(value(ship[i, j]))\")\n        end\n    end\n    return\nend\n\nexample_cannery()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cannery/","page":"The cannery problem","title":"The cannery problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cannery/","page":"The cannery problem","title":"The cannery problem","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cannery/","page":"The cannery problem","title":"The cannery problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Semidefinite programs/max_cut_sdp.jl\"","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/#SDP-relaxations:-max-cut","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"Solves a semidefinite programming relaxation of the MAXCUT graph problem:","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"max   0.25 * L‚Ä¢X\ns.t.  diag(X) == e\n      X ‚âΩ 0","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"Where L is the weighted graph Laplacian. Uses this relaxation to generate a solution to the original MAXCUT problem using the method from the paper:","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"Goemans, M. X., & Williamson, D. P. (1995). Improved approximation algorithms for maximum cut and satisfiability problems using semidefinite programming. Journal of the ACM (JACM), 42(6), 1115-1145.","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"using JuMP\nimport LinearAlgebra\nimport Random\nimport SCS\nimport Test\n\nfunction solve_max_cut_sdp(num_vertex, weights)\n    # Calculate the (weighted) Lapacian of the graph: L = D - W.\n    laplacian = LinearAlgebra.diagm(0 => weights * ones(num_vertex)) - weights\n    # Solve the SDP relaxation\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, X[1:num_vertex, 1:num_vertex], PSD)\n    @objective(model, Max, 1 / 4 * LinearAlgebra.dot(laplacian, X))\n    @constraint(model, LinearAlgebra.diag(X) .== 1)\n    optimize!(model)\n    # Compute the Cholesky factorization of X, i.e., X = V^T V.\n    opt_X = LinearAlgebra.Hermitian(value.(X), :U)  # Tell Julia its PSD.\n    factorization = LinearAlgebra.cholesky(opt_X, Val(true); check = false)\n    V = (factorization.P * factorization.L)'\n    # Normalize columns.\n    for i in 1:num_vertex\n        V[:, i] ./= LinearAlgebra.norm(V[:, i])\n    end\n    # Generate random vector on unit sphere.\n    Random.seed!(num_vertex)\n    r = rand(num_vertex)\n    r /= LinearAlgebra.norm(r)\n    # Iterate over vertices, and assign each vertex to a side of cut.\n    cut = ones(num_vertex)\n    for i in 1:num_vertex\n        if LinearAlgebra.dot(r, V[:, i]) <= 0\n            cut[i] = -1\n        end\n    end\n\n    return cut, 0.25 * sum(laplacian .* (cut * cut'))\nend\n\nfunction example_max_cut_sdp()\n    #   [1] --- 5 --- [2]\n    #\n    # Solution:\n    #  (S, S‚Ä≤)  = ({1}, {2})\n    cut, cutval = solve_max_cut_sdp(2, [0.0 5.0; 5.0 0.0])\n    Test.@test cut[1] != cut[2]\n    #   [1] --- 5 --- [2]\n    #    |  \\          |\n    #    |    \\        |\n    #    7      6      1\n    #    |        \\    |\n    #    |          \\  |\n    #   [3] --- 1 --- [4]\n    #\n    # Solution:\n    #  (S, S‚Ä≤)  = ({1}, {2, 3, 4})\n    W = [0.0 5.0 7.0 6.0;\n         5.0 0.0 0.0 1.0;\n         7.0 0.0 0.0 1.0;\n         6.0 1.0 1.0 0.0]\n    cut, cutval = solve_max_cut_sdp(4, W)\n    Test.@test cut[1] != cut[2]\n    Test.@test cut[2] == cut[3] == cut[4]\n    #   [1] --- 1 --- [2]\n    #    |             |\n    #    |             |\n    #    5             9\n    #    |             |\n    #    |             |\n    #   [3] --- 2 --- [4]\n    #\n    # Solution:\n    #  (S, S‚Ä≤)  = ({1, 4}, {2, 3})\n    W = [0.0 1.0 5.0 0.0;\n         1.0 0.0 0.0 9.0;\n         5.0 0.0 0.0 2.0;\n         0.0 9.0 2.0 0.0]\n    cut, cutval = solve_max_cut_sdp(4, W)\n    Test.@test cut[1] == cut[4]\n    Test.@test cut[2] == cut[3]\n    Test.@test cut[1] != cut[2]\n    return\nend\n\nexample_max_cut_sdp()","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"View this file on Github.","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"This page was generated using Literate.jl.","category":"page"}]
}
