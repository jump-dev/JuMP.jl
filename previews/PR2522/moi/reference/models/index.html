<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Models · JuMP</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="JuMP logo"/></a><div class="docs-package-name"><span class="docs-autofit">JuMP</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Introduction</a></li><li><a class="tocitem" href="../../../installation/">Installation Guide</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/Getting started/an_introduction_to_julia/">Getting started with Julia</a></li><li><a class="tocitem" href="../../../tutorials/Getting started/getting_started_with_JuMP/">Getting started with JuMP</a></li><li><a class="tocitem" href="../../../tutorials/Getting started/performance_tips/">Performance tips</a></li><li><a class="tocitem" href="../../../tutorials/Getting started/solvers_and_solutions/">Solvers and Solutions</a></li><li><a class="tocitem" href="../../../tutorials/Getting started/variables_constraints_objective/">Variables, constraints, and objective functions</a></li><li><a class="tocitem" href="../../../tutorials/Getting started/working_with_data_files/">Working with Data Files</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Mixed-integer linear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/cutting_stock_column_generation/">Cutting stock</a></li><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/diet/">The diet problem</a></li><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/finance/">Finance</a></li><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/geographic_clustering/">Geographical Clustering</a></li><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/knapsack/">The knapsack problem</a></li><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/n-queens/">N-Queens</a></li><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/network_flows/">Network Flows</a></li><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/power_systems/">Power Systems</a></li><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/prod/">The workforce scheduling problem</a></li><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/steelT3/">The SteelT3 problem</a></li><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/sudoku/">Sudoku</a></li><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/transp/">The transportation problem</a></li><li><a class="tocitem" href="../../../tutorials/Mixed-integer linear programs/urban_plan/">The urban planning problem</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Nonlinear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/Nonlinear programs/clnlbeam/">The clnlbeam problem</a></li><li><a class="tocitem" href="../../../tutorials/Nonlinear programs/mle/">Maximum likelihood estimation</a></li><li><a class="tocitem" href="../../../tutorials/Nonlinear programs/nlp_tricks/">Nonlinear tips and tricks</a></li><li><a class="tocitem" href="../../../tutorials/Nonlinear programs/rocket_control/">Rocket Control</a></li><li><a class="tocitem" href="../../../tutorials/Nonlinear programs/rosenbrock/">The Rosenbrock function</a></li><li><a class="tocitem" href="../../../tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/">Space Shuttle Reentry Trajectory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Quadratic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/Quadratic programs/portfolio/">Portfolio Optimization</a></li><li><a class="tocitem" href="../../../tutorials/Quadratic programs/qcp/">Quadratically constrained programs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Conic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/Conic programs/logistic_regression/">Logistic Regression</a></li><li><a class="tocitem" href="../../../tutorials/Conic programs/tips_and_tricks/">Tips and Tricks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-6" type="checkbox"/><label class="tocitem" for="menuitem-3-6"><span class="docs-label">Semidefinite programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/Semidefinite programs/cluster/">K-means clustering via SDP</a></li><li><a class="tocitem" href="../../../tutorials/Semidefinite programs/corr_sdp/">The correlation problem</a></li><li><a class="tocitem" href="../../../tutorials/Semidefinite programs/experiment_design/">Experiment Design</a></li><li><a class="tocitem" href="../../../tutorials/Semidefinite programs/max_cut_sdp/">SDP relaxations: max-cut</a></li><li><a class="tocitem" href="../../../tutorials/Semidefinite programs/min_distortion/">The minimum distortion problem</a></li><li><a class="tocitem" href="../../../tutorials/Semidefinite programs/min_ellipse/">Minimum ellipses</a></li><li><a class="tocitem" href="../../../tutorials/Semidefinite programs/robust_uncertainty/">Robust uncertainty sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Optimization concepts</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/Optimization concepts/benders_decomposition/">Benders Decomposition</a></li><li><a class="tocitem" href="../../../tutorials/Optimization concepts/benders_lazy_constraints/">Benders Decomposition (Lazy Constraints)</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../manual/models/">Models</a></li><li><a class="tocitem" href="../../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../../manual/expressions/">Expressions</a></li><li><a class="tocitem" href="../../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../manual/containers/">Containers</a></li><li><a class="tocitem" href="../../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../manual/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../../manual/callbacks/">Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../reference/models/">Models</a></li><li><a class="tocitem" href="../../../reference/variables/">Variables</a></li><li><a class="tocitem" href="../../../reference/expressions/">Expressions</a></li><li><a class="tocitem" href="../../../reference/objectives/">Objectives</a></li><li><a class="tocitem" href="../../../reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../reference/containers/">Containers</a></li><li><a class="tocitem" href="../../../reference/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../reference/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../../reference/callbacks/">Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background information</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../background/should_i_use/">Should I use JuMP?</a></li><li><a class="tocitem" href="../../../background/algebraic_modeling_languages/">Algebraic modeling languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../developers/extensions/">Extensions</a></li><li><a class="tocitem" href="../../../developers/style/">Style Guide</a></li><li><a class="tocitem" href="../../../developers/roadmap/">Roadmap</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox" checked/><label class="tocitem" for="menuitem-8"><span class="docs-label">MathOptInterface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/motivation/">Motivation</a></li><li><a class="tocitem" href="../../background/duality/">Duality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/standard_form/">Standard form problem</a></li><li><a class="tocitem" href="../../manual/models/">Models</a></li><li><a class="tocitem" href="../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../manual/modification/">Problem modification</a></li><li><a class="tocitem" href="../../manual/example/">A complete example: solving a knapsack problem</a></li><li><a class="tocitem" href="../../manual/implementing/">Implementing a solver interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox" checked/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../standard_form/">Standard form</a></li><li class="is-active"><a class="tocitem" href>Models</a><ul class="internal"><li><a class="tocitem" href="#Attribute-interface"><span>Attribute interface</span></a></li><li><a class="tocitem" href="#Model-interface"><span>Model interface</span></a></li><li><a class="tocitem" href="#Model-attributes"><span>Model attributes</span></a></li><li><a class="tocitem" href="#Optimizer-interface"><span>Optimizer interface</span></a></li><li><a class="tocitem" href="#Optimizer-attributes"><span>Optimizer attributes</span></a></li></ul></li><li><a class="tocitem" href="../variables/">Variables</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../modification/">Modifications</a></li><li><a class="tocitem" href="../nonlinear/">Nonlinear programming</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../errors/">Errors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox"/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-5-1" type="checkbox"/><label class="tocitem" for="menuitem-8-5-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5-2" type="checkbox"/><label class="tocitem" for="menuitem-8-5-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Bridges/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Bridges/implementation/">Implementation</a></li><li><a class="tocitem" href="../../submodules/Bridges/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5-3" type="checkbox"/><label class="tocitem" for="menuitem-8-5-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/FileFormats/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5-4" type="checkbox"/><label class="tocitem" for="menuitem-8-5-4"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Utilities/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Utilities/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5-5" type="checkbox"/><label class="tocitem" for="menuitem-8-5-5"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Test/overview/">Overview</a></li></ul></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">MathOptInterface</a></li><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Models</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/moi/reference/models.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This documentation is a copy of the official MathOptInterface documentation available at <a href="https://jump.dev/MathOptInterface.jl/v0.9.21">https://jump.dev/MathOptInterface.jl/v0.9.21</a>. It is included here to make it easier to link concepts between JuMP and MathOptInterface.</p></div></div><h1 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h1><h2 id="Attribute-interface"><a class="docs-heading-anchor" href="#Attribute-interface">Attribute interface</a><a id="Attribute-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Attribute-interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.is_set_by_optimize" href="#MathOptInterface.is_set_by_optimize"><code>MathOptInterface.is_set_by_optimize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_set_by_optimize(::AnyAttribute)</code></pre><p>Return a <code>Bool</code> indicating whether the value of the attribute is modified during an <a href="#MathOptInterface.optimize!"><code>optimize!</code></a> call, that is, the attribute is used to query the result of the optimization.</p><p><strong>Important note when defining new attributes</strong></p><p>This function returns <code>false</code> by default so it should be implemented for attributes that are modified by <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.is_copyable" href="#MathOptInterface.is_copyable"><code>MathOptInterface.is_copyable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_copyable(::AnyAttribute)</code></pre><p>Return a <code>Bool</code> indicating whether the value of the attribute may be copied during <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> using <a href="#MathOptInterface.set"><code>set</code></a>.</p><p><strong>Important note when defining new attributes</strong></p><p>By default <code>is_copyable(attr)</code> returns <code>!is_set_by_optimize(attr)</code>. A specific method should be defined for attributes which are copied indirectly during <a href="#MathOptInterface.copy_to"><code>copy_to</code></a>. For instance, both <code>is_copyable</code> and <a href="#MathOptInterface.is_set_by_optimize"><code>is_set_by_optimize</code></a> return <code>false</code> for the following attributes:</p><ul><li><a href="#MathOptInterface.ListOfOptimizerAttributesSet"><code>ListOfOptimizerAttributesSet</code></a>, <a href="#MathOptInterface.ListOfModelAttributesSet"><code>ListOfModelAttributesSet</code></a>, <a href="#MathOptInterface.ListOfConstraintAttributesSet"><code>ListOfConstraintAttributesSet</code></a> and <a href="#MathOptInterface.ListOfVariableAttributesSet"><code>ListOfVariableAttributesSet</code></a>.</li><li><a href="#MathOptInterface.SolverName"><code>SolverName</code></a> and <a href="#MathOptInterface.RawSolver"><code>RawSolver</code></a>: these attributes cannot be set.</li><li><a href="#MathOptInterface.NumberOfVariables"><code>NumberOfVariables</code></a> and <a href="#MathOptInterface.ListOfVariableIndices"><code>ListOfVariableIndices</code></a>: these attributes are set indirectly by <a href="../variables/#MathOptInterface.add_variable"><code>add_variable</code></a> and <a href="../variables/#MathOptInterface.add_variables"><code>add_variables</code></a>.</li><li><a href="#MathOptInterface.ObjectiveFunctionType"><code>ObjectiveFunctionType</code></a>: this attribute is set indirectly when setting the <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a> attribute.</li><li><a href="#MathOptInterface.NumberOfConstraints"><code>NumberOfConstraints</code></a>, <a href="#MathOptInterface.ListOfConstraintIndices"><code>ListOfConstraintIndices</code></a>, <a href="#MathOptInterface.ListOfConstraints"><code>ListOfConstraints</code></a>, <a href="../constraints/#MathOptInterface.CanonicalConstraintFunction"><code>CanonicalConstraintFunction</code></a>, <a href="../constraints/#MathOptInterface.ConstraintFunction"><code>ConstraintFunction</code></a> and <a href="../constraints/#MathOptInterface.ConstraintSet"><code>ConstraintSet</code></a>: these attributes are set indirectly by <a href="../constraints/#MathOptInterface.add_constraint"><code>add_constraint</code></a> and <a href="../constraints/#MathOptInterface.add_constraints"><code>add_constraints</code></a>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.get" href="#MathOptInterface.get"><code>MathOptInterface.get</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute)</code></pre><p>Return an attribute <code>attr</code> of the optimizer <code>optimizer</code>.</p><pre><code class="language-none">get(model::ModelLike, attr::AbstractModelAttribute)</code></pre><p>Return an attribute <code>attr</code> of the model <code>model</code>.</p><pre><code class="language-none">get(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex)</code></pre><p>If the attribute <code>attr</code> is set for the variable <code>v</code> in the model <code>model</code>, return its value, return <code>nothing</code> otherwise. If the attribute <code>attr</code> is not supported by <code>model</code> then an error should be thrown instead of returning <code>nothing</code>.</p><pre><code class="language-none">get(model::ModelLike, attr::AbstractVariableAttribute, v::Vector{VariableIndex})</code></pre><p>Return a vector of attributes corresponding to each variable in the collection <code>v</code> in the model <code>model</code>.</p><pre><code class="language-none">get(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex)</code></pre><p>If the attribute <code>attr</code> is set for the constraint <code>c</code> in the model <code>model</code>, return its value, return <code>nothing</code> otherwise. If the attribute <code>attr</code> is not supported by <code>model</code> then an error should be thrown instead of returning <code>nothing</code>.</p><pre><code class="language-none">get(model::ModelLike, attr::AbstractConstraintAttribute, c::Vector{ConstraintIndex{F,S}})</code></pre><p>Return a vector of attributes corresponding to each constraint in the collection <code>c</code> in the model <code>model</code>.</p><pre><code class="language-none">get(model::ModelLike, ::Type{VariableIndex}, name::String)</code></pre><p>If a variable with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. Errors if two variables have the same name.</p><pre><code class="language-none">get(model::ModelLike, ::Type{ConstraintIndex{F,S}}, name::String) where {F&lt;:AbstractFunction,S&lt;:AbstractSet}</code></pre><p>If an <code>F</code>-in-<code>S</code> constraint with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. Errors if two constraints have the same name.</p><pre><code class="language-none">get(model::ModelLike, ::Type{ConstraintIndex}, name::String)</code></pre><p>If <em>any</em> constraint with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. This version is available for convenience but may incur a performance penalty because it is not type stable. Errors if two constraints have the same name.</p><p><strong>Examples</strong></p><pre><code class="language-julia">get(model, ObjectiveValue())
get(model, VariablePrimal(), ref)
get(model, VariablePrimal(5), [ref1, ref2])
get(model, OtherAttribute(&quot;something specific to cplex&quot;))
get(model, VariableIndex, &quot;var1&quot;)
get(model, ConstraintIndex{ScalarAffineFunction{Float64},LessThan{Float64}}, &quot;con1&quot;)
get(model, ConstraintIndex, &quot;con1&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.get!" href="#MathOptInterface.get!"><code>MathOptInterface.get!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get!(output, model::ModelLike, args...)</code></pre><p>An in-place version of <code>get</code>. The signature matches that of <code>get</code> except that the the result is placed in the vector <code>output</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.set" href="#MathOptInterface.set"><code>MathOptInterface.set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the optimizer <code>optimizer</code>.</p><pre><code class="language-none">set(model::ModelLike, attr::AbstractModelAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the model <code>model</code>.</p><pre><code class="language-none">set(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of variable <code>v</code> in model <code>model</code>.</p><pre><code class="language-none">set(model::ModelLike, attr::AbstractVariableAttribute, v::Vector{VariableIndex}, vector_of_values)</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each variable in the collection <code>v</code> in model <code>model</code>.</p><pre><code class="language-none">set(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex, value)</code></pre><p>Assign a value to the attribute <code>attr</code> of constraint <code>c</code> in model <code>model</code>.</p><pre><code class="language-none">set(model::ModelLike, attr::AbstractConstraintAttribute, c::Vector{ConstraintIndex{F,S}}, vector_of_values)</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each constraint in the collection <code>c</code> in model <code>model</code>.</p><p>An <a href="../errors/#MathOptInterface.UnsupportedAttribute"><code>UnsupportedAttribute</code></a> error is thrown if <code>model</code> does not support the attribute <code>attr</code> (see <a href="#MathOptInterface.supports"><code>supports</code></a>) and a <a href="../errors/#MathOptInterface.SetAttributeNotAllowed"><code>SetAttributeNotAllowed</code></a> error is thrown if it supports the attribute <code>attr</code> but it cannot be set.</p><p><strong>Replace set in a constraint</strong></p><pre><code class="language-none">set(model::ModelLike, ::ConstraintSet, c::ConstraintIndex{F,S}, set::S)</code></pre><p>Change the set of constraint <code>c</code> to the new set <code>set</code> which should be of the same type as the original set.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintIndex{F,Interval}</code></p><pre><code class="language-julia">set(model, ConstraintSet(), c, Interval(0, 5))
set(model, ConstraintSet(), c, GreaterThan(0.0))  # Error</code></pre><p><strong>Replace function in a constraint</strong></p><pre><code class="language-none">set(model::ModelLike, ::ConstraintFunction, c::ConstraintIndex{F,S}, func::F)</code></pre><p>Replace the function in constraint <code>c</code> with <code>func</code>. <code>F</code> must match the original function type used to define the constraint.</p><p><strong>Note</strong></p><p>Setting the constraint function is not allowed if <code>F</code> is <a href="../standard_form/#MathOptInterface.SingleVariable"><code>SingleVariable</code></a>, it throws a <a href="../errors/#MathOptInterface.SettingSingleVariableFunctionNotAllowed"><code>SettingSingleVariableFunctionNotAllowed</code></a> error. Indeed, it would require changing the index <code>c</code> as the index of <code>SingleVariable</code> constraints should be the same as the index of the variable.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintIndex{ScalarAffineFunction,S}</code> and <code>v1</code> and <code>v2</code> are <code>VariableIndex</code> objects,</p><pre><code class="language-julia">set(model, ConstraintFunction(), c,
    ScalarAffineFunction(ScalarAffineTerm.([1.0, 2.0], [v1, v2]), 5.0))
set(model, ConstraintFunction(), c, SingleVariable(v1)) # Error</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.supports" href="#MathOptInterface.supports"><code>MathOptInterface.supports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">supports(model::ModelLike, sub::AbstractSubmittable)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the submittable <code>sub</code>.</p><pre><code class="language-none">supports(model::ModelLike, attr::AbstractOptimizerAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the optimizer attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> shows a warning in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfOptimizerAttributesSet"><code>ListOfOptimizerAttributesSet</code></a> of <code>src</code>; see <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> for more details on how unsupported optimizer attributes are handled in copy.</p><pre><code class="language-none">supports(model::ModelLike, attr::AbstractModelAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the model attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfModelAttributesSet"><code>ListOfModelAttributesSet</code></a> of <code>src</code>.</p><pre><code class="language-none">supports(model::ModelLike, attr::AbstractVariableAttribute, ::Type{VariableIndex})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the variable attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfVariableAttributesSet"><code>ListOfVariableAttributesSet</code></a> of <code>src</code>.</p><pre><code class="language-none">supports(model::ModelLike, attr::AbstractConstraintAttribute, ::Type{ConstraintIndex{F,S}})::Bool where {F,S}</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the constraint attribute <code>attr</code> applied to an <code>F</code>-in-<code>S</code> constraint. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfConstraintAttributesSet"><code>ListOfConstraintAttributesSet</code></a> of <code>src</code>.</p><p>For all five methods, if the attribute is only not supported in specific circumstances, it should still return <code>true</code>.</p><p>Note that <code>supports</code> is only defined for attributes for which <a href="#MathOptInterface.is_copyable"><code>is_copyable</code></a> returns <code>true</code> as other attributes do not appear in the list of attributes set obtained by <code>ListOf...AttributesSet</code>.</p></div></section></article><h2 id="Model-interface"><a class="docs-heading-anchor" href="#Model-interface">Model interface</a><a id="Model-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Model-interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ModelLike" href="#MathOptInterface.ModelLike"><code>MathOptInterface.ModelLike</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ModelLike</code></pre><p>Abstract supertype for objects that implement the &quot;Model&quot; interface for defining an optimization problem.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.is_empty" href="#MathOptInterface.is_empty"><code>MathOptInterface.is_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_empty(model::ModelLike)</code></pre><p>Returns <code>false</code> if the <code>model</code> has any model attribute set or has any variables or constraints. Note that an empty model can have optimizer attributes set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.empty!" href="#MathOptInterface.empty!"><code>MathOptInterface.empty!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">empty!(model::ModelLike)</code></pre><p>Empty the model, that is, remove all variables, constraints and model attributes but not optimizer attributes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.write_to_file" href="#MathOptInterface.write_to_file"><code>MathOptInterface.write_to_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_to_file(model::ModelLike, filename::String)</code></pre><p>Writes the current model data to the given file. Supported file types depend on the model type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.read_from_file" href="#MathOptInterface.read_from_file"><code>MathOptInterface.read_from_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_from_file(model::ModelLike, filename::String)</code></pre><p>Read the file <code>filename</code> into the model <code>model</code>. If <code>model</code> is non-empty, this may throw an error.</p><p>Supported file types depend on the model type.</p><p><strong>Note</strong></p><p>Once the contents of the file are loaded into the model, users can query the variables via <code>get(model, ListOfVariableIndices())</code>. However, some filetypes, such as LP files, do not maintain an explicit ordering of the variables. Therefore, the returned list may be in an arbitrary order. To avoid depending on the order of the indices, users should look up each variable index by name: <code>get(model, VariableIndex, &quot;name&quot;)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.copy_to" href="#MathOptInterface.copy_to"><code>MathOptInterface.copy_to</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">copy_to(dest::ModelLike, src::ModelLike; copy_names=true, warn_attributes=true)</code></pre><p>Copy the model from <code>src</code> into <code>dest</code>. The target <code>dest</code> is emptied, and all previous indices to variables or constraints in <code>dest</code> are invalidated. Returns a dictionary-like object that translates variable and constraint indices from the <code>src</code> model to the corresponding indices in the <code>dest</code> model.</p><p>If <code>copy_names</code> is <code>false</code>, the <code>Name</code>, <code>VariableName</code> and <code>ConstraintName</code> attributes are not copied even if they are set in <code>src</code>. If a constraint that is copied from <code>src</code> is not supported by <code>dest</code> then an <a href="../errors/#MathOptInterface.UnsupportedConstraint"><code>UnsupportedConstraint</code></a> error is thrown. Similarly, if a model, variable or constraint attribute that is copied from <code>src</code> is not supported by <code>dest</code> then an <a href="../errors/#MathOptInterface.UnsupportedAttribute"><code>UnsupportedAttribute</code></a> error is thrown. Unsupported <em>optimizer</em> attributes are treated differently:</p><ul><li>If <code>warn_attributes</code> is <code>true</code>, a warning is displayed, otherwise,</li><li>the attribute is silently ignored.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia"># Given empty `ModelLike` objects `src` and `dest`.

x = add_variable(src)

is_valid(src, x)   # true
is_valid(dest, x)  # false (`dest` has no variables)

index_map = copy_to(dest, src)
is_valid(dest, x) # false (unless index_map[x] == x)
is_valid(dest, index_map[x]) # true</code></pre></div></section></article><h2 id="Model-attributes"><a class="docs-heading-anchor" href="#Model-attributes">Model attributes</a><a id="Model-attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Model-attributes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractModelAttribute" href="#MathOptInterface.AbstractModelAttribute"><code>MathOptInterface.AbstractModelAttribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractModelAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Name" href="#MathOptInterface.Name"><code>MathOptInterface.Name</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Name()</code></pre><p>A model attribute for the string identifying the model. It has a default value of <code>&quot;&quot;</code> if not set`.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveFunction" href="#MathOptInterface.ObjectiveFunction"><code>MathOptInterface.ObjectiveFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ObjectiveFunction{F&lt;:AbstractScalarFunction}()</code></pre><p>A model attribute for the objective function which has a type <code>F&lt;:AbstractScalarFunction</code>. <code>F</code> should be guaranteed to be equivalent but not necessarily identical to the function type provided by the user. Throws an <code>InexactError</code> if the objective function cannot be converted to <code>F</code>, e.g. the objective function is quadratic and <code>F</code> is <code>ScalarAffineFunction{Float64}</code> or it has non-integer coefficient and <code>F</code> is <code>ScalarAffineFunction{Int}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveFunctionType" href="#MathOptInterface.ObjectiveFunctionType"><code>MathOptInterface.ObjectiveFunctionType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ObjectiveFunctionType()</code></pre><p>A model attribute for the type <code>F</code> of the objective function set using the <code>ObjectiveFunction{F}</code> attribute.</p><p><strong>Examples</strong></p><p>In the following code, <code>attr</code> should be equal to <code>MOI.SingleVariable</code>:</p><pre><code class="language-julia">x = MOI.add_variable(model)
MOI.set(model, MOI.ObjectiveFunction{MOI.SingleVariable}(),
         MOI.SingleVariable(x))
attr = MOI.get(model, MOI.ObjectiveFunctionType())</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveSense" href="#MathOptInterface.ObjectiveSense"><code>MathOptInterface.ObjectiveSense</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ObjectiveSense()</code></pre><p>A model attribute for the objective sense of the objective function, which must be an <code>OptimizationSense</code>: <code>MIN_SENSE</code>, <code>MAX_SENSE</code>, or <code>FEASIBILITY_SENSE</code>. The default is <code>FEASIBILITY_SENSE</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NumberOfVariables" href="#MathOptInterface.NumberOfVariables"><code>MathOptInterface.NumberOfVariables</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NumberOfVariables()</code></pre><p>A model attribute for the number of variables in the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfVariableIndices" href="#MathOptInterface.ListOfVariableIndices"><code>MathOptInterface.ListOfVariableIndices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ListOfVariableIndices()</code></pre><p>A model attribute for the <code>Vector{VariableIndex}</code> of all variable indices present in the model (i.e., of length equal to the value of <code>NumberOfVariables()</code>) in the order in which they were added.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfConstraints" href="#MathOptInterface.ListOfConstraints"><code>MathOptInterface.ListOfConstraints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ListOfConstraints()</code></pre><p>A model attribute for the list of tuples of the form <code>(F,S)</code>, where <code>F</code> is a function type and <code>S</code> is a set type indicating that the attribute <code>NumberOfConstraints{F,S}()</code> has value greater than zero.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NumberOfConstraints" href="#MathOptInterface.NumberOfConstraints"><code>MathOptInterface.NumberOfConstraints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NumberOfConstraints{F,S}()</code></pre><p>A model attribute for the number of constraints of the type <code>F</code>-in-<code>S</code> present in the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfConstraintIndices" href="#MathOptInterface.ListOfConstraintIndices"><code>MathOptInterface.ListOfConstraintIndices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ListOfConstraintIndices{F,S}()</code></pre><p>A model attribute for the <code>Vector{ConstraintIndex{F,S}}</code> of all constraint indices of type <code>F</code>-in-<code>S</code> in the model (i.e., of length equal to the value of <code>NumberOfConstraints{F,S}()</code>) in the order in which they were added.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfOptimizerAttributesSet" href="#MathOptInterface.ListOfOptimizerAttributesSet"><code>MathOptInterface.ListOfOptimizerAttributesSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ListOfOptimizerAttributesSet()</code></pre><p>An optimizer attribute for the <code>Vector{AbstractOptimizerAttribute}</code> of all optimizer attributes that were set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfModelAttributesSet" href="#MathOptInterface.ListOfModelAttributesSet"><code>MathOptInterface.ListOfModelAttributesSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ListOfModelAttributesSet()</code></pre><p>A model attribute for the <code>Vector{AbstractModelAttribute}</code> of all model attributes <code>attr</code> such that 1) <code>is_copyable(attr)</code> returns <code>true</code> and 2) the attribute was set to the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfVariableAttributesSet" href="#MathOptInterface.ListOfVariableAttributesSet"><code>MathOptInterface.ListOfVariableAttributesSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ListOfVariableAttributesSet()</code></pre><p>A model attribute for the <code>Vector{AbstractVariableAttribute}</code> of all variable attributes <code>attr</code> such that 1) <code>is_copyable(attr)</code> returns <code>true</code> and 2) the attribute was set to variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfConstraintAttributesSet" href="#MathOptInterface.ListOfConstraintAttributesSet"><code>MathOptInterface.ListOfConstraintAttributesSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ListOfConstraintAttributesSet{F, S}()</code></pre><p>A model attribute for the <code>Vector{AbstractConstraintAttribute}</code> of all constraint attributes <code>attr</code> such that 1) <code>is_copyable(attr)</code> returns <code>true</code> and</p><ol><li>the attribute was set to <code>F</code>-in-<code>S</code> constraints.</li></ol><p><strong>Note</strong></p><p>The attributes <a href="../constraints/#MathOptInterface.ConstraintFunction"><code>ConstraintFunction</code></a> and <a href="../constraints/#MathOptInterface.ConstraintSet"><code>ConstraintSet</code></a> should not be included in the list even if then have been set with <a href="#MathOptInterface.set"><code>set</code></a>.</p></div></section></article><h2 id="Optimizer-interface"><a class="docs-heading-anchor" href="#Optimizer-interface">Optimizer interface</a><a id="Optimizer-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizer-interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractOptimizer" href="#MathOptInterface.AbstractOptimizer"><code>MathOptInterface.AbstractOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractOptimizer</code></pre><p>Abstract supertype for objects representing an instance of an optimization problem tied to a particular solver. This is typically a solver&#39;s in-memory representation. In addition to <code>ModelLike</code>, <code>AbstractOptimizer</code> objects let you solve the model and query the solution.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.OptimizerWithAttributes" href="#MathOptInterface.OptimizerWithAttributes"><code>MathOptInterface.OptimizerWithAttributes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct OptimizerWithAttributes
    optimizer_constructor
    params::Vector{Pair{AbstractOptimizerAttribute,&lt;:Any}}
end</code></pre><p>Object grouping an optimizer constructor and a list of optimizer attributes. Instances are created with <a href="#MathOptInterface.instantiate"><code>instantiate</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.optimize!" href="#MathOptInterface.optimize!"><code>MathOptInterface.optimize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">optimize!(optimizer::AbstractOptimizer)</code></pre><p>Start the solution procedure.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.instantiate" href="#MathOptInterface.instantiate"><code>MathOptInterface.instantiate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">instantiate(optimizer_constructor,
            with_bridge_type::Union{Nothing, Type}=nothing,
            with_names::Bool=false)</code></pre><p>Creates an instance of optimizer either by calling <code>optimizer_constructor.optimizer_constructor()</code> and setting the parameters in <code>optimizer_constructor.params</code> if <code>optimizer_constructor</code> is a <a href="#MathOptInterface.OptimizerWithAttributes"><code>OptimizerWithAttributes</code></a> or by calling <code>optimizer_constructor()</code> if <code>optimizer_constructor</code> is callable.</p><p>If <code>with_bridge_type</code> is not <code>nothing</code>, it enables all the bridges defined in the MathOptInterface.Bridges submodule with coefficient type <code>with_bridge_type</code>.</p><p>If the optimizer created by <code>optimizer_constructor</code> does not support loading the problem incrementally or does not support names and <code>with_names</code> is <code>true</code> (see <a href="../../submodules/Utilities/reference/#MathOptInterface.Utilities.supports_default_copy_to"><code>Utilities.supports_default_copy_to</code></a>) then a <a href="../../submodules/Utilities/reference/#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a> is added to store a cache of the bridged model. Hence set <code>with_names</code> to <code>true</code> if names might be set.</p></div></section></article><h2 id="Optimizer-attributes"><a class="docs-heading-anchor" href="#Optimizer-attributes">Optimizer attributes</a><a id="Optimizer-attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizer-attributes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractOptimizerAttribute" href="#MathOptInterface.AbstractOptimizerAttribute"><code>MathOptInterface.AbstractOptimizerAttribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractOptimizerAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the optimizer.</p><p><strong>Note</strong></p><p>The difference between <code>AbstractOptimizerAttribute</code> and <code>AbstractModelAttribute</code> lies in the behavior of <code>is_empty</code>, <code>empty!</code> and <code>copy_to</code>. Typically optimizer attributes only affect how the model is solved.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SolverName" href="#MathOptInterface.SolverName"><code>MathOptInterface.SolverName</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SolverName()</code></pre><p>An optimizer attribute for the string identifying the solver/optimizer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Silent" href="#MathOptInterface.Silent"><code>MathOptInterface.Silent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Silent()</code></pre><p>An optimizer attribute for silencing the output of an optimizer. When <code>set</code> to <code>true</code>, it takes precedence over any other attribute controlling verbosity and requires the solver to produce no output. The default value is <code>false</code> which has no effect. In this case the verbosity is controlled by other attributes.</p><p><strong>Note</strong></p><p>Every optimizer should have verbosity on by default. For instance, if a solver has a solver-specific log level attribute, the MOI implementation should set it to <code>1</code> by default. If the user sets <code>Silent</code> to <code>true</code>, then the log level should be set to <code>0</code>, even if the user specifically sets a value of log level. If the value of <code>Silent</code> is <code>false</code> then the log level set to the solver is the value given by the user for this solver-specific parameter or <code>1</code> if none is given.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.TimeLimitSec" href="#MathOptInterface.TimeLimitSec"><code>MathOptInterface.TimeLimitSec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TimeLimitSec()</code></pre><p>An optimizer attribute for setting a time limit for an optimization. When <code>set</code> to <code>nothing</code>, it deactivates the solver time limit. The default value is <code>nothing</code>. The time limit is in seconds.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RawParameter" href="#MathOptInterface.RawParameter"><code>MathOptInterface.RawParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RawParameter(name)</code></pre><p>An optimizer attribute for the solver-specific parameter identified by <code>name</code> which is typically an <code>Enum</code> or a <code>String</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NumberOfThreads" href="#MathOptInterface.NumberOfThreads"><code>MathOptInterface.NumberOfThreads</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NumberOfThreads()</code></pre><p>An optimizer attribute for setting the number of threads used for an optimization. When set to <code>nothing</code> uses solver default. Values are positive integers. The default value is <code>nothing</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RawSolver" href="#MathOptInterface.RawSolver"><code>MathOptInterface.RawSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RawSolver()</code></pre><p>A model attribute for the object that may be used to access a solver-specific API for this optimizer.</p></div></section></article><p>List of attributes useful for optimizers</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.TerminationStatus" href="#MathOptInterface.TerminationStatus"><code>MathOptInterface.TerminationStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TerminationStatus()</code></pre><p>A model attribute for the <code>TerminationStatusCode</code> explaining why the optimizer stopped.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.TerminationStatusCode" href="#MathOptInterface.TerminationStatusCode"><code>MathOptInterface.TerminationStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TerminationStatusCode</code></pre><p>An Enum of possible values for the <code>TerminationStatus</code> attribute. This attribute is meant to explain the reason why the optimizer stopped executing in the most recent call to <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>.</p><p>If no call has been made to <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>, then the <code>TerminationStatus</code> is:</p><ul><li><code>OPTIMIZE_NOT_CALLED</code>: The algorithm has not started.</li></ul><p><strong>OK</strong></p><p>These are generally OK statuses, i.e., the algorithm ran to completion normally.</p><ul><li><code>OPTIMAL</code>: The algorithm found a globally optimal solution.</li><li><code>INFEASIBLE</code>: The algorithm concluded that no feasible solution exists.</li><li><code>DUAL_INFEASIBLE</code>: The algorithm concluded that no dual bound exists for the problem. If, additionally, a feasible (primal) solution is known to exist, this status typically implies that the problem is unbounded, with some technical exceptions.</li><li><code>LOCALLY_SOLVED</code>: The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.</li><li><code>LOCALLY_INFEASIBLE</code>: The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.</li><li><code>INFEASIBLE_OR_UNBOUNDED</code>: The algorithm stopped because it decided that the problem is infeasible or unbounded; this occasionally happens during MIP presolve.</li></ul><p><strong>Solved to relaxed tolerances</strong></p><ul><li><code>ALMOST_OPTIMAL</code>: The algorithm found a globally optimal solution to relaxed tolerances.</li><li><code>ALMOST_INFEASIBLE</code>: The algorithm concluded that no feasible solution exists within relaxed tolerances.</li><li><code>ALMOST_DUAL_INFEASIBLE</code>: The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.</li><li><code>ALMOST_LOCALLY_SOLVED</code>: The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.</li></ul><p><strong>Limits</strong></p><p>The optimizer stopped because of some user-defined limit.</p><ul><li><code>ITERATION_LIMIT</code>: An iterative algorithm stopped after conducting the maximum number of iterations.</li><li><code>TIME_LIMIT</code>: The algorithm stopped after a user-specified computation time.</li><li><code>NODE_LIMIT</code>: A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.</li><li><code>SOLUTION_LIMIT</code>: The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.</li><li><code>MEMORY_LIMIT</code>: The algorithm stopped because it ran out of memory.</li><li><code>OBJECTIVE_LIMIT</code>: The algorithm stopped because it found a solution better than a minimum limit set by the user.</li><li><code>NORM_LIMIT</code>: The algorithm stopped because the norm of an iterate became too large.</li><li><code>OTHER_LIMIT</code>: The algorithm stopped due to a limit not covered by one of the above.</li></ul><p><strong>Problematic</strong></p><p>This group of statuses means that something unexpected or problematic happened.</p><ul><li><code>SLOW_PROGRESS</code>: The algorithm stopped because it was unable to continue making progress towards the solution.</li><li><code>NUMERICAL_ERROR</code>: The algorithm stopped because it encountered unrecoverable numerical error.</li><li><code>INVALID_MODEL</code>: The algorithm stopped because the model is invalid.</li><li><code>INVALID_OPTION</code>: The algorithm stopped because it was provided an invalid option.</li><li><code>INTERRUPTED</code>: The algorithm stopped because of an interrupt signal.</li><li><code>OTHER_ERROR</code>: The algorithm stopped because of an error not covered by one of the statuses defined above.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.PrimalStatus" href="#MathOptInterface.PrimalStatus"><code>MathOptInterface.PrimalStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PrimalStatus(N)
PrimalStatus()</code></pre><p>A model attribute for the <code>ResultStatusCode</code> of the primal result <code>N</code>. If <code>N</code> is omitted, it defaults to 1. If <code>N</code> is larger than the value of <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> then <code>NO_SOLUTION</code> is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.DualStatus" href="#MathOptInterface.DualStatus"><code>MathOptInterface.DualStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DualStatus(N)
DualStatus()</code></pre><p>A model attribute for the <code>ResultStatusCode</code> of the dual result <code>N</code>. If <code>N</code> is omitted, it defaults to 1. If <code>N</code> is larger than the value of <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> then <code>NO_SOLUTION</code> is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ResultStatusCode" href="#MathOptInterface.ResultStatusCode"><code>MathOptInterface.ResultStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ResultStatusCode</code></pre><p>An Enum of possible values for the <code>PrimalStatus</code> and <code>DualStatus</code> attributes. The values indicate how to interpret the result vector.</p><ul><li><code>NO_SOLUTION</code>: the result vector is empty.</li><li><code>FEASIBLE_POINT</code>: the result vector is a feasible point.</li><li><code>NEARLY_FEASIBLE_POINT</code>: the result vector is feasible if some constraint tolerances are relaxed.</li><li><code>INFEASIBLE_POINT</code>: the result vector is an infeasible point.</li><li><code>INFEASIBILITY_CERTIFICATE</code>: the result vector is an infeasibility certificate. If the <code>PrimalStatus</code> is <code>INFEASIBILITY_CERTIFICATE</code>, then the primal result vector is a certificate of dual infeasibility. If the <code>DualStatus</code> is <code>INFEASIBILITY_CERTIFICATE</code>, then the dual result vector is a proof of primal infeasibility.</li><li><code>NEARLY_INFEASIBILITY_CERTIFICATE</code>: the result satisfies a relaxed criterion for a certificate of infeasibility.</li><li><code>REDUCTION_CERTIFICATE</code>: the result vector is an ill-posed certificate; see <a href="https://arxiv.org/abs/1408.4685">this article</a> for details. If the <code>PrimalStatus</code> is <code>REDUCTION_CERTIFICATE</code>, then the primal result vector is a proof that the dual problem is ill-posed. If the <code>DualStatus</code> is <code>REDUCTION_CERTIFICATE</code>, then the dual result vector is a proof that the primal is ill-posed.</li><li><code>NEARLY_REDUCTION_CERTIFICATE</code>: the result satisfies a relaxed criterion for an ill-posed certificate.</li><li><code>UNKNOWN_RESULT_STATUS</code>: the result vector contains a solution with an unknown interpretation.</li><li><code>OTHER_RESULT_STATUS</code>: the result vector contains a solution with an interpretation not covered by one of the statuses defined above.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RawStatusString" href="#MathOptInterface.RawStatusString"><code>MathOptInterface.RawStatusString</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RawStatusString()</code></pre><p>A model attribute for a solver specific string explaining why the optimizer stopped.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ResultCount" href="#MathOptInterface.ResultCount"><code>MathOptInterface.ResultCount</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ResultCount()</code></pre><p>A model attribute for the number of results available.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveValue" href="#MathOptInterface.ObjectiveValue"><code>MathOptInterface.ObjectiveValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ObjectiveValue(resultidx::Int=1)</code></pre><p>A model attribute for the objective value of the <code>result_index</code>th primal result.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.DualObjectiveValue" href="#MathOptInterface.DualObjectiveValue"><code>MathOptInterface.DualObjectiveValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DualObjectiveValue(result_index::Int=1)</code></pre><p>A model attribute for the value of the objective function of the dual problem for the <code>result_index</code>th dual result.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveBound" href="#MathOptInterface.ObjectiveBound"><code>MathOptInterface.ObjectiveBound</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ObjectiveBound()</code></pre><p>A model attribute for the best known bound on the optimal objective value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RelativeGap" href="#MathOptInterface.RelativeGap"><code>MathOptInterface.RelativeGap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RelativeGap()</code></pre><p>A model attribute for the final relative optimality gap, defined as <span>$\frac{|b-f|}{|f|}$</span>, where <span>$b$</span> is the best bound and <span>$f$</span> is the best feasible objective value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SolveTime" href="#MathOptInterface.SolveTime"><code>MathOptInterface.SolveTime</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SolveTime()</code></pre><p>A model attribute for the total elapsed solution time (in seconds) as reported by the optimizer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SimplexIterations" href="#MathOptInterface.SimplexIterations"><code>MathOptInterface.SimplexIterations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimplexIterations()</code></pre><p>A model attribute for the cumulative number of simplex iterations during the optimization process. In particular, for a mixed-integer program (MIP), the total simplex iterations for all nodes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.BarrierIterations" href="#MathOptInterface.BarrierIterations"><code>MathOptInterface.BarrierIterations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BarrierIterations()</code></pre><p>A model attribute for the cumulative number of barrier iterations while solving a problem.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NodeCount" href="#MathOptInterface.NodeCount"><code>MathOptInterface.NodeCount</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NodeCount()</code></pre><p>A model attribute for the total number of branch-and-bound nodes explored while solving a mixed-integer program (MIP).</p></div></section></article><h3 id="Conflict-Status"><a class="docs-heading-anchor" href="#Conflict-Status">Conflict Status</a><a id="Conflict-Status-1"></a><a class="docs-heading-anchor-permalink" href="#Conflict-Status" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.compute_conflict!" href="#MathOptInterface.compute_conflict!"><code>MathOptInterface.compute_conflict!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_conflict!(optimizer::AbstractOptimizer)</code></pre><p>Computes a minimal subset of constraints such that the model with the other constraint removed is still infeasible.</p><p>Some solvers call a set of conflicting constraints an Irreducible Inconsistent Subsystem (IIS).</p><p>See also <a href="#MathOptInterface.ConflictStatus"><code>ConflictStatus</code></a> and <a href="#MathOptInterface.ConstraintConflictStatus"><code>ConstraintConflictStatus</code></a>.</p><p><strong>Note</strong></p><p>If the model is modified after a call to <code>compute_conflict!</code>, the implementor is not obliged to purge the conflict. Any calls to the above attributes may return values for the original conflict without a warning. Similarly, when modifying the model, the conflict can be discarded.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictStatus" href="#MathOptInterface.ConflictStatus"><code>MathOptInterface.ConflictStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConflictStatus()</code></pre><p>A model attribute for the <a href="#MathOptInterface.ConflictStatusCode"><code>ConflictStatusCode</code></a> explaining why the conflict refiner stopped when computing the conflict.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictStatusCode" href="#MathOptInterface.ConflictStatusCode"><code>MathOptInterface.ConflictStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConflictStatusCode</code></pre><p>An Enum of possible values for the <code>ConflictStatus</code> attribute. This attribute is meant to explain the reason why the conflict finder stopped executing in the most recent call to <a href="#MathOptInterface.compute_conflict!"><code>compute_conflict!</code></a>.</p><p>Possible values are:</p><ul><li><code>COMPUTE_CONFLICT_NOT_CALLED</code>: the function <a href="#MathOptInterface.compute_conflict!"><code>compute_conflict!</code></a> has not yet been called</li><li><code>NO_CONFLICT_EXISTS</code>: there is no conflict because the problem is feasible</li><li><code>NO_CONFLICT_FOUND</code>: the solver could not find a conflict</li><li><code>CONFLICT_FOUND</code>: at least one conflict could be found</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConstraintConflictStatus" href="#MathOptInterface.ConstraintConflictStatus"><code>MathOptInterface.ConstraintConflictStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstraintConflictStatus()</code></pre><p>A constraint attribute indicating whether the constraint participates in the conflict. Its type is <a href="#MathOptInterface.ConflictParticipationStatusCode"><code>ConflictParticipationStatusCode</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictParticipationStatusCode" href="#MathOptInterface.ConflictParticipationStatusCode"><code>MathOptInterface.ConflictParticipationStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConflictParticipationStatusCode</code></pre><p>An Enum of possible values for the <a href="#MathOptInterface.ConstraintConflictStatus"><code>ConstraintConflictStatus</code></a> attribute. This attribute is meant to indicate whether a given constraint participates or not in the last computed conflict.</p><p>Possible values are:</p><ul><li><code>NOT_IN_CONFLICT</code>: the constraint does not participate in the conflict</li><li><code>IN_CONFLICT</code>: the constraint participates in the conflict</li><li><code>MAYBE_IN_CONFLICT</code>: the constraint may participate in the conflict, the solver was not able to prove that the constraint can be excluded from the conflict</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L13">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../standard_form/">« Standard form</a><a class="docs-footer-nextpage" href="../variables/">Variables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 9 May 2021 21:40">Sunday 9 May 2021</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
