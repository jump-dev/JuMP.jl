<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · JuMP</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuMP logo"/></a><div class="docs-package-name"><span class="docs-autofit">JuMP</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../installation/">Installation Guide</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/Getting started/an_introduction_to_julia/">Getting started with Julia</a></li><li><a class="tocitem" href="../../tutorials/Getting started/getting_started_with_JuMP/">Getting started with JuMP</a></li><li><a class="tocitem" href="../../tutorials/Getting started/performance_tips/">Performance tips</a></li><li><a class="tocitem" href="../../tutorials/Getting started/solvers_and_solutions/">Solvers and Solutions</a></li><li><a class="tocitem" href="../../tutorials/Getting started/variables_constraints_objective/">Variables, constraints, and objective functions</a></li><li><a class="tocitem" href="../../tutorials/Getting started/working_with_data_files/">Working with Data Files</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Mixed-integer linear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/cutting_stock_column_generation/">Cutting stock</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/diet/">The diet problem</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/finance/">Finance</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/geographic_clustering/">Geographical Clustering</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/knapsack/">The knapsack problem</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/n-queens/">N-Queens</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/network_flows/">Network Flows</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/power_systems/">Power Systems</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/prod/">The workforce scheduling problem</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/steelT3/">The SteelT3 problem</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/sudoku/">Sudoku</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/transp/">The transportation problem</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/urban_plan/">The urban planning problem</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Nonlinear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/Nonlinear programs/clnlbeam/">The clnlbeam problem</a></li><li><a class="tocitem" href="../../tutorials/Nonlinear programs/mle/">Maximum likelihood estimation</a></li><li><a class="tocitem" href="../../tutorials/Nonlinear programs/nlp_tricks/">Nonlinear tips and tricks</a></li><li><a class="tocitem" href="../../tutorials/Nonlinear programs/rocket_control/">Rocket Control</a></li><li><a class="tocitem" href="../../tutorials/Nonlinear programs/rosenbrock/">The Rosenbrock function</a></li><li><a class="tocitem" href="../../tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/">Space Shuttle Reentry Trajectory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Quadratic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/Quadratic programs/portfolio/">Portfolio Optimization</a></li><li><a class="tocitem" href="../../tutorials/Quadratic programs/qcp/">Quadratically constrained programs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Conic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/Conic programs/logistic_regression/">Logistic Regression</a></li><li><a class="tocitem" href="../../tutorials/Conic programs/tips_and_tricks/">Tips and Tricks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-6" type="checkbox"/><label class="tocitem" for="menuitem-3-6"><span class="docs-label">Semidefinite programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/Semidefinite programs/cluster/">K-means clustering via SDP</a></li><li><a class="tocitem" href="../../tutorials/Semidefinite programs/corr_sdp/">The correlation problem</a></li><li><a class="tocitem" href="../../tutorials/Semidefinite programs/experiment_design/">Experiment Design</a></li><li><a class="tocitem" href="../../tutorials/Semidefinite programs/max_cut_sdp/">SDP relaxations: max-cut</a></li><li><a class="tocitem" href="../../tutorials/Semidefinite programs/min_distortion/">The minimum distortion problem</a></li><li><a class="tocitem" href="../../tutorials/Semidefinite programs/min_ellipse/">Minimum ellipses</a></li><li><a class="tocitem" href="../../tutorials/Semidefinite programs/robust_uncertainty/">Robust uncertainty sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Optimization concepts</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/Optimization concepts/benders_decomposition/">Benders Decomposition</a></li><li><a class="tocitem" href="../../tutorials/Optimization concepts/benders_lazy_constraints/">Benders Decomposition (Lazy Constraints)</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/models/">Models</a></li><li><a class="tocitem" href="../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../manual/expressions/">Expressions</a></li><li><a class="tocitem" href="../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../manual/containers/">Containers</a></li><li><a class="tocitem" href="../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../manual/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../manual/callbacks/">Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/models/">Models</a></li><li><a class="tocitem" href="../../reference/variables/">Variables</a></li><li><a class="tocitem" href="../../reference/expressions/">Expressions</a></li><li><a class="tocitem" href="../../reference/objectives/">Objectives</a></li><li><a class="tocitem" href="../../reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../reference/containers/">Containers</a></li><li><a class="tocitem" href="../../reference/solutions/">Solutions</a></li><li><a class="tocitem" href="../../reference/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../reference/callbacks/">Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background information</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/should_i_use/">Should I use JuMP?</a></li><li><a class="tocitem" href="../../background/algebraic_modeling_languages/">Algebraic modeling languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../developers/extensions/">Extensions</a></li><li><a class="tocitem" href="../../developers/style/">Style Guide</a></li><li><a class="tocitem" href="../../developers/roadmap/">Roadmap</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox" checked/><label class="tocitem" for="menuitem-8"><span class="docs-label">MathOptInterface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manual/basic_usage/">Basic usage</a></li><li><a class="tocitem" href="../manual/advanced_usage/">Advanced usage</a></li><li><a class="tocitem" href="../manual/implementing/">Implementing a solver interface</a></li><li><a class="tocitem" href="../manual/Benchmarks/">The <code>Benchmarks</code> submodule</a></li><li><a class="tocitem" href="../manual/Bridges/">The <code>Bridges</code> submodule</a></li><li><a class="tocitem" href="../manual/FileFormats/">The <code>FileFormats</code> submodule</a></li><li><a class="tocitem" href="../manual/Test/">The <code>Test</code> submodule</a></li><li><a class="tocitem" href="../manual/Utilities/">The <code>Utilities</code> submodule</a></li></ul></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Attributes"><span>Attributes</span></a></li><li><a class="tocitem" href="#Model-Interface"><span>Model Interface</span></a></li><li><a class="tocitem" href="#Optimizers"><span>Optimizers</span></a></li><li><a class="tocitem" href="#Variables-and-Constraints"><span>Variables and Constraints</span></a></li><li><a class="tocitem" href="#Functions-and-function-modifications"><span>Functions and function modifications</span></a></li><li><a class="tocitem" href="#Sets"><span>Sets</span></a></li><li><a class="tocitem" href="#Modifications"><span>Modifications</span></a></li><li><a class="tocitem" href="#Nonlinear-programming-(NLP)"><span>Nonlinear programming (NLP)</span></a></li><li><a class="tocitem" href="#Errors"><span>Errors</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Bridges"><span>Bridges</span></a></li><li><a class="tocitem" href="#Copy-utilities"><span>Copy utilities</span></a></li><li><a class="tocitem" href="#Function-utilities"><span>Function utilities</span></a></li><li><a class="tocitem" href="#Constraint-utilities"><span>Constraint utilities</span></a></li><li><a class="tocitem" href="#Benchmarks"><span>Benchmarks</span></a></li><li><a class="tocitem" href="#File-Formats"><span>File Formats</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">MathOptInterface</a></li><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/moi/apireference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>[Some introduction to API. List basic standalone methods.]</p><h2 id="Attributes"><a class="docs-heading-anchor" href="#Attributes">Attributes</a><a id="Attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Attributes" title="Permalink"></a></h2><p>List of attribute categories.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractOptimizerAttribute" href="#MathOptInterface.AbstractOptimizerAttribute"><code>MathOptInterface.AbstractOptimizerAttribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractOptimizerAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the optimizer.</p><p><strong>Note</strong></p><p>The difference between <code>AbstractOptimizerAttribute</code> and <code>AbstractModelAttribute</code> lies in the behavior of <code>is_empty</code>, <code>empty!</code> and <code>copy_to</code>. Typically optimizer attributes only affect how the model is solved.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractModelAttribute" href="#MathOptInterface.AbstractModelAttribute"><code>MathOptInterface.AbstractModelAttribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractModelAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractVariableAttribute" href="#MathOptInterface.AbstractVariableAttribute"><code>MathOptInterface.AbstractVariableAttribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractVariableAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of variables in the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractConstraintAttribute" href="#MathOptInterface.AbstractConstraintAttribute"><code>MathOptInterface.AbstractConstraintAttribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractConstraintAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of constraints in the model.</p></div></section></article><p>Attributes can be set in different ways:</p><ul><li>it is either set when the model is created like <a href="#MathOptInterface.SolverName"><code>SolverName</code></a> and <a href="#MathOptInterface.RawSolver"><code>RawSolver</code></a>,</li><li>or explicitly when the model is copied like <a href="#MathOptInterface.ObjectiveSense"><code>ObjectiveSense</code></a>,</li><li>or implicitly, e.g., <a href="#MathOptInterface.NumberOfVariables"><code>NumberOfVariables</code></a> is implicitly set by <a href="#MathOptInterface.add_variable"><code>add_variable</code></a> and <a href="#MathOptInterface.ConstraintFunction"><code>ConstraintFunction</code></a> is implicitly set by <a href="#MathOptInterface.add_constraint"><code>add_constraint</code></a>.</li><li>or it is set to contain the result of the optimization during <a href="#MathOptInterface.optimize!"><code>optimize!</code></a> like <a href="#MathOptInterface.VariablePrimal"><code>VariablePrimal</code></a>.</li></ul><p>The following functions allow to distinguish between some of these different categories:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.is_set_by_optimize" href="#MathOptInterface.is_set_by_optimize"><code>MathOptInterface.is_set_by_optimize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_set_by_optimize(::AnyAttribute)</code></pre><p>Return a <code>Bool</code> indicating whether the value of the attribute is modified during an <a href="#MathOptInterface.optimize!"><code>optimize!</code></a> call, that is, the attribute is used to query the result of the optimization.</p><p><strong>Important note when defining new attributes</strong></p><p>This function returns <code>false</code> by default so it should be implemented for attributes that are modified by <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.is_copyable" href="#MathOptInterface.is_copyable"><code>MathOptInterface.is_copyable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_copyable(::AnyAttribute)</code></pre><p>Return a <code>Bool</code> indicating whether the value of the attribute may be copied during <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> using <a href="#MathOptInterface.set"><code>set</code></a>.</p><p><strong>Important note when defining new attributes</strong></p><p>By default <code>is_copyable(attr)</code> returns <code>!is_set_by_optimize(attr)</code>. A specific method should be defined for attributes which are copied indirectly during <a href="#MathOptInterface.copy_to"><code>copy_to</code></a>. For instance, both <code>is_copyable</code> and <a href="#MathOptInterface.is_set_by_optimize"><code>is_set_by_optimize</code></a> return <code>false</code> for the following attributes:</p><ul><li><a href="#MathOptInterface.ListOfOptimizerAttributesSet"><code>ListOfOptimizerAttributesSet</code></a>, <a href="#MathOptInterface.ListOfModelAttributesSet"><code>ListOfModelAttributesSet</code></a>, <a href="#MathOptInterface.ListOfConstraintAttributesSet"><code>ListOfConstraintAttributesSet</code></a> and <a href="#MathOptInterface.ListOfVariableAttributesSet"><code>ListOfVariableAttributesSet</code></a>.</li><li><a href="#MathOptInterface.SolverName"><code>SolverName</code></a> and <a href="#MathOptInterface.RawSolver"><code>RawSolver</code></a>: these attributes cannot be set.</li><li><a href="#MathOptInterface.NumberOfVariables"><code>NumberOfVariables</code></a> and <a href="#MathOptInterface.ListOfVariableIndices"><code>ListOfVariableIndices</code></a>: these attributes are set indirectly by <a href="#MathOptInterface.add_variable"><code>add_variable</code></a> and <a href="#MathOptInterface.add_variables"><code>add_variables</code></a>.</li><li><a href="#MathOptInterface.ObjectiveFunctionType"><code>ObjectiveFunctionType</code></a>: this attribute is set indirectly when setting the <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a> attribute.</li><li><a href="#MathOptInterface.NumberOfConstraints"><code>NumberOfConstraints</code></a>, <a href="#MathOptInterface.ListOfConstraintIndices"><code>ListOfConstraintIndices</code></a>, <a href="#MathOptInterface.ListOfConstraints"><code>ListOfConstraints</code></a>, <a href="#MathOptInterface.CanonicalConstraintFunction"><code>CanonicalConstraintFunction</code></a>, <a href="#MathOptInterface.ConstraintFunction"><code>ConstraintFunction</code></a> and <a href="#MathOptInterface.ConstraintSet"><code>ConstraintSet</code></a>: these attributes are set indirectly by <a href="#MathOptInterface.add_constraint"><code>add_constraint</code></a> and <a href="#MathOptInterface.add_constraints"><code>add_constraints</code></a>.</li></ul></div></section></article><p>Functions for getting and setting attributes.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.get" href="#MathOptInterface.get"><code>MathOptInterface.get</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute)</code></pre><p>Return an attribute <code>attr</code> of the optimizer <code>optimizer</code>.</p><pre><code class="language-none">get(model::ModelLike, attr::AbstractModelAttribute)</code></pre><p>Return an attribute <code>attr</code> of the model <code>model</code>.</p><pre><code class="language-none">get(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex)</code></pre><p>If the attribute <code>attr</code> is set for the variable <code>v</code> in the model <code>model</code>, return its value, return <code>nothing</code> otherwise. If the attribute <code>attr</code> is not supported by <code>model</code> then an error should be thrown instead of returning <code>nothing</code>.</p><pre><code class="language-none">get(model::ModelLike, attr::AbstractVariableAttribute, v::Vector{VariableIndex})</code></pre><p>Return a vector of attributes corresponding to each variable in the collection <code>v</code> in the model <code>model</code>.</p><pre><code class="language-none">get(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex)</code></pre><p>If the attribute <code>attr</code> is set for the constraint <code>c</code> in the model <code>model</code>, return its value, return <code>nothing</code> otherwise. If the attribute <code>attr</code> is not supported by <code>model</code> then an error should be thrown instead of returning <code>nothing</code>.</p><pre><code class="language-none">get(model::ModelLike, attr::AbstractConstraintAttribute, c::Vector{ConstraintIndex{F,S}})</code></pre><p>Return a vector of attributes corresponding to each constraint in the collection <code>c</code> in the model <code>model</code>.</p><pre><code class="language-none">get(model::ModelLike, ::Type{VariableIndex}, name::String)</code></pre><p>If a variable with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. Errors if two variables have the same name.</p><pre><code class="language-none">get(model::ModelLike, ::Type{ConstraintIndex{F,S}}, name::String) where {F&lt;:AbstractFunction,S&lt;:AbstractSet}</code></pre><p>If an <code>F</code>-in-<code>S</code> constraint with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. Errors if two constraints have the same name.</p><pre><code class="language-none">get(model::ModelLike, ::Type{ConstraintIndex}, name::String)</code></pre><p>If <em>any</em> constraint with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. This version is available for convenience but may incur a performance penalty because it is not type stable. Errors if two constraints have the same name.</p><p><strong>Examples</strong></p><pre><code class="language-julia">get(model, ObjectiveValue())
get(model, VariablePrimal(), ref)
get(model, VariablePrimal(5), [ref1, ref2])
get(model, OtherAttribute(&quot;something specific to cplex&quot;))
get(model, VariableIndex, &quot;var1&quot;)
get(model, ConstraintIndex{ScalarAffineFunction{Float64},LessThan{Float64}}, &quot;con1&quot;)
get(model, ConstraintIndex, &quot;con1&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.get!" href="#MathOptInterface.get!"><code>MathOptInterface.get!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get!(output, model::ModelLike, args...)</code></pre><p>An in-place version of <code>get</code>. The signature matches that of <code>get</code> except that the the result is placed in the vector <code>output</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.set" href="#MathOptInterface.set"><code>MathOptInterface.set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the optimizer <code>optimizer</code>.</p><pre><code class="language-none">set(model::ModelLike, attr::AbstractModelAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the model <code>model</code>.</p><pre><code class="language-none">set(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of variable <code>v</code> in model <code>model</code>.</p><pre><code class="language-none">set(model::ModelLike, attr::AbstractVariableAttribute, v::Vector{VariableIndex}, vector_of_values)</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each variable in the collection <code>v</code> in model <code>model</code>.</p><pre><code class="language-none">set(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex, value)</code></pre><p>Assign a value to the attribute <code>attr</code> of constraint <code>c</code> in model <code>model</code>.</p><pre><code class="language-none">set(model::ModelLike, attr::AbstractConstraintAttribute, c::Vector{ConstraintIndex{F,S}}, vector_of_values)</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each constraint in the collection <code>c</code> in model <code>model</code>.</p><p>An <a href="#MathOptInterface.UnsupportedAttribute"><code>UnsupportedAttribute</code></a> error is thrown if <code>model</code> does not support the attribute <code>attr</code> (see <a href="#MathOptInterface.supports"><code>supports</code></a>) and a <a href="#MathOptInterface.SetAttributeNotAllowed"><code>SetAttributeNotAllowed</code></a> error is thrown if it supports the attribute <code>attr</code> but it cannot be set.</p><p><strong>Replace set in a constraint</strong></p><pre><code class="language-none">set(model::ModelLike, ::ConstraintSet, c::ConstraintIndex{F,S}, set::S)</code></pre><p>Change the set of constraint <code>c</code> to the new set <code>set</code> which should be of the same type as the original set.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintIndex{F,Interval}</code></p><pre><code class="language-julia">set(model, ConstraintSet(), c, Interval(0, 5))
set(model, ConstraintSet(), c, GreaterThan(0.0))  # Error</code></pre><p><strong>Replace function in a constraint</strong></p><pre><code class="language-none">set(model::ModelLike, ::ConstraintFunction, c::ConstraintIndex{F,S}, func::F)</code></pre><p>Replace the function in constraint <code>c</code> with <code>func</code>. <code>F</code> must match the original function type used to define the constraint.</p><p><strong>Note</strong></p><p>Setting the constraint function is not allowed if <code>F</code> is <a href="#MathOptInterface.SingleVariable"><code>SingleVariable</code></a>, it throws a <a href="#MathOptInterface.SettingSingleVariableFunctionNotAllowed"><code>SettingSingleVariableFunctionNotAllowed</code></a> error. Indeed, it would require changing the index <code>c</code> as the index of <code>SingleVariable</code> constraints should be the same as the index of the variable.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintIndex{ScalarAffineFunction,S}</code> and <code>v1</code> and <code>v2</code> are <code>VariableIndex</code> objects,</p><pre><code class="language-julia">set(model, ConstraintFunction(), c,
    ScalarAffineFunction(ScalarAffineTerm.([1.0, 2.0], [v1, v2]), 5.0))
set(model, ConstraintFunction(), c, SingleVariable(v1)) # Error</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.supports" href="#MathOptInterface.supports"><code>MathOptInterface.supports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">supports(model::ModelLike, sub::AbstractSubmittable)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the submittable <code>sub</code>.</p><pre><code class="language-none">supports(model::ModelLike, attr::AbstractOptimizerAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the optimizer attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> shows a warning in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfOptimizerAttributesSet"><code>ListOfOptimizerAttributesSet</code></a> of <code>src</code>; see <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> for more details on how unsupported optimizer attributes are handled in copy.</p><pre><code class="language-none">supports(model::ModelLike, attr::AbstractModelAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the model attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfModelAttributesSet"><code>ListOfModelAttributesSet</code></a> of <code>src</code>.</p><pre><code class="language-none">supports(model::ModelLike, attr::AbstractVariableAttribute, ::Type{VariableIndex})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the variable attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfVariableAttributesSet"><code>ListOfVariableAttributesSet</code></a> of <code>src</code>.</p><pre><code class="language-none">supports(model::ModelLike, attr::AbstractConstraintAttribute, ::Type{ConstraintIndex{F,S}})::Bool where {F,S}</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the constraint attribute <code>attr</code> applied to an <code>F</code>-in-<code>S</code> constraint. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfConstraintAttributesSet"><code>ListOfConstraintAttributesSet</code></a> of <code>src</code>.</p><p>For all five methods, if the attribute is only not supported in specific circumstances, it should still return <code>true</code>.</p><p>Note that <code>supports</code> is only defined for attributes for which <a href="#MathOptInterface.is_copyable"><code>is_copyable</code></a> returns <code>true</code> as other attributes do not appear in the list of attributes set obtained by <code>ListOf...AttributesSet</code>.</p></div></section></article><h3 id="Fallbacks"><a class="docs-heading-anchor" href="#Fallbacks">Fallbacks</a><a id="Fallbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Fallbacks" title="Permalink"></a></h3><p>The value of some attributes can be inferred from the value of other attributes. For instance, the value of <a href="#MathOptInterface.ObjectiveValue"><code>ObjectiveValue</code></a> can be computed using <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a> and <a href="#MathOptInterface.VariablePrimal"><code>VariablePrimal</code></a>. When a solver gives access to the objective value, it is better to return this value but otherwise, <a href="#MathOptInterface.Utilities.get_fallback"><code>Utilities.get_fallback</code></a> can be used.</p><pre><code class="language-julia">function MOI.get(optimizer::Optimizer, attr::MOI.ObjectiveValue)
    return MOI.Utilities.get_fallback(optimizer, attr)
end</code></pre><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.get_fallback" href="#MathOptInterface.Utilities.get_fallback"><code>MathOptInterface.Utilities.get_fallback</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_fallback(model::MOI.ModelLike, ::MOI.ObjectiveValue)</code></pre><p>Compute the objective function value using the <code>VariablePrimal</code> results and the <code>ObjectiveFunction</code> value.</p></div></section><section><div><pre><code class="language-none">get_fallback(model::MOI.ModelLike, ::MOI.DualObjectiveValue, T::Type)::T</code></pre><p>Compute the dual objective value of type <code>T</code> using the <code>ConstraintDual</code> results and the <code>ConstraintFunction</code> and <code>ConstraintSet</code> values. Note that the nonlinear part of the model is ignored.</p></div></section><section><div><pre><code class="language-none">get_fallback(model::MOI.ModelLike, ::MOI.ConstraintPrimal,
             constraint_index::MOI.ConstraintIndex)</code></pre><p>Compute the value of the function of the constraint of index <code>constraint_index</code> using the <code>VariablePrimal</code> results and the <code>ConstraintFunction</code> values.</p></div></section><section><div><pre><code class="language-none">get_fallback(model::MOI.ModelLike, attr::MOI.ConstraintDual,
             ci::MOI.ConstraintIndex{Union{MOI.SingleVariable,
                                           MOI.VectorOfVariables}})</code></pre><p>Compute the dual of the constraint of index <code>ci</code> using the <code>ConstraintDual</code> of other constraints and the <code>ConstraintFunction</code> values. Throws an error if some constraints are quadratic or if there is one another <code>MOI.SingleVariable</code>-in-<code>S</code> or <code>MOI.VectorOfVariables</code>-in-<code>S</code> constraint with one of the variables in the function of the constraint <code>ci</code>.</p></div></section></article><h3 id="Submit"><a class="docs-heading-anchor" href="#Submit">Submit</a><a id="Submit-1"></a><a class="docs-heading-anchor-permalink" href="#Submit" title="Permalink"></a></h3><p>Objects may be submitted to an optimizer using <a href="#MathOptInterface.submit"><code>submit</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractSubmittable" href="#MathOptInterface.AbstractSubmittable"><code>MathOptInterface.AbstractSubmittable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractSubmittable</code></pre><p>Abstract supertype for objects that can be submitted to the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.submit" href="#MathOptInterface.submit"><code>MathOptInterface.submit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">submit(optimizer::AbstractOptimizer, sub::AbstractSubmittable,
       values...)::Nothing</code></pre><p>Submit <code>values</code> to the submittable <code>sub</code> of the optimizer <code>optimizer</code>.</p><p>An <a href="#MathOptInterface.UnsupportedSubmittable"><code>UnsupportedSubmittable</code></a> error is thrown if <code>model</code> does not support the attribute <code>attr</code> (see <a href="#MathOptInterface.supports"><code>supports</code></a>) and a <a href="#MathOptInterface.SubmitNotAllowed"><code>SubmitNotAllowed</code></a> error is thrown if it supports the submittable <code>sub</code> but it cannot be submitted.</p></div></section></article><p>List of submittables</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.LazyConstraint" href="#MathOptInterface.LazyConstraint"><code>MathOptInterface.LazyConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LazyConstraint(callback_data)</code></pre><p>Lazy constraint <code>func</code>-in-<code>set</code> submitted as <code>func, set</code>. The optimal solution returned by <a href="#MathOptInterface.VariablePrimal"><code>VariablePrimal</code></a> will satisfy all lazy constraints that have been submitted.</p><p>This can be submitted only from the <a href="#MathOptInterface.LazyConstraintCallback"><code>LazyConstraintCallback</code></a>. The field <code>callback_data</code> is a solver-specific callback type that is passed as the argument to the feasible solution callback.</p><p><strong>Examples</strong></p><p>Suppose <code>fx = MOI.SingleVariable(x)</code> and <code>fx = MOI.SingleVariable(y)</code> where <code>x</code> and <code>y</code> are <a href="#MathOptInterface.VariableIndex"><code>VariableIndex</code></a>s of <code>optimizer</code>. To add a <code>LazyConstraint</code> for <code>2x + 3y &lt;= 1</code>, write</p><pre><code class="language-julia">func = 2.0fx + 3.0fy
set = MOI.LessThan(1.0)
MOI.submit(optimizer, MOI.LazyConstraint(callback_data), func, set)</code></pre><p>inside a <a href="#MathOptInterface.LazyConstraintCallback"><code>LazyConstraintCallback</code></a> of data <code>callback_data</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.HeuristicSolutionStatus" href="#MathOptInterface.HeuristicSolutionStatus"><code>MathOptInterface.HeuristicSolutionStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HeuristicSolutionStatus</code></pre><p>An Enum of possible return values for <a href="#MathOptInterface.submit"><code>submit</code></a> with <a href="#MathOptInterface.HeuristicSolution"><code>HeuristicSolution</code></a>. This informs whether the heuristic solution was accepted or rejected. Possible values are:</p><ul><li><code>HEURISTIC_SOLUTION_ACCEPTED</code>: The heuristic solution was accepted.</li><li><code>HEURISTIC_SOLUTION_REJECTED</code>: The heuristic solution was rejected.</li><li><code>HEURISTIC_SOLUTION_UNKNOWN</code>: No information available on the acceptance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.HeuristicSolution" href="#MathOptInterface.HeuristicSolution"><code>MathOptInterface.HeuristicSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HeuristicSolution(callback_data)</code></pre><p>Heuristically obtained feasible solution. The solution is submitted as <code>variables, values</code> where <code>values[i]</code> gives the value of <code>variables[i]</code>, similarly to <a href="#MathOptInterface.set"><code>set</code></a>. The <a href="#MathOptInterface.submit"><code>submit</code></a> call returns a <a href="#MathOptInterface.HeuristicSolutionStatus"><code>HeuristicSolutionStatus</code></a> indicating whether the provided solution was accepted or rejected.</p><p>This can be submitted only from the <a href="#MathOptInterface.HeuristicCallback"><code>HeuristicCallback</code></a>. The field <code>callback_data</code> is a solver-specific callback type that is passed as the argument to the heuristic callback.</p><p>Some solvers require a complete solution, others only partial solutions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.UserCut" href="#MathOptInterface.UserCut"><code>MathOptInterface.UserCut</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UserCut(callback_data)</code></pre><p>Constraint <code>func</code>-to-<code>set</code> suggested to help the solver detect the solution given by <a href="#MathOptInterface.CallbackVariablePrimal"><code>CallbackVariablePrimal</code></a> as infeasible. The cut is submitted as <code>func, set</code>. Typically <a href="#MathOptInterface.CallbackVariablePrimal"><code>CallbackVariablePrimal</code></a> will violate integrality constraints, and a cut would be of the form <a href="#MathOptInterface.ScalarAffineFunction"><code>ScalarAffineFunction</code></a>-in-<a href="#MathOptInterface.LessThan"><code>LessThan</code></a> or <a href="#MathOptInterface.ScalarAffineFunction"><code>ScalarAffineFunction</code></a>-in-<a href="#MathOptInterface.GreaterThan"><code>GreaterThan</code></a>. Note that, as opposed to <a href="#MathOptInterface.LazyConstraint"><code>LazyConstraint</code></a>, the provided constraint cannot modify the feasible set, the constraint should be redundant, e.g., it may be a consequence of affine and integrality constraints.</p><p>This can be submitted only from the <a href="#MathOptInterface.UserCutCallback"><code>UserCutCallback</code></a>. The field <code>callback_data</code> is a solver-specific callback type that is passed as the argument to the infeasible solution callback.</p><p>Note that the solver may silently ignore the provided constraint.</p></div></section></article><h2 id="Model-Interface"><a class="docs-heading-anchor" href="#Model-Interface">Model Interface</a><a id="Model-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ModelLike" href="#MathOptInterface.ModelLike"><code>MathOptInterface.ModelLike</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ModelLike</code></pre><p>Abstract supertype for objects that implement the &quot;Model&quot; interface for defining an optimization problem.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.is_empty" href="#MathOptInterface.is_empty"><code>MathOptInterface.is_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_empty(model::ModelLike)</code></pre><p>Returns <code>false</code> if the <code>model</code> has any model attribute set or has any variables or constraints. Note that an empty model can have optimizer attributes set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.empty!" href="#MathOptInterface.empty!"><code>MathOptInterface.empty!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">empty!(model::ModelLike)</code></pre><p>Empty the model, that is, remove all variables, constraints and model attributes but not optimizer attributes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.write_to_file" href="#MathOptInterface.write_to_file"><code>MathOptInterface.write_to_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_to_file(model::ModelLike, filename::String)</code></pre><p>Writes the current model data to the given file. Supported file types depend on the model type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.read_from_file" href="#MathOptInterface.read_from_file"><code>MathOptInterface.read_from_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_from_file(model::ModelLike, filename::String)</code></pre><p>Read the file <code>filename</code> into the model <code>model</code>. If <code>model</code> is non-empty, this may throw an error.</p><p>Supported file types depend on the model type.</p><p><strong>Note</strong></p><p>Once the contents of the file are loaded into the model, users can query the variables via <code>get(model, ListOfVariableIndices())</code>. However, some filetypes, such as LP files, do not maintain an explicit ordering of the variables. Therefore, the returned list may be in an arbitrary order. To avoid depending on the order of the indices, users should look up each variable index by name: <code>get(model, VariableIndex, &quot;name&quot;)</code>.</p></div></section></article><p>Copying</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.copy_to" href="#MathOptInterface.copy_to"><code>MathOptInterface.copy_to</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">copy_to(dest::ModelLike, src::ModelLike; copy_names=true, warn_attributes=true)</code></pre><p>Copy the model from <code>src</code> into <code>dest</code>. The target <code>dest</code> is emptied, and all previous indices to variables or constraints in <code>dest</code> are invalidated. Returns a dictionary-like object that translates variable and constraint indices from the <code>src</code> model to the corresponding indices in the <code>dest</code> model.</p><p>If <code>copy_names</code> is <code>false</code>, the <code>Name</code>, <code>VariableName</code> and <code>ConstraintName</code> attributes are not copied even if they are set in <code>src</code>. If a constraint that is copied from <code>src</code> is not supported by <code>dest</code> then an <a href="#MathOptInterface.UnsupportedConstraint"><code>UnsupportedConstraint</code></a> error is thrown. Similarly, if a model, variable or constraint attribute that is copied from <code>src</code> is not supported by <code>dest</code> then an <a href="#MathOptInterface.UnsupportedAttribute"><code>UnsupportedAttribute</code></a> error is thrown. Unsupported <em>optimizer</em> attributes are treated differently:</p><ul><li>If <code>warn_attributes</code> is <code>true</code>, a warning is displayed, otherwise,</li><li>the attribute is silently ignored.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia"># Given empty `ModelLike` objects `src` and `dest`.

x = add_variable(src)

is_valid(src, x)   # true
is_valid(dest, x)  # false (`dest` has no variables)

index_map = copy_to(dest, src)
is_valid(dest, x) # false (unless index_map[x] == x)
is_valid(dest, index_map[x]) # true</code></pre></div></section></article><p>List of model attributes</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Name" href="#MathOptInterface.Name"><code>MathOptInterface.Name</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Name()</code></pre><p>A model attribute for the string identifying the model. It has a default value of <code>&quot;&quot;</code> if not set`.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveSense" href="#MathOptInterface.ObjectiveSense"><code>MathOptInterface.ObjectiveSense</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ObjectiveSense()</code></pre><p>A model attribute for the objective sense of the objective function, which must be an <code>OptimizationSense</code>: <code>MIN_SENSE</code>, <code>MAX_SENSE</code>, or <code>FEASIBILITY_SENSE</code>. The default is <code>FEASIBILITY_SENSE</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NumberOfVariables" href="#MathOptInterface.NumberOfVariables"><code>MathOptInterface.NumberOfVariables</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NumberOfVariables()</code></pre><p>A model attribute for the number of variables in the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfVariableIndices" href="#MathOptInterface.ListOfVariableIndices"><code>MathOptInterface.ListOfVariableIndices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ListOfVariableIndices()</code></pre><p>A model attribute for the <code>Vector{VariableIndex}</code> of all variable indices present in the model (i.e., of length equal to the value of <code>NumberOfVariables()</code>) in the order in which they were added.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfConstraints" href="#MathOptInterface.ListOfConstraints"><code>MathOptInterface.ListOfConstraints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ListOfConstraints()</code></pre><p>A model attribute for the list of tuples of the form <code>(F,S)</code>, where <code>F</code> is a function type and <code>S</code> is a set type indicating that the attribute <code>NumberOfConstraints{F,S}()</code> has value greater than zero.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NumberOfConstraints" href="#MathOptInterface.NumberOfConstraints"><code>MathOptInterface.NumberOfConstraints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NumberOfConstraints{F,S}()</code></pre><p>A model attribute for the number of constraints of the type <code>F</code>-in-<code>S</code> present in the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfConstraintIndices" href="#MathOptInterface.ListOfConstraintIndices"><code>MathOptInterface.ListOfConstraintIndices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ListOfConstraintIndices{F,S}()</code></pre><p>A model attribute for the <code>Vector{ConstraintIndex{F,S}}</code> of all constraint indices of type <code>F</code>-in-<code>S</code> in the model (i.e., of length equal to the value of <code>NumberOfConstraints{F,S}()</code>) in the order in which they were added.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfOptimizerAttributesSet" href="#MathOptInterface.ListOfOptimizerAttributesSet"><code>MathOptInterface.ListOfOptimizerAttributesSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ListOfOptimizerAttributesSet()</code></pre><p>An optimizer attribute for the <code>Vector{AbstractOptimizerAttribute}</code> of all optimizer attributes that were set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfModelAttributesSet" href="#MathOptInterface.ListOfModelAttributesSet"><code>MathOptInterface.ListOfModelAttributesSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ListOfModelAttributesSet()</code></pre><p>A model attribute for the <code>Vector{AbstractModelAttribute}</code> of all model attributes <code>attr</code> such that 1) <code>is_copyable(attr)</code> returns <code>true</code> and 2) the attribute was set to the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfVariableAttributesSet" href="#MathOptInterface.ListOfVariableAttributesSet"><code>MathOptInterface.ListOfVariableAttributesSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ListOfVariableAttributesSet()</code></pre><p>A model attribute for the <code>Vector{AbstractVariableAttribute}</code> of all variable attributes <code>attr</code> such that 1) <code>is_copyable(attr)</code> returns <code>true</code> and 2) the attribute was set to variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfConstraintAttributesSet" href="#MathOptInterface.ListOfConstraintAttributesSet"><code>MathOptInterface.ListOfConstraintAttributesSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ListOfConstraintAttributesSet{F, S}()</code></pre><p>A model attribute for the <code>Vector{AbstractConstraintAttribute}</code> of all constraint attributes <code>attr</code> such that 1) <code>is_copyable(attr)</code> returns <code>true</code> and</p><ol><li>the attribute was set to <code>F</code>-in-<code>S</code> constraints.</li></ol><p><strong>Note</strong></p><p>The attributes <a href="#MathOptInterface.ConstraintFunction"><code>ConstraintFunction</code></a> and <a href="#MathOptInterface.ConstraintSet"><code>ConstraintSet</code></a> should not be included in the list even if then have been set with <a href="#MathOptInterface.set"><code>set</code></a>.</p></div></section></article><h2 id="Optimizers"><a class="docs-heading-anchor" href="#Optimizers">Optimizers</a><a id="Optimizers-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractOptimizer" href="#MathOptInterface.AbstractOptimizer"><code>MathOptInterface.AbstractOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractOptimizer</code></pre><p>Abstract supertype for objects representing an instance of an optimization problem tied to a particular solver. This is typically a solver&#39;s in-memory representation. In addition to <code>ModelLike</code>, <code>AbstractOptimizer</code> objects let you solve the model and query the solution.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.optimize!" href="#MathOptInterface.optimize!"><code>MathOptInterface.optimize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">optimize!(optimizer::AbstractOptimizer)</code></pre><p>Start the solution procedure.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.OptimizerWithAttributes" href="#MathOptInterface.OptimizerWithAttributes"><code>MathOptInterface.OptimizerWithAttributes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct OptimizerWithAttributes
    optimizer_constructor
    params::Vector{Pair{AbstractOptimizerAttribute,&lt;:Any}}
end</code></pre><p>Object grouping an optimizer constructor and a list of optimizer attributes. Instances are created with <a href="#MathOptInterface.instantiate"><code>instantiate</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.instantiate" href="#MathOptInterface.instantiate"><code>MathOptInterface.instantiate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">instantiate(optimizer_constructor,
            with_bridge_type::Union{Nothing, Type}=nothing,
            with_names::Bool=false)</code></pre><p>Creates an instance of optimizer either by calling <code>optimizer_constructor.optimizer_constructor()</code> and setting the parameters in <code>optimizer_constructor.params</code> if <code>optimizer_constructor</code> is a <a href="#MathOptInterface.OptimizerWithAttributes"><code>OptimizerWithAttributes</code></a> or by calling <code>optimizer_constructor()</code> if <code>optimizer_constructor</code> is callable.</p><p>If <code>with_bridge_type</code> is not <code>nothing</code>, it enables all the bridges defined in the MathOptInterface.Bridges submodule with coefficient type <code>with_bridge_type</code>.</p><p>If the optimizer created by <code>optimizer_constructor</code> does not support loading the problem incrementally or does not support names and <code>with_names</code> is <code>true</code> (see <a href="#MathOptInterface.Utilities.supports_default_copy_to"><code>Utilities.supports_default_copy_to</code></a>) then a <a href="#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a> is added to store a cache of the bridged model. Hence set <code>with_names</code> to <code>true</code> if names might be set.</p></div></section></article><p>List of optimizers attributes</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SolverName" href="#MathOptInterface.SolverName"><code>MathOptInterface.SolverName</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SolverName()</code></pre><p>An optimizer attribute for the string identifying the solver/optimizer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Silent" href="#MathOptInterface.Silent"><code>MathOptInterface.Silent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Silent()</code></pre><p>An optimizer attribute for silencing the output of an optimizer. When <code>set</code> to <code>true</code>, it takes precedence over any other attribute controlling verbosity and requires the solver to produce no output. The default value is <code>false</code> which has no effect. In this case the verbosity is controlled by other attributes.</p><p><strong>Note</strong></p><p>Every optimizer should have verbosity on by default. For instance, if a solver has a solver-specific log level attribute, the MOI implementation should set it to <code>1</code> by default. If the user sets <code>Silent</code> to <code>true</code>, then the log level should be set to <code>0</code>, even if the user specifically sets a value of log level. If the value of <code>Silent</code> is <code>false</code> then the log level set to the solver is the value given by the user for this solver-specific parameter or <code>1</code> if none is given.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.TimeLimitSec" href="#MathOptInterface.TimeLimitSec"><code>MathOptInterface.TimeLimitSec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TimeLimitSec()</code></pre><p>An optimizer attribute for setting a time limit for an optimization. When <code>set</code> to <code>nothing</code>, it deactivates the solver time limit. The default value is <code>nothing</code>. The time limit is in seconds.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RawParameter" href="#MathOptInterface.RawParameter"><code>MathOptInterface.RawParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RawParameter(name)</code></pre><p>An optimizer attribute for the solver-specific parameter identified by <code>name</code> which is typically an <code>Enum</code> or a <code>String</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NumberOfThreads" href="#MathOptInterface.NumberOfThreads"><code>MathOptInterface.NumberOfThreads</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NumberOfThreads()</code></pre><p>An optimizer attribute for setting the number of threads used for an optimization. When set to <code>nothing</code> uses solver default. Values are positive integers. The default value is <code>nothing</code>.</p></div></section></article><p>List of attributes useful for optimizers</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RawSolver" href="#MathOptInterface.RawSolver"><code>MathOptInterface.RawSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RawSolver()</code></pre><p>A model attribute for the object that may be used to access a solver-specific API for this optimizer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ResultCount" href="#MathOptInterface.ResultCount"><code>MathOptInterface.ResultCount</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ResultCount()</code></pre><p>A model attribute for the number of results available.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveFunction" href="#MathOptInterface.ObjectiveFunction"><code>MathOptInterface.ObjectiveFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ObjectiveFunction{F&lt;:AbstractScalarFunction}()</code></pre><p>A model attribute for the objective function which has a type <code>F&lt;:AbstractScalarFunction</code>. <code>F</code> should be guaranteed to be equivalent but not necessarily identical to the function type provided by the user. Throws an <code>InexactError</code> if the objective function cannot be converted to <code>F</code>, e.g. the objective function is quadratic and <code>F</code> is <code>ScalarAffineFunction{Float64}</code> or it has non-integer coefficient and <code>F</code> is <code>ScalarAffineFunction{Int}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveFunctionType" href="#MathOptInterface.ObjectiveFunctionType"><code>MathOptInterface.ObjectiveFunctionType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ObjectiveFunctionType()</code></pre><p>A model attribute for the type <code>F</code> of the objective function set using the <code>ObjectiveFunction{F}</code> attribute.</p><p><strong>Examples</strong></p><p>In the following code, <code>attr</code> should be equal to <code>MOI.SingleVariable</code>:</p><pre><code class="language-julia">x = MOI.add_variable(model)
MOI.set(model, MOI.ObjectiveFunction{MOI.SingleVariable}(),
         MOI.SingleVariable(x))
attr = MOI.get(model, MOI.ObjectiveFunctionType())</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveValue" href="#MathOptInterface.ObjectiveValue"><code>MathOptInterface.ObjectiveValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ObjectiveValue(resultidx::Int=1)</code></pre><p>A model attribute for the objective value of the <code>result_index</code>th primal result.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.DualObjectiveValue" href="#MathOptInterface.DualObjectiveValue"><code>MathOptInterface.DualObjectiveValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DualObjectiveValue(result_index::Int=1)</code></pre><p>A model attribute for the value of the objective function of the dual problem for the <code>result_index</code>th dual result.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveBound" href="#MathOptInterface.ObjectiveBound"><code>MathOptInterface.ObjectiveBound</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ObjectiveBound()</code></pre><p>A model attribute for the best known bound on the optimal objective value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RelativeGap" href="#MathOptInterface.RelativeGap"><code>MathOptInterface.RelativeGap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RelativeGap()</code></pre><p>A model attribute for the final relative optimality gap, defined as <span>$\frac{|b-f|}{|f|}$</span>, where <span>$b$</span> is the best bound and <span>$f$</span> is the best feasible objective value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SolveTime" href="#MathOptInterface.SolveTime"><code>MathOptInterface.SolveTime</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SolveTime()</code></pre><p>A model attribute for the total elapsed solution time (in seconds) as reported by the optimizer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SimplexIterations" href="#MathOptInterface.SimplexIterations"><code>MathOptInterface.SimplexIterations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimplexIterations()</code></pre><p>A model attribute for the cumulative number of simplex iterations during the optimization process. In particular, for a mixed-integer program (MIP), the total simplex iterations for all nodes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.BarrierIterations" href="#MathOptInterface.BarrierIterations"><code>MathOptInterface.BarrierIterations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BarrierIterations()</code></pre><p>A model attribute for the cumulative number of barrier iterations while solving a problem.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NodeCount" href="#MathOptInterface.NodeCount"><code>MathOptInterface.NodeCount</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NodeCount()</code></pre><p>A model attribute for the total number of branch-and-bound nodes explored while solving a mixed-integer program (MIP).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.TerminationStatus" href="#MathOptInterface.TerminationStatus"><code>MathOptInterface.TerminationStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TerminationStatus()</code></pre><p>A model attribute for the <code>TerminationStatusCode</code> explaining why the optimizer stopped.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RawStatusString" href="#MathOptInterface.RawStatusString"><code>MathOptInterface.RawStatusString</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RawStatusString()</code></pre><p>A model attribute for a solver specific string explaining why the optimizer stopped.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.PrimalStatus" href="#MathOptInterface.PrimalStatus"><code>MathOptInterface.PrimalStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PrimalStatus(N)
PrimalStatus()</code></pre><p>A model attribute for the <code>ResultStatusCode</code> of the primal result <code>N</code>. If <code>N</code> is omitted, it defaults to 1. If <code>N</code> is larger than the value of <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> then <code>NO_SOLUTION</code> is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.DualStatus" href="#MathOptInterface.DualStatus"><code>MathOptInterface.DualStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DualStatus(N)
DualStatus()</code></pre><p>A model attribute for the <code>ResultStatusCode</code> of the dual result <code>N</code>. If <code>N</code> is omitted, it defaults to 1. If <code>N</code> is larger than the value of <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> then <code>NO_SOLUTION</code> is returned.</p></div></section></article><p>Attributes relating to solver callbacks:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractCallback" href="#MathOptInterface.AbstractCallback"><code>MathOptInterface.AbstractCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractCallback &lt;: AbstractModelAttribute end</code></pre><p>Abstract type for a model attribute representing a callback function. The value set to subtypes of <code>AbstractCallback</code> is a function that may be called during <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>. As <a href="#MathOptInterface.optimize!"><code>optimize!</code></a> is in progress, the result attributes (i.e, the attributes <code>attr</code> such that <code>is_set_by_optimize(attr)</code>) may not be accessible from the callback, hence trying to get result attributes might throw a <a href="#MathOptInterface.OptimizeInProgress"><code>OptimizeInProgress</code></a> error.</p><p>At most one callback of each type can be registered. If an optimizer already has a function for a callback type, and the user registers a new function, then the old one is replaced.</p><p>The value of the attribute should be a function taking only one argument, commonly called <code>callback_data</code>, that can be used for instance in <a href="#MathOptInterface.LazyConstraintCallback"><code>LazyConstraintCallback</code></a>, <a href="#MathOptInterface.HeuristicCallback"><code>HeuristicCallback</code></a> and <a href="#MathOptInterface.UserCutCallback"><code>UserCutCallback</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.LazyConstraintCallback" href="#MathOptInterface.LazyConstraintCallback"><code>MathOptInterface.LazyConstraintCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LazyConstraintCallback() &lt;: AbstractCallback</code></pre><p>The callback can be used to reduce the feasible set given the current primal solution by submitting a <a href="#MathOptInterface.LazyConstraint"><code>LazyConstraint</code></a>. For instance, it may be called at an incumbent of a mixed-integer problem. Note that there is no guarantee that the callback is called at <em>every</em> feasible primal solution.</p><p>The current primal solution is accessed through <a href="#MathOptInterface.CallbackVariablePrimal"><code>CallbackVariablePrimal</code></a>. Trying to access other result attributes will throw <a href="#MathOptInterface.OptimizeInProgress"><code>OptimizeInProgress</code></a> as discussed in <a href="#MathOptInterface.AbstractCallback"><code>AbstractCallback</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">x = MOI.add_variables(optimizer, 8)
MOI.set(optimizer, MOI.LazyConstraintCallback(), callback_data -&gt; begin
    sol = MOI.get(optimizer, MOI.CallbackVariablePrimal(callback_data), x)
    if # should add a lazy constraint
        func = # computes function
        set = # computes set
        MOI.submit(optimizer, MOI.LazyConstraint(callback_data), func, set)
    end
end)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.HeuristicCallback" href="#MathOptInterface.HeuristicCallback"><code>MathOptInterface.HeuristicCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HeuristicCallback() &lt;: AbstractCallback</code></pre><p>The callback can be used to submit <a href="#MathOptInterface.HeuristicSolution"><code>HeuristicSolution</code></a> given the current primal solution. For instance, it may be called at fractional (i.e., non-integer) nodes in the branch and bound tree of a mixed-integer problem. Note that there is not guarantee that the callback is called <em>everytime</em> the solver has an infeasible solution.</p><p>The current primal solution is accessed through <a href="#MathOptInterface.CallbackVariablePrimal"><code>CallbackVariablePrimal</code></a>. Trying to access other result attributes will throw <a href="#MathOptInterface.OptimizeInProgress"><code>OptimizeInProgress</code></a> as discussed in <a href="#MathOptInterface.AbstractCallback"><code>AbstractCallback</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">x = MOI.add_variables(optimizer, 8)
MOI.set(optimizer, MOI.HeuristicCallback(), callback_data -&gt; begin
    sol = MOI.get(optimizer, MOI.CallbackVariablePrimal(callback_data), x)
    if # can find a heuristic solution
        values = # computes heuristic solution
        MOI.submit(optimizer, MOI.HeuristicSolution(callback_data), x,
                   values)
    end
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.UserCutCallback" href="#MathOptInterface.UserCutCallback"><code>MathOptInterface.UserCutCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UserCutCallback() &lt;: AbstractCallback</code></pre><p>The callback can be used to submit <a href="#MathOptInterface.UserCut"><code>UserCut</code></a> given the current primal solution. For instance, it may be called at fractional (i.e., non-integer) nodes in the branch and bound tree of a mixed-integer problem. Note that there is not guarantee that the callback is called <em>everytime</em> the solver has an infeasible solution.</p><p>The infeasible solution is accessed through <a href="#MathOptInterface.CallbackVariablePrimal"><code>CallbackVariablePrimal</code></a>. Trying to access other result attributes will throw <a href="#MathOptInterface.OptimizeInProgress"><code>OptimizeInProgress</code></a> as discussed in <a href="#MathOptInterface.AbstractCallback"><code>AbstractCallback</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">x = MOI.add_variables(optimizer, 8)
MOI.set(optimizer, MOI.UserCutCallback(), callback_data -&gt; begin
    sol = MOI.get(optimizer, MOI.CallbackVariablePrimal(callback_data), x)
    if # can find a user cut
        func = # computes function
        set = # computes set
        MOI.submit(optimizer, MOI.UserCut(callback_data), func, set)
    end
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.CallbackNodeStatus" href="#MathOptInterface.CallbackNodeStatus"><code>MathOptInterface.CallbackNodeStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CallbackNodeStatus(callback_data)</code></pre><p>An optimizer attribute describing the (in)feasibility of the primal solution available from <a href="#MathOptInterface.CallbackVariablePrimal"><code>CallbackVariablePrimal</code></a> during a callback identified by <code>callback_data</code>.</p><p>Returns a <a href="#MathOptInterface.CallbackNodeStatusCode"><code>CallbackNodeStatusCode</code></a> Enum.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.CallbackNodeStatusCode" href="#MathOptInterface.CallbackNodeStatusCode"><code>MathOptInterface.CallbackNodeStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CallbackNodeStatusCode</code></pre><p>An Enum of possible return values from calling <a href="#MathOptInterface.get"><code>get</code></a> with <a href="#MathOptInterface.CallbackNodeStatus"><code>CallbackNodeStatus</code></a>.</p><p>Possible values are:</p><ul><li><code>CALLBACK_NODE_STATUS_INTEGER</code>: the primal solution available from <a href="#MathOptInterface.CallbackVariablePrimal"><code>CallbackVariablePrimal</code></a> is integer feasible.</li><li><code>CALLBACK_NODE_STATUS_FRACTIONAL</code>: the primal solution available from <a href="#MathOptInterface.CallbackVariablePrimal"><code>CallbackVariablePrimal</code></a> is integer infeasible.</li><li><code>CALLBACK_NODE_STATUS_UNKNOWN</code>: the primal solution available from <a href="#MathOptInterface.CallbackVariablePrimal"><code>CallbackVariablePrimal</code></a> might be integer feasible or infeasible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.CallbackVariablePrimal" href="#MathOptInterface.CallbackVariablePrimal"><code>MathOptInterface.CallbackVariablePrimal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CallbackVariablePrimal(callback_data)</code></pre><p>A variable attribute for the assignment to some primal variable&#39;s value during the callback identified by <code>callback_data</code>.</p></div></section></article><h3 id="Termination-Status"><a class="docs-heading-anchor" href="#Termination-Status">Termination Status</a><a id="Termination-Status-1"></a><a class="docs-heading-anchor-permalink" href="#Termination-Status" title="Permalink"></a></h3><p>The <code>TerminationStatus</code> attribute indicates why the optimizer stopped executing. The value of the attribute is of type <code>TerminationStatusCode</code>.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.TerminationStatusCode" href="#MathOptInterface.TerminationStatusCode"><code>MathOptInterface.TerminationStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TerminationStatusCode</code></pre><p>An Enum of possible values for the <code>TerminationStatus</code> attribute. This attribute is meant to explain the reason why the optimizer stopped executing in the most recent call to <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>.</p><p>If no call has been made to <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>, then the <code>TerminationStatus</code> is:</p><ul><li><code>OPTIMIZE_NOT_CALLED</code>: The algorithm has not started.</li></ul><p><strong>OK</strong></p><p>These are generally OK statuses, i.e., the algorithm ran to completion normally.</p><ul><li><code>OPTIMAL</code>: The algorithm found a globally optimal solution.</li><li><code>INFEASIBLE</code>: The algorithm concluded that no feasible solution exists.</li><li><code>DUAL_INFEASIBLE</code>: The algorithm concluded that no dual bound exists for the problem. If, additionally, a feasible (primal) solution is known to exist, this status typically implies that the problem is unbounded, with some technical exceptions.</li><li><code>LOCALLY_SOLVED</code>: The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.</li><li><code>LOCALLY_INFEASIBLE</code>: The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.</li><li><code>INFEASIBLE_OR_UNBOUNDED</code>: The algorithm stopped because it decided that the problem is infeasible or unbounded; this occasionally happens during MIP presolve.</li></ul><p><strong>Solved to relaxed tolerances</strong></p><ul><li><code>ALMOST_OPTIMAL</code>: The algorithm found a globally optimal solution to relaxed tolerances.</li><li><code>ALMOST_INFEASIBLE</code>: The algorithm concluded that no feasible solution exists within relaxed tolerances.</li><li><code>ALMOST_DUAL_INFEASIBLE</code>: The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.</li><li><code>ALMOST_LOCALLY_SOLVED</code>: The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.</li></ul><p><strong>Limits</strong></p><p>The optimizer stopped because of some user-defined limit.</p><ul><li><code>ITERATION_LIMIT</code>: An iterative algorithm stopped after conducting the maximum number of iterations.</li><li><code>TIME_LIMIT</code>: The algorithm stopped after a user-specified computation time.</li><li><code>NODE_LIMIT</code>: A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.</li><li><code>SOLUTION_LIMIT</code>: The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.</li><li><code>MEMORY_LIMIT</code>: The algorithm stopped because it ran out of memory.</li><li><code>OBJECTIVE_LIMIT</code>: The algorithm stopped because it found a solution better than a minimum limit set by the user.</li><li><code>NORM_LIMIT</code>: The algorithm stopped because the norm of an iterate became too large.</li><li><code>OTHER_LIMIT</code>: The algorithm stopped due to a limit not covered by one of the above.</li></ul><p><strong>Problematic</strong></p><p>This group of statuses means that something unexpected or problematic happened.</p><ul><li><code>SLOW_PROGRESS</code>: The algorithm stopped because it was unable to continue making progress towards the solution.</li><li><code>NUMERICAL_ERROR</code>: The algorithm stopped because it encountered unrecoverable numerical error.</li><li><code>INVALID_MODEL</code>: The algorithm stopped because the model is invalid.</li><li><code>INVALID_OPTION</code>: The algorithm stopped because it was provided an invalid option.</li><li><code>INTERRUPTED</code>: The algorithm stopped because of an interrupt signal.</li><li><code>OTHER_ERROR</code>: The algorithm stopped because of an error not covered by one of the statuses defined above.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L78">source</a></section></article><h3 id="Conflict-Status"><a class="docs-heading-anchor" href="#Conflict-Status">Conflict Status</a><a id="Conflict-Status-1"></a><a class="docs-heading-anchor-permalink" href="#Conflict-Status" title="Permalink"></a></h3><p>The <code>ConflictStatus</code> attribute indicates why the conflict finder stopped executing. The value of the attribute is of type <code>ConflictStatusCode</code>.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.compute_conflict!" href="#MathOptInterface.compute_conflict!"><code>MathOptInterface.compute_conflict!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_conflict!(optimizer::AbstractOptimizer)</code></pre><p>Computes a minimal subset of constraints such that the model with the other constraint removed is still infeasible.</p><p>Some solvers call a set of conflicting constraints an Irreducible Inconsistent Subsystem (IIS).</p><p>See also <a href="#MathOptInterface.ConflictStatus"><code>ConflictStatus</code></a> and <a href="#MathOptInterface.ConstraintConflictStatus"><code>ConstraintConflictStatus</code></a>.</p><p><strong>Note</strong></p><p>If the model is modified after a call to <code>compute_conflict!</code>, the implementor is not obliged to purge the conflict. Any calls to the above attributes may return values for the original conflict without a warning. Similarly, when modifying the model, the conflict can be discarded.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictStatus" href="#MathOptInterface.ConflictStatus"><code>MathOptInterface.ConflictStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConflictStatus()</code></pre><p>A model attribute for the <a href="#MathOptInterface.ConflictStatusCode"><code>ConflictStatusCode</code></a> explaining why the conflict refiner stopped when computing the conflict.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictStatusCode" href="#MathOptInterface.ConflictStatusCode"><code>MathOptInterface.ConflictStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConflictStatusCode</code></pre><p>An Enum of possible values for the <code>ConflictStatus</code> attribute. This attribute is meant to explain the reason why the conflict finder stopped executing in the most recent call to <a href="#MathOptInterface.compute_conflict!"><code>compute_conflict!</code></a>.</p><p>Possible values are:</p><ul><li><code>COMPUTE_CONFLICT_NOT_CALLED</code>: the function <a href="#MathOptInterface.compute_conflict!"><code>compute_conflict!</code></a> has not yet been called</li><li><code>NO_CONFLICT_EXISTS</code>: there is no conflict because the problem is feasible</li><li><code>NO_CONFLICT_FOUND</code>: the solver could not find a conflict</li><li><code>CONFLICT_FOUND</code>: at least one conflict could be found</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConstraintConflictStatus" href="#MathOptInterface.ConstraintConflictStatus"><code>MathOptInterface.ConstraintConflictStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstraintConflictStatus()</code></pre><p>A constraint attribute indicating whether the constraint participates in the conflict. Its type is <a href="#MathOptInterface.ConflictParticipationStatusCode"><code>ConflictParticipationStatusCode</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictParticipationStatusCode" href="#MathOptInterface.ConflictParticipationStatusCode"><code>MathOptInterface.ConflictParticipationStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConflictParticipationStatusCode</code></pre><p>An Enum of possible values for the <a href="#MathOptInterface.ConstraintConflictStatus"><code>ConstraintConflictStatus</code></a> attribute. This attribute is meant to indicate whether a given constraint participates or not in the last computed conflict.</p><p>Possible values are:</p><ul><li><code>NOT_IN_CONFLICT</code>: the constraint does not participate in the conflict</li><li><code>IN_CONFLICT</code>: the constraint participates in the conflict</li><li><code>MAYBE_IN_CONFLICT</code>: the constraint may participate in the conflict, the solver was not able to prove that the constraint can be excluded from the conflict</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L13">source</a></section></article><h3 id="Result-Status"><a class="docs-heading-anchor" href="#Result-Status">Result Status</a><a id="Result-Status-1"></a><a class="docs-heading-anchor-permalink" href="#Result-Status" title="Permalink"></a></h3><p>The <code>PrimalStatus</code> and <code>DualStatus</code> attributes indicate how to interpret the result returned by the solver. The value of the attribute is of type <code>ResultStatusCode</code>.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ResultStatusCode" href="#MathOptInterface.ResultStatusCode"><code>MathOptInterface.ResultStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ResultStatusCode</code></pre><p>An Enum of possible values for the <code>PrimalStatus</code> and <code>DualStatus</code> attributes. The values indicate how to interpret the result vector.</p><ul><li><code>NO_SOLUTION</code>: the result vector is empty.</li><li><code>FEASIBLE_POINT</code>: the result vector is a feasible point.</li><li><code>NEARLY_FEASIBLE_POINT</code>: the result vector is feasible if some constraint tolerances are relaxed.</li><li><code>INFEASIBLE_POINT</code>: the result vector is an infeasible point.</li><li><code>INFEASIBILITY_CERTIFICATE</code>: the result vector is an infeasibility certificate. If the <code>PrimalStatus</code> is <code>INFEASIBILITY_CERTIFICATE</code>, then the primal result vector is a certificate of dual infeasibility. If the <code>DualStatus</code> is <code>INFEASIBILITY_CERTIFICATE</code>, then the dual result vector is a proof of primal infeasibility.</li><li><code>NEARLY_INFEASIBILITY_CERTIFICATE</code>: the result satisfies a relaxed criterion for a certificate of infeasibility.</li><li><code>REDUCTION_CERTIFICATE</code>: the result vector is an ill-posed certificate; see <a href="https://arxiv.org/abs/1408.4685">this article</a> for details. If the <code>PrimalStatus</code> is <code>REDUCTION_CERTIFICATE</code>, then the primal result vector is a proof that the dual problem is ill-posed. If the <code>DualStatus</code> is <code>REDUCTION_CERTIFICATE</code>, then the dual result vector is a proof that the primal is ill-posed.</li><li><code>NEARLY_REDUCTION_CERTIFICATE</code>: the result satisfies a relaxed criterion for an ill-posed certificate.</li><li><code>UNKNOWN_RESULT_STATUS</code>: the result vector contains a solution with an unknown interpretation.</li><li><code>OTHER_RESULT_STATUS</code>: the result vector contains a solution with an interpretation not covered by one of the statuses defined above.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L30">source</a></section></article><h2 id="Variables-and-Constraints"><a class="docs-heading-anchor" href="#Variables-and-Constraints">Variables and Constraints</a><a id="Variables-and-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Variables-and-Constraints" title="Permalink"></a></h2><h3 id="Basis-Status"><a class="docs-heading-anchor" href="#Basis-Status">Basis Status</a><a id="Basis-Status-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-Status" title="Permalink"></a></h3><p>The <code>BasisStatus</code> attribute of a constraint describes its status with respect to a basis, if one is known. The value of the attribute is of type <code>BasisStatusCode</code>.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.BasisStatusCode" href="#MathOptInterface.BasisStatusCode"><code>MathOptInterface.BasisStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BasisStatusCode</code></pre><p>An Enum of possible values for the <code>ConstraintBasisStatus</code> attribute, explaining the status of a given element with respect to an optimal solution basis.</p><p>Possible values are:</p><ul><li><code>BASIC</code>: element is in the basis</li><li><code>NONBASIC</code>: element is not in the basis</li><li><code>NONBASIC_AT_LOWER</code>: element is not in the basis and is at its lower bound</li><li><code>NONBASIC_AT_UPPER</code>: element is not in the basis and is at its upper bound</li><li><code>SUPER_BASIC</code>: element is not in the basis but is also not at one of its bounds</li></ul><p>Notes</p><ul><li><p><code>NONBASIC_AT_LOWER</code> and <code>NONBASIC_AT_UPPER</code> should be used only for constraints with the <code>Interval</code> set. In this case, they are necessary to distinguish which side of the constraint is active. One-sided constraints (e.g., <code>LessThan</code> and <code>GreaterThan</code>) should use <code>NONBASIC</code> instead of the <code>NONBASIC_AT_*</code> values.</p></li><li><p>In general, <code>SUPER_BASIC</code> usually occurs when the problem is nonlinear. For linear programs, <code>SUPER_BASIC</code> variables only occur if the solver returns a solution that is not at a vertex of the feasible region.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L26">source</a></section></article><h3 id="Index-types"><a class="docs-heading-anchor" href="#Index-types">Index types</a><a id="Index-types-1"></a><a class="docs-heading-anchor-permalink" href="#Index-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.VariableIndex" href="#MathOptInterface.VariableIndex"><code>MathOptInterface.VariableIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VariableIndex</code></pre><p>A type-safe wrapper for <code>Int64</code> for use in referencing variables in a model. To allow for deletion, indices need not be consecutive.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConstraintIndex" href="#MathOptInterface.ConstraintIndex"><code>MathOptInterface.ConstraintIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstraintIndex{F, S}</code></pre><p>A type-safe wrapper for <code>Int64</code> for use in referencing <code>F</code>-in-<code>S</code> constraints in a model. The parameter <code>F</code> is the type of the function in the constraint, and the parameter <code>S</code> is the type of set in the constraint. To allow for deletion, indices need not be consecutive. Indices within a constraint type (i.e. <code>F</code>-in-<code>S</code>) must be unique, but non-unique indices across different constraint types are allowed. If <code>F</code> is <a href="#MathOptInterface.SingleVariable"><code>SingleVariable</code></a> then the index is equal to the index of the variable. That is for an <code>index::ConstraintIndex{SingleVariable}</code>, we always have</p><pre><code class="language-julia">index.value == MOI.get(model, MOI.ConstraintFunction(), index).variable.value</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.is_valid" href="#MathOptInterface.is_valid"><code>MathOptInterface.is_valid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_valid(model::ModelLike, index::Index)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this index refers to a valid object in the model <code>model</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.throw_if_not_valid" href="#MathOptInterface.throw_if_not_valid"><code>MathOptInterface.throw_if_not_valid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">throw_if_not_valid(model::ModelLike, index::Index)</code></pre><p>Throw an <code>InvalidIndex(index)</code> error if <code>MOI.is_valid(model, index)</code> returns <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.delete-Tuple{MathOptInterface.ModelLike,Union{VariableIndex, ConstraintIndex}}" href="#MathOptInterface.delete-Tuple{MathOptInterface.ModelLike,Union{VariableIndex, ConstraintIndex}}"><code>MathOptInterface.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete(model::ModelLike, index::Index)</code></pre><p>Delete the referenced object from the model. Throw <a href="#MathOptInterface.DeleteNotAllowed"><code>DeleteNotAllowed</code></a> if if <code>index</code> cannot be deleted.</p><p>The following modifications also take effect if <code>Index</code> is <a href="#MathOptInterface.VariableIndex"><code>VariableIndex</code></a>:</p><ul><li>If <code>index</code> used in the objective function, it is removed from the function, i.e., it is substituted for zero.</li><li>For each <code>func</code>-in-<code>set</code> constraint of the model:<ul><li>If <code>func isa SingleVariable</code> and <code>func.variable == index</code> then the constraint is deleted.</li><li>If <code>func isa VectorOfVariables</code> and <code>index in func.variable</code> then<ul><li>if <code>length(func.variable) == 1</code> is one, the constraint is deleted;</li><li>if <code>length(func.variable) &gt; 1</code> and <code>supports_dimension_update(set)</code> then then the variable is removed from <code>func</code> and <code>set</code> is replaced by <code>update_dimension(set, MOI.dimension(set) - 1)</code>.</li><li>Otherwise, a <a href="#MathOptInterface.DeleteNotAllowed"><code>DeleteNotAllowed</code></a> error is thrown.</li></ul></li><li>Otherwise, the variable is removed from <code>func</code>, i.e., it is substituted for zero.</li></ul></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.delete-Tuple{MathOptInterface.ModelLike,Array{#s938,1} where #s938&lt;:Union{VariableIndex, ConstraintIndex}}" href="#MathOptInterface.delete-Tuple{MathOptInterface.ModelLike,Array{#s938,1} where #s938&lt;:Union{VariableIndex, ConstraintIndex}}"><code>MathOptInterface.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete(model::ModelLike, indices::Vector{R&lt;:Index}) where {R}</code></pre><p>Delete the referenced objects in the vector <code>indices</code> from the model. It may be assumed that <code>R</code> is a concrete type. The default fallback sequentially deletes the individual items in <code>indices</code>, although specialized implementations may be more efficient.</p></div></section></article><h3 id="Variables"><a class="docs-heading-anchor" href="#Variables">Variables</a><a id="Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Variables" title="Permalink"></a></h3><p><em>Free variables</em> are the variables created with <a href="#MathOptInterface.add_variable"><code>add_variable</code></a> or <a href="#MathOptInterface.add_variables"><code>add_variables</code></a> while <em>constrained variables</em> are the variables created with <a href="#MathOptInterface.add_constrained_variable"><code>add_constrained_variable</code></a> or <a href="#MathOptInterface.add_constrained_variables"><code>add_constrained_variables</code></a>. Adding constrained variables instead of constraining free variables with <a href="#MathOptInterface.add_constraint"><code>add_constraint</code></a> allows <a href="#variable_bridges">variable bridges</a> to be used. Note further that free variables that are constrained with <a href="#MathOptInterface.add_constraint"><code>add_constraint</code></a> may be copied by <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> with <a href="#MathOptInterface.add_constrained_variable"><code>add_constrained_variable</code></a> or <a href="#MathOptInterface.add_constrained_variables"><code>add_constrained_variables</code></a> by the <a href="#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a>. More precisely, the attributes do not distinguish constraints on variables created with <code>add_constrained_variable(s)</code> or <code>add_variable(s)</code>/<code>add_constraint</code>. When the model is copied, if a variable is constrained in several sets, the implementation of <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> can determine whether it is added using <a href="#MathOptInterface.add_variable"><code>add_variable</code></a> or <a href="#MathOptInterface.add_constrained_variable"><code>add_constrained_variable</code></a> with one of the sets. The rest of the constraints on the variables are added with <a href="#MathOptInterface.add_constraint"><code>add_constraint</code></a>. For deleting, see <a href="#Index-types">Index types</a>.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.add_variable" href="#MathOptInterface.add_variable"><code>MathOptInterface.add_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_variable(model::ModelLike)::VariableIndex</code></pre><p>Add a scalar variable to the model, returning a variable index.</p><p>A <a href="#MathOptInterface.AddVariableNotAllowed"><code>AddVariableNotAllowed</code></a> error is thrown if adding variables cannot be done in the current state of the model <code>model</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.add_variables" href="#MathOptInterface.add_variables"><code>MathOptInterface.add_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_variables(model::ModelLike, n::Int)::Vector{VariableIndex}</code></pre><p>Add <code>n</code> scalar variables to the model, returning a vector of variable indices.</p><p>A <a href="#MathOptInterface.AddVariableNotAllowed"><code>AddVariableNotAllowed</code></a> error is thrown if adding variables cannot be done in the current state of the model <code>model</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.add_constrained_variable" href="#MathOptInterface.add_constrained_variable"><code>MathOptInterface.add_constrained_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_constrained_variable(
    model::ModelLike,
    set::AbstractScalarSet
)::Tuple{MOI.VariableIndex,
         MOI.ConstraintIndex{MOI.SingleVariable, typeof(set)}}</code></pre><p>Add to <code>model</code> a scalar variable constrained to belong to <code>set</code>, returning the index of the variable created and the index of the constraint constraining the variable to belong to <code>set</code>.</p><p>By default, this function falls back to creating a free variable with <a href="#MathOptInterface.add_variable"><code>add_variable</code></a> and then constraining it to belong to <code>set</code> with <a href="#MathOptInterface.add_constraint"><code>add_constraint</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.add_constrained_variables" href="#MathOptInterface.add_constrained_variables"><code>MathOptInterface.add_constrained_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_constrained_variables(
    model::ModelLike,
    sets::AbstractVector{&lt;:AbstractScalarSet}
)::Tuple{Vector{MOI.VariableIndex},
         Vector{MOI.ConstraintIndex{MOI.SingleVariable, eltype(sets)}}}</code></pre><p>Add to <code>model</code> scalar variables constrained to belong to <code>sets</code>, returning the indices of the variables created and the indices of the constraints constraining the variables to belong to each set in <code>sets</code>. That is, if it returns <code>variables</code> and <code>constraints</code>, <code>constraints[i]</code> is the index of the constraint constraining <code>variable[i]</code> to belong to <code>sets[i]</code>.</p><p>By default, this function falls back to calling <a href="#MathOptInterface.add_constrained_variable"><code>add_constrained_variable</code></a> on each set.</p></div></section><section><div><pre><code class="language-none">add_constrained_variables(
    model::ModelLike,
    set::AbstractVectorSet
)::Tuple{Vector{MOI.VariableIndex},
         MOI.ConstraintIndex{MOI.VectorOfVariables, typeof(set)}}</code></pre><p>Add to <code>model</code> a vector of variables constrained to belong to <code>set</code>, returning the indices of the variables created and the index of the constraint constraining the vector of variables to belong to <code>set</code>.</p><p>By default, this function falls back to creating free variables with <a href="#MathOptInterface.add_variables"><code>add_variables</code></a> and then constraining it to belong to <code>set</code> with <a href="#MathOptInterface.add_constraint"><code>add_constraint</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.supports_add_constrained_variable" href="#MathOptInterface.supports_add_constrained_variable"><code>MathOptInterface.supports_add_constrained_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">supports_add_constrained_variable(
    model::ModelLike,
    S::Type{&lt;:AbstractScalarSet}
)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports constraining a variable to belong to a set of type <code>S</code> either on creation of the variable with <a href="#MathOptInterface.add_constrained_variable"><code>add_constrained_variable</code></a> or after the variable is created with <a href="#MathOptInterface.add_constraint"><code>add_constraint</code></a>.</p><p>By default, this function falls back to <code>supports_add_constrained_variables(model, Reals) &amp;&amp; supports_constraint(model, MOI.SingleVariable, S)</code> which is the correct definition for most models.</p><p><strong>Example</strong></p><p>Suppose that a solver supports only two kind of variables: binary variables and continuous variables with a lower bound. If the solver decides not to support <code>SingleVariable</code>-in-<code>Binary</code> and <code>SingleVariable</code>-in-<code>GreaterThan</code> constraints, it only has to implement <code>add_constrained_variable</code> for these two sets which prevents the user to add both a binary constraint and a lower bound on the same variable. Moreover, if the user adds a <code>SingleVariable</code>-in-<code>GreaterThan</code> constraint, implementing this interface (i.e., <code>supports_add_constrained_variables</code>) enables the constraint to be transparently bridged into a supported constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.supports_add_constrained_variables" href="#MathOptInterface.supports_add_constrained_variables"><code>MathOptInterface.supports_add_constrained_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">supports_add_constrained_variables(
    model::ModelLike,
    S::Type{&lt;:AbstractVectorSet}
)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports constraining a vector of variables to belong to a set of type <code>S</code> either on creation of the vector of variables with <a href="#MathOptInterface.add_constrained_variables"><code>add_constrained_variables</code></a> or after the variable is created with <a href="#MathOptInterface.add_constraint"><code>add_constraint</code></a>.</p><p>By default, if <code>S</code> is <code>Reals</code> then this function returns <code>true</code> and otherwise, it falls back to <code>supports_add_constrained_variables(model, Reals) &amp;&amp; supports_constraint(model, MOI.VectorOfVariables, S)</code> which is the correct definition for most models.</p><p><strong>Example</strong></p><p>In the standard conic form (see <a href="../manual/advanced_usage/#Duality">Duality</a>), the variables are grouped into several cones and the constraints are affine equality constraints. If <code>Reals</code> is not one of the cones supported by the solvers then it needs to implement <code>supports_add_constrained_variables(::Optimizer, ::Type{Reals}) = false</code> as free variables are not supported. The solvers should then implement <code>supports_add_constrained_variables(::Optimizer, ::Type{&lt;:SupportedCones}) = true</code> where <code>SupportedCones</code> is the union of all cone types that are supported; it does not have to implement the method <code>supports_constraint(::Type{VectorOfVariables}, Type{&lt;:SupportedCones})</code> as it should return <code>false</code> and it&#39;s the default. This prevents the user to constrain the same variable in two different cones. When a <code>VectorOfVariables</code>-in-<code>S</code> is added, the variables of the vector have already been created so they already belong to given cones. If bridges are enabled, the constraint will therefore be bridged by adding slack variables in <code>S</code> and equality constraints ensuring that the slack variables are equal to the corresponding variables of the given constraint function.</p><p>Note that there may also be sets for which <code>!supports_add_constrained_variables(model, S)</code> and <code>supports_constraint(model, MOI.VectorOfVariables, S)</code>. For instance, suppose a solver supports positive semidefinite variable constraints and two types of variables: binary variables and nonnegative variables. Then the solver should support adding <code>VectorOfVariables</code>-in-<code>PositiveSemidefiniteConeTriangle</code> constraints, but it should not support creating variables constrained to belong to the <code>PositiveSemidefiniteConeTriangle</code> because the variables in <code>PositiveSemidefiniteConeTriangle</code> should first be created as either binary or non-negative.</p></div></section></article><p>List of attributes associated with variables. [category AbstractVariableAttribute] Calls to <code>get</code> and <code>set</code> should include as an argument a single <code>VariableIndex</code> or a vector of <code>VariableIndex</code> objects.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.VariableName" href="#MathOptInterface.VariableName"><code>MathOptInterface.VariableName</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VariableName()</code></pre><p>A variable attribute for a string identifying the variable. It is <em>valid</em> for two variables to have the same name; however, variables with duplicate names cannot be looked up using <a href="#MathOptInterface.get"><code>get</code></a>. It has a default value of <code>&quot;&quot;</code> if not set`.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.VariablePrimalStart" href="#MathOptInterface.VariablePrimalStart"><code>MathOptInterface.VariablePrimalStart</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VariablePrimalStart()</code></pre><p>A variable attribute for the initial assignment to some primal variable&#39;s value that the optimizer may use to warm-start the solve. May be a number or <code>nothing</code> (unset).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.VariablePrimal" href="#MathOptInterface.VariablePrimal"><code>MathOptInterface.VariablePrimal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VariablePrimal(N)
VariablePrimal()</code></pre><p>A variable attribute for the assignment to some primal variable&#39;s value in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div></section></article><h3 id="Constraints"><a class="docs-heading-anchor" href="#Constraints">Constraints</a><a id="Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints" title="Permalink"></a></h3><p>Functions for adding and modifying constraints.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.is_valid-Tuple{MathOptInterface.ModelLike,MathOptInterface.ConstraintIndex}" href="#MathOptInterface.is_valid-Tuple{MathOptInterface.ModelLike,MathOptInterface.ConstraintIndex}"><code>MathOptInterface.is_valid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_valid(model::ModelLike, index::Index)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this index refers to a valid object in the model <code>model</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.add_constraint" href="#MathOptInterface.add_constraint"><code>MathOptInterface.add_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_constraint(model::ModelLike, func::F, set::S)::ConstraintIndex{F,S} where {F,S}</code></pre><p>Add the constraint <span>$f(x) \in \mathcal{S}$</span> where <span>$f$</span> is defined by <code>func</code>, and <span>$\mathcal{S}$</span> is defined by <code>set</code>.</p><pre><code class="language-none">add_constraint(model::ModelLike, v::VariableIndex, set::S)::ConstraintIndex{SingleVariable,S} where {S}
add_constraint(model::ModelLike, vec::Vector{VariableIndex}, set::S)::ConstraintIndex{VectorOfVariables,S} where {S}</code></pre><p>Add the constraint <span>$v \in \mathcal{S}$</span> where <span>$v$</span> is the variable (or vector of variables) referenced by <code>v</code> and <span>$\mathcal{S}$</span> is defined by <code>set</code>.</p><ul><li>An <a href="#MathOptInterface.UnsupportedConstraint"><code>UnsupportedConstraint</code></a> error is thrown if <code>model</code> does not support <code>F</code>-in-<code>S</code> constraints,</li><li>a <a href="#MathOptInterface.AddConstraintNotAllowed"><code>AddConstraintNotAllowed</code></a> error is thrown if it supports <code>F</code>-in-<code>S</code> constraints but it cannot add the constraint(s) in its current state and</li><li>a <a href="#MathOptInterface.ScalarFunctionConstantNotZero"><code>ScalarFunctionConstantNotZero</code></a> error may be thrown if <code>func</code> is an <code>AbstractScalarFunction</code> with nonzero constant and <code>set</code> is <a href="#MathOptInterface.EqualTo"><code>EqualTo</code></a>, <a href="#MathOptInterface.GreaterThan"><code>GreaterThan</code></a>, <a href="#MathOptInterface.LessThan"><code>LessThan</code></a> or <a href="#MathOptInterface.Interval"><code>Interval</code></a>.</li><li>a <a href="#MathOptInterface.LowerBoundAlreadySet"><code>LowerBoundAlreadySet</code></a> error is thrown if <code>F</code> is a <a href="#MathOptInterface.SingleVariable"><code>SingleVariable</code></a> and a constraint was already added to this variable that sets a lower bound.</li><li>a <a href="#MathOptInterface.UpperBoundAlreadySet"><code>UpperBoundAlreadySet</code></a> error is thrown if <code>F</code> is a <a href="#MathOptInterface.SingleVariable"><code>SingleVariable</code></a> and a constraint was already added to this variable that sets an upper bound.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.add_constraints" href="#MathOptInterface.add_constraints"><code>MathOptInterface.add_constraints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_constraints(model::ModelLike, funcs::Vector{F}, sets::Vector{S})::Vector{ConstraintIndex{F,S}} where {F,S}</code></pre><p>Add the set of constraints specified by each function-set pair in <code>funcs</code> and <code>sets</code>. <code>F</code> and <code>S</code> should be concrete types. This call is equivalent to <code>add_constraint.(model, funcs, sets)</code> but may be more efficient.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.transform" href="#MathOptInterface.transform"><code>MathOptInterface.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Transform Constraint Set</strong></p><pre><code class="language-none">transform(model::ModelLike, c::ConstraintIndex{F,S1}, newset::S2)::ConstraintIndex{F,S2}</code></pre><p>Replace the set in constraint <code>c</code> with <code>newset</code>. The constraint index <code>c</code> will no longer be valid, and the function returns a new constraint index with the correct type.</p><p>Solvers may only support a subset of constraint transforms that they perform efficiently (for example, changing from a <code>LessThan</code> to <code>GreaterThan</code> set). In addition, set modification (where <code>S1 = S2</code>) should be performed via the <code>modify</code> function.</p><p>Typically, the user should delete the constraint and add a new one.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintIndex{ScalarAffineFunction{Float64},LessThan{Float64}}</code>,</p><pre><code class="language-julia">c2 = transform(model, c, GreaterThan(0.0))
transform(model, c, LessThan(0.0)) # errors</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.supports_constraint" href="#MathOptInterface.supports_constraint"><code>MathOptInterface.supports_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">MOI.supports_constraint(BT::Type{&lt;:AbstractBridge}, F::Type{&lt;:MOI.AbstractFunction}, S::Type{&lt;:MOI.AbstractSet})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether the bridges of type <code>BT</code> support bridging <code>F</code>-in-<code>S</code> constraints.</p></div></section><section><div><pre><code class="language-none">supports_constraint(model::ModelLike, ::Type{F}, ::Type{S})::Bool where {F&lt;:AbstractFunction,S&lt;:AbstractSet}</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports <code>F</code>-in-<code>S</code> constraints, that is, <code>copy_to(model, src)</code> does not throw <a href="#MathOptInterface.UnsupportedConstraint"><code>UnsupportedConstraint</code></a> when <code>src</code> contains <code>F</code>-in-<code>S</code> constraints. If <code>F</code>-in-<code>S</code> constraints are only not supported in specific circumstances, e.g. <code>F</code>-in-<code>S</code> constraints cannot be combined with another type of constraint, it should still return <code>true</code>.</p><pre><code class="language-none">supports_constraint(model::ModelLike, ::Type{VectorOfVariables}, ::Type{Reals})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports free variables. That is, <code>copy_to(model, src)</code> does not error when <code>src</code> contains variables that are not constrained by any <a href="#MathOptInterface.SingleVariable"><code>SingleVariable</code></a> or <a href="#MathOptInterface.VectorOfVariables"><code>VectorOfVariables</code></a> constraint. By default, this method returns <code>true</code> so it should only be implemented if <code>model</code> does not support free variables. For instance, if a solver requires all variables to be nonnegative, it should implement this method and return <code>false</code> because free variables cannot be copied to the solver.</p><p>Note that free variables are not explicitly set to be free by calling <a href="#MathOptInterface.add_constraint"><code>add_constraint</code></a> with the set <a href="#MathOptInterface.Reals"><code>Reals</code></a>, instead, free variables are created with <a href="#MathOptInterface.add_variable"><code>add_variable</code></a> and <a href="#MathOptInterface.add_variables"><code>add_variables</code></a>. If <code>model</code> does not support free variables, it should not implement <a href="#MathOptInterface.add_variable"><code>add_variable</code></a> nor <a href="#MathOptInterface.add_variables"><code>add_variables</code></a> but should implement this method and return <code>false</code>. This allows free variables to be bridged as the sum of a nonnegative and a nonpositive variables.</p></div></section></article><p>List of attributes associated with constraints. [category AbstractConstraintAttribute] Calls to <code>get</code> and <code>set</code> should include as an argument a single <code>ConstraintIndex</code> or a vector of <code>ConstraintIndex{F,S}</code> objects.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConstraintName" href="#MathOptInterface.ConstraintName"><code>MathOptInterface.ConstraintName</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstraintName()</code></pre><p>A constraint attribute for a string identifying the constraint. It is <em>valid</em> for constraints variables to have the same name; however, constraints with duplicate names cannot be looked up using <a href="#MathOptInterface.get"><code>get</code></a> regardless of if they have the same <code>F</code>-in-<code>S</code> type. It has a default value of <code>&quot;&quot;</code> if not set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConstraintPrimalStart" href="#MathOptInterface.ConstraintPrimalStart"><code>MathOptInterface.ConstraintPrimalStart</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstraintPrimalStart()</code></pre><p>A constraint attribute for the initial assignment to some constraint&#39;s primal value(s) that the optimizer may use to warm-start the solve. May be a number or <code>nothing</code> (unset).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConstraintDualStart" href="#MathOptInterface.ConstraintDualStart"><code>MathOptInterface.ConstraintDualStart</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstraintDualStart()</code></pre><p>A constraint attribute for the initial assignment to some constraint&#39;s dual value(s) that the optimizer may use to warm-start the solve. May be a number or <code>nothing</code> (unset).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConstraintPrimal" href="#MathOptInterface.ConstraintPrimal"><code>MathOptInterface.ConstraintPrimal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstraintPrimal(N)
ConstraintPrimal()</code></pre><p>A constraint attribute for the assignment to some constraint&#39;s primal value(s) in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p><p>Given a constraint <code>function-in-set</code>, the <code>ConstraintPrimal</code> is the value of the function evaluated at the primal solution of the variables. For example, given the constraint <code>ScalarAffineFunction([x,y], [1, 2], 3)</code>-in-<code>Interval(0, 20)</code> and a primal solution of <code>(x,y) = (4,5)</code>, the <code>ConstraintPrimal</code> solution of the constraint is <code>1 * 4 + 2 * 5 + 3 = 17</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConstraintDual" href="#MathOptInterface.ConstraintDual"><code>MathOptInterface.ConstraintDual</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstraintDual(N)
ConstraintDual()</code></pre><p>A constraint attribute for the assignment to some constraint&#39;s dual value(s) in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConstraintBasisStatus" href="#MathOptInterface.ConstraintBasisStatus"><code>MathOptInterface.ConstraintBasisStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstraintBasisStatus(result_index)
ConstraintBasisStatus()</code></pre><p>A constraint attribute for the <code>BasisStatusCode</code> of some constraint in result <code>result_index</code>, with respect to an available optimal solution basis. If <code>result_index</code> is omitted, it is 1 by default.</p><p><strong>For the basis status of a variable, query the corresponding <code>SingleVariable</code> constraint that enforces the variable&#39;s bounds.</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConstraintFunction" href="#MathOptInterface.ConstraintFunction"><code>MathOptInterface.ConstraintFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstraintFunction()</code></pre><p>A constraint attribute for the <code>AbstractFunction</code> object used to define the constraint. It is guaranteed to be equivalent but not necessarily identical to the function provided by the user.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.CanonicalConstraintFunction" href="#MathOptInterface.CanonicalConstraintFunction"><code>MathOptInterface.CanonicalConstraintFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CanonicalConstraintFunction()</code></pre><p>A constraint attribute for a canonical representation of the <a href="#MathOptInterface.AbstractFunction"><code>AbstractFunction</code></a> object used to define the constraint. Getting this attribute is guaranteed to return a function that is equivalent but not necessarily identical to the function provided by the user.</p><p>By default, <code>MOI.get(model, MOI.CanonicalConstraintFunction(), ci)</code> fallbacks to <code>MOI.Utilities.canonical(MOI.get(model, MOI.ConstraintFunction(), ci))</code>. However, if <code>model</code> knows that the constraint function is canonical then it can implement a specialized method that directly return the function without calling <a href="#MathOptInterface.Utilities.canonical"><code>Utilities.canonical</code></a>. Therefore, the value returned <strong>cannot</strong> be assumed to be a copy of the function stored in <code>model</code>. Moreover, <a href="#MathOptInterface.Utilities.Model"><code>Utilities.Model</code></a> checks with <a href="#MathOptInterface.Utilities.is_canonical"><code>Utilities.is_canonical</code></a> whether the function stored internally is already canonical and if it&#39;s the case, then it returns the function stored internally instead of a copy.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConstraintSet" href="#MathOptInterface.ConstraintSet"><code>MathOptInterface.ConstraintSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstraintSet()</code></pre><p>A constraint attribute for the <code>AbstractSet</code> object used to define the constraint.</p></div></section></article><p>Note that setting the <a href="#MathOptInterface.ConstraintFunction"><code>ConstraintFunction</code></a> of a [<code>SingleVariable</code>] constraint is not allowed:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SettingSingleVariableFunctionNotAllowed" href="#MathOptInterface.SettingSingleVariableFunctionNotAllowed"><code>MathOptInterface.SettingSingleVariableFunctionNotAllowed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SettingSingleVariableFunctionNotAllowed()</code></pre><p>Error type that should be thrown when the user calls <a href="#MathOptInterface.set"><code>set</code></a> to change the <a href="#MathOptInterface.ConstraintFunction"><code>ConstraintFunction</code></a> of a <a href="#MathOptInterface.SingleVariable"><code>SingleVariable</code></a> constraint.</p></div></section></article><h2 id="Functions-and-function-modifications"><a class="docs-heading-anchor" href="#Functions-and-function-modifications">Functions and function modifications</a><a id="Functions-and-function-modifications-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-and-function-modifications" title="Permalink"></a></h2><p>List of recognized functions.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractFunction" href="#MathOptInterface.AbstractFunction"><code>MathOptInterface.AbstractFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractFunction</code></pre><p>Abstract supertype for function objects.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractVectorFunction" href="#MathOptInterface.AbstractVectorFunction"><code>MathOptInterface.AbstractVectorFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractVectorFunction</code></pre><p>Abstract supertype for vector-valued function objects.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SingleVariable" href="#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SingleVariable(variable)</code></pre><p>The function that extracts the scalar variable referenced by <code>variable</code>, a <code>VariableIndex</code>. This function is naturally be used for single variable bounds or integrality constraints.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.VectorOfVariables" href="#MathOptInterface.VectorOfVariables"><code>MathOptInterface.VectorOfVariables</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VectorOfVariables(variables)</code></pre><p>The function that extracts the vector of variables referenced by <code>variables</code>, a <code>Vector{VariableIndex}</code>. This function is naturally be used for constraints that apply to groups of variables, such as an &quot;all different&quot; constraint, an indicator constraint, or a complementarity constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ScalarAffineTerm" href="#MathOptInterface.ScalarAffineTerm"><code>MathOptInterface.ScalarAffineTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ScalarAffineTerm{T}
    coefficient::T
    variable_index::VariableIndex
end</code></pre><p>Represents <span>$c x_i$</span> where <span>$c$</span> is <code>coefficient</code> and <span>$x_i$</span> is the variable identified by <code>variable_index</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ScalarAffineFunction" href="#MathOptInterface.ScalarAffineFunction"><code>MathOptInterface.ScalarAffineFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScalarAffineFunction{T}(terms, constant)</code></pre><p>The scalar-valued affine function <span>$a^T x + b$</span>, where:</p><ul><li><span>$a$</span> is a sparse vector specified by a list of <a href="#MathOptInterface.ScalarAffineTerm"><code>ScalarAffineTerm</code></a> structs.</li><li><span>$b$</span> is a scalar specified by <code>constant::T</code></li></ul><p>Duplicate variable indices in <code>terms</code> are accepted, and the corresponding coefficients are summed together.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.VectorAffineTerm" href="#MathOptInterface.VectorAffineTerm"><code>MathOptInterface.VectorAffineTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct VectorAffineTerm{T}
    output_index::Int64
    scalar_term::ScalarAffineTerm{T}
end</code></pre><p>A <code>ScalarAffineTerm</code> plus its index of the output component of a <code>VectorAffineFunction</code> or <code>VectorQuadraticFunction</code>. <code>output_index</code> can also be interpreted as a row index into a sparse matrix, where the <code>scalar_term</code> contains the column index and coefficient.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.VectorAffineFunction" href="#MathOptInterface.VectorAffineFunction"><code>MathOptInterface.VectorAffineFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VectorAffineFunction{T}(terms, constants)</code></pre><p>The vector-valued affine function <span>$A x + b$</span>, where:</p><ul><li><span>$A$</span> is a sparse matrix specified by a list of <code>VectorAffineTerm</code> objects.</li><li><span>$b$</span> is a vector specified by <code>constants</code></li></ul><p>Duplicate indices in the <span>$A$</span> are accepted, and the corresponding coefficients are summed together.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ScalarQuadraticTerm" href="#MathOptInterface.ScalarQuadraticTerm"><code>MathOptInterface.ScalarQuadraticTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ScalarQuadraticTerm{T}
    coefficient::T
    variable_index_1::VariableIndex
    variable_index_2::VariableIndex
end</code></pre><p>Represents <span>$c x_i x_j$</span> where <span>$c$</span> is <code>coefficient</code>, <span>$x_i$</span> is the variable identified by <code>variable_index_1</code> and <span>$x_j$</span> is the variable identified by <code>variable_index_2</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ScalarQuadraticFunction" href="#MathOptInterface.ScalarQuadraticFunction"><code>MathOptInterface.ScalarQuadraticFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScalarQuadraticFunction{T}(affine_terms, quadratic_terms, constant)</code></pre><p>The scalar-valued quadratic function <span>$\frac{1}{2}x^TQx + a^T x + b$</span>, where:</p><ul><li><span>$a$</span> is a sparse vector specified by a list of <code>ScalarAffineTerm</code> structs.</li><li><span>$b$</span> is a scalar specified by <code>constant</code>.</li><li><span>$Q$</span> is a symmetric matrix specified by a list of <code>ScalarQuadraticTerm</code> structs.</li></ul><p>Duplicate indices in <span>$a$</span> or <span>$Q$</span> are accepted, and the corresponding coefficients are summed together. &quot;Mirrored&quot; indices <code>(q,r)</code> and <code>(r,q)</code> (where <code>r</code> and <code>q</code> are <code>VariableIndex</code>es) are considered duplicates; only one need be specified.</p><p>For example, for two scalar variables <span>$y, z$</span>, the quadratic expression <span>$yz + y^2$</span> is represented by the terms <code>ScalarQuadraticTerm.([1.0, 2.0], [y, y], [z, y])</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.VectorQuadraticTerm" href="#MathOptInterface.VectorQuadraticTerm"><code>MathOptInterface.VectorQuadraticTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct VectorQuadraticTerm{T}
    output_index::Int64
    scalar_term::ScalarQuadraticTerm{T}
end</code></pre><p>A <a href="#MathOptInterface.ScalarQuadraticTerm"><code>ScalarQuadraticTerm</code></a> plus its index of the output component of a <code>VectorQuadraticFunction</code>. Each output component corresponds to a distinct sparse matrix <span>$Q_i$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.VectorQuadraticFunction" href="#MathOptInterface.VectorQuadraticFunction"><code>MathOptInterface.VectorQuadraticFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VectorQuadraticFunction{T}(affine_terms, quadratic_terms, constants)</code></pre><p>The vector-valued quadratic function with i<code>th</code> component (&quot;output index&quot;) defined as <span>$\frac{1}{2}x^TQ_ix + a_i^T x + b_i$</span>, where:</p><ul><li><span>$a_i$</span> is a sparse vector specified by the <code>VectorAffineTerm</code>s with <code>output_index == i</code>.</li><li><span>$b_i$</span> is a scalar specified by <code>constants[i]</code></li><li><span>$Q_i$</span> is a symmetric matrix specified by the <code>VectorQuadraticTerm</code> with <code>output_index == i</code>.</li></ul><p>Duplicate indices in <span>$a_i$</span> or <span>$Q_i$</span> are accepted, and the corresponding coefficients are summed together. &quot;Mirrored&quot; indices <code>(q,r)</code> and <code>(r,q)</code> (where <code>r</code> and <code>q</code> are <code>VariableIndex</code>es) are considered duplicates; only one need be specified.</p></div></section></article><p>Functions for getting and setting properties of functions.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.output_dimension" href="#MathOptInterface.output_dimension"><code>MathOptInterface.output_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">output_dimension(f::AbstractFunction)</code></pre><p>Return 1 if <code>f</code> has a scalar output and the number of output components if <code>f</code> has a vector output.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.constant-Tuple{Union{ScalarAffineFunction, ScalarQuadraticFunction}}" href="#MathOptInterface.constant-Tuple{Union{ScalarAffineFunction, ScalarQuadraticFunction}}"><code>MathOptInterface.constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constant(f::Union{ScalarAffineFunction, ScalarQuadraticFunction})</code></pre><p>Returns the constant term of the scalar function</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.constant-Tuple{Union{VectorAffineFunction, VectorQuadraticFunction}}" href="#MathOptInterface.constant-Tuple{Union{VectorAffineFunction, VectorQuadraticFunction}}"><code>MathOptInterface.constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constant(f::Union{VectorAffineFunction, VectorQuadraticFunction})</code></pre><p>Returns the vector of constant terms of the vector function</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.constant-Tuple{MathOptInterface.SingleVariable,DataType}" href="#MathOptInterface.constant-Tuple{MathOptInterface.SingleVariable,DataType}"><code>MathOptInterface.constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constant(f::SingleVariable, T::DataType)</code></pre><p>The constant term of a <code>SingleVariable</code> function is the zero value of the specified type <code>T</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.constant-Tuple{MathOptInterface.VectorOfVariables,DataType}" href="#MathOptInterface.constant-Tuple{MathOptInterface.VectorOfVariables,DataType}"><code>MathOptInterface.constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constant(f::VectorOfVariables, T::DataType)</code></pre><p>The constant term of a <code>VectorOfVariables</code> function is a vector of zero values of the specified type <code>T</code>.</p></div></section></article><h2 id="Sets"><a class="docs-heading-anchor" href="#Sets">Sets</a><a id="Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Sets" title="Permalink"></a></h2><p>All sets are subtypes of <a href="#MathOptInterface.AbstractSet"><code>AbstractSet</code></a> and they should either be scalar or vector sets.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractSet" href="#MathOptInterface.AbstractSet"><code>MathOptInterface.AbstractSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractSet</code></pre><p>Abstract supertype for set objects used to encode constraints. A set object should not contain any <a href="#MathOptInterface.VariableIndex"><code>VariableIndex</code></a> or <a href="#MathOptInterface.ConstraintIndex"><code>ConstraintIndex</code></a> as the set is passed unmodifed during <a href="#MathOptInterface.copy_to"><code>copy_to</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractScalarSet" href="#MathOptInterface.AbstractScalarSet"><code>MathOptInterface.AbstractScalarSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractScalarSet</code></pre><p>Abstract supertype for subsets of <span>$\mathbb{R}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractVectorSet" href="#MathOptInterface.AbstractVectorSet"><code>MathOptInterface.AbstractVectorSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractVectorSet</code></pre><p>Abstract supertype for subsets of <span>$\mathbb{R}^n$</span> for some <span>$n$</span>.</p></div></section></article><p>Functions for getting properties of sets.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.dimension" href="#MathOptInterface.dimension"><code>MathOptInterface.dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dimension(s::AbstractSet)</code></pre><p>Return the <a href="#MathOptInterface.output_dimension"><code>output_dimension</code></a> that an <a href="#MathOptInterface.AbstractFunction"><code>AbstractFunction</code></a> should have to be used with the set <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dimension(Reals(4))
4

julia&gt; dimension(LessThan(3.0))
1

julia&gt; dimension(PositiveSemidefiniteConeTriangle(2))
3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.dual_set" href="#MathOptInterface.dual_set"><code>MathOptInterface.dual_set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dual_set(s::AbstractSet)</code></pre><p>Return the dual set of <code>s</code>, that is the dual cone of the set. This follows the definition of duality discussed in <a href="../manual/advanced_usage/#Duality">Duality</a>.</p><p>See <a href="https://en.wikipedia.org/wiki/Dual_cone_and_polar_cone">Dual cone</a> for more information.</p><p>If the dual cone is not defined it returns an error.</p><p><strong>Examples</strong></p><pre><code class="language-jldocstest">julia&gt; dual_set(Reals(4))
Zeros(4)

julia&gt; dual_set(SecondOrderCone(5))
SecondOrderCone(5)

julia&gt; dual_set(ExponentialCone())
DualExponentialCone()</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.dual_set_type" href="#MathOptInterface.dual_set_type"><code>MathOptInterface.dual_set_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dual_set_type(S::Type{&lt;:AbstractSet})</code></pre><p>Return the type of dual set of sets of type <code>S</code>, as returned by <a href="#MathOptInterface.dual_set"><code>dual_set</code></a>. If the dual cone is not defined it returns an error.</p><p><strong>Examples</strong></p><pre><code class="language-jldocstest">julia&gt; dual_set_type(Reals)
Zeros

julia&gt; dual_set_type(SecondOrderCone)
SecondOrderCone

julia&gt; dual_set_type(ExponentialCone)
DualExponentialCone</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.constant-Tuple{MathOptInterface.EqualTo}" href="#MathOptInterface.constant-Tuple{MathOptInterface.EqualTo}"><code>MathOptInterface.constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constant(s::Union{EqualTo, GreaterThan, LessThan})</code></pre><p>Returns the constant of the set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.supports_dimension_update" href="#MathOptInterface.supports_dimension_update"><code>MathOptInterface.supports_dimension_update</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">supports_dimension_update(S::Type{&lt;:MOI.AbstractVectorSet})</code></pre><p>Return a <code>Bool</code> indicating whether the elimination of any dimension of <code>n</code>-dimensional sets of type <code>S</code> give an <code>n-1</code>-dimensional set <code>S</code>. By default, this function returns <code>false</code> so it should only be implemented for sets that supports dimension update.</p><p>For instance, <code>supports_dimension_update(MOI.Nonnegatives}</code> is <code>true</code> because the elimination of any dimension of the <code>n</code>-dimensional nonnegative orthant gives the <code>n-1</code>-dimensional nonnegative orthant. However <code>supports_dimension_update(MOI.ExponentialCone}</code> is <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.update_dimension" href="#MathOptInterface.update_dimension"><code>MathOptInterface.update_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">update_dimension(s::AbstractVectorSet, new_dim)</code></pre><p>Returns a set with the dimension modified to <code>new_dim</code>.</p></div></section></article><h3 id="Scalar-sets"><a class="docs-heading-anchor" href="#Scalar-sets">Scalar sets</a><a id="Scalar-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-sets" title="Permalink"></a></h3><p>List of recognized scalar sets.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.GreaterThan" href="#MathOptInterface.GreaterThan"><code>MathOptInterface.GreaterThan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GreaterThan{T &lt;: Real}(lower::T)</code></pre><p>The set <span>$[lower,\infty) \subseteq \mathbb{R}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.LessThan" href="#MathOptInterface.LessThan"><code>MathOptInterface.LessThan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LessThan{T &lt;: Real}(upper::T)</code></pre><p>The set <span>$(-\infty,upper] \subseteq \mathbb{R}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.EqualTo" href="#MathOptInterface.EqualTo"><code>MathOptInterface.EqualTo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EqualTo{T &lt;: Number}(value::T)</code></pre><p>The set containing the single point <span>$x \in \mathbb{R}$</span> where <span>$x$</span> is given by <code>value</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Interval" href="#MathOptInterface.Interval"><code>MathOptInterface.Interval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Interval{T &lt;: Real}(lower::T,upper::T)</code></pre><p>The interval <span>$[lower, upper] \subseteq \mathbb{R}$</span>. If <code>lower</code> or <code>upper</code> is <code>-Inf</code> or <code>Inf</code>, respectively, the set is interpreted as a one-sided interval.</p><pre><code class="language-none">Interval(s::GreaterThan{&lt;:AbstractFloat})</code></pre><p>Construct a (right-unbounded) <code>Interval</code> equivalent to the given <a href="#MathOptInterface.GreaterThan"><code>GreaterThan</code></a> set.</p><pre><code class="language-none">Interval(s::LessThan{&lt;:AbstractFloat})</code></pre><p>Construct a (left-unbounded) <code>Interval</code> equivalent to the given <a href="#MathOptInterface.LessThan"><code>LessThan</code></a> set.</p><pre><code class="language-none">Interval(s::EqualTo{&lt;:Real})</code></pre><p>Construct a (degenerate) <code>Interval</code> equivalent to the given <a href="#MathOptInterface.EqualTo"><code>EqualTo</code></a> set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Integer" href="#MathOptInterface.Integer"><code>MathOptInterface.Integer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Integer()</code></pre><p>The set of integers <span>$\mathbb{Z}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ZeroOne" href="#MathOptInterface.ZeroOne"><code>MathOptInterface.ZeroOne</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ZeroOne()</code></pre><p>The set <span>$\{ 0, 1 \}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Semicontinuous" href="#MathOptInterface.Semicontinuous"><code>MathOptInterface.Semicontinuous</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Semicontinuous{T &lt;: Real}(lower::T,upper::T)</code></pre><p>The set <span>$\{0\} \cup [lower,upper]$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Semiinteger" href="#MathOptInterface.Semiinteger"><code>MathOptInterface.Semiinteger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Semiinteger{T &lt;: Real}(lower::T,upper::T)</code></pre><p>The set <span>$\{0\} \cup \{lower,lower+1,\ldots,upper-1,upper\}$</span>.</p></div></section></article><h3 id="Vector-sets"><a class="docs-heading-anchor" href="#Vector-sets">Vector sets</a><a id="Vector-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-sets" title="Permalink"></a></h3><p>List of recognized vector sets.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Reals" href="#MathOptInterface.Reals"><code>MathOptInterface.Reals</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Reals(dimension)</code></pre><p>The set <span>$\mathbb{R}^{dimension}$</span> (containing all points) of dimension <code>dimension</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Zeros" href="#MathOptInterface.Zeros"><code>MathOptInterface.Zeros</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Zeros(dimension)</code></pre><p>The set <span>$\{ 0 \}^{dimension}$</span> (containing only the origin) of dimension <code>dimension</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Nonnegatives" href="#MathOptInterface.Nonnegatives"><code>MathOptInterface.Nonnegatives</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Nonnegatives(dimension)</code></pre><p>The nonnegative orthant <span>$\{ x \in \mathbb{R}^{dimension} : x \ge 0 \}$</span> of dimension <code>dimension</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Nonpositives" href="#MathOptInterface.Nonpositives"><code>MathOptInterface.Nonpositives</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Nonpositives(dimension)</code></pre><p>The nonpositive orthant <span>$\{ x \in \mathbb{R}^{dimension} : x \le 0 \}$</span> of dimension <code>dimension</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NormInfinityCone" href="#MathOptInterface.NormInfinityCone"><code>MathOptInterface.NormInfinityCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NormInfinityCone(dimension)</code></pre><p>The <span>$\ell_\infty$</span>-norm cone <span>$\{ (t,x) \in \mathbb{R}^{dimension} : t \ge \lVert x \rVert_\infty = \max_i \lvert x_i \rvert \}$</span> of dimension <code>dimension</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NormOneCone" href="#MathOptInterface.NormOneCone"><code>MathOptInterface.NormOneCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NormOneCone(dimension)</code></pre><p>The <span>$\ell_1$</span>-norm cone <span>$\{ (t,x) \in \mathbb{R}^{dimension} : t \ge \lVert x \rVert_1 = \sum_i \lvert x_i \rvert \}$</span> of dimension <code>dimension</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SecondOrderCone" href="#MathOptInterface.SecondOrderCone"><code>MathOptInterface.SecondOrderCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SecondOrderCone(dimension)</code></pre><p>The second-order cone (or Lorenz cone or <span>$\ell_2$</span>-norm cone) <span>$\{ (t,x) \in \mathbb{R}^{dimension} : t \ge \lVert x \rVert_2 \}$</span> of dimension <code>dimension</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RotatedSecondOrderCone" href="#MathOptInterface.RotatedSecondOrderCone"><code>MathOptInterface.RotatedSecondOrderCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RotatedSecondOrderCone(dimension)</code></pre><p>The rotated second-order cone <span>$\{ (t,u,x) \in \mathbb{R}^{dimension} : 2tu \ge \lVert x \rVert_2^2, t,u \ge 0 \}$</span> of dimension <code>dimension</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.GeometricMeanCone" href="#MathOptInterface.GeometricMeanCone"><code>MathOptInterface.GeometricMeanCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GeometricMeanCone(dimension)</code></pre><p>The geometric mean cone <span>$\{ (t,x) \in \mathbb{R}^{n+1} : x \ge 0, t \le \sqrt[n]{x_1 x_2 \cdots x_n} \}$</span> of dimension <code>dimension</code><span>${}=n+1$</span>.</p><p><strong>Duality note</strong></p><p>The dual of the geometric mean cone is <span>$\{ (u, v) \in \mathbb{R}^{n+1} : u \le 0, v \ge 0, -u \le n \sqrt[n]{\prod_i v_i} \}$</span> of dimension <code>dimension</code><span>${}=n+1$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ExponentialCone" href="#MathOptInterface.ExponentialCone"><code>MathOptInterface.ExponentialCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ExponentialCone()</code></pre><p>The 3-dimensional exponential cone <span>$\{ (x,y,z) \in \mathbb{R}^3 : y \exp (x/y) \le z, y &gt; 0 \}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.DualExponentialCone" href="#MathOptInterface.DualExponentialCone"><code>MathOptInterface.DualExponentialCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DualExponentialCone()</code></pre><p>The 3-dimensional dual exponential cone <span>$\{ (u,v,w) \in \mathbb{R}^3 : -u \exp (v/u) \le \exp(1) w, u &lt; 0 \}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.PowerCone" href="#MathOptInterface.PowerCone"><code>MathOptInterface.PowerCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PowerCone{T &lt;: Real}(exponent::T)</code></pre><p>The 3-dimensional power cone <span>$\{ (x,y,z) \in \mathbb{R}^3 : x^{exponent} y^{1-exponent} \ge |z|, x \ge 0, y \ge 0 \}$</span> with parameter <code>exponent</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.DualPowerCone" href="#MathOptInterface.DualPowerCone"><code>MathOptInterface.DualPowerCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DualPowerCone{T &lt;: Real}(exponent::T)</code></pre><p>The 3-dimensional power cone <span>$\{ (u,v,w) \in \mathbb{R}^3 : (\frac{u}{exponent})^{exponent} (\frac{v}{1-exponent})^{1-exponent} \ge |w|, u \ge 0, v \ge 0 \}$</span> with parameter <code>exponent</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RelativeEntropyCone" href="#MathOptInterface.RelativeEntropyCone"><code>MathOptInterface.RelativeEntropyCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RelativeEntropyCone(dimension)</code></pre><p>The relative entropy cone <span>$\{ (u, v, w) \in \mathbb{R}^{1+2n} : u \ge \sum_{i=1}^n w_i \log (\frac{w_i}{v_i}), v_i \ge 0, w_i \ge 0 \}$</span> of dimension <code>dimension</code><span>${}=2n+1$</span>.</p><p><strong>Duality note</strong></p><p>The dual of the relative entropy cone is <span>$\{ (u, v, w) \in \mathbb{R}^{1+2n} : \forall i, w_i \ge u (\log (\frac{u}{v_i}) - 1), v_i \ge 0, u &gt; 0 \}$</span> of dimension <code>dimension</code><span>${}=2n+1$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NormSpectralCone" href="#MathOptInterface.NormSpectralCone"><code>MathOptInterface.NormSpectralCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NormSpectralCone(row_dim, column_dim)</code></pre><p>The epigraph of the matrix spectral norm (maximum singular value function) <span>$\{ (t, X) \in \mathbb{R}^{1 + row_dim \times column_dim} : t \ge \sigma_1(X) \}$</span> where <span>$\sigma_i$</span> is the <span>$i$</span>th singular value of the matrix <span>$X$</span> of row dimension <code>row_dim</code> and column dimension <code>column_dim</code>. The matrix X is vectorized by stacking the columns, matching the behavior of Julia&#39;s <code>vec</code> function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NormNuclearCone" href="#MathOptInterface.NormNuclearCone"><code>MathOptInterface.NormNuclearCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NormNuclearCone(row_dim, column_dim)</code></pre><p>The epigraph of the matrix nuclear norm (sum of singular values function) <span>$\{ (t, X) \in \mathbb{R}^{1 + row_dim \times column_dim} : t \ge \sum_i \sigma_i(X) \}$</span> where <span>$\sigma_i$</span> is the <span>$i$</span>th singular value of the matrix <span>$X$</span> of row dimension <code>row_dim</code> and column dimension <code>column_dim</code>. The matrix X is vectorized by stacking the columns, matching the behavior of Julia&#39;s <code>vec</code> function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SOS1" href="#MathOptInterface.SOS1"><code>MathOptInterface.SOS1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SOS1{T &lt;: Real}(weights::Vector{T})</code></pre><p>The set corresponding to the special ordered set (SOS) constraint of type 1. Of the variables in the set, at most one can be nonzero. The <code>weights</code> induce an ordering of the variables; as such, they should be unique values. The <em>k</em>th element in the set corresponds to the <em>k</em>th weight in <code>weights</code>. See <a href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for a description of SOS constraints and their potential uses.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SOS2" href="#MathOptInterface.SOS2"><code>MathOptInterface.SOS2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SOS2{T &lt;: Real}(weights::Vector{T})</code></pre><p>The set corresponding to the special ordered set (SOS) constraint of type 2. Of the variables in the set, at most two can be nonzero, and if two are nonzero, they must be adjacent in the ordering of the set. The <code>weights</code> induce an ordering of the variables; as such, they should be unique values. The <em>k</em>th element in the set corresponds to the <em>k</em>th weight in <code>weights</code>. See <a href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for a description of SOS constraints and their potential uses.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.IndicatorSet" href="#MathOptInterface.IndicatorSet"><code>MathOptInterface.IndicatorSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IndicatorSet{A, S &lt;: AbstractScalarSet}(set::S)</code></pre><p><span>$\{(y, x) \in \{0, 1\} \times \mathbb{R}^n : y = 0 \implies x \in set\}$</span> when <code>A</code> is <code>ACTIVATE_ON_ZERO</code> and <span>$\{(y, x) \in \{0, 1\} \times \mathbb{R}^n : y = 1 \implies x \in set\}$</span> when <code>A</code> is <code>ACTIVATE_ON_ONE</code>.</p><p><code>S</code> has to be a sub-type of <code>AbstractScalarSet</code>. <code>A</code> is one of the value of the <code>ActivationCond</code> enum. <code>IndicatorSet</code> is used with a <code>VectorAffineFunction</code> holding the indicator variable first.</p><p>Example: <span>$\{(y, x) \in \{0, 1\} \times \mathbb{R}^2 : y = 1 \implies x_1 + x_2 \leq 9 \}$</span></p><pre><code class="language-julia">f = MOI.VectorAffineFunction(
    [MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(1.0, y)),
     MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(1.0, x1)),
     MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(1.0, x2)),
    ],
    [0.0, 0.0],
)

indicator_set = MOI.IndicatorSet{MOI.ACTIVATE_ON_ONE}(MOI.LessThan(9.0))

MOI.add_constraint(model, f, indicator_set)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Complements" href="#MathOptInterface.Complements"><code>MathOptInterface.Complements</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Complements(dimension::Int)</code></pre><p>The set corresponding to a mixed complementarity constraint.</p><p>Complementarity constraints should be specified with an <a href="#MathOptInterface.AbstractVectorFunction"><code>AbstractVectorFunction</code></a>-in-<code>Complements(dimension)</code> constraint.</p><p>The dimension of the vector-valued function <code>F</code> must be <code>2 * dimension</code>. This defines a complementarity constraint between the scalar function <code>F[i]</code> and the variable in <code>F[i + dimension]</code>. Thus, <code>F[i + dimension]</code> must be interpretable as a single variable <code>x_i</code> (e.g., <code>1.0 * x + 0.0</code>).</p><p>The mixed complementarity problem consists of finding <code>x_i</code> in the interval <code>[lb, ub]</code> (i.e., in the set <code>Interval(lb, ub)</code>), such that the following holds:</p><ol><li><code>F_i(x) == 0</code> if <code>lb_i &lt; x_i &lt; ub_i</code></li><li><code>F_i(x) &gt;= 0</code> if <code>lb_i == x_i</code></li><li><code>F_i(x) &lt;= 0</code> if <code>x_i == ub_i</code></li></ol><p>Classically, the bounding set for <code>x_i</code> is <code>Interval(0, Inf)</code>, which recovers: <code>0 &lt;= F_i(x) ⟂ x_i &gt;= 0</code>, where the <code>⟂</code> operator implies <code>F_i(x) * x_i = 0</code>.</p><p><strong>Examples</strong></p><p>The problem:</p><pre><code class="language-none">x -in- Interval(-1, 1)
[-4 * x - 3, x] -in- Complements(1)</code></pre><p>defines the mixed complementarity problem where the following holds:</p><ol><li><code>-4 * x - 3 == 0</code> if <code>-1 &lt; x &lt; 1</code></li><li><code>-4 * x - 3 &gt;= 0</code> if <code>x == -1</code></li><li><code>-4 * x - 3 &lt;= 0</code> if <code>x == 1</code></li></ol><p>There are three solutions:</p><ol><li><code>x = -3/4</code> with <code>F(x) = 0</code></li><li><code>x = -1</code> with <code>F(x) = 1</code></li><li><code>x = 1</code> with <code>F(x) = -7</code></li></ol><p>The function <code>F</code> can also be defined in terms of single variables. For example, the problem:</p><pre><code class="language-none">[x_3, x_4] -in- Nonnegatives(2)
[x_1, x_2, x_3, x_4] -in- Complements(2)</code></pre><p>defines the complementarity problem where <code>0 &lt;= x_1 ⟂ x_3 &gt;= 0</code> and <code>0 &lt;= x_2 ⟂ x_4 &gt;= 0</code>.</p></div></section></article><h3 id="Matrix-sets"><a class="docs-heading-anchor" href="#Matrix-sets">Matrix sets</a><a id="Matrix-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-sets" title="Permalink"></a></h3><p>Matrix sets are vectorized in order to be subtypes of <a href="#MathOptInterface.AbstractVectorSet"><code>AbstractVectorSet</code></a>. For sets of symmetric matrices, storing both the <code>(i, j)</code> and <code>(j, i)</code> elements is redundant so there exists the <a href="#MathOptInterface.AbstractSymmetricMatrixSetTriangle"><code>AbstractSymmetricMatrixSetTriangle</code></a> set to represent only the vectorization of the upper triangular part of the matrix. When the matrix of expressions constrained to be in the set is not symmetric and hence the <code>(i, j)</code> and <code>(j, i)</code> elements should be constrained to be symmetric, the <a href="#MathOptInterface.AbstractSymmetricMatrixSetSquare"><code>AbstractSymmetricMatrixSetSquare</code></a> set can be used. The <a href="#MathOptInterface.Bridges.Constraint.SquareBridge"><code>Bridges.Constraint.SquareBridge</code></a> can transform a set from the square form to the <a href="#MathOptInterface.triangular_form"><code>triangular_form</code></a> by adding appropriate constraints if the <code>(i, j)</code> and <code>(j, i)</code> expressions are different.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractSymmetricMatrixSetTriangle" href="#MathOptInterface.AbstractSymmetricMatrixSetTriangle"><code>MathOptInterface.AbstractSymmetricMatrixSetTriangle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractSymmetricMatrixSetTriangle &lt;: AbstractVectorSet end</code></pre><p>Abstract supertype for subsets of the (vectorized) cone of symmetric matrices, with <a href="#MathOptInterface.side_dimension"><code>side_dimension</code></a> rows and columns. The entries of the upper-right triangular part of the matrix are given column by column (or equivalently, the entries of the lower-left triangular part are given row by row). A vectorized cone of <a href="#MathOptInterface.dimension"><code>dimension</code></a> <span>$n$</span> corresponds to a square matrix with side dimension <span>$\sqrt{1/4 + 2 n} - 1/2$</span>. (Because a <span>$d \times d$</span> matrix has <span>$d(d + 1) / 2$</span> elements in the upper or lower triangle.)</p><p><strong>Examples</strong></p><p>The matrix</p><p class="math-container">\[\begin{bmatrix}
  1 &amp; 2 &amp; 4\\
  2 &amp; 3 &amp; 5\\
  4 &amp; 5 &amp; 6
\end{bmatrix}\]</p><p>has <a href="#MathOptInterface.side_dimension"><code>side_dimension</code></a> 3 and vectorization <span>$(1, 2, 3, 4, 5, 6)$</span>.</p><p><strong>Note</strong></p><p>Two packed storage formats exist for symmetric matrices, the respective orders of the entries are:</p><ul><li>upper triangular column by column (or lower triangular row by row);</li><li>lower triangular column by column (or upper triangular row by row).</li></ul><p>The advantage of the first format is the mapping between the <code>(i, j)</code> matrix indices and the <code>k</code> index of the vectorized form. It is simpler and does not depend on the side dimension of the matrix. Indeed,</p><ul><li>the entry of matrix indices <code>(i, j)</code> has vectorized index <code>k = div((j - 1) * j, 2) + i</code> if <span>$i \leq j$</span> and <code>k = div((i - 1) * i, 2) + j</code> if <span>$j \leq i$</span>;</li><li>and the entry with vectorized index <code>k</code> has matrix indices <code>i = div(1 + isqrt(8k - 7), 2)</code> and <code>j = k - div((i - 1) * i, 2)</code> or <code>j = div(1 + isqrt(8k - 7), 2)</code> and <code>i = k - div((j - 1) * j, 2)</code>.</li></ul><p><strong>Duality note</strong></p><p>The scalar product for the symmetric matrix in its vectorized form is the sum of the pairwise product of the diagonal entries plus twice the sum of the pairwise product of the upper diagonal entries; see [p. 634, 1]. This has important consequence for duality.</p><p>Consider for example the following problem (<a href="#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>PositiveSemidefiniteConeTriangle</code></a> is a subtype of <a href="#MathOptInterface.AbstractSymmetricMatrixSetTriangle"><code>AbstractSymmetricMatrixSetTriangle</code></a>)</p><p class="math-container">\[\begin{align*}
    &amp; \max_{x \in \mathbb{R}} &amp; x
    \\
    &amp; \;\;\text{s.t.} &amp;
    (1, -x, 1) &amp; \in \text{PositiveSemidefiniteConeTriangle}(2).
\end{align*}\]</p><p>The dual is the following problem</p><p class="math-container">\[\begin{align*}
    &amp; \min_{x \in \mathbb{R}^3} &amp; y_1 + y_3
    \\
    &amp; \;\;\text{s.t.} &amp; 2y_2 &amp; = 1\\
    &amp; &amp; y &amp; \in \text{PositiveSemidefiniteConeTriangle}(2).
\end{align*}\]</p><p>Why do we use <span>$2y_2$</span> in the dual constraint instead of <span>$y_2$</span> ? The reason is that <span>$2y_2$</span> is the scalar product between <span>$y$</span> and the symmetric matrix whose vectorized form is <span>$(0, 1, 0)$</span>. Indeed, with our modified scalar products we have</p><p class="math-container">\[\langle
(0, 1, 0),
(y_1, y_2, y_3)
\rangle
=
\mathrm{trace}
\begin{pmatrix}
  0 &amp; 1\\
  1 &amp; 0
\end{pmatrix}
\begin{pmatrix}
  y_1 &amp; y_2\\
  y_2 &amp; y_3
\end{pmatrix}
= 2y_2.\]</p><p><strong>References</strong></p><p>[1] Boyd, S. and Vandenberghe, L.. <em>Convex optimization</em>. Cambridge university press, 2004.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractSymmetricMatrixSetSquare" href="#MathOptInterface.AbstractSymmetricMatrixSetSquare"><code>MathOptInterface.AbstractSymmetricMatrixSetSquare</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractSymmetricMatrixSetSquare &lt;: AbstractVectorSet end</code></pre><p>Abstract supertype for subsets of the (vectorized) cone of symmetric matrices, with <a href="#MathOptInterface.side_dimension"><code>side_dimension</code></a> rows and columns. The entries of the matrix are given column by column (or equivalently, row by row). The matrix is both constrained to be symmetric and to have its <a href="#MathOptInterface.triangular_form"><code>triangular_form</code></a> belong to the corresponding set. That is, if the functions in entries <span>$(i, j)$</span> and <span>$(j, i)$</span> are different, then a constraint will be added to make sure that the entries are equal.</p><p><strong>Examples</strong></p><p><a href="#MathOptInterface.PositiveSemidefiniteConeSquare"><code>PositiveSemidefiniteConeSquare</code></a> is a subtype of <a href="#MathOptInterface.AbstractSymmetricMatrixSetSquare"><code>AbstractSymmetricMatrixSetSquare</code></a> and constraining the matrix</p><p class="math-container">\[\begin{bmatrix}
  1 &amp; -y\\
  -z &amp; 0\\
\end{bmatrix}\]</p><p>to be symmetric positive semidefinite can be achieved by constraining the vector <span>$(1, -z, -y, 0)$</span> (or <span>$(1, -y, -z, 0)$</span>) to belong to the <code>PositiveSemidefiniteConeSquare(2)</code>. It both constrains <span>$y = z$</span> and <span>$(1, -y, 0)$</span> (or <span>$(1, -z, 0)$</span>) to be in <code>PositiveSemidefiniteConeTriangle(2)</code>, since <code>triangular_form(PositiveSemidefiniteConeSquare)</code> is <code>PositiveSemidefiniteConeTriangle</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.side_dimension" href="#MathOptInterface.side_dimension"><code>MathOptInterface.side_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">side_dimension(set::Union{AbstractSymmetricMatrixSetTriangle,
                          AbstractSymmetricMatrixSetSquare})</code></pre><p>Side dimension of the matrices in <code>set</code>. By convention, it should be stored in the <code>side_dimension</code> field but if it is not the case for a subtype of <a href="#MathOptInterface.AbstractSymmetricMatrixSetTriangle"><code>AbstractSymmetricMatrixSetTriangle</code></a>, the method should be implemented for this subtype.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.triangular_form" href="#MathOptInterface.triangular_form"><code>MathOptInterface.triangular_form</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">triangular_form(S::Type{&lt;:AbstractSymmetricMatrixSetSquare})
triangular_form(set::AbstractSymmetricMatrixSetSquare)</code></pre><p>Return the <a href="#MathOptInterface.AbstractSymmetricMatrixSetTriangle"><code>AbstractSymmetricMatrixSetTriangle</code></a> corresponding to the vectorization of the upper triangular part of matrices in the <a href="#MathOptInterface.AbstractSymmetricMatrixSetSquare"><code>AbstractSymmetricMatrixSetSquare</code></a> set.</p></div></section></article><p>List of recognized matrix sets.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.PositiveSemidefiniteConeTriangle" href="#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MathOptInterface.PositiveSemidefiniteConeTriangle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PositiveSemidefiniteConeTriangle(side_dimension) &lt;: AbstractSymmetricMatrixSetTriangle</code></pre><p>The (vectorized) cone of symmetric positive semidefinite matrices, with <code>side_dimension</code> rows and columns. See <a href="#MathOptInterface.AbstractSymmetricMatrixSetTriangle"><code>AbstractSymmetricMatrixSetTriangle</code></a> for more details on the vectorized form.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.PositiveSemidefiniteConeSquare" href="#MathOptInterface.PositiveSemidefiniteConeSquare"><code>MathOptInterface.PositiveSemidefiniteConeSquare</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PositiveSemidefiniteConeSquare(side_dimension) &lt;: AbstractSymmetricMatrixSetSquare</code></pre><p>The cone of symmetric positive semidefinite matrices, with side length <code>side_dimension</code>.  See <a href="#MathOptInterface.AbstractSymmetricMatrixSetSquare"><code>AbstractSymmetricMatrixSetSquare</code></a> for more details on the vectorized form.</p><p>The entries of the matrix are given column by column (or equivalently, row by row). The matrix is both constrained to be symmetric and to be positive semidefinite. That is, if the functions in entries <span>$(i, j)$</span> and <span>$(j, i)$</span> are different, then a constraint will be added to make sure that the entries are equal.</p><p><strong>Examples</strong></p><p>Constraining the matrix</p><p class="math-container">\[\begin{bmatrix}
  1 &amp; -y\\
  -z &amp; 0\\
\end{bmatrix}\]</p><p>to be symmetric positive semidefinite can be achieved by constraining the vector <span>$(1, -z, -y, 0)$</span> (or <span>$(1, -y, -z, 0)$</span>) to belong to the <code>PositiveSemidefiniteConeSquare(2)</code>. It both constrains <span>$y = z$</span> and <span>$(1, -y, 0)$</span> (or <span>$(1, -z, 0)$</span>) to be in <code>PositiveSemidefiniteConeTriangle(2)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.LogDetConeTriangle" href="#MathOptInterface.LogDetConeTriangle"><code>MathOptInterface.LogDetConeTriangle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogDetConeTriangle(side_dimension)</code></pre><p>The log-determinant cone <span>$\{ (t, u, X) \in \mathbb{R}^{2 + d(d+1)/2} : t \le u \log(\det(X/u)), u &gt; 0 \}$</span> where the matrix <code>X</code> is represented in the same symmetric packed format as in the <code>PositiveSemidefiniteConeTriangle</code>. The argument <code>side_dimension</code> is the side dimension of the matrix <code>X</code>, i.e., its number of rows or columns.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.LogDetConeSquare" href="#MathOptInterface.LogDetConeSquare"><code>MathOptInterface.LogDetConeSquare</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogDetConeSquare(side_dimension)</code></pre><p>The log-determinant cone <span>$\{ (t, u, X) \in \mathbb{R}^{2 + d^2} : t \le u \log(\det(X/u)), X \text{ symmetric}, u &gt; 0 \}$</span> where the matrix <code>X</code> is represented in the same format as in the <code>PositiveSemidefiniteConeSquare</code>. Similarly to <code>PositiveSemidefiniteConeSquare</code>, constraints are added to ensures that <code>X</code> is symmetric. The argument <code>side_dimension</code> is the side dimension of the matrix <code>X</code>, i.e., its number of rows or columns.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RootDetConeTriangle" href="#MathOptInterface.RootDetConeTriangle"><code>MathOptInterface.RootDetConeTriangle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RootDetConeTriangle(side_dimension)</code></pre><p>The root-determinant cone <span>$\{ (t, X) \in \mathbb{R}^{1 + d(d+1)/2} : t \le \det(X)^{1/d} \}$</span> where the matrix <code>X</code> is represented in the same symmetric packed format as in the <code>PositiveSemidefiniteConeTriangle</code>. The argument <code>side_dimension</code> is the side dimension of the matrix <code>X</code>, i.e., its number of rows or columns.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RootDetConeSquare" href="#MathOptInterface.RootDetConeSquare"><code>MathOptInterface.RootDetConeSquare</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RootDetConeSquare(side_dimension)</code></pre><p>The root-determinant cone <span>$\{ (t, X) \in \mathbb{R}^{1 + d^2} : t \le \det(X)^{1/d}, X \text{ symmetric} \}$</span> where the matrix <code>X</code> is represented in the same format as in the <code>PositiveSemidefiniteConeSquare</code>. Similarly to <code>PositiveSemidefiniteConeSquare</code>, constraints are added to ensure that <code>X</code> is symmetric. The argument <code>side_dimension</code> is the side dimension of the matrix <code>X</code>, i.e., its number of rows or columns.</p></div></section></article><h2 id="Modifications"><a class="docs-heading-anchor" href="#Modifications">Modifications</a><a id="Modifications-1"></a><a class="docs-heading-anchor-permalink" href="#Modifications" title="Permalink"></a></h2><p>Functions for modifying objective and constraint functions.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.modify" href="#MathOptInterface.modify"><code>MathOptInterface.modify</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Constraint Function</strong></p><pre><code class="language-none">modify(model::ModelLike, ci::ConstraintIndex, change::AbstractFunctionModification)</code></pre><p>Apply the modification specified by <code>change</code> to the function of constraint <code>ci</code>.</p><p>An <a href="#MathOptInterface.ModifyConstraintNotAllowed"><code>ModifyConstraintNotAllowed</code></a> error is thrown if modifying constraints is not supported by the model <code>model</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modify(model, ci, ScalarConstantChange(10.0))</code></pre><p><strong>Objective Function</strong></p><pre><code class="language-none">modify(model::ModelLike, ::ObjectiveFunction, change::AbstractFunctionModification)</code></pre><p>Apply the modification specified by <code>change</code> to the objective function of <code>model</code>. To change the function completely, call <code>set</code> instead.</p><p>An <a href="#MathOptInterface.ModifyObjectiveNotAllowed"><code>ModifyObjectiveNotAllowed</code></a> error is thrown if modifying objectives is not supported by the model <code>model</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modify(model, ObjectiveFunction{ScalarAffineFunction{Float64}}(), ScalarConstantChange(10.0))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractFunctionModification" href="#MathOptInterface.AbstractFunctionModification"><code>MathOptInterface.AbstractFunctionModification</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractFunctionModification</code></pre><p>An abstract supertype for structs which specify partial modifications to functions, to be used for making small modifications instead of replacing the functions entirely.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ScalarConstantChange" href="#MathOptInterface.ScalarConstantChange"><code>MathOptInterface.ScalarConstantChange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScalarConstantChange{T}(new_constant::T)</code></pre><p>A struct used to request a change in the constant term of a scalar-valued function. Applicable to <code>ScalarAffineFunction</code> and <code>ScalarQuadraticFunction</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.VectorConstantChange" href="#MathOptInterface.VectorConstantChange"><code>MathOptInterface.VectorConstantChange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VectorConstantChange{T}(new_constant::Vector{T})</code></pre><p>A struct used to request a change in the constant vector of a vector-valued function. Applicable to <code>VectorAffineFunction</code> and <code>VectorQuadraticFunction</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ScalarCoefficientChange" href="#MathOptInterface.ScalarCoefficientChange"><code>MathOptInterface.ScalarCoefficientChange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScalarCoefficientChange{T}(variable::VariableIndex, new_coefficient::T)</code></pre><p>A struct used to request a change in the linear coefficient of a single variable in a scalar-valued function. Applicable to <code>ScalarAffineFunction</code> and <code>ScalarQuadraticFunction</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.MultirowChange" href="#MathOptInterface.MultirowChange"><code>MathOptInterface.MultirowChange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MultirowChange{T}(variable::VariableIndex, new_coefficients::Vector{Tuple{Int64, T}})</code></pre><p>A struct used to request a change in the linear coefficients of a single variable in a vector-valued function. New coefficients are specified by <code>(output_index, coefficient)</code> tuples. Applicable to <code>VectorAffineFunction</code> and <code>VectorQuadraticFunction</code>.</p></div></section></article><h2 id="Nonlinear-programming-(NLP)"><a class="docs-heading-anchor" href="#Nonlinear-programming-(NLP)">Nonlinear programming (NLP)</a><a id="Nonlinear-programming-(NLP)-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-programming-(NLP)" title="Permalink"></a></h2><h3 id="Attributes-2"><a class="docs-heading-anchor" href="#Attributes-2">Attributes</a><a class="docs-heading-anchor-permalink" href="#Attributes-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NLPBlock" href="#MathOptInterface.NLPBlock"><code>MathOptInterface.NLPBlock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NLPBlock()</code></pre><p>Holds the <code>NLPBlockData</code> that represents a set of nonlinear constraints, and optionally a nonlinear objective.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NLPBoundsPair" href="#MathOptInterface.NLPBoundsPair"><code>MathOptInterface.NLPBoundsPair</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NLPBoundsPair(lower,upper)</code></pre><p>A struct holding a pair of lower and upper bounds. <code>-Inf</code> and <code>Inf</code> can be used to indicate no lower or upper bound, respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NLPBlockData" href="#MathOptInterface.NLPBlockData"><code>MathOptInterface.NLPBlockData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct NLPBlockData
    constraint_bounds::Vector{NLPBoundsPair}
    evaluator::AbstractNLPEvaluator
    has_objective::Bool
end</code></pre><p>A <code>struct</code> encoding a set of nonlinear constraints of the form <span>$lb \le g(x) \le ub$</span> and, if <code>has_objective == true</code>, a nonlinear objective function <span>$f(x)$</span>. <code>constraint_bounds</code> holds the pairs of <span>$lb$</span> and <span>$ub$</span> elements. Nonlinear objectives <em>override</em> any objective set by using the <code>ObjectiveFunction</code> attribute. The <code>evaluator</code> is a callback object that is used to query function values, derivatives, and expression graphs. If <code>has_objective == false</code>, then it is an error to query properties of the objective function, and in Hessian-of-the-Lagrangian queries, <code>σ</code> must be set to zero. Throughout the evaluator, all variables are ordered according to ListOfVariableIndices(). </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NLPBlockDual" href="#MathOptInterface.NLPBlockDual"><code>MathOptInterface.NLPBlockDual</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NLPBlockDual(N)
NLPBlockDual()</code></pre><p>The Lagrange multipliers on the constraints from the <code>NLPBlock</code> in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NLPBlockDualStart" href="#MathOptInterface.NLPBlockDualStart"><code>MathOptInterface.NLPBlockDualStart</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NLPBlockDualStart()</code></pre><p>An initial assignment of the Lagrange multipliers on the constraints from the <code>NLPBlock</code> that the solver may use to warm-start the solve.</p></div></section></article><h3 id="NLP-evaluator-methods"><a class="docs-heading-anchor" href="#NLP-evaluator-methods">NLP evaluator methods</a><a id="NLP-evaluator-methods-1"></a><a class="docs-heading-anchor-permalink" href="#NLP-evaluator-methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractNLPEvaluator" href="#MathOptInterface.AbstractNLPEvaluator"><code>MathOptInterface.AbstractNLPEvaluator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractNLPEvaluator</code></pre><p>Abstract supertype for the callback object used in <code>NLPBlock</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.initialize" href="#MathOptInterface.initialize"><code>MathOptInterface.initialize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">initialize(d::AbstractNLPEvaluator, requested_features::Vector{Symbol})</code></pre><p>Must be called before any other methods. The vector <code>requested_features</code> lists features requested by the solver. These may include <code>:Grad</code> for gradients of <span>$f$</span>, <code>:Jac</code> for explicit Jacobians of <span>$g$</span>, <code>:JacVec</code> for Jacobian-vector products, <code>:HessVec</code> for Hessian-vector and Hessian-of-Lagrangian-vector products, <code>:Hess</code> for explicit Hessians and Hessian-of-Lagrangians, and <code>:ExprGraph</code> for expression graphs.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.features_available" href="#MathOptInterface.features_available"><code>MathOptInterface.features_available</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">features_available(d::AbstractNLPEvaluator)</code></pre><p>Returns the subset of features available for this problem instance, as a list of symbols in the same format as in <code>initialize</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.eval_objective" href="#MathOptInterface.eval_objective"><code>MathOptInterface.eval_objective</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_objective(d::AbstractNLPEvaluator, x)</code></pre><p>Evaluate the objective <span>$f(x)$</span>, returning a scalar value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.eval_constraint" href="#MathOptInterface.eval_constraint"><code>MathOptInterface.eval_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_constraint(d::AbstractNLPEvaluator, g, x)</code></pre><p>Evaluate the constraint function <span>$g(x)$</span>, storing the result in the vector <code>g</code> which must be of the appropriate size.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.eval_objective_gradient" href="#MathOptInterface.eval_objective_gradient"><code>MathOptInterface.eval_objective_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_objective_gradient(d::AbstractNLPEvaluator, g, x)</code></pre><p>Evaluate <span>$\nabla f(x)$</span> as a dense vector, storing the result in the vector <code>g</code> which must be of the appropriate size.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.jacobian_structure" href="#MathOptInterface.jacobian_structure"><code>MathOptInterface.jacobian_structure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">jacobian_structure(d::AbstractNLPEvaluator)::Vector{Tuple{Int64,Int64}}</code></pre><p>Returns the sparsity structure of the Jacobian matrix <span>$J_g(x) = \left[ \begin{array}{c} \nabla g_1(x) \\ \nabla g_2(x) \\ \vdots \\ \nabla g_m(x) \end{array}\right]$</span> where <span>$g_i$</span> is the <span>$i\text{th}$</span> component of <span>$g$</span>. The sparsity structure is assumed to be independent of the point <span>$x$</span>. Returns a vector of tuples, <code>(row, column)</code>, where each indicates the position of a structurally nonzero element. These indices are not required to be sorted and can contain duplicates, in which case the solver should combine the corresponding elements by adding them together.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.hessian_lagrangian_structure" href="#MathOptInterface.hessian_lagrangian_structure"><code>MathOptInterface.hessian_lagrangian_structure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hessian_lagrangian_structure(d::AbstractNLPEvaluator)::Vector{Tuple{Int64,Int64}}</code></pre><p>Returns the sparsity structure of the Hessian-of-the-Lagrangian matrix <span>$\nabla^2 f + \sum_{i=1}^m \nabla^2 g_i$</span> as a vector of tuples, where each indicates the position of a structurally nonzero element. These indices are not required to be sorted and can contain duplicates, in which case the solver should combine the corresponding elements by adding them together. Any mix of lower and upper-triangular indices is valid. Elements <code>(i,j)</code> and <code>(j,i)</code>, if both present, should be treated as duplicates.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.eval_constraint_jacobian" href="#MathOptInterface.eval_constraint_jacobian"><code>MathOptInterface.eval_constraint_jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_constraint_jacobian(d::AbstractNLPEvaluator, J, x)</code></pre><p>Evaluates the sparse Jacobian matrix <span>$J_g(x) = \left[ \begin{array}{c} \nabla g_1(x) \\ \nabla g_2(x) \\ \vdots \\ \nabla g_m(x) \end{array}\right]$</span>. The result is stored in the vector <code>J</code> in the same order as the indices returned by <code>jacobian_structure</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.eval_constraint_jacobian_product" href="#MathOptInterface.eval_constraint_jacobian_product"><code>MathOptInterface.eval_constraint_jacobian_product</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_constraint_jacobian_product(d::AbstractNLPEvaluator, y, x, w)</code></pre><p>Computes the Jacobian-vector product <span>$J_g(x)w$</span>, storing the result in the vector <code>y</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.eval_constraint_jacobian_transpose_product" href="#MathOptInterface.eval_constraint_jacobian_transpose_product"><code>MathOptInterface.eval_constraint_jacobian_transpose_product</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_constraint_jacobian_transpose_product(d::AbstractNLPEvaluator, y, x, w)</code></pre><p>Computes the Jacobian-transpose-vector product <span>$J_g(x)^Tw$</span>, storing the result in the vector <code>y</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.eval_hessian_lagrangian" href="#MathOptInterface.eval_hessian_lagrangian"><code>MathOptInterface.eval_hessian_lagrangian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_hessian_lagrangian(d::AbstractNLPEvaluator, H, x, σ, μ)</code></pre><p>Given scalar weight <code>σ</code> and vector of constraint weights <code>μ</code>, computes the sparse Hessian-of-the-Lagrangian matrix <span>$\sigma\nabla^2 f(x) + \sum_{i=1}^m \mu_i \nabla^2 g_i(x)$</span>, storing the result in the vector <code>H</code> in the same order as the indices returned by <code>hessian_lagrangian_structure</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.eval_hessian_lagrangian_product" href="#MathOptInterface.eval_hessian_lagrangian_product"><code>MathOptInterface.eval_hessian_lagrangian_product</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_hessian_lagrangian_product(d::AbstractNLPEvaluator, h, x, v, σ, μ)</code></pre><p>Given scalar weight <code>σ</code> and vector of constraint weights <code>μ</code>, computes the Hessian-of-the-Lagrangian-vector product <span>$\left(\sigma\nabla^2 f(x) + \sum_{i=1}^m \mu_i \nabla^2 g_i(x)\right)v$</span>, storing the result in the vector <code>h</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.objective_expr" href="#MathOptInterface.objective_expr"><code>MathOptInterface.objective_expr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">objective_expr(d::AbstractNLPEvaluator)</code></pre><p>Returns an expression graph for the objective function as a standard Julia <code>Expr</code> object. All sums and products are flattened out as simple <code>Expr(:+,...)</code> and <code>Expr(:*,...)</code> objects. The symbol <code>x</code> is used as a placeholder for the vector of decision variables. No other undefined symbols are permitted; coefficients are embedded as explicit values. For example, the expression <span>$x_1+\sin(x_2/\exp(x_3))$</span> would be represented as the Julia object <code>:(x[1] + sin(x[2]/exp(x[3])))</code>. Each integer index is wrapped in a <a href="#MathOptInterface.VariableIndex"><code>VariableIndex</code></a>. See the <a href="https://docs.julialang.org/en/release-0.6/manual/metaprogramming/">Julia manual</a> for more information on the structure of <code>Expr</code> objects. There are currently no restrictions on recognized functions; typically these will be built-in Julia functions like <code>^</code>, <code>exp</code>, <code>log</code>, <code>cos</code>, <code>tan</code>, <code>sqrt</code>, etc., but modeling interfaces may choose to extend these basic functions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.constraint_expr" href="#MathOptInterface.constraint_expr"><code>MathOptInterface.constraint_expr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">constraint_expr(d::AbstractNLPEvaluator, i)</code></pre><p>Returns an expression graph for the <span>$i\text{th}$</span> constraint in the same format as described above, with an additional comparison operator indicating the sense of and bounds on the constraint. The right-hand side of the comparison must be a constant; that is, <code>:(x[1]^3 &lt;= 1)</code> is allowed, while <code>:(1 &lt;= x[1]^3)</code> is not valid. Double-sided constraints are allowed, in which case both the lower bound and upper bounds should be constants; for example, <code>:(-1 &lt;= cos(x[1]) + sin(x[2]) &lt;= 1)</code> is valid.</p></div></section></article><h2 id="Errors"><a class="docs-heading-anchor" href="#Errors">Errors</a><a id="Errors-1"></a><a class="docs-heading-anchor-permalink" href="#Errors" title="Permalink"></a></h2><p>When an MOI call fails on a model, precise errors should be thrown when possible instead of simply calling <code>error</code> with a message. The docstrings for the respective methods describe the errors that the implementation should thrown in certain situations. This error-reporting system allows code to distinguish between internal errors (that should be shown to the user) and unsupported operations which may have automatic workarounds.</p><p>When an invalid index is used in an MOI call, an <a href="#MathOptInterface.InvalidIndex"><code>InvalidIndex</code></a> should be thrown:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.InvalidIndex" href="#MathOptInterface.InvalidIndex"><code>MathOptInterface.InvalidIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct InvalidIndex{IndexType&lt;:Index} &lt;: Exception
    index::IndexType
end</code></pre><p>An error indicating that the index <code>index</code> is invalid.</p></div></section></article><p>As discussed in <a href="../manual/implementing/#JuMP-mapping">JuMP mapping</a>, for scalar constraint with a nonzero function constant, a <a href="#MathOptInterface.ScalarFunctionConstantNotZero"><code>ScalarFunctionConstantNotZero</code></a> exception may be thrown:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ScalarFunctionConstantNotZero" href="#MathOptInterface.ScalarFunctionConstantNotZero"><code>MathOptInterface.ScalarFunctionConstantNotZero</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ScalarFunctionConstantNotZero{T, F, S} &lt;: Exception
    constant::T
end</code></pre><p>An error indicating that the constant part of the function in the constraint <code>F</code>-in-<code>S</code> is nonzero.</p></div></section></article><p>Some <a href="#MathOptInterface.SingleVariable"><code>SingleVariable</code></a> constraints cannot be combined on the same variable:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.LowerBoundAlreadySet" href="#MathOptInterface.LowerBoundAlreadySet"><code>MathOptInterface.LowerBoundAlreadySet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LowerBoundAlreadySet{S1, S2}</code></pre><p>Error thrown when setting a <code>SingleVariable</code>-in-<code>S2</code> when a <code>SingleVariable</code>-in-<code>S1</code> has already been added and the sets <code>S1</code>, <code>S2</code> both set a lower bound, i.e. they are <a href="#MathOptInterface.EqualTo"><code>EqualTo</code></a>, <a href="#MathOptInterface.GreaterThan"><code>GreaterThan</code></a>, <a href="#MathOptInterface.Interval"><code>Interval</code></a>, <a href="#MathOptInterface.Semicontinuous"><code>Semicontinuous</code></a> or <a href="#MathOptInterface.Semiinteger"><code>Semiinteger</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.UpperBoundAlreadySet" href="#MathOptInterface.UpperBoundAlreadySet"><code>MathOptInterface.UpperBoundAlreadySet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UpperBoundAlreadySet{S1, S2}</code></pre><p>Error thrown when setting a <code>SingleVariable</code>-in-<code>S2</code> when a <code>SingleVariable</code>-in-<code>S1</code> has already been added and the sets <code>S1</code>, <code>S2</code> both set an upper bound, i.e. they are <a href="#MathOptInterface.EqualTo"><code>EqualTo</code></a>, <a href="#MathOptInterface.LessThan"><code>LessThan</code></a>, <a href="#MathOptInterface.Interval"><code>Interval</code></a>, <a href="#MathOptInterface.Semicontinuous"><code>Semicontinuous</code></a> or <a href="#MathOptInterface.Semiinteger"><code>Semiinteger</code></a>.</p></div></section></article><p>As discussed in <a href="#MathOptInterface.AbstractCallback"><code>AbstractCallback</code></a>, trying to <a href="#MathOptInterface.get"><code>get</code></a> attributes inside a callback may throw:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.OptimizeInProgress" href="#MathOptInterface.OptimizeInProgress"><code>MathOptInterface.OptimizeInProgress</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct OptimizeInProgress{AttrType&lt;:AnyAttribute} &lt;: Exception
    attr::AttrType
end</code></pre><p>Error thrown from optimizer when <code>MOI.get(optimizer, attr)</code> is called inside an <a href="#MathOptInterface.AbstractCallback"><code>AbstractCallback</code></a> while it is only defined once <a href="#MathOptInterface.optimize!"><code>optimize!</code></a> has completed. This can only happen when <code>is_set_by_optimize(attr)</code> is <code>true</code>.</p></div></section></article><p>Trying to submit the wrong type of <a href="#MathOptInterface.AbstractSubmittable"><code>AbstractSubmittable</code></a> inside an <a href="#MathOptInterface.AbstractCallback"><code>AbstractCallback</code></a> (e.g., a <a href="#MathOptInterface.UserCut"><code>UserCut</code></a> inside a <a href="#MathOptInterface.LazyConstraintCallback"><code>LazyConstraintCallback</code></a>) will throw:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.InvalidCallbackUsage" href="#MathOptInterface.InvalidCallbackUsage"><code>MathOptInterface.InvalidCallbackUsage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct InvalidCallbackUsage{C, S} &lt;: Exception
    callback::C
    submittable::S
end</code></pre><p>An error indicating that <code>submittable</code> cannot be submitted inside <code>callback</code>.</p><p>For example, <a href="#MathOptInterface.UserCut"><code>UserCut</code></a> cannot be submitted inside <a href="#MathOptInterface.LazyConstraintCallback"><code>LazyConstraintCallback</code></a>.</p></div></section></article><p>The rest of the errors defined in MOI fall in two categories represented by the following two abstract types:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.UnsupportedError" href="#MathOptInterface.UnsupportedError"><code>MathOptInterface.UnsupportedError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UnsupportedError &lt;: Exception</code></pre><p>Abstract type for error thrown when an element is not supported by the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NotAllowedError" href="#MathOptInterface.NotAllowedError"><code>MathOptInterface.NotAllowedError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NotAllowedError &lt;: Exception</code></pre><p>Abstract type for error thrown when an operation is supported but cannot be applied in the current state of the model.</p></div></section></article><p>The different <a href="#MathOptInterface.UnsupportedError"><code>UnsupportedError</code></a> and <a href="#MathOptInterface.NotAllowedError"><code>NotAllowedError</code></a> are the following errors:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.UnsupportedAttribute" href="#MathOptInterface.UnsupportedAttribute"><code>MathOptInterface.UnsupportedAttribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct UnsupportedAttribute{AttrType} &lt;: UnsupportedError
    attr::AttrType
    message::String
end</code></pre><p>An error indicating that the attribute <code>attr</code> is not supported by the model, i.e. that <a href="#MathOptInterface.supports"><code>supports</code></a> returns <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SetAttributeNotAllowed" href="#MathOptInterface.SetAttributeNotAllowed"><code>MathOptInterface.SetAttributeNotAllowed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SetAttributeNotAllowed{AttrType} &lt;: NotAllowedError
    attr::AttrType
    message::String # Human-friendly explanation why the attribute cannot be set
end</code></pre><p>An error indicating that the attribute <code>attr</code> is supported (see <a href="#MathOptInterface.supports"><code>supports</code></a>) but cannot be set for some reason (see the error string).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AddVariableNotAllowed" href="#MathOptInterface.AddVariableNotAllowed"><code>MathOptInterface.AddVariableNotAllowed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct AddVariableNotAllowed &lt;: NotAllowedError
    message::String # Human-friendly explanation why the attribute cannot be set
end</code></pre><p>An error indicating that variables cannot be added to the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.UnsupportedConstraint" href="#MathOptInterface.UnsupportedConstraint"><code>MathOptInterface.UnsupportedConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct UnsupportedConstraint{F&lt;:AbstractFunction, S&lt;:AbstractSet} &lt;: UnsupportedError
    message::String # Human-friendly explanation why the attribute cannot be set
end</code></pre><p>An error indicating that constraints of type <code>F</code>-in-<code>S</code> are not supported by the model, i.e. that <a href="#MathOptInterface.supports_constraint"><code>supports_constraint</code></a> returns <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AddConstraintNotAllowed" href="#MathOptInterface.AddConstraintNotAllowed"><code>MathOptInterface.AddConstraintNotAllowed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct AddConstraintNotAllowed{F&lt;:AbstractFunction, S&lt;:AbstractSet} &lt;: NotAllowedError
    message::String # Human-friendly explanation why the attribute cannot be set
end</code></pre><p>An error indicating that constraints of type <code>F</code>-in-<code>S</code> are supported (see <a href="#MathOptInterface.supports_constraint"><code>supports_constraint</code></a>) but cannot be added.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ModifyConstraintNotAllowed" href="#MathOptInterface.ModifyConstraintNotAllowed"><code>MathOptInterface.ModifyConstraintNotAllowed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ModifyConstraintNotAllowed{F&lt;:AbstractFunction, S&lt;:AbstractSet,
                                  C&lt;:AbstractFunctionModification} &lt;: NotAllowedError
    constraint_index::ConstraintIndex{F, S}
    change::C
    message::String
end</code></pre><p>An error indicating that the constraint modification <code>change</code> cannot be applied to the constraint of index <code>ci</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ModifyObjectiveNotAllowed" href="#MathOptInterface.ModifyObjectiveNotAllowed"><code>MathOptInterface.ModifyObjectiveNotAllowed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ModifyObjectiveNotAllowed{C&lt;:AbstractFunctionModification} &lt;: NotAllowedError
    change::C
    message::String
end</code></pre><p>An error indicating that the objective modification <code>change</code> cannot be applied to the objective.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.DeleteNotAllowed" href="#MathOptInterface.DeleteNotAllowed"><code>MathOptInterface.DeleteNotAllowed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct DeleteNotAllowed{IndexType &lt;: Index} &lt;: NotAllowedError
    index::IndexType
    message::String
end</code></pre><p>An error indicating that the index <code>index</code> cannot be deleted.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.UnsupportedSubmittable" href="#MathOptInterface.UnsupportedSubmittable"><code>MathOptInterface.UnsupportedSubmittable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct UnsupportedSubmittable{SubmitType} &lt;: UnsupportedError
    sub::SubmitType
    message::String
end</code></pre><p>An error indicating that the submittable <code>sub</code> is not supported by the model, i.e. that <a href="#MathOptInterface.supports"><code>supports</code></a> returns <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SubmitNotAllowed" href="#MathOptInterface.SubmitNotAllowed"><code>MathOptInterface.SubmitNotAllowed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SubmitNotAllowed{SubmitTyp&lt;:AbstractSubmittable} &lt;: NotAllowedError
    sub::SubmitType
    message::String # Human-friendly explanation why the attribute cannot be set
end</code></pre><p>An error indicating that the submittable <code>sub</code> is supported (see <a href="#MathOptInterface.supports"><code>supports</code></a>) but cannot be added for some reason (see the error string).</p></div></section></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><p><a href="#MathOptInterface.Utilities.Model"><code>Utilities.Model</code></a> provides an implementation of a <a href="#MathOptInterface.ModelLike"><code>ModelLike</code></a> that efficiently supports all functions and sets defined within MOI. However, given the extensibility of MOI, this might not over all use cases.</p><p><a href="#MathOptInterface.Utilities.UniversalFallback"><code>Utilities.UniversalFallback</code></a> is a layer that sits on top of any <code>ModelLike</code> and provides non-specialized (slower) fallbacks for constraints and attributes that the underlying <code>ModeLike</code> does not support.</p><p>For advanced use cases that need efficient support for functions and sets defined outside of MOI (but still known at compile time), we provide the <a href="#MathOptInterface.Utilities.@model"><code>Utilities.@model</code></a> macro.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.Model" href="#MathOptInterface.Utilities.Model"><code>MathOptInterface.Utilities.Model</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An implementation of <code>ModelLike</code> that supports all functions and sets defined in MOI. It is parameterized by the coefficient type.</p><p><strong>Examples</strong></p><pre><code class="language-jl">model = Model{Float64}()
x = add_variable(model)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.UniversalFallback" href="#MathOptInterface.Utilities.UniversalFallback"><code>MathOptInterface.Utilities.UniversalFallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UniversalFallback</code></pre><p>The <code>UniversalFallback</code> can be applied on a <a href="#MathOptInterface.ModelLike"><code>MathOptInterface.ModelLike</code></a> <code>model</code> to create the model <code>UniversalFallback(model)</code> supporting <em>any</em> constraint and attribute. This allows to have a specialized implementation in <code>model</code> for performance critical constraints and attributes while still supporting other attributes with a small performance penalty. Note that <code>model</code> is unaware of constraints and attributes stored by <code>UniversalFallback</code> so this is not appropriate if <code>model</code> is an optimizer (for this reason, <a href="#MathOptInterface.optimize!"><code>MathOptInterface.optimize!</code></a> has not been implemented). In that case, optimizer bridges should be used instead.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.@model" href="#MathOptInterface.Utilities.@model"><code>MathOptInterface.Utilities.@model</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">macro model(
    model_name,
    scalar_sets,
    typed_scalar_sets,
    vector_sets,
    typed_vector_sets,
    scalar_functions,
    typed_scalar_functions,
    vector_functions,
    typed_vector_functions,
    is_optimizer = false
)</code></pre><p>Creates a type <code>model_name</code> implementing the MOI model interface and containing <code>scalar_sets</code> scalar sets <code>typed_scalar_sets</code> typed scalar sets, <code>vector_sets</code> vector sets, <code>typed_vector_sets</code> typed vector sets, <code>scalar_functions</code> scalar functions, <code>typed_scalar_functions</code> typed scalar functions, <code>vector_functions</code> vector functions and <code>typed_vector_functions</code> typed vector functions. To give no set/function, write <code>()</code>, to give one set <code>S</code>, write <code>(S,)</code>.</p><p>The function <a href="#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a> should not be given in <code>scalar_functions</code>. The model supports <a href="#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a>-in-<code>F</code> constraints where <code>F</code> is <a href="#MathOptInterface.EqualTo"><code>MathOptInterface.EqualTo</code></a>, <a href="#MathOptInterface.GreaterThan"><code>MathOptInterface.GreaterThan</code></a>, <a href="#MathOptInterface.LessThan"><code>MathOptInterface.LessThan</code></a>, <a href="#MathOptInterface.Interval"><code>MathOptInterface.Interval</code></a>, <a href="#MathOptInterface.Integer"><code>MathOptInterface.Integer</code></a>, <a href="#MathOptInterface.ZeroOne"><code>MathOptInterface.ZeroOne</code></a>, <a href="#MathOptInterface.Semicontinuous"><code>MathOptInterface.Semicontinuous</code></a> or <a href="#MathOptInterface.Semiinteger"><code>MathOptInterface.Semiinteger</code></a>. The sets supported with the <a href="#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a> cannot be controlled from the macro, use the <a href="#MathOptInterface.Utilities.UniversalFallback"><code>UniversalFallback</code></a> to support more sets.</p><p>This macro creates a model specialized for specific types of constraint, by defining specialized structures and methods. To create a model that, in addition to be optimized for specific constraints, also support arbitrary constraints and attributes, use <a href="#MathOptInterface.Utilities.UniversalFallback"><code>UniversalFallback</code></a>.</p><p>This implementation of the MOI model certifies that the constraint indices, in addition to being different between constraints <code>F</code>-in-<code>S</code> for the same types <code>F</code> and <code>S</code>, are also different between constraints for different types <code>F</code> and <code>S</code>. This means that for constraint indices <code>ci1</code>, <code>ci2</code> of this model, <code>ci1 == ci2</code> if and only if <code>ci1.value == ci2.value</code>. This fact can be used to use the the value of the index directly in a dictionary representing a mapping between constraint indices and something else.</p><p>If <code>is_optimizer = true</code>, the resulting struct is a subtype of of <code>MOIU.AbstractOptimizer</code>, which is a subtype of <a href="#MathOptInterface.AbstractOptimizer"><code>MathOptInterface.AbstractOptimizer</code></a>, otherwise, it is a subtype of <code>MOIU.AbstractModelLike</code>, which is a subtype of <a href="#MathOptInterface.ModelLike"><code>MathOptInterface.ModelLike</code></a>.</p><p><strong>Examples</strong></p><p>The model describing an linear program would be:</p><pre><code class="language-julia">@model(LPModel,                                                   # Name of model
      (),                                                         # untyped scalar sets
      (MOI.EqualTo, MOI.GreaterThan, MOI.LessThan, MOI.Interval), #   typed scalar sets
      (MOI.Zeros, MOI.Nonnegatives, MOI.Nonpositives),            # untyped vector sets
      (),                                                         #   typed vector sets
      (),                                                         # untyped scalar functions
      (MOI.ScalarAffineFunction,),                                #   typed scalar functions
      (MOI.VectorOfVariables,),                                   # untyped vector functions
      (MOI.VectorAffineFunction,),                                #   typed vector functions
      false
    )</code></pre><p>Let <code>MOI</code> denote <code>MathOptInterface</code>, <code>MOIU</code> denote <code>MOI.Utilities</code> and <code>MOIU.ConstraintEntry{F, S}</code> be defined as <code>MOI.Tuple{MOI.ConstraintIndex{F, S}, F, S}</code>. The macro would create the types:</p><pre><code class="language-julia">struct LPModelScalarConstraints{T, F &lt;: MOI.AbstractScalarFunction} &lt;: MOIU.Constraints{F}
    equalto::Vector{MOIU.ConstraintEntry{F, MOI.EqualTo{T}}}
    greaterthan::Vector{MOIU.ConstraintEntry{F, MOI.GreaterThan{T}}}
    lessthan::Vector{MOIU.ConstraintEntry{F, MOI.LessThan{T}}}
    interval::Vector{MOIU.ConstraintEntry{F, MOI.Interval{T}}}
end
struct LPModelVectorConstraints{T, F &lt;: MOI.AbstractVectorFunction} &lt;: MOIU.Constraints{F}
    zeros::Vector{MOIU.ConstraintEntry{F, MOI.Zeros}}
    nonnegatives::Vector{MOIU.ConstraintEntry{F, MOI.Nonnegatives}}
    nonpositives::Vector{MOIU.ConstraintEntry{F, MOI.Nonpositives}}
end
mutable struct LPModel{T} &lt;: MOIU.AbstractModel{T}
    name::String
    sense::MOI.OptimizationSense
    objective::Union{MOI.SingleVariable, MOI.ScalarAffineFunction{T}, MOI.ScalarQuadraticFunction{T}}
    num_variables_created::Int64
    # If nothing, no variable has been deleted so the indices of the
    # variables are VI.(1:num_variables_created)
    variable_indices::Union{Nothing, Set{MOI.VariableIndex}}
    # Union of flags of `S` such that a `SingleVariable`-in-`S`
    # constraint was added to the model and not deleted yet.
    single_variable_mask::Vector{UInt8}
    # Lower bound set by `SingleVariable`-in-`S` where `S`is
    # `GreaterThan{T}`, `EqualTo{T}` or `Interval{T}`.
    lower_bound::Vector{T}
    # Lower bound set by `SingleVariable`-in-`S` where `S`is
    # `LessThan{T}`, `EqualTo{T}` or `Interval{T}`.
    upper_bound::Vector{T}
    var_to_name::Dict{MOI.VariableIndex, String}
    # If `nothing`, the dictionary hasn&#39;t been constructed yet.
    name_to_var::Union{Dict{String, MOI.VariableIndex}, Nothing}
    nextconstraintid::Int64
    con_to_name::Dict{MOI.ConstraintIndex, String}
    name_to_con::Union{Dict{String, MOI.ConstraintIndex}, Nothing}
    constrmap::Vector{Int}
    scalaraffinefunction::LPModelScalarConstraints{T, MOI.ScalarAffineFunction{T}}
    vectorofvariables::LPModelVectorConstraints{T, MOI.VectorOfVariables}
    vectoraffinefunction::LPModelVectorConstraints{T, MOI.VectorAffineFunction{T}}
end</code></pre><p>The type <code>LPModel</code> implements the MathOptInterface API except methods specific to solver models like <code>optimize!</code> or <code>getattribute</code> with <code>VariablePrimal</code>.</p></div></section></article><h2 id="Bridges"><a class="docs-heading-anchor" href="#Bridges">Bridges</a><a id="Bridges-1"></a><a class="docs-heading-anchor-permalink" href="#Bridges" title="Permalink"></a></h2><p>Bridges can be used for automatic reformulation of constrained variables (i.e. variables added with <a href="#MathOptInterface.add_constrained_variable"><code>add_constrained_variable</code></a>/<a href="#MathOptInterface.add_constrained_variables"><code>add_constrained_variables</code></a>) or constraints into equivalent formulations using constrained variables and constraints of different types. There are two important concepts to distinguish:</p><ul><li><a href="#MathOptInterface.Bridges.AbstractBridge"><code>Bridges.AbstractBridge</code></a>s are recipes implementing a specific reformulation. Bridges are not directly subtypes of <a href="#MathOptInterface.Bridges.AbstractBridge"><code>Bridges.AbstractBridge</code></a>, they are either <a href="#MathOptInterface.Bridges.Variable.AbstractBridge"><code>Bridges.Variable.AbstractBridge</code></a> or <a href="#MathOptInterface.Bridges.Constraint.AbstractBridge"><code>Bridges.Constraint.AbstractBridge</code></a>.</li><li><a href="#MathOptInterface.Bridges.AbstractBridgeOptimizer"><code>Bridges.AbstractBridgeOptimizer</code></a> is a layer that can be applied to another <a href="#MathOptInterface.ModelLike"><code>ModelLike</code></a> to apply the reformulation. The <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>Bridges.LazyBridgeOptimizer</code></a> automatically chooses the appropriate bridges to use when a constrained variable or constraint is not supported by using the list of bridges that were added to it by <a href="#MathOptInterface.Bridges.add_bridge"><code>Bridges.add_bridge</code></a>. <a href="#MathOptInterface.Bridges.full_bridge_optimizer"><code>Bridges.full_bridge_optimizer</code></a> wraps a model in a <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>Bridges.LazyBridgeOptimizer</code></a> where all the bridges defined in MOI are added. This is the recommended way to use bridges in the <a href="../manual/implementing/#Testing-guideline">Testing guideline</a>, and JuMP automatically calls <a href="#MathOptInterface.Bridges.full_bridge_optimizer"><code>Bridges.full_bridge_optimizer</code></a> when attaching an optimizer. <a href="#MathOptInterface.Bridges.debug_supports_constraint"><code>Bridges.debug_supports_constraint</code></a> and <a href="#MathOptInterface.Bridges.debug_supports"><code>Bridges.debug_supports</code></a> allow introspection into the bridge selection rationale of <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>Bridges.LazyBridgeOptimizer</code></a>.</li></ul><p>Most bridges are added by default in <a href="#MathOptInterface.Bridges.full_bridge_optimizer"><code>Bridges.full_bridge_optimizer</code></a>. However, for technical reasons, some bridges are not added by default, for instance: <a href="#MathOptInterface.Bridges.Constraint.SOCtoPSDBridge"><code>Bridges.Constraint.SOCtoPSDBridge</code></a>, <a href="#MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge"><code>Bridges.Constraint.SOCtoNonConvexQuadBridge</code></a> and <a href="#MathOptInterface.Bridges.Constraint.RSOCtoNonConvexQuadBridge"><code>Bridges.Constraint.RSOCtoNonConvexQuadBridge</code></a>. See the docs of those bridges for more information.</p><p>It is possible to add those bridges and also user defined bridges, following one of the two methods. We present the examples for: <a href="#MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge"><code>Bridges.Constraint.SOCtoNonConvexQuadBridge</code></a>.</p><p>The first option is to add the specific bridges to a <code>bridged_model</code> optimizer, with coefficient type <code>T</code>. The <code>bridged_model</code> optimizer itself must have been constructed with a <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>Bridges.LazyBridgeOptimizer</code></a>. Once such a optimizer is available, we can proceed using using <a href="#MathOptInterface.Bridges.add_bridge"><code>Bridges.add_bridge</code></a>:</p><pre><code class="language-julia">MOIB.add_bridge(bridged_model, SOCtoNonConvexQuadBridge{T})</code></pre><p>Alternatively, it is possible to create a <a href="#MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer"><code>Bridges.Constraint.SingleBridgeOptimizer</code></a> and wrap an existing <code>model</code> with it:</p><pre><code class="language-julia">const SOCtoNonConvexQuad{T, OT&lt;:ModelLike} = Bridges.Constraint.SingleBridgeOptimizer{Bridges.Constraint.SOCtoNonConvexQuadBridge{T}, OT}
bridged_model = SOCtoNonConvexQuad{Float64}(model)</code></pre><p>Those procedures could be applied to user define bridges. For the bridges defined in MathOptInterface, the <a href="#MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer"><code>Bridges.Constraint.SingleBridgeOptimizer</code></a>&#39;s are already created, therefore, for the case of <a href="#MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge"><code>Bridges.Constraint.SOCtoNonConvexQuadBridge</code></a>, one could simply use the existing optimizer:</p><pre><code class="language-julia">bridged_model = Bridges.Constraint.SOCtoNonConvexQuad{Float64}(model)</code></pre><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.AbstractBridge" href="#MathOptInterface.Bridges.AbstractBridge"><code>MathOptInterface.Bridges.AbstractBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractBridge</code></pre><p>Represents a bridged constraint or variable in a <a href="#MathOptInterface.Bridges.AbstractBridgeOptimizer"><code>MathOptInterface.Bridges.AbstractBridgeOptimizer</code></a>. It contains the indices of the variables and constraints that it has created in the model. These can be obtained using <a href="#MathOptInterface.NumberOfVariables"><code>MathOptInterface.NumberOfVariables</code></a>, <a href="#MathOptInterface.ListOfVariableIndices"><code>MathOptInterface.ListOfVariableIndices</code></a>, <a href="#MathOptInterface.NumberOfConstraints"><code>MathOptInterface.NumberOfConstraints</code></a> and <a href="#MathOptInterface.ListOfConstraintIndices"><code>MathOptInterface.ListOfConstraintIndices</code></a> using <a href="#MathOptInterface.get"><code>MathOptInterface.get</code></a> with the bridge in place of the <a href="#MathOptInterface.ModelLike"><code>MathOptInterface.ModelLike</code></a>. Attributes of the bridged model such as <a href="#MathOptInterface.ConstraintDual"><code>MathOptInterface.ConstraintDual</code></a> and <a href="#MathOptInterface.ConstraintPrimal"><code>MathOptInterface.ConstraintPrimal</code></a>, can be obtained using <a href="#MathOptInterface.get"><code>MathOptInterface.get</code></a> with the bridge in place of the constraint index. These calls are used by the <a href="#MathOptInterface.Bridges.AbstractBridgeOptimizer"><code>MathOptInterface.Bridges.AbstractBridgeOptimizer</code></a> to communicate with the bridge so they should be implemented by the bridge.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.AbstractBridgeOptimizer" href="#MathOptInterface.Bridges.AbstractBridgeOptimizer"><code>MathOptInterface.Bridges.AbstractBridgeOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractBridgeOptimizer</code></pre><p>A bridge optimizer applies given constraint bridges to a given optimizer thus extending the types of supported constraints. The attributes of the inner optimizer are automatically transformed to make the bridges transparent, e.g. the variables and constraints created by the bridges are hidden.</p><p>By convention, the inner optimizer should be stored in a <code>model</code> field and the dictionary mapping constraint indices to bridges should be stored in a <code>bridges</code> field. If a bridge optimizer deviates from these conventions, it should implement the functions <code>MOI.optimize!</code> and <code>bridge</code> respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.LazyBridgeOptimizer" href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>MathOptInterface.Bridges.LazyBridgeOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LazyBridgeOptimizer{OT&lt;:MOI.ModelLike} &lt;: AbstractBridgeOptimizer</code></pre><p>The <code>LazyBridgeOptimizer</code> combines several bridges, which are added using the <a href="#MathOptInterface.Bridges.add_bridge"><code>add_bridge</code></a> function. Whenever a constraint is added, it only attempts to bridge it if it is not supported by the internal model (hence its name <code>Lazy</code>). When bridging a constraint, it selects the minimal number of bridges needed. For instance, a constraint <code>F</code>-in-<code>S</code> can be bridged into a constraint <code>F1</code>-in-<code>S1</code> (supported by the internal model) using bridge 1 or bridged into a constraint <code>F2</code>-in-<code>S2</code> (unsupported by the internal model) using bridge 2 which can then be bridged into a constraint <code>F3</code>-in-<code>S3</code> (supported by the internal model) using bridge 3, it will choose bridge 1 as it allows to bridge <code>F</code>-in-<code>S</code> using only one bridge instead of two if it uses bridge 2 and 3.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.add_bridge" href="#MathOptInterface.Bridges.add_bridge"><code>MathOptInterface.Bridges.add_bridge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_bridge(b::LazyBridgeOptimizer, BT::Type{&lt;:AbstractBridge})</code></pre><p>Enable the use of the bridges of type <code>BT</code> by <code>b</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.remove_bridge" href="#MathOptInterface.Bridges.remove_bridge"><code>MathOptInterface.Bridges.remove_bridge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove_bridge(b::LazyBridgeOptimizer, BT::Type{&lt;:AbstractBridge})</code></pre><p>Disable the use of the bridges of type <code>BT</code> by <code>b</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.has_bridge" href="#MathOptInterface.Bridges.has_bridge"><code>MathOptInterface.Bridges.has_bridge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">has_bridge(b::LazyBridgeOptimizer, BT::Type{&lt;:AbstractBridge})</code></pre><p>Return a <code>Bool</code> indicating whether the bridges of type <code>BT</code> are used by <code>b</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.full_bridge_optimizer" href="#MathOptInterface.Bridges.full_bridge_optimizer"><code>MathOptInterface.Bridges.full_bridge_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">full_bridge_optimizer(model::MOI.ModelLike, ::Type{T}) where T</code></pre><p>Returns a <code>LazyBridgeOptimizer</code> bridging <code>model</code> for every bridge defined in this package and for the coefficient type <code>T</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.debug_supports_constraint" href="#MathOptInterface.Bridges.debug_supports_constraint"><code>MathOptInterface.Bridges.debug_supports_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">debug_supports_constraint(
    b::LazyBridgeOptimizer, F::Type{&lt;:MOI.AbstractFunction},
    S::Type{&lt;:MOI.AbstractSet}; io::IO = Base.stdout)</code></pre><p>Prints to <code>io</code> explanations for the value of <a href="#MathOptInterface.supports_constraint"><code>MOI.supports_constraint</code></a> with the same arguments.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.debug_supports" href="#MathOptInterface.Bridges.debug_supports"><code>MathOptInterface.Bridges.debug_supports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">debug_supports(b::LazyBridgeOptimizer, ::MOI.ObjectiveFunction{F}; io::IO = Base.stdout) where F</code></pre><p>Prints to <code>io</code> explanations for the value of <a href="#MathOptInterface.supports"><code>MOI.supports</code></a> with the same arguments.</p></div></section></article><h3 id="variable_bridges"><a class="docs-heading-anchor" href="#variable_bridges">Variable bridges</a><a id="variable_bridges-1"></a><a class="docs-heading-anchor-permalink" href="#variable_bridges" title="Permalink"></a></h3><p>When variables are added, either free with <a href="#MathOptInterface.add_variable"><code>add_variable</code></a>/<a href="#MathOptInterface.add_variables"><code>add_variables</code></a>, or constrained with <a href="#MathOptInterface.add_constrained_variable"><code>add_constrained_variable</code></a>/<a href="#MathOptInterface.add_constrained_variables"><code>add_constrained_variables</code></a>, variable bridges allow to return <em>bridged variables</em> that do not correspond to variables of the underlying model. These variables are parametrized by variables of the underlying model and this parametrization can be obtained with <a href="#MathOptInterface.Bridges.bridged_variable_function"><code>Bridges.bridged_variable_function</code></a>. Similarly, the variables of the underlying model that were created by the bridge can be expressed in terms of the bridged variables and this expression can be obtained with <a href="#MathOptInterface.Bridges.unbridged_variable_function"><code>Bridges.unbridged_variable_function</code></a>. For instance, consider a model bridged by the <a href="#MathOptInterface.Bridges.Variable.VectorizeBridge"><code>Bridges.Variable.VectorizeBridge</code></a>:</p><pre><code class="language-julia">model = MOI.Utilities.Model{Float64}()
bridged_model = MOI.Bridges.Variable.Vectorize{Float64}(model)
bridged_variable, bridged_constraint = MOI.add_constrained_variable(bridged_model, MOI.GreaterThan(1.0))

# output

(VariableIndex(-1), MOI.ConstraintIndex{MOI.SingleVariable,MOI.GreaterThan{Float64}}(-1))</code></pre><p>The constrained variable in <code>MOI.GreaterThan(1.0)</code> returned is a bridged variable as its index in negative. In <code>model</code>, a constrained variable in <code>MOI.Nonnegatives</code> is created:</p><pre><code class="language-julia">inner_variables = MOI.get(model, MOI.ListOfVariableIndices())

# output

1-element Array{VariableIndex,1}:
 VariableIndex(1)</code></pre><p>In the functions used for adding constraints or setting the objective to <code>bridged_model</code>, <code>bridged_variable</code> is substituted for <code>inner_variables[1]</code> plus 1:</p><pre><code class="language-julia">MOI.Bridges.bridged_variable_function(bridged_model, bridged_variable)

# output

MOI.ScalarAffineFunction{Float64}(MOI.ScalarAffineTerm{Float64}[ScalarAffineTerm{Float64}(1.0, VariableIndex(1))], 1.0)</code></pre><p>When getting <a href="#MathOptInterface.ConstraintFunction"><code>ConstraintFunction</code></a> or <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a>, <code>inner_variables[1]</code> is substituted for <code>bridged_variable</code> minus 1:</p><pre><code class="language-julia">MOI.Bridges.unbridged_variable_function(bridged_model, inner_variables[1])

# output

MOI.ScalarAffineFunction{Float64}(MOI.ScalarAffineTerm{Float64}[ScalarAffineTerm{Float64}(1.0, VariableIndex(-1))], -1.0)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A notable exception is with <a href="#MathOptInterface.Bridges.Variable.ZerosBridge"><code>Bridges.Variable.ZerosBridge</code></a> where no variable is created in the underlying model as the variables are simply transformed to zeros. When this bridge is used, it is not possible to recover functions with bridged variables from functions of the inner model. Consider for instance that we create two zero variables:</p><pre><code class="language-julia">model = MOI.Utilities.Model{Float64}()
bridged_model = MOI.Bridges.Variable.Zeros{Float64}(model)
bridged_variables, bridged_constraint = MOI.add_constrained_variables(bridged_model, MOI.Zeros(2))

# output

(MOI.VariableIndex[VariableIndex(-1), VariableIndex(-2)], MOI.ConstraintIndex{MOI.VectorOfVariables,MOI.Zeros}(-1))</code></pre><p>Consider the following functions in the variables of <code>bridged_model</code>:</p><pre><code class="language-julia">func = MOI.Utilities.operate(+, Float64, MOI.SingleVariable.(bridged_variables)...)

# output

MOI.ScalarAffineFunction{Float64}(MOI.ScalarAffineTerm{Float64}[ScalarAffineTerm{Float64}(1.0, VariableIndex(-1)), ScalarAffineTerm{Float64}(1.0, VariableIndex(-2))], 0.0)</code></pre><p>We can obtain the equivalent function in the variables of <code>model</code> as follows:</p><pre><code class="language-julia">inner_func = MOI.Bridges.bridged_function(bridged_model, func)

# output

MOI.ScalarAffineFunction{Float64}(MOI.ScalarAffineTerm{Float64}[], 0.0)</code></pre><p>However, it&#39;s not possible to invert this operation. Indeed, since the bridged variables are substituted for zeros, we cannot deduce whether they were present in the initial function.</p><pre><code class="language-julia">MOI.Bridges.unbridged_function(bridged_model, inner_func)

# output

ERROR: Cannot unbridge function because some variables are bridged by variable bridges that do not support reverse mapping, e.g., `ZerosBridge`.
Stacktrace:
 [1] error(::String, ::String, ::String) at ./error.jl:42
 [2] throw_if_cannot_unbridge at /home/blegat/.julia/dev/MathOptInterface/src/Bridges/Variable/map.jl:343 [inlined]
 [3] unbridged_function(::MOI.Bridges.Variable.SingleBridgeOptimizer{MOI.Bridges.Variable.ZerosBridge{Float64},MOI.Utilities.Model{Float64}}, ::MOI.ScalarAffineFunction{Float64}) at /home/blegat/.julia/dev/MOI/src/Bridges/bridge_optimizer.jl:920
 [4] top-level scope at none:0</code></pre></div></div><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.AbstractBridge" href="#MathOptInterface.Bridges.Variable.AbstractBridge"><code>MathOptInterface.Bridges.Variable.AbstractBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractBridge</code></pre><p>Subtype of <a href="#MathOptInterface.Bridges.AbstractBridge"><code>MathOptInterface.Bridges.AbstractBridge</code></a> for variable bridges.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.bridged_variable_function" href="#MathOptInterface.Bridges.bridged_variable_function"><code>MathOptInterface.Bridges.bridged_variable_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bridged_variable_function(b::AbstractBridgeOptimizer,
                          vi::MOI.VariableIndex)</code></pre><p>Return a <code>MOI.AbstractScalarFunction</code> of variables of <code>b.model</code> that equals <code>vi</code>. That is, if the variable <code>vi</code> is bridged, it returns its expression in terms of the variables of <code>b.model</code>. Otherwise, it returns <code>MOI.SingleVariable(vi)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.unbridged_variable_function" href="#MathOptInterface.Bridges.unbridged_variable_function"><code>MathOptInterface.Bridges.unbridged_variable_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unbridged_variable_function(b::AbstractBridgeOptimizer,
                            vi::MOI.VariableIndex)</code></pre><p>Return a <code>MOI.AbstractScalarFunction</code> of variables of <code>b</code> that equals <code>vi</code>. That is, if the variable <code>vi</code> is an internal variable of <code>b.model</code> created by a bridge but not visible to the user, it returns its expression in terms of the variables of bridged variables. Otherwise, it returns <code>MOI.SingleVariable(vi)</code>.</p></div></section></article><p>Below is the list of variable bridges implemented in this package.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.ZerosBridge" href="#MathOptInterface.Bridges.Variable.ZerosBridge"><code>MathOptInterface.Bridges.Variable.ZerosBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ZerosBridge{T} &lt;: Bridges.Variable.AbstractBridge</code></pre><p>Transforms constrained variables in <a href="#MathOptInterface.Zeros"><code>MathOptInterface.Zeros</code></a> to zeros, which ends up creating no variables in the underlying model. The bridged variables are therefore similar to parameters with zero values. Parameters with non-zero value can be created with constrained variables in <a href="#MathOptInterface.EqualTo"><code>MOI.EqualTo</code></a> by combining a <a href="#MathOptInterface.Bridges.Variable.VectorizeBridge"><code>VectorizeBridge</code></a> and this bridge. The functions cannot be unbridged, given a function, we cannot determine, if the bridged variables were used. The dual values cannot be determined by the bridge but they can be determined by the bridged optimizer using <a href="#MathOptInterface.Utilities.get_fallback"><code>MathOptInterface.Utilities.get_fallback</code></a> if a <code>CachingOptimizer</code> is used (since <code>ConstraintFunction</code> cannot be got as functions cannot be unbridged).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.FreeBridge" href="#MathOptInterface.Bridges.Variable.FreeBridge"><code>MathOptInterface.Bridges.Variable.FreeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FreeBridge{T} &lt;: Bridges.Variable.AbstractBridge</code></pre><p>Transforms constrained variables in <a href="#MathOptInterface.Reals"><code>MOI.Reals</code></a> to the difference of constrained variables in <a href="#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.NonposToNonnegBridge" href="#MathOptInterface.Bridges.Variable.NonposToNonnegBridge"><code>MathOptInterface.Bridges.Variable.NonposToNonnegBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonposToNonnegBridge{T, F&lt;:MOI.AbstractVectorFunction, G&lt;:MOI.AbstractVectorFunction} &lt;:
    FlipSignBridge{T, MOI.Nonpositives, MOI.Nonnegatives, F, G}</code></pre><p>Transforms constrained variables in <code>Nonpositives</code> into constrained variables in <code>Nonnegatives</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.VectorizeBridge" href="#MathOptInterface.Bridges.Variable.VectorizeBridge"><code>MathOptInterface.Bridges.Variable.VectorizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VectorizeBridge{T, S}</code></pre><p>Transforms a constrained variable in <code>scalar_set_type(S, T)</code> where <code>S &lt;: VectorLinearSet</code> into a constrained vector of one variable in <code>S</code>. For instance, <code>VectorizeBridge{Float64, MOI.Nonnegatives}</code> transforms a constrained variable in <code>MOI.GreaterThan{Float64}</code> into a constrained vector of one variable in <code>MOI.Nonnegatives</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.SOCtoRSOCBridge" href="#MathOptInterface.Bridges.Variable.SOCtoRSOCBridge"><code>MathOptInterface.Bridges.Variable.SOCtoRSOCBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SOCtoRSOCBridge{T} &lt;: Bridges.Variable.AbstractBridge</code></pre><p>Same transformation as <a href="#MathOptInterface.Bridges.Constraint.SOCRBridge"><code>MOI.Bridges.Constraint.SOCRBridge</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.RSOCtoSOCBridge" href="#MathOptInterface.Bridges.Variable.RSOCtoSOCBridge"><code>MathOptInterface.Bridges.Variable.RSOCtoSOCBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RSOCtoSOCBridge{T} &lt;: Bridges.Variable.AbstractBridge</code></pre><p>Same transformation as <a href="#MathOptInterface.Bridges.Constraint.RSOCBridge"><code>MOI.Bridges.Constraint.RSOCBridge</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.RSOCtoPSDBridge" href="#MathOptInterface.Bridges.Variable.RSOCtoPSDBridge"><code>MathOptInterface.Bridges.Variable.RSOCtoPSDBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RSOCtoPSDBridge{T} &lt;: Bridges.Variable.AbstractBridge</code></pre><p>Transforms constrained variables in <a href="#MathOptInterface.RotatedSecondOrderCone"><code>MathOptInterface.RotatedSecondOrderCone</code></a> to constrained variables in <a href="#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MathOptInterface.PositiveSemidefiniteConeTriangle</code></a>.</p></div></section></article><p>For each bridge defined in this package, a corresponding <a href="#MathOptInterface.Bridges.Variable.SingleBridgeOptimizer"><code>Bridges.Variable.SingleBridgeOptimizer</code></a> is available with the same name without the &quot;Bridge&quot; suffix, e.g., <code>SplitInterval</code> is a <code>SingleBridgeOptimizer</code> for the <code>SplitIntervalBridge</code>. Moreover, they are all added in the <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>Bridges.LazyBridgeOptimizer</code></a> returned by <a href="#MathOptInterface.Bridges.full_bridge_optimizer"><code>Bridges.full_bridge_optimizer</code></a> as it calls <a href="#MathOptInterface.Bridges.Variable.add_all_bridges"><code>Bridges.Variable.add_all_bridges</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.SingleBridgeOptimizer" href="#MathOptInterface.Bridges.Variable.SingleBridgeOptimizer"><code>MathOptInterface.Bridges.Variable.SingleBridgeOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SingleBridgeOptimizer{BT&lt;:AbstractBridge, OT&lt;:MOI.ModelLike} &lt;: AbstractBridgeOptimizer</code></pre><p>The <code>SingleBridgeOptimizer</code> bridges any constrained variables supported by the bridge <code>BT</code>. This is in contrast with the <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>MathOptInterface.Bridges.LazyBridgeOptimizer</code></a> which only bridges the constrained variables that are unsupported by the internal model, even if they are supported by one of its bridges.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Two bridge optimizers using variable bridges cannot be used together as both of them assume that the underlying model only returns variable indices with nonnegative values.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.add_all_bridges" href="#MathOptInterface.Bridges.Variable.add_all_bridges"><code>MathOptInterface.Bridges.Variable.add_all_bridges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_all_bridges(bridged_model, T::Type)</code></pre><p>Add all bridges defined in the <code>Bridges.Variable</code> submodule to <code>bridged_model</code>. The coefficient type used is <code>T</code>.</p></div></section></article><h3 id="Constraint-bridges"><a class="docs-heading-anchor" href="#Constraint-bridges">Constraint bridges</a><a id="Constraint-bridges-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-bridges" title="Permalink"></a></h3><p>When constraints are added with <a href="#MathOptInterface.add_constraint"><code>add_constraint</code></a>, constraint bridges allow to return <em>bridged constraints</em> that do not correspond to constraints of the underlying model. These constraints were enforced by an equivalent formulation that added constraints (and possibly also variables) in the underlying model. For instance, consider a model bridged by the <a href="#MathOptInterface.Bridges.Constraint.SplitIntervalBridge"><code>Bridges.Constraint.SplitIntervalBridge</code></a>:</p><pre><code class="language-julia">model = MOI.Utilities.Model{Float64}()
bridged_model = MOI.Bridges.Constraint.SplitInterval{Float64}(model)
x, y = MOI.add_variables(bridged_model, 2)
func = MOI.Utilities.operate(+, Float64, MOI.SingleVariable(x), MOI.SingleVariable(y))
c = MOI.add_constraint(bridged_model, func, MOI.Interval(1.0, 2.0))

# output

MOI.ConstraintIndex{MOI.ScalarAffineFunction{Float64},MOI.Interval{Float64}}(1)</code></pre><p>We can see the constraint was bridged to two constraints, one for each bound, in the inner model.</p><pre><code class="language-julia">MOI.get(model, MOI.ListOfConstraints())

# output

2-element Array{Tuple{DataType,DataType},1}:
 (MOI.ScalarAffineFunction{Float64}, MOI.GreaterThan{Float64})
 (MOI.ScalarAffineFunction{Float64}, MOI.LessThan{Float64})</code></pre><p>However, <code>bridged_model</code> transparently hides these constraints and creates the illusion that an interval constraint was created.</p><pre><code class="language-julia">MOI.get(bridged_model, MOI.ListOfConstraints())

# output

1-element Array{Tuple{DataType,DataType},1}:
 (MOI.ScalarAffineFunction{Float64}, MOI.Interval{Float64})</code></pre><p>It is nevertheless possible to differentiate this constraint from a constraint added to the inner model by asking whether it is bridged:</p><pre><code class="language-julia">MOI.Bridges.is_bridged(bridged_model, c)

# output

true</code></pre><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.AbstractBridge" href="#MathOptInterface.Bridges.Constraint.AbstractBridge"><code>MathOptInterface.Bridges.Constraint.AbstractBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractBridge</code></pre><p>Subtype of <a href="#MathOptInterface.Bridges.AbstractBridge"><code>MathOptInterface.Bridges.AbstractBridge</code></a> for constraint bridges.</p></div></section></article><p>Below is the list of constraint bridges implemented in this package.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge" href="#MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge"><code>MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GreaterToIntervalBridge{T, F&lt;:MOI.AbstractScalarFunction} &lt;:
    AbstractToIntervalBridge{T, MOI.GreaterThan{T}, F}</code></pre><p>Transforms a <code>F</code>-in-<code>GreaterThan{T}</code> constraint into an <code>F</code>-in-<code>Interval{T}</code> constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.LessToIntervalBridge" href="#MathOptInterface.Bridges.Constraint.LessToIntervalBridge"><code>MathOptInterface.Bridges.Constraint.LessToIntervalBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LessToIntervalBridge{T, F&lt;:MOI.AbstractScalarFunction} &lt;:
    AbstractToIntervalBridge{T, MOI.LessThan{T}, F}</code></pre><p>Transforms a <code>F</code>-in-<code>LessThan{T}</code> constraint into an <code>F</code>-in-<code>Interval{T}</code> constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.GreaterToLessBridge" href="#MathOptInterface.Bridges.Constraint.GreaterToLessBridge"><code>MathOptInterface.Bridges.Constraint.GreaterToLessBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GreaterToLessBridge{T, F&lt;:MOI.AbstractScalarFunction, G&lt;:MOI.AbstractScalarFunction} &lt;:
    FlipSignBridge{T, MOI.GreaterThan{T}, MOI.LessThan{T}, F, G}</code></pre><p>Transforms a <code>G</code>-in-<code>GreaterThan{T}</code> constraint into an <code>F</code>-in-<code>LessThan{T}</code> constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.LessToGreaterBridge" href="#MathOptInterface.Bridges.Constraint.LessToGreaterBridge"><code>MathOptInterface.Bridges.Constraint.LessToGreaterBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LessToGreaterBridge{T, F&lt;:MOI.AbstractScalarFunction, G&lt;:MOI.AbstractScalarFunction} &lt;:
    FlipSignBridge{T, MOI.LessThan{T}, MOI.GreaterThan{T}, F, G}</code></pre><p>Transforms a <code>G</code>-in-<code>LessThan{T}</code> constraint into an <code>F</code>-in-<code>GreaterThan{T}</code> constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NonnegToNonposBridge" href="#MathOptInterface.Bridges.Constraint.NonnegToNonposBridge"><code>MathOptInterface.Bridges.Constraint.NonnegToNonposBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonnegToNonposBridge{T, F&lt;:MOI.AbstractVectorFunction, G&lt;:MOI.AbstractVectorFunction} &lt;:
    FlipSignBridge{T, MOI.Nonnegatives, MOI.Nonpositives, F, G}</code></pre><p>Transforms a <code>G</code>-in-<code>Nonnegatives</code> constraint into a <code>F</code>-in-<code>Nonpositives</code> constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NonposToNonnegBridge" href="#MathOptInterface.Bridges.Constraint.NonposToNonnegBridge"><code>MathOptInterface.Bridges.Constraint.NonposToNonnegBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonposToNonnegBridge{T, F&lt;:MOI.AbstractVectorFunction, G&lt;:MOI.AbstractVectorFunction} &lt;:
    FlipSignBridge{T, MOI.Nonpositives, MOI.Nonnegatives, F, G}</code></pre><p>Transforms a <code>G</code>-in-<code>Nonpositives</code> constraint into a <code>F</code>-in-<code>Nonnegatives</code> constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.VectorizeBridge" href="#MathOptInterface.Bridges.Constraint.VectorizeBridge"><code>MathOptInterface.Bridges.Constraint.VectorizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VectorizeBridge{T, F, S, G}</code></pre><p>Transforms a constraint <code>G</code>-in-<code>scalar_set_type(S, T)</code> where <code>S &lt;: VectorLinearSet</code> to <code>F</code>-in-<code>S</code>.</p><p><strong>Examples</strong></p><p>The constraint <code>SingleVariable</code>-in-<code>LessThan{Float64}</code> becomes <code>VectorAffineFunction{Float64}</code>-in-<code>Nonpositives</code>, where <code>T = Float64</code>, <code>F = VectorAffineFunction{Float64}</code>, <code>S = Nonpositives</code>, and <code>G = SingleVariable</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.ScalarizeBridge" href="#MathOptInterface.Bridges.Constraint.ScalarizeBridge"><code>MathOptInterface.Bridges.Constraint.ScalarizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScalarizeBridge{T, F, S}</code></pre><p>Transforms a constraint <code>AbstractVectorFunction</code>-in-<code>vector_set_type(S)</code> where <code>S &lt;: LPCone{T}</code> to <code>F</code>-in-<code>S</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.ScalarSlackBridge" href="#MathOptInterface.Bridges.Constraint.ScalarSlackBridge"><code>MathOptInterface.Bridges.Constraint.ScalarSlackBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScalarSlackBridge{T, F, S}</code></pre><p>The <code>ScalarSlackBridge</code> converts a constraint <code>G</code>-in-<code>S</code> where <code>G</code> is a function different from <code>SingleVariable</code> into the constraints <code>F</code>-in-<code>EqualTo{T}</code> and <code>SingleVariable</code>-in-<code>S</code>. <code>F</code> is the result of subtracting a <code>SingleVariable</code> from <code>G</code>. Typically <code>G</code> is the same as <code>F</code>, but that is not mandatory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.VectorSlackBridge" href="#MathOptInterface.Bridges.Constraint.VectorSlackBridge"><code>MathOptInterface.Bridges.Constraint.VectorSlackBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VectorSlackBridge{T, F, S}</code></pre><p>The <code>VectorSlackBridge</code> converts a constraint <code>G</code>-in-<code>S</code> where <code>G</code> is a function different from <code>VectorOfVariables</code> into the constraints <code>F</code>in-<code>Zeros</code> and <code>VectorOfVariables</code>-in-<code>S</code>. <code>F</code> is the result of subtracting a <code>VectorOfVariables</code> from <code>G</code>. Tipically <code>G</code> is the same as <code>F</code>, but that is not mandatory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge" href="#MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge"><code>MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScalarFunctionizeBridge{T, S}</code></pre><p>The <code>ScalarFunctionizeBridge</code> converts a constraint <code>SingleVariable</code>-in-<code>S</code> into the constraint <code>ScalarAffineFunction{T}</code>-in-<code>S</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge" href="#MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge"><code>MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VectorFunctionizeBridge{T, S}</code></pre><p>The <code>VectorFunctionizeBridge</code> converts a constraint <code>VectorOfVariables</code>-in-<code>S</code> into the constraint <code>VectorAffineFunction{T}</code>-in-<code>S</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SplitIntervalBridge" href="#MathOptInterface.Bridges.Constraint.SplitIntervalBridge"><code>MathOptInterface.Bridges.Constraint.SplitIntervalBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SplitIntervalBridge{T, F, S, LS, US}</code></pre><p>The <code>SplitIntervalBridge</code> splits a <code>F</code>-in-<code>S</code> constraint into a <code>F</code>-in-<code>LS</code> and a <code>F</code>-in-<code>US</code> constraint where we have either:</p><ul><li><code>S = MOI.Interval{T}</code>, <code>LS = MOI.GreaterThan{T}</code> and <code>US = MOI.LessThan{T}</code>,</li><li><code>S = MOI.EqualTo{T}</code>, <code>LS = MOI.GreaterThan{T}</code> and <code>US = MOI.LessThan{T}</code>, or</li><li><code>S = MOI.Zeros</code>, <code>LS = MOI.Nonnegatives</code> and <code>US = MOI.Nonpositives</code>.</li></ul><p>For instance, if <code>F</code> is <code>MOI.ScalarAffineFunction</code> and <code>S</code> is <code>MOI.Interval</code>, it transforms the constraint <span>$l ≤ ⟨a, x⟩ + α ≤ u$</span> into the constraints <span>$⟨a, x⟩ + α ≥ l$</span> and <span>$⟨a, x⟩ + α ≤ u$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.RSOCBridge" href="#MathOptInterface.Bridges.Constraint.RSOCBridge"><code>MathOptInterface.Bridges.Constraint.RSOCBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RSOCBridge{T, F, G}</code></pre><p>The <code>RotatedSecondOrderCone</code> is <code>SecondOrderCone</code> representable; see [1, p. 104]. Indeed, we have <span>$2tu = (t/√2 + u/√2)^2 - (t/√2 - u/√2)^2$</span> hence</p><p class="math-container">\[2tu \ge \lVert x \rVert_2^2\]</p><p>is equivalent to</p><p class="math-container">\[(t/√2 + u/√2)^2 \ge \lVert x \rVert_2^2 + (t/√2 - u/√2)^2.\]</p><p>We can therefore use the transformation <span>$(t, u, x) \mapsto (t/√2+u/√2, t/√2-u/√2, x)$</span>. Note that the linear transformation is a symmetric involution (i.e. it is its own transpose and its own inverse). That means in particular that the norm is of constraint primal and duals are preserved by the tranformation.</p><p>[1] Ben-Tal, Aharon, and Arkadi Nemirovski. <em>Lectures on modern convex optimization: analysis, algorithms, and engineering applications</em>. Society for Industrial and Applied Mathematics, 2001.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SOCRBridge" href="#MathOptInterface.Bridges.Constraint.SOCRBridge"><code>MathOptInterface.Bridges.Constraint.SOCRBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SOCRBridge{T, F, G}</code></pre><p>We simply do the inverse transformation of <a href="#MathOptInterface.Bridges.Constraint.RSOCBridge"><code>RSOCBridge</code></a>. In fact, as the transformation is an involution, we do the same transformation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.QuadtoSOCBridge" href="#MathOptInterface.Bridges.Constraint.QuadtoSOCBridge"><code>MathOptInterface.Bridges.Constraint.QuadtoSOCBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuadtoSOCBridge{T}</code></pre><p>The set of points <code>x</code> satisfying the constraint</p><p class="math-container">\[\frac{1}{2}x^T Q x + a^T x + b \le 0\]</p><p>is a convex set if <code>Q</code> is positive semidefinite and is the union of two convex cones if <code>a</code> and <code>b</code> are zero (i.e. <em>homogeneous</em> case) and <code>Q</code> has only one negative eigenvalue. Currently, only the non-homogeneous transformation is implemented, see the Note section below for more details.</p><p><strong>Non-homogeneous case</strong></p><p>If <code>Q</code> is positive semidefinite, there exists <code>U</code> such that <span>$Q = U^T U$</span>, the inequality can then be rewritten as</p><p class="math-container">\[\|U x\|_2^2 \le 2 (-a^T x - b)\]</p><p>which is equivalent to the membership of <code>(1, -a^T x - b, Ux)</code> to the rotated second-order cone.</p><p><strong>Homogeneous case</strong></p><p>If <code>Q</code> has only one negative eigenvalue, the set of <code>x</code> such that <span>$x^T Q x \le 0$</span> is the union of a convex cone and its opposite. We can choose which one to model by checking the existence of bounds on variables as shown below.</p><p><strong>Second-order cone</strong></p><p>If <code>Q</code> is diagonal and has eigenvalues <code>(1, 1, -1)</code>, the inequality <span>$x^2 + x^2 \le z^2$</span> combined with <span>$z \ge 0$</span> defines the Lorenz cone (i.e. the second-order cone) but when combined with <span>$z \le 0$</span>, it gives the opposite of the second order cone. Therefore, we need to check if the variable <code>z</code> has a lower bound 0 or an upper bound 0 in order to determine which cone is</p><p><strong>Rotated second-order cone</strong></p><p>The matrix <code>Q</code> corresponding to the inequality <span>$x^2 \le 2yz$</span> has one eigenvalue 1 with eigenvectors <code>(1, 0, 0)</code> and <code>(0, 1, -1)</code> and one eigenvalue <code>-1</code> corresponding to the eigenvector <code>(0, 1, 1)</code>. Hence if we intersect this union of two convex cone with the halfspace <span>$x + y \ge 0$</span>, we get the rotated second-order cone and if we intersect it with the halfspace <span>$x + y \le 0$</span> we get the opposite of the rotated second-order cone. Note that <code>y</code> and <code>z</code> have the same sign since <code>yz</code> is nonnegative hence <span>$x + y \ge 0$</span> is equivalent to <span>$x \ge 0$</span> and <span>$y \ge 0$</span>.</p><p><strong>Note</strong></p><p>The check for existence of bound can be implemented (but inefficiently) with the current interface but if bound is removed or transformed (e.g. <code>≤ 0</code> transformed into <code>≥ 0</code>) then the bridge is no longer valid. For this reason the homogeneous version of the bridge is not implemented yet.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge" href="#MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge"><code>MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SOCtoNonConvexQuadBridge{T}</code></pre><p>Constraints of the form <code>VectorOfVariables</code>-in-<code>SecondOrderCone</code> can be transformed into a <code>ScalarQuadraticFunction</code>-in-<code>LessThan</code> and a <code>ScalarAffineFunction</code>-in-<code>GreaterThan</code>. Indeed, the definition of the second-order cone</p><p class="math-container">\[t \ge \lVert x \rVert_2 \  (1)\]</p><p>is equivalent to</p><p class="math-container">\[\sum x_i^2 \le t^2  (2)\]</p><p>with <span>$t \ge 0$</span>.  (3)</p><p><em>WARNING</em> This transformation starts from a convex constraint (1) and creates a non-convex constraint (2), because the Q matrix associated with the constraint 2 has one negative eigenvalue. This might be wrongly interpreted by a solver. Some solvers can look at (2) and understand that it is a second order cone, but this is not a general rule. For these reasons this bridge is not automatically added by <a href="#MathOptInterface.Bridges.full_bridge_optimizer"><code>MOI.Bridges.full_bridge_optimizer</code></a>. Care is recommended when adding this bridge to a optimizer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.RSOCtoNonConvexQuadBridge" href="#MathOptInterface.Bridges.Constraint.RSOCtoNonConvexQuadBridge"><code>MathOptInterface.Bridges.Constraint.RSOCtoNonConvexQuadBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RSOCtoNonConvexQuadBridge{T}</code></pre><p>Constraints of the form <code>VectorOfVariables</code>-in-<code>SecondOrderCone</code> can be transformed into a <code>ScalarQuadraticFunction</code>-in-<code>LessThan</code> and a <code>ScalarAffineFunction</code>-in-<code>GreaterThan</code>. Indeed, the definition of the second-order cone</p><p class="math-container">\[2tu \ge \lVert x \rVert_2^2, t,u \ge 0  (1)\]</p><p>is equivalent to</p><p class="math-container">\[\sum x_i^2 \le 2tu  (2)\]</p><p>with <span>$t,u \ge 0$</span>.  (3)</p><p><em>WARNING</em> This transformation starts from a convex constraint (1) and creates a non-convex constraint (2), because the Q matrix associated with the constraint 2 has two negative eigenvalues. This might be wrongly interpreted by a solver. Some solvers can look at (2) and understand that it is a rotated second order cone, but this is not a general rule. For these reasons, this bridge is not automatically added by <a href="#MathOptInterface.Bridges.full_bridge_optimizer"><code>MOI.Bridges.full_bridge_optimizer</code></a>. Care is recommended when adding this bridge to an optimizer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NormInfinityBridge" href="#MathOptInterface.Bridges.Constraint.NormInfinityBridge"><code>MathOptInterface.Bridges.Constraint.NormInfinityBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NormInfinityBridge{T}</code></pre><p>The <code>NormInfinityCone</code> is representable with LP constraints, since <span>$t \ge \max_i \lvert x_i \rvert$</span> if and only if <span>$t \ge x_i$</span> and <span>$t \ge -x_i$</span> for all <span>$i$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NormOneBridge" href="#MathOptInterface.Bridges.Constraint.NormOneBridge"><code>MathOptInterface.Bridges.Constraint.NormOneBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NormOneBridge{T}</code></pre><p>The <code>NormOneCone</code> is representable with LP constraints, since <span>$t \ge \sum_i \lvert x_i \rvert$</span> if and only if there exists a vector y such that <span>$t \ge \sum_i y_i$</span> and <span>$y_i \ge x_i$</span>, <span>$y_i \ge -x_i$</span> for all <span>$i$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge" href="#MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge"><code>MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GeoMeantoRelEntrBridge{T}</code></pre><p>The <code>geometric mean cone</code> is representable with a relative entropy constraint and a nonnegative auxiliary variable, since <span>$u \le \prod_{i=1}^n w_i^{1/n}$</span> is equivalent to <span>$y \ge 0$</span> and <span>$0 \le u + y \le \prod_{i=1}^n w_i^{1/n}$</span>, and the latter inequality is equivalent to <span>$1 \le \prod_{i=1}^n (\frac{w_i}{u + y})^{1/n}$</span>, which is equivalent to <span>$0 \le \sum_{i=1}^n \log (\frac{w_i}{u + y})^{1/n}$</span>, which is equivalent to <span>$0 \ge \sum_{i=1}^n (u + y) \log (\frac{u + y}{w_i})$</span>. Thus <span>$(u, w) \in GeometricMeanCone(1 + n)$</span> is representable as <span>$y \ge 0$</span>, <span>$(0, w, (u + y) e) \in RelativeEntropyCone(1 + 2n)$</span>, where <span>$e$</span> is a vector of ones.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.GeoMeanBridge" href="#MathOptInterface.Bridges.Constraint.GeoMeanBridge"><code>MathOptInterface.Bridges.Constraint.GeoMeanBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GeoMeanBridge{T, F, G, H}</code></pre><p>The <code>GeometricMeanCone</code> is <code>SecondOrderCone</code> representable; see [1, p. 105]. The reformulation is best described in an example. Consider the cone of dimension 4</p><p class="math-container">\[t \le \sqrt[3]{x_1 x_2 x_3}\]</p><p>This can be rewritten as <span>$\exists x_{21} \ge 0$</span> such that</p><p class="math-container">\[\begin{align*}
  t &amp; \le x_{21},\\
  x_{21}^4 &amp; \le x_1 x_2 x_3 x_{21}.
\end{align*}\]</p><p>Note that we need to create <span>$x_{21}$</span> and not use <span>$t^4$</span> directly as <span>$t$</span> is allowed to be negative. Now, this is equivalent to</p><p class="math-container">\[\begin{align*}
  t &amp; \le x_{21}/\sqrt{4},\\
  x_{21}^2 &amp; \le 2x_{11} x_{12},\\
  x_{11}^2 &amp; \le 2x_1 x_2, &amp; x_{12}^2 &amp; \le 2x_3(x_{21}/\sqrt{4}).
\end{align*}\]</p><p>[1] Ben-Tal, Aharon, and Arkadi Nemirovski. <em>Lectures on modern convex optimization: analysis, algorithms, and engineering applications</em>. Society for Industrial and Applied Mathematics, 2001.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.RelativeEntropyBridge" href="#MathOptInterface.Bridges.Constraint.RelativeEntropyBridge"><code>MathOptInterface.Bridges.Constraint.RelativeEntropyBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RelativeEntropyBridge{T}</code></pre><p>The <code>RelativeEntropyCone</code> is representable with exponential cone and LP constraints, since <span>$u \ge \sum_{i=1}^n w_i \log (\frac{w_i}{v_i})$</span> if and only if there exists a vector <span>$y$</span> such that <span>$u \ge \sum_i y_i$</span> and <span>$y_i \ge w_i \log (\frac{w_i}{v_i})$</span> or equivalently <span>$v_i \ge w_i \exp (\frac{-y_i}{w_i})$</span> or equivalently <span>$(-y_i, w_i, v_i) \in ExponentialCone$</span>, for all <span>$i$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NormSpectralBridge" href="#MathOptInterface.Bridges.Constraint.NormSpectralBridge"><code>MathOptInterface.Bridges.Constraint.NormSpectralBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NormSpectralBridge{T}</code></pre><p>The <code>NormSpectralCone</code> is representable with a PSD constraint, since <span>$t \ge \sigma_1(X)$</span> if and only if <span>$[tI X^\top; X tI] \succ 0$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NormNuclearBridge" href="#MathOptInterface.Bridges.Constraint.NormNuclearBridge"><code>MathOptInterface.Bridges.Constraint.NormNuclearBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NormNuclearBridge{T}</code></pre><p>The <code>NormNuclearCone</code> is representable with an SDP constraint and extra variables, since <span>$t \ge \sum_i \sigma_i (X)$</span> if and only if there exists symmetric matrices <span>$U, V$</span> such that <span>$[U X^\top; X V] \succ 0$</span> and <span>$t \ge (tr(U) + tr(V)) / 2$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SquareBridge" href="#MathOptInterface.Bridges.Constraint.SquareBridge"><code>MathOptInterface.Bridges.Constraint.SquareBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SquareBridge{T, F&lt;:MOI.AbstractVectorFunction,
             G&lt;:MOI.AbstractScalarFunction,
             TT&lt;:MOI.AbstractSymmetricMatrixSetTriangle,
             ST&lt;:MOI.AbstractSymmetricMatrixSetSquare} &lt;: AbstractBridge</code></pre><p>The <code>SquareBridge</code> reformulates the constraint of a square matrix to be in <code>ST</code> to a list of equality constraints for pair or off-diagonal entries with different expressions and a <code>TT</code> constraint the upper triangular part of the matrix.</p><p>For instance, the constraint for the matrix</p><p class="math-container">\[\begin{pmatrix}
  1      &amp; 1 + x &amp; 2 - 3x\\
  1 +  x &amp; 2 + x &amp; 3 -  x\\
  2 - 3x &amp; 2 + x &amp;     2x
\end{pmatrix}\]</p><p>to be PSD can be broken down to the constraint of the symmetric matrix</p><p class="math-container">\[\begin{pmatrix}
  1      &amp; 1 + x &amp; 2 - 3x\\
  \cdot &amp; 2 + x &amp; 3 -  x\\
  \cdot &amp; \cdot &amp;    2x
\end{pmatrix}\]</p><p>and the equality constraint between the off-diagonal entries (2, 3) and (3, 2) <span>$2x == 1$</span>. Note that now symmetrization constraint need to be added between the off-diagonal entries (1, 2) and (2, 1) or between (1, 3) and (3, 1) since the expressions are the same.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.RootDetBridge" href="#MathOptInterface.Bridges.Constraint.RootDetBridge"><code>MathOptInterface.Bridges.Constraint.RootDetBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RootDetBridge{T}</code></pre><p>The <code>RootDetConeTriangle</code> is representable by a <code>PositiveSemidefiniteConeTriangle</code> and an <code>GeometricMeanCone</code> constraints; see [1, p. 149]. Indeed, <span>$t \le \det(X)^{1/n}$</span> if and only if there exists a lower triangular matrix <span>$Δ$</span> such that</p><p class="math-container">\[\begin{align*}
  \begin{pmatrix}
    X &amp; Δ\\
    Δ^\top &amp; \mathrm{Diag}(Δ)
  \end{pmatrix} &amp; \succeq 0\\
  t &amp; \le (Δ_{11} Δ_{22} \cdots Δ_{nn})^{1/n}
\end{align*}\]</p><p>[1] Ben-Tal, Aharon, and Arkadi Nemirovski. <em>Lectures on modern convex optimization: analysis, algorithms, and engineering applications</em>. Society for Industrial and Applied Mathematics, 2001.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.LogDetBridge" href="#MathOptInterface.Bridges.Constraint.LogDetBridge"><code>MathOptInterface.Bridges.Constraint.LogDetBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogDetBridge{T}</code></pre><p>The <code>LogDetConeTriangle</code> is representable by a <code>PositiveSemidefiniteConeTriangle</code> and <code>ExponentialCone</code> constraints. Indeed, <span>$\log\det(X) = \log(\delta_1) + \cdots + \log(\delta_n)$</span> where <span>$\delta_1$</span>, ..., <span>$\delta_n$</span> are the eigenvalues of <span>$X$</span>. Adapting the method from [1, p. 149], we see that <span>$t \le u \log(\det(X/u))$</span> for <span>$u &gt; 0$</span> if and only if there exists a lower triangular matrix <span>$Δ$</span> such that</p><p class="math-container">\[\begin{align*}
  \begin{pmatrix}
    X &amp; Δ\\
    Δ^\top &amp; \mathrm{Diag}(Δ)
  \end{pmatrix} &amp; \succeq 0\\
  t &amp; \le u \log(Δ_{11}/u) + u \log(Δ_{22}/u) + \cdots + u \log(Δ_{nn}/u)
\end{align*}\]</p><p>[1] Ben-Tal, Aharon, and Arkadi Nemirovski. <em>Lectures on modern convex optimization: analysis, algorithms, and engineering applications</em>. Society for Industrial and Applied Mathematics, 2001. ```</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SOCtoPSDBridge" href="#MathOptInterface.Bridges.Constraint.SOCtoPSDBridge"><code>MathOptInterface.Bridges.Constraint.SOCtoPSDBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The <code>SOCtoPSDBridge</code> transforms the second order cone constraint <span>$\lVert x \rVert \le t$</span> into the semidefinite cone constraints</p><p class="math-container">\[\begin{pmatrix}
  t &amp; x^\top\\
  x &amp; tI
\end{pmatrix} \succeq 0\]</p><p>Indeed by the Schur Complement, it is positive definite iff</p><p class="math-container">\[\begin{align*}
  tI &amp; \succ 0\\
  t - x^\top (tI)^{-1} x &amp; \succ 0
\end{align*}\]</p><p>which is equivalent to</p><p class="math-container">\[\begin{align*}
  t &amp; &gt; 0\\
  t^2 &amp; &gt; x^\top x
\end{align*}\]</p><p>This bridge is not added by default by <a href="#MathOptInterface.Bridges.full_bridge_optimizer"><code>MOI.Bridges.full_bridge_optimizer</code></a> as bridging second order cone constraints to semidefinite constraints can be achieved by the <a href="#MathOptInterface.Bridges.Constraint.SOCRBridge"><code>SOCRBridge</code></a> followed by the <a href="#MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge"><code>RSOCtoPSDBridge</code></a> while creating a smaller semidefinite constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge" href="#MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge"><code>MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The <code>RSOCtoPSDBridge</code> transforms the second order cone constraint <span>$\lVert x \rVert \le 2tu$</span> with <span>$u \ge 0$</span> into the semidefinite cone constraints</p><p class="math-container">\[\begin{pmatrix}
  t &amp; x^\top\\
  x &amp; 2uI
\end{pmatrix} \succeq 0\]</p><p>Indeed by the Schur Complement, it is positive definite iff</p><p class="math-container">\[\begin{align*}
  uI &amp; \succ 0\\
  t - x^\top (2uI)^{-1} x &amp; \succ 0
\end{align*}\]</p><p>which is equivalent to</p><p class="math-container">\[\begin{align*}
  u &amp; &gt; 0\\
  2tu &amp; &gt; x^\top x
\end{align*}\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge" href="#MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge"><code>MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IndicatorActiveOnFalseBridge{T}</code></pre><p>The <code>IndicatorActiveOnFalseBridge</code> replaces an indicator constraint activated on 0 with a variable <span>$z_0$</span> with the constraint activated on 1, with a variable <span>$z_1$</span>. It stores the added <code>variable_index</code> and added constraints:</p><ul><li><span>$z_1 \in \mathbb{B}$</span> in <code>zero_one_cons</code></li><li><span>$z_0 + z_1 == 1$</span> in `<code>in</code>disjunction_cons`</li><li>The added <code>ACTIVATE_ON_ONE</code> indicator constraint in <code>indicator_cons_index</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge" href="#MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge"><code>MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IndicatorSOS1Bridge{T, BC &lt;: MOI.AbstractScalarSet}</code></pre><p>The <code>IndicatorSOS1Bridge</code> replaces an indicator constraint of the following form: <span>$z \in \mathbb{B}, z == 1 \implies f(x) \leq b$</span> with a SOS1 constraint: <span>$z \in \mathbb{B}, w \leq 0, f(x) + w \leq b, SOS1(w, z)$</span>. <code>GreaterThan</code> constraints are handled in a symmetric way: <span>$z \in \mathbb{B}, z == 1 \implies f(x) \geq b$</span> is reformulated as: <span>$z \in \mathbb{B}, w \geq 0, f(x) + w \geq b, SOS1(w, z)$</span>. Other scalar sets are handled without a bound constraint: <span>$z \in \mathbb{B}, z == 1 \implies f(x) == b$</span> is reformulated as: <span>$z \in \mathbb{B}, w \text{ free}, f(x) + w == b, SOS1(w, z)$</span>.</p><p>If <code>BC !&lt;: Union{LessThan, GreaterThan}</code>, <code>bound_constraint_index</code> is <code>nothing</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SemiToBinaryBridge" href="#MathOptInterface.Bridges.Constraint.SemiToBinaryBridge"><code>MathOptInterface.Bridges.Constraint.SemiToBinaryBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SemiToBinaryBridge{T, S &lt;: MOI.AbstractScalarSet}</code></pre><p>The <code>SemiToBinaryBridge</code> replaces an Semicontinuous constraint: <span>$x \in \mathsf{Semicontinuous}(l, u)$</span> is replaced by: <span>$z \in \{0, 1\}$</span>, <span>$x \leq z \cdot u$</span>, <span>$x \geq z \cdot l$</span>.</p><p>The <code>SemiToBinaryBridge</code> replaces an Semiinteger constraint: <span>$x \in Semiinteger(l, u)$</span> is replaced by: <span>$z \in \{0, 1\}$</span>, <span>$x \in \mathbb{Z}$</span>, <span>$x \leq z \cdot u$</span>, <span>$x \geq z \cdot l$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.ZeroOneBridge" href="#MathOptInterface.Bridges.Constraint.ZeroOneBridge"><code>MathOptInterface.Bridges.Constraint.ZeroOneBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ZeroOneBridge{T}</code></pre><p>The <code>ZeroOneBridge</code> splits a <code>MOI.SingleVariable</code>-in-<code>MOI.ZeroOne</code> constraint into a <code>MOI.SingleVariable</code>-in-<code>MOI.Integer</code> constraint and a <code>MOI.SingleVariable</code>-in-<code>MOI.Interval(0, 1)</code> constraint.</p></div></section></article><p>For each bridge defined in this package, a corresponding <a href="#MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer"><code>Bridges.Constraint.SingleBridgeOptimizer</code></a> is available with the same name without the &quot;Bridge&quot; suffix, e.g., <code>SplitInterval</code> is a <code>SingleBridgeOptimizer</code> for the <code>SplitIntervalBridge</code>. Moreover, they are all added in the <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>Bridges.LazyBridgeOptimizer</code></a> returned by <a href="#MathOptInterface.Bridges.full_bridge_optimizer"><code>Bridges.full_bridge_optimizer</code></a> as it calls <a href="#MathOptInterface.Bridges.Constraint.add_all_bridges"><code>Bridges.Constraint.add_all_bridges</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer" href="#MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer"><code>MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SingleBridgeOptimizer{BT&lt;:AbstractBridge, OT&lt;:MOI.ModelLike} &lt;: AbstractBridgeOptimizer</code></pre><p>The <code>SingleBridgeOptimizer</code> bridges any constraint supported by the bridge <code>BT</code>. This is in contrast with the <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>MathOptInterface.Bridges.LazyBridgeOptimizer</code></a> which only bridges the constraints that are unsupported by the internal model, even if they are supported by one of its bridges.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.add_all_bridges" href="#MathOptInterface.Bridges.Constraint.add_all_bridges"><code>MathOptInterface.Bridges.Constraint.add_all_bridges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_all_bridges(bridged_model, ::Type{T})</code></pre><p>Add all bridges defined in the <code>Bridges.Constraint</code> submodule to <code>bridged_model</code>. The coefficient type used is <code>T</code>.</p></div></section></article><h3 id="Objective-bridges"><a class="docs-heading-anchor" href="#Objective-bridges">Objective bridges</a><a id="Objective-bridges-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-bridges" title="Permalink"></a></h3><p>When an objective is set with <a href="#MathOptInterface.set"><code>set</code></a>, objective bridges allow to set a <em>bridged objective</em> to the underlying model that do not correspond to the objective set by the user. This equivalent formulation may add constraints (and possibly also variables) in the underlying model in addition to setting an objective function.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Objective.AbstractBridge" href="#MathOptInterface.Bridges.Objective.AbstractBridge"><code>MathOptInterface.Bridges.Objective.AbstractBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractBridge</code></pre><p>Subtype of <a href="#MathOptInterface.Bridges.AbstractBridge"><code>MathOptInterface.Bridges.AbstractBridge</code></a> for objective bridges.</p></div></section></article><p>Below is the list of objective bridges implemented in this package.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Objective.SlackBridge" href="#MathOptInterface.Bridges.Objective.SlackBridge"><code>MathOptInterface.Bridges.Objective.SlackBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SlackBridge{T, F, G}</code></pre><p>The <code>SlackBridge</code> converts an objective function of type <code>G</code> into a <a href="#MathOptInterface.SingleVariable"><code>MOI.SingleVariable</code></a> objective by creating a slack variable and a <code>F</code>-in-<a href="#MathOptInterface.LessThan"><code>MOI.LessThan</code></a> constraint for minimization or <code>F</code>-in-<a href="#MathOptInterface.LessThan"><code>MOI.LessThan</code></a> constraint for maximization where <code>F</code> is <code>MOI.Utilities.promote_operation(-, T, G, MOI.SingleVariable}</code>. Note that when using this bridge, changing the optimization sense is not supported. Set the sense to <code>MOI.FEASIBILITY_SENSE</code> first to delete the bridge in order to change the sense, then re-add the objective.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Objective.FunctionizeBridge" href="#MathOptInterface.Bridges.Objective.FunctionizeBridge"><code>MathOptInterface.Bridges.Objective.FunctionizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FunctionizeBridge{T}</code></pre><p>The <code>FunctionizeBridge</code> converts a <code>SingleVariable</code> objective into a <code>ScalarAffineFunction{T}</code> objective.</p></div></section></article><p>For each bridge defined in this package, a corresponding <a href="#MathOptInterface.Bridges.Objective.SingleBridgeOptimizer"><code>Bridges.Objective.SingleBridgeOptimizer</code></a> is available with the same name without the &quot;Bridge&quot; suffix, e.g., <code>Slack</code> is a <code>SingleBridgeOptimizer</code> for the <code>SlackBridge</code>. Moreover, they are all added in the <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>Bridges.LazyBridgeOptimizer</code></a> returned by <a href="#MathOptInterface.Bridges.full_bridge_optimizer"><code>Bridges.full_bridge_optimizer</code></a> as it calls <a href="#MathOptInterface.Bridges.Objective.add_all_bridges"><code>Bridges.Objective.add_all_bridges</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Objective.SingleBridgeOptimizer" href="#MathOptInterface.Bridges.Objective.SingleBridgeOptimizer"><code>MathOptInterface.Bridges.Objective.SingleBridgeOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SingleBridgeOptimizer{BT&lt;:AbstractBridge, OT&lt;:MOI.ModelLike} &lt;: AbstractBridgeOptimizer</code></pre><p>The <code>SingleBridgeOptimizer</code> bridges any objective functions supported by the bridge <code>BT</code>. This is in contrast with the <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>MathOptInterface.Bridges.LazyBridgeOptimizer</code></a> which only bridges the objective functions that are unsupported by the internal model, even if they are supported by one of its bridges.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Objective.add_all_bridges" href="#MathOptInterface.Bridges.Objective.add_all_bridges"><code>MathOptInterface.Bridges.Objective.add_all_bridges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_all_bridges(bridged_model, T::Type)</code></pre><p>Add all bridges defined in the <code>Bridges.Objective</code> submodule to <code>bridged_model</code>. The coefficient type used is <code>T</code>.</p></div></section></article><h3 id="Bridge-interface"><a class="docs-heading-anchor" href="#Bridge-interface">Bridge interface</a><a id="Bridge-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Bridge-interface" title="Permalink"></a></h3><p>A bridge should implement the following functions to be usable by a bridge optimizer:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.added_constrained_variable_types" href="#MathOptInterface.Bridges.added_constrained_variable_types"><code>MathOptInterface.Bridges.added_constrained_variable_types</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">added_constrained_variable_types(BT::Type{&lt;:Variable.AbstractBridge})::Vector{Tuple{DataType}}</code></pre><p>Return a list of the types of constrained variables that bridges of concrete type <code>BT</code> add. This is used by the <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>LazyBridgeOptimizer</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.added_constraint_types" href="#MathOptInterface.Bridges.added_constraint_types"><code>MathOptInterface.Bridges.added_constraint_types</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">added_constraint_types(BT::Type{&lt;:Constraint.AbstractBridge})::Vector{Tuple{DataType, DataType}}</code></pre><p>Return a list of the types of constraints that bridges of concrete type <code>BT</code> add. This is used by the <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>LazyBridgeOptimizer</code></a>.</p></div></section></article><p>Additionally, variable bridges should implement:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.supports_constrained_variable" href="#MathOptInterface.Bridges.Variable.supports_constrained_variable"><code>MathOptInterface.Bridges.Variable.supports_constrained_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">supports_constrained_variable(::Type{&lt;:AbstractBridge},
                               ::Type{&lt;:MOI.AbstractSet})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether the bridges of type <code>BT</code> support bridging constrained variables in <code>S</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.concrete_bridge_type" href="#MathOptInterface.Bridges.Variable.concrete_bridge_type"><code>MathOptInterface.Bridges.Variable.concrete_bridge_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">concrete_bridge_type(
    BT::Type{&lt;:AbstractBridge},
    S::Type{&lt;:MOI.AbstractSet},
)::DataType</code></pre><p>Return the concrete type of the bridge supporting variables in <code>S</code> constraints. This function can only be called if <code>MOI.supports_constrained_variable(BT, S)</code> is <code>true</code>.</p><p><strong>Examples</strong></p><p>As a variable in <a href="#MathOptInterface.GreaterThan"><code>MathOptInterface.GreaterThan</code></a> is bridged into variables in <a href="#MathOptInterface.Nonnegatives"><code>MathOptInterface.Nonnegatives</code></a> by the <a href="#MathOptInterface.Bridges.Variable.VectorizeBridge"><code>VectorizeBridge</code></a>:</p><pre><code class="language-julia">MOI.Bridges.Variable.concrete_bridge_type(
    MOI.Bridges.Variable.VectorizeBridge{Float64},
    MOI.GreaterThan{Float64},
)

# output

MathOptInterface.Bridges.Variable.VectorizeBridge{Float64,MathOptInterface.Nonnegatives}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.bridge_constrained_variable" href="#MathOptInterface.Bridges.Variable.bridge_constrained_variable"><code>MathOptInterface.Bridges.Variable.bridge_constrained_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bridge_constrained_variable(BT::Type{&lt;:AbstractBridge}, model::MOI.ModelLike,
                            set::MOI.AbstractSet)</code></pre><p>Bridge the constrained variable in <code>set</code> using bridge <code>BT</code> to <code>model</code> and returns a bridge object of type <code>BT</code>. The bridge type <code>BT</code> should be a concrete type, that is, all the type parameters of the bridge should be set. Use <a href="#MathOptInterface.Bridges.Variable.concrete_bridge_type"><code>concrete_bridge_type</code></a> to obtain a concrete type for given set types.</p></div></section></article><p>constraint bridges should implement:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.supports_constraint-Tuple{Type{#s938} where #s938&lt;:MathOptInterface.Bridges.Constraint.AbstractBridge,Type{#s937} where #s937&lt;:MathOptInterface.AbstractFunction,Type{#s936} where #s936&lt;:MathOptInterface.AbstractSet}" href="#MathOptInterface.supports_constraint-Tuple{Type{#s938} where #s938&lt;:MathOptInterface.Bridges.Constraint.AbstractBridge,Type{#s937} where #s937&lt;:MathOptInterface.AbstractFunction,Type{#s936} where #s936&lt;:MathOptInterface.AbstractSet}"><code>MathOptInterface.supports_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MOI.supports_constraint(BT::Type{&lt;:AbstractBridge}, F::Type{&lt;:MOI.AbstractFunction}, S::Type{&lt;:MOI.AbstractSet})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether the bridges of type <code>BT</code> support bridging <code>F</code>-in-<code>S</code> constraints.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.concrete_bridge_type" href="#MathOptInterface.Bridges.Constraint.concrete_bridge_type"><code>MathOptInterface.Bridges.Constraint.concrete_bridge_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">concrete_bridge_type(
    BT::Type{&lt;:AbstractBridge},
    F::Type{&lt;:MOI.AbstractFunction},
    S::Type{&lt;:MOI.AbstractSet}
)::DataType</code></pre><p>Return the concrete type of the bridge supporting <code>F</code>-in-<code>S</code> constraints. This function can only be called if <code>MOI.supports_constraint(BT, F, S)</code> is <code>true</code>.</p><p><strong>Examples</strong></p><p>As a <a href="#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a>-in-<a href="#MathOptInterface.Interval"><code>MathOptInterface.Interval</code></a> constraint is bridged into a <a href="#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a>-in-<a href="#MathOptInterface.GreaterThan"><code>MathOptInterface.GreaterThan</code></a> and a <a href="#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a>-in-<a href="#MathOptInterface.LessThan"><code>MathOptInterface.LessThan</code></a> by the <a href="#MathOptInterface.Bridges.Constraint.SplitIntervalBridge"><code>SplitIntervalBridge</code></a>:</p><pre><code class="language-julia">MOI.Bridges.Constraint.concrete_bridge_type(
    MOI.Bridges.Constraint.SplitIntervalBridge{Float64},
    MOI.SingleVariable,
    MOI.Interval{Float64},
)

# output

MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64,MathOptInterface.SingleVariable,MathOptInterface.Interval{Float64},MathOptInterface.GreaterThan{Float64},MathOptInterface.LessThan{Float64}}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.bridge_constraint" href="#MathOptInterface.Bridges.Constraint.bridge_constraint"><code>MathOptInterface.Bridges.Constraint.bridge_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bridge_constraint(BT::Type{&lt;:AbstractBridge}, model::MOI.ModelLike,
                  func::AbstractFunction, set::MOI.AbstractSet)</code></pre><p>Bridge the constraint <code>func</code>-in-<code>set</code> using bridge <code>BT</code> to <code>model</code> and returns a bridge object of type <code>BT</code>. The bridge type <code>BT</code> should be a concrete type, that is, all the type parameters of the bridge should be set. Use <a href="#MathOptInterface.Bridges.Constraint.concrete_bridge_type"><code>concrete_bridge_type</code></a> to obtain a concrete type for given function and set types.</p></div></section></article><p>and objective bridges should implement:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.set_objective_function_type" href="#MathOptInterface.Bridges.set_objective_function_type"><code>MathOptInterface.Bridges.set_objective_function_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_objective_function_type(BT::Type{&lt;:Objective.AbstractBridge})::Type{&lt;:MOI.AbstractScalarFunction}</code></pre><p>Return the type of objective function that bridges of concrete type <code>BT</code> set. This is used by the <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>LazyBridgeOptimizer</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Objective.concrete_bridge_type" href="#MathOptInterface.Bridges.Objective.concrete_bridge_type"><code>MathOptInterface.Bridges.Objective.concrete_bridge_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">concrete_bridge_type(BT::Type{&lt;:MOI.Bridges.Objective.AbstractBridge},
                     F::Type{&lt;:MOI.AbstractScalarFunction})::DataType</code></pre><p>Return the concrete type of the bridge supporting objective functions of type <code>F</code>. This function can only be called if <code>MOI.supports_objective_function(BT, F)</code> is <code>true</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Objective.bridge_objective" href="#MathOptInterface.Bridges.Objective.bridge_objective"><code>MathOptInterface.Bridges.Objective.bridge_objective</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bridge_objective(BT::Type{&lt;:MOI.Bridges.Objective.AbstractBridge},
                 model::MOI.ModelLike,
                 func::MOI.AbstractScalarFunction)</code></pre><p>Bridge the objective function <code>func</code> using bridge <code>BT</code> to <code>model</code> and returns a bridge object of type <code>BT</code>. The bridge type <code>BT</code> should be a concrete type, that is, all the type parameters of the bridge should be set. Use <a href="#MathOptInterface.Bridges.Objective.concrete_bridge_type"><code>concrete_bridge_type</code></a> to obtain a concrete type for a given function type.</p></div></section></article><p>When querying the <a href="#MathOptInterface.NumberOfVariables"><code>NumberOfVariables</code></a>, <a href="#MathOptInterface.NumberOfConstraints"><code>NumberOfConstraints</code></a> and <a href="#MathOptInterface.ListOfConstraintIndices"><code>ListOfConstraintIndices</code></a>, the variables and constraints created by the bridges in the underlying model are hidden by the bridge optimizer. For this purpose, the bridge should provide access to the variables and constraints it has creates by implemented the following methods of <a href="#MathOptInterface.get"><code>get</code></a>:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.get-Tuple{MathOptInterface.Bridges.Constraint.AbstractBridge,MathOptInterface.NumberOfVariables}" href="#MathOptInterface.get-Tuple{MathOptInterface.Bridges.Constraint.AbstractBridge,MathOptInterface.NumberOfVariables}"><code>MathOptInterface.get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MOI.get(b::AbstractBridge, ::MOI.NumberOfVariables)</code></pre><p>The number of variables created by the bridge <code>b</code> in the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.get-Tuple{MathOptInterface.Bridges.Constraint.AbstractBridge,MathOptInterface.ListOfVariableIndices}" href="#MathOptInterface.get-Tuple{MathOptInterface.Bridges.Constraint.AbstractBridge,MathOptInterface.ListOfVariableIndices}"><code>MathOptInterface.get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MOI.get(b::AbstractBridge, ::MOI.NumberOfVariables)</code></pre><p>The list of variables created by the bridge <code>b</code> in the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.get-Tuple{MathOptInterface.Bridges.AbstractBridge,MathOptInterface.NumberOfConstraints}" href="#MathOptInterface.get-Tuple{MathOptInterface.Bridges.AbstractBridge,MathOptInterface.NumberOfConstraints}"><code>MathOptInterface.get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MOI.get(b::AbstractBridge, ::MOI.NumberOfConstraints{F, S}) where {F, S}</code></pre><p>The number of constraints of the type <code>F</code>-in-<code>S</code> created by the bridge <code>b</code> in the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.get-Tuple{MathOptInterface.Bridges.AbstractBridge,MathOptInterface.ListOfConstraintIndices}" href="#MathOptInterface.get-Tuple{MathOptInterface.Bridges.AbstractBridge,MathOptInterface.ListOfConstraintIndices}"><code>MathOptInterface.get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MOI.get(b::AbstractBridge, ::MOI.ListOfConstraintIndices{F, S}) where {F, S}</code></pre><p>A <code>Vector{ConstraintIndex{F,S}}</code> with indices of all constraints of type <code>F</code>-in<code>S</code> created by the bride <code>b</code> in the model (i.e., of length equal to the value of <code>NumberOfConstraints{F,S}()</code>).</p></div></section></article><h2 id="Copy-utilities"><a class="docs-heading-anchor" href="#Copy-utilities">Copy utilities</a><a id="Copy-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Copy-utilities" title="Permalink"></a></h2><p>The following utilities can be used to implement <a href="#MathOptInterface.copy_to"><code>copy_to</code></a>. See <a href="../manual/implementing/#Implementing-copy">Implementing copy</a> for more details.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.automatic_copy_to" href="#MathOptInterface.Utilities.automatic_copy_to"><code>MathOptInterface.Utilities.automatic_copy_to</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">automatic_copy_to(dest::MOI.ModelLike, src::MOI.ModelLike;
                  copy_names::Bool=true, 
                  filter_constraints::Union{Nothing, Function}=nothing)</code></pre><p>Use <a href="#MathOptInterface.Utilities.supports_default_copy_to"><code>Utilities.supports_default_copy_to</code></a> and <a href="#MathOptInterface.Utilities.supports_allocate_load"><code>Utilities.supports_allocate_load</code></a> to automatically choose between <a href="#MathOptInterface.Utilities.default_copy_to"><code>Utilities.default_copy_to</code></a> or <a href="#MathOptInterface.Utilities.allocate_load"><code>Utilities.allocate_load</code></a> to apply the copy operation.</p><p>If the <code>filter_constraints</code> arguments is given, only the constraints for which this function returns <code>true</code> will be copied. This function is given a  constraint index as argument. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.default_copy_to" href="#MathOptInterface.Utilities.default_copy_to"><code>MathOptInterface.Utilities.default_copy_to</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">default_copy_to(dest::MOI.ModelLike, src::MOI.ModelLike, copy_names::Bool,
                filter_constraints::Union{Nothing, Function}=nothing)</code></pre><p>Implements <code>MOI.copy_to(dest, src)</code> by adding the variables and then the constraints and attributes incrementally. The function <a href="#MathOptInterface.Utilities.supports_default_copy_to"><code>supports_default_copy_to</code></a> can be used to check whether <code>dest</code> supports the copying a model incrementally.</p><p>If the <code>filter_constraints</code> arguments is given, only the constraints for which this function returns <code>true</code> will be copied. This function is given a  constraint index as argument. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.supports_default_copy_to" href="#MathOptInterface.Utilities.supports_default_copy_to"><code>MathOptInterface.Utilities.supports_default_copy_to</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">supports_default_copy_to(model::ModelLike, copy_names::Bool)</code></pre><p>Return a <code>Bool</code> indicating whether the model <code>model</code> supports <a href="#MathOptInterface.Utilities.default_copy_to"><code>default_copy_to(model, src, copy_names=copy_names)</code></a> if all the attributes set to <code>src</code> and constraints added to <code>src</code> are supported by <code>model</code>.</p><p>This function can be used to determine whether a model can be loaded into <code>model</code> incrementally or whether it should be cached and copied at once instead. This is used by JuMP to determine whether to add a cache or not in two situations:</p><ol><li>A first cache can be used to store the model as entered by the user as well as the names of variables and constraints. This cache is created if this function returns <code>false</code> when <code>copy_names</code> is <code>true</code>.</li><li>If bridges are used, then a second cache can be used to store the bridged model with unnamed variables and constraints. This cache is created if this function returns <code>false</code> when <code>copy_names</code> is <code>false</code>.</li></ol><p><strong>Examples</strong></p><p>If <a href="#MathOptInterface.set"><code>MathOptInterface.set</code></a>, <a href="#MathOptInterface.add_variable"><code>MathOptInterface.add_variable</code></a> and <a href="#MathOptInterface.add_constraint"><code>MathOptInterface.add_constraint</code></a> are implemented for a model of type <code>MyModel</code> and names are supported, then <a href="#MathOptInterface.copy_to"><code>MathOptInterface.copy_to</code></a> can be implemented as</p><pre><code class="language-julia">MOI.Utilities.supports_default_copy_to(model::MyModel, copy_names::Bool) = true
function MOI.copy_to(dest::MyModel, src::MOI.ModelLike; kws...)
    return MOI.Utilities.automatic_copy_to(dest, src; kws...)
end</code></pre><p>The <a href="#MathOptInterface.Utilities.automatic_copy_to"><code>Utilities.automatic_copy_to</code></a> function automatically redirects to <a href="#MathOptInterface.Utilities.default_copy_to"><code>Utilities.default_copy_to</code></a>.</p><p>If names are not supported, simply change the first line by</p><pre><code class="language-julia">MOI.supports_default_copy_to(model::MyModel, copy_names::Bool) = !copy_names</code></pre><p>The <a href="#MathOptInterface.Utilities.default_copy_to"><code>Utilities.default_copy_to</code></a> function automatically throws an helpful error in case <code>copy_to</code> is called with <code>copy_names</code> equal to <code>true</code>.</p></div></section></article><h3 id="Allocate-Load-API"><a class="docs-heading-anchor" href="#Allocate-Load-API">Allocate-Load API</a><a id="Allocate-Load-API-1"></a><a class="docs-heading-anchor-permalink" href="#Allocate-Load-API" title="Permalink"></a></h3><p>The Allocate-Load API allows solvers that do not support loading the problem incrementally to implement <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> in a way that still allows transformations to be applied in the copy between the cache and the model if the transformations are implemented as MOI layers implementing the Allocate-Load API, see <a href="../manual/implementing/#Implementing-copy">Implementing copy</a> for more details.</p><p>Loading a model using the Allocate-Load interface consists of two passes through the model data:</p><ol><li>the allocate pass where the model typically records the necessary information about the constraints and attributes such as their number and size. This information may be used by the solver to allocate datastructures of appropriate size.</li><li>the load pass where the model typically loads the constraint and attribute data to the model.</li></ol><p>The description above only gives a suggestion of what to achieve in each pass. In fact the exact same constraint and attribute data is provided to each pass, so an implementation of the Allocate-Load API is free to do whatever is more convenient in each pass.</p><p>The main difference between each pass, apart from the fact that one is executed before the other during a copy, is that the allocate pass needs to create and return new variable and constraint indices, while during the load pass the appropriate constraint indices are provided.</p><p>The Allocate-Load API is <strong>not</strong> meant to be used outside a copy operation, that is, the interface is not meant to be used to create new constraints with <a href="#MathOptInterface.Utilities.allocate_constraint"><code>Utilities.allocate_constraint</code></a> followed by <a href="#MathOptInterface.Utilities.load_constraint"><code>Utilities.load_constraint</code></a> after a solve. This means that the order in which the different functions of the API are called is fixed by <a href="#MathOptInterface.Utilities.allocate_load"><code>Utilities.allocate_load</code></a> and models implementing the API can rely on the fact that functions will be called in this order. That is, it can be assumed that the different functions will the called in the following order:</p><ol><li><a href="#MathOptInterface.Utilities.allocate_variables"><code>Utilities.allocate_variables</code></a></li><li><a href="#MathOptInterface.Utilities.allocate"><code>Utilities.allocate</code></a> and <a href="#MathOptInterface.Utilities.allocate_constraint"><code>Utilities.allocate_constraint</code></a></li><li><a href="#MathOptInterface.Utilities.load_variables"><code>Utilities.load_variables</code></a></li><li><a href="#MathOptInterface.Utilities.load"><code>Utilities.load</code></a> and <a href="#MathOptInterface.Utilities.load_constraint"><code>Utilities.load_constraint</code></a></li></ol><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.allocate_load" href="#MathOptInterface.Utilities.allocate_load"><code>MathOptInterface.Utilities.allocate_load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allocate_load(dest::MOI.ModelLike, src::MOI.ModelLike, 
              filter_constraints::Union{Nothing, Function}=nothing
              )</code></pre><p>Implements <code>MOI.copy_to(dest, src)</code> using the Allocate-Load API. The function <a href="#MathOptInterface.Utilities.supports_allocate_load"><code>supports_allocate_load</code></a> can be used to check whether <code>dest</code> supports the Allocate-Load API.</p><p>If the <code>filter_constraints</code> arguments is given, only the constraints for which this function returns <code>true</code> will be copied. This function is given a  constraint index as argument. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.supports_allocate_load" href="#MathOptInterface.Utilities.supports_allocate_load"><code>MathOptInterface.Utilities.supports_allocate_load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">supports_allocate_load(model::MOI.ModelLike, copy_names::Bool)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports <a href="#MathOptInterface.Utilities.allocate_load"><code>allocate_load(model, src, copy_names=copy_names)</code></a> if all the attributes set to <code>src</code> and constraints added to <code>src</code> are supported by <code>model</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.allocate_variables" href="#MathOptInterface.Utilities.allocate_variables"><code>MathOptInterface.Utilities.allocate_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allocate_variables(model::MOI.ModelLike, nvars::Integer)</code></pre><p>Creates <code>nvars</code> variables and returns a vector of <code>nvars</code> variable indices.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.allocate" href="#MathOptInterface.Utilities.allocate"><code>MathOptInterface.Utilities.allocate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allocate(model::ModelLike, attr::ModelLikeAttribute, value)
allocate(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex, value)
allocate(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex, value)</code></pre><p>Informs <code>model</code> that <code>load</code> will be called with the same arguments after <code>load_variables</code> is called.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.allocate_constraint" href="#MathOptInterface.Utilities.allocate_constraint"><code>MathOptInterface.Utilities.allocate_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allocate_constraint(model::MOI.ModelLike, f::MOI.AbstractFunction, s::MOI.AbstractSet)</code></pre><p>Returns the index for the constraint to be used in <code>load_constraint</code> that will be called after <code>load_variables</code> is called.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.load_variables" href="#MathOptInterface.Utilities.load_variables"><code>MathOptInterface.Utilities.load_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load_variables(model::MOI.ModelLike, nvars::Integer)</code></pre><p>Prepares <code>model</code> for <a href="#MathOptInterface.Utilities.load"><code>load</code></a> and <a href="#MathOptInterface.Utilities.load_constraint"><code>load_constraint</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.load" href="#MathOptInterface.Utilities.load"><code>MathOptInterface.Utilities.load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load(model::ModelLike, attr::ModelLikeAttribute, value)
load(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex, value)
load(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex, value)</code></pre><p>This has the same effect that <code>set</code> with the same arguments except that <code>allocate</code> should be called first before <code>load_variables</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.load_constraint" href="#MathOptInterface.Utilities.load_constraint"><code>MathOptInterface.Utilities.load_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load_constraint(model::MOI.ModelLike, ci::MOI.ConstraintIndex, f::MOI.AbstractFunction, s::MOI.AbstractSet)</code></pre><p>Sets the constraint function and set for the constraint of index <code>ci</code>.</p></div></section></article><h3 id="Caching-optimizer"><a class="docs-heading-anchor" href="#Caching-optimizer">Caching optimizer</a><a id="Caching-optimizer-1"></a><a class="docs-heading-anchor-permalink" href="#Caching-optimizer" title="Permalink"></a></h3><p>Some solvers do not support incremental definition of optimization models. Nevertheless, you are still able to build incrementally an optimization model with such solvers. MathOptInterface provides a utility, <a href="#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a>, that will store in a <a href="#MathOptInterface.ModelLike"><code>ModelLike</code></a> the optimization model during its incremental definition. Once the model is completely defined, the <code>CachingOptimizer</code> specifies all problem information to the underlying solver, all at once.</p><p>The function <a href="#MathOptInterface.Utilities.state"><code>Utilities.state</code></a> allows to query the state of the optimizer cached inside a <code>CachingOptimizer</code>. The state could be:</p><ul><li><code>NO_OPTIMIZER</code>, if no optimizer is attached;</li><li><code>EMPTY_OPTIMIZER</code>, if the attached optimizer is empty;</li><li><code>ATTACHED_OPTIMIZER</code>, if the attached optimizer is synchronized with the cached model defined in <code>CachingOptimizer</code>.</li></ul><p>The following methods modify the state of the attached optimizer:</p><ul><li><a href="#MathOptInterface.Utilities.attach_optimizer"><code>Utilities.attach_optimizer</code></a> attachs a new <code>optimizer</code> to a <code>cached_optimizer</code> with state <code>EMPTY_OPTIMIZER</code>. The state of <code>cached_optimizer</code> is set to <code>ATTACHED_OPTIMIZER</code> after the call.</li><li><a href="#MathOptInterface.Utilities.drop_optimizer"><code>Utilities.drop_optimizer</code></a> drops the underlying <code>optimizer</code> from <code>cached_optimizer</code>, without emptying it. The state of <code>cached_optimizer</code> is set to <code>NO_OPTIMIZER</code> after the call.</li><li><a href="#MathOptInterface.Utilities.reset_optimizer"><code>Utilities.reset_optimizer</code></a> empties <code>optimizer</code> inside <code>cached_optimizer</code>, without droping it. The state of <code>cached_optimizer</code> is set to <code>EMPTY_OPTIMIZER</code> after the call.</li></ul><p>The way to operate a <code>CachingOptimizer</code> depends whether the mode is set to <code>AUTOMATIC</code> or to <code>MANUAL</code>.</p><ul><li>In <code>MANUAL</code> mode, the state of the <code>CachingOptimizer</code> changes only if the methods <a href="#MathOptInterface.Utilities.attach_optimizer"><code>Utilities.attach_optimizer</code></a>, <a href="#MathOptInterface.Utilities.reset_optimizer"><code>Utilities.reset_optimizer</code></a> or <a href="#MathOptInterface.Utilities.drop_optimizer"><code>Utilities.drop_optimizer</code></a> are being called. Any unattended operation results in an error.</li><li>In <code>AUTOMATIC</code> mode, the state of the <code>CachingOptimizer</code> changes when necessary. Any modification not supported by the solver (e.g. dropping a constraint) results in a drop to the state <code>EMPTY_OPTIMIZER</code>.</li></ul><p>When calling <a href="#MathOptInterface.Utilities.attach_optimizer"><code>Utilities.attach_optimizer</code></a>, the <code>CachingOptimizer</code> copies the cached model to the optimizer with <a href="#MathOptInterface.copy_to"><code>copy_to</code></a>. We refer to <a href="../manual/implementing/#Implementing-copy">Implementing copy</a> for more details.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.CachingOptimizer" href="#MathOptInterface.Utilities.CachingOptimizer"><code>MathOptInterface.Utilities.CachingOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CachingOptimizer</code></pre><p><code>CachingOptimizer</code> is an intermediate layer that stores a cache of the model and links it with an optimizer. It supports incremental model construction and modification even when the optimizer doesn&#39;t.</p><p>A <code>CachingOptimizer</code> may be in one of three possible states (<code>CachingOptimizerState</code>):</p><ul><li><code>NO_OPTIMIZER</code>: The CachingOptimizer does not have any optimizer.</li><li><code>EMPTY_OPTIMIZER</code>: The CachingOptimizer has an empty optimizer. The optimizer is not synchronized with the cached model.</li><li><code>ATTACHED_OPTIMIZER</code>: The CachingOptimizer has an optimizer, and it is synchronized with the cached model.</li></ul><p>A <code>CachingOptimizer</code> has two modes of operation (<code>CachingOptimizerMode</code>):</p><ul><li><code>MANUAL</code>: The only methods that change the state of the <code>CachingOptimizer</code> are <a href="#MathOptInterface.Utilities.reset_optimizer"><code>Utilities.reset_optimizer</code></a>, <a href="#MathOptInterface.Utilities.drop_optimizer"><code>Utilities.drop_optimizer</code></a>, and <a href="#MathOptInterface.Utilities.attach_optimizer"><code>Utilities.attach_optimizer</code></a>. Attempting to perform an operation in the incorrect state results in an error.</li><li><code>AUTOMATIC</code>: The <code>CachingOptimizer</code> changes its state when necessary. For example, <code>optimize!</code> will automatically call <code>attach_optimizer</code> (an optimizer must have been previously set). Attempting to add a constraint or perform a modification not supported by the optimizer results in a drop to <code>EMPTY_OPTIMIZER</code> mode.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.attach_optimizer" href="#MathOptInterface.Utilities.attach_optimizer"><code>MathOptInterface.Utilities.attach_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">attach_optimizer(model::CachingOptimizer)</code></pre><p>Attaches the optimizer to <code>model</code>, copying all model data into it. Can be called only from the <code>EMPTY_OPTIMIZER</code> state. If the copy succeeds, the <code>CachingOptimizer</code> will be in state <code>ATTACHED_OPTIMIZER</code> after the call, otherwise an error is thrown; see <a href="#MathOptInterface.copy_to"><code>MathOptInterface.copy_to</code></a> for more details on which errors can be thrown.</p></div></section><section><div><pre><code class="language-julia">MOIU.attach_optimizer(model::Model)</code></pre><p>Call <code>MOIU.attach_optimizer</code> on the backend of <code>model</code>.</p><p>Cannot be called in direct mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/6ce8abcbb6167c28f354a39c36e0dc1ba8e892d3/src/optimizer_interface.jl#L63-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.reset_optimizer" href="#MathOptInterface.Utilities.reset_optimizer"><code>MathOptInterface.Utilities.reset_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reset_optimizer(m::CachingOptimizer, optimizer::MOI.AbstractOptimizer)</code></pre><p>Sets or resets <code>m</code> to have the given empty optimizer. Can be called from any state. The <code>CachingOptimizer</code> will be in state <code>EMPTY_OPTIMIZER</code> after the call.</p></div></section><section><div><pre><code class="language-none">reset_optimizer(m::CachingOptimizer)</code></pre><p>Detaches and empties the current optimizer. Can be called from <code>ATTACHED_OPTIMIZER</code> or <code>EMPTY_OPTIMIZER</code> state. The <code>CachingOptimizer</code> will be in state <code>EMPTY_OPTIMIZER</code> after the call.</p></div></section><section><div><pre><code class="language-none">MOIU.reset_optimizer(model::Model, optimizer::MOI.AbstractOptimizer)</code></pre><p>Call <code>MOIU.reset_optimizer</code> on the backend of <code>model</code>.</p><p>Cannot be called in direct mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/6ce8abcbb6167c28f354a39c36e0dc1ba8e892d3/src/optimizer_interface.jl#L23-L29">source</a></section><section><div><pre><code class="language-julia">MOIU.reset_optimizer(model::Model)</code></pre><p>Call <code>MOIU.reset_optimizer</code> on the backend of <code>model</code>.</p><p>Cannot be called in direct mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/6ce8abcbb6167c28f354a39c36e0dc1ba8e892d3/src/optimizer_interface.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.drop_optimizer" href="#MathOptInterface.Utilities.drop_optimizer"><code>MathOptInterface.Utilities.drop_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">drop_optimizer(m::CachingOptimizer)</code></pre><p>Drops the optimizer, if one is present. Can be called from any state. The <code>CachingOptimizer</code> will be in state <code>NO_OPTIMIZER</code> after the call.</p></div></section><section><div><pre><code class="language-julia">MOIU.drop_optimizer(model::Model)</code></pre><p>Call <code>MOIU.drop_optimizer</code> on the backend of <code>model</code>.</p><p>Cannot be called in direct mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/6ce8abcbb6167c28f354a39c36e0dc1ba8e892d3/src/optimizer_interface.jl#L51-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.state" href="#MathOptInterface.Utilities.state"><code>MathOptInterface.Utilities.state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">state(m::CachingOptimizer)::CachingOptimizerState</code></pre><p>Returns the state of the CachingOptimizer <code>m</code>. See <a href="#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.mode" href="#MathOptInterface.Utilities.mode"><code>MathOptInterface.Utilities.mode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mode(m::CachingOptimizer)::CachingOptimizerMode</code></pre><p>Returns the operating mode of the CachingOptimizer <code>m</code>. See <a href="#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a>.</p></div></section></article><h2 id="Function-utilities"><a class="docs-heading-anchor" href="#Function-utilities">Function utilities</a><a id="Function-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Function-utilities" title="Permalink"></a></h2><p>The following utilities are available for functions:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.eval_variables" href="#MathOptInterface.Utilities.eval_variables"><code>MathOptInterface.Utilities.eval_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_variables(varval::Function, f::AbstractFunction)</code></pre><p>Returns the value of function <code>f</code> if each variable index <code>vi</code> is evaluated as <code>varval(vi)</code>. Note that <code>varval</code> should return a number, see <a href="#MathOptInterface.Utilities.substitute_variables"><code>substitute_variables</code></a> for a similar function where <code>varval</code> returns a function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.map_indices" href="#MathOptInterface.Utilities.map_indices"><code>MathOptInterface.Utilities.map_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_indices(index_map::Function, x)</code></pre><p>Substitute any <a href="#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> (resp. <a href="#MathOptInterface.ConstraintIndex"><code>MOI.ConstraintIndex</code></a>) in <code>x</code> by the <a href="#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> (resp. <a href="#MathOptInterface.ConstraintIndex"><code>MOI.ConstraintIndex</code></a>) of the same type given by <code>index_map(x)</code>.</p><p>This function is used by implementations of <a href="#MathOptInterface.copy_to"><code>MOI.copy_to</code></a> on constraint functions, attribute values and submittable values hence it needs to be implemented for custom types that are meant to be used as attribute or submittable value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.substitute_variables" href="#MathOptInterface.Utilities.substitute_variables"><code>MathOptInterface.Utilities.substitute_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">substitute_variables(variable_map::Function, x)</code></pre><p>Substitute any <a href="#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <code>x</code> by <code>variable_map(x)</code>. The <code>variable_map</code> function returns either <a href="#MathOptInterface.SingleVariable"><code>MOI.SingleVariable</code></a> or <a href="#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction</code></a>, see <a href="#MathOptInterface.Utilities.eval_variables"><code>eval_variables</code></a> for a similar function where <code>variable_map</code> returns a number.</p><p>This function is used by bridge optimizers on constraint functions, attribute values and submittable values when at least one variable bridge is used hence it needs to be implemented for custom types that are meant to be used as attribute or submittable value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.filter_variables" href="#MathOptInterface.Utilities.filter_variables"><code>MathOptInterface.Utilities.filter_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">filter_variables(keep::Function, f::AbstractFunction)</code></pre><p>Return a new function <code>f</code> with the variable <code>vi</code> such that <code>!keep(vi)</code> removed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.remove_variable" href="#MathOptInterface.Utilities.remove_variable"><code>MathOptInterface.Utilities.remove_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove_variable(f::AbstractFunction, vi::VariableIndex)</code></pre><p>Return a new function <code>f</code> with the variable vi removed.</p></div></section><section><div><pre><code class="language-none">remove_variable(f::MOI.AbstractFunction, s::MOI.AbstractSet, vi::MOI.VariableIndex)</code></pre><p>Return a tuple <code>(g, t)</code> representing the constraint <code>f</code>-in-<code>s</code> with the variable <code>vi</code> removed. That is, the terms containing the variable <code>vi</code> in the function <code>f</code> are removed and the dimension of the set <code>s</code> is updated if needed (e.g. when <code>f</code> is a <code>VectorOfVariables</code> with <code>vi</code> being one of the variables).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.all_coefficients" href="#MathOptInterface.Utilities.all_coefficients"><code>MathOptInterface.Utilities.all_coefficients</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_coefficients(p::Function, f::MOI.AbstractFunction)</code></pre><p>Determine whether predicate <code>p</code> returns <code>true</code> for all coefficients of <code>f</code>, returning <code>false</code> as soon as the first coefficient of <code>f</code> for which <code>p</code> returns <code>false</code> is encountered (short-circuiting). Similar to <code>all</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.unsafe_add" href="#MathOptInterface.Utilities.unsafe_add"><code>MathOptInterface.Utilities.unsafe_add</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unsafe_add(t1::MOI.ScalarAffineTerm, t2::MOI.ScalarAffineTerm)</code></pre><p>Sums the coefficients of <code>t1</code> and <code>t2</code> and returns an output <code>MOI.ScalarAffineTerm</code>. It is unsafe because it uses the <code>variable_index</code> of <code>t1</code> as the <code>variable_index</code> of the output without checking that it is equal to that of <code>t2</code>.</p></div></section><section><div><pre><code class="language-none">unsafe_add(t1::MOI.ScalarQuadraticTerm, t2::MOI.ScalarQuadraticTerm)</code></pre><p>Sums the coefficients of <code>t1</code> and <code>t2</code> and returns an output <code>MOI.ScalarQuadraticTerm</code>. It is unsafe because it uses the <code>variable_index</code>&#39;s of <code>t1</code> as the <code>variable_index</code>&#39;s of the output without checking that they are the same (up to permutation) to those of <code>t2</code>.</p></div></section><section><div><pre><code class="language-none">unsafe_add(t1::MOI.VectorAffineTerm, t2::MOI.VectorAffineTerm)</code></pre><p>Sums the coefficients of <code>t1</code> and <code>t2</code> and returns an output <code>MOI.VectorAffineTerm</code>. It is unsafe because it uses the <code>output_index</code> and <code>variable_index</code> of <code>t1</code> as the <code>output_index</code> and <code>variable_index</code> of the output term without checking that they are equal to those of <code>t2</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.isapprox_zero" href="#MathOptInterface.Utilities.isapprox_zero"><code>MathOptInterface.Utilities.isapprox_zero</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isapprox_zero(f::MOI.AbstractFunction, tol)</code></pre><p>Return a <code>Bool</code> indicating whether the function <code>f</code> is approximately zero using <code>tol</code> as a tolerance.</p><p><strong>Important note</strong></p><p>This function assumes that <code>f</code> does not contain any duplicate terms, you might want to first call <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a> if that is not guaranteed. For instance, given</p><pre><code class="language-julia">f = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([1, -1], [x, x]), 0)`.</code></pre><p>then <code>isapprox_zero(f)</code> is <code>false</code> but <code>isapprox_zero(MOIU.canonical(f))</code> is <code>true</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.modify_function" href="#MathOptInterface.Utilities.modify_function"><code>MathOptInterface.Utilities.modify_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">modify_function(f::AbstractFunction, change::AbstractFunctionModification)</code></pre><p>Return a new function <code>f</code> modified according to <code>change</code>.</p></div></section></article><p>The following functions can be used to canonicalize a function:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.is_canonical" href="#MathOptInterface.Utilities.is_canonical"><code>MathOptInterface.Utilities.is_canonical</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_canonical(f::Union{ScalarAffineFunction, VectorAffineFunction})</code></pre><p>Returns a Bool indicating whether the function is in canonical form. See <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a>.</p></div></section><section><div><pre><code class="language-none">is_canonical(f::Union{ScalarQuadraticFunction, VectorQuadraticFunction})</code></pre><p>Returns a Bool indicating whether the function is in canonical form. See <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.canonical" href="#MathOptInterface.Utilities.canonical"><code>MathOptInterface.Utilities.canonical</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">canonical(f::Union{ScalarAffineFunction, VectorAffineFunction,
                   ScalarQuadraticFunction, VectorQuadraticFunction})</code></pre><p>Returns the function in a canonical form, i.e.</p><ul><li>A term appear only once.</li><li>The coefficients are nonzero.</li><li>The terms appear in increasing order of variable where there the order of the variables is the order of their value.</li><li>For a <code>AbstractVectorFunction</code>, the terms are sorted in ascending order of output index.</li></ul><p>The output of <code>canonical</code> can be assumed to be a copy of <code>f</code>, even for <code>VectorOfVariables</code>.</p><p><strong>Examples</strong></p><p>If <code>x</code> (resp. <code>y</code>, <code>z</code>) is <code>VariableIndex(1)</code> (resp. 2, 3). The canonical representation of <code>ScalarAffineFunction([y, x, z, x, z], [2, 1, 3, -2, -3], 5)</code> is <code>ScalarAffineFunction([x, y], [-1, 2], 5)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.canonicalize!" href="#MathOptInterface.Utilities.canonicalize!"><code>MathOptInterface.Utilities.canonicalize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">canonicalize!(f::Union{ScalarAffineFunction, VectorAffineFunction})</code></pre><p>Convert a function to canonical form in-place, without allocating a copy to hold the result. See <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a>.</p></div></section><section><div><pre><code class="language-none">canonicalize!(f::Union{ScalarQuadraticFunction, VectorQuadraticFunction})</code></pre><p>Convert a function to canonical form in-place, without allocating a copy to hold the result. See <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a>.</p></div></section></article><p>The following functions can be used to manipulate functions with basic algebra:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.scalar_type" href="#MathOptInterface.Utilities.scalar_type"><code>MathOptInterface.Utilities.scalar_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scalar_type(F::Type{&lt;:MOI.AbstractVectorFunction})</code></pre><p>Type of functions obtained by indexing objects obtained by calling <code>eachscalar</code> on functions of type <code>F</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.promote_operation" href="#MathOptInterface.Utilities.promote_operation"><code>MathOptInterface.Utilities.promote_operation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">promote_operation(op::Function, ::Type{T},
                  ArgsTypes::Type{&lt;:Union{T, MOI.AbstractFunction}}...) where T</code></pre><p>Returns the type of the <code>MOI.AbstractFunction</code> returned to the call <code>operate(op, T, args...)</code> where the types of the arguments <code>args</code> are <code>ArgsTypes</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.operate" href="#MathOptInterface.Utilities.operate"><code>MathOptInterface.Utilities.operate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">operate(op::Function, ::Type{T},
        args::Union{T, MOI.AbstractFunction}...)::MOI.AbstractFunction where T</code></pre><p>Returns an <code>MOI.AbstractFunction</code> representing the function resulting from the operation <code>op(args...)</code> on functions of coefficient type <code>T</code>. No argument can be modified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.operate!" href="#MathOptInterface.Utilities.operate!"><code>MathOptInterface.Utilities.operate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">operate!(op::Function, ::Type{T},
         args::Union{T, MOI.AbstractFunction}...)::MOI.AbstractFunction where T</code></pre><p>Returns an <code>MOI.AbstractFunction</code> representing the function resulting from the operation <code>op(args...)</code> on functions of coefficient type <code>T</code>. The first argument can be modified. The return type is the same than the method <code>operate(op, T, args...)</code> without <code>!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.operate_output_index!" href="#MathOptInterface.Utilities.operate_output_index!"><code>MathOptInterface.Utilities.operate_output_index!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">operate_output_index!(
    op::Function, ::Type{T}, output_index::Integer,
    func::MOI.AbstractVectorFunction
    args::Union{T, MOI.AbstractScalarFunction}...)::MOI.AbstractFunction where T</code></pre><p>Returns an <code>MOI.AbstractVectorFunction</code> where the function at <code>output_index</code> is the result of the operation <code>op</code> applied to the function at <code>output_index</code> of <code>func</code> and <code>args</code>. The functions at output index different to <code>output_index</code> are the same as the functions at the same output index in <code>func</code>. The first argument can be modified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.vectorize" href="#MathOptInterface.Utilities.vectorize"><code>MathOptInterface.Utilities.vectorize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vectorize(funcs::AbstractVector{MOI.SingleVariable})</code></pre><p>Returns the vector of scalar affine functions in the form of a <code>MOI.VectorAffineFunction{T}</code>.</p></div></section><section><div><pre><code class="language-none">vectorize(funcs::AbstractVector{MOI.ScalarAffineFunction{T}}) where T</code></pre><p>Returns the vector of scalar affine functions in the form of a <code>MOI.VectorAffineFunction{T}</code>.</p></div></section><section><div><pre><code class="language-none">vectorize(funcs::AbstractVector{MOI.ScalarQuadraticFunction{T}}) where T</code></pre><p>Returns the vector of scalar quadratic functions in the form of a <code>MOI.VectorQuadraticFunction{T}</code>.</p></div></section></article><h2 id="Constraint-utilities"><a class="docs-heading-anchor" href="#Constraint-utilities">Constraint utilities</a><a id="Constraint-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-utilities" title="Permalink"></a></h2><p>The following utilities are available for moving the function constant to the set for scalar constraints:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.shift_constant" href="#MathOptInterface.Utilities.shift_constant"><code>MathOptInterface.Utilities.shift_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">shift_constant(set::MOI.AbstractScalarSet,
               offset)</code></pre><p>Returns a new scalar set <code>new_set</code> such that <code>func</code>-in-<code>set</code> is equivalent to <code>func + offset</code>-in-<code>new_set</code>.</p><p><strong>Examples</strong></p><p>The call <code>shift_constant(MOI.Interval(-2, 3), 1)</code> is equal to <code>MOI.Interval(-1, 4)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.normalize_and_add_constraint" href="#MathOptInterface.Utilities.normalize_and_add_constraint"><code>MathOptInterface.Utilities.normalize_and_add_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalize_and_add_constraint(model::MOI.ModelLike,
                             func::MOI.AbstractScalarFunction,
                             set::MOI.AbstractScalarSet;
                             allow_modify_function::Bool=false)</code></pre><p>Adds the scalar constraint obtained by moving the constant term in <code>func</code> to the set in <code>model</code>. If <code>allow_modify_function</code> is <code>true</code> then the function <code>func</code> can be modified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.normalize_constant" href="#MathOptInterface.Utilities.normalize_constant"><code>MathOptInterface.Utilities.normalize_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalize_constant(func::MOI.AbstractScalarFunction,
                   set::MOI.AbstractScalarSet;
                   allow_modify_function::Bool=false)</code></pre><p>Return the <code>func</code>-in-<code>set</code> constraint in normalized form. That is, if <code>func</code> is <a href="#MathOptInterface.ScalarQuadraticFunction"><code>MOI.ScalarQuadraticFunction</code></a> or <a href="#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction</code></a>, the constant is moved to the set. If <code>allow_modify_function</code> is <code>true</code> then the function <code>func</code> can be modified.</p></div></section></article><p>The following utility identifies those constraints imposing bounds on a given variable, and returns those bound values:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.get_bounds" href="#MathOptInterface.Utilities.get_bounds"><code>MathOptInterface.Utilities.get_bounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_bounds(model::MOI.ModelLike, ::Type{T}, x::MOI.VariableIndex)</code></pre><p>Return a tuple <code>(lb, ub)</code> of type <code>Tuple{T, T}</code>, where <code>lb</code> and <code>ub</code> are lower  and upper bounds, respectively, imposed on <code>x</code> in <code>model</code>.</p></div></section></article><p>The following utilities are useful when working with symmetric matrix cones.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.is_diagonal_vectorized_index" href="#MathOptInterface.Utilities.is_diagonal_vectorized_index"><code>MathOptInterface.Utilities.is_diagonal_vectorized_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_diagonal_vectorized_index(index::Base.Integer)</code></pre><p>Return whether <code>index</code> is the index of a diagonal element in a <a href="#MathOptInterface.AbstractSymmetricMatrixSetTriangle"><code>MOI.AbstractSymmetricMatrixSetTriangle</code></a> set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.side_dimension_for_vectorized_dimension" href="#MathOptInterface.Utilities.side_dimension_for_vectorized_dimension"><code>MathOptInterface.Utilities.side_dimension_for_vectorized_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">side_dimension_for_vectorized_dimension(n::Integer)</code></pre><p>Return the dimension <code>d</code> such that <code>MOI.dimension(MOI.PositiveSemidefiniteConeTriangle(d))</code> is <code>n</code>.</p></div></section></article><h2 id="Benchmarks"><a class="docs-heading-anchor" href="#Benchmarks">Benchmarks</a><a id="Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarks" title="Permalink"></a></h2><p>Functions to help benchmark the performance of solver wrappers. See <a href="../manual/Benchmarks/#The-Benchmarks-submodule">The Benchmarks submodule</a> for more details.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Benchmarks.suite" href="#MathOptInterface.Benchmarks.suite"><code>MathOptInterface.Benchmarks.suite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">suite(
    new_model::Function;
    exclude::Vector{Regex} = Regex[]
)</code></pre><p>Create a suite of benchmarks. <code>new_model</code> should be a function that takes no arguments, and returns a new instance of the optimizer you wish to benchmark.</p><p>Use <code>exclude</code> to exclude a subset of benchmarks.</p><p><strong>Examples</strong></p><pre><code class="language-julia">suite() do
    GLPK.Optimizer()
end
suite(exclude = [r&quot;delete&quot;]) do
    Gurobi.Optimizer(OutputFlag=0)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Benchmarks.create_baseline" href="#MathOptInterface.Benchmarks.create_baseline"><code>MathOptInterface.Benchmarks.create_baseline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">create_baseline(suite, name::String; directory::String = &quot;&quot;; kwargs...)</code></pre><p>Run all benchmarks in <code>suite</code> and save to files called <code>name</code> in <code>directory</code>.</p><p>Extra <code>kwargs</code> are based to <code>BenchmarkTools.run</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">my_suite = suite(() -&gt; GLPK.Optimizer())
create_baseline(my_suite, &quot;glpk_master&quot;; directory = &quot;/tmp&quot;, verbose = true)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Benchmarks.compare_against_baseline" href="#MathOptInterface.Benchmarks.compare_against_baseline"><code>MathOptInterface.Benchmarks.compare_against_baseline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compare_against_baseline(
    suite, name::String; directory::String = &quot;&quot;,
    report_filename::String = &quot;report.txt&quot;
)</code></pre><p>Run all benchmarks in <code>suite</code> and compare against files called <code>name</code> in <code>directory</code> that were created by a call to <code>create_baseline</code>.</p><p>A report summarizing the comparison is written to <code>report_filename</code> in <code>directory</code>.</p><p>Extra <code>kwargs</code> are based to <code>BenchmarkTools.run</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">my_suite = suite(() -&gt; GLPK.Optimizer())
compare_against_baseline(
    my_suite, &quot;glpk_master&quot;; directory = &quot;/tmp&quot;, verbose = true
)</code></pre></div></section></article><h2 id="File-Formats"><a class="docs-heading-anchor" href="#File-Formats">File Formats</a><a id="File-Formats-1"></a><a class="docs-heading-anchor-permalink" href="#File-Formats" title="Permalink"></a></h2><p>Functions to help read and write MOI models to/from various file formats. See <a href="../manual/FileFormats/#The-FileFormats-submodule">The FileFormats submodule</a> for more details.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.FileFormats.Model" href="#MathOptInterface.FileFormats.Model"><code>MathOptInterface.FileFormats.Model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Model(
    ;
    format::FileFormat = FORMAT_AUTOMATIC,
    filename::Union{Nothing, String} = nothing,
    kwargs...
)</code></pre><p>Return model corresponding to the <code>FileFormat</code> <code>format</code>, or, if <code>format == FORMAT_AUTOMATIC</code>, guess the format from <code>filename</code>.</p><p>The <code>filename</code> argument is only needed if <code>format == FORMAT_AUTOMATIC</code>.</p><p><code>kwargs</code> are passed to the underlying model constructor.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.FileFormats.FileFormat" href="#MathOptInterface.FileFormats.FileFormat"><code>MathOptInterface.FileFormats.FileFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FileFormat</code></pre><p>List of accepted export formats.</p><ul><li><code>FORMAT_AUTOMATIC</code>: try to detect the file format based on the file name</li><li><code>FORMAT_CBF</code>: the Conic Benchmark format</li><li><code>FORMAT_LP</code>: the LP file format</li><li><code>FORMAT_MOF</code>: the MathOptFormat file format</li><li><code>FORMAT_MPS</code>: the MPS file format</li><li><code>FORMAT_SDPA</code>: the SemiDefinite Programming Algorithm format</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L11">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual/Utilities/">« The <code>Utilities</code> submodule</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 23 April 2021 03:45">Friday 23 April 2021</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
