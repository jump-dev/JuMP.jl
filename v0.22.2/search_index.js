var documenterSearchIndex = {"docs":
[{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/nonlinear/querying_hessians.jl\"","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/#Computing-Hessians","page":"Computing Hessians","title":"Computing Hessians","text":"","category":"section"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"The purpose of this tutorial is to demonstrate how to compute the Hessian of the Lagrangian of a nonlinear program.","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"warning: Warning\nThis is an advanced tutorial that interacts with the low-level nonlinear interface of MathOptInterface.By default, JuMP exports the MOI symbol as an alias for the MathOptInterface.jl package. We recommend making this more explicit in your code by adding the following lines:import MathOptInterface\nconst MOI = MathOptInterface","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Given a nonlinear program:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"beginalign\n min_x in mathbbR^n  f(x) \n textst  l le g_i(x) le u\nendalign","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"the Hessian of the Lagrangian is computed as:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"H(x sigma mu) = sigmanabla^2 f(x) + sum_i=1^m mu_i nabla^2 g_i(x)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"where x is a primal point, sigma is a scalar (typically 1), and mu is a vector of weights corresponding to the Lagrangian dual of the constraints.","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"using JuMP\nimport Ipopt\nimport LinearAlgebra\nimport Random\nimport SparseArrays","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/#The-basic-model","page":"Computing Hessians","title":"The basic model","text":"","category":"section"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"To demonstrate how to interact with the lower-level nonlinear interface, we need an example model. The exact model isn't important; we use the model from The Rosenbrock function tutorial, with some additional constraints to demonstrate various features of the lower-level interface.","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"model = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, x[i = 1:2], start = -i)\n@constraint(model, g_1, x[1]^2 <= 1)\n@NLconstraint(model, g_2, (x[1] + x[2])^2 <= 2)\n@NLobjective(model, Min, (1 - x[1])^2 + 100 * (x[2] - x[1]^2)^2)\noptimize!(model)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/#The-analytic-solution","page":"Computing Hessians","title":"The analytic solution","text":"","category":"section"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"With a little work, it is possible to analytically derive the correct hessian:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"function analytic_hessian(x, σ, μ)\n    g_1_H = [2.0 0.0; 0.0 0.0]\n    g_2_H = [2.0 2.0; 2.0 2.0]\n    f_H = zeros(2, 2)\n    f_H[1, 1] = 2.0 + 1200.0 * x[1]^2 - 400.0 * x[2]\n    f_H[1, 2] = f_H[2, 1] = -400.0 * x[1]\n    f_H[2, 2] = 200.0\n    return σ * f_H + μ' * [g_1_H, g_2_H]\nend","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Here are various points:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"analytic_hessian([1, 1], 0, [0, 0])","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"analytic_hessian([1, 1], 0, [1, 0])","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"analytic_hessian([1, 1], 0, [0, 1])","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"analytic_hessian([1, 1], 1, [0, 0])","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/#Initializing-the-NLPEvaluator","page":"Computing Hessians","title":"Initializing the NLPEvaluator","text":"","category":"section"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"JuMP stores all information relating to the nonlinear portions of the model in a NLPEvaluator struct:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"d = NLPEvaluator(model)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Before computing anything with the NLPEvaluator, we need to initialize it. Use MOI.features_available to see what we can query:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"MOI.features_available(d)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Consult the MOI documentation for specifics. But to obtain the Hessian matrix, we need to initialize :Hess:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"MOI.initialize(d, [:Hess])","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"MOI represents the Hessian as a sparse matrix. Get the sparsity pattern as follows:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"hessian_sparsity = MOI.hessian_lagrangian_structure(d)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"The sparsity pattern has a few properties of interest:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Each element (i, j) indicates a structural non-zero in row i and column j\nThe list may contain duplicates, in which case we should add the values together\nThe list does not need to be sorted\nThe list may contain any mix of lower- or upper-triangular indices","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"This format matches Julia's sparse-triplet form of a SparseArray, so we can convert from the sparse Hessian representation to a Julia SparseArray as follows:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"I = [i for (i, _) in hessian_sparsity]\nJ = [j for (_, j) in hessian_sparsity]\nV = zeros(length(hessian_sparsity))\nn = num_variables(model)\nH = SparseArrays.sparse(I, J, V, n, n)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Of course, knowing where the zeros are isn't very interesting. We really want to compute the value of the Hessian matrix at a point.","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"num_g = num_nl_constraints(model)\nMOI.eval_hessian_lagrangian(d, V, ones(n), 1.0, ones(num_g))\nH = SparseArrays.sparse(I, J, V, n, n)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"In practice, we often want to compute the value of the hessian at the optimal solution.","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"First, we compute the primal solution. To do so, we need a vector of the variables in the order that they were passed to the solver:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"x = all_variables(model)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Here x[1] is the variable that corresponds to column 1, and so on. Here's the optimal primal solution:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"x_optimal = value.(x)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Next, we need the optimal dual solution associated with the nonlinear constraints:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"y_optimal = dual.(all_nl_constraints(model))","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Now we can compute the Hessian at the optimal primal-dual point:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"MOI.eval_hessian_lagrangian(d, V, x_optimal, 1.0, y_optimal)\nH = SparseArrays.sparse(I, J, V, n, n)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"However, this Hessian isn't quite right because it isn't symmetric. We can fix this by filling in the appropriate off-diagonal terms:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"function fill_off_diagonal(H)\n    ret = H + H'\n    row_vals = SparseArrays.rowvals(ret)\n    non_zeros = SparseArrays.nonzeros(ret)\n    for col in 1:size(ret, 2)\n        for i in SparseArrays.nzrange(ret, col)\n            if col == row_vals[i]\n                non_zeros[i] /= 2\n            end\n        end\n    end\n    return ret\nend\n\nfill_off_diagonal(H)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Moreover, this Hessian only accounts for the objective and constraints entered using @NLobjective and @NLconstraint. If we want to take quadratic objectives and constraints written using @objective or @constraint into account, we'll need to handle them separately.","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"tip: Tip\nIf you don't want to do this, you can replace calls to @objective and @constraint with @NLobjective and @NLconstraint.","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/#Hessians-from-QuadExpr-functions","page":"Computing Hessians","title":"Hessians from QuadExpr functions","text":"","category":"section"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"To compute the hessian from a quadratic expression, let's see how JuMP represents a quadratic constraint:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"f = constraint_object(g_1).func","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"f is a quadratic expression of the form:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"f(x) = Σqᵢⱼ * xᵢ * xⱼ + Σaᵢ xᵢ + c","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"So ∇²f(x) is the matrix formed by [qᵢⱼ]ᵢⱼ.","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"variables_to_column = Dict(x[i] => i for i in 1:n)\n\nfunction add_to_hessian(H, f::QuadExpr, μ)\n    for (vars, coef) in f.terms\n        i = variables_to_column[vars.a]\n        j = variables_to_column[vars.b]\n        H[i, j] += μ * coef\n    end\n    return\nend","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"If the function f is not a QuadExpr, do nothing because it is an AffExpr or a VariableRef. In both cases, the second derivative is zero.","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"add_to_hessian(H, f::Any, μ) = nothing","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Then we iterate over all constraints in the model and add their Hessian components:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"for (F, S) in list_of_constraint_types(model)\n    for cref in all_constraints(model, F, S)\n        f = constraint_object(cref).func\n        add_to_hessian(H, f, dual(cref))\n    end\nend\n\nH","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Finally, we need to take into account the objective function:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"add_to_hessian(H, objective_function(model), 1.0)\n\nfill_off_diagonal(H)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Putting everything together:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"function compute_optimal_hessian(model)\n    d = NLPEvaluator(model)\n    MOI.initialize(d, [:Hess])\n    hessian_sparsity = MOI.hessian_lagrangian_structure(d)\n    I = [i for (i, _) in hessian_sparsity]\n    J = [j for (_, j) in hessian_sparsity]\n    V = zeros(length(hessian_sparsity))\n    x = all_variables(model)\n    x_optimal = value.(x)\n    y_optimal = dual.(all_nl_constraints(model))\n    MOI.eval_hessian_lagrangian(d, V, x_optimal, 1.0, y_optimal)\n    n = num_variables(model)\n    H = SparseArrays.sparse(I, J, V, n, n)\n    vmap = Dict(x[i] => i for i in 1:n)\n    add_to_hessian(H, f::Any, μ) = nothing\n    function add_to_hessian(H, f::QuadExpr, μ)\n        for (vars, coef) in f.terms\n            H[vmap[vars.a], vmap[vars.b]] += μ * coef\n        end\n    end\n    for (F, S) in list_of_constraint_types(model)\n        for cref in all_constraints(model, F, S)\n            add_to_hessian(H, constraint_object(cref).func, dual(cref))\n        end\n    end\n    add_to_hessian(H, objective_function(model), 1.0)\n    return Matrix(fill_off_diagonal(H))\nend\n\nH_star = compute_optimal_hessian(model)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"If we compare our solution against the analytical solution:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"analytic_hessian(value.(x), 1.0, dual.([g_1, g_2]))","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"If we look at the eigenvalues of the Hessian:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"LinearAlgebra.eigvals(H_star)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"we see that they are all positive. Therefore, the Hessian is positive definite, and so the solution found by Ipopt is a local minimizer.","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"moi/submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\n\n    # For compatibility with both Julia 1.0.5 and 1.5.2\n    # Upon the Julia LTS version becoming 1.6, these imports could be dropped,\n    # and all ScalarAffineTerm and VariableIndex instances in doctests below\n    # could be replaced with MOI.ScalarAffineTerm and MOI.VariableIndex\n    # Check discussion at PR 1184: https://github.com/jump-dev/MathOptInterface.jl/pull/1184#discussion_r515300914\n    import MathOptInterface.ScalarAffineTerm\n    import MathOptInterface.VariableIndex\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/FileFormats/reference/#File-Formats","page":"API Reference","title":"File Formats","text":"","category":"section"},{"location":"moi/submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"Functions to help read and write MOI models to/from various file formats. See The FileFormats submodule for more details.","category":"page"},{"location":"moi/submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"FileFormats.Model\nFileFormats.FileFormat","category":"page"},{"location":"moi/submodules/FileFormats/reference/#MathOptInterface.FileFormats.Model","page":"API Reference","title":"MathOptInterface.FileFormats.Model","text":"Model(\n    ;\n    format::FileFormat = FORMAT_AUTOMATIC,\n    filename::Union{Nothing, String} = nothing,\n    kwargs...\n)\n\nReturn model corresponding to the FileFormat format, or, if format == FORMAT_AUTOMATIC, guess the format from filename.\n\nThe filename argument is only needed if format == FORMAT_AUTOMATIC.\n\nkwargs are passed to the underlying model constructor.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/FileFormats/reference/#MathOptInterface.FileFormats.FileFormat","page":"API Reference","title":"MathOptInterface.FileFormats.FileFormat","text":"FileFormat\n\nList of accepted export formats.\n\nFORMAT_AUTOMATIC: try to detect the file format based on the file name\nFORMAT_CBF: the Conic Benchmark format\nFORMAT_LP: the LP file format\nFORMAT_MOF: the MathOptFormat file format\nFORMAT_MPS: the MPS file format\nFORMAT_NL: the AMPL .nl file format\nFORMAT_SDPA: the SemiDefinite Programming Algorithm format\n\n\n\n\n\n","category":"type"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/solutions/#manual_solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"moi/manual/solutions/#Solving-and-retrieving-the-results","page":"Solutions","title":"Solving and retrieving the results","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Once an optimizer is loaded with the objective function and all of the constraints, we can ask the solver to solve the model by calling optimize!.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"MOI.optimize!(optimizer)","category":"page"},{"location":"moi/manual/solutions/#Why-did-the-solver-stop?","page":"Solutions","title":"Why did the solver stop?","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"The optimization procedure may terminate for a number of reasons. The TerminationStatus attribute of the optimizer returns a TerminationStatusCode object which explains why the solver stopped.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"The termination statuses distinguish between proofs of optimality, infeasibility, local convergence, limits, and termination because of something unexpected like invalid problem data or failure to converge.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"A typical usage of the TerminationStatus attribute is as follows:","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"status = MOI.get(optimizer, TerminationStatus())\nif status == MOI.OPTIMAL\n    # Ok, we solved the problem!\nelse\n    # Handle other cases.\nend","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"After checking the TerminationStatus, check ResultCount. This attribute returns the number of results that the solver has available to return. A result is defined as a primal-dual pair, but either the primal or the dual may be missing from the result. While the OPTIMAL termination status normally implies that at least one result is available, other statuses do not. For example, in the case of infeasiblity, a solver may return no result or a proof of infeasibility. The ResultCount attribute distinguishes between these two cases.","category":"page"},{"location":"moi/manual/solutions/#Primal-solutions","page":"Solutions","title":"Primal solutions","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Use the PrimalStatus optimizer attribute to return a ResultStatusCode describing the status of the primal solution.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Common returns are described below in the Common status situations section.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Query the primal solution using the VariablePrimal and ConstraintPrimal attributes.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Query the objective function value using the ObjectiveValue attribute.","category":"page"},{"location":"moi/manual/solutions/#Dual-solutions","page":"Solutions","title":"Dual solutions","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nSee Duality for a discussion of the MOI conventions for primal-dual pairs and certificates.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Use the DualStatus optimizer attribute to return a ResultStatusCode describing the status of the dual solution.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Query the dual solution using the ConstraintDual attribute.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Query the dual objective function value using the DualObjectiveValue attribute.","category":"page"},{"location":"moi/manual/solutions/#Common-status-situations","page":"Solutions","title":"Common status situations","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"The sections below describe how to interpret typical or interesting status cases for three common classes of solvers. The example cases are illustrative, not comprehensive. Solver wrappers may provide additional information on how the solver's statuses map to MOI statuses.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"info: Info\n* in the tables indicate that multiple different values are possible.","category":"page"},{"location":"moi/manual/solutions/#Primal-dual-convex-solver","page":"Solutions","title":"Primal-dual convex solver","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Linear programming and conic optimization solvers fall into this category.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"What happened? TerminationStatus ResultCount PrimalStatus DualStatus\nProved optimality OPTIMAL 1 FEASIBLE_POINT FEASIBLE_POINT\nProved infeasible INFEASIBLE 1 NO_SOLUTION INFEASIBILITY_CERTIFICATE\nOptimal within relaxed tolerances ALMOST_OPTIMAL 1 FEASIBLE_POINT FEASIBLE_POINT\nOptimal within relaxed tolerances ALMOST_OPTIMAL 1 ALMOST_FEASIBLE_POINT ALMOST_FEASIBLE_POINT\nDetected an unbounded ray of the primal DUAL_INFEASIBLE 1 INFEASIBILITY_CERTIFICATE NO_SOLUTION\nStall SLOW_PROGRESS 1 * *","category":"page"},{"location":"moi/manual/solutions/#Global-branch-and-bound-solvers","page":"Solutions","title":"Global branch-and-bound solvers","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Mixed-integer programming solvers fall into this category.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"What happened? TerminationStatus ResultCount PrimalStatus DualStatus\nProved optimality OPTIMAL 1 FEASIBLE_POINT NO_SOLUTION\nPresolve detected infeasibility or unboundedness INFEASIBLE_OR_UNBOUNDED 0 NO_SOLUTION NO_SOLUTION\nProved infeasibility INFEASIBLE 0 NO_SOLUTION NO_SOLUTION\nTimed out (no solution) TIME_LIMIT 0 NO_SOLUTION NO_SOLUTION\nTimed out (with a solution) TIME_LIMIT 1 FEASIBLE_POINT NO_SOLUTION\nCPXMIP_OPTIMAL_INFEAS ALMOST_OPTIMAL 1 INFEASIBLE_POINT NO_SOLUTION","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"info: Info\nCPXMIP_OPTIMAL_INFEAS is a CPLEX status that indicates that a preprocessed problem was solved to optimality, but the solver was unable to recover a feasible solution to the original problem. Handling this status was one of the motivating drivers behind the design of MOI.","category":"page"},{"location":"moi/manual/solutions/#Local-search-solvers","page":"Solutions","title":"Local search solvers","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Nonlinear programming solvers fall into this category. It also includes non-global tree search solvers like Juniper.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"What happened? TerminationStatus ResultCount PrimalStatus DualStatus\nConverged to a stationary point LOCALLY_SOLVED 1 FEASIBLE_POINT FEASIBLE_POINT\nCompleted a non-global tree search (with a solution) LOCALLY_SOLVED 1 FEASIBLE_POINT FEASIBLE_POINT\nConverged to an infeasible point LOCALLY_INFEASIBLE 1 INFEASIBLE_POINT *\nCompleted a non-global tree search (no solution found) LOCALLY_INFEASIBLE 0 NO_SOLUTION NO_SOLUTION\nIteration limit ITERATION_LIMIT 1 * *\nDiverging iterates NORM_LIMIT or OBJECTIVE_LIMIT 1 * *","category":"page"},{"location":"tutorials/linear/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/linear/steelT3.jl\"","category":"page"},{"location":"tutorials/linear/steelT3/#The-SteelT3-problem","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"","category":"section"},{"location":"tutorials/linear/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"The steelT3 model from AMPL: A Modeling Language for Mathematical Programming, 2nd ed by Robert Fourer, David Gay, and Brian W. Kernighan.","category":"page"},{"location":"tutorials/linear/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"Originally contributed by Louis Luangkesorn, April 3, 2015.","category":"page"},{"location":"tutorials/linear/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_steelT3(; verbose = true)\n    T = 4\n    prod = [\"bands\", \"coils\"]\n    area = Dict(\n        \"bands\" => (\"east\", \"north\"),\n        \"coils\" => (\"east\", \"west\", \"export\"),\n    )\n    avail = [40, 40, 32, 40]\n    rate = Dict(\"bands\" => 200, \"coils\" => 140)\n    inv0 = Dict(\"bands\" => 10, \"coils\" => 0)\n    prodcost = Dict(\"bands\" => 10, \"coils\" => 11)\n    invcost = Dict(\"bands\" => 2.5, \"coils\" => 3)\n    revenue = Dict(\n        \"bands\" => Dict(\n            \"east\" => [25.0, 26.0, 27.0, 27.0],\n            \"north\" => [26.5, 27.5, 28.0, 28.5],\n        ),\n        \"coils\" => Dict(\n            \"east\" => [30, 35, 37, 39],\n            \"west\" => [29, 32, 33, 35],\n            \"export\" => [25, 25, 25, 28],\n        ),\n    )\n    market = Dict(\n        \"bands\" => Dict(\n            \"east\" => [2000, 2000, 1500, 2000],\n            \"north\" => [4000, 4000, 2500, 4500],\n        ),\n        \"coils\" => Dict(\n            \"east\" => [1000, 800, 1000, 1100],\n            \"west\" => [2000, 1200, 2000, 2300],\n            \"export\" => [1000, 500, 500, 800],\n        ),\n    )\n    # Model\n    model = Model(GLPK.Optimizer)\n    # Decision Variables\n    @variables(\n        model,\n        begin\n            make[p in prod, t in 1:T] >= 0\n            inventory[p in prod, t in 0:T] >= 0\n            0 <= sell[p in prod, a in area[p], t in 1:T] <= market[p][a][t]\n        end\n    )\n    @constraints(\n        model,\n        begin\n            [p = prod, a = area[p], t = 1:T], sell[p, a, t] <= market[p][a][t]\n            # Total of hours used by all products may not exceed hours available,\n            # in each week\n            [t in 1:T], sum(1 / rate[p] * make[p, t] for p in prod) <= avail[t]\n            # Initial inventory must equal given value\n            [p in prod], inventory[p, 0] == inv0[p]\n            # Tons produced and taken from inventory must equal tons sold and put\n            # into inventory.\n            [p in prod, t in 1:T],\n            make[p, t] + inventory[p, t-1] ==\n            sum(sell[p, a, t] for a in area[p]) + inventory[p, t]\n        end\n    )\n    # Maximize total profit: total revenue less costs for all products in all\n    # weeks.\n    @objective(\n        model,\n        Max,\n        sum(\n            revenue[p][a][t] * sell[p, a, t] - prodcost[p] * make[p, t] -\n            invcost[p] * inventory[p, t] for p in prod, a in area[p], t in 1:T\n        )\n    )\n    optimize!(model)\n    Test.@test termination_status(model) == OPTIMAL\n    Test.@test primal_status(model) == FEASIBLE_POINT\n    Test.@test objective_value(model) == 172850.0\n    if verbose\n        println(\"RESULTS:\")\n        for p in prod\n            println(\"make $(p)\")\n            for t in 1:T\n                print(value(make[p, t]), \"\\t\")\n            end\n            println()\n            println(\"Inventory $(p)\")\n            for t in 1:T\n                print(value(inventory[p, t]), \"\\t\")\n            end\n            println()\n            for a in area[p]\n                println(\"sell $(p) $(a)\")\n                for t in 1:T\n                    print(value(sell[p, a, t]), \"\\t\")\n                end\n                println()\n            end\n        end\n    end\n    return\nend\n\nexample_steelT3()","category":"page"},{"location":"tutorials/linear/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"","category":"page"},{"location":"tutorials/linear/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"moi/reference/nonlinear/","page":"Nonlinear programming","title":"Nonlinear programming","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/nonlinear/#Nonlinear-programming","page":"Nonlinear programming","title":"Nonlinear programming","text":"","category":"section"},{"location":"moi/reference/nonlinear/#Types","page":"Nonlinear programming","title":"Types","text":"","category":"section"},{"location":"moi/reference/nonlinear/","page":"Nonlinear programming","title":"Nonlinear programming","text":"AbstractNLPEvaluator\nNLPBoundsPair\nNLPBlockData","category":"page"},{"location":"moi/reference/nonlinear/#MathOptInterface.AbstractNLPEvaluator","page":"Nonlinear programming","title":"MathOptInterface.AbstractNLPEvaluator","text":"AbstractNLPEvaluator\n\nAbstract supertype for the callback object that is used to query function values, derivatives, and expression graphs. It is used in NLPBlock.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#MathOptInterface.NLPBoundsPair","page":"Nonlinear programming","title":"MathOptInterface.NLPBoundsPair","text":"NLPBoundsPair(lower,upper)\n\nA struct holding a pair of lower and upper bounds. -Inf and Inf can be used to indicate no lower or upper bound, respectively.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#MathOptInterface.NLPBlockData","page":"Nonlinear programming","title":"MathOptInterface.NLPBlockData","text":"struct NLPBlockData\n    constraint_bounds::Vector{NLPBoundsPair}\n    evaluator::AbstractNLPEvaluator\n    has_objective::Bool\nend\n\nA struct encoding a set of nonlinear constraints of the form lb le g(x) le ub and, if has_objective == true, a nonlinear objective function f(x). constraint_bounds holds the pairs of lb and ub elements. Nonlinear objectives override any objective set by using the ObjectiveFunction attribute. The evaluator is a callback object that is used to query function values, derivatives, and expression graphs. If has_objective == false, then it is an error to query properties of the objective function, and in Hessian-of-the-Lagrangian queries, σ must be set to zero.\n\nnote: Note\nThroughout the evaluator, all variables are ordered according to ListOfVariableIndices. Hence, MOI copies of nonlinear problems should be done with attention.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#Attributes","page":"Nonlinear programming","title":"Attributes","text":"","category":"section"},{"location":"moi/reference/nonlinear/","page":"Nonlinear programming","title":"Nonlinear programming","text":"NLPBlock\nNLPBlockDual\nNLPBlockDualStart","category":"page"},{"location":"moi/reference/nonlinear/#MathOptInterface.NLPBlock","page":"Nonlinear programming","title":"MathOptInterface.NLPBlock","text":"NLPBlock()\n\nHolds the NLPBlockData that represents a set of nonlinear constraints, and optionally a nonlinear objective.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#MathOptInterface.NLPBlockDual","page":"Nonlinear programming","title":"MathOptInterface.NLPBlockDual","text":"NLPBlockDual(result_index::Int)\nNLPBlockDual()\n\nThe Lagrange multipliers on the constraints from the NLPBlock in result result_index. If result_index is omitted, it is 1 by default.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#MathOptInterface.NLPBlockDualStart","page":"Nonlinear programming","title":"MathOptInterface.NLPBlockDualStart","text":"NLPBlockDualStart()\n\nAn initial assignment of the Lagrange multipliers on the constraints from the NLPBlock that the solver may use to warm-start the solve.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#Functions","page":"Nonlinear programming","title":"Functions","text":"","category":"section"},{"location":"moi/reference/nonlinear/","page":"Nonlinear programming","title":"Nonlinear programming","text":"initialize\nfeatures_available\neval_objective\neval_constraint\neval_objective_gradient\njacobian_structure\nhessian_lagrangian_structure\neval_constraint_jacobian\neval_constraint_jacobian_product\neval_constraint_jacobian_transpose_product\neval_hessian_lagrangian\neval_hessian_lagrangian_product\nobjective_expr\nconstraint_expr","category":"page"},{"location":"moi/reference/nonlinear/#MathOptInterface.initialize","page":"Nonlinear programming","title":"MathOptInterface.initialize","text":"initialize(d::AbstractNLPEvaluator, requested_features::Vector{Symbol})\n\nMust be called before any other methods. The vector requested_features lists features requested by the solver. These may include :Grad for gradients of the obejctive, f, :Jac for explicit Jacobians of constraints, g, :JacVec for Jacobian-vector products, :HessVec for Hessian-vector and Hessian-of-Lagrangian-vector products, :Hess for explicit Hessians and Hessian-of-Lagrangians, and :ExprGraph for expression graphs.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.features_available","page":"Nonlinear programming","title":"MathOptInterface.features_available","text":"features_available(d::AbstractNLPEvaluator)\n\nReturns the subset of features available for this problem instance, as a vector of symbols in the same format as in initialize.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_objective","page":"Nonlinear programming","title":"MathOptInterface.eval_objective","text":"eval_objective(d::AbstractNLPEvaluator, x)\n\nEvaluate the objective f(x), returning a scalar value.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_constraint","page":"Nonlinear programming","title":"MathOptInterface.eval_constraint","text":"eval_constraint(d::AbstractNLPEvaluator, g, x)\n\nEvaluate the constraint function g(x), storing the result in the vector g which must be of the appropriate size.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_objective_gradient","page":"Nonlinear programming","title":"MathOptInterface.eval_objective_gradient","text":"eval_objective_gradient(d::AbstractNLPEvaluator, df, x)\n\nEvaluate nabla f(x) as a dense vector, storing the result in the vector df which must be of the appropriate size.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.jacobian_structure","page":"Nonlinear programming","title":"MathOptInterface.jacobian_structure","text":"jacobian_structure(d::AbstractNLPEvaluator)::Vector{Tuple{Int64,Int64}}\n\nReturns the sparsity structure of the Jacobian matrix J_g(x) = left beginarrayc nabla g_1(x)  nabla g_2(x)  vdots  nabla g_m(x) endarrayright where g_i is the itextth component of g. The sparsity structure is assumed to be independent of the point x. Returns a vector of tuples, (row, column), where each indicates the position of a structurally nonzero element. These indices are not required to be sorted and can contain duplicates, in which case the solver should combine the corresponding elements by adding them together.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.hessian_lagrangian_structure","page":"Nonlinear programming","title":"MathOptInterface.hessian_lagrangian_structure","text":"hessian_lagrangian_structure(d::AbstractNLPEvaluator)::Vector{Tuple{Int64,Int64}}\n\nReturns the sparsity structure of the Hessian-of-the-Lagrangian matrix nabla^2 f + sum_i=1^m nabla^2 g_i as a vector of tuples, where each indicates the position of a structurally nonzero element. These indices are not required to be sorted and can contain duplicates, in which case the solver should combine the corresponding elements by adding them together. Any mix of lower and upper-triangular indices is valid. Elements (i,j) and (j,i), if both present, should be treated as duplicates.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_constraint_jacobian","page":"Nonlinear programming","title":"MathOptInterface.eval_constraint_jacobian","text":"eval_constraint_jacobian(d::AbstractNLPEvaluator, J, x)\n\nEvaluates the sparse Jacobian matrix J_g(x) = left beginarrayc nabla g_1(x)  nabla g_2(x)  vdots  nabla g_m(x) endarrayright. The result is stored in the vector J in the same order as the indices returned by jacobian_structure.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_constraint_jacobian_product","page":"Nonlinear programming","title":"MathOptInterface.eval_constraint_jacobian_product","text":"eval_constraint_jacobian_product(d::AbstractNLPEvaluator, y, x, w)\n\nComputes the Jacobian-vector product J_g(x)w, storing the result in the vector y.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_constraint_jacobian_transpose_product","page":"Nonlinear programming","title":"MathOptInterface.eval_constraint_jacobian_transpose_product","text":"eval_constraint_jacobian_transpose_product(d::AbstractNLPEvaluator, y, x, w)\n\nComputes the Jacobian-transpose-vector product J_g(x)^Tw, storing the result in the vector y.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_hessian_lagrangian","page":"Nonlinear programming","title":"MathOptInterface.eval_hessian_lagrangian","text":"eval_hessian_lagrangian(d::AbstractNLPEvaluator, H, x, σ, μ)\n\nGiven scalar weight σ and vector of constraint weights μ, computes the sparse Hessian-of-the-Lagrangian matrix sigmanabla^2 f(x) + sum_i=1^m mu_i nabla^2 g_i(x), storing the result in the vector H in the same order as the indices returned by hessian_lagrangian_structure.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_hessian_lagrangian_product","page":"Nonlinear programming","title":"MathOptInterface.eval_hessian_lagrangian_product","text":"eval_hessian_lagrangian_product(d::AbstractNLPEvaluator, h, x, v, σ, μ)\n\nGiven scalar weight σ and vector of constraint weights μ, computes the Hessian-of-the-Lagrangian-vector product left(sigmanabla^2 f(x) + sum_i=1^m mu_i nabla^2 g_i(x)right)v, storing the result in the vector h.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.objective_expr","page":"Nonlinear programming","title":"MathOptInterface.objective_expr","text":"objective_expr(d::AbstractNLPEvaluator)\n\nReturns an expression graph for the objective function as a standard Julia Expr object. All sums and products are flattened out as simple Expr(:+,...) and Expr(:*,...) objects. The symbol x is used as a placeholder for the vector of decision variables. No other undefined symbols are permitted; coefficients are embedded as explicit values. For example, the expression x_1+sin(x_2exp(x_3)) would be represented as the Julia object :(x[1] + sin(x[2]/exp(x[3]))). Each integer index is wrapped in a VariableIndex. See the Julia manual for more information on the structure of Expr objects. There are currently no restrictions on recognized functions; typically these will be built-in Julia functions like ^, exp, log, cos, tan, sqrt, etc., but modeling interfaces may choose to extend these basic functions.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.constraint_expr","page":"Nonlinear programming","title":"MathOptInterface.constraint_expr","text":"constraint_expr(d::AbstractNLPEvaluator, i)\n\nReturns an expression graph for the itextth constraint in the same format as described above, with an additional comparison operator indicating the sense of and bounds on the constraint. The right-hand side of the comparison must be a constant; that is, :(x[1]^3 <= 1) is allowed, while :(1 <= x[1]^3) is not valid. Double-sided constraints are allowed, in which case both the lower bound and upper bounds should be constants; for example, :(-1 <= cos(x[1]) + sin(x[2]) <= 1) is valid.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/algorithms/cutting_stock_column_generation.jl\"","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/#Column-generation","page":"Column generation","title":"Column generation","text":"","category":"section"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"This example solves the cutting stock problem (sometimes also called the cutting rod problem) using a column-generation technique. It is based on https://doi.org/10.5281/zenodo.3329388.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Intuitively, this problem is about cutting large rolls of paper into smaller pieces. There is an exact demand of pieces to meet, and all rolls have the same size. The goal is to meet the demand while maximizing the profits (each paper roll has a fixed cost, each sold piece allows earning some money), which is roughly equivalent to using the smallest amount of rolls to cut (or, equivalently, to minimize the amount of paper waste).","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"This function takes five parameters:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"maxwidth: the maximum width of a roll (or length of a rod)\nwidths: an array of the requested widths\nrollcost: the cost of a complete roll\ndemand: the demand, in number of pieces, for each width\nprices: the selling price for each width","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Mathematically, this problem might be formulated with two variables:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"x[i, j] ∈ ℕ: the number of times the width i is cut out of the roll j\ny[j] ∈ 𝔹: whether the roll j is used","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Several constraints are needed:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"the demand must be satisfied, for each width i: ∑j x[i, j] = demand[i]\nthe roll size cannot be exceed, for each roll j that is used: ∑i x[i, j] width[i] ≤ maxwidth y[j]","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"If you want to implement this naïve model, you will need an upper bound on the number of rolls to use: the simplest one is to consider that each required width is cut from its own roll, i.e. j varies from 1 to ∑i demand[i].","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"This example prefers a more advanced technique to solve this problem: column generation.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"It considers a different set of variables: patterns of width to cut a roll. The decisions then become the number of times each pattern is used (i.e. the number of rolls that are cut following this pattern).","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"The intelligence comes from the way these patterns are chosen: not all of them are considered, but only the \"interesting\" ones, within the master problem.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"A \"pricing\" problem is used to decide whether a new pattern should be generated or not (it is implemented in the function solve_pricing). \"Interesting\" means, for a pattern, that the optimal solution may use this cutting pattern.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"In more detail, the solving process is the following. First, a series of dumb patterns are generated (one width per roll, repeated until the roll is completely cut). Then, the master problem is solved with these first patterns and its dual solution is passed on to the pricing problem. The latter decides if there is a new pattern to include in the formulation or not; if so, it returns it to the master problem. The master is solved again, the new dual variables are given to the pricing problem, until there is no more pattern to generate from the pricing problem: all \"interesting\" patterns have been generated, and the master can take its optimal decision.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"In the implementation, the variables deciding how many times a pattern is chosen are called θ.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"For more information on column-generation techniques applied on the cutting stock problem, you can see:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Integer programming column generation strategies for the cutting stock problem and its variants\nTackling the cutting stock problem","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"This example uses the following packages:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"using JuMP\nimport GLPK\nimport SparseArrays","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"The function solve_pricing implements the pricing problem for the function example_cutting_stock.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"It takes, as input, the dual solution from the master problem and the cutting stock instance.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"It outputs either a new cutting pattern, or nothing if no pattern could improve the current cost.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"function solve_pricing(\n    dual_demand_satisfaction,\n    maxwidth,\n    widths,\n    rollcost,\n    demand,\n    prices,\n)\n    reduced_costs = dual_demand_satisfaction + prices\n    n = length(reduced_costs)\n    # The actual pricing model.\n    submodel = Model(GLPK.Optimizer)\n    set_silent(submodel)\n    @variable(submodel, xs[1:n] >= 0, Int)\n    @constraint(submodel, sum(xs .* widths) <= maxwidth)\n    @objective(submodel, Max, sum(xs .* reduced_costs))\n    optimize!(submodel)\n    new_pattern = round.(Int, value.(xs))\n    net_cost =\n        rollcost - sum(new_pattern .* (dual_demand_satisfaction .+ prices))\n    # If the net cost of this new pattern is nonnegative, no more patterns to add.\n    return net_cost >= 0 ? nothing : new_pattern\nend\n\nfunction example_cutting_stock(; max_gen_cols::Int = 5_000)\n    maxwidth = 100.0\n    rollcost = 500.0\n    prices = [\n        167.0,\n        197.0,\n        281.0,\n        212.0,\n        225.0,\n        111.0,\n        93.0,\n        129.0,\n        108.0,\n        106.0,\n        55.0,\n        85.0,\n        66.0,\n        44.0,\n        47.0,\n        15.0,\n        24.0,\n        13.0,\n        16.0,\n        14.0,\n    ]\n    widths = [\n        75.0,\n        75.0,\n        75.0,\n        75.0,\n        75.0,\n        53.8,\n        53.0,\n        51.0,\n        50.2,\n        32.2,\n        30.8,\n        29.8,\n        20.1,\n        16.2,\n        14.5,\n        11.0,\n        8.6,\n        8.2,\n        6.6,\n        5.1,\n    ]\n    demand = [\n        38,\n        44,\n        30,\n        41,\n        36,\n        33,\n        36,\n        41,\n        35,\n        37,\n        44,\n        49,\n        37,\n        36,\n        42,\n        33,\n        47,\n        35,\n        49,\n        42,\n    ]\n    nwidths = length(prices)\n    n = length(widths)\n    ncols = length(widths)\n    # Initial set of patterns (stored in a sparse matrix: a pattern won't\n    # include many different cuts).\n    patterns = SparseArrays.spzeros(UInt16, n, ncols)\n    for i in 1:n\n        patterns[i, i] =\n            min(floor(Int, maxwidth / widths[i]), round(Int, demand[i]))\n    end\n    # Write the master problem with this \"reduced\" set of patterns.\n    # Not yet integer variables: otherwise, the dual values may make no sense\n    # (actually, GLPK will yell at you if you're trying to get duals for\n    # integer problems).\n    m = Model(GLPK.Optimizer)\n    set_silent(m)\n    @variable(m, θ[1:ncols] >= 0)\n    @objective(\n        m,\n        Min,\n        sum(\n            θ[p] * (rollcost - sum(patterns[j, p] * prices[j] for j in 1:n)) for\n            p in 1:ncols\n        )\n    )\n    @constraint(\n        m,\n        demand_satisfaction[j = 1:n],\n        sum(patterns[j, p] * θ[p] for p in 1:ncols) >= demand[j]\n    )\n    # First solve of the master problem.\n    optimize!(m)\n    if termination_status(m) != OPTIMAL\n        warn(\"Master not optimal ($ncols patterns so far)\")\n    end\n    # Then, generate new patterns, based on the dual information.\n    while ncols - n <= max_gen_cols ## Generate at most max_gen_cols columns.\n        if !has_duals(m)\n            break\n        end\n        new_pattern = solve_pricing(\n            dual.(demand_satisfaction),\n            maxwidth,\n            widths,\n            rollcost,\n            demand,\n            prices,\n        )\n        # No new pattern to add to the formulation: done!\n        if new_pattern === nothing\n            break\n        end\n        # Otherwise, add the new pattern to the master problem, recompute the\n        # duals, and go on waltzing one more time with the pricing problem.\n        ncols += 1\n        patterns = hcat(patterns, new_pattern)\n        # One new variable.\n        push!(θ, @variable(m, base_name = \"θ\", lower_bound = 0))\n        # Update the objective function.\n        set_objective_coefficient(\n            m,\n            θ[ncols],\n            rollcost - sum(patterns[j, ncols] * prices[j] for j in 1:n),\n        )\n        # Update the constraint number j if the new pattern impacts this production.\n        for j in 1:n\n            if new_pattern[j] > 0\n                set_normalized_coefficient(\n                    demand_satisfaction[j],\n                    θ[ncols],\n                    new_pattern[j],\n                )\n            end\n        end\n        # Solve the new master problem to update the dual variables.\n        optimize!(m)\n        if termination_status(m) != OPTIMAL\n            @warn(\"Master not optimal ($ncols patterns so far)\")\n        end\n    end\n    # Finally, impose the master variables to be integer and resolve.\n    # To be exact, at each node in the branch-and-bound tree, we would need to\n    # restart the column generation process (just in case a new column would be\n    # interesting to add). This way, we only get an upper bound (a feasible\n    # solution).\n    set_integer.(θ)\n    optimize!(m)\n    if termination_status(m) != OPTIMAL\n        @warn(\"Final master not optimal ($ncols patterns)\")\n        return\n    end\n    println(\"Final solution:\")\n    for i in 1:length(θ)\n        if value(θ[i]) > 0.5\n            println(\"$(round(Int, value(θ[i]))) units of pattern $(i)\")\n        end\n    end\n    return\nend\n\nexample_cutting_stock()","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"reference/containers/#ContainersAPI","page":"Containers","title":"Containers","text":"","category":"section"},{"location":"reference/containers/","page":"Containers","title":"Containers","text":"More information can be found in the Containers section of the manual.","category":"page"},{"location":"reference/containers/","page":"Containers","title":"Containers","text":"Containers\nContainers.DenseAxisArray\nContainers.SparseAxisArray\nContainers.container\nContainers.default_container\nContainers.@container\nContainers.VectorizedProductIterator\nContainers.vectorized_product\nContainers.NestedIterator\nContainers.nested","category":"page"},{"location":"reference/containers/#JuMP.Containers","page":"Containers","title":"JuMP.Containers","text":"Containers\n\nModule defining the containers DenseAxisArray and SparseAxisArray that behaves as a regular AbstractArray but with custom indexes that are not necessarily integers.\n\n\n\n\n\n","category":"module"},{"location":"reference/containers/#JuMP.Containers.DenseAxisArray","page":"Containers","title":"JuMP.Containers.DenseAxisArray","text":"DenseAxisArray(data::Array{T, N}, axes...) where {T, N}\n\nConstruct a JuMP array with the underlying data specified by the data array and the given axes. Exactly N axes must be provided, and their lengths must match size(data) in the corresponding dimensions.\n\nExample\n\njulia> array = JuMP.Containers.DenseAxisArray([1 2; 3 4], [:a, :b], 2:3)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 2:3\nAnd data, a 2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> array[:b, 3]\n4\n\n\n\n\n\nDenseAxisArray{T}(undef, axes...) where T\n\nConstruct an uninitialized DenseAxisArray with element-type T indexed over the given axes.\n\nExample\n\njulia> array = JuMP.Containers.DenseAxisArray{Float64}(undef, [:a, :b], 1:2);\n\njulia> fill!(array, 1.0)\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 1:2\nAnd data, a 2×2 Array{Float64,2}:\n 1.0  1.0\n 1.0  1.0\n\njulia> array[:a, 2] = 5.0\n5.0\n\njulia> array[:a, 2]\n5.0\n\njulia> array\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 1:2\nAnd data, a 2×2 Array{Float64,2}:\n 1.0  5.0\n 1.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"reference/containers/#JuMP.Containers.SparseAxisArray","page":"Containers","title":"JuMP.Containers.SparseAxisArray","text":"struct SparseAxisArray{T,N,K<:NTuple{N, Any}} <: AbstractArray{T,N}\n    data::Dict{K,T}\nend\n\nN-dimensional array with elements of type T where only a subset of the entries are defined. The entries with indices idx = (i1, i2, ..., iN) in keys(data) has value data[idx]. Note that as opposed to SparseArrays.AbstractSparseArray, the missing entries are not assumed to be zero(T), they are simply not part of the array. This means that the result of map(f, sa::SparseAxisArray) or f.(sa::SparseAxisArray) has the same sparsity structure than sa even if f(zero(T)) is not zero.\n\nExamples\n\njulia> dict = Dict((:a, 2) => 1.0, (:a, 3) => 2.0, (:b, 3) => 3.0)\nDict{Tuple{Symbol,Int64},Float64} with 3 entries:\n  (:b, 3) => 3.0\n  (:a, 2) => 1.0\n  (:a, 3) => 2.0\n\njulia> array = JuMP.Containers.SparseAxisArray(dict)\nJuMP.Containers.SparseAxisArray{Float64,2,Tuple{Symbol,Int64}} with 3 entries:\n  [b, 3]  =  3.0\n  [a, 2]  =  1.0\n  [a, 3]  =  2.0\n\njulia> array[:b, 3]\n3.0\n\n\n\n\n\n","category":"type"},{"location":"reference/containers/#JuMP.Containers.container","page":"Containers","title":"JuMP.Containers.container","text":"container(f::Function, indices, ::Type{C})\n\nCreate a container of type C with indices indices and values at given indices given by f.\n\ncontainer(f::Function, indices)\n\nCreate a container with indices indices and values at given indices given by f. The type of container used is determined by default_container.\n\nExamples\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(Base.OneTo(3), Base.OneTo(3)))\n3×3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(1:3, 1:3))\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, 1:3\nAnd data, a 3×3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(2:3, Base.OneTo(3)))\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, Base.OneTo(3)\nAnd data, a 2×3 Array{Int64,2}:\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.nested(() -> 1:3, i -> i:3, condition = (i, j) -> isodd(i) || isodd(j)))\nSparseAxisArray{Int64,2,Tuple{Int64,Int64}} with 5 entries:\n  [1, 2]  =  3\n  [2, 3]  =  5\n  [3, 3]  =  6\n  [1, 1]  =  2\n  [1, 3]  =  4\n\n\n\n\n\n","category":"function"},{"location":"reference/containers/#JuMP.Containers.default_container","page":"Containers","title":"JuMP.Containers.default_container","text":"default_container(indices)\n\nIf indices is a NestedIterator, return a SparseAxisArray. Otherwise, indices should be a VectorizedProductIterator and the function returns Array if all iterators of the product are Base.OneTo and retunrs DenseAxisArray otherwise.\n\n\n\n\n\n","category":"function"},{"location":"reference/containers/#JuMP.Containers.@container","page":"Containers","title":"JuMP.Containers.@container","text":"@container([i=..., j=..., ...], expr[, container = :Auto])\n\nCreate a container with indices i, j, ... and values given by expr that may depend on the value of the indices.\n\n@container(ref[i=..., j=..., ...], expr[, container = :Auto])\n\nSame as above but the container is assigned to the variable of name ref.\n\nThe type of container can be controlled by the container keyword.\n\nnote: Note\nWhen the index set is explicitly given as 1:n for any expression n, it is transformed to Base.OneTo(n) before being given to container.\n\nExamples\n\njulia> Containers.@container([i = 1:3, j = 1:3], i + j)\n3×3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> I = 1:3\n1:3\n\njulia> Containers.@container(x[i = I, j = I], i + j);\n\njulia> x\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, 1:3\nAnd data, a 3×3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.@container([i = 2:3, j = 1:3], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, Base.OneTo(3)\nAnd data, a 2×3 Array{Int64,2}:\n 3  4  5\n 4  5  6\n\njulia> Containers.@container([i = 1:3, j = 1:3; i <= j], i + j)\nJuMP.Containers.SparseAxisArray{Int64,2,Tuple{Int64,Int64}} with 6 entries:\n  [1, 2]  =  3\n  [2, 3]  =  5\n  [3, 3]  =  6\n  [2, 2]  =  4\n  [1, 1]  =  2\n  [1, 3]  =  4\n\n\n\n\n\n","category":"macro"},{"location":"reference/containers/#JuMP.Containers.VectorizedProductIterator","page":"Containers","title":"JuMP.Containers.VectorizedProductIterator","text":"struct VectorizedProductIterator{T}\n    prod::Iterators.ProductIterator{T}\nend\n\nA wrapper type for Iterators.ProuctIterator that discards shape information and returns a Vector.\n\nConstruct a VectorizedProductIterator using vectorized_product.\n\n\n\n\n\n","category":"type"},{"location":"reference/containers/#JuMP.Containers.vectorized_product","page":"Containers","title":"JuMP.Containers.vectorized_product","text":"vectorized_product(iterators...)\n\nCreated a VectorizedProductIterator.\n\nExamples\n\nvectorized_product(1:2, [\"A\", \"B\"])\n\n\n\n\n\n","category":"function"},{"location":"reference/containers/#JuMP.Containers.NestedIterator","page":"Containers","title":"JuMP.Containers.NestedIterator","text":"struct NestedIterator{T}\n    iterators::T # Tuple of functions\n    condition::Function\nend\n\nIterators over the tuples that are produced by a nested for loop.\n\nConstruct a NestedIterator using nested.\n\nExample\n\nIf length(iterators) == 3:\n\nx = NestedIterator(iterators, condition)\nfor (i1, i2, i3) in x\n    # produces (i1, i2, i3)\nend\n\nis the same as\n\nfor i1 in iterators[1]()\n    for i2 in iterator[2](i1)\n        for i3 in iterator[3](i1, i2)\n            if condition(i1, i2, i3)\n                # produces (i1, i2, i3)\n            end\n        end\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/containers/#JuMP.Containers.nested","page":"Containers","title":"JuMP.Containers.nested","text":"nested(iterators...; condition = (args...) -> true)\n\nCreate a NestedIterator.\n\nExample\n\nnested(1:2, [\"A\", \"B\"]; condition = (i, j) -> isodd(i) || j == \"B\")\n\n\n\n\n\n","category":"function"},{"location":"reference/containers/","page":"Containers","title":"Containers","text":"For advanced users, the following functions are provided to aid the writing of macros that use the container functionality.","category":"page"},{"location":"reference/containers/","page":"Containers","title":"Containers","text":"Containers.build_ref_sets\nContainers.container_code","category":"page"},{"location":"reference/containers/#JuMP.Containers.build_ref_sets","page":"Containers","title":"JuMP.Containers.build_ref_sets","text":"build_ref_sets(_error::Function, expr)\n\nHelper function for macros to construct container objects.\n\nwarning: Warning\nThis function is for advanced users implementing JuMP extensions. See container_code for more details.\n\nArguments\n\n_error: a function that takes a String and throws an error, potentially annotating the input string with extra information such as from which macro it was thrown from. Use error if you do not want a modified error message.\nexpr: an Expr that specifies the container, e.g., :(x[i = 1:3, [:red, :blue], k = S; i + k <= 6])\n\nReturns\n\nindex_vars: a Vector{Any} of names for the index variables, e.g., [:i, gensym(), :k]. These may also be expressions, like :((i, j)) from a call like :(x[(i, j) in S]).\nindices: an iterator over the indices, e.g.,\nContainers.NestedIterators(\n    (1:3, [:red, :blue], S),\n    (i, _, k) -> i + k <= 6,\n)\n\nExamples\n\nSee container_code for a worked example.\n\n\n\n\n\n","category":"function"},{"location":"reference/containers/#JuMP.Containers.container_code","page":"Containers","title":"JuMP.Containers.container_code","text":"container_code(\n    index_vars::Vector{Any},\n    indices::Expr,\n    code,\n    requested_container::Union{Symbol,Expr},\n)\n\nUsed in macros to construct a call to container. This should be used in conjunction with build_ref_sets.\n\nArguments\n\nindex_vars::Vector{Any}: a vector of names for the indices of the container. These may also be expressions, like :((i, j)) from a call like :(x[(i, j) in S]).\nindices::Expr: an expression that evaluates to an iterator of the indices.\ncode: an expression or literal constant for the value to be stored in the container as a function of the named index_vars.\nrequested_container: passed to the third argument of container. For built-in JuMP types, choose one of :Array, :DenseAxisArray, :SparseAxisArray, or :Auto. For a user-defined container, this expression must evaluate to the correct type.\n\nwarning: Warning\nIn most cases, you should esc(code) before passing it to container_code.\n\nExamples\n\njulia> macro foo(ref_sets, code)\n           index_vars, indices = Containers.build_ref_sets(error, ref_sets)\n           return Containers.container_code(\n               index_vars,\n               indices,\n               esc(code),\n               :Auto,\n            )\n       end\n@foo (macro with 1 method)\n\njulia> @foo(x[i=1:2, j=[\"A\", \"B\"]], j^i)\n2-dimensional DenseAxisArray{String,2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, [\"A\", \"B\"]\nAnd data, a 2×2 Matrix{String}:\n \"A\"   \"B\"\n \"AA\"  \"BB\"\n\n\n\n\n\n","category":"function"},{"location":"tutorials/linear/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/linear/prod.jl\"","category":"page"},{"location":"tutorials/linear/prod/#The-workforce-scheduling-problem","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"","category":"section"},{"location":"tutorials/linear/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"This model determines a set of workforce levels that will most economically meet demands and inventory requirements over time. The formulation is motivated by the experiences of a large producer in the United States. The data are for three products and 13 periods.","category":"page"},{"location":"tutorials/linear/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"Problem taken from the Appendix C of the expanded version of Fourer, Gay, and Kernighan, A Modeling Language for Mathematical Programming","category":"page"},{"location":"tutorials/linear/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"Originally contributed by Louis Luangkesorn, February 26, 2015.","category":"page"},{"location":"tutorials/linear/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_prod(; verbose = true)\n    # PRODUCTION SETS AND PARAMETERS\n    prd = [\"18REG\" \"24REG\" \"24PRO\"]\n    # Members of the product group\n    numprd = length(prd)\n    pt = [1.194, 1.509, 1.509]\n    # Crew-hours to produce 1000 units\n    pc = [2304, 2920, 2910]\n    # Nominal production cost per 1000, used\n    # to compute inventory and shortage costs\n    #\n    # TIME PERIOD SETS AND PARAMETERS\n    firstperiod = 1\n    # Index of first production period to be modeled\n    lastperiod = 13\n    # Index of last production period to be modeled\n    numperiods = firstperiod:lastperiod\n    # 'planning horizon' := first..last;\n    # EMPLOYMENT PARAMETERS\n    # Workers per crew\n    cs = 18\n    # Regular-time hours per shift\n    sl = 8\n    # Wage per hour for regular-time labor\n    rtr = 16.00\n    # Wage per hour for overtime labor\n    otr = 43.85\n    # Crews employed at start of first period\n    iw = 8\n    # Regular working days in a production period\n    dpp = [19.5, 19, 20, 19, 19.5, 19, 19, 20, 19, 20, 20, 18, 18]\n    # Maximum crew-hours of overtime in a period\n    ol = [96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96]\n    # Lower limit on average employment in a period\n    cmin = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    # Upper limit on average employment in a period\n    cmax = [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]\n    # Penalty cost of hiring a crew\n    hc = [\n        7500,\n        7500,\n        7500,\n        7500,\n        15000,\n        15000,\n        15000,\n        15000,\n        15000,\n        15000,\n        7500,\n        7500,\n        7500,\n    ]\n    # Penalty cost of laying off a crew\n    lc = [\n        7500,\n        7500,\n        7500,\n        7500,\n        15000,\n        15000,\n        15000,\n        15000,\n        15000,\n        15000,\n        7500,\n        7500,\n        7500,\n    ]\n    # DEMAND PARAMETERS\n    d18REG = [\n        63.8,\n        76,\n        88.4,\n        913.8,\n        115,\n        133.8,\n        79.6,\n        111,\n        121.6,\n        470,\n        78.4,\n        99.4,\n        140.4,\n        63.8,\n    ]\n    d24REG = [\n        1212,\n        306.2,\n        319,\n        208.4,\n        298,\n        328.2,\n        959.6,\n        257.6,\n        335.6,\n        118,\n        284.8,\n        970,\n        343.8,\n        1212,\n    ]\n    d24PRO = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1102, 0, 0, 0, 0]\n    # Requirements (in 1000s) to be met from current production and inventory\n    dem = Array[d18REG, d24REG, d24PRO]\n    # true if product will be the subject of a special promotion in the period\n    pro = Array[\n        [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n    ]\n    # INVENTORY AND SHORTAGE PARAMETERS\n    # Proportion of non-promoted demand that must be in inventory the previous\n    # period\n    rir = 0.75\n    # Proportion of promoted demand that must be in inventory the previous\n    # period\n    pir = 0.80\n    # Upper limit on number of periods that any product may sit in inventory\n    life = 2\n    # Inventory cost per 1000 units is cri times nominal production cost\n    cri = [0.015, 0.015, 0.015]\n    # Shortage cost per 1000 units is crs times nominal production cost\n    crs = [1.1, 1.1, 1.1]\n    # Inventory at start of first period; age unknown\n    iinv = [82, 792.2, 0]\n    # Initial inventory still available for allocation at end of period t\n    iil = [\n        [\n            max(0, iinv[p] - sum(dem[p][v] for v in firstperiod:t)) for\n            t in numperiods\n        ] for p in 1:numprd\n    ]\n    # Lower limit on inventory at end of period t\n    function checkpro(\n        product,\n        timeperiod,\n        production,\n        promotionalrate,\n        regularrate,\n    )\n        if production[product][timeperiod+1] == 1\n            return promotionalrate\n        else\n            return regularrate\n        end\n    end\n    minv = [\n        [dem[p][t+1] * checkpro(p, t, pro, pir, rir) for t in numperiods]\n        for p in 1:numprd\n    ]\n    # DEFINE MODEL\n    prod = Model(GLPK.Optimizer)\n    # VARIABLES\n    # Average number of crews employed in each period\n    @variable(prod, Crews[0:lastperiod] >= 0)\n    # Crews hired from previous to current period\n    @variable(prod, Hire[numperiods] >= 0)\n    # Crews laid off from previous to current period\n    @variable(prod, Layoff[numperiods] >= 0)\n    # Production using regular-time labor, in 1000s\n    @variable(prod, Rprd[1:numprd, numperiods] >= 0)\n    # Production using overtime labor, in 1000s\n    @variable(prod, Oprd[1:numprd, numperiods] >= 0)\n    # a numperiods old -- produced in period (t+1)-a --\n    # and still in storage at the end of period t\n    @variable(prod, Inv[1:numprd, numperiods, 1:life] >= 0)\n    # Accumulated unsatisfied demand at the end of period t\n    @variable(prod, Short[1:numprd, numperiods] >= 0)\n    # CONSTRAINTS\n    # Hours needed to accomplish all regular-time production in a period must\n    # not exceed hours available on all shifts\n    @constraint(\n        prod,\n        [t = numperiods],\n        sum(pt[p] * Rprd[p, t] for p in 1:numprd) <= sl * dpp[t] * Crews[t]\n    )\n    # Hours needed to accomplish all overtime production in a period must not\n    # exceed the specified overtime limit\n    @constraint(\n        prod,\n        [t = numperiods],\n        sum(pt[p] * Oprd[p, t] for p in 1:numprd) <= ol[t]\n    )\n    # Use given initial workforce\n    @constraint(prod, Crews[firstperiod-1] == iw)\n    # Workforce changes by hiring or layoffs\n    @constraint(\n        prod,\n        [t in numperiods],\n        Crews[t] == Crews[t-1] + Hire[t] - Layoff[t]\n    )\n    # Workforce must remain within specified bounds\n    @constraint(prod, [t in numperiods], cmin[t] <= Crews[t])\n    @constraint(prod, [t in numperiods], Crews[t] <= cmax[t])\n    # 'first demand requirement\n    @constraint(\n        prod,\n        [p in 1:numprd],\n        Rprd[p, firstperiod] + Oprd[p, firstperiod] + Short[p, firstperiod] -\n        Inv[p, firstperiod, 1] == max(0, dem[p][firstperiod] - iinv[p])\n    )\n    # Production plus increase in shortage plus decrease in inventory must\n    # equal demand\n    for t in (firstperiod+1):lastperiod\n        @constraint(\n            prod,\n            [p in 1:numprd],\n            Rprd[p, t] + Oprd[p, t] + Short[p, t] - Short[p, t-1] +\n            sum(Inv[p, t-1, a] - Inv[p, t, a] for a in 1:life) ==\n            max(0, dem[p][t] - iil[p][t-1])\n        )\n    end\n    # Inventory in storage at end of period t must meet specified minimum\n    @constraint(\n        prod,\n        [p in 1:numprd, t in numperiods],\n        sum(Inv[p, t, a] + iil[p][t] for a in 1:life) >= minv[p][t]\n    )\n    # In the vth period (starting from first) no inventory may be more than v\n    # numperiods old (initial inventories are handled separately)\n    @constraint(\n        prod,\n        [p in 1:numprd, v in 1:(life-1), a in (v+1):life],\n        Inv[p, firstperiod+v-1, a] == 0\n    )\n    # New inventory cannot exceed production in the most recent period\n    @constraint(\n        prod,\n        [p in 1:numprd, t in numperiods],\n        Inv[p, t, 1] <= Rprd[p, t] + Oprd[p, t]\n    )\n    # Inventory left from period (t+1)-p can only decrease as time goes on\n    secondperiod = firstperiod + 1\n    @constraint(\n        prod,\n        [p in 1:numprd, t in 2:lastperiod, a in 2:life],\n        Inv[p, t, a] <= Inv[p, t-1, a-1]\n    )\n    # OBJECTIVE\n    # Full regular wages for all crews employed, plus penalties for hiring and\n    # layoffs, plus wages for any overtime worked, plus inventory and shortage\n    # costs. (All other production costs are assumed to depend on initial\n    # inventory and on demands, and so are not included explicitly.)\n    @objective(\n        prod,\n        Min,\n        sum(\n            rtr * sl * dpp[t] * cs * Crews[t] +\n            hc[t] * Hire[t] +\n            lc[t] * Layoff[t] +\n            sum(\n                otr * cs * pt[p] * Oprd[p, t] +\n                sum(cri[p] * pc[p] * Inv[p, t, a] for a in 1:life) +\n                crs[p] * pc[p] * Short[p, t] for p in 1:numprd\n            ) for t in numperiods\n        )\n    )\n    # Obtain solution\n    optimize!(prod)\n    Test.@test termination_status(prod) == OPTIMAL\n    Test.@test primal_status(prod) == FEASIBLE_POINT\n    Test.@test objective_value(prod) ≈ 4_426_822.89 atol = 1e-2\n    if verbose\n        println(\"RESULTS:\")\n        println(\"Crews\")\n        for t in 0:length(Crews.data)-1\n            print(\" $(value(Crews[t])) \")\n        end\n        println()\n        println(\"Hire\")\n        for t in 1:length(Hire.data)\n            print(\" $(value(Hire[t])) \")\n        end\n        println()\n        println(\"Layoff\")\n        for t in 1:length(Layoff.data)\n            print(\" $(value(Layoff[t])) \")\n        end\n        println()\n    end\n    return\nend\n\nexample_prod()","category":"page"},{"location":"tutorials/linear/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"","category":"page"},{"location":"tutorials/linear/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/linear/cannery.jl\"","category":"page"},{"location":"tutorials/linear/cannery/#The-cannery-problem","page":"The cannery problem","title":"The cannery problem","text":"","category":"section"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Original author: Louis Luangkesorn, January 30, 2015.","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"This tutorial solves the cannery problem from Dantzig, Linear Programming and Extensions, Princeton University Press, Princeton, NJ, 1963. This class of problem is known as a transshipment problem.","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"The purpose of this tutorial is to demonstrate how to use JSON data in the formulation of a JuMP model.","category":"page"},{"location":"tutorials/linear/cannery/#Required-packages","page":"The cannery problem","title":"Required packages","text":"","category":"section"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"using JuMP\nimport GLPK\nimport JSON","category":"page"},{"location":"tutorials/linear/cannery/#Formulation","page":"The cannery problem","title":"Formulation","text":"","category":"section"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"The cannery problem assumes we are optimizing the shipment of cans from production plants p in P to markets m in M.","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Each production plant p has a capacity, c_p, and each market m has a demand d_m. The distance from plant to market is d_pm.","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"With a little effort, we can formulate our problem as the following linear program:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"beginaligned\nmin  sumlimits_p in Psumlimits_m in M d_pm x_pm \ntextst  sumlimits_m in M x_pm le c_p  forall p in P \n             sumlimits_p in P x_pm ge d_m  forall m in M \n             x_pm ge 0  forall p in P m in M\nendaligned","category":"page"},{"location":"tutorials/linear/cannery/#Data","page":"The cannery problem","title":"Data","text":"","category":"section"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"A key feature of the tutorial is to demonstrate how to load data from JSON.","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"For simplicity, we've hard-coded it below. But if the data was available as a .json file, we could use data = JSON.parsefile(filename) to read in the data.","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"data = JSON.parse(\"\"\"\n{\n    \"plants\": {\n        \"Seattle\": {\"capacity\": 350},\n        \"San-Diego\": {\"capacity\": 600}\n    },\n    \"markets\": {\n        \"New-York\": {\"demand\": 300},\n        \"Chicago\": {\"demand\": 300},\n        \"Topeka\": {\"demand\": 300}\n    },\n    \"distances\": {\n        \"Seattle => New-York\": 2.5,\n        \"Seattle => Chicago\": 1.7,\n        \"Seattle => Topeka\": 1.8,\n        \"San-Diego => New-York\": 2.5,\n        \"San-Diego => Chicago\": 1.8,\n        \"San-Diego => Topeka\": 1.4\n    }\n}\n\"\"\")","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Create the set of plants:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"P = keys(data[\"plants\"])","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Create the set of markets:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"M = keys(data[\"markets\"])","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"We also need a function to compute the distance from plant to market:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"distance(p::String, m::String) = data[\"distances\"][\"$(p) => $(m)\"]","category":"page"},{"location":"tutorials/linear/cannery/#JuMP-formulation","page":"The cannery problem","title":"JuMP formulation","text":"","category":"section"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Now we're ready to convert our mathematical formulation into a JuMP model.","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"First, create a new JuMP model. Since we have a linear program, we'll use GLPK as our optimizer:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"model = Model(GLPK.Optimizer)","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Our decision variables are indexed over the set of plants and markets:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"@variable(model, x[P, M] >= 0)","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"We need a constraint that each plant can ship no more than its capacity:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"@constraint(model, [p in P], sum(x[p, :]) <= data[\"plants\"][p][\"capacity\"])","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"and each market must receive at least its demand:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"@constraint(model, [m in M], sum(x[:, m]) >= data[\"markets\"][m][\"demand\"])","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Finally, our objective is to minimize the transportation distance:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"@objective(model, Min, sum(distance(p, m) * x[p, m] for p in P, m in M))","category":"page"},{"location":"tutorials/linear/cannery/#Solution","page":"The cannery problem","title":"Solution","text":"","category":"section"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"optimize!(model)\n\nsolution_summary(model)","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"What's the optimal shipment?","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"println(\"RESULTS:\")\nfor p in P, m in M\n    println(p, \" => \", m, \": \", value(x[p, m]))\nend","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"moi/reference/models/#Attribute-interface","page":"Models","title":"Attribute interface","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"is_set_by_optimize\nis_copyable\nget\nget!\nset\nsupports\nattribute_value_type","category":"page"},{"location":"moi/reference/models/#MathOptInterface.is_set_by_optimize","page":"Models","title":"MathOptInterface.is_set_by_optimize","text":"is_set_by_optimize(::AnyAttribute)\n\nReturn a Bool indicating whether the value of the attribute is modified during an optimize! call, that is, the attribute is used to query the result of the optimization.\n\nImportant note when defining new attributes\n\nThis function returns false by default so it should be implemented for attributes that are modified by optimize!.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.is_copyable","page":"Models","title":"MathOptInterface.is_copyable","text":"is_copyable(::AnyAttribute)\n\nReturn a Bool indicating whether the value of the attribute may be copied during copy_to using set.\n\nImportant note when defining new attributes\n\nBy default is_copyable(attr) returns !is_set_by_optimize(attr). A specific method should be defined for attributes which are copied indirectly during copy_to. For instance, both is_copyable and is_set_by_optimize return false for the following attributes:\n\nListOfOptimizerAttributesSet, ListOfModelAttributesSet, ListOfConstraintAttributesSet and ListOfVariableAttributesSet.\nSolverName and RawSolver: these attributes cannot be set.\nNumberOfVariables and ListOfVariableIndices: these attributes are set indirectly by add_variable and add_variables.\nObjectiveFunctionType: this attribute is set indirectly when setting the ObjectiveFunction attribute.\nNumberOfConstraints, ListOfConstraintIndices, ListOfConstraintTypesPresent, CanonicalConstraintFunction, ConstraintFunction and ConstraintSet: these attributes are set indirectly by add_constraint and add_constraints.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.get","page":"Models","title":"MathOptInterface.get","text":"get(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute)\n\nReturn an attribute attr of the optimizer optimizer.\n\nget(model::ModelLike, attr::AbstractModelAttribute)\n\nReturn an attribute attr of the model model.\n\nget(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex)\n\nIf the attribute attr is set for the variable v in the model model, return its value, return nothing otherwise. If the attribute attr is not supported by model then an error should be thrown instead of returning nothing.\n\nget(model::ModelLike, attr::AbstractVariableAttribute, v::Vector{VariableIndex})\n\nReturn a vector of attributes corresponding to each variable in the collection v in the model model.\n\nget(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex)\n\nIf the attribute attr is set for the constraint c in the model model, return its value, return nothing otherwise. If the attribute attr is not supported by model then an error should be thrown instead of returning nothing.\n\nget(model::ModelLike, attr::AbstractConstraintAttribute, c::Vector{ConstraintIndex{F,S}})\n\nReturn a vector of attributes corresponding to each constraint in the collection c in the model model.\n\nget(model::ModelLike, ::Type{VariableIndex}, name::String)\n\nIf a variable with name name exists in the model model, return the corresponding index, otherwise return nothing. Errors if two variables have the same name.\n\nget(model::ModelLike, ::Type{ConstraintIndex{F,S}}, name::String) where {F<:AbstractFunction,S<:AbstractSet}\n\nIf an F-in-S constraint with name name exists in the model model, return the corresponding index, otherwise return nothing. Errors if two constraints have the same name.\n\nget(model::ModelLike, ::Type{ConstraintIndex}, name::String)\n\nIf any constraint with name name exists in the model model, return the corresponding index, otherwise return nothing. This version is available for convenience but may incur a performance penalty because it is not type stable. Errors if two constraints have the same name.\n\nExamples\n\nget(model, ObjectiveValue())\nget(model, VariablePrimal(), ref)\nget(model, VariablePrimal(5), [ref1, ref2])\nget(model, OtherAttribute(\"something specific to cplex\"))\nget(model, VariableIndex, \"var1\")\nget(model, ConstraintIndex{ScalarAffineFunction{Float64},LessThan{Float64}}, \"con1\")\nget(model, ConstraintIndex, \"con1\")\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.get!","page":"Models","title":"MathOptInterface.get!","text":"get!(output, model::ModelLike, args...)\n\nAn in-place version of get.\n\nThe signature matches that of get except that the the result is placed in the vector output.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.set","page":"Models","title":"MathOptInterface.set","text":"set(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute, value)\n\nAssign value to the attribute attr of the optimizer optimizer.\n\nset(model::ModelLike, attr::AbstractModelAttribute, value)\n\nAssign value to the attribute attr of the model model.\n\nset(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex, value)\n\nAssign value to the attribute attr of variable v in model model.\n\nset(model::ModelLike, attr::AbstractVariableAttribute, v::Vector{VariableIndex}, vector_of_values)\n\nAssign a value respectively to the attribute attr of each variable in the collection v in model model.\n\nset(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex, value)\n\nAssign a value to the attribute attr of constraint c in model model.\n\nset(model::ModelLike, attr::AbstractConstraintAttribute, c::Vector{ConstraintIndex{F,S}}, vector_of_values)\n\nAssign a value respectively to the attribute attr of each constraint in the collection c in model model.\n\nAn UnsupportedAttribute error is thrown if model does not support the attribute attr (see supports) and a SetAttributeNotAllowed error is thrown if it supports the attribute attr but it cannot be set.\n\nReplace set in a constraint\n\nset(model::ModelLike, ::ConstraintSet, c::ConstraintIndex{F,S}, set::S)\n\nChange the set of constraint c to the new set set which should be of the same type as the original set.\n\nExamples\n\nIf c is a ConstraintIndex{F,Interval}\n\nset(model, ConstraintSet(), c, Interval(0, 5))\nset(model, ConstraintSet(), c, GreaterThan(0.0))  # Error\n\nReplace function in a constraint\n\nset(model::ModelLike, ::ConstraintFunction, c::ConstraintIndex{F,S}, func::F)\n\nReplace the function in constraint c with func. F must match the original function type used to define the constraint.\n\nNote\n\nSetting the constraint function is not allowed if F is VariableIndex, it throws a SettingVariableIndexNotAllowed error. Indeed, it would require changing the index c as the index of VariableIndex constraints should be the same as the index of the variable.\n\nExamples\n\nIf c is a ConstraintIndex{ScalarAffineFunction,S} and v1 and v2 are VariableIndex objects,\n\nset(model, ConstraintFunction(), c,\n    ScalarAffineFunction(ScalarAffineTerm.([1.0, 2.0], [v1, v2]), 5.0))\nset(model, ConstraintFunction(), c, v1) # Error\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.supports","page":"Models","title":"MathOptInterface.supports","text":"supports(model::ModelLike, sub::AbstractSubmittable)::Bool\n\nReturn a Bool indicating whether model supports the submittable sub.\n\nsupports(model::ModelLike, attr::AbstractOptimizerAttribute)::Bool\n\nReturn a Bool indicating whether model supports the optimizer attribute attr. That is, it returns false if copy_to(model, src) shows a warning in case attr is in the ListOfOptimizerAttributesSet of src; see copy_to for more details on how unsupported optimizer attributes are handled in copy.\n\nsupports(model::ModelLike, attr::AbstractModelAttribute)::Bool\n\nReturn a Bool indicating whether model supports the model attribute attr. That is, it returns false if copy_to(model, src) cannot be performed in case attr is in the ListOfModelAttributesSet of src.\n\nsupports(model::ModelLike, attr::AbstractVariableAttribute, ::Type{VariableIndex})::Bool\n\nReturn a Bool indicating whether model supports the variable attribute attr. That is, it returns false if copy_to(model, src) cannot be performed in case attr is in the ListOfVariableAttributesSet of src.\n\nsupports(model::ModelLike, attr::AbstractConstraintAttribute, ::Type{ConstraintIndex{F,S}})::Bool where {F,S}\n\nReturn a Bool indicating whether model supports the constraint attribute attr applied to an F-in-S constraint. That is, it returns false if copy_to(model, src) cannot be performed in case attr is in the ListOfConstraintAttributesSet of src.\n\nFor all five methods, if the attribute is only not supported in specific circumstances, it should still return true.\n\nNote that supports is only defined for attributes for which is_copyable returns true as other attributes do not appear in the list of attributes set obtained by ListOf...AttributesSet.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.attribute_value_type","page":"Models","title":"MathOptInterface.attribute_value_type","text":"attribute_value_type(attr::AnyAttribute)\n\nGiven an attribute attr, return the type of value expected by get, or returned by set.\n\nNotes\n\nOnly implement this if it make sense to do so. If un-implemented, the default is Any.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#Model-interface","page":"Models","title":"Model interface","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"ModelLike\nis_empty\nempty!\nwrite_to_file\nread_from_file\nsupports_incremental_interface\ncopy_to\nIndexMap","category":"page"},{"location":"moi/reference/models/#MathOptInterface.ModelLike","page":"Models","title":"MathOptInterface.ModelLike","text":"ModelLike\n\nAbstract supertype for objects that implement the \"Model\" interface for defining an optimization problem.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.is_empty","page":"Models","title":"MathOptInterface.is_empty","text":"is_empty(model::ModelLike)\n\nReturns false if the model has any model attribute set or has any variables or constraints.\n\nNote that an empty model can have optimizer attributes set.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.empty!","page":"Models","title":"MathOptInterface.empty!","text":"empty!(model::ModelLike)\n\nEmpty the model, that is, remove all variables, constraints and model attributes but not optimizer attributes.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.write_to_file","page":"Models","title":"MathOptInterface.write_to_file","text":"write_to_file(model::ModelLike, filename::String)\n\nWrites the current model data to the given file. Supported file types depend on the model type.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.read_from_file","page":"Models","title":"MathOptInterface.read_from_file","text":"read_from_file(model::ModelLike, filename::String)\n\nRead the file filename into the model model. If model is non-empty, this may throw an error.\n\nSupported file types depend on the model type.\n\nNote\n\nOnce the contents of the file are loaded into the model, users can query the variables via get(model, ListOfVariableIndices()). However, some filetypes, such as LP files, do not maintain an explicit ordering of the variables. Therefore, the returned list may be in an arbitrary order. To avoid depending on the order of the indices, users should look up each variable index by name: get(model, VariableIndex, \"name\").\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.supports_incremental_interface","page":"Models","title":"MathOptInterface.supports_incremental_interface","text":"supports_incremental_interface(model::ModelLike)\n\nReturn a Bool indicating whether model supports building incrementally via add_variable and add_constraint.\n\nThe main purpose of this function is to determine whether a model can be loaded into model incrementally or whether it should be cached and copied at once instead.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.copy_to","page":"Models","title":"MathOptInterface.copy_to","text":"copy_to(dest::ModelLike, src::ModelLike)::IndexMap\n\nCopy the model from src into dest.\n\nThe target dest is emptied, and all previous indices to variables and constraints in dest are invalidated.\n\nReturns an IndexMap object that translates variable and constraint indices from the src model to the corresponding indices in the dest model.\n\nNotes\n\nIf a constraint that in src is not supported by dest, then an UnsupportedConstraint error is thrown.\nIf an AbstractModelAttribute, AbstractVariableAttribute, or AbstractConstraintAttribute is set in src but not supported by dest, then an UnsupportedAttribute error is thrown.\n\nAbstractOptimizerAttributes are not copied  to the dest model.\n\nIndexMap\n\nImplementations of copy_to must return an IndexMap. For technical reasons, this type is defined in the Utilities submodule as MOI.Utilities.IndexMap. However, since it is an integral part of the MOI API, we provide MOI.IndexMap as an alias.\n\nExample\n\n# Given empty `ModelLike` objects `src` and `dest`.\n\nx = add_variable(src)\n\nis_valid(src, x)   # true\nis_valid(dest, x)  # false (`dest` has no variables)\n\nindex_map = copy_to(dest, src)\nis_valid(dest, x) # false (unless index_map[x] == x)\nis_valid(dest, index_map[x]) # true\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.IndexMap","page":"Models","title":"MathOptInterface.IndexMap","text":"IndexMap()\n\nThe dictionary-like object returned by copy_to.\n\nIndexMap\n\nImplementations of copy_to must return an IndexMap. For technical reasons, the IndexMap type is defined in the Utilties submodule as MOI.Utilities.IndexMap. However, since it is an integral part of the MOI API, we provide this MOI.IndexMap as an alias.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#Model-attributes","page":"Models","title":"Model attributes","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"AbstractModelAttribute\nName\nObjectiveFunction\nObjectiveFunctionType\nObjectiveSense\nNumberOfVariables\nListOfVariableIndices\nListOfConstraintTypesPresent\nNumberOfConstraints\nListOfConstraintIndices\nListOfOptimizerAttributesSet\nListOfModelAttributesSet\nListOfVariableAttributesSet\nListOfConstraintAttributesSet","category":"page"},{"location":"moi/reference/models/#MathOptInterface.AbstractModelAttribute","page":"Models","title":"MathOptInterface.AbstractModelAttribute","text":"AbstractModelAttribute\n\nAbstract supertype for attribute objects that can be used to set or get attributes (properties) of the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.Name","page":"Models","title":"MathOptInterface.Name","text":"Name()\n\nA model attribute for the string identifying the model. It has a default value of \"\" if not set`.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ObjectiveFunction","page":"Models","title":"MathOptInterface.ObjectiveFunction","text":"ObjectiveFunction{F<:AbstractScalarFunction}()\n\nA model attribute for the objective function which has a type F<:AbstractScalarFunction. F should be guaranteed to be equivalent but not necessarily identical to the function type provided by the user. Throws an InexactError if the objective function cannot be converted to F, e.g. the objective function is quadratic and F is ScalarAffineFunction{Float64} or it has non-integer coefficient and F is ScalarAffineFunction{Int}.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ObjectiveFunctionType","page":"Models","title":"MathOptInterface.ObjectiveFunctionType","text":"ObjectiveFunctionType()\n\nA model attribute for the type F of the objective function set using the ObjectiveFunction{F} attribute.\n\nExamples\n\nIn the following code, attr should be equal to MOI.VariableIndex:\n\nx = MOI.add_variable(model)\nMOI.set(model, MOI.ObjectiveFunction{MOI.VariableIndex}(),\n         x)\nattr = MOI.get(model, MOI.ObjectiveFunctionType())\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ObjectiveSense","page":"Models","title":"MathOptInterface.ObjectiveSense","text":"ObjectiveSense()\n\nA model attribute for the objective sense of the objective function, which must be an OptimizationSense: MIN_SENSE, MAX_SENSE, or FEASIBILITY_SENSE. The default is FEASIBILITY_SENSE.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.NumberOfVariables","page":"Models","title":"MathOptInterface.NumberOfVariables","text":"NumberOfVariables()\n\nA model attribute for the number of variables in the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfVariableIndices","page":"Models","title":"MathOptInterface.ListOfVariableIndices","text":"ListOfVariableIndices()\n\nA model attribute for the Vector{VariableIndex} of all variable indices present in the model (i.e., of length equal to the value of NumberOfVariables()) in the order in which they were added.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfConstraintTypesPresent","page":"Models","title":"MathOptInterface.ListOfConstraintTypesPresent","text":"ListOfConstraintTypesPresent()\n\nA model attribute for the list of tuples of the form (F,S), where F is a function type and S is a set type indicating that the attribute NumberOfConstraints{F,S}() has value greater than zero.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.NumberOfConstraints","page":"Models","title":"MathOptInterface.NumberOfConstraints","text":"NumberOfConstraints{F,S}()\n\nA model attribute for the number of constraints of the type F-in-S present in the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfConstraintIndices","page":"Models","title":"MathOptInterface.ListOfConstraintIndices","text":"ListOfConstraintIndices{F,S}()\n\nA model attribute for the Vector{ConstraintIndex{F,S}} of all constraint indices of type F-in-S in the model (i.e., of length equal to the value of NumberOfConstraints{F,S}()) in the order in which they were added.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfOptimizerAttributesSet","page":"Models","title":"MathOptInterface.ListOfOptimizerAttributesSet","text":"ListOfOptimizerAttributesSet()\n\nAn optimizer attribute for the Vector{AbstractOptimizerAttribute} of all optimizer attributes that were set.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfModelAttributesSet","page":"Models","title":"MathOptInterface.ListOfModelAttributesSet","text":"ListOfModelAttributesSet()\n\nA model attribute for the Vector{AbstractModelAttribute} of all model attributes attr such that 1) is_copyable(attr) returns true and 2) the attribute was set to the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfVariableAttributesSet","page":"Models","title":"MathOptInterface.ListOfVariableAttributesSet","text":"ListOfVariableAttributesSet()\n\nA model attribute for the Vector{AbstractVariableAttribute} of all variable attributes attr such that 1) is_copyable(attr) returns true and 2) the attribute was set to variables.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfConstraintAttributesSet","page":"Models","title":"MathOptInterface.ListOfConstraintAttributesSet","text":"ListOfConstraintAttributesSet{F, S}()\n\nA model attribute for the Vector{AbstractConstraintAttribute} of all constraint attributes attr such that 1) is_copyable(attr) returns true and\n\nthe attribute was set to F-in-S constraints.\n\nNote\n\nThe attributes ConstraintFunction and ConstraintSet should not be included in the list even if then have been set with set.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#Optimizer-interface","page":"Models","title":"Optimizer interface","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"AbstractOptimizer\nOptimizerWithAttributes\noptimize!\ninstantiate","category":"page"},{"location":"moi/reference/models/#MathOptInterface.AbstractOptimizer","page":"Models","title":"MathOptInterface.AbstractOptimizer","text":"AbstractOptimizer <: ModelLike\n\nAbstract supertype for objects representing an instance of an optimization problem tied to a particular solver. This is typically a solver's in-memory representation. In addition to ModelLike, AbstractOptimizer objects let you solve the model and query the solution.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.OptimizerWithAttributes","page":"Models","title":"MathOptInterface.OptimizerWithAttributes","text":"struct OptimizerWithAttributes\n    optimizer_constructor\n    params::Vector{Pair{AbstractOptimizerAttribute,<:Any}}\nend\n\nObject grouping an optimizer constructor and a list of optimizer attributes. Instances are created with instantiate.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.optimize!","page":"Models","title":"MathOptInterface.optimize!","text":"optimize!(optimizer::AbstractOptimizer)\n\nOptimize the problem contained in optimizer.\n\nBefore calling optimize!, the problem should first be constructed using the incremental interface (see supports_incremental_interface) or copy_to.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.instantiate","page":"Models","title":"MathOptInterface.instantiate","text":"instantiate(\n    optimizer_constructor,\n    with_bridge_type::Union{Nothing, Type} = nothing,\n)\n\nCreates an instance of optimizer by either:\n\ncalling optimizer_constructor.optimizer_constructor() and setting the parameters in optimizer_constructor.params if optimizer_constructor is a OptimizerWithAttributes\ncalling optimizer_constructor() if optimizer_constructor is callable.\n\nIf with_bridge_type is not nothing, it enables all the bridges defined in the MathOptInterface.Bridges submodule with coefficient type with_bridge_type.\n\nIf the optimizer created by optimizer_constructor does not support loading the problem incrementally (see supports_incremental_interface), then a Utilities.CachingOptimizer is added to store a cache of the bridged model.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#Optimizer-attributes","page":"Models","title":"Optimizer attributes","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"AbstractOptimizerAttribute\nSolverName\nSolverVersion\nSilent\nTimeLimitSec\nRawOptimizerAttribute\nNumberOfThreads\nRawSolver","category":"page"},{"location":"moi/reference/models/#MathOptInterface.AbstractOptimizerAttribute","page":"Models","title":"MathOptInterface.AbstractOptimizerAttribute","text":"AbstractOptimizerAttribute\n\nAbstract supertype for attribute objects that can be used to set or get attributes (properties) of the optimizer.\n\nNote\n\nThe difference between AbstractOptimizerAttribute and AbstractModelAttribute lies in the behavior of is_empty, empty! and copy_to. Typically optimizer attributes only affect how the model is solved.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.SolverName","page":"Models","title":"MathOptInterface.SolverName","text":"SolverName()\n\nAn optimizer attribute for the string identifying the solver/optimizer.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.SolverVersion","page":"Models","title":"MathOptInterface.SolverVersion","text":"SolverVersion()\n\nAn optimizer attribute for the string identifying the version of the solver.\n\nnote: Note\nFor solvers supporting semantic versioning, the SolverVersion should be a string of the form \"vMAJOR.MINOR.PATCH\", so that it can be converted to a Julia VersionNumber (e.g., `VersionNumber(\"v1.2.3\")).We do not require Semantic Versioning because some solvers use alternate versioning systems. For example, CPLEX uses Calendar Versioning, so SolverVersion will return a string like \"202001\".\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.Silent","page":"Models","title":"MathOptInterface.Silent","text":"Silent()\n\nAn optimizer attribute for silencing the output of an optimizer. When set to true, it takes precedence over any other attribute controlling verbosity and requires the solver to produce no output. The default value is false which has no effect. In this case the verbosity is controlled by other attributes.\n\nNote\n\nEvery optimizer should have verbosity on by default. For instance, if a solver has a solver-specific log level attribute, the MOI implementation should set it to 1 by default. If the user sets Silent to true, then the log level should be set to 0, even if the user specifically sets a value of log level. If the value of Silent is false then the log level set to the solver is the value given by the user for this solver-specific parameter or 1 if none is given.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.TimeLimitSec","page":"Models","title":"MathOptInterface.TimeLimitSec","text":"TimeLimitSec()\n\nAn optimizer attribute for setting a time limit for an optimization. When set to nothing, it deactivates the solver time limit. The default value is nothing. The time limit is in seconds.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.RawOptimizerAttribute","page":"Models","title":"MathOptInterface.RawOptimizerAttribute","text":"RawOptimizerAttribute(name::String)\n\nAn optimizer attribute for the solver-specific parameter identified by name.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.NumberOfThreads","page":"Models","title":"MathOptInterface.NumberOfThreads","text":"NumberOfThreads()\n\nAn optimizer attribute for setting the number of threads used for an optimization. When set to nothing uses solver default. Values are positive integers. The default value is nothing.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.RawSolver","page":"Models","title":"MathOptInterface.RawSolver","text":"RawSolver()\n\nA model attribute for the object that may be used to access a solver-specific API for this optimizer.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"List of attributes useful for optimizers","category":"page"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"TerminationStatus\nTerminationStatusCode\nPrimalStatus\nDualStatus\nResultStatusCode\nRawStatusString\nResultCount\nObjectiveValue\nDualObjectiveValue\nObjectiveBound\nRelativeGap\nSolveTimeSec\nSimplexIterations\nBarrierIterations\nNodeCount","category":"page"},{"location":"moi/reference/models/#MathOptInterface.TerminationStatus","page":"Models","title":"MathOptInterface.TerminationStatus","text":"TerminationStatus()\n\nA model attribute for the TerminationStatusCode explaining why the optimizer stopped.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.TerminationStatusCode","page":"Models","title":"MathOptInterface.TerminationStatusCode","text":"TerminationStatusCode\n\nAn Enum of possible values for the TerminationStatus attribute. This attribute is meant to explain the reason why the optimizer stopped executing in the most recent call to optimize!.\n\nIf no call has been made to optimize!, then the TerminationStatus is:\n\nOPTIMIZE_NOT_CALLED: The algorithm has not started.\n\nOK\n\nThese are generally OK statuses, i.e., the algorithm ran to completion normally.\n\nOPTIMAL: The algorithm found a globally optimal solution.\nINFEASIBLE: The algorithm concluded that no feasible solution exists.\nDUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem. If, additionally, a feasible (primal) solution is known to exist, this status typically implies that the problem is unbounded, with some technical exceptions.\nLOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.\nLOCALLY_INFEASIBLE: The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.\nINFEASIBLE_OR_UNBOUNDED: The algorithm stopped because it decided that the problem is infeasible or unbounded; this occasionally happens during MIP presolve.\n\nSolved to relaxed tolerances\n\nALMOST_OPTIMAL: The algorithm found a globally optimal solution to relaxed tolerances.\nALMOST_INFEASIBLE: The algorithm concluded that no feasible solution exists within relaxed tolerances.\nALMOST_DUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.\nALMOST_LOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.\n\nLimits\n\nThe optimizer stopped because of some user-defined limit.\n\nITERATION_LIMIT: An iterative algorithm stopped after conducting the maximum number of iterations.\nTIME_LIMIT: The algorithm stopped after a user-specified computation time.\nNODE_LIMIT: A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.\nSOLUTION_LIMIT: The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.\nMEMORY_LIMIT: The algorithm stopped because it ran out of memory.\nOBJECTIVE_LIMIT: The algorithm stopped because it found a solution better than a minimum limit set by the user.\nNORM_LIMIT: The algorithm stopped because the norm of an iterate became too large.\nOTHER_LIMIT: The algorithm stopped due to a limit not covered by one of the above.\n\nProblematic\n\nThis group of statuses means that something unexpected or problematic happened.\n\nSLOW_PROGRESS: The algorithm stopped because it was unable to continue making progress towards the solution.\nNUMERICAL_ERROR: The algorithm stopped because it encountered unrecoverable numerical error.\nINVALID_MODEL: The algorithm stopped because the model is invalid.\nINVALID_OPTION: The algorithm stopped because it was provided an invalid option.\nINTERRUPTED: The algorithm stopped because of an interrupt signal.\nOTHER_ERROR: The algorithm stopped because of an error not covered by one of the statuses defined above.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.PrimalStatus","page":"Models","title":"MathOptInterface.PrimalStatus","text":"PrimalStatus(result_index::Int = 1)\n\nA model attribute for the ResultStatusCode of the primal result result_index. If result_index is omitted, it defaults to 1.\n\nSee ResultCount for information on how the results are ordered.\n\nIf result_index is larger than the value of ResultCount then NO_SOLUTION is returned.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.DualStatus","page":"Models","title":"MathOptInterface.DualStatus","text":"DualStatus(result_index::Int = 1)\n\nA model attribute for the ResultStatusCode of the dual result result_index. If result_index is omitted, it defaults to 1.\n\nSee ResultCount for information on how the results are ordered.\n\nIf result_index is larger than the value of ResultCount then NO_SOLUTION is returned.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ResultStatusCode","page":"Models","title":"MathOptInterface.ResultStatusCode","text":"ResultStatusCode\n\nAn Enum of possible values for the PrimalStatus and DualStatus attributes. The values indicate how to interpret the result vector.\n\nNO_SOLUTION: the result vector is empty.\nFEASIBLE_POINT: the result vector is a feasible point.\nNEARLY_FEASIBLE_POINT: the result vector is feasible if some constraint tolerances are relaxed.\nINFEASIBLE_POINT: the result vector is an infeasible point.\nINFEASIBILITY_CERTIFICATE: the result vector is an infeasibility certificate. If the PrimalStatus is INFEASIBILITY_CERTIFICATE, then the primal result vector is a certificate of dual infeasibility. If the DualStatus is INFEASIBILITY_CERTIFICATE, then the dual result vector is a proof of primal infeasibility.\nNEARLY_INFEASIBILITY_CERTIFICATE: the result satisfies a relaxed criterion for a certificate of infeasibility.\nREDUCTION_CERTIFICATE: the result vector is an ill-posed certificate; see this article for details. If the PrimalStatus is REDUCTION_CERTIFICATE, then the primal result vector is a proof that the dual problem is ill-posed. If the DualStatus is REDUCTION_CERTIFICATE, then the dual result vector is a proof that the primal is ill-posed.\nNEARLY_REDUCTION_CERTIFICATE: the result satisfies a relaxed criterion for an ill-posed certificate.\nUNKNOWN_RESULT_STATUS: the result vector contains a solution with an unknown interpretation.\nOTHER_RESULT_STATUS: the result vector contains a solution with an interpretation not covered by one of the statuses defined above.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.RawStatusString","page":"Models","title":"MathOptInterface.RawStatusString","text":"RawStatusString()\n\nA model attribute for a solver specific string explaining why the optimizer stopped.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ResultCount","page":"Models","title":"MathOptInterface.ResultCount","text":"ResultCount()\n\nA model attribute for the number of results available.\n\nOrder of solutions\n\nA number of attributes contain an index, result_index, which is used to refer to one of the available results. Thus, result_index must be an integer between 1 and the number of available results.\n\nAs a general rule, the first result (result_index=1) is the most important result (e.g., an optimal solution or an infeasibility certificate). Other results will typically be alternate solutions that the solver found during the search for the first result.\n\nIf a (local) optimal solution is available, i.e., TerminationStatus is OPTIMAL or LOCALLY_SOLVED, the first result must correspond to the (locally) optimal solution. Other results may be alternative optimal solutions, or they may be other suboptimal solutions; use ObjectiveValue to distingiush between them.\n\nIf a primal or dual infeasibility certificate is available, i.e., TerminationStatus is INFEASIBLE or DUAL_INFEASIBLE and the corresponding PrimalStatus or DualStatus is INFEASIBILITY_CERTIFICATE, then the first result must be a certificate. Other results may be alternate certificates, or infeasible points.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ObjectiveValue","page":"Models","title":"MathOptInterface.ObjectiveValue","text":"ObjectiveValue(result_index::Int = 1)\n\nA model attribute for the objective value of the primal solution result_index.\n\nIf the solver does not have a primal value for the objective because the result_index is beyond the available solutions (whose number is indicated by the ResultCount attribute), getting this attribute must throw a ResultIndexBoundsError. Otherwise, if the result is unavailable for another reason (for instance, only a dual solution is available), the result is undefined. Users should first check PrimalStatus before accessing the ObjectiveValue attribute.\n\nSee ResultCount for information on how the results are ordered.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.DualObjectiveValue","page":"Models","title":"MathOptInterface.DualObjectiveValue","text":"DualObjectiveValue(result_index::Int = 1)\n\nA model attribute for the value of the objective function of the dual problem for the result_indexth dual result.\n\nIf the solver does not have a dual value for the objective because the result_index is beyond the available solutions (whose number is indicated by the ResultCount attribute), getting this attribute must throw a ResultIndexBoundsError. Otherwise, if the result is unavailable for another reason (for instance, only a primal solution is available), the result is undefined. Users should first check DualStatus before accessing the DualObjectiveValue attribute.\n\nSee ResultCount for information on how the results are ordered.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ObjectiveBound","page":"Models","title":"MathOptInterface.ObjectiveBound","text":"ObjectiveBound()\n\nA model attribute for the best known bound on the optimal objective value.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.RelativeGap","page":"Models","title":"MathOptInterface.RelativeGap","text":"RelativeGap()\n\nA model attribute for the final relative optimality gap.\n\nwarning: Warning\nThe definition of this gap is solver-dependent. However, most solvers implementing this attribute define the relative gap as some variation of fracb-ff, where b is the best bound and f is the best feasible objective value.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.SolveTimeSec","page":"Models","title":"MathOptInterface.SolveTimeSec","text":"SolveTimeSec()\n\nA model attribute for the total elapsed solution time (in seconds) as reported by the optimizer.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.SimplexIterations","page":"Models","title":"MathOptInterface.SimplexIterations","text":"SimplexIterations()\n\nA model attribute for the cumulative number of simplex iterations during the optimization process. In particular, for a mixed-integer program (MIP), the total simplex iterations for all nodes.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.BarrierIterations","page":"Models","title":"MathOptInterface.BarrierIterations","text":"BarrierIterations()\n\nA model attribute for the cumulative number of barrier iterations while solving a problem.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.NodeCount","page":"Models","title":"MathOptInterface.NodeCount","text":"NodeCount()\n\nA model attribute for the total number of branch-and-bound nodes explored while solving a mixed-integer program (MIP).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#Conflict-Status","page":"Models","title":"Conflict Status","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"compute_conflict!\nConflictStatus\nConflictStatusCode\nConstraintConflictStatus\nConflictParticipationStatusCode","category":"page"},{"location":"moi/reference/models/#MathOptInterface.compute_conflict!","page":"Models","title":"MathOptInterface.compute_conflict!","text":"compute_conflict!(optimizer::AbstractOptimizer)\n\nComputes a minimal subset of constraints such that the model with the other constraint removed is still infeasible.\n\nSome solvers call a set of conflicting constraints an Irreducible Inconsistent Subsystem (IIS).\n\nSee also ConflictStatus and ConstraintConflictStatus.\n\nNote\n\nIf the model is modified after a call to compute_conflict!, the implementor is not obliged to purge the conflict. Any calls to the above attributes may return values for the original conflict without a warning. Similarly, when modifying the model, the conflict can be discarded.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.ConflictStatus","page":"Models","title":"MathOptInterface.ConflictStatus","text":"ConflictStatus()\n\nA model attribute for the ConflictStatusCode explaining why the conflict refiner stopped when computing the conflict.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ConflictStatusCode","page":"Models","title":"MathOptInterface.ConflictStatusCode","text":"ConflictStatusCode\n\nAn Enum of possible values for the ConflictStatus attribute. This attribute is meant to explain the reason why the conflict finder stopped executing in the most recent call to compute_conflict!.\n\nPossible values are:\n\nCOMPUTE_CONFLICT_NOT_CALLED: the function compute_conflict! has not yet been called\nNO_CONFLICT_EXISTS: there is no conflict because the problem is feasible\nNO_CONFLICT_FOUND: the solver could not find a conflict\nCONFLICT_FOUND: at least one conflict could be found\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ConstraintConflictStatus","page":"Models","title":"MathOptInterface.ConstraintConflictStatus","text":"ConstraintConflictStatus()\n\nA constraint attribute indicating whether the constraint participates in the conflict. Its type is ConflictParticipationStatusCode.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ConflictParticipationStatusCode","page":"Models","title":"MathOptInterface.ConflictParticipationStatusCode","text":"ConflictParticipationStatusCode\n\nAn Enum of possible values for the ConstraintConflictStatus attribute. This attribute is meant to indicate whether a given constraint participates or not in the last computed conflict.\n\nPossible values are:\n\nNOT_IN_CONFLICT: the constraint does not participate in the conflict\nIN_CONFLICT: the constraint participates in the conflict\nMAYBE_IN_CONFLICT: the constraint may participate in the conflict, the solver was not able to prove that the constraint can be excluded from the conflict\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Utilities/overview/#The-Utilities-submodule","page":"Overview","title":"The Utilities submodule","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The Utilities submodule provides a variety of functionality for managing MOI.ModelLike objects.","category":"page"},{"location":"moi/submodules/Utilities/overview/#Utilities.Model","page":"Overview","title":"Utilities.Model","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Utilities.Model provides an implementation of a ModelLike that efficiently supports all functions and sets defined within MOI. However, given the extensibility of MOI, this might not cover all use cases.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Create a model as follows:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}","category":"page"},{"location":"moi/submodules/Utilities/overview/#Utilities.UniversalFallback","page":"Overview","title":"Utilities.UniversalFallback","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Utilities.UniversalFallback is a layer that sits on top of any ModelLike and provides non-specialized (slower) fallbacks for constraints and attributes that the underlying ModelLike does not support.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"For example, Utilities.Model doesn't support some variable attributes like VariablePrimalStart, so JuMP uses a combination of Universal fallback and Utilities.Model as a generic problem cache:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.Utilities.UniversalFallback(MOI.Utilities.Model{Float64}())\nMOIU.UniversalFallback{MOIU.Model{Float64}}\nfallback for MOIU.Model{Float64}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"warning: Warning\nAdding a UniversalFallback means that your model will now support all constraints, even if the inner-model does not! This can lead to unexpected behavior.","category":"page"},{"location":"moi/submodules/Utilities/overview/#Utilities.@model","page":"Overview","title":"Utilities.@model","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"For advanced use cases that need efficient support for functions and sets defined outside of MOI (but still known at compile time), we provide the Utilities.@model macro.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The @model macro takes a name (for a new type, which must not exist yet), eight tuples specifying the types of constraints that are supported, and then a Bool indicating the type is a subtype of MOI.AbstractOptimizer (if true) or MOI.ModelLike (if false).","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The eight tuples are in the following order:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Un-typed scalar sets, e.g., Integer\nTyped scalar sets, e.g., LessThan\nUn-typed vector sets, e.g., Nonnegatives\nTyped vector sets, e.g., PowerCone\nUn-typed scalar functions, e.g., VariableIndex\nTyped scalar functions, e.g., ScalarAffineFunction\nUn-typed vector functions, e.g., VectorOfVariables\nTyped vector functions, e.g., VectorAffineFunction","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The tuples can contain more than one element. Typed-sets must be specified without their type parameter, i.e., MOI.LessThan, not MOI.LessThan{Float64}.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Here is an example:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.@model(\n           MyNewModel,\n           (MOI.Integer,),                  # Un-typed scalar sets\n           (MOI.GreaterThan,),              # Typed scalar sets\n           (MOI.Nonnegatives,),             # Un-typed vector sets\n           (MOI.PowerCone,),                # Typed vector sets\n           (MOI.VariableIndex,),            # Un-typed scalar functions\n           (MOI.ScalarAffineFunction,),     # Typed scalar functions\n           (MOI.VectorOfVariables,),        # Un-typed vector functions\n           (MOI.VectorAffineFunction,),     # Typed vector functions\n           true,                            # <:MOI.AbstractOptimizer?\n       )\nMathOptInterface.Utilities.GenericOptimizer{T, MathOptInterface.Utilities.ObjectiveContainer{T}, MathOptInterface.Utilities.VariablesContainer{T}, MyNewModelFunctionConstraints{T}} where T\n\njulia> model = MyNewModel{Float64}()\nMOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MyNewModelFunctionConstraints{Float64}}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"warning: Warning\nMyNewModel supports every VariableIndex-in-Set constraint, as well as VariableIndex, ScalarAffineFunction, and ScalarQuadraticFunction objective functions. Implement MOI.supports as needed to forbid constraint and objective function combinations.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"As another example, PATHSolver, which only supports VectorAffineFunction-in-Complements defines its optimizer as:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.@model(\n           PathOptimizer,\n           (),  # Scalar sets\n           (),  # Typed scalar sets\n           (MOI.Complements,),  # Vector sets\n           (),  # Typed vector sets\n           (),  # Scalar functions\n           (),  # Typed scalar functions\n           (),  # Vector functions\n           (MOI.VectorAffineFunction,),  # Typed vector functions\n           true,  # is_optimizer\n       )\nMathOptInterface.Utilities.GenericOptimizer{T, MathOptInterface.Utilities.ObjectiveContainer{T}, MathOptInterface.Utilities.VariablesContainer{T}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{T}, MathOptInterface.Complements}} where T","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"However, PathOptimizer does not support some VariableIndex-in-Set constraints, so we must explicitly define:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> function MOI.supports_constraint(\n           ::PathOptimizer,\n           ::Type{MOI.VariableIndex},\n           ::Type{Union{<:MOI.Semiinteger,MOI.Semicontinuous,MOI.ZeroOne,MOI.Integer}}\n       )\n           return false\n       end","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Finally, PATH doesn't support an objective function, so we need to add:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.supports(::PathOptimizer, ::MOI.ObjectiveFunction) = false","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"warning: Warning\nThis macro creates a new type, so it must be called from the top-level of a module, e.g., it cannot be called from inside a function.","category":"page"},{"location":"moi/submodules/Utilities/overview/#Utilities.CachingOptimizer","page":"Overview","title":"Utilities.CachingOptimizer","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"A [Utilities.CachingOptimizer] is an MOI layer that abstracts the difference between solvers that support incremental modification (e.g., they support adding variables one-by-one), and solvers that require the entire problem in a single API call (e.g., they only accept the A, b and c matrices of a linear program).","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"It has two parts:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"A cache, where the model can be built and modified incrementally\nAn optimizer, which is used to solve the problem","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.Utilities.CachingOptimizer(\n           MOI.Utilities.Model{Float64}(),\n           PathOptimizer{Float64}(),\n       )\nMOIU.CachingOptimizer{MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}, MOIU.Model{Float64}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.Model{Float64}\nwith optimizer MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"A Utilities.CachingOptimizer may be in one of three possible states:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"NO_OPTIMIZER: The CachingOptimizer does not have any optimizer.\nEMPTY_OPTIMIZER: The CachingOptimizer has an empty optimizer, and it is not synchronized with the cached model. Modifications are forwarded to the cache, but not to the optimizer.\nATTACHED_OPTIMIZER: The CachingOptimizer has an optimizer, and it is synchronized with the cached model. Modifications are forwarded to the optimizer. If the optimizer does not support modifications, and error will be thrown.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Use Utilities.attach_optimizer to go from EMPTY_OPTIMIZER to ATTACHED_OPTIMIZER:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.attach_optimizer(model)\n\njulia> model\nMOIU.CachingOptimizer{MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}, MOIU.Model{Float64}}\nin state ATTACHED_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.Model{Float64}\nwith optimizer MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"info: Info\nYou must be in ATTACHED_OPTIMIZER to use optimize!.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Use Utilities.reset_optimizer to go from ATTACHED_OPTIMIZER to EMPTY_OPTIMIZER:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.reset_optimizer(model)\n\njulia> model\nMOIU.CachingOptimizer{MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}, MOIU.Model{Float64}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.Model{Float64}\nwith optimizer MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"info: Info\nCalling MOI.empty!(model) also resets the state to EMPTY_OPTIMIZER. So after emptying a model, the modification will only be applied to the cache.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Use Utilities.drop_optimizer to go from any state to NO_OPTIMIZER:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.drop_optimizer(model)\n\njulia> model\nMOIU.CachingOptimizer{MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}, MOIU.Model{Float64}}\nin state NO_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.Model{Float64}\nwith optimizer nothing","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Pass an empty optimizer to Utilities.reset_optimizer to go from NO_OPTIMIZER to EMPTY_OPTIMIZER:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.reset_optimizer(model, PathOptimizer{Float64}())\n\njulia> model\nMOIU.CachingOptimizer{MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}, MOIU.Model{Float64}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.Model{Float64}\nwith optimizer MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Deciding when to attach and reset the optimizer is tedious, and you will often write code like this:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"try\n    # modification\ncatch\n    MOI.Utilities.reset_optimizer(model)\n    # Re-try modification\nend","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"To make this easier, Utilities.CachingOptimizer has two modes of operation:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"AUTOMATIC: The CachingOptimizer changes its state when necessary. Attempting to add a constraint or perform a modification not supported by the optimizer results in a drop to EMPTY_OPTIMIZER mode.\nMANUAL: The user must change the state of the CachingOptimizer. Attempting to perform an operation in the incorrect state results in an error.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"By default, AUTOMATIC mode is chosen. However, you can create a CachingOptimizer in MANUAL mode as follows:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.Utilities.CachingOptimizer(\n           MOI.Utilities.Model{Float64}(),\n           MOI.Utilities.MANUAL,\n       )\nMOIU.CachingOptimizer{MOI.AbstractOptimizer, MOIU.Model{Float64}}\nin state NO_OPTIMIZER\nin mode MANUAL\nwith model cache MOIU.Model{Float64}\nwith optimizer nothing\n\njulia> MOI.Utilities.reset_optimizer(model, PathOptimizer{Float64}())\n\njulia> model\nMOIU.CachingOptimizer{MOI.AbstractOptimizer, MOIU.Model{Float64}}\nin state EMPTY_OPTIMIZER\nin mode MANUAL\nwith model cache MOIU.Model{Float64}\nwith optimizer MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}","category":"page"},{"location":"moi/submodules/Utilities/overview/#Printing","page":"Overview","title":"Printing","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Use print to print the formulation of the model.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.Utilities.Model{Float64}();\n\njulia> x = MOI.add_variable(model)\nMathOptInterface.VariableIndex(1)\n\njulia> MOI.set(model, MOI.VariableName(), x, \"x_var\")\n\njulia> MOI.add_constraint(model, x, MOI.ZeroOne())\nMathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}(1)\n\njulia> MOI.set(model, MOI.ObjectiveFunction{typeof(x)}(), x)\n\njulia> MOI.set(model, MOI.ObjectiveSense(), MOI.MAX_SENSE)\n\njulia> print(model)\nMaximize VariableIndex:\n x_var\n\nSubject to:\n\nVariableIndex-in-ZeroOne\n x_var ∈ {0, 1}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Use Utilities.latex_formulation to display the model in LaTeX form:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.latex_formulation(model)\n$$ \\begin{aligned}\n\\max\\quad & x\\_var \\\\\n\\text{Subject to}\\\\\n & \\text{VariableIndex-in-ZeroOne} \\\\\n & x\\_var \\in \\{0, 1\\} \\\\\n\\end{aligned} $$","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"tip: Tip\nIn IJulia, calling print or ending a cell with Utilities.latex_formulation will render the model in LaTeX.","category":"page"},{"location":"moi/submodules/Utilities/overview/#Utilities.MatrixOfConstraints","page":"Overview","title":"Utilities.MatrixOfConstraints","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The constraints of Utilities.Model are stored as a vector of tuples of function and set in a Utilities.VectorOfConstraints. Other representations can be used by parametrizing the type Utilities.GenericModel (resp. Utilities.GenericOptimizer). For instance, if all non-VariableIndex constraints are affine, the coefficients of all the constraints can be stored in a single sparse matrix using Utilities.MatrixOfConstraints. The constraints storage can even be customized up to a point where it exactly matches the storage of the solver of interest, in which case copy_to can be implemented for the solver by calling copy_to to this custom model.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"For instance, Clp defines the following model","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"MOI.Utilities.@product_of_scalar_sets(LP, MOI.EqualTo{T}, MOI.LessThan{T}, MOI.GreaterThan{T})\nconst Model = MOI.Utilities.GenericModel{\n    Float64,\n    MOI.Utilities.MatrixOfConstraints{\n        Float64,\n        MOI.Utilities.MutableSparseMatrixCSC{Float64,Cint,MOI.Utilities.ZeroBasedIndexing},\n        MOI.Utilities.Hyperrectangle{Float64},\n        LP{Float64},\n    },\n}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The copy_to operation can now be implemented as follows (assuming that the Model definition above is in the Clp module so that it can be referred to as Model, to be distinguished with Utilities.Model):","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"function _copy_to(dest::Optimizer, src::Model)\n    @assert MOI.is_empty(dest)\n    A = src.constraints.coefficients\n    row_bounds = src.constraints.constants\n    Clp_loadProblem(\n        dest,\n        A.n,\n        A.m,\n        A.colptr,\n        A.rowval,\n        A.nzval,\n        src.lower_bound,\n        src.upper_bound,\n        # (...) objective vector (omitted),\n        row_bounds.lower,\n        row_bounds.upper,\n    )\n    # Set objective sense and constant (omitted)\n    return\nend\n\nfunction MOI.copy_to(dest::Optimizer, src::Model)\n    _copy_to(dest, src)\n    return MOI.Utilities.identity_index_map(src)\nend\n\nfunction MOI.copy_to(\n    dest::Optimizer,\n    src::MOI.Utilities.UniversalFallback{Model},\n)\n    # Copy attributes from `src` to `dest` and error in case any unsupported\n    # constraints or attributes are set in `UniversalFallback`.\n    return MOI.copy_to(dest, src.model)\nend\n\nfunction MOI.copy_to(\n    dest::Optimizer,\n    src::MOI.ModelLike,\n)\n    model = Model()\n    index_map = MOI.copy_to(model, src)\n    _copy_to(dest, model)\n    return index_map\nend","category":"page"},{"location":"moi/submodules/Utilities/overview/#ModelFilter","page":"Overview","title":"ModelFilter","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Utilities provides Utilities.ModelFilter as a useful tool to copy a subset of a model. For example, given an infeasible model, we can copy the irreducible infeasible subsystem (for models implementing ConstraintConflictStatus) as follows:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"my_filter(::Any) = true\nfunction my_filter(ci::MOI.ConstraintIndex)\n    status = MOI.get(dest, MOI.ConstraintConflictStatus(), ci)\n    return status != MOI.NOT_IN_CONFLICT\nend\nfiltered_src = MOI.Utilities.ModelFilter(my_filter, src)\nindex_map = MOI.copy_to(dest, filtered_src)","category":"page"},{"location":"moi/submodules/Utilities/overview/#Fallbacks","page":"Overview","title":"Fallbacks","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The value of some attributes can be inferred from the value of other attributes.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"For example, the value of ObjectiveValue can be computed using ObjectiveFunction and VariablePrimal.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"When a solver gives direct access to an attribute, it is better to return this value. However, if this is not the case, Utilities.get_fallback can be used instead. For example:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"function MOI.get(model::Optimizer, attr::MOI.ObjectiveFunction)\n    return MOI.Utilities.get_fallback(model, attr)\nend","category":"page"},{"location":"moi/submodules/Utilities/overview/#DoubleDicts","page":"Overview","title":"DoubleDicts","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"When writing MOI interfaces, we often need to handle situations in which we map ConstraintIndexs to different values. For example, to a string for ConstraintName.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"One option is to use a dictionary like Dict{MOI.ConstraintIndex,String}. However, this incurs a performance cost because the key is not a concrete type.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The DoubleDicts submodule helps this situation by providing two types main types Utilities.DoubleDicts.DoubleDict and Utilities.DoubleDicts.IndexDoubleDict. These types act like normal dictionaries, but internally they use more efficient dictionaries specialized to the type of the function-set pair.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The most common usage of a DoubleDict is in the index_map returned by copy_to. Performance can be improved, by using a function barrier. That is, instead of code like:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"index_map = MOI.copy_to(dest, src)\nfor (F, S) in MOI.get(src, MOI.ListOfConstraintTypesPresent())\n    for ci in MOI.get(src, MOI.ListOfConstraintIndices{F,S}())\n        dest_ci = index_map[ci]\n        # ...\n    end\nend","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"use instead:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"function function_barrier(\n    dest,\n    src,\n    index_map::MOI.Utilities.DoubleDicts.IndexDoubleDictInner{F,S},\n) where {F,S}\n    for ci in MOI.get(src, MOI.ListOfConstraintIndices{F,S}())\n        dest_ci = index_map[ci]\n        # ...\n    end\n    return\nend\n\nindex_map = MOI.copy_to(dest, src)\nfor (F, S) in MOI.get(src, MOI.ListOfConstraintTypesPresent())\n    function_barrier(dest, src, index_map[F, S])\nend","category":"page"},{"location":"reference/extensions/#ExtensionAPI","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"reference/extensions/","page":"Extensions","title":"Extensions","text":"More information can be found in the Extensions section of the manual.","category":"page"},{"location":"reference/extensions/#Define-a-new-set","page":"Extensions","title":"Define a new set","text":"","category":"section"},{"location":"reference/extensions/","page":"Extensions","title":"Extensions","text":"AbstractVectorSet","category":"page"},{"location":"reference/extensions/#JuMP.AbstractVectorSet","page":"Extensions","title":"JuMP.AbstractVectorSet","text":"AbstractVectorSet\n\nAn abstract type for defining new sets in JuMP.\n\nImplement moi_set(::AbstractVectorSet, dim::Int) to convert the type into an MOI set.\n\nSee also: moi_set.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#Extend-@variable","page":"Extensions","title":"Extend @variable","text":"","category":"section"},{"location":"reference/extensions/","page":"Extensions","title":"Extensions","text":"ScalarVariable\nVariableInfo\nadd_variable\nbuild_variable","category":"page"},{"location":"reference/extensions/#JuMP.ScalarVariable","page":"Extensions","title":"JuMP.ScalarVariable","text":"ScalarVariable{S,T,U,V} <: AbstractVariable\n\nA struct used when adding variables.\n\nSee also: add_variable.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.VariableInfo","page":"Extensions","title":"JuMP.VariableInfo","text":"VariableInfo{S,T,U,V}\n\nA struct by JuMP internally when creating variables. This may also be used by JuMP extensions to create new types of variables.\n\nSee also: ScalarVariable.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.add_variable","page":"Extensions","title":"JuMP.add_variable","text":"add_variable(m::Model, v::AbstractVariable, name::String=\"\")\n\nAdd a variable v to Model m and sets its name.\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.build_variable","page":"Extensions","title":"JuMP.build_variable","text":"build_variable(_error::Function, variables, ::SymMatrixSpace)\n\nReturn a VariablesConstrainedOnCreation of shape SymmetricMatrixShape creating variables in MOI.Reals, i.e. \"free\" variables unless they are constrained after their creation.\n\nThis function is used by the @variable macro as follows:\n\n@variable(model, Q[1:2, 1:2], Symmetric)\n\n\n\n\n\nbuild_variable(_error::Function, variables, ::SkewSymmetricMatrixSpace)\n\nReturn a VariablesConstrainedOnCreation of shape SkewSymmetricMatrixShape creating variables in MOI.Reals, i.e. \"free\" variables unless they are constrained after their creation.\n\nThis function is used by the @variable macro as follows:\n\n@variable(model, Q[1:2, 1:2] in SkewSymmetricMatrixSpace())\n\n\n\n\n\nbuild_variable(_error::Function, variables, ::PSDCone)\n\nReturn a VariablesConstrainedOnCreation of shape SymmetricMatrixShape constraining the variables to be positive semidefinite.\n\nThis function is used by the @variable macro as follows:\n\n@variable(model, Q[1:2, 1:2], PSD)\n\n\n\n\n\nbuild_variable(\n    _error::Function,\n    info::VariableInfo,\n    args...;\n    kwargs...,\n)\n\nReturn a new AbstractVariable object.\n\nThis method should only be implemented by developers creating JuMP extensions. It should never be called by users of JuMP.\n\nArguments\n\n_error: a function to call instead of error. _error annotates the error message with additional information for the user.\ninfo: an instance of VariableInfo. This has a variety of fields relating to the variable such as info.lower_bound and info.binary.\nargs: optional additional positional arguments for extending the @variable macro.\nkwargs: optional keyword arguments for extending the @variable macro.\n\nSee also: @variable\n\nwarning: Warning\nExtensions should define a method with ONE positional argument to dispatch the call to a different method. Creating an extension that relies on multiple positional arguments leads to MethodErrors if the user passes the arguments in the wrong order.\n\nExamples\n\n@variable(model, x, Foo)\n\nwill call\n\nbuild_variable(_error::Function, info::VariableInfo, ::Type{Foo})\n\nPassing special-case positional arguments such as Bin, Int, and PSD is okay, along with keyword arguments:\n\n@variable(model, x, Int, Foo(), mykwarg = true)\n# or\n@variable(model, x, Foo(), Int, mykwarg = true)\n\nwill call\n\nbuild_variable(_error::Function, info::VariableInfo, ::Foo; mykwarg)\n\nand info.integer will be true.\n\nNote that the order of the positional arguments does not matter.\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#Extend-@constraint","page":"Extensions","title":"Extend @constraint","text":"","category":"section"},{"location":"reference/extensions/","page":"Extensions","title":"Extensions","text":"build_constraint\nadd_constraint\nAbstractShape\nshape\nreshape_vector\nreshape_set\ndual_shape\nScalarShape\nVectorShape\nSquareMatrixShape\nSymmetricMatrixShape\noperator_to_set\nparse_constraint\nparse_constraint_head\nparse_constraint_call","category":"page"},{"location":"reference/extensions/#JuMP.build_constraint","page":"Extensions","title":"JuMP.build_constraint","text":"build_constraint(\n    _error::Function,\n    f::AbstractVector{<:AbstractJuMPScalar},\n    s::MOI.GreaterThan,\n    extra::Union{MOI.AbstractVectorSet,AbstractVectorSet},\n)\n\nA helper method that re-writes\n\n@constraint(model, X >= Y, extra)\n\ninto\n\n@constraint(model, X - Y in extra)\n\n\n\n\n\nbuild_constraint(\n    _error::Function,\n    f::AbstractVector{<:AbstractJuMPScalar},\n    s::MOI.LessThan,\n    extra::Union{MOI.AbstractVectorSet,AbstractVectorSet},\n)\n\nA helper method that re-writes\n\n@constraint(model, Y <= X, extra)\n\ninto\n\n@constraint(model, X - Y in extra)\n\n\n\n\n\nbuild_constraint(_error::Function, Q::Symmetric{V, M},\n                 ::PSDCone) where {V <: AbstractJuMPScalar,\n                                   M <: AbstractMatrix{V}}\n\nReturn a VectorConstraint of shape SymmetricMatrixShape constraining the matrix Q to be positive semidefinite.\n\nThis function is used by the @constraint macros as follows:\n\n@constraint(model, Symmetric(Q) in PSDCone())\n\nThe form above is usually used when the entries of Q are affine or quadratic expressions, but it can also be used when the entries are variables to get the reference of the semidefinite constraint, e.g.,\n\n@variable model Q[1:2,1:2] Symmetric\n# The type of `Q` is `Symmetric{VariableRef, Matrix{VariableRef}}`\nvar_psd = @constraint model Q in PSDCone()\n# The `var_psd` variable contains a reference to the constraint\n\n\n\n\n\nbuild_constraint(\n    _error::Function,\n    Q::AbstractMatrix{<:AbstractJuMPScalar},\n    ::PSDCone,\n)\n\nReturn a VectorConstraint of shape SquareMatrixShape constraining the matrix Q to be symmetric and positive semidefinite.\n\nThis function is used by the @constraint macro as follows:\n\n@constraint(model, Q in PSDCone())\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.add_constraint","page":"Extensions","title":"JuMP.add_constraint","text":"add_constraint(model::Model, con::AbstractConstraint, name::String=\"\")\n\nAdd a constraint con to Model model and sets its name.\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.AbstractShape","page":"Extensions","title":"JuMP.AbstractShape","text":"AbstractShape\n\nAbstract vectorizable shape. Given a flat vector form of an object of shape shape, the original object can be obtained by reshape_vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.shape","page":"Extensions","title":"JuMP.shape","text":"shape(c::AbstractConstraint)::AbstractShape\n\nReturn the shape of the constraint c.\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.reshape_vector","page":"Extensions","title":"JuMP.reshape_vector","text":"reshape_vector(vectorized_form::Vector, shape::AbstractShape)\n\nReturn an object in its original shape shape given its vectorized form vectorized_form.\n\nExamples\n\nGiven a SymmetricMatrixShape of vectorized form [1, 2, 3], the following code returns the matrix Symmetric(Matrix[1 2; 2 3]):\n\njulia> reshape_vector([1, 2, 3], SymmetricMatrixShape(2))\n2×2 LinearAlgebra.Symmetric{Int64,Array{Int64,2}}:\n 1  2\n 2  3\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.reshape_set","page":"Extensions","title":"JuMP.reshape_set","text":"reshape_set(vectorized_set::MOI.AbstractSet, shape::AbstractShape)\n\nReturn a set in its original shape shape given its vectorized form vectorized_form.\n\nExamples\n\nGiven a SymmetricMatrixShape of vectorized form [1, 2, 3] in MOI.PositiveSemidefinieConeTriangle(2), the following code returns the set of the original constraint Symmetric(Matrix[1 2; 2 3]) in PSDCone():\n\njulia> reshape_set(MOI.PositiveSemidefiniteConeTriangle(2), SymmetricMatrixShape(2))\nPSDCone()\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.dual_shape","page":"Extensions","title":"JuMP.dual_shape","text":"dual_shape(shape::AbstractShape)::AbstractShape\n\nReturns the shape of the dual space of the space of objects of shape shape. By default, the dual_shape of a shape is itself. See the examples section below for an example for which this is not the case.\n\nExamples\n\nConsider polynomial constraints for which the dual is moment constraints and moment constraints for which the dual is polynomial constraints. Shapes for polynomials can be defined as follows:\n\nstruct Polynomial\n    coefficients::Vector{Float64}\n    monomials::Vector{Monomial}\nend\nstruct PolynomialShape <: AbstractShape\n    monomials::Vector{Monomial}\nend\nJuMP.reshape_vector(x::Vector, shape::PolynomialShape) = Polynomial(x, shape.monomials)\n\nand a shape for moments can be defined as follows:\n\nstruct Moments\n    coefficients::Vector{Float64}\n    monomials::Vector{Monomial}\nend\nstruct MomentsShape <: AbstractShape\n    monomials::Vector{Monomial}\nend\nJuMP.reshape_vector(x::Vector, shape::MomentsShape) = Moments(x, shape.monomials)\n\nThen dual_shape allows the definition of the shape of the dual of polynomial and moment constraints:\n\ndual_shape(shape::PolynomialShape) = MomentsShape(shape.monomials)\ndual_shape(shape::MomentsShape) = PolynomialShape(shape.monomials)\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.ScalarShape","page":"Extensions","title":"JuMP.ScalarShape","text":"ScalarShape\n\nShape of scalar constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.VectorShape","page":"Extensions","title":"JuMP.VectorShape","text":"VectorShape\n\nVector for which the vectorized form corresponds exactly to the vector given.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.SquareMatrixShape","page":"Extensions","title":"JuMP.SquareMatrixShape","text":"SquareMatrixShape\n\nShape object for a square matrix of side_dimension rows and columns. The vectorized form contains the entries of the the matrix given column by column (or equivalently, the entries of the lower-left triangular part given row by row).\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.SymmetricMatrixShape","page":"Extensions","title":"JuMP.SymmetricMatrixShape","text":"SymmetricMatrixShape\n\nShape object for a symmetric square matrix of side_dimension rows and columns. The vectorized form contains the entries of the upper-right triangular part of the matrix given column by column (or equivalently, the entries of the lower-left triangular part given row by row).\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.operator_to_set","page":"Extensions","title":"JuMP.operator_to_set","text":"operator_to_set(_error::Function, ::Val{sense_symbol})\n\nConverts a sense symbol to a set set such that @constraint(model, func sense_symbol 0) is equivalent to @constraint(model, func in set) for any func::AbstractJuMPScalar.\n\nExample\n\nOnce a custom set is defined you can directly create a JuMP constraint with it:\n\njulia> struct CustomSet{T} <: MOI.AbstractScalarSet\n           value::T\n       end\n\njulia> Base.copy(x::CustomSet) = CustomSet(x.value)\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> cref = @constraint(model, x in CustomSet(1.0))\nx ∈ CustomSet{Float64}(1.0)\n\nHowever, there might be an appropriate sign that could be used in order to provide a more convenient syntax:\n\njulia> JuMP.operator_to_set(::Function, ::Val{:⊰}) = CustomSet(0.0)\n\njulia> MOIU.shift_constant(set::CustomSet, value) = CustomSet(set.value + value)\n\njulia> cref = @constraint(model, x ⊰ 1)\nx ∈ CustomSet{Float64}(1.0)\n\nNote that the whole function is first moved to the right-hand side, then the sign is transformed into a set with zero constant and finally the constant is moved to the set with MOIU.shift_constant.\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.parse_constraint","page":"Extensions","title":"JuMP.parse_constraint","text":"parse_constraint(_error::Function, expr::Expr)\n\nThe entry-point for all constraint-related parsing.\n\nArguments\n\nThe _error function is passed everywhere to provide better error messages\nexpr comes from the @constraint macro. There are two possibilities:\n@constraint(model, expr)\n@constraint(model, name[args], expr)\nIn both cases, expr is the main component of the constraint.\n\nSupported syntax\n\nJuMP currently supports the following expr objects:\n\nlhs <= rhs\nlhs == rhs\nlhs >= rhs\nl <= body <= u\nu >= body >= l\nlhs ⟂ rhs\nlhs in rhs\nlhs ∈ rhs\nz => {constraint}\n!z => {constraint}\n\nas well as all broadcasted variants.\n\nExtensions\n\nThe infrastructure behind parse_constraint is extendable. See parse_constraint_head and parse_constraint_call for details.\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.parse_constraint_head","page":"Extensions","title":"JuMP.parse_constraint_head","text":"parse_constraint_head(_error::Function, ::Val{head}, args...)\n\nImplement this method to intercept the parsing of an expression with head head.\n\nwarning: Warning\nExtending the constraint macro at parse time is an advanced operation and has the potential to interfere with existing JuMP syntax. Please discuss with the developer chatroom before publishing any code that implements these methods.\n\nArguments\n\n_error: a function that accepts a String and throws the string as an error, along with some descriptive information of the macro from which it was thrown.\nhead: the .head field of the Expr to intercept\nargs...: the .args field of the Expr.\n\nReturns\n\nThis function must return:\n\nis_vectorized::Bool: whether the expression represents a broadcasted expression like x .<= 1\nparse_code::Expr: an expression containing any setup or rewriting code that needs to be called before build_constraint\nbuild_code::Expr: an expression that calls build_constraint( or build_constraint.( depending on is_vectorized.\n\nExisting implementations\n\nJuMP currently implements:\n\n::Val{:call}, which forwards calls to parse_constraint_call\n::Val{:comparison}, which handles the special case of l <= body <= u.\n\nSee also: parse_constraint_call, build_constraint\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.parse_constraint_call","page":"Extensions","title":"JuMP.parse_constraint_call","text":"parse_constraint_call(\n    _error::Function,\n    is_vectorized::Bool,\n    ::Val{op},\n    args...,\n)\n\nImplement this method to intercept the parsing of a :call expression with operator op.\n\nwarning: Warning\nExtending the constraint macro at parse time is an advanced operation and has the potential to interfere with existing JuMP syntax. Please discuss with the developer chatroom before publishing any code that implements these methods.\n\nArguments\n\n_error: a function that accepts a String and throws the string as an error, along with some descriptive information of the macro from which it was thrown.\nis_vectorized: a boolean to indicate if op should be broadcast or not\nop: the first element of the .args field of the Expr to intercept\nargs...: the .args field of the Expr.\n\nReturns\n\nThis function must return:\n\nparse_code::Expr: an expression containing any setup or rewriting code that needs to be called before build_constraint\nbuild_code::Expr: an expression that calls build_constraint( or build_constraint.( depending on is_vectorized.\n\nSee also: parse_constraint_head, build_constraint\n\n\n\n\n\nparse_constraint_call(\n    _error::Function,\n    vectorized::Bool,\n    ::Val{op},\n    lhs,\n    rhs,\n) where {op}\n\nFallback handler for binary operators. These might be infix operators like @constraint(model, lhs op rhs), or normal operators like @constraint(model, op(lhs, rhs)).\n\nIn both cases, we rewrite as lhs - rhs in operator_to_set(_error, op).\n\nSee operator_to_set for details.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/linear/diet.jl\"","category":"page"},{"location":"tutorials/linear/diet/#The-diet-problem","page":"The diet problem","title":"The diet problem","text":"","category":"section"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"This tutorial solves the classic \"diet problem\", also known as the Stigler diet.","category":"page"},{"location":"tutorials/linear/diet/#Required-packages","page":"The diet problem","title":"Required packages","text":"","category":"section"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"using JuMP\nimport DataFrames\nimport GLPK\nimport Test  #hide","category":"page"},{"location":"tutorials/linear/diet/#Formulation","page":"The diet problem","title":"Formulation","text":"","category":"section"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Suppose we wish to cook a nutritionally balanced meal by choosing the quantity of each food f to eat from a set of foods F in our kitchen.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Each food f has a cost, c_f, as well as a macronutrient profile a_mf for each macronutrient m in M.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Because we care about a nutritionally balanced meal, we set some minimum and maximum limits for each nutrient, which we denote l_m and u_m respectively.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Furthermore, because we are optimizers, we seek the minimum cost solution.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"With a little effort, we can formulate our dinner problem as the following linear program:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"beginaligned\nmin  sumlimits_f in F c_f x_f \ntextst   l_m le sumlimits_f in F a_mf x_f le u_m  forall m in M \n x_f ge 0  forall f in F\nendaligned","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"In the rest of this tutorial, we will create and solve this problem in JuMP, and learn what we should cook for dinner.","category":"page"},{"location":"tutorials/linear/diet/#Data","page":"The diet problem","title":"Data","text":"","category":"section"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"First, we need some data for the problem:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"foods = DataFrames.DataFrame(\n    [\n        \"hamburger\" 2.49 410 24 26 730\n        \"chicken\" 2.89 420 32 10 1190\n        \"hot dog\" 1.50 560 20 32 1800\n        \"fries\" 1.89 380 4 19 270\n        \"macaroni\" 2.09 320 12 10 930\n        \"pizza\" 1.99 320 15 12 820\n        \"salad\" 2.49 320 31 12 1230\n        \"milk\" 0.89 100 8 2.5 125\n        \"ice cream\" 1.59 330 8 10 180\n    ],\n    [\"name\", \"cost\", \"calories\", \"protein\", \"fat\", \"sodium\"],\n)","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Here, F is foods.name and c_f is foods.cost. (We're also playing a bit loose the term \"macronutrient\" by including calories and sodium.)","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"tip: Tip\nAlthough we hard-coded the data here, you could also read it in from a file. See Getting started with data and plotting for details.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"We also need our minimum and maximum limits:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"limits = DataFrames.DataFrame(\n    [\n        \"calories\" 1800 2200\n        \"protein\" 91 Inf\n        \"fat\" 0 65\n        \"sodium\" 0 1779\n    ],\n    [\"name\", \"min\", \"max\"],\n)","category":"page"},{"location":"tutorials/linear/diet/#JuMP-formulation","page":"The diet problem","title":"JuMP formulation","text":"","category":"section"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Now we're ready to convert our mathematical formulation into a JuMP model.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"First, create a new JuMP model. Since we have a linear program, we'll use GLPK as our optimizer:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"model = Model(GLPK.Optimizer)","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Next, we create a set of decision variables x, indexed over the foods in the data DataFrame. Each x has a lower bound of 0.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"@variable(model, x[foods.name] >= 0)","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Our objective is to minimize the total cost of purchasing food. We can write that as a sum over the rows in data.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"@objective(\n    model,\n    Min,\n    sum(food[\"cost\"] * x[food[\"name\"]] for food in eachrow(foods)),\n)","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"For the next component, we need to add a constraint that our total intake of each component is within the limits contained in the limits DataFrame. To make this more readable, we introduce a JuMP @expression","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"for limit in eachrow(limits)\n    intake = @expression(\n        model,\n        sum(food[limit[\"name\"]] * x[food[\"name\"]] for food in eachrow(foods)),\n    )\n    @constraint(model, limit.min <= intake <= limit.max)\nend","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"What does our model look like?","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"print(model)","category":"page"},{"location":"tutorials/linear/diet/#Solution","page":"The diet problem","title":"Solution","text":"","category":"section"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"optimize!(model)\n\nTest.@test primal_status(model) == FEASIBLE_POINT   #hide\nTest.@test objective_value(model) ≈ 11.8288 atol = 1e-4 #hide\n\nsolution_summary(model)","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Success! We found an optimal solution. Let's see what the optimal solution is:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"for food in foods.name\n    println(food, \" = \", value(x[food]))\nend","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"That's a lot of milk and ice cream! And sadly, we only get 0.6 of a hamburger.","category":"page"},{"location":"tutorials/linear/diet/#Problem-modification","page":"The diet problem","title":"Problem modification","text":"","category":"section"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"JuMP makes it easy to take an existing model and modify it by adding extra constraints. Let's see what happens if we add a constraint that we can buy at most 6 units of milk or ice cream combined.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"@constraint(model, x[\"milk\"] + x[\"ice cream\"] <= 6)","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"optimize!(model)\n\nTest.@test termination_status(model) == INFEASIBLE  #hide\nTest.@test primal_status(model) == NO_SOLUTION      #hide\n\nsolution_summary(model)","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Uh oh! There exists no feasible solution to our problem. Looks like we're stuck eating ice cream for dinner.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"moi/submodules/Test/reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Test/reference/#test_reference","page":"API Reference","title":"The Test submodule","text":"","category":"section"},{"location":"moi/submodules/Test/reference/","page":"API Reference","title":"API Reference","text":"Functions to help test implementations of MOI. See The Test submodule for more details.","category":"page"},{"location":"moi/submodules/Test/reference/","page":"API Reference","title":"API Reference","text":"Test.Config\nTest.runtests\nTest.setup_test\nTest.version_added\nTest.@requires\nTest.RequirementUnmet","category":"page"},{"location":"moi/submodules/Test/reference/#MathOptInterface.Test.Config","page":"API Reference","title":"MathOptInterface.Test.Config","text":"Config(\n    ::Type{T} = Float64;\n    atol::Real = Base.rtoldefault(T),\n    rtol::Real = Base.rtoldefault(T),\n    optimal_status::MOI.TerminationStatusCode = MOI.OPTIMAL,\n    infeasible_status::MOI.TerminationStatusCode = MOI.INFEASIBLE,\n    exclude::Vector{Any} = Any[],\n) where {T}\n\nReturn an object that is used to configure various tests.\n\nConfiguration arguments\n\natol::Real = Base.rtoldefault(T): Control the absolute tolerance used when comparing solutions.\nrtol::Real = Base.rtoldefault(T): Control the relative tolerance used when comparing solutions.\noptimal_status = MOI.OPTIMAL: Set to MOI.LOCALLY_SOLVED if the solver cannot prove global optimality.\ninfeasible_status = MOI.INFEASIBLE: Set to MOI.LOCALLY_INFEASIBLE if the solver cannot prove global infeasibility.\nexclude = Vector{Any}: Pass attributes or functions to exclude to skip parts of tests that require certain functionality. Common arguments include:\nMOI.delete to skip deletion-related tests\nMOI.optimize! to skip optimize-related tests\nMOI.ConstraintDual to skip dual-related tests\nMOI.VariableName to skip setting variable names\nMOI.ConstraintName to skip setting constraint names\n\nExamples\n\nFor a nonlinear solver that finds local optima and does not support finding dual variables or constraint names:\n\nConfig(\n    Float64;\n    optimal_status = MOI.LOCALLY_SOLVED,\n    exclude = Any[\n        MOI.ConstraintDual,\n        MOI.VariableName,\n        MOI.ConstraintName,\n        MOI.delete,\n    ],\n)\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Test/reference/#MathOptInterface.Test.runtests","page":"API Reference","title":"MathOptInterface.Test.runtests","text":"runtests(\n    model::MOI.ModelLike,\n    config::Config;\n    include::Vector{String} = String[],\n    exclude::Vector{String} = String[],\n    warn_unsupported::Bool = false,\n    exclude_tests_after::VersionNumber = v\"999.0.0\",\n)\n\nRun all tests in MathOptInterface.Test on model.\n\nConfiguration arguments\n\nconfig is a Test.Config object that can be used to modify the behavior of tests.\nIf include is not empty, only run tests that contain an element from include in their name.\nIf exclude is not empty, skip tests that contain an element from exclude in their name.\nexclude takes priority over include.\nIf warn_unsupported is false, runtests will silently skip tests that fail with UnsupportedConstraint or UnsupportedAttribute. When warn_unsupported is true, a warning will be printed. For most cases the default behavior (false) is what you want, since these tests likely test functionality that is not supported by model. However, it can be useful to run  warn_unsupported = true to check you are not skipping tests due to a missing supports_constraint method or equivalent.\nexclude_tests_after is a version number that excludes any tests to MOI added after that version number. This is useful for solvers who can declare a fixed set of tests, and not cause their tests to break if a new patch of MOI is released with a new test.\n\nSee also: setup_test.\n\nExample\n\nconfig = MathOptInterface.Test.Config()\nMathOptInterface.Test.runtests(\n    model,\n    config;\n    include = [\"test_linear_\"],\n    exclude = [\"VariablePrimalStart\"],\n    warn_unsupported = true,\n    exclude_tests_after = v\"0.10.5\",\n)\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Test/reference/#MathOptInterface.Test.setup_test","page":"API Reference","title":"MathOptInterface.Test.setup_test","text":"setup_test(::typeof(f), model::MOI.ModelLike, config::Config)\n\nOverload this method to modify model before running the test function f on model with config. You can also modify the fields in config (e.g., to loosen the default tolerances).\n\nThis function should either return nothing, or return a function which, when called with zero arguments, undoes the setup to return the model to its previous state. You do not need to undo any modifications to config.\n\nThis function is most useful when writing new tests of the tests for MOI, but it can also be used to set test-specific tolerances, etc.\n\nSee also: runtests\n\nExample\n\nfunction MOI.Test.setup_test(\n    ::typeof(MOI.Test.test_linear_VariablePrimalStart_partial),\n    mock::MOIU.MockOptimizer,\n    ::MOI.Test.Config,\n)\n    MOIU.set_mock_optimize!(\n        mock,\n        (mock::MOIU.MockOptimizer) -> MOIU.mock_optimize!(mock, [1.0, 0.0]),\n    )\n    mock.eval_variable_constraint_dual = false\n\n    function reset_function()\n        mock.eval_variable_constraint_dual = true\n        return\n    end\n    return reset_function\nend\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Test/reference/#MathOptInterface.Test.version_added","page":"API Reference","title":"MathOptInterface.Test.version_added","text":"version_added(::typeof(function_name))\n\nReturns the version of MOI in which the test function_name was added.\n\nThis method should be implemented for all new tests.\n\nSee the exclude_tests_after keyword of runtests for more details.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Test/reference/#MathOptInterface.Test.@requires","page":"API Reference","title":"MathOptInterface.Test.@requires","text":"@requires(x)\n\nCheck that the condition x is true. Otherwise, throw an RequirementUnmet error to indicate that the model does not support something required by the test function.\n\nExamples\n\n@requires MOI.supports(model, MOI.Silent())\n@test MOI.get(model, MOI.Silent())\n\n\n\n\n\n","category":"macro"},{"location":"moi/submodules/Test/reference/#MathOptInterface.Test.RequirementUnmet","page":"API Reference","title":"MathOptInterface.Test.RequirementUnmet","text":"RequirementUnmet(msg::String) <: Exception\n\nAn error for throwing in tests to indicate that the model does not support some requirement expected by the test function.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/linear/geographic_clustering.jl\"","category":"page"},{"location":"tutorials/linear/geographic_clustering/#Geographical-clustering","page":"Geographical clustering","title":"Geographical clustering","text":"","category":"section"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"Originally Contributed by: Matthew Helm (with help from Mathieu Tanneau on Julia Discourse)","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"The goal of this exercise is to cluster n cities into k groups, minimizing the total pairwise distance between cities and ensuring that the variance in the total populations of each group is relatively small.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"using JuMP\nimport DataFrames\nimport GLPK\nimport LinearAlgebra","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"For this example, we'll use the 20 most populous cities in the United States.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"cities = DataFrames.DataFrame(\n    city = [\n        \"New York, NY\",\n        \"Los Angeles, CA\",\n        \"Chicago, IL\",\n        \"Houston, TX\",\n        \"Philadelphia, PA\",\n        \"Phoenix, AZ\",\n        \"San Antonio, TX\",\n        \"San Diego, CA\",\n        \"Dallas, TX\",\n        \"San Jose, CA\",\n        \"Austin, TX\",\n        \"Indianapolis, IN\",\n        \"Jacksonville, FL\",\n        \"San Francisco, CA\",\n        \"Columbus, OH\",\n        \"Charlotte, NC\",\n        \"Fort Worth, TX\",\n        \"Detroit, MI\",\n        \"El Paso, TX\",\n        \"Memphis, TN\",\n    ],\n    population = [\n        8.405,\n        3.884,\n        2.718,\n        2.195,\n        1.553,\n        1.513,\n        1.409,\n        1.355,\n        1.257,\n        0.998,\n        0.885,\n        0.843,\n        0.842,\n        0.837,\n        0.822,\n        0.792,\n        0.792,\n        0.688,\n        0.674,\n        0.653,\n    ],\n    lat = [\n        40.7127,\n        34.0522,\n        41.8781,\n        29.7604,\n        39.9525,\n        33.4483,\n        29.4241,\n        32.7157,\n        32.7766,\n        37.3382,\n        30.2671,\n        39.7684,\n        30.3321,\n        37.7749,\n        39.9611,\n        35.2270,\n        32.7554,\n        42.3314,\n        31.7775,\n        35.1495,\n    ],\n    lon = [\n        -74.0059,\n        -118.2436,\n        -87.6297,\n        -95.3698,\n        -75.1652,\n        -112.0740,\n        -98.4936,\n        -117.1610,\n        -96.7969,\n        -121.8863,\n        -97.7430,\n        -86.1580,\n        -81.6556,\n        -122.4194,\n        -82.9987,\n        -80.8431,\n        -97.3307,\n        -83.0457,\n        -106.4424,\n        -90.0489,\n    ],\n)","category":"page"},{"location":"tutorials/linear/geographic_clustering/#Model-Specifics","page":"Geographical clustering","title":"Model Specifics","text":"","category":"section"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"We will cluster these 20 cities into 3 different groups and we will assume that the ideal or target population P for a group is simply the total population of the 20 cities divided by 3:","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"n = size(cities, 1)\nk = 3\nP = sum(cities.population) / k","category":"page"},{"location":"tutorials/linear/geographic_clustering/#Obtaining-the-distances-between-each-city","page":"Geographical clustering","title":"Obtaining the distances between each city","text":"","category":"section"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"Let's compute the pairwise Haversine distance between each of the cities in our data set and store the result in a variable we'll call dm:","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"\"\"\"\n    haversine(lat1, long1, lat2, long2, r = 6372.8)\n\nCompute the haversine distance between two points on a sphere of radius `r`,\nwhere the points are given by the latitude/longitude pairs `lat1/long1` and\n`lat2/long2` (in degrees).\n\"\"\"\nfunction haversine(lat1, long1, lat2, long2, r = 6372.8)\n    lat1, long1 = deg2rad(lat1), deg2rad(long1)\n    lat2, long2 = deg2rad(lat2), deg2rad(long2)\n    hav(a, b) = sin((b - a) / 2)^2\n    inner_term = hav(lat1, lat2) + cos(lat1) * cos(lat2) * hav(long1, long2)\n    d = 2 * r * asin(sqrt(inner_term))\n    # Round distance to nearest kilometer.\n    return round(Int, d)\nend","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"Our distance matrix is symmetric so we'll convert it to a LowerTriangular matrix so that we can better interpret the objective value of our model:","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"dm = LinearAlgebra.LowerTriangular([\n    haversine(cities.lat[i], cities.lon[i], cities.lat[j], cities.lon[j])\n    for i in 1:n, j in 1:n\n])","category":"page"},{"location":"tutorials/linear/geographic_clustering/#Build-the-model","page":"Geographical clustering","title":"Build the model","text":"","category":"section"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"Now that we have the basics taken  care of, we can set up our model, create decision variables, add constraints, and then solve.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"First, we'll set up a model that leverages the Cbc solver. Next, we'll set up a binary variable x_ik that takes the value 1 if city i is in group k and 0 otherwise. Each city must be in a group, so we'll add the constraint sum_kx_ik = 1 for every i.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"model = Model(GLPK.Optimizer)\nset_silent(model)","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"@variable(model, x[1:n, 1:k], Bin)","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"@constraint(model, [i = 1:n], sum(x[i, :]) == 1)","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"To reduce symmetry, we fix the first city to belong to the first group.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"fix(x[1, 1], 1; force = true)","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"The total population of a group k is Q_k = sum_ix_ikq_i where q_i is simply the ith value from the population column in our cities DataFrame. Let's add constraints so that alpha leq (Q_k - P) leq beta. We'll set alpha equal to -3 million and beta equal to 3. By adjusting these thresholds you'll find that there is a tradeoff between having relatively even populations between groups and having geographically close cities within each group. In other words, the larger the absolute values of alpha and beta, the closer together the cities in a group will be but the variance between the group populations will be higher.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"@variable(model, -3 <= population_diff[1:k] <= 3)\n@constraint(model, population_diff .== x' * cities.population .- P)","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"Now we need to add one last binary variable z_ij to our model that we'll use to compute the total distance between the cities in our groups, defined as sum_ijd_ijz_ij. Variable z_ij will equal 1 if cities i and j are in the same group, and 0 if they are not in the same group.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"To ensure that z_ij = 1 if and only if cities i and j are in the same group, we add the constraints z_ij geq x_ik + x_jk - 1 for every pair ij and every k:","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"@variable(model, z[i = 1:n, j = 1:i], Bin)","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"for k in 1:k, i in 1:n, j in 1:i\n    @constraint(model, z[i, j] >= x[i, k] + x[j, k] - 1)\nend","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"We can now add an objective to our model which will simply be to minimize the dot product of z and our distance matrix, dm.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"@objective(model, Min, sum(dm[i, j] * z[i, j] for i in 1:n, j in 1:i))","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"We can then call optimize! and review the results.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"optimize!(model)","category":"page"},{"location":"tutorials/linear/geographic_clustering/#Reviewing-the-Results","page":"Geographical clustering","title":"Reviewing the Results","text":"","category":"section"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"Now that we have results, we can add a column to our cities DataFrame for the group and then loop through our x variable to assign each city to its group. Once we have that, we can look at the total population for each group and also look at the cities in each group to verify that they are grouped by geographic proximity.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"cities.group = zeros(n)\n\nfor i in 1:n, j in 1:k\n    if round(Int, value(x[i, j])) == 1\n        cities.group[i] = j\n    end\nend\n\nfor group in DataFrames.groupby(cities, :group)\n    @show group\n    println(\"\")\n    @show sum(group.population)\n    println(\"\")\nend","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"manual/variables/#jump_variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The term variable in mathematical optimization has many meanings. For example, optimization variables (also called decision variables) are the unknowns x that we are solving for in the problem:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"beginalign\n     min_x in mathbbR^n  f_0(x)\n    \n     textst  f_i(x)  in mathcalS_i  i = 1 ldots m\nendalign","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"To complicate things, Julia uses variable to mean a binding between a name and a value. For example, in the statement:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x = 1\n1","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"x is a variable that stores the value 1.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP uses variable in a third way, to mean an instance of the VariableRef struct. JuMP variables are the link between Julia and the optimization variables inside a JuMP model.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"This page explains how to create and manage JuMP variables in a variety of contexts.","category":"page"},{"location":"manual/variables/#Create-a-variable","page":"Variables","title":"Create a variable","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Create variables using the @variable macro. When creating a variable, you can also specify variable bounds:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"model = Model()\n@variable(model, x_free)\n@variable(model, x_lower >= 0)\n@variable(model, x_upper <= 1)\n@variable(model, 2 <= x_interval <= 3)\n@variable(model, x_fixed == 4)\nprint(model)\n\n# output\n\nFeasibility\nSubject to\n x_fixed = 4.0\n x_lower ≥ 0.0\n x_interval ≥ 2.0\n x_upper ≤ 1.0\n x_interval ≤ 3.0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"warning: Warning\nWhen creating a variable with a single lower- or upper-bound, and the value of the bound is not a numeric literal (for example, 1 or 1.0), the name of the variable must appear on the left-hand side. Putting the name on the right-hand side is an error. For example, to create a variable x:a = 1\n@variable(model, x >= 1)      # ✓ Okay\n@variable(model, 1.0 <= x)    # ✓ Okay\n@variable(model, x >= a)      # ✓ Okay\n@variable(model, a <= x)      # × Not okay\n@variable(model, x >= 1 / 2)  # ✓ Okay\n@variable(model, 1 / 2 <= x)  # × Not okay","category":"page"},{"location":"manual/variables/#Containers-of-variables","page":"Variables","title":"Containers of variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The @variable macro also supports creating collections of JuMP variables. We'll cover some brief syntax here; read the Variable containers section for more details.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"You can create arrays of JuMP variables:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2])\n2×2 Matrix{VariableRef}:\n x[1,1]  x[1,2]\n x[2,1]  x[2,2]\n\njulia> x[1, 2]\nx[1,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Index sets can be named, and bounds can depend on those names:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, sqrt(i) <= x[i = 1:3] <= i^2)\n3-element Vector{VariableRef}:\n x[1]\n x[2]\n x[3]\n\njulia> x[2]\nx[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Sets can be any Julia type that supports iteration:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i = 2:3, j = 1:2:3, [\"red\", \"blue\"]] >= 0)\n3-dimensional DenseAxisArray{VariableRef,3,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, 1:2:3\n    Dimension 3, [\"red\", \"blue\"]\nAnd data, a 2×2×2 Array{VariableRef, 3}:\n[:, :, \"red\"] =\n x[2,1,red]  x[2,3,red]\n x[3,1,red]  x[3,3,red]\n\n[:, :, \"blue\"] =\n x[2,1,blue]  x[2,3,blue]\n x[3,1,blue]  x[3,3,blue]\n\njulia> x[2, 1, \"red\"]\nx[2,1,red]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Sets can depend upon previous indices:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, u[i = 1:2, j = i:3])\nJuMP.Containers.SparseAxisArray{VariableRef, 2, Tuple{Int64, Int64}} with 5 entries:\n  [1, 1]  =  u[1,1]\n  [1, 2]  =  u[1,2]\n  [1, 3]  =  u[1,3]\n  [2, 2]  =  u[2,2]\n  [2, 3]  =  u[2,3]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"and we can filter elements in the sets using the ; syntax:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, v[i = 1:9; mod(i, 3) == 0])\nJuMP.Containers.SparseAxisArray{VariableRef, 1, Tuple{Int64}} with 3 entries:\n  [3]  =  v[3]\n  [6]  =  v[6]\n  [9]  =  v[9]","category":"page"},{"location":"manual/variables/#Registered-variables","page":"Variables","title":"Registered variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"When you create variables, JuMP registers them inside the model using their corresponding symbol. Get a registered name using model[:key]:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> model\nA JuMP Model\nFeasibility problem with:\nVariable: 1\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: x\n\njulia> model[:x] === x\ntrue","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Registered names are most useful when you start to write larger models and want to break up the model construction into functions:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> function set_objective(model::Model)\n           @objective(model, Min, 2 * model[:my_x] + 1)\n           return\n       end\nset_objective (generic function with 1 method)\n\njulia> model = Model();\n\njulia> @variable(model, my_x);\n\njulia> set_objective(model)\n\njulia> print(model)\nMin 2 my_x + 1\nSubject to","category":"page"},{"location":"manual/variables/#anonymous_variables","page":"Variables","title":"Anonymous variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"To reduce the likelihood of accidental bugs, and because JuMP registers variables inside a model, creating two variables with the same name is an error:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, x)\nERROR: An object of name x is already attached to this model. If this\n    is intended, consider using the anonymous construction syntax, e.g.,\n    `x = @variable(model, [1:N], ...)` where the name of the object does\n    not appear inside the macro.\n\n    Alternatively, use `unregister(model, :x)` to first unregister\n    the existing name from the model. Note that this will not delete the\n    object; it will just remove the reference at `model[:x]`.\n[...]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"A common reason for encountering this error is adding variables in a loop.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"As a work-around, JuMP provides anonymous variables. Create a scalar valued anonymous variable by omitting the name argument:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x = @variable(model)\n_[1]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Anonymous variables get printed as an underscore followed by a unique index of the variable.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"warning: Warning\nThe index of the variable may not correspond to the column of the variable in the solver!","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Create a container of anonymous JuMP variables by dropping the name in front of the [:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> y = @variable(model, [1:2])\n2-element Vector{VariableRef}:\n _[1]\n _[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The <= and >= short-hand cannot be used to set bounds on scalar-valued anonymous JuMP variables. Instead, use the lower_bound and upper_bound keywords:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x_lower = @variable(model, lower_bound = 1.0)\n_[1]\n\njulia> x_upper = @variable(model, upper_bound = 2.0)\n_[2]\n\njulia> x_interval = @variable(model, lower_bound = 3.0, upper_bound = 4.0)\n_[3]","category":"page"},{"location":"manual/variables/#Variable-names","page":"Variables","title":"Variable names","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"In addition to the symbol that variables are registered with, JuMP variables have a String name that is used for printing and writing to file formats.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Get and set the name of a variable using name and set_name:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> name(x)\n\"x\"\n\njulia> set_name(x, \"my_x_name\")\n\njulia> x\nmy_x_name","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Override the default choice of name using the base_name keyword:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x[i=1:2], base_name = \"my_var\")\n2-element Vector{VariableRef}:\n my_var[1]\n my_var[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Note that names apply to each element of the container, not to the container of variables:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> name(x[1])\n\"my_var[1]\"\n\njulia> set_name(x[1], \"my_x\")\n\njulia> x\n2-element Vector{VariableRef}:\n my_x\n my_var[2]","category":"page"},{"location":"manual/variables/#Retrieve-a-variable-by-name","page":"Variables","title":"Retrieve a variable by name","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Retrieve a variable from a model using variable_by_name:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> variable_by_name(model, \"my_x\")\nmy_x","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"If the name is not present, nothing will be returned:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> variable_by_name(model, \"bad_name\")","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"You can only look up individual variables using variable_by_name. Something like this will not work:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, [i = 1:2], base_name = \"my_var\")\n2-element Vector{VariableRef}:\n my_var[1]\n my_var[2]\n\njulia> variable_by_name(model, \"my_var\")","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"To look up a collection of variables, do not use variable_by_name. Instead, register them using the model[:key] = value syntax:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> model[:x] = @variable(model, [i = 1:2], base_name = \"my_var\")\n2-element Vector{VariableRef}:\n my_var[1]\n my_var[2]\n\njulia> model[:x]\n2-element Vector{VariableRef}:\n my_var[1]\n my_var[2]","category":"page"},{"location":"manual/variables/#String-names,-symbolic-names,-and-bindings","page":"Variables","title":"String names, symbolic names, and bindings","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"It's common for new users to experience confusion relating to JuMP variables. Part of the problem is the overloaded use of \"variable\" in mathematical optimization, along with the difference between the name that a variable is registered under and the String name used for printing.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Here's a summary of the differences:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP variables are created using @variable.\nJuMP variables can be named or anonymous.\nNamed JuMP variables have the form @variable(model, x). For named variables:\nThe String name of the variable is set to \"x\".\nA Julia variable x is created that binds x to  the JuMP variable.\nThe name :x is registered as a key in the model with the value x.\nAnonymous JuMP variables have the form x = @variable(model). For anonymous variables:\nThe String name of the variable is set to \"\". When printed, this is replaced with \"_[i]\" where i is the index of the variable.\nYou control the name of the Julia variable used as the binding.\nNo name is registered as a key in the model.\nThe base_name keyword can override the String name of the variable.\nYou can manually register names in the model via model[:key] = value","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Here's an example that should make things clearer:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> x_binding = @variable(model, base_name = \"x\")\nx\n\njulia> model\nA JuMP Model\nFeasibility problem with:\nVariable: 1\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> x\nERROR: UndefVarError: x not defined\n\njulia> x_binding\nx\n\njulia> name(x_binding)\n\"x\"\n\njulia> model[:x_register] = x_binding\nx\n\njulia> model\nA JuMP Model\nFeasibility problem with:\nVariable: 1\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: x_register\n\njulia> model[:x_register]\nx\n\njulia> model[:x_register] === x_binding\ntrue\n\njulia> x\nERROR: UndefVarError: x not defined","category":"page"},{"location":"manual/variables/#Create,-delete,-and-modify-variable-bounds","page":"Variables","title":"Create, delete, and modify variable bounds","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Query whether a variable has a bound using has_lower_bound, has_upper_bound, and is_fixed:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> has_lower_bound(x_free)\nfalse\n\njulia> has_upper_bound(x_upper)\ntrue\n\njulia> is_fixed(x_fixed)\ntrue","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"If a variable has a particular bound, query the value of it using lower_bound, upper_bound, and fix_value:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> lower_bound(x_interval)\n2.0\n\njulia> upper_bound(x_interval)\n3.0\n\njulia> fix_value(x_fixed)\n4.0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Querying the value of a bound that does not exist will result in an error.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Delete variable bounds using delete_lower_bound, delete_upper_bound, and unfix:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> delete_lower_bound(x_lower)\n\njulia> has_lower_bound(x_lower)\nfalse\n\njulia> delete_upper_bound(x_upper)\n\njulia> has_upper_bound(x_upper)\nfalse\n\njulia> unfix(x_fixed)\n\njulia> is_fixed(x_fixed)\nfalse","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Set or update variable bounds using set_lower_bound, set_upper_bound, and fix:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> set_lower_bound(x_lower, 1.1)\n\njulia> set_upper_bound(x_upper, 2.1)\n\njulia> fix(x_fixed, 4.1)","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Fixing a variable with existing bounds will throw an error. To delete the bounds prior to fixing, use fix(variable, value; force = true).","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x >= 1)\nx\n\njulia> fix(x, 2)\nERROR: Unable to fix x to 2 because it has existing variable bounds. Consider calling `JuMP.fix(variable, value; force=true)` which will delete existing bounds before fixing the variable.\n\njulia> fix(x, 2; force = true)\n\n\njulia> fix_value(x)\n2.0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"tip: Tip\nUse fix instead of @constraint(model, x == 2). The former modifies variable bounds, while the latter adds a new linear constraint to the problem.","category":"page"},{"location":"manual/variables/#Binary-variables","page":"Variables","title":"Binary variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Binary variables are constrained to the set x in 0 1.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Create a binary variable by passing Bin as an optional positional argument:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, Bin)\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Check if a variable is binary using is_binary:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> is_binary(x)\ntrue","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Delete a binary constraint using unset_binary:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> unset_binary(x)\n\njulia> is_binary(x)\nfalse","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Binary variables can also be created by setting the binary keyword to true:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, binary=true)\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"or by using set_binary:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x)\nx\n\njulia> set_binary(x)","category":"page"},{"location":"manual/variables/#Integer-variables","page":"Variables","title":"Integer variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Integer variables are constrained to the set x in mathbbZ.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Create an integer variable by passing Int as an optional positional argument:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, Int)\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Check if a variable is integer using is_integer:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> is_integer(x)\ntrue","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Delete an integer constraint using unset_integer.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> unset_integer(x)\n\njulia> is_integer(x)\nfalse","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Integer variables can also be created by setting the integer keyword to true:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, integer=true)\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"or by using set_integer:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x)\nx\n\njulia> set_integer(x)","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"tip: Tip\nThe relax_integrality function relaxes all integrality constraints in the model, returning a function that can be called to undo the operation later on.","category":"page"},{"location":"manual/variables/#Start-values","page":"Variables","title":"Start values","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"There are two ways to provide a primal starting solution (also called MIP-start or a warmstart) for each variable:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"using the start keyword in the @variable macro\nusing set_start_value","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The starting value of a variable can be queried using start_value. If no start value has been set, start_value will return nothing.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x)\nx\n\njulia> start_value(x)\n\njulia> @variable(model, y, start = 1)\ny\n\njulia> start_value(y)\n1.0\n\njulia> set_start_value(y, 2)\n\njulia> start_value(y)\n2.0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"warning: Warning\nSome solvers do not support start values. If a solver does not support start values, an MathOptInterface.UnsupportedAttribute{MathOptInterface.VariablePrimalStart} error will be thrown.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"tip: Tip\nTo set the optimal solution from a previous solve as a new starting value, use all_variables to get a vector of all the variables in the model, then run:x = all_variables(model)\nx_solution = value.(x)\nset_start_value.(x, x_solution)","category":"page"},{"location":"manual/variables/#delete_a_variable","page":"Variables","title":"Delete a variable","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Use delete to delete a variable from a model. Use is_valid to check if a variable belongs to a model and has not been deleted.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x)\nx\n\njulia> is_valid(model, x)\ntrue\n\njulia> delete(model, x)\n\njulia> is_valid(model, x)\nfalse","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Deleting a variable does not unregister the corresponding name from the model. Therefore, creating a new variable of the same name will throw an error:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x)\nERROR: An object of name x is already attached to this model. If this\n    is intended, consider using the anonymous construction syntax, e.g.,\n    `x = @variable(model, [1:N], ...)` where the name of the object does\n    not appear inside the macro.\n\n    Alternatively, use `unregister(model, :x)` to first unregister\n    the existing name from the model. Note that this will not delete the\n    object; it will just remove the reference at `model[:x]`.\n[...]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"After calling delete, call unregister to remove the symbolic reference:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> unregister(model, :x)\n\njulia> @variable(model, x)\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"info: Info\ndelete does not automatically unregister because we do not distinguish between names that are automatically registered by JuMP macros and names that are manually registered by the user by setting values in object_dictionary. In addition, deleting a variable and then adding a new variable of the same name is an easy way to introduce bugs into your code.","category":"page"},{"location":"manual/variables/#Variable-containers","page":"Variables","title":"Variable containers","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP provides a mechanism for creating collections of variables in three types of data structures, which we refer to as containers.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The three types are Arrays, DenseAxisArrays, and SparseAxisArrays. We explain each of these in the following.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"tip: Tip\nYou can read more about containers in the Containers section.","category":"page"},{"location":"manual/variables/#Arrays","page":"Variables","title":"Arrays","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We have already seen the creation of an array of JuMP variables with the x[1:2] syntax. This can be extended to create multi-dimensional arrays of JuMP variables. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2])\n2×2 Matrix{VariableRef}:\n x[1,1]  x[1,2]\n x[2,1]  x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Arrays of JuMP variables can be indexed and sliced as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x[1, 2]\nx[1,2]\n\njulia> x[2, :]\n2-element Vector{VariableRef}:\n x[2,1]\n x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Variable bounds can depend upon the indices:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=1:2, j=1:2] >= 2i + j)\n2×2 Matrix{VariableRef}:\n x[1,1]  x[1,2]\n x[2,1]  x[2,2]\n\njulia> lower_bound.(x)\n2×2 Matrix{Float64}:\n 3.0  4.0\n 5.0  6.0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP will form an Array of JuMP variables when it can determine at compile time that the indices are one-based integer ranges. Therefore x[1:b] will create an Array of JuMP variables, but x[a:b] will not. If JuMP cannot determine that the indices are one-based integer ranges (for example, in the case of x[a:b]), JuMP will create a DenseAxisArray instead.","category":"page"},{"location":"manual/variables/#variable_jump_arrays","page":"Variables","title":"DenseAxisArrays","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We often want to create arrays where the indices are not one-based integer ranges. For example, we may want to create a variable indexed by the name of a product or a location. The syntax is the same as that above, except with an arbitrary vector as an index as opposed to a one-based range. The biggest difference is that instead of returning an Array of JuMP variables, JuMP will return a DenseAxisArray. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, [:A,:B]])\n2-dimensional DenseAxisArray{VariableRef,2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, [:A, :B]\nAnd data, a 2×2 Matrix{VariableRef}:\n x[1,A]  x[1,B]\n x[2,A]  x[2,B]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"DenseAxisArrays can be indexed and sliced as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x[1, :A]\nx[1,A]\n\njulia> x[2, :]\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, [:A, :B]\nAnd data, a 2-element Vector{VariableRef}:\n x[2,A]\n x[2,B]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Bounds can depend upon indices:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=2:3, j=1:2:3] >= 0.5i + j)\n2-dimensional DenseAxisArray{VariableRef,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, 1:2:3\nAnd data, a 2×2 Matrix{VariableRef}:\n x[2,1]  x[2,3]\n x[3,1]  x[3,3]\n\njulia> lower_bound.(x)\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, 1:2:3\nAnd data, a 2×2 Matrix{Float64}:\n 2.0  4.0\n 2.5  4.5","category":"page"},{"location":"manual/variables/#variable_sparseaxisarrays","page":"Variables","title":"SparseAxisArrays","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The third container type that JuMP natively supports is SparseAxisArray. These arrays are created when the indices do not form a rectangular set. For example, this applies when indices have a dependence upon previous indices (called triangular indexing). JuMP supports this as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=1:2, j=i:2])\nJuMP.Containers.SparseAxisArray{VariableRef, 2, Tuple{Int64, Int64}} with 3 entries:\n  [1, 1]  =  x[1,1]\n  [1, 2]  =  x[1,2]\n  [2, 2]  =  x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We can also conditionally create variables via a JuMP-specific syntax. This syntax appends a comparison check that depends upon the named indices and is separated from the indices by a semi-colon (;). For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=1:4; mod(i, 2)==0])\nJuMP.Containers.SparseAxisArray{VariableRef, 1, Tuple{Int64}} with 2 entries:\n  [2]  =  x[2]\n  [4]  =  x[4]","category":"page"},{"location":"manual/variables/#Performance-considerations","page":"Variables","title":"Performance considerations","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"When using the semi-colon as a filter, JuMP iterates over all indices and evaluates the conditional for each combination. If there are many index dimensions and a large amount of sparsity, this can be inefficient.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> N = 10\n10\n\njulia> S = [(1, 1, 1), (N, N, N)]\n2-element Vector{Tuple{Int64, Int64, Int64}}:\n (1, 1, 1)\n (10, 10, 10)\n\njulia> @time @variable(model, x1[i=1:N, j=1:N, k=1:N; (i, j, k) in S])\n  0.203861 seconds (392.22 k allocations: 23.977 MiB, 99.10% compilation time)\nJuMP.Containers.SparseAxisArray{VariableRef, 3, Tuple{Int64, Int64, Int64}} with 2 entries:\n  [1, 1, 1   ]  =  x1[1,1,1]\n  [10, 10, 10]  =  x1[10,10,10]\n\njulia> @time @variable(model, x2[S])\n  0.045407 seconds (65.24 k allocations: 3.771 MiB, 99.15% compilation time)\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, [(1, 1, 1), (10, 10, 10)]\nAnd data, a 2-element Vector{VariableRef}:\n x2[(1, 1, 1)]\n x2[(10, 10, 10)]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The first option is slower because it is equivalent to:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"x1 = Dict()\nfor i in 1:N\n    for j in 1:N\n        for k in 1:N\n            if (i, j, k) in S\n                x1[i, j, k] = @variable(model)\n            end\n        end\n    end\nend","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"If performance is a concern, explicitly construct the set of indices instead of using the filtering syntax.","category":"page"},{"location":"manual/variables/#variable_forcing","page":"Variables","title":"Forcing the container type","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"When creating a container of JuMP variables, JuMP will attempt to choose the tightest container type that can store the JuMP variables. Thus, it will prefer to create an Array before a DenseAxisArray and a DenseAxisArray before a SparseAxisArray. However, because this happens at compile time, JuMP does not always make the best choice. To illustrate this, consider the following example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> A = 1:2\n1:2\n\njulia> @variable(model, x[A])\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, 1:2\nAnd data, a 2-element Vector{VariableRef}:\n x[1]\n x[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Since the value (and type) of A is unknown at parsing time, JuMP is unable to infer that A is a one-based integer range. Therefore, JuMP creates a DenseAxisArray, even though it could store these two variables in a standard one-dimensional Array.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We can share our knowledge that it is possible to store these JuMP variables as an array by setting the container keyword:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, y[A], container=Array)\n2-element Vector{VariableRef}:\n y[1]\n y[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP now creates a vector of JuMP variables instead of a DenseAxisArray. Choosing an invalid container type will throw an error.","category":"page"},{"location":"manual/variables/#User-defined-containers","page":"Variables","title":"User-defined containers","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"In addition to the built-in container types, you can create your own collections of JuMP variables.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"tip: Tip\nThis is a point that users often overlook: you are not restricted to the built-in container types in JuMP.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For example, the following code creates a dictionary with symmetric matrices as the values:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> variables = Dict{Symbol,Array{VariableRef,2}}(\n           key => @variable(model, [1:2, 1:2], Symmetric, base_name = \"$(key)\")\n           for key in [:A, :B]\n       )\nDict{Symbol, Matrix{VariableRef}} with 2 entries:\n  :A => [A[1,1] A[1,2]; A[1,2] A[2,2]]\n  :B => [B[1,1] B[1,2]; B[1,2] B[2,2]]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Another common scenario is a request to add variables to existing containers, for example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"using JuMP\nmodel = Model()\n@variable(model, x[1:2] >= 0)\n# Later I want to add\n@variable(model, x[3:4] >= 0)","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"This is not possible with the built-in JuMP container types. However, you can use regular Julia types instead:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"model = Model()\nx = model[:x] = @variable(model, [1:2], lower_bound = 0, base_name = \"x\")\nappend!(x, @variable(model, [1:2], lower_bound = 0, base_name = \"y\"))\nmodel[:x]\n\n# output\n\n4-element Vector{VariableRef}:\n x[1]\n x[2]\n y[1]\n y[2]","category":"page"},{"location":"manual/variables/#Semidefinite-variables","page":"Variables","title":"Semidefinite variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"A square symmetric matrix X is positive semidefinite if all eigenvalues are nonnegative.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Declare a matrix of JuMP variables to be positive semidefinite by passing PSD as an optional positional argument:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2], PSD)\n2×2 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"note: Note\nx must be a square 2-dimensional Array of JuMP variables; it cannot be a DenseAxisArray or a SparseAxisArray.","category":"page"},{"location":"manual/variables/#Symmetric-variables","page":"Variables","title":"Symmetric variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Declare a square matrix of JuMP variables to be symmetric by passing Symmetric  as an optional positional argument:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2], Symmetric)\n2×2 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"manual/variables/#variables","page":"Variables","title":"The @variables macro","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"If you have many @variable calls, JuMP provides the macro @variables that can improve readability:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variables(model, begin\n           x\n           y[i=1:2] >= i, (start = i, base_name = \"Y_$i\")\n           z, Bin\n       end)\n(x, VariableRef[Y_1[1], Y_2[2]], z)\n\njulia> print(model)\nFeasibility\nSubject to\n Y_1[1] ≥ 1.0\n Y_2[2] ≥ 2.0\n z binary","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The @variables macro returns a tuple of the variables that were defined.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"note: Note\nKeyword arguments must be contained within parentheses.","category":"page"},{"location":"manual/variables/#jump_variables_on_creation","page":"Variables","title":"Variables constrained on creation","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"All uses of the @variable macro documented so far translate into separate calls for variable creation and the adding of any bound or integrality constraints.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For example, @variable(model, x >= 0, Int), is equivalent to:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"@variable(model, x)\nset_lower_bound(x, 0.0)\nset_integer(x)","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Importantly, the bound and integrality constraints are added after the variable has been created.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"However, some solvers require a set specifying the variable domain to be given when the variable is first created. We say that these variables are constrained on creation.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Use in within @variable to access the special syntax for constraining variables on creation.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For example, the following creates a vector of variables that belong to the SecondOrderCone:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, y[1:3] in SecondOrderCone())\n3-element Vector{VariableRef}:\n y[1]\n y[2]\n y[3]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For contrast, the standard syntax is as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:3])\n3-element Vector{VariableRef}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in SecondOrderCone())\n[x[1], x[2], x[3]] ∈ MathOptInterface.SecondOrderCone(3)","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"An alternate syntax to x in Set is to use the set keyword of @variable. This is most useful when creating anonymous variables:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"x = @variable(model, [1:3], set = SecondOrderCone())","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"note: Note\nYou cannot delete the constraint associated with a variable constrained on creation.","category":"page"},{"location":"manual/variables/#Example:-positive-semidefinite-variables","page":"Variables","title":"Example: positive semidefinite variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"An alternative to the syntax in Semidefinite variables, declare a matrix of JuMP variables to be positive semidefinite using PSDCone:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2] in PSDCone())\n2×2 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"manual/variables/#Example:-symmetric-variables","page":"Variables","title":"Example: symmetric variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"As an alternative to the syntax in Symmetric variables, declare a matrix of JuMP variables to be symmetric using SymMatrixSpace:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2] in SymMatrixSpace())\n2×2 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"manual/variables/#Example:-skew-symmetric-variables","page":"Variables","title":"Example: skew-symmetric variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Declare a matrix of JuMP variables to be skew-symmetric using SkewSymmetricMatrixSpace:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2] in SkewSymmetricMatrixSpace())\n2×2 Matrix{AffExpr}:\n 0        x[1,2]\n -x[1,2]  0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Note that even though x is 2 by 2, only one decision variable is added to model; the remaining elements in x are linear transformations of the single variable.","category":"page"},{"location":"manual/variables/#Why-use-variables-constrained-on-creation?","page":"Variables","title":"Why use variables constrained on creation?","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For most users, it does not matter if you use the constrained on creation syntax. Therefore, use whatever syntax you find most convenient.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"However, if you use direct_model, you may be forced to use the constrained on creation syntax.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The technical difference between variables constrained on creation and the standard JuMP syntax is that variables constrained on creation calls MOI.add_constrained_variables, while the standard JuMP syntax calls MOI.add_variables and then MOI.add_constraint.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Consult the implementation of solver package you are using to see if your solver requires MOI.add_constrained_variables.","category":"page"},{"location":"moi/reference/constraints/","page":"Constraints","title":"Constraints","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/constraints/#constraints_ref","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"moi/reference/constraints/#Types","page":"Constraints","title":"Types","text":"","category":"section"},{"location":"moi/reference/constraints/","page":"Constraints","title":"Constraints","text":"ConstraintIndex","category":"page"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintIndex","page":"Constraints","title":"MathOptInterface.ConstraintIndex","text":"ConstraintIndex{F, S}\n\nA type-safe wrapper for Int64 for use in referencing F-in-S constraints in a model. The parameter F is the type of the function in the constraint, and the parameter S is the type of set in the constraint. To allow for deletion, indices need not be consecutive. Indices within a constraint type (i.e. F-in-S) must be unique, but non-unique indices across different constraint types are allowed. If F is VariableIndex then the index is equal to the index of the variable. That is for an index::ConstraintIndex{VariableIndex}, we always have\n\nindex.value == MOI.get(model, MOI.ConstraintFunction(), index).value\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#Functions","page":"Constraints","title":"Functions","text":"","category":"section"},{"location":"moi/reference/constraints/","page":"Constraints","title":"Constraints","text":"is_valid(::ModelLike,::ConstraintIndex)\nadd_constraint\nadd_constraints\ntransform\nsupports_constraint","category":"page"},{"location":"moi/reference/constraints/#MathOptInterface.is_valid-Tuple{MathOptInterface.ModelLike, MathOptInterface.ConstraintIndex}","page":"Constraints","title":"MathOptInterface.is_valid","text":"is_valid(model::ModelLike, index::Index)::Bool\n\nReturn a Bool indicating whether this index refers to a valid object in the model model.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/constraints/#MathOptInterface.add_constraint","page":"Constraints","title":"MathOptInterface.add_constraint","text":"add_constraint(model::ModelLike, func::F, set::S)::ConstraintIndex{F,S} where {F,S}\n\nAdd the constraint f(x) in mathcalS where f is defined by func, and mathcalS is defined by set.\n\nadd_constraint(model::ModelLike, v::VariableIndex, set::S)::ConstraintIndex{VariableIndex,S} where {S}\nadd_constraint(model::ModelLike, vec::Vector{VariableIndex}, set::S)::ConstraintIndex{VectorOfVariables,S} where {S}\n\nAdd the constraint v in mathcalS where v is the variable (or vector of variables) referenced by v and mathcalS is defined by set.\n\nAn UnsupportedConstraint error is thrown if model does not support F-in-S constraints,\na AddConstraintNotAllowed error is thrown if it supports F-in-S constraints but it cannot add the constraint(s) in its current state and\na ScalarFunctionConstantNotZero error may be thrown if func is an AbstractScalarFunction with nonzero constant and set is EqualTo, GreaterThan, LessThan or Interval.\na LowerBoundAlreadySet error is thrown if F is a VariableIndex and a constraint was already added to this variable that sets a lower bound.\na UpperBoundAlreadySet error is thrown if F is a VariableIndex and a constraint was already added to this variable that sets an upper bound.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/constraints/#MathOptInterface.add_constraints","page":"Constraints","title":"MathOptInterface.add_constraints","text":"add_constraints(model::ModelLike, funcs::Vector{F}, sets::Vector{S})::Vector{ConstraintIndex{F,S}} where {F,S}\n\nAdd the set of constraints specified by each function-set pair in funcs and sets. F and S should be concrete types. This call is equivalent to add_constraint.(model, funcs, sets) but may be more efficient.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/constraints/#MathOptInterface.transform","page":"Constraints","title":"MathOptInterface.transform","text":"Transform Constraint Set\n\ntransform(model::ModelLike, c::ConstraintIndex{F,S1}, newset::S2)::ConstraintIndex{F,S2}\n\nReplace the set in constraint c with newset. The constraint index c will no longer be valid, and the function returns a new constraint index with the correct type.\n\nSolvers may only support a subset of constraint transforms that they perform efficiently (for example, changing from a LessThan to GreaterThan set). In addition, set modification (where S1 = S2) should be performed via the modify function.\n\nTypically, the user should delete the constraint and add a new one.\n\nExamples\n\nIf c is a ConstraintIndex{ScalarAffineFunction{Float64},LessThan{Float64}},\n\nc2 = transform(model, c, GreaterThan(0.0))\ntransform(model, c, LessThan(0.0)) # errors\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/constraints/#MathOptInterface.supports_constraint","page":"Constraints","title":"MathOptInterface.supports_constraint","text":"MOI.supports_constraint(\n    BT::Type{<:AbstractBridge},\n    F::Type{<:MOI.AbstractFunction},\n    S::Type{<:MOI.AbstractSet},\n)::Bool\n\nReturn a Bool indicating whether the bridges of type BT support bridging F-in-S constraints.\n\n\n\n\n\nsupports_constraint(\n    model::ModelLike,\n    ::Type{F},\n    ::Type{S},\n)::Bool where {F<:AbstractFunction,S<:AbstractSet}\n\nReturn a Bool indicating whether model supports F-in-S constraints, that is, copy_to(model, src) does not throw UnsupportedConstraint when src contains F-in-S constraints. If F-in-S constraints are only not supported in specific circumstances, e.g. F-in-S constraints cannot be combined with another type of constraint, it should still return true.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/constraints/#Attributes","page":"Constraints","title":"Attributes","text":"","category":"section"},{"location":"moi/reference/constraints/","page":"Constraints","title":"Constraints","text":"AbstractConstraintAttribute\nConstraintName\nConstraintPrimalStart\nConstraintDualStart\nConstraintPrimal\nConstraintDual\nConstraintBasisStatus\nBasisStatusCode\nConstraintFunction\nCanonicalConstraintFunction\nConstraintSet","category":"page"},{"location":"moi/reference/constraints/#MathOptInterface.AbstractConstraintAttribute","page":"Constraints","title":"MathOptInterface.AbstractConstraintAttribute","text":"AbstractConstraintAttribute\n\nAbstract supertype for attribute objects that can be used to set or get attributes (properties) of constraints in the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintName","page":"Constraints","title":"MathOptInterface.ConstraintName","text":"ConstraintName()\n\nA constraint attribute for a string identifying the constraint.\n\nIt is valid for constraints variables to have the same name; however, constraints with duplicate names cannot be looked up using get, regardless of whether they have the same F-in-S type.\n\nConstraintName has a default value of \"\" if not set.\n\nNotes\n\nYou should not implement ConstraintName for VariableIndex constraints.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintPrimalStart","page":"Constraints","title":"MathOptInterface.ConstraintPrimalStart","text":"ConstraintPrimalStart()\n\nA constraint attribute for the initial assignment to some constraint's ConstraintPrimal that the optimizer may use to warm-start the solve.\n\nMay be nothing (unset), a number for AbstractScalarFunction, or a vector for AbstractVectorFunction.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintDualStart","page":"Constraints","title":"MathOptInterface.ConstraintDualStart","text":"ConstraintDualStart()\n\nA constraint attribute for the initial assignment to some constraint's ConstraintDual that the optimizer may use to warm-start the solve.\n\nMay be nothing (unset), a number for AbstractScalarFunction, or a vector for AbstractVectorFunction.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintPrimal","page":"Constraints","title":"MathOptInterface.ConstraintPrimal","text":"ConstraintPrimal(result_index::Int = 1)\n\nA constraint attribute for the assignment to some constraint's primal value(s) in result result_index.\n\nIf the constraint is f(x) in S, then in most cases the ConstraintPrimal is the value of f, evaluated at the correspondng VariablePrimal solution.\n\nHowever, some conic solvers reformulate b - Ax in S to s = b - Ax, s in S. These solvers may return the value of s for ConstraintPrimal, rather than b - Ax. (Although these are constrained by an equality constraint, due to numerical tolerances they may not be identical.)\n\nIf the solver does not have a primal value for the constraint because the result_index is beyond the available solutions (whose number is indicated by the ResultCount attribute), getting this attribute must throw a ResultIndexBoundsError. Otherwise, if the result is unavailable for another reason (for instance, only a dual solution is available), the result is undefined. Users should first check PrimalStatus before accessing the ConstraintPrimal attribute.\n\nIf result_index is omitted, it is 1 by default. See ResultCount for information on how the results are ordered.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintDual","page":"Constraints","title":"MathOptInterface.ConstraintDual","text":"ConstraintDual(result_index::Int = 1)\n\nA constraint attribute for the assignment to some constraint's dual value(s) in result result_index. If result_index is omitted, it is 1 by default.\n\nIf the solver does not have a dual value for the variable because the result_index is beyond the available solutions (whose number is indicated by the ResultCount attribute), getting this attribute must throw a ResultIndexBoundsError. Otherwise, if the result is unavailable for another reason (for instance, only a primal solution is available), the result is undefined. Users should first check DualStatus before accessing the ConstraintDual attribute.\n\nSee ResultCount for information on how the results are ordered.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintBasisStatus","page":"Constraints","title":"MathOptInterface.ConstraintBasisStatus","text":"ConstraintBasisStatus(result_index::Int = 1)\n\nA constraint attribute for the BasisStatusCode of some constraint in result result_index, with respect to an available optimal solution basis. If result_index is omitted, it is 1 by default.\n\nIf the solver does not have a basis statue for the constraint because the result_index is beyond the available solutions (whose number is indicated by the ResultCount attribute), getting this attribute must throw a ResultIndexBoundsError. Otherwise, if the result is unavailable for another reason (for instance, only a dual solution is available), the result is undefined. Users should first check PrimalStatus before accessing the ConstraintBasisStatus attribute.\n\nSee ResultCount for information on how the results are ordered.\n\nNotes\n\nFor the basis status of a variable, query VariableBasisStatus.\n\nConstraintBasisStatus does not apply to VariableIndex constraints. You can infer the basis status of a VariableIndex constraint by looking at the result of VariableBasisStatus.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.BasisStatusCode","page":"Constraints","title":"MathOptInterface.BasisStatusCode","text":"BasisStatusCode\n\nAn Enum of possible values for the ConstraintBasisStatus and VariableBasisStatus attributes, explaining the status of a given element with respect to an optimal solution basis.\n\nPossible values are:\n\nBASIC: element is in the basis\nNONBASIC: element is not in the basis\nNONBASIC_AT_LOWER: element is not in the basis and is at its lower bound\nNONBASIC_AT_UPPER: element is not in the basis and is at its upper bound\nSUPER_BASIC: element is not in the basis but is also not at one of its bounds\n\nNotes\n\nNONBASIC_AT_LOWER and NONBASIC_AT_UPPER should be used only for constraints with the Interval set. In this case, they are necessary to distinguish which side of the constraint is active. One-sided constraints (e.g., LessThan and GreaterThan) should use NONBASIC instead of the NONBASIC_AT_* values. This restriction does not apply to VariableBasisStatus, which should return NONBASIC_AT_* regardless of whether the alternative bound exists.\nIn linear programs, SUPER_BASIC occurs when a variable with no bounds is not in the basis.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintFunction","page":"Constraints","title":"MathOptInterface.ConstraintFunction","text":"ConstraintFunction()\n\nA constraint attribute for the AbstractFunction object used to define the constraint. It is guaranteed to be equivalent but not necessarily identical to the function provided by the user.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.CanonicalConstraintFunction","page":"Constraints","title":"MathOptInterface.CanonicalConstraintFunction","text":"CanonicalConstraintFunction()\n\nA constraint attribute for a canonical representation of the AbstractFunction object used to define the constraint. Getting this attribute is guaranteed to return a function that is equivalent but not necessarily identical to the function provided by the user.\n\nBy default, MOI.get(model, MOI.CanonicalConstraintFunction(), ci) fallbacks to MOI.Utilities.canonical(MOI.get(model, MOI.ConstraintFunction(), ci)). However, if model knows that the constraint function is canonical then it can implement a specialized method that directly return the function without calling Utilities.canonical. Therefore, the value returned cannot be assumed to be a copy of the function stored in model. Moreover, Utilities.Model checks with Utilities.is_canonical whether the function stored internally is already canonical and if it's the case, then it returns the function stored internally instead of a copy.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintSet","page":"Constraints","title":"MathOptInterface.ConstraintSet","text":"ConstraintSet()\n\nA constraint attribute for the AbstractSet object used to define the constraint.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/algorithms/tsp_lazy_constraints.jl\"","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"SOFTWARE.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/#tsp_lazy","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"","category":"section"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Originally Contributed by: Daniel Schermer","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"This tutorial describes how to implement the Traveling Salesperson Problem in JuMP using solver-independent lazy constraints that dynamically separate subtours. To be more precise, we use lazy constraints to cut off infeasible subtours only when necessary and not before needed.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"It uses the following packages:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"using JuMP\nimport GLPK\nimport Random\nimport Plots","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/#tsp_model","page":"Traveling Salesperson Problem","title":"Mathematical Formulation","text":"","category":"section"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Assume that we are given a complete graph mathcalG(VE) where V is the set of vertices (or cities) and E is the set of edges (or roads). For each pair of vertices i j in V i neq j the edge (ij) in E is associated with a weight (or distance) d_ij in mathbbR^+.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"For this tutorial, we assume the problem to be symmetric, that is, d_ij = d_ji  forall ij in V.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"In the Traveling Salesperson Problem, we are tasked with finding a tour with minimal length that visits every vertex exactly once and then returns to the point of origin, that is, a hamiltonian cycle with minimal weight.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"To model the problem, we introduce a binary variable, x_ij in 01  forall i j in V, that indicates if edge (ij) is part of the tour or not. Using these variables, the Traveling Salesperson Problem can be modeled as the following integer linear program.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/#tsp_objective","page":"Traveling Salesperson Problem","title":"Objective Function","text":"","category":"section"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"The objective is to minimize the length of the tour (due to the assumed symmetry, the second sum only contains ij):","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"textmin  sum_i in V  sum_j in V i  j d_ij x_ij","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Note that it is also possible to use the following objective function instead:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"textmin  sum_i in V  sum_j in V dfracd_ij x_ij2","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/#tsp_constraints","page":"Traveling Salesperson Problem","title":"Constraints","text":"","category":"section"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"There are four classes of constraints in our formulation.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"First, due to the presumed symmetry, the following constraints must hold:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"x_ij = x_ji quad forall ij in V","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Second, for each vertex i, exactly two edges must be selected that connect it to other vertices j in the graph G:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"sum_j in V x_ij = 2 quad forall i in V","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Third, we do not permit loops to occur:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"x_ii = 0 quad forall i in V","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"The fourth constraint is more complicated. A major difficulty of the Traveling Salesperson Problem arises from the fact that we need to prevent subtours, that is, several distinct Hamiltonian cycles existing on subgraphs of G.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Note that the previous constraints do not guarantee that the solution will be free of subtours. To this end, by S we label a subset of vertices. Then, for each proper subset S subset V, the following constraints guarantee that no subtour may occur:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"sum_i in S sum_j in S i  j x_ij leq vert S vert - 1 quad forall S subset V","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Problematically, we require exponentially many of these constraints as vert V vert increases. Therefore, we will add these constraints only when necessary.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/#tsp_implementation","page":"Traveling Salesperson Problem","title":"Implementation","text":"","category":"section"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"There are two ways we can eliminate subtours in JuMP, both of which will be shown in what follows:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"iteratively solving a new model that incorporates previously identified subtours,\nor adding violated subtours as lazy constraints.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/#Data","page":"Traveling Salesperson Problem","title":"Data","text":"","category":"section"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"The vertices are assumed to be randomly distributed in the Euclidean space; thus, the weight (distance) of each edge is defined as follows.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"function generate_distance_matrix(n; random_seed = 1)\n    Random.seed!(random_seed)\n    X = 100 * rand(n)\n    Y = 100 * rand(n)\n    d = [sqrt((X[i] - X[j])^2 + (Y[i] - Y[j])^2) for i in 1:n, j in 1:n]\n    return X, Y, d\nend\n\nn = 40\nX, Y, d = generate_distance_matrix(n)","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"For the JuMP model, we first initialize the model object. Then, we create the binary decision variables and add the objective function and constraints. By defining the x matrix as Symmetric, we do not need to add explicit constraints that x[i, j] == x[j, i].","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"function build_tsp_model(d, n)\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:n, 1:n], Bin, Symmetric)\n    @objective(model, Min, sum(d .* x) / 2)\n    @constraint(model, [i in 1:n], sum(x[i, :]) == 2)\n    @constraint(model, [i in 1:n], x[i, i] == 0)\n    return model\nend","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"To search for violated constraints, based on the edges that are currently in the solution (that is, those that have value x_ij = 1), we identify the shortest cycle through the function subtour(). Whenever a subtour has been identified, a constraint corresponding to the form above can be added to the model.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"function subtour(edges::Vector{Tuple{Int,Int}}, n)\n    shortest_subtour, unvisited = collect(1:n), Set(collect(1:n))\n    while !isempty(unvisited)\n        this_cycle, neighbors = Int[], unvisited\n        while !isempty(neighbors)\n            current = pop!(neighbors)\n            push!(this_cycle, current)\n            if length(this_cycle) > 1\n                pop!(unvisited, current)\n            end\n            neighbors =\n                [j for (i, j) in edges if i == current && j in unvisited]\n        end\n        if length(this_cycle) < length(shortest_subtour)\n            shortest_subtour = this_cycle\n        end\n    end\n    return shortest_subtour\nend","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Let us declare a helper function selected_edges() that will be repeatedly used in what follows.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"function selected_edges(x::Matrix{Float64}, n)\n    return Tuple{Int,Int}[(i, j) for i in 1:n, j in 1:n if x[i, j] > 0.5]\nend","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Other helper functions for computing subtours:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"subtour(x::Matrix{Float64}) = subtour(selected_edges(x, size(x, 1)), size(x, 1))\nsubtour(x::AbstractMatrix{VariableRef}) = subtour(value.(x))","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/#Iterative-method","page":"Traveling Salesperson Problem","title":"Iterative method","text":"","category":"section"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"An iterative way of eliminating subtours is the following.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"However, it is reasonable to assume that this is not the most efficient way: Whenever a new subtour elimination constraint is added to the model, the optimization has to start from the very beginning.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"That way, the solver will repeatedly discard useful information encountered during previous solves (e.g., all cuts, the incumbent solution, or lower bounds).","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"info: Info\nNote that, in principle, it would also be feasible to add all subtours (instead of just the shortest one) to the model. However, preventing just the shortest cycle is often sufficient for breaking other subtours and will keep the model size smaller.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"iterative_model = build_tsp_model(d, n)\noptimize!(iterative_model)\ntime_iterated = solve_time(iterative_model)\ncycle = subtour(iterative_model[:x])\nwhile 1 < length(cycle) < n\n    println(\"Found cycle of length $(length(cycle))\")\n    S = [(i, j) for (i, j) in Iterators.product(cycle, cycle) if i < j]\n    @constraint(\n        iterative_model,\n        sum(iterative_model[:x][i, j] for (i, j) in S) <= length(cycle) - 1,\n    )\n    optimize!(iterative_model)\n    global time_iterated += solve_time(iterative_model)\n    global cycle = subtour(iterative_model[:x])\nend\n\nobjective_value(iterative_model)","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"time_iterated","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"As a quick sanity check, we visualize the optimal tour to verify that no subtour is present:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"function plot_tour(X, Y, x)\n    plt = Plots.plot()\n    for (i, j) in selected_edges(x, size(x, 1))\n        Plots.plot!([X[i], X[j]], [Y[i], Y[j]], legend = false)\n    end\n    return plt\nend\n\nplot_tour(X, Y, value.(iterative_model[:x]))","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/#Lazy-constraint-method","page":"Traveling Salesperson Problem","title":"Lazy constraint method","text":"","category":"section"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"A more sophisticated approach makes use of lazy constraints. To be more precise, we do this through the subtour_elimination_callback() below, which is only run whenever we encounter a new integer-feasible solution.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"lazy_model = build_tsp_model(d, n)\nfunction subtour_elimination_callback(cb_data)\n    status = callback_node_status(cb_data, lazy_model)\n    if status != MOI.CALLBACK_NODE_STATUS_INTEGER\n        return  # Only run at integer solutions\n    end\n    cycle = subtour(callback_value.(cb_data, lazy_model[:x]))\n    if !(1 < length(cycle) < n)\n        return  # Only add a constraint if there is a cycle\n    end\n    println(\"Found cycle of length $(length(cycle))\")\n    S = [(i, j) for (i, j) in Iterators.product(cycle, cycle) if i < j]\n    con = @build_constraint(\n        sum(lazy_model[:x][i, j] for (i, j) in S) <= length(cycle) - 1,\n    )\n    MOI.submit(lazy_model, MOI.LazyConstraint(cb_data), con)\n    return\nend\nMOI.set(lazy_model, MOI.LazyConstraintCallback(), subtour_elimination_callback)\noptimize!(lazy_model)\nobjective_value(lazy_model)","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"This finds the same optimal tour:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"plot_tour(X, Y, value.(lazy_model[:x]))","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Surprisingly, for this particular model with GLPK, the solution time is worse than the iterative method:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"time_lazy = solve_time(lazy_model)","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"In most other cases and solvers, however, the lazy time should be faster than the iterative method.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/linear/n-queens.jl\"","category":"page"},{"location":"tutorials/linear/n-queens/#N-Queens","page":"N-Queens","title":"N-Queens","text":"","category":"section"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"Originally Contributed by: Matthew Helm (with help from @mtanneau on Julia Discourse)","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"The N-Queens problem involves placing N queens on an N x N chessboard such that none of the queens attacks another. In chess, a queen can move vertically, horizontally, and diagonally so there cannot be more than one queen on any given row, column, or diagonal.","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"(Image: Four Queens)","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"Note that none of the queens above are able to attack any other as a result of their careful placement.","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"using JuMP\nimport GLPK\nimport LinearAlgebra","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"N-Queens","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"N = 8\n\nmodel = Model(GLPK.Optimizer)","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"Next, let's create an N x N chessboard of binary values. 0 will represent an empty space on the board and 1 will represent a space occupied by one of our queens:","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"@variable(model, x[1:N, 1:N], Bin)","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"Now we can add our constraints:","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"There must be exactly one queen in a given row/column","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"for i in 1:N\n    @constraint(model, sum(x[i, :]) == 1)\n    @constraint(model, sum(x[:, i]) == 1)\nend","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"There can only be one queen on any given diagonal","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"for i in -(N - 1):(N-1)\n    @constraint(model, sum(LinearAlgebra.diag(x, i)) <= 1)\n    @constraint(model, sum(LinearAlgebra.diag(reverse(x, dims = 1), i)) <= 1)\nend","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"That's it! We are ready to put our model to work and see if it is able to find a feasible solution:","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"optimize!(model)","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"We can now review the solution that our model found:","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"solution = convert.(Int, value.(x))","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"(Image: Four Queens)","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/FileFormats/overview/#The-FileFormats-submodule","page":"Overview","title":"The FileFormats submodule","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The FileFormats module provides functionality for reading and writing MOI models using write_to_file and read_from_file.","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Supported-file-types","page":"Overview","title":"Supported file types","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"You must read and write files to a FileFormats.Model object. Specifc the file-type by passing a FileFormats.FileFormat enum. For example:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The Conic Benchmark Format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_CBF)\nA Conic Benchmark Format (CBF) model","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The LP file format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_LP)\nA .LP-file model","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The MathOptFormat file format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MOF)\nA MathOptFormat Model","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The MPS file format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MPS)\nA Mathematical Programming System (MPS) model","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The NL file format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_NL)\nAn AMPL (.nl) model","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The SDPA file format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_SDPA)\nA SemiDefinite Programming Algorithm Format (SDPA) model","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Write-to-file","page":"Overview","title":"Write to file","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"To write a model src to a MathOptFormat file, use:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> src = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> MOI.add_variable(src)\nMathOptInterface.VariableIndex(1)\n\njulia> dest = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MOF)\nA MathOptFormat Model\n\njulia> MOI.copy_to(dest, src)\nMathOptInterface.Utilities.IndexMap with 1 entry:\n  VariableIndex(1) => VariableIndex(1)\n\njulia> MOI.write_to_file(dest, \"file.mof.json\")\n\njulia> print(read(\"file.mof.json\", String))\n{\n  \"name\": \"MathOptFormat Model\",\n  \"version\": {\n    \"major\": 1,\n    \"minor\": 0\n  },\n  \"variables\": [\n    {\n      \"name\": \"x1\"\n    }\n  ],\n  \"objective\": {\n    \"sense\": \"feasibility\"\n  },\n  \"constraints\": []\n}","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Read-from-file","page":"Overview","title":"Read from file","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"To read a MathOptFormat file, use:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> dest = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MOF)\nA MathOptFormat Model\n\njulia> MOI.read_from_file(dest, \"file.mof.json\")\n\njulia> MOI.get(dest, MOI.ListOfVariableIndices())\n1-element Vector{MathOptInterface.VariableIndex}:\n MathOptInterface.VariableIndex(1)\n\njulia> rm(\"file.mof.json\")  # Clean up after ourselves.","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Detecing-the-filetype-automatically","page":"Overview","title":"Detecing the filetype automatically","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"Instead of the format keyword, you can also use the filename keyword argument to FileFormats.Model. This will attempt to automatically guess the format from the file extension. For example:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> src = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> dest = MOI.FileFormats.Model(filename = \"file.cbf.gz\")\nA Conic Benchmark Format (CBF) model\n\njulia> MOI.copy_to(dest, src)\nMathOptInterface.Utilities.IndexMap()\n\njulia> MOI.write_to_file(dest, \"file.cbf.gz\")\n\njulia> src_2 = MOI.FileFormats.Model(filename = \"file.cbf.gz\")\nA Conic Benchmark Format (CBF) model\n\njulia> src = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> dest = MOI.FileFormats.Model(filename = \"file.cbf.gz\")\nA Conic Benchmark Format (CBF) model\n\njulia> MOI.copy_to(dest, src)\nMathOptInterface.Utilities.IndexMap()\n\njulia> MOI.write_to_file(dest, \"file.cbf.gz\")\n\njulia> src_2 = MOI.FileFormats.Model(filename = \"file.cbf.gz\")\nA Conic Benchmark Format (CBF) model\n\njulia> MOI.read_from_file(src_2, \"file.cbf.gz\")\n\njulia> rm(\"file.cbf.gz\")  # Clean up after ourselves.","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"Note how the compression format (GZip) is also automatically detected from the filename.","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Unsupported-constraints","page":"Overview","title":"Unsupported constraints","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"In some cases src may contain constraints that are not supported by the file format (e.g., the CBF format supports integer variables but not binary). If so, copy src to a bridged model using Bridges.full_bridge_optimizer:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"src = MOI.Utilities.Model{Float64}()\nx = MOI.add_variable(model)\nMOI.add_constraint(model, x, MOI.ZeroOne())\ndest = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_CBF)\nbridged = MOI.Bridges.full_bridge_optimizer(dest, Float64)\nMOI.copy_to(bridged, src)\nMOI.write_to_file(dest, \"my_model.cbf\")","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"note: Note\nEven after bridging, it may still not be possible to write the model to file because of unsupported constraints (e.g., PSD variables in the LP file format).","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Read-and-write-to-io","page":"Overview","title":"Read and write to io","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"In addition to write_to_file and read_from_file, you can read and write directly from IO streams using Base.write and Base.read!:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> src = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> dest = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MPS)\nA Mathematical Programming System (MPS) model\n\njulia> MOI.copy_to(dest, src)\nMathOptInterface.Utilities.IndexMap()\n\njulia> io = IOBuffer();\n\njulia> write(io, dest)\n\njulia> seekstart(io);\n\njulia> src_2 = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MPS)\nA Mathematical Programming System (MPS) model\n\njulia> read!(io, src_2);","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Validating-MOF-files","page":"Overview","title":"Validating MOF files","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"MathOptFormat files are governed by a schema. Use JSONSchema.jl to check if a .mof.json file satisfies the schema.","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"First, construct the schema object as follows:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> import JSON, JSONSchema\n\njulia> schema = JSONSchema.Schema(JSON.parsefile(MOI.FileFormats.MOF.SCHEMA_PATH))\nA JSONSchema","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"Then, check if a model file is valid using isvalid:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> good_model = JSON.parse(\"\"\"\n       {\n         \"version\": {\n           \"major\": 1,\n           \"minor\": 0\n         },\n         \"variables\": [{\"name\": \"x\"}],\n         \"objective\": {\"sense\": \"feasibility\"},\n         \"constraints\": []\n       }\n       \"\"\");\n\njulia> isvalid(good_model, schema)\ntrue","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"If we construct an invalid file, for example by mis-typing name as NaMe, the validation fails:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> bad_model = JSON.parse(\"\"\"\n       {\n         \"version\": {\n           \"major\": 1,\n           \"minor\": 0\n         },\n         \"variables\": [{\"NaMe\": \"x\"}],\n         \"objective\": {\"sense\": \"feasibility\"},\n         \"constraints\": []\n       }\n       \"\"\");\n\njulia> isvalid(bad_model, schema)\nfalse","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"Use JSONSchema.validate to obtain more insight into why the validation failed:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> JSONSchema.validate(bad_model, schema)\nValidation failed:\npath:         [variables][1]\ninstance:     Dict{String, Any}(\"NaMe\" => \"x\")\nschema key:   required\nschema value: Any[\"name\"]","category":"page"},{"location":"tutorials/nonlinear/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/nonlinear/mle.jl\"","category":"page"},{"location":"tutorials/nonlinear/mle/#Maximum-likelihood-estimation","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"","category":"section"},{"location":"tutorials/nonlinear/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"Use nonlinear optimization to compute the maximum likelihood estimate (MLE) of the parameters of a normal distribution, a.k.a., the sample mean and variance.","category":"page"},{"location":"tutorials/nonlinear/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"using JuMP\nimport Ipopt\nimport Random\nimport Statistics\nimport Test\n\nfunction example_mle(; verbose = true)\n    n = 1_000\n    Random.seed!(1234)\n    data = randn(n)\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, μ, start = 0.0)\n    @variable(model, σ >= 0.0, start = 1.0)\n    @NLobjective(\n        model,\n        Max,\n        n / 2 * log(1 / (2 * π * σ^2)) -\n        sum((data[i] - μ)^2 for i in 1:n) / (2 * σ^2)\n    )\n    optimize!(model)\n    if verbose\n        println(\"μ             = \", value(μ))\n        println(\"mean(data)    = \", Statistics.mean(data))\n        println(\"σ^2           = \", value(σ)^2)\n        println(\"var(data)     = \", Statistics.var(data))\n        println(\"MLE objective = \", objective_value(model))\n    end\n    Test.@test value(μ) ≈ Statistics.mean(data) atol = 1e-3\n    Test.@test value(σ)^2 ≈ Statistics.var(data) atol = 1e-2\n    # You can even do constrained MLE!\n    @NLconstraint(model, μ == σ^2)\n    optimize!(model)\n    Test.@test value(μ) ≈ value(σ)^2\n    if verbose\n        println()\n        println(\"With constraint μ == σ^2:\")\n        println(\"μ                         = \", value(μ))\n        println(\"σ^2                       = \", value(σ)^2)\n        println(\"Constrained MLE objective = \", objective_value(model))\n    end\n    return\nend\n\nexample_mle()","category":"page"},{"location":"tutorials/nonlinear/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"","category":"page"},{"location":"tutorials/nonlinear/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"should_i_use/#Should-I-use-JuMP?","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"","category":"section"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"JuMP is an algebraic modeling language for mathematical optimization written in the Julia language.","category":"page"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"This page explains when you should consider using JuMP, and importantly, when you should not use JuMP.","category":"page"},{"location":"should_i_use/#When-should-I-use-JuMP?","page":"Should I use JuMP?","title":"When should I use JuMP?","text":"","category":"section"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"You should use JuMP if you have a constrained optimization problem for which you can formulate:","category":"page"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"a set of decision variables\na scalar objective function\na set of constraints.","category":"page"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Key reasons to use JuMP include:","category":"page"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"User friendliness\nJuMP has syntax that mimics natural mathematical expressions. (See the section on algebraic modeling languages.)\nSpeed\nBenchmarking has shown that JuMP can create problems at similar speeds to special-purpose modeling languages such as AMPL.\nJuMP communicates with most solvers in memory, avoiding the need to write intermediary files.\nSolver independence\nJuMP uses a generic solver-independent interface provided by the MathOptInterface package, making it easy to change between a number of open-source and commercial optimization software packages (\"solvers\"). The Supported solvers section contains a table of the currently supported solvers.\nAccess to advanced algorithmic techniques\nJuMP supports efficient in-memory re-solves of linear programs, which previously required using solver-specific or low-level C++ libraries.\nJuMP provides access to solver-independent and solver-dependent Callbacks.\nEase of embedding\nJuMP itself is written purely in Julia. Solvers are the only binary dependencies.\nAutomated install of many solver dependencies.\nJuMP provides automatic installation of many open-source solvers. This is different to modeling languages in Python which require you to download and install a solver yourself.\nBeing embedded in a general-purpose programming language makes it easy to solve optimization problems as part of a larger workflow (e.g., inside a simulation, behind a web server, or as a subproblem in a decomposition algorithm).\nAs a trade-off, JuMP's syntax is constrained by the syntax available in Julia.\nJuMP is MPL licensed, meaning that it can be embedded in commercial software that complies with the terms of the license.","category":"page"},{"location":"should_i_use/#When-should-I-not-use-JuMP?","page":"Should I use JuMP?","title":"When should I not use JuMP?","text":"","category":"section"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"JuMP supports a broad range of optimization classes. However, there are still some that it doesn't support, or that are better supported by other software packages.","category":"page"},{"location":"should_i_use/#You-want-to-optimize-a-complicated-Julia-function","page":"Should I use JuMP?","title":"You want to optimize a complicated Julia function","text":"","category":"section"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Packages in Julia compose well. It's common for people to pick two unrelated packages and use them in conjunction to create novel behavior. JuMP isn't one of those packages.","category":"page"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"If you want to optimize a ordinary differential equation from DifferentialEquations.jl or tune a neural network from Flux.jl, consider using other packages such as:","category":"page"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Optim.jl\nGalacticOptim.jl\nNonconvex.jl","category":"page"},{"location":"should_i_use/#Black-box,-derivative-free,-or-unconstrained-optimization","page":"Should I use JuMP?","title":"Black-box, derivative free, or unconstrained optimization","text":"","category":"section"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"JuMP does support nonlinear programs with constraints and objectives containing user-defined functions. However, the functions must be automatically differentiable, or need to provide explicit derivatives. (See User-defined Functions for more information.)","category":"page"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"If your function is a black-box that is non-differentiable (e.g., the output of a simulation written in C++), JuMP is not the right tool for the job. This also applies if you want to use a derivative free method.","category":"page"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Even if your problem is differentiable, if it is unconstrained there is limited benefit (and downsides in the form of more overhead) to using JuMP over tools which are only concerned with function minimization.","category":"page"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Alternatives to consider are:","category":"page"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Optim.jl\nGalacticOptim.jl\nNLopt.jl","category":"page"},{"location":"should_i_use/#Multiobjective-programs","page":"Should I use JuMP?","title":"Multiobjective programs","text":"","category":"section"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"If your problem has more than one objective, JuMP is not the right tool for the job. However, we're working on fixing this!.","category":"page"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Alternatives to consider are:","category":"page"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"vOptGeneric.jl","category":"page"},{"location":"should_i_use/#Disciplined-convex-programming","page":"Should I use JuMP?","title":"Disciplined convex programming","text":"","category":"section"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"JuMP does not support disciplined convex programming (DCP).","category":"page"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Alternatives to consider are:","category":"page"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Convex.jl","category":"page"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"note: Note\nConvex.jl is also built on MathOptInterface, and shares the same set of underlying solvers. However, you input problems differently, and Convex.jl checks that the problem is DCP.","category":"page"},{"location":"should_i_use/#Stochastic-programming","page":"Should I use JuMP?","title":"Stochastic programming","text":"","category":"section"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"JuMP requires deterministic input data.","category":"page"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"If you have stochastic input data, consider using a JuMP extension such as:","category":"page"},{"location":"should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"InfiniteOpt.jl\nStochasticPrograms.jl\nSDDP.jl","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/getting_started/design_patterns_for_larger_models.jl\"","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Design-patterns-for-larger-models","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"JuMP makes it easy to build and solve optimization models. However, once you start to construct larger models, and especially ones that interact with external data sources or have customizable sets of variables and constraints based on client choices, you may find that your scripts become unwieldy. This tutorial demonstrates a variety of ways in which you can structure larger JuMP models to improve their readability and maintainability.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"tip: Tip\nThis tutorial is more advanced than the other \"Getting started\" tutorials. It's in the \"Getting started\" section to give you an early preview of how JuMP makes it easy to structure larger models. However, if you are new to JuMP you may want to briefly skim the tutorial, and come back to it once you have written a few JuMP models.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Overview","page":"Design patterns for larger models","title":"Overview","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"This tutorial uses explanation-by-example. We're going to start with a simple knapsack model, and then expand it to add various features and structure.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#A-simple-script","page":"Design patterns for larger models","title":"A simple script","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Your first prototype of a JuMP model is probably a script that uses a small set of hard-coded data.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"using JuMP, GLPK\nprofit = [5, 3, 2, 7, 4]\nweight = [2, 8, 4, 2, 5]\ncapacity = 10\nN = 5\nmodel = Model(GLPK.Optimizer)\n@variable(model, x[1:N], Bin)\n@objective(model, Max, sum(profit[i] * x[i] for i in 1:N))\n@constraint(model, sum(weight[i] * x[i] for i in 1:N) <= capacity)\noptimize!(model)\nvalue.(x)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"The benefits of this approach are:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"it is quick to code\nit is quick to make changes.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"The downsides include:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"all variables are global (read Performance tips)\nit is easy to introduce errors, e.g., having profit and weight be vectors of different lengths, or not match N\nthe solution, x[i], is hard to interpret without knowing the order in which we provided the data.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Wrap-the-model-in-a-fuction","page":"Design patterns for larger models","title":"Wrap the model in a fuction","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"A good next step is to wrap your model in a function. This is useful for a few reasons:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"it removes global variables\nit encapsulates the JuMP model and forces you to clarify your inputs and outputs\nwe can add some error checking.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function solve_knapsack_1(profit::Vector, weight::Vector, capacity::Real)\n    if length(profit) != length(weight)\n        throw(DimensionMismatch(\"profit and weight are different sizes\"))\n    end\n    N = length(weight)\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:N], Bin)\n    @objective(model, Max, sum(profit[i] * x[i] for i in 1:N))\n    @constraint(model, sum(weight[i] * x[i] for i in 1:N) <= capacity)\n    optimize!(model)\n    return value.(x)\nend\n\nsolve_knapsack_1([5, 3, 2, 7, 4], [2, 8, 4, 2, 5], 10)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Create-better-data-structures","page":"Design patterns for larger models","title":"Create better data structures","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Although we can check for errors like mis-matched vector lengths, if you start to develop models with a lot of data, keeping track of vectors and lengths and indices is fragile and a common source of bugs. A good solution is to use Julia's type system to create an abstraction over your data.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"For example, we can create a struct that represents a single object, with a constructor that lets us validate assumptions on the input data:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"struct KnapsackObject\n    profit::Float64\n    weight::Float64\n    function KnapsackObject(profit::Float64, weight::Float64)\n        if weight < 0\n            throw(DomainError(\"Weight of object cannot be negative\"))\n        end\n        return new(profit, weight)\n    end\nend","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"as well as a struct that holds a dictionary of objects and the knapsack's capacity:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"struct KnapsackData\n    objects::Dict{String,KnapsackObject}\n    capacity::Float64\nend","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Here's what our data might look like now:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"objects = Dict(\n    \"apple\" => KnapsackObject(5.0, 2.0),\n    \"banana\" => KnapsackObject(3.0, 8.0),\n    \"cherry\" => KnapsackObject(2.0, 4.0),\n    \"date\" => KnapsackObject(7.0, 2.0),\n    \"eggplant\" => KnapsackObject(4.0, 5.0),\n)\ndata = KnapsackData(objects, 10.0)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"If you want, you can add custom printing to make it easier to visualize:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function Base.show(io::IO, data::KnapsackData)\n    println(io, \"A knapsack with capacity $(data.capacity) and possible items:\")\n    for (k, v) in data.objects\n        println(\n            io,\n            \"  $(rpad(k, 8)) : profit = $(v.profit), weight = $(v.weight)\",\n        )\n    end\n    return\nend\n\ndata","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Then, we can re-write our solve_knapsack function to take our KnapsackData as input:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function solve_knapsack_2(data::KnapsackData)\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[keys(data.objects)], Bin)\n    @objective(model, Max, sum(v.profit * x[k] for (k, v) in data.objects))\n    @constraint(\n        model,\n        sum(v.weight * x[k] for (k, v) in data.objects) <= data.capacity,\n    )\n    optimize!(model)\n    return value.(x)\nend\n\nsolve_knapsack_2(data)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Read-in-data-from-files","page":"Design patterns for larger models","title":"Read in data from files","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Having a data structure is a good step. But it is still annoying that we have to hard-code the data into Julia. A good next step is to separate the data into an external file format; JSON is a common choice.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"The JuMP repository has a file we're going to use for this tutorial. To run this tutorial locally, download the file and then update data_filename as appropriate.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"To build this version of the JuMP documentation, we needed to set the filename:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"data_filename = joinpath(@__DIR__, \"data\", \"knapsack.json\");\nnothing #hide","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"knapsack.json has the following contents:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"println(read(data_filename, String))","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Now let's write a function that reads this file and builds a KnapsackData object:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"import JSON\n\nfunction read_data(filename)\n    d = JSON.parsefile(filename)\n    return KnapsackData(\n        Dict(\n            k => KnapsackObject(v[\"profit\"], v[\"weight\"]) for\n            (k, v) in d[\"objects\"]\n        ),\n        d[\"capacity\"],\n    )\nend\n\ndata = read_data(data_filename)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Add-options-via-if-else","page":"Design patterns for larger models","title":"Add options via if-else","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"At this point, we have data in a file format which we can load and solve a single problem. For many users, this might be sufficient. However, at some point you may be asked to add features like \"but what if I want to take more than one of a particular item?\"","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"If this is the first time that you've been asked to add a feature, adding options via if-else statements is a good approach. For example, we might write:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function solve_knapsack_3(data::KnapsackData; binary_knapsack::Bool)\n    model = Model(GLPK.Optimizer)\n    if binary_knapsack\n        @variable(model, x[keys(data.objects)], Bin)\n    else\n        @variable(model, x[keys(data.objects)] >= 0, Int)\n    end\n    @objective(model, Max, sum(v.profit * x[k] for (k, v) in data.objects))\n    @constraint(\n        model,\n        sum(v.weight * x[k] for (k, v) in data.objects) <= data.capacity,\n    )\n    optimize!(model)\n    return value.(x)\nend","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Now we can solve the binary knapsack:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"solve_knapsack_3(data; binary_knapsack = true)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"And an integer knapsack where we can take more than one copy of each item:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"solve_knapsack_3(data; binary_knapsack = false)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Add-configuation-options-via-dispatch","page":"Design patterns for larger models","title":"Add configuation options via dispatch","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"If you get repeated requests to add different options, you'll quickly find yourself in a mess of different flags and if-else statements. It's hard to write, hard to read, and hard to ensure you haven't introduced any bugs. A good solution is to use Julia's type dispatch to control the configuration of the model. The easiest way to explain this is by example.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"First, start by defining a new abstract type, as well as new subtypes for each of our options. These types are going to control the configuration of the knapsack model.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"abstract type AbstractConfiguration end\n\nstruct BinaryKnapsackConfig <: AbstractConfiguration end\n\nstruct IntegerKnapsackConfig <: AbstractConfiguration end","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Then, we rewrite our solve_knapsack function to take a config argument, and we introduce an add_knapsack_variables function to abstract the creation of our variables.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function solve_knapsack_4(data::KnapsackData, config::AbstractConfiguration)\n    model = Model(GLPK.Optimizer)\n    x = add_knapsack_variables(model, data, config)\n    @objective(model, Max, sum(v.profit * x[k] for (k, v) in data.objects))\n    @constraint(\n        model,\n        sum(v.weight * x[k] for (k, v) in data.objects) <= data.capacity,\n    )\n    optimize!(model)\n    return value.(x)\nend","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"For the binary knapsack problem, add_knapsack_variables looks like this:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function add_knapsack_variables(\n    model::Model,\n    data::KnapsackData,\n    ::BinaryKnapsackConfig,\n)\n    return @variable(model, x[keys(data.objects)], Bin)\nend","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"For the integer knapsack problem, add_knapsack_variables looks like this:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function add_knapsack_variables(\n    model::Model,\n    data::KnapsackData,\n    ::IntegerKnapsackConfig,\n)\n    return @variable(model, x[keys(data.objects)] >= 0, Int)\nend","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Now we can solve the binary knapsack:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"solve_knapsack_4(data, BinaryKnapsackConfig())","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"and the integer knapsack problem:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"solve_knapsack_4(data, IntegerKnapsackConfig())","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"The main benefit of the dispatch approach is that you can quickly add new options without needing to modify the existing code. For example:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"struct UpperBoundedKnapsackConfig <: AbstractConfiguration\n    limit::Int\nend\n\nfunction add_knapsack_variables(\n    model::Model,\n    data::KnapsackData,\n    config::UpperBoundedKnapsackConfig,\n)\n    return @variable(model, 0 <= x[keys(data.objects)] <= config.limit, Int)\nend\n\nsolve_knapsack_4(data, UpperBoundedKnapsackConfig(3))","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Generalize-constraints-and-objectives","page":"Design patterns for larger models","title":"Generalize constraints and objectives","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"It's easy to extend the dispatch approach to constraints and objectives as well. The key points to notice in the next two functions are that:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"we can access registered variables via model[:x]\nwe can define generic functions which accept any AbstractConfiguration as a configuration argument. That means we can implement a single method and have it apply to multiple configuration types.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function add_knapsack_constraints(\n    model::Model,\n    data::KnapsackData,\n    ::AbstractConfiguration,\n)\n    x = model[:x]\n    @constraint(\n        model,\n        capacity_constraint,\n        sum(v.weight * x[k] for (k, v) in data.objects) <= data.capacity,\n    )\n    return\nend\n\nfunction add_knapsack_objective(\n    model::Model,\n    data::KnapsackData,\n    ::AbstractConfiguration,\n)\n    x = model[:x]\n    @objective(model, Max, sum(v.profit * x[k] for (k, v) in data.objects))\n    return\nend\n\nfunction solve_knapsack_5(data::KnapsackData, config::AbstractConfiguration)\n    model = Model(GLPK.Optimizer)\n    add_knapsack_variables(model, data, config)\n    add_knapsack_constraints(model, data, config)\n    add_knapsack_objective(model, data, config)\n    optimize!(model)\n    return value.(model[:x])\nend\n\nsolve_knapsack_5(data, BinaryKnapsackConfig())","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Remove-solver-dependence,-add-error-checks","page":"Design patterns for larger models","title":"Remove solver dependence, add error checks","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Compared to where we started, our knapsack model is now significantly different. We've wrapped it in a function, defined some data types, and introduced configuration options to control the variables and constraints that get added. There are a few other steps we can do to further improve things:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"remove the dependence on GLPK\nadd checks that we found an optimal solution\nadd a helper function to avoid the need to explicitly construct the data.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function solve_knapsack_6(\n    optimizer,\n    data::KnapsackData,\n    config::AbstractConfiguration,\n)\n    model = Model(optimizer)\n    add_knapsack_variables(model, data, config)\n    add_knapsack_constraints(model, data, config)\n    add_knapsack_objective(model, data, config)\n    optimize!(model)\n    if termination_status(model) != OPTIMAL\n        @warn(\"Model not solved to optimality\")\n        return nothing\n    end\n    return value.(model[:x])\nend\n\nfunction solve_knapsack_6(\n    optimizer,\n    data::String,\n    config::AbstractConfiguration,\n)\n    return solve_knapsack_6(optimizer, read_data(data), config)\nend\n\nsolution =\n    solve_knapsack_6(GLPK.Optimizer, data_filename, BinaryKnapsackConfig())","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Create-a-module","page":"Design patterns for larger models","title":"Create a module","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Now we're ready to expose our model to the wider world. That might be as part of a larger Julia project that we're contributing to, or as a stand-alone script that we can run on-demand. In either case, it's good practice to wrap everything in a module. This further encapsulates our code into a single namespace, and we can add documentation in the form of docstrings.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Some good rules to follow when creating a module are:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"use import in a module instead of using to make it clear which functions are from which packages\nuse _ to start function and type names that are considered private\nadd docstrings to all public variables and functions.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"module KnapsackModel\n\nimport JuMP\nimport JSON\n\nstruct _KnapsackObject\n    profit::Float64\n    weight::Float64\n    function _KnapsackObject(profit::Float64, weight::Float64)\n        if weight < 0\n            throw(DomainError(\"Weight of object cannot be negative\"))\n        end\n        return new(profit, weight)\n    end\nend\n\nstruct _KnapsackData\n    objects::Dict{String,_KnapsackObject}\n    capacity::Float64\nend\n\nfunction _read_data(filename)\n    d = JSON.parsefile(filename)\n    return _KnapsackData(\n        Dict(\n            k => _KnapsackObject(v[\"profit\"], v[\"weight\"]) for\n            (k, v) in d[\"objects\"]\n        ),\n        d[\"capacity\"],\n    )\nend\n\nabstract type _AbstractConfiguration end\n\n\"\"\"\n    BinaryKnapsackConfig()\n\nCreate a binary knapsack problem where each object can be taken 0 or 1 times.\n\"\"\"\nstruct BinaryKnapsackConfig <: _AbstractConfiguration end\n\n\"\"\"\n    IntegerKnapsackConfig()\n\nCreate an integer knapsack problem where each object can be taken any number of\ntimes.\n\"\"\"\nstruct IntegerKnapsackConfig <: _AbstractConfiguration end\n\nfunction _add_knapsack_variables(\n    model::JuMP.Model,\n    data::_KnapsackData,\n    ::BinaryKnapsackConfig,\n)\n    return JuMP.@variable(model, x[keys(data.objects)], Bin)\nend\n\nfunction _add_knapsack_variables(\n    model::JuMP.Model,\n    data::_KnapsackData,\n    ::IntegerKnapsackConfig,\n)\n    return JuMP.@variable(model, x[keys(data.objects)] >= 0, Int)\nend\n\nfunction _add_knapsack_constraints(\n    model::JuMP.Model,\n    data::_KnapsackData,\n    ::_AbstractConfiguration,\n)\n    x = model[:x]\n    JuMP.@constraint(\n        model,\n        capacity_constraint,\n        sum(v.weight * x[k] for (k, v) in data.objects) <= data.capacity,\n    )\n    return\nend\n\nfunction _add_knapsack_objective(\n    model::JuMP.Model,\n    data::_KnapsackData,\n    ::_AbstractConfiguration,\n)\n    x = model[:x]\n    JuMP.@objective(model, Max, sum(v.profit * x[k] for (k, v) in data.objects))\n    return\nend\n\nfunction _solve_knapsack(\n    optimizer,\n    data::_KnapsackData,\n    config::_AbstractConfiguration,\n)\n    model = JuMP.Model(optimizer)\n    _add_knapsack_variables(model, data, config)\n    _add_knapsack_constraints(model, data, config)\n    _add_knapsack_objective(model, data, config)\n    JuMP.optimize!(model)\n    if JuMP.termination_status(model) != JuMP.OPTIMAL\n        @warn(\"Model not solved to optimality\")\n        return nothing\n    end\n    return JuMP.value.(model[:x])\nend\n\n\"\"\"\n    solve_knapsack(\n        optimizer,\n        data_filename::String,\n        config::_AbstractConfiguration,\n    )\n\nSolve the knapsack problem and return the optimal primal solution\n\n# Arguments\n\n * `optimizer` : an object that can be passed to `JuMP.Model` to construct a new\n   JuMP model.\n * `data_filename` : the filename of a JSON file containing the data for the\n   problem.\n * `config` : an object to control the type of knapsack model constructed.\n   Valid options are:\n    * `BinaryKnapsackConfig()`\n    * `IntegerKnapsackConfig()`\n\n# Returns\n\n * If an optimal solution exists: a `JuMP.DenseAxisArray` that maps the `String`\n   name of each object to the number of objects to pack into the knapsack.\n * Otherwise, `nothing`, indicating that the problem does not have an optimal\n   solution.\n\n# Examples\n\n```julia\nsolution = solve_knapsack(\n    GLPK.Optimizer,\n    \"path/to/data.json\",\n    BinaryKnapsackConfig(),\n)\n```\n\n```julia\nsolution = solve_knapsack(\n    MOI.OptimizerWithAttributes(GLPK.Optimizer, \"msg_lev\" => 0),\n    \"path/to/data.json\",\n    IntegerKnapsackConfig(),\n)\n```\n\"\"\"\nfunction solve_knapsack(\n    optimizer,\n    data_filename::String,\n    config::_AbstractConfiguration,\n)\n    return _solve_knapsack(optimizer, _read_data(data_filename), config)\nend\n\nend","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Finally, you can call your model:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"import .KnapsackModel\n\nKnapsackModel.solve_knapsack(\n    GLPK.Optimizer,\n    joinpath(@__DIR__, \"data\", \"knapsack.json\"),\n    KnapsackModel.BinaryKnapsackConfig(),\n)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"note: Note\nThe . in .KnapsackModel denotes that it is a submodule and not a separate package that we installed with Pkg.add. If you put the KnapsackModel in a separate file, load it with:include(\"path/to/KnapsackModel.jl\")\nimport .KnapsackModel","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Add-tests","page":"Design patterns for larger models","title":"Add tests","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"As a final step, you should add tests for your model. This often means testing on a small problem for which you can work out the optimal solution by hand. The Julia standard library Test has good unit-testing functionality.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"import .KnapsackModel\nusing Test\n\n@testset \"KnapsackModel\" begin\n    @testset \"feasible_binary_knapsack\" begin\n        x = KnapsackModel.solve_knapsack(\n            GLPK.Optimizer,\n            joinpath(@__DIR__, \"data\", \"knapsack.json\"),\n            KnapsackModel.BinaryKnapsackConfig(),\n        )\n        @test isapprox(x[\"apple\"], 1, atol = 1e-5)\n        @test isapprox(x[\"banana\"], 0, atol = 1e-5)\n        @test isapprox(x[\"cherry\"], 0, atol = 1e-5)\n        @test isapprox(x[\"date\"], 1, atol = 1e-5)\n        @test isapprox(x[\"eggplant\"], 1, atol = 1e-5)\n    end\n    @testset \"feasible_integer_knapsack\" begin\n        x = KnapsackModel.solve_knapsack(\n            GLPK.Optimizer,\n            joinpath(@__DIR__, \"data\", \"knapsack.json\"),\n            KnapsackModel.IntegerKnapsackConfig(),\n        )\n        @test isapprox(x[\"apple\"], 0, atol = 1e-5)\n        @test isapprox(x[\"banana\"], 0, atol = 1e-5)\n        @test isapprox(x[\"cherry\"], 0, atol = 1e-5)\n        @test isapprox(x[\"date\"], 5, atol = 1e-5)\n        @test isapprox(x[\"eggplant\"], 0, atol = 1e-5)\n    end\n    @testset \"infeasible_binary_knapsack\" begin\n        x = KnapsackModel.solve_knapsack(\n            GLPK.Optimizer,\n            # This file contains data that makes the problem infeasible.\n            joinpath(@__DIR__, \"data\", \"knapsack_infeasible.json\"),\n            KnapsackModel.BinaryKnapsackConfig(),\n        )\n        @test x === nothing\n    end\nend","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"tip: Tip\nPlace these tests in a separate file test_knapsack_model.jl so that you can run the tests by adding include(\"test_knapsack_model.jl\") to any file where needed.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Next-steps","page":"Design patterns for larger models","title":"Next steps","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"We've only briefly scratched the surface of ways to create and structure large JuMP models, so consider this tutorial a starting point, rather than a comprehensive list of all the possible ways to structure JuMP models.  If you are embarking on a large project that uses JuMP, a good next step is to look at ways people have written large JuMP projects \"in the wild\".","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Here are some good examples (all co-incidentally related to energy):","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"AnyMOD.jl\nJuMP-dev 2021 talk\nsource code\nPowerModels.jl\nJuMP-dev 2021 talk\nsource code\nPowerSimulations.jl\nJuliaCon 2021 talk\nsource code\nUnitCommitment.jl\nJuMP-dev 2021 talk\nsource code","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/linear/multi.jl\"","category":"page"},{"location":"tutorials/linear/multi/#The-multi-commodity-flow-problem","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"","category":"section"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"JuMP implementation of the multicommodity transportation model AMPL: A Modeling Language for Mathematical Programming, 2nd ed by Robert Fourer, David Gay, and Brian W. Kernighan 4-1.","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"Originally contributed by Louis Luangkesorn, February 26, 2015.","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_multi(; verbose = true)\n    orig = [\"GARY\", \"CLEV\", \"PITT\"]\n    dest = [\"FRA\", \"DET\", \"LAN\", \"WIN\", \"STL\", \"FRE\", \"LAF\"]\n    prod = [\"bands\", \"coils\", \"plate\"]\n    numorig = length(orig)\n    numdest = length(dest)\n    numprod = length(prod)\n    # supply(prod, orig) amounts available at origins\n    supply = [\n        400 700 800\n        800 1600 1800\n        200 300 300\n    ]\n    # demand(prod, dest) amounts required at destinations\n    demand = [\n        300 300 100 75 650 225 250\n        500 750 400 250 950 850 500\n        100 100 0 50 200 100 250\n    ]\n    # limit(orig, dest) of total units from any origin to destination\n    limit = [625.0 for j in 1:numorig, i in 1:numdest]\n    # cost(dest, orig, prod) Shipment cost per unit\n    cost = reshape(\n        [\n            [\n                [30, 10, 8, 10, 11, 71, 6]\n                [22, 7, 10, 7, 21, 82, 13]\n                [19, 11, 12, 10, 25, 83, 15]\n            ]\n            [\n                [39, 14, 11, 14, 16, 82, 8]\n                [27, 9, 12, 9, 26, 95, 17]\n                [24, 14, 17, 13, 28, 99, 20]\n            ]\n            [\n                [41, 15, 12, 16, 17, 86, 8]\n                [29, 9, 13, 9, 28, 99, 18]\n                [26, 14, 17, 13, 31, 104, 20]\n            ]\n        ],\n        7,\n        3,\n        3,\n    )\n    # DECLARE MODEL\n    multi = Model(GLPK.Optimizer)\n    # VARIABLES\n    @variable(multi, trans[1:numorig, 1:numdest, 1:numprod] >= 0)\n    # OBJECTIVE\n    @objective(\n        multi,\n        Max,\n        sum(\n            cost[j, i, p] * trans[i, j, p] for i in 1:numorig, j in 1:numdest,\n            p in 1:numprod\n        )\n    )\n    # CONSTRAINTS\n    # Supply constraint\n    @constraint(\n        multi,\n        supply_con[i in 1:numorig, p in 1:numprod],\n        sum(trans[i, j, p] for j in 1:numdest) == supply[p, i]\n    )\n    # Demand constraint\n    @constraint(\n        multi,\n        demand_con[j in 1:numdest, p in 1:numprod],\n        sum(trans[i, j, p] for i in 1:numorig) == demand[p, j]\n    )\n    # Total shipment constraint\n    @constraint(\n        multi,\n        total_con[i in 1:numorig, j in 1:numdest],\n        sum(trans[i, j, p] for p in 1:numprod) - limit[i, j] <= 0\n    )\n    optimize!(multi)\n    Test.@test termination_status(multi) == OPTIMAL\n    Test.@test primal_status(multi) == FEASIBLE_POINT\n    Test.@test objective_value(multi) == 225_700.0\n    if verbose\n        println(\"RESULTS:\")\n        for i in 1:length(orig)\n            for j in 1:length(dest)\n                for p in 1:length(prod)\n                    print(\n                        \" $(prod[p]) $(orig[i]) $(dest[j]) = $(value(trans[i, j, p]))\\t\",\n                    )\n                end\n                println()\n            end\n        end\n    end\n    return\nend\n\nexample_multi()","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"moi/tutorials/mathprogbase/#Transitioning-from-MathProgBase","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"","category":"section"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"MathOptInterface is a replacement for MathProgBase.jl. However, it is not a direct replacement.","category":"page"},{"location":"moi/tutorials/mathprogbase/#Transitioning-a-solver-interface","page":"Transitioning from MathProgBase","title":"Transitioning a solver interface","text":"","category":"section"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"MathOptInterface is more extensive than MathProgBase which may make its implementation seem daunting at first. There are however numerous utilities in MathOptInterface that the simplify implementation process.","category":"page"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"For more information, read Implementing a solver interface.","category":"page"},{"location":"moi/tutorials/mathprogbase/#Transitioning-the-high-level-functions","page":"Transitioning from MathProgBase","title":"Transitioning the high-level functions","text":"","category":"section"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"MathOptInterface doesn't provide replacements for the high-level interfaces in MathProgBase. We recommend you use JuMP as a modeling interface instead.","category":"page"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"tip: Tip\nIf you haven't used JuMP before, start with the tutorial Getting started with JuMP","category":"page"},{"location":"moi/tutorials/mathprogbase/#linprog","page":"Transitioning from MathProgBase","title":"linprog","text":"","category":"section"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"Here is one way of transitioning from linprog:","category":"page"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"using JuMP\n\nfunction linprog(c, A, sense, b, l, u, solver)\n    N = length(c)\n    model = Model(solver)\n    @variable(model, l[i] <= x[i=1:N] <= u[i])\n    @objective(model, Min, c' * x)\n    eq_rows, ge_rows, le_rows = sense .== '=', sense .== '>', sense .== '<'\n    @constraint(model, A[eq_rows, :] * x .== b[eq_rows])\n    @constraint(model, A[ge_rows, :] * x .>= b[ge_rows])\n    @constraint(model, A[le_rows, :] * x .<= b[le_rows])\n    optimize!(model)\n    return (\n        status = termination_status(model),\n        objval = objective_value(model),\n        sol = value.(x)\n    )\nend","category":"page"},{"location":"moi/tutorials/mathprogbase/#mixintprog","page":"Transitioning from MathProgBase","title":"mixintprog","text":"","category":"section"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"Here is one way of transitioning from mixintprog:","category":"page"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"using JuMP\n\nfunction mixintprog(c, A, rowlb, rowub, vartypes, lb, ub, solver)\n    N = length(c)\n    model = Model(solver)\n    @variable(model, lb[i] <= x[i=1:N] <= ub[i])\n    for i in 1:N\n        if vartypes[i] == :Bin\n            set_binary(x[i])\n        elseif vartypes[i] == :Int\n            set_integer(x[i])\n        end\n    end\n    @objective(model, Min, c' * x)\n    @constraint(model, rowlb .<= A * x .<= rowub)\n    optimize!(model)\n    return (\n        status = termination_status(model),\n        objval = objective_value(model),\n        sol = value.(x)\n    )\nend","category":"page"},{"location":"moi/tutorials/mathprogbase/#quadprog","page":"Transitioning from MathProgBase","title":"quadprog","text":"","category":"section"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"Here is one way of transitioning from quadprog:","category":"page"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"using JuMP\n\nfunction quadprog(c, Q, A, rowlb, rowub, lb, ub, solver)\n    N = length(c)\n    model = Model(solver)\n    @variable(model, lb[i] <= x[i=1:N] <= ub[i])\n    @objective(model, Min, c' * x + 0.5 * x' * Q * x)\n    @constraint(model, rowlb .<= A * x .<= rowub)\n    optimize!(model)\n    return (\n        status = termination_status(model),\n        objval = objective_value(model),\n        sol = value.(x)\n    )\nend","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/linear/finance.jl\"","category":"page"},{"location":"tutorials/linear/finance/#Financial-modeling-problems","page":"Financial modeling problems","title":"Financial modeling problems","text":"","category":"section"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Optimization models play an increasingly important role in financial decisions. Many computational finance problems can be solved efficiently using modern optimization techniques.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"In this tutorial we will discuss two such examples taken from the book Optimization Methods in Finance.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"This tutorial uses the following packages","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"using JuMP\nimport GLPK","category":"page"},{"location":"tutorials/linear/finance/#Short-term-financing","page":"Financial modeling problems","title":"Short-term financing","text":"","category":"section"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Corporations routinely face the problem of financing short term cash commitments such as the following:","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Month Jan Feb Mar Apr May Jun\nNet Cash Flow -150 -100 200 -200 50 300","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Net cash flow requirements are given in thousands of dollars. The company has the following sources of funds:","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"A line of credit of up to $100K at an interest rate of 1% per month,\nIn any one of the first three months, it can issue 90-day commercial paper bearing a total interest of 2% for the 3-month period,\nExcess funds can be invested at an interest rate of 0.3% per month.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Our task is to find out the most economical way to use these 3 sources such that we end up with the most amount of money at the end of June.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"We model this problem in the following manner:","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"We will use the following decision variables:","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"the amount u_i drawn from the line of credit in month i\nthe amount v_i of commercial paper issued in month i\nthe excess funds w_i in month i","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Here we have three types of constraints:","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"for every month, cash inflow = cash outflow for each month\nupper bounds on u_i\nnonnegativity of the decision variables u_i, v_i and w_i.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Our objective will be to simply maximize the company's wealth in June, which say we represent with the variable m.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"financing = Model(GLPK.Optimizer)\n\n@variables(financing, begin\n    0 <= u[1:5] <= 100\n    0 <= v[1:3]\n    0 <= w[1:5]\n    m\nend)\n\n@objective(financing, Max, m)\n\n@constraints(\n    financing,\n    begin\n        u[1] + v[1] - w[1] == 150 # January\n        u[2] + v[2] - w[2] - 1.01u[1] + 1.003w[1] == 100 # February\n        u[3] + v[3] - w[3] - 1.01u[2] + 1.003w[2] == -200 # March\n        u[4] - w[4] - 1.02v[1] - 1.01u[3] + 1.003w[3] == 200 # April\n        u[5] - w[5] - 1.02v[2] - 1.01u[4] + 1.003w[4] == -50 # May\n        -m - 1.02v[3] - 1.01u[5] + 1.003w[5] == -300 # June\n    end\n)\n\noptimize!(financing)\n\nobjective_value(financing)","category":"page"},{"location":"tutorials/linear/finance/#Combinatorial-auctions","page":"Financial modeling problems","title":"Combinatorial auctions","text":"","category":"section"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"In many auctions, the value that a bidder has for a set of items may not be the sum of the values that he has for individual items.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Examples are equity trading, electricity markets, pollution right auctions and auctions for airport landing slots.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"To take this into account, combinatorial auctions allow the bidders to submit bids on combinations of items.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Let M=12 ldots m be the set of items that the auctioneer has to sell. A bid is a pair B_j=left(S_j p_jright) where S_j subseteq M is a nonempty set of items and p_j is the price offer for this set.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Suppose that the auctioneer has received n bids B_1 B_2 ldots B_n The goal of this problem is to help an auctioneer determine the winners in order to maximize his revenue.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"We model this problem by taking a decision variable y_j for every bid. We add a constraint that each item i is sold at most once. This gives us the following model:","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"beginaligned\nmax  sum_i=1^n p_j y_j \ntext  st    sum_j  i in S_j y_j leq 1  forall i=12 ldots m \n y_j in01  forall j in12 ldots n\nendaligned","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"bid_values = [6 3 12 12 8 16]\nbid_items = [[1], [2], [3 4], [1 3], [2 4], [1 3 4]]\n\nauction = Model(GLPK.Optimizer)\n@variable(auction, y[1:6], Bin)\n@objective(auction, Max, sum(y' .* bid_values))\nfor i in 1:6\n    @constraint(auction, sum(y[j] for j in 1:6 if i in bid_items[j]) <= 1)\nend\n\noptimize!(auction)\n\nobjective_value(auction)","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"value.(y)","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/objective/#Objectives","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"This page describes macros and functions related to linear and quadratic objective functions only, unless otherwise indicated. For nonlinear objective functions, see Nonlinear Modeling.","category":"page"},{"location":"manual/objective/#Set-a-linear-objective","page":"Objectives","title":"Set a linear objective","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use the @objective macro to set a linear objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use Min to create a minimization objective:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x + 1)\n2 x + 1","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use Max to create a maximization objective:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Max, 2x + 1)\n2 x + 1","category":"page"},{"location":"manual/objective/#Set-a-quadratic-objective","page":"Objectives","title":"Set a quadratic objective","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use the @objective macro to set a quadratic objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use ^2 to have a variable squared:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, x^2 + 2x + 1)\nx² + 2 x + 1","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"You can also have bilinear terms between variables:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @objective(model, Max, x * y + x + y)\nx*y + x + y","category":"page"},{"location":"manual/objective/#Query-the-objective-function","page":"Objectives","title":"Query the objective function","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use objective_function to return the current objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x + 1)\n2 x + 1\n\njulia> objective_function(model)\n2 x + 1","category":"page"},{"location":"manual/objective/#Evaluate-the-objective-function-at-a-point","page":"Objectives","title":"Evaluate the objective function at a point","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use value to evaluate an objective function at a point specifying values for variables.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @variable(model, x[1:2]);\n\njulia> @objective(model, Min, 2x[1]^2 + x[1] + 0.5*x[2])\n2 x[1]² + x[1] + 0.5 x[2]\n\njulia> f = objective_function(model)\n2 x[1]² + x[1] + 0.5 x[2]\n\njulia> point = Dict(x[1] => 2.0, x[2] => 1.0);\n\njulia> value(z -> point[z], f)\n10.5","category":"page"},{"location":"manual/objective/#Query-the-objective-sense","page":"Objectives","title":"Query the objective sense","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use objective_sense to return the current objective sense.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x + 1)\n2 x + 1\n\njulia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0","category":"page"},{"location":"manual/objective/#Modify-an-objective","page":"Objectives","title":"Modify an objective","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"To modify an objective, call @objective with the new objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x)\n2 x\n\njulia> @objective(model, Max, -2x)\n-2 x","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Alternatively, use set_objective_function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x)\n2 x\n\njulia> new_objective = @expression(model, -2 * x)\n-2 x\n\njulia> set_objective_function(model, new_objective)","category":"page"},{"location":"manual/objective/#Modify-an-objective-coefficient","page":"Objectives","title":"Modify an objective coefficient","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use set_objective_coefficient to modify an objective coefficient.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x)\n2 x\n\njulia> set_objective_coefficient(model, x, 3)\n\njulia> objective_function(model)\n3 x","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"info: Info\nThere is no way to modify the coefficient of a quadratic term. Set a new objective instead.","category":"page"},{"location":"manual/objective/#Modify-the-objective-sense","page":"Objectives","title":"Modify the objective sense","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use set_objective_sense to modify the objective sense.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x)\n2 x\n\njulia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0\n\njulia> set_objective_sense(model, MAX_SENSE);\n\njulia> objective_sense(model)\nMAX_SENSE::OptimizationSense = 1","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Alternatively, call @objective and pass the existing objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x)\n2 x\n\njulia> @objective(model, Max, objective_function(model))\n2 x","category":"page"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\n\n    # For compatibility with both Julia 1.0.5 and 1.5.2\n    # Upon the Julia LTS version becoming 1.6, these imports could be dropped,\n    # and all ScalarAffineTerm and VariableIndex instances in doctests below\n    # could be replaced with MOI.ScalarAffineTerm and MOI.VariableIndex\n    # Check discussion at PR 1184: https://github.com/jump-dev/MathOptInterface.jl/pull/1184#discussion_r515300914\n    import MathOptInterface.ScalarAffineTerm\n    import MathOptInterface.VariableIndex\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Bridges/reference/#Bridges","page":"API Reference","title":"Bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.AbstractBridge\nBridges.AbstractBridgeOptimizer\nBridges.LazyBridgeOptimizer\nBridges.add_bridge\nBridges.remove_bridge\nBridges.has_bridge\nBridges.full_bridge_optimizer\nBridges.ListOfNonstandardBridges\nBridges.debug_supports_constraint\nBridges.debug_supports\nBridges.bridged_variable_function\nBridges.unbridged_variable_function\nBridges.bridged_function\nBridges.Variable.unbridged_map","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.AbstractBridge","page":"API Reference","title":"MathOptInterface.Bridges.AbstractBridge","text":"AbstractBridge\n\nRepresents a bridged constraint or variable in a MathOptInterface.Bridges.AbstractBridgeOptimizer. It contains the indices of the variables and constraints that it has created in the model. These can be obtained using MathOptInterface.NumberOfVariables, MathOptInterface.ListOfVariableIndices, MathOptInterface.NumberOfConstraints and MathOptInterface.ListOfConstraintIndices using MathOptInterface.get with the bridge in place of the MathOptInterface.ModelLike. Attributes of the bridged model such as MathOptInterface.ConstraintDual and MathOptInterface.ConstraintPrimal, can be obtained using MathOptInterface.get with the bridge in place of the constraint index. These calls are used by the MathOptInterface.Bridges.AbstractBridgeOptimizer to communicate with the bridge so they should be implemented by the bridge.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.AbstractBridgeOptimizer","page":"API Reference","title":"MathOptInterface.Bridges.AbstractBridgeOptimizer","text":"AbstractBridgeOptimizer\n\nA bridge optimizer applies given constraint bridges to a given optimizer thus extending the types of supported constraints. The attributes of the inner optimizer are automatically transformed to make the bridges transparent, e.g. the variables and constraints created by the bridges are hidden.\n\nBy convention, the inner optimizer should be stored in a model field and the dictionary mapping constraint indices to bridges should be stored in a bridges field. If a bridge optimizer deviates from these conventions, it should implement the functions MOI.optimize! and bridge respectively.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.LazyBridgeOptimizer","page":"API Reference","title":"MathOptInterface.Bridges.LazyBridgeOptimizer","text":"LazyBridgeOptimizer{OT<:MOI.ModelLike} <: AbstractBridgeOptimizer\n\nThe LazyBridgeOptimizer combines several bridges, which are added using the add_bridge function.\n\nWhenever a constraint is added, it only attempts to bridge it if it is not supported by the internal model (hence its name Lazy).\n\nWhen bridging a constraint, it selects the minimal number of bridges needed.\n\nFor example, if a constraint F-in-S can be bridged into a constraint F1-in-S1 (supported by the internal model) using bridge 1 or bridged into a constraint F2-in-S2 (unsupported by the internal model) using bridge 2 which can then be bridged into a constraint F3-in-S3 (supported by the internal model) using bridge 3, it will choose bridge 1 as it allows to bridge F-in-`S using only one bridge instead of two if it uses bridge 2 and 3.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.add_bridge","page":"API Reference","title":"MathOptInterface.Bridges.add_bridge","text":"add_bridge(b::LazyBridgeOptimizer, BT::Type{<:AbstractBridge})\n\nEnable the use of the bridges of type BT by b.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.remove_bridge","page":"API Reference","title":"MathOptInterface.Bridges.remove_bridge","text":"remove_bridge(b::LazyBridgeOptimizer, BT::Type{<:AbstractBridge})\n\nDisable the use of the bridges of type BT by b.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.has_bridge","page":"API Reference","title":"MathOptInterface.Bridges.has_bridge","text":"has_bridge(b::LazyBridgeOptimizer, BT::Type{<:AbstractBridge})\n\nReturn a Bool indicating whether the bridges of type BT are used by b.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.full_bridge_optimizer","page":"API Reference","title":"MathOptInterface.Bridges.full_bridge_optimizer","text":"full_bridge_optimizer(model::MOI.ModelLike, ::Type{T}) where {T}\n\nReturns a LazyBridgeOptimizer bridging model for every bridge defined in this package (see below for the few exceptions) and for the coefficient type T in addition to the bridges in the list returned by MOI.get(model, MOI.Bridges.ListOfNonstandardBridges{T}()).\n\nSee also ListOfNonstandardBridges.\n\nnote: Note\nThe following bridges are not added by full_bridge_optimizer except if they are in the list returned by MOI.get(model, MOI.Bridges.ListOfNonstandardBridges{T}()) (see the docstrings of the corresponding bridge for the reason they are not added):Constraint.SOCtoNonConvexQuadBridge, Constraint.RSOCtoNonConvexQuadBridge and Constraint.SOCtoPSDBridge.\nThe subtypes of Constraint.AbstractToIntervalBridge (i.e. Constraint.GreaterToIntervalBridge and Constraint.LessToIntervalBridge) if T is not a subtype of AbstractFloat.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.ListOfNonstandardBridges","page":"API Reference","title":"MathOptInterface.Bridges.ListOfNonstandardBridges","text":"ListOfNonstandardBridges{T}() <: MOI.AbstractOptimizerAttribute\n\nAny optimizer can be wrapped in a LazyBridgeOptimizer using full_bridge_optimizer. However, by default LazyBridgeOptimizer uses a limited set of bridges that are:\n\nimplemented in MOI.Bridges\ngenerally applicable for all optimizers.\n\nFor some optimizers however, it is useful to add additional bridges, such as those that are implemented in external packages (e.g., within the solver package itself) or only apply in certain circumstances (e.g., Constraint.SOCtoNonConvexQuadBridge).\n\nSuch optimizers should implement the ListOfNonstandardBridges attribute to return a vector of bridge types that are added by full_bridge_optimizer in addition to the list of default bridges.\n\nNote that optimizers implementing ListOfNonstandardBridges may require package-specific functions or sets to be used if the non-standard bridges are not added. Therefore, you are recommended to use model = MOI.instantiate(Package.Optimizer; with_bridge_type = T) instead of model = MOI.instantiate(Package.Optimizer). See MathOptInterface.instantiate.\n\nExamples\n\nAn optimizer using a non-default bridge in MOI.Bridges\n\nSolvers supporting MOI.ScalarQuadraticFunction can support MOI.SecondOrderCone and MOI.RotatedSecondOrderCone by defining:\n\nfunction MOI.get(::MyQuadraticOptimizer, ::ListOfNonstandardBridges{Float64})\n    return Type[\n        MOI.Bridges.Constraint.SOCtoNonConvexQuadBridge{Float64},\n        MOI.Bridges.Constraint.RSOCtoNonConvexQuadBridge{Float64},\n    ]\nend\n\nAn optimizer defining an internal bridge\n\nSuppose an optimizer can exploit specific structure of a constraint, e.g., it can exploit the structure of the matrix A in the linear system of equations A * x = b.\n\nThe optimizer can define the function:\n\nstruct MatrixAffineFunction{T} <: MOI.AbstractVectorFunction\n    A::SomeStructuredMatrixType{T}\n    b::Vector{T}\nend\n\nand then a bridge\n\nstruct MatrixAffineFunctionBridge{T} <: MOI.Constraint.AbstractBridge\n    # ...\nend\n# ...\n\nfrom VectorAffineFunction{T} to the MatrixAffineFunction. Finally, it defines:\n\nfunction MOI.get(::Optimizer{T}, ::ListOfNonstandardBridges{T}) where {T}\n    return Type[MatrixAffineFunctionBridge{T}]\nend\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.debug_supports_constraint","page":"API Reference","title":"MathOptInterface.Bridges.debug_supports_constraint","text":"debug_supports_constraint(\n    b::LazyBridgeOptimizer,\n    F::Type{<:MOI.AbstractFunction},\n    S::Type{<:MOI.AbstractSet};\n    io::IO = Base.stdout,\n)\n\nPrints to io explanations for the value of MOI.supports_constraint with the same arguments.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.debug_supports","page":"API Reference","title":"MathOptInterface.Bridges.debug_supports","text":"debug_supports(\n    b::LazyBridgeOptimizer,\n    ::MOI.ObjectiveFunction{F};\n    io::IO = Base.stdout,\n) where F\n\nPrints to io explanations for the value of MOI.supports with the same arguments.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.bridged_variable_function","page":"API Reference","title":"MathOptInterface.Bridges.bridged_variable_function","text":"bridged_variable_function(\n    b::AbstractBridgeOptimizer,\n    vi::MOI.VariableIndex,\n)\n\nReturn a MOI.AbstractScalarFunction of variables of b.model that equals vi. That is, if the variable vi is bridged, it returns its expression in terms of the variables of b.model. Otherwise, it returns vi.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.unbridged_variable_function","page":"API Reference","title":"MathOptInterface.Bridges.unbridged_variable_function","text":"unbridged_variable_function(\n    b::AbstractBridgeOptimizer,\n    vi::MOI.VariableIndex,\n)\n\nReturn a MOI.AbstractScalarFunction of variables of b that equals vi. That is, if the variable vi is an internal variable of b.model created by a bridge but not visible to the user, it returns its expression in terms of the variables of bridged variables. Otherwise, it returns vi.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.bridged_function","page":"API Reference","title":"MathOptInterface.Bridges.bridged_function","text":"bridged_function(b::AbstractBridgeOptimizer, value)::typeof(value)\n\nSubstitute any bridged MOI.VariableIndex in value by an equivalent expression in terms of variables of b.model.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.unbridged_map","page":"API Reference","title":"MathOptInterface.Bridges.Variable.unbridged_map","text":"unbridged_map(        bridge::MOI.Bridges.Variable.AbstractBridge,         vi::MOI.VariableIndex,     )\n\nFor a bridged variable in a scalar set, return a tuple of pairs mapping the variables created by the bridge to an affine expression in terms of the bridged variable vi.\n\nunbridged_map(\n    bridge::MOI.Bridges.Variable.AbstractBridge,\n    vis::Vector{MOI.VariableIndex},\n)\n\nFor a bridged variable in a vector set, return a tuple of pairs mapping the variables created by the bridge to an affine expression in terms of the bridged variable vis. If this method is not implemented, it falls back to calling the following method for every variable of vis.\n\nunbridged_map(\n    bridge::MOI.Bridges.Variable.AbstractBridge,\n    vi::MOI.VariableIndex,\n    i::MOIB.IndexInVector,\n)\n\nFor a bridged variable in a vector set, return a tuple of pairs mapping the variables created by the bridge to an affine expression in terms of the bridged variable vi corresponding to the ith variable of the vector.\n\nIf there is no way to recover the expression in terms of the bridged variable(s) vi(s), return nothing. See ZerosBridge for an example of bridge returning nothing.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#Constraint-bridges","page":"API Reference","title":"Constraint bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.Constraint.AbstractBridge\nBridges.Constraint.AbstractFunctionConversionBridge\nBridges.Constraint.SingleBridgeOptimizer\nBridges.Constraint.add_all_bridges","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.AbstractBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.AbstractBridge","text":"AbstractBridge\n\nSubtype of MathOptInterface.Bridges.AbstractBridge for constraint bridges.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.AbstractFunctionConversionBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.AbstractFunctionConversionBridge","text":"abstract type AbstractFunctionConversionBridge{F, S} <: AbstractBridge end\n\nBridge a constraint G-in-S into a constraint F-in-S where F and G are equivalent representations of the same function. By convention, the transformed function is stored in the constraint field.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer","text":"SingleBridgeOptimizer{BT<:AbstractBridge, OT<:MOI.ModelLike} <:\nAbstractBridgeOptimizer\n\nThe SingleBridgeOptimizer bridges any constraint supported by the bridge BT. This is in contrast with the MathOptInterface.Bridges.LazyBridgeOptimizer which only bridges the constraints that are unsupported by the internal model, even if they are supported by one of its bridges.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.add_all_bridges","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.add_all_bridges","text":"add_all_bridges(bridged_model, ::Type{T}) where {T}\n\nAdd all bridges defined in the Bridges.Constraint submodule to bridged_model. The coefficient type used is T.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#constraint_set_map","page":"API Reference","title":"SetMap bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.Variable.SetMapBridge\nBridges.Constraint.SetMapBridge\nBridges.map_set\nBridges.inverse_map_set\nBridges.map_function\nBridges.inverse_map_function\nBridges.adjoint_map_function\nBridges.inverse_adjoint_map_function","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.SetMapBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.SetMapBridge","text":"abstract type SetMapBridge{T,S1,S2} <: AbstractBridge end\n\nConsider two type of sets S1, S2 and a linear mapping A that the image of a set of type S1 under A is a set of type S2. A SetMapBridge{T,S1,S2} is a bridge that substitutes constrained variables in S2 into the image through A of constrained variables in S1.\n\nThe linear map A is described by MathOptInterface.Bridges.map_set, MathOptInterface.Bridges.map_function. Implementing a method for these two functions is sufficient to bridge constrained variables. In order for the getters and setters of dual solutions, starting values, etc...  to work as well a method for the following functions should be implemented as well: MathOptInterface.Bridges.inverse_map_set, MathOptInterface.Bridges.inverse_map_function, MathOptInterface.Bridges.adjoint_map_function and MathOptInterface.Bridges.inverse_adjoint_map_function. See the docstrings of the function to see which feature would be missing it it was not implemented for a given bridge.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.SetMapBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.SetMapBridge","text":"abstract type SetMapBridge{T,S2,S1,F,G} <: AbstractBridge end\n\nConsider two type of sets S1, S2 and a linear mapping A that the image of a set of type S1 under A is a set of type S2. A SetMapBridge{T,S2,S1,F,G} is a bridge that maps G-in-S2 constraints into F-in-S1 by mapping the function through A.\n\nThe linear map A is described by MathOptInterface.Bridges.map_set, MathOptInterface.Bridges.map_function. Implementing a method for these two functions is sufficient to bridge constraints. In order for the getters and setters of dual solutions, starting values, etc...  to work as well a method for the following functions should be implemented as well: MathOptInterface.Bridges.inverse_map_set, MathOptInterface.Bridges.inverse_map_function, MathOptInterface.Bridges.adjoint_map_function and MathOptInterface.Bridges.inverse_adjoint_map_function. See the docstrings of the function to see which feature would be missing it it was not implemented for a given bridge.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.map_set","page":"API Reference","title":"MathOptInterface.Bridges.map_set","text":"map_set(::Type{BT}, set) where {BT}\n\nReturn the image of set through the linear map A defined in Variable.SetMapBridge and Constraint.SetMapBridge. This is used for bridging the constraint and setting the MathOptInterface.ConstraintSet.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.inverse_map_set","page":"API Reference","title":"MathOptInterface.Bridges.inverse_map_set","text":"inverse_map_set(::Type{BT}, set) where {BT}\n\nReturn the preimage of set through the linear map A defined in Variable.SetMapBridge and Constraint.SetMapBridge. This is used for getting the MathOptInterface.ConstraintSet.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.map_function","page":"API Reference","title":"MathOptInterface.Bridges.map_function","text":"map_function(::Type{BT}, func) where {BT}\n\nReturn the image of func through the linear map A defined in Variable.SetMapBridge and Constraint.SetMapBridge. This is used for getting the MathOptInterface.ConstraintPrimal of variable bridges. For constraint bridges, this is used for bridging the constraint, setting the MathOptInterface.ConstraintFunction and MathOptInterface.ConstraintPrimalStart and modifying the function with MathOptInterface.modify.\n\nmap_function(::Type{BT}, func, i::IndexInVector) where {BT}\n\nReturn the scalar function at the ith index of the vector function that would be returned by map_function(BT, func) except that it may compute the ith element. This is used by bridged_function and for getting the MathOptInterface.VariablePrimal and MathOptInterface.VariablePrimalStart of variable bridges.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.inverse_map_function","page":"API Reference","title":"MathOptInterface.Bridges.inverse_map_function","text":"inverse_map_function(::Type{BT}, func) where {BT}\n\nReturn the image of func through the inverse of the linear map A defined in Variable.SetMapBridge and Constraint.SetMapBridge. This is used by Variable.unbridged_map and for setting the MathOptInterface.VariablePrimalStart of variable bridges and for getting the MathOptInterface.ConstraintFunction, the MathOptInterface.ConstraintPrimal and the MathOptInterface.ConstraintPrimalStart of constraint bridges.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.adjoint_map_function","page":"API Reference","title":"MathOptInterface.Bridges.adjoint_map_function","text":"adjoint_map_function(::Type{BT}, func) where {BT}\n\nReturn the image of func through the adjoint of the linear map A defined in Variable.SetMapBridge and Constraint.SetMapBridge. This is used for getting the MathOptInterface.ConstraintDual and MathOptInterface.ConstraintDualStart of constraint bridges.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.inverse_adjoint_map_function","page":"API Reference","title":"MathOptInterface.Bridges.inverse_adjoint_map_function","text":"inverse_adjoint_map_function(::Type{BT}, func) where {BT}\n\nReturn the image of func through the inverse of the adjoint of the linear map A defined in Variable.SetMapBridge and Constraint.SetMapBridge. This is used for getting the MathOptInterface.ConstraintDual of variable bridges and setting the MathOptInterface.ConstraintDualStart of constraint bridges.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#constraint_bridges_ref","page":"API Reference","title":"Bridges implemented","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.Constraint.FlipSignBridge\nBridges.Constraint.AbstractToIntervalBridge\nBridges.Constraint.GreaterToIntervalBridge\nBridges.Constraint.LessToIntervalBridge\nBridges.Constraint.GreaterToLessBridge\nBridges.Constraint.LessToGreaterBridge\nBridges.Constraint.NonnegToNonposBridge\nBridges.Constraint.NonposToNonnegBridge\nBridges.Constraint.VectorizeBridge\nBridges.Constraint.ScalarizeBridge\nBridges.Constraint.ScalarSlackBridge\nBridges.Constraint.VectorSlackBridge\nBridges.Constraint.ScalarFunctionizeBridge\nBridges.Constraint.VectorFunctionizeBridge\nBridges.Constraint.SplitIntervalBridge\nBridges.Constraint.SOCtoRSOCBridge\nBridges.Constraint.RSOCtoSOCBridge\nBridges.Constraint.SOCtoNonConvexQuadBridge\nBridges.Constraint.RSOCtoNonConvexQuadBridge\nBridges.Constraint.QuadtoSOCBridge\nBridges.Constraint.SOCtoPSDBridge\nBridges.Constraint.RSOCtoPSDBridge\nBridges.Constraint.NormInfinityBridge\nBridges.Constraint.NormOneBridge\nBridges.Constraint.GeoMeantoRelEntrBridge\nBridges.Constraint.GeoMeanBridge\nBridges.Constraint.RelativeEntropyBridge\nBridges.Constraint.NormSpectralBridge\nBridges.Constraint.NormNuclearBridge\nBridges.Constraint.SquareBridge\nBridges.Constraint.RootDetBridge\nBridges.Constraint.LogDetBridge\nBridges.Constraint.IndicatorActiveOnFalseBridge\nBridges.Constraint.IndicatorSOS1Bridge\nBridges.Constraint.SemiToBinaryBridge\nBridges.Constraint.ZeroOneBridge","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.FlipSignBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.FlipSignBridge","text":"FlipSignBridge{T, S1, S2, F, G}\n\nBridge a G-in-S1 constraint into an F-in-S2 constraint by multiplying the function by -1 and taking the point reflection of the set across the origin. The flipped F-in-S constraint is stored in the constraint field by convention.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.AbstractToIntervalBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.AbstractToIntervalBridge","text":"AbstractToIntervalBridge{T, S1, F}\n\nBridge a F-in-Interval constraint into an F-in-Interval{T} constraint where we have either:\n\nS1 = MOI.GreaterThan{T}\nS1 = MOI.LessThan{T}\n\nThe F-in-Interval{T} constraint is stored in the constraint field by convention.\n\nwarning: Warning\nIt is required that T be a AbstractFloat type because otherwise typemin and typemax would either be not implemented (e.g. BigInt) or would not give infinite value (e.g. Int). For this reason, this bridge is only added to MathOptInterface.Bridges.full_bridge_optimizer.when T is a subtype of AbstractFloat.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge","text":"GreaterToIntervalBridge{T, F<:MOI.AbstractScalarFunction} <:\n    AbstractToIntervalBridge{T, MOI.GreaterThan{T}, F}\n\nTransforms a F-in-GreaterThan{T} constraint into an F-in-Interval{T} constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.LessToIntervalBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.LessToIntervalBridge","text":"LessToIntervalBridge{T, F<:MOI.AbstractScalarFunction} <:\n    AbstractToIntervalBridge{T, MOI.LessThan{T}, F}\n\nTransforms a F-in-LessThan{T} constraint into an F-in-Interval{T} constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.GreaterToLessBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.GreaterToLessBridge","text":"GreaterToLessBridge{\n    T,\n    F<:MOI.AbstractScalarFunction,\n    G<:MOI.AbstractScalarFunction\n} <: FlipSignBridge{T, MOI.GreaterThan{T}, MOI.LessThan{T}, F, G}\n\nTransforms a G-in-GreaterThan{T} constraint into an F-in-LessThan{T} constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.LessToGreaterBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.LessToGreaterBridge","text":"LessToGreaterBridge{\n    T,\n    F<:MOI.AbstractScalarFunction,\n    G<:MOI.AbstractScalarFunction\n} <: FlipSignBridge{T, MOI.LessThan{T}, MOI.GreaterThan{T}, F, G}\n\nTransforms a G-in-LessThan{T} constraint into an F-in-GreaterThan{T} constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.NonnegToNonposBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.NonnegToNonposBridge","text":"NonnegToNonposBridge{\n    T,\n    F<:MOI.AbstractVectorFunction,\n    G<:MOI.AbstractVectorFunction\n} <: FlipSignBridge{T, MOI.Nonnegatives, MOI.Nonpositives, F, G}\n\nTransforms a G-in-Nonnegatives constraint into a F-in-Nonpositives constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.NonposToNonnegBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.NonposToNonnegBridge","text":"NonposToNonnegBridge{\n    T,\n    F<:MOI.AbstractVectorFunction,\n    G<:MOI.AbstractVectorFunction,\n} <: FlipSignBridge{T, MOI.Nonpositives, MOI.Nonnegatives, F, G}\n\nTransforms a G-in-Nonpositives constraint into a F-in-Nonnegatives constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.VectorizeBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.VectorizeBridge","text":"VectorizeBridge{T,F,S,G}\n\nTransforms a constraint G-in-scalar_set_type(S, T) where S <: VectorLinearSet to F-in-S.\n\nExamples\n\nThe constraint VariableIndex-in-LessThan{Float64} becomes VectorAffineFunction{Float64}-in-Nonpositives, where T = Float64, F = VectorAffineFunction{Float64}, S = Nonpositives, and G = VariableIndex.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.ScalarizeBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.ScalarizeBridge","text":"ScalarizeBridge{T, F, S}\n\nTransforms a constraint AbstractVectorFunction-in-vector_set_type(S) where S <: LPCone{T} to F-in-S.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.ScalarSlackBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.ScalarSlackBridge","text":"ScalarSlackBridge{T, F, S}\n\nThe ScalarSlackBridge converts a constraint G-in-S where G is a function different from VariableIndex into the constraints F-in-EqualTo{T} and VariableIndex-in-S.\n\nF is the result of subtracting a VariableIndex from G. Typically G is the same as F, but that is not mandatory.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.VectorSlackBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.VectorSlackBridge","text":"VectorSlackBridge{T, F, S}\n\nThe VectorSlackBridge converts a constraint G-in-S where G is a function different from VectorOfVariables into the constraints Fin-Zeros and VectorOfVariables-in-S.\n\nF is the result of subtracting a VectorOfVariables from G. Typically G is the same as F, but that is not mandatory.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge","text":"ScalarFunctionizeBridge{T, S}\n\nThe ScalarFunctionizeBridge converts a constraint VariableIndex-in-S into the constraint ScalarAffineFunction{T}-in-S.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge","text":"VectorFunctionizeBridge{T, S}\n\nThe VectorFunctionizeBridge converts a constraint VectorOfVariables-in-S into the constraint VectorAffineFunction{T}-in-S.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.SplitIntervalBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.SplitIntervalBridge","text":"SplitIntervalBridge{T, F, S, LS, US}\n\nThe SplitIntervalBridge splits a F-in-S constraint into a F-in-LS and a F-in-US constraint where we have either:\n\nS = MOI.Interval{T}, LS = MOI.GreaterThan{T} and US = MOI.LessThan{T},\nS = MOI.EqualTo{T}, LS = MOI.GreaterThan{T} and US = MOI.LessThan{T}, or\nS = MOI.Zeros, LS = MOI.Nonnegatives and US = MOI.Nonpositives.\n\nFor instance, if F is MOI.ScalarAffineFunction and S is MOI.Interval, it transforms the constraint l  a x + α  u into the constraints a x + α  l and a x + α  u.\n\nnote: Note\nIf T<:AbstractFloat and S is MOI.Interval{T} then no lower (resp. upper) bound constraint is created if the lower (resp. upper) bound is typemin(T) (resp. typemax(T)). Similarly, when MathOptInterface.ConstraintSet is set, a lower or upper bound constraint may be deleted or created accordingly.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge","text":"SOCtoRSOCBridge{T, F, G}\n\nWe simply do the inverse transformation of RSOCtoSOCBridge. In fact, as the transformation is an involution, we do the same transformation.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge","text":"RSOCtoSOCBridge{T, F, G}\n\nThe RotatedSecondOrderCone is SecondOrderCone representable; see [BN01, p. 104]. Indeed, we have 2tu = (t2 + u2)^2 - (t2 - u2)^2 hence\n\n2tu ge lVert x rVert_2^2\n\nis equivalent to\n\n(t2 + u2)^2 ge lVert x rVert_2^2 + (t2 - u2)^2\n\nWe can therefore use the transformation (t u x) mapsto (t2+u2 t2-u2 x). Note that the linear transformation is a symmetric involution (i.e. it is its own transpose and its own inverse). That means in particular that the norm of constraint primal and dual values are preserved by the tranformation.\n\n[BN01] Ben-Tal, Aharon, and Nemirovski, Arkadi. Lectures on modern convex optimization: analysis, algorithms, and engineering applications. Society for Industrial and Applied Mathematics, 2001.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge","text":"SOCtoNonConvexQuadBridge{T}\n\nConstraints of the form VectorOfVariables-in-SecondOrderCone can be transformed into a ScalarQuadraticFunction-in-LessThan and a ScalarAffineFunction-in-GreaterThan. Indeed, the definition of the second-order cone\n\nt ge lVert x rVert_2   (1)\n\nis equivalent to\n\nsum x_i^2 le t^2  (2)\n\nwith t ge 0.  (3)\n\nwarning: Warning\nThis transformation starts from a convex constraint (1) and creates a non-convex constraint (2), because the Q matrix associated with the constraint (2) has one negative eigenvalue. This might be wrongly interpreted by a solver. Some solvers can look at (2) and understand that it is a second order cone, but this is not a general rule. For these reasons this bridge is not automatically added by MOI.Bridges.full_bridge_optimizer. Care is recommended when adding this bridge to a optimizer.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.RSOCtoNonConvexQuadBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.RSOCtoNonConvexQuadBridge","text":"RSOCtoNonConvexQuadBridge{T}\n\nConstraints of the form VectorOfVariables-in-SecondOrderCone can be transformed into a ScalarQuadraticFunction-in-LessThan and a ScalarAffineFunction-in-GreaterThan. Indeed, the definition of the second-order cone\n\n2tu ge lVert x rVert_2^2 tu ge 0  (1)\n\nis equivalent to\n\nsum x_i^2 le 2tu  (2)\n\nwith tu ge 0.  (3)\n\nWARNING This transformation starts from a convex constraint (1) and creates a non-convex constraint (2), because the Q matrix associated with the constraint 2 has two negative eigenvalues. This might be wrongly interpreted by a solver. Some solvers can look at (2) and understand that it is a rotated second order cone, but this is not a general rule. For these reasons, this bridge is not automatically added by MOI.Bridges.full_bridge_optimizer. Care is recommended when adding this bridge to an optimizer.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.QuadtoSOCBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.QuadtoSOCBridge","text":"QuadtoSOCBridge{T}\n\nThe set of points x satisfying the constraint\n\nfrac12x^T Q x + a^T x + b le 0\n\nis a convex set if Q is positive semidefinite and is the union of two convex cones if a and b are zero (i.e. homogeneous case) and Q has only one negative eigenvalue. Currently, only the non-homogeneous transformation is implemented, see the Note section below for more details.\n\nNon-homogeneous case\n\nIf Q is positive semidefinite, there exists U such that Q = U^T U, the inequality can then be rewritten as\n\nU x_2^2 le 2 (-a^T x - b)\n\nwhich is equivalent to the membership of (1, -a^T x - b, Ux) to the rotated second-order cone.\n\nHomogeneous case\n\nIf Q has only one negative eigenvalue, the set of x such that x^T Q x le 0 is the union of a convex cone and its opposite. We can choose which one to model by checking the existence of bounds on variables as shown below.\n\nSecond-order cone\n\nIf Q is diagonal and has eigenvalues (1, 1, -1), the inequality x^2 + x^2 le z^2 combined with z ge 0 defines the Lorenz cone (i.e. the second-order cone) but when combined with z le 0, it gives the opposite of the second order cone. Therefore, we need to check if the variable z has a lower bound 0 or an upper bound 0 in order to determine which cone is\n\nRotated second-order cone\n\nThe matrix Q corresponding to the inequality x^2 le 2yz has one eigenvalue 1 with eigenvectors (1, 0, 0) and (0, 1, -1) and one eigenvalue -1 corresponding to the eigenvector (0, 1, 1). Hence if we intersect this union of two convex cone with the halfspace x + y ge 0, we get the rotated second-order cone and if we intersect it with the halfspace x + y le 0 we get the opposite of the rotated second-order cone. Note that y and z have the same sign since yz is nonnegative hence x + y ge 0 is equivalent to x ge 0 and y ge 0.\n\nNote\n\nThe check for existence of bound can be implemented (but inefficiently) with the current interface but if bound is removed or transformed (e.g. ≤ 0 transformed into ≥ 0) then the bridge is no longer valid. For this reason the homogeneous version of the bridge is not implemented yet.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.SOCtoPSDBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.SOCtoPSDBridge","text":"The SOCtoPSDBridge transforms the second order cone constraint lVert x rVert le t into the semidefinite cone constraints\n\nbeginpmatrix\n  t  x^top\n  x  tI\nendpmatrix succeq 0\n\nIndeed by the Schur Complement, it is positive definite iff\n\nbeginalign*\n  tI  succ 0\n  t - x^top (tI)^-1 x  succ 0\nendalign*\n\nwhich is equivalent to\n\nbeginalign*\n  t   0\n  t^2   x^top x\nendalign*\n\nwarning: Warning\nThis bridge is not added by default by MOI.Bridges.full_bridge_optimizer as bridging second order cone constraints to semidefinite constraints can be achieved by the SOCtoRSOCBridge followed by the RSOCtoPSDBridge while creating a smaller semidefinite constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge","text":"The RSOCtoPSDBridge transforms the second order cone constraint lVert x rVert le 2tu with u ge 0 into the semidefinite cone constraints\n\nbeginpmatrix\n  t  x^top\n  x  2uI\nendpmatrix succeq 0\n\nIndeed by the Schur Complement, it is positive definite iff\n\nbeginalign*\n  uI  succ 0\n  t - x^top (2uI)^-1 x  succ 0\nendalign*\n\nwhich is equivalent to\n\nbeginalign*\n  u   0\n  2tu   x^top x\nendalign*\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.NormInfinityBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.NormInfinityBridge","text":"NormInfinityBridge{T}\n\nThe NormInfinityCone is representable with LP constraints, since t ge max_i lvert x_i rvert if and only if t ge x_i and t ge -x_i for all i.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.NormOneBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.NormOneBridge","text":"NormOneBridge{T}\n\nThe NormOneCone is representable with LP constraints, since t ge sum_i lvert x_i rvert if and only if there exists a vector y such that t ge sum_i y_i and y_i ge x_i, y_i ge -x_i for all i.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge","text":"GeoMeantoRelEntrBridge{T}\n\nThe geometric mean cone is representable with a relative entropy constraint and a nonnegative auxiliary variable.\n\nThis is because u le prod_i=1^n w_i^1n is equivalent to y ge 0 and 0 le u + y le prod_i=1^n w_i^1n, and the latter inequality is equivalent to 1 le prod_i=1^n (fracw_iu + y)^1n, which is equivalent to 0 le sum_i=1^n log (fracw_iu + y)^1n, which is equivalent to 0 ge sum_i=1^n (u + y) log (fracu + yw_i).\n\nThus (u w) in GeometricMeanCone(1 + n) is representable as y ge 0, (0 w (u + y) e) in RelativeEntropyCone(1 + 2n), where e is a vector of ones.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.GeoMeanBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.GeoMeanBridge","text":"GeoMeanBridge{T, F, G, H}\n\nThe GeometricMeanCone is SecondOrderCone representable; see [1, p. 105].\n\nThe reformulation is best described in an example.\n\nConsider the cone of dimension 4:\n\nt le sqrt3x_1 x_2 x_3\n\nThis can be rewritten as exists x_21 ge 0 such that:\n\nbeginalign*\n  t  le x_21\n  x_21^4  le x_1 x_2 x_3 x_21\nendalign*\n\nNote that we need to create x_21 and not use t^4 directly as t is allowed to be negative. Now, this is equivalent to:\n\nbeginalign*\n  t  le x_21sqrt4\n  x_21^2  le 2x_11 x_12\n  x_11^2  le 2x_1 x_2  x_12^2  le 2x_3(x_21sqrt4)\nendalign*\n\n[1] Ben-Tal, Aharon, and Arkadi Nemirovski. Lectures on modern convex     optimization: analysis, algorithms, and engineering applications. Society     for Industrial and Applied Mathematics, 2001.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.RelativeEntropyBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.RelativeEntropyBridge","text":"RelativeEntropyBridge{T}\n\nThe RelativeEntropyCone is representable with exponential cone and LP constraints, since u ge sum_i=1^n w_i log (fracw_iv_i) if and only if there exists a vector y such that u ge sum_i y_i and y_i ge w_i log (fracw_iv_i) or equivalently v_i ge w_i exp (frac-y_iw_i) or equivalently (-y_i w_i v_i) in ExponentialCone, for all i.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.NormSpectralBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.NormSpectralBridge","text":"NormSpectralBridge{T}\n\nThe NormSpectralCone is representable with a PSD constraint, since t ge sigma_1(X) if and only if tI X^top X tI succ 0.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.NormNuclearBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.NormNuclearBridge","text":"NormNuclearBridge{T}\n\nThe NormNuclearCone is representable with an SDP constraint and extra variables, since t ge sum_i sigma_i (X) if and only if there exists symmetric matrices U V such that U X^top X V succ 0 and t ge (tr(U) + tr(V))  2.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.SquareBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.SquareBridge","text":"SquareBridge{T, F<:MOI.AbstractVectorFunction,\n             G<:MOI.AbstractScalarFunction,\n             TT<:MOI.AbstractSymmetricMatrixSetTriangle,\n             ST<:MOI.AbstractSymmetricMatrixSetSquare} <: AbstractBridge\n\nThe SquareBridge reformulates the constraint of a square matrix to be in ST to a list of equality constraints for pair or off-diagonal entries with different expressions and a TT constraint the upper triangular part of the matrix.\n\nFor instance, the constraint for the matrix\n\nbeginpmatrix\n  1       1 + x  2 - 3x\n  1 +  x  2 + x  3 -  x\n  2 - 3x  2 + x      2x\nendpmatrix\n\nto be PSD can be broken down to the constraint of the symmetric matrix\n\nbeginpmatrix\n  1       1 + x  2 - 3x\n  cdot  2 + x  3 -  x\n  cdot  cdot     2x\nendpmatrix\n\nand the equality constraint between the off-diagonal entries (2, 3) and (3, 2) 2x == 1. Note that now symmetrization constraint need to be added between the off-diagonal entries (1, 2) and (2, 1) or between (1, 3) and (3, 1) since the expressions are the same.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.RootDetBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.RootDetBridge","text":"RootDetBridge{T,F,G,H}\n\nThe RootDetConeTriangle is representable by a PositiveSemidefiniteConeTriangle and an GeometricMeanCone constraints; see [1, p. 149].\n\nIndeed, t le det(X)^1n if and only if there exists a lower triangular matrix Δ such that:\n\nbeginalign*\n  beginpmatrix\n    X  Δ\n    Δ^top  mathrmDiag(Δ)\n  endpmatrix  succeq 0\n  t  le (Δ_11 Δ_22 cdots Δ_nn)^1n\nendalign*\n\n[1] Ben-Tal, Aharon, and Arkadi Nemirovski. Lectures on modern convex     optimization: analysis, algorithms, and engineering applications. Society     for Industrial and Applied Mathematics, 2001.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.LogDetBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.LogDetBridge","text":"LogDetBridge{T,F,G,H,I}\n\nThe LogDetConeTriangle is representable by a PositiveSemidefiniteConeTriangle and ExponentialCone constraints.\n\nIndeed, logdet(X) = log(delta_1) + cdots + log(delta_n) where delta_1, ..., delta_n are the eigenvalues of X.\n\nAdapting the method from [1, p. 149], we see that t le u log(det(Xu)) for u  0 if and only if there exists a lower triangular matrix Δ such that\n\nbeginalign*\n  beginpmatrix\n    X  Δ\n    Δ^top  mathrmDiag(Δ)\n  endpmatrix  succeq 0\n  t  le u log(Δ_11u) + u log(Δ_22u) + cdots + u log(Δ_nnu)\nendalign*\n\n[1] Ben-Tal, Aharon, and Arkadi Nemirovski. Lectures on modern convex     optimization: analysis, algorithms, and engineering applications. Society     for Industrial and Applied Mathematics, 2001. ```\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge","text":"IndicatorActiveOnFalseBridge{T}\n\nThe IndicatorActiveOnFalseBridge replaces an indicator constraint activated on 0 with a variable z_0 with the constraint activated on 1, with a variable z_1. It stores the added variable and added constraints:\n\nz_1 in mathbbB in zero_one_cons\nz_0 + z_1 == 1 in `indisjunction_cons`\nThe added ACTIVATE_ON_ONE indicator constraint in indicator_cons_index.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge","text":"IndicatorSOS1Bridge{T,S<:MOI.AbstractScalarSet}\n\nThe IndicatorSOS1Bridge replaces an indicator constraint of the following form: z in mathbbB z == 1 implies f(x) in S with a SOS1 constraint: z in mathbbB slack text free f(x) + slack in S SOS1(slack z).\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.SemiToBinaryBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.SemiToBinaryBridge","text":"SemiToBinaryBridge{T, S <: MOI.AbstractScalarSet}\n\nThe SemiToBinaryBridge replaces a Semicontinuous constraint: x in mathsfSemicontinuous(l u) is replaced by: z in 0 1, x leq z cdot u, x geq z cdot l.\n\nThe SemiToBinaryBridge replaces a Semiinteger constraint: x in Semiinteger(l u) is replaced by: z in 0 1, x in mathbbZ, x leq z cdot u, x geq z cdot l.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.ZeroOneBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.ZeroOneBridge","text":"ZeroOneBridge{T}\n\nThe ZeroOneBridge splits a MOI.VariableIndex-in-MOI.ZeroOne constraint into a MOI.VariableIndex-in-MOI.Integer constraint and a MOI.VariableIndex-in-MOI.Interval(0, 1) constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#ref_variable_bridges","page":"API Reference","title":"Variable bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.Variable.AbstractBridge\nBridges.Variable.SingleBridgeOptimizer\nBridges.Variable.add_all_bridges","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.AbstractBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.AbstractBridge","text":"AbstractBridge\n\nSubtype of MathOptInterface.Bridges.AbstractBridge for variable bridges.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.SingleBridgeOptimizer","page":"API Reference","title":"MathOptInterface.Bridges.Variable.SingleBridgeOptimizer","text":"SingleBridgeOptimizer{BT<:AbstractBridge, OT<:MOI.ModelLike} <:\nAbstractBridgeOptimizer\n\nThe SingleBridgeOptimizer bridges any constrained variables supported by the bridge BT. This is in contrast with the MathOptInterface.Bridges.LazyBridgeOptimizer which only bridges the constrained variables that are unsupported by the internal model, even if they are supported by one of its bridges.\n\nnote: Note\nTwo bridge optimizers using variable bridges cannot be used together as both of them assume that the underlying model only returns variable indices with nonnegative values.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.add_all_bridges","page":"API Reference","title":"MathOptInterface.Bridges.Variable.add_all_bridges","text":"add_all_bridges(bridged_model, ::Type{T}) where {T}\n\nAdd all bridges defined in the Bridges.Variable submodule to bridged_model. The coefficient type used is T.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#variable_bridges_ref","page":"API Reference","title":"Bridges implemented","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.Variable.FlipSignBridge\nBridges.Variable.ZerosBridge\nBridges.Variable.FreeBridge\nBridges.Variable.NonposToNonnegBridge\nBridges.Variable.VectorizeBridge\nBridges.Variable.SOCtoRSOCBridge\nBridges.Variable.RSOCtoSOCBridge\nBridges.Variable.RSOCtoPSDBridge","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.FlipSignBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.FlipSignBridge","text":"FlipSignBridge{T, S1, S2}\n\nBridge constrained variables in S1 into constrained variables in S2 by multiplying the variables by -1 and taking the point reflection of the set across the origin. The flipped MOI.VectorOfVariables-in-S constraint is stored in the flipped_constraint field by convention.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.ZerosBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.ZerosBridge","text":"ZerosBridge{T} <: Bridges.Variable.AbstractBridge\n\nTransforms constrained variables in MathOptInterface.Zeros to zeros, which ends up creating no variables in the underlying model.\n\nThe bridged variables are therefore similar to parameters with zero values. Parameters with non-zero value can be created with constrained variables in MOI.EqualTo by combining a VectorizeBridge and this bridge. The functions cannot be unbridged, given a function, we cannot determine, if the bridged variables were used.\n\nThe dual values cannot be determined by the bridge but they can be determined by the bridged optimizer using MathOptInterface.Utilities.get_fallback if a CachingOptimizer is used (since ConstraintFunction cannot be got as functions cannot be unbridged).\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.FreeBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.FreeBridge","text":"FreeBridge{T} <: Bridges.Variable.AbstractBridge\n\nTransforms constrained variables in MOI.Reals to the difference of constrained variables in MOI.Nonnegatives.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.NonposToNonnegBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.NonposToNonnegBridge","text":"NonposToNonnegBridge{T} <:\n    FlipSignBridge{T, MOI.Nonpositives, MOI.Nonnegatives}\n\nTransforms constrained variables in Nonpositives into constrained variables in Nonnegatives.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.VectorizeBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.VectorizeBridge","text":"VectorizeBridge{T, S}\n\nTransforms a constrained variable in scalar_set_type(S, T) where S <: VectorLinearSet into a constrained vector of one variable in S. For instance, VectorizeBridge{Float64, MOI.Nonnegatives} transforms a constrained variable in MOI.GreaterThan{Float64} into a constrained vector of one variable in MOI.Nonnegatives.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.SOCtoRSOCBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.SOCtoRSOCBridge","text":"SOCtoRSOCBridge{T} <: Bridges.Variable.SetMapBridge{T,MOI.RotatedSecondOrderCone,MOI.SecondOrderCone}\n\nSame transformation as MOI.Bridges.Constraint.SOCtoRSOCBridge.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.RSOCtoSOCBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.RSOCtoSOCBridge","text":"RSOCtoSOCBridge{T} <: Bridges.Variable.SetMapBridge{T,MOI.SecondOrderCone,MOI.RotatedSecondOrderCone}\n\nSame transformation as MOI.Bridges.Constraint.RSOCtoSOCBridge.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.RSOCtoPSDBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.RSOCtoPSDBridge","text":"RSOCtoPSDBridge{T} <: Bridges.Variable.AbstractBridge\n\nTransforms constrained variables in MathOptInterface.RotatedSecondOrderCone to constrained variables in MathOptInterface.PositiveSemidefiniteConeTriangle.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#Objective-bridges","page":"API Reference","title":"Objective bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.Objective.AbstractBridge\nBridges.Objective.SingleBridgeOptimizer\nBridges.Objective.add_all_bridges","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Objective.AbstractBridge","page":"API Reference","title":"MathOptInterface.Bridges.Objective.AbstractBridge","text":"AbstractBridge\n\nSubtype of MathOptInterface.Bridges.AbstractBridge for objective bridges.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Objective.SingleBridgeOptimizer","page":"API Reference","title":"MathOptInterface.Bridges.Objective.SingleBridgeOptimizer","text":"SingleBridgeOptimizer{BT<:AbstractBridge, OT<:MOI.ModelLike} <: AbstractBridgeOptimizer\n\nThe SingleBridgeOptimizer bridges any objective functions supported by the bridge BT. This is in contrast with the MathOptInterface.Bridges.LazyBridgeOptimizer which only bridges the objective functions that are unsupported by the internal model, even if they are supported by one of its bridges.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Objective.add_all_bridges","page":"API Reference","title":"MathOptInterface.Bridges.Objective.add_all_bridges","text":"add_all_bridges(bridged_model, ::Type{T}) where {T}\n\nAdd all bridges defined in the Bridges.Objective submodule to bridged_model. The coefficient type used is T.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#objective_bridges_ref","page":"API Reference","title":"Bridges implemented","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.Objective.SlackBridge\nBridges.Objective.FunctionizeBridge","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Objective.SlackBridge","page":"API Reference","title":"MathOptInterface.Bridges.Objective.SlackBridge","text":"SlackBridge{T, F, G}\n\nThe SlackBridge converts an objective function of type G into a MOI.VariableIndex objective by creating a slack variable and a F-in-MOI.LessThan constraint for minimization or F-in-MOI.LessThan constraint for maximization where F is MOI.Utilities.promote_operation(-, T, G, MOI.VariableIndex}. Note that when using this bridge, changing the optimization sense is not supported. Set the sense to MOI.FEASIBILITY_SENSE first to delete the bridge in order to change the sense, then re-add the objective.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Objective.FunctionizeBridge","page":"API Reference","title":"MathOptInterface.Bridges.Objective.FunctionizeBridge","text":"FunctionizeBridge{T}\n\nThe FunctionizeBridge converts a VariableIndex objective into a ScalarAffineFunction{T} objective.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"AbstractCallback\nAbstractSubmittable\nsubmit","category":"page"},{"location":"moi/reference/callbacks/#MathOptInterface.AbstractCallback","page":"Callbacks","title":"MathOptInterface.AbstractCallback","text":"abstract type AbstractCallback <: AbstractModelAttribute end\n\nAbstract type for a model attribute representing a callback function. The value set to subtypes of AbstractCallback is a function that may be called during optimize!. As optimize! is in progress, the result attributes (i.e, the attributes attr such that is_set_by_optimize(attr)) may not be accessible from the callback, hence trying to get result attributes might throw a OptimizeInProgress error.\n\nAt most one callback of each type can be registered. If an optimizer already has a function for a callback type, and the user registers a new function, then the old one is replaced.\n\nThe value of the attribute should be a function taking only one argument, commonly called callback_data, that can be used for instance in LazyConstraintCallback, HeuristicCallback and UserCutCallback.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.AbstractSubmittable","page":"Callbacks","title":"MathOptInterface.AbstractSubmittable","text":"AbstractSubmittable\n\nAbstract supertype for objects that can be submitted to the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.submit","page":"Callbacks","title":"MathOptInterface.submit","text":"submit(optimizer::AbstractOptimizer, sub::AbstractSubmittable,\n       values...)::Nothing\n\nSubmit values to the submittable sub of the optimizer optimizer.\n\nAn UnsupportedSubmittable error is thrown if model does not support the attribute attr (see supports) and a SubmitNotAllowed error is thrown if it supports the submittable sub but it cannot be submitted.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/callbacks/#Attributes","page":"Callbacks","title":"Attributes","text":"","category":"section"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"CallbackNodeStatus\nCallbackNodeStatusCode\nCallbackVariablePrimal","category":"page"},{"location":"moi/reference/callbacks/#MathOptInterface.CallbackNodeStatus","page":"Callbacks","title":"MathOptInterface.CallbackNodeStatus","text":"CallbackNodeStatus(callback_data)\n\nAn optimizer attribute describing the (in)feasibility of the primal solution available from CallbackVariablePrimal during a callback identified by callback_data.\n\nReturns a CallbackNodeStatusCode Enum.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.CallbackNodeStatusCode","page":"Callbacks","title":"MathOptInterface.CallbackNodeStatusCode","text":"CallbackNodeStatusCode\n\nAn Enum of possible return values from calling get with CallbackNodeStatus.\n\nPossible values are:\n\nCALLBACK_NODE_STATUS_INTEGER: the primal solution available from CallbackVariablePrimal is integer feasible.\nCALLBACK_NODE_STATUS_FRACTIONAL: the primal solution available from CallbackVariablePrimal is integer infeasible.\nCALLBACK_NODE_STATUS_UNKNOWN: the primal solution available from CallbackVariablePrimal might be integer feasible or infeasible.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.CallbackVariablePrimal","page":"Callbacks","title":"MathOptInterface.CallbackVariablePrimal","text":"CallbackVariablePrimal(callback_data)\n\nA variable attribute for the assignment to some primal variable's value during the callback identified by callback_data.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#Lazy-constraints","page":"Callbacks","title":"Lazy constraints","text":"","category":"section"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"LazyConstraintCallback\nLazyConstraint","category":"page"},{"location":"moi/reference/callbacks/#MathOptInterface.LazyConstraintCallback","page":"Callbacks","title":"MathOptInterface.LazyConstraintCallback","text":"LazyConstraintCallback() <: AbstractCallback\n\nThe callback can be used to reduce the feasible set given the current primal solution by submitting a LazyConstraint. For instance, it may be called at an incumbent of a mixed-integer problem. Note that there is no guarantee that the callback is called at every feasible primal solution.\n\nThe current primal solution is accessed through CallbackVariablePrimal. Trying to access other result attributes will throw OptimizeInProgress as discussed in AbstractCallback.\n\nExamples\n\nx = MOI.add_variables(optimizer, 8)\nMOI.set(optimizer, MOI.LazyConstraintCallback(), callback_data -> begin\n    sol = MOI.get(optimizer, MOI.CallbackVariablePrimal(callback_data), x)\n    if # should add a lazy constraint\n        func = # computes function\n        set = # computes set\n        MOI.submit(optimizer, MOI.LazyConstraint(callback_data), func, set)\n    end\nend)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.LazyConstraint","page":"Callbacks","title":"MathOptInterface.LazyConstraint","text":"LazyConstraint(callback_data)\n\nLazy constraint func-in-set submitted as func, set. The optimal solution returned by VariablePrimal will satisfy all lazy constraints that have been submitted.\n\nThis can be submitted only from the LazyConstraintCallback. The field callback_data is a solver-specific callback type that is passed as the argument to the feasible solution callback.\n\nExamples\n\nSuppose x and y are VariableIndexs of optimizer. To add a LazyConstraint for 2x + 3y <= 1, write\n\nfunc = 2.0x + 3.0y\nset = MOI.LessThan(1.0)\nMOI.submit(optimizer, MOI.LazyConstraint(callback_data), func, set)\n\ninside a LazyConstraintCallback of data callback_data.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#User-cuts","page":"Callbacks","title":"User cuts","text":"","category":"section"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"UserCutCallback\nUserCut","category":"page"},{"location":"moi/reference/callbacks/#MathOptInterface.UserCutCallback","page":"Callbacks","title":"MathOptInterface.UserCutCallback","text":"UserCutCallback() <: AbstractCallback\n\nThe callback can be used to submit UserCut given the current primal solution. For instance, it may be called at fractional (i.e., non-integer) nodes in the branch and bound tree of a mixed-integer problem. Note that there is not guarantee that the callback is called everytime the solver has an infeasible solution.\n\nThe infeasible solution is accessed through CallbackVariablePrimal. Trying to access other result attributes will throw OptimizeInProgress as discussed in AbstractCallback.\n\nExamples\n\nx = MOI.add_variables(optimizer, 8)\nMOI.set(optimizer, MOI.UserCutCallback(), callback_data -> begin\n    sol = MOI.get(optimizer, MOI.CallbackVariablePrimal(callback_data), x)\n    if # can find a user cut\n        func = # computes function\n        set = # computes set\n        MOI.submit(optimizer, MOI.UserCut(callback_data), func, set)\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.UserCut","page":"Callbacks","title":"MathOptInterface.UserCut","text":"UserCut(callback_data)\n\nConstraint func-to-set suggested to help the solver detect the solution given by CallbackVariablePrimal as infeasible. The cut is submitted as func, set. Typically CallbackVariablePrimal will violate integrality constraints, and a cut would be of the form ScalarAffineFunction-in-LessThan or ScalarAffineFunction-in-GreaterThan. Note that, as opposed to LazyConstraint, the provided constraint cannot modify the feasible set, the constraint should be redundant, e.g., it may be a consequence of affine and integrality constraints.\n\nThis can be submitted only from the UserCutCallback. The field callback_data is a solver-specific callback type that is passed as the argument to the infeasible solution callback.\n\nNote that the solver may silently ignore the provided constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#Heuristic-solutions","page":"Callbacks","title":"Heuristic solutions","text":"","category":"section"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"HeuristicCallback\nHeuristicSolutionStatus\nHeuristicSolution","category":"page"},{"location":"moi/reference/callbacks/#MathOptInterface.HeuristicCallback","page":"Callbacks","title":"MathOptInterface.HeuristicCallback","text":"HeuristicCallback() <: AbstractCallback\n\nThe callback can be used to submit HeuristicSolution given the current primal solution. For instance, it may be called at fractional (i.e., non-integer) nodes in the branch and bound tree of a mixed-integer problem. Note that there is not guarantee that the callback is called everytime the solver has an infeasible solution.\n\nThe current primal solution is accessed through CallbackVariablePrimal. Trying to access other result attributes will throw OptimizeInProgress as discussed in AbstractCallback.\n\nExamples\n\nx = MOI.add_variables(optimizer, 8)\nMOI.set(optimizer, MOI.HeuristicCallback(), callback_data -> begin\n    sol = MOI.get(optimizer, MOI.CallbackVariablePrimal(callback_data), x)\n    if # can find a heuristic solution\n        values = # computes heuristic solution\n        MOI.submit(optimizer, MOI.HeuristicSolution(callback_data), x,\n                   values)\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.HeuristicSolutionStatus","page":"Callbacks","title":"MathOptInterface.HeuristicSolutionStatus","text":"HeuristicSolutionStatus\n\nAn Enum of possible return values for submit with HeuristicSolution. This informs whether the heuristic solution was accepted or rejected. Possible values are:\n\nHEURISTIC_SOLUTION_ACCEPTED: The heuristic solution was accepted.\nHEURISTIC_SOLUTION_REJECTED: The heuristic solution was rejected.\nHEURISTIC_SOLUTION_UNKNOWN: No information available on the acceptance.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.HeuristicSolution","page":"Callbacks","title":"MathOptInterface.HeuristicSolution","text":"HeuristicSolution(callback_data)\n\nHeuristically obtained feasible solution. The solution is submitted as variables, values where values[i] gives the value of variables[i], similarly to set. The submit call returns a HeuristicSolutionStatus indicating whether the provided solution was accepted or rejected.\n\nThis can be submitted only from the HeuristicCallback. The field callback_data is a solver-specific callback type that is passed as the argument to the heuristic callback.\n\nSome solvers require a complete solution, others only partial solutions.\n\n\n\n\n\n","category":"type"},{"location":"developers/contributing/#How-to-contribute-to-JuMP","page":"Contributing","title":"How to contribute to JuMP","text":"","category":"section"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Welcome! This document explains some ways you can contribute to JuMP.","category":"page"},{"location":"developers/contributing/#Code-of-Conduct","page":"Contributing","title":"Code of Conduct","text":"","category":"section"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"This project and everyone participating in it is governed by the JuMP Code of Conduct. By participating, you are expected to uphold this code.","category":"page"},{"location":"developers/contributing/#Join-the-community-forum","page":"Contributing","title":"Join the community forum","text":"","category":"section"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"First up, join the community forum.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"The forum is a good place to ask questions about how to use JuMP. You can also use the forum to discuss possible feature requests and bugs before raising a GitHub issue (more on this below).","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Aside from asking questions, the easiest way you can contribute to JuMP is to help answer questions on the forum!","category":"page"},{"location":"developers/contributing/#Join-the-developer-chatroom","page":"Contributing","title":"Join the developer chatroom","text":"","category":"section"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"If you're interested in contributing code to JuMP, the next place to join is the developer chatroom. Let us know what you have in mind, and we can point you in the right direction.","category":"page"},{"location":"developers/contributing/#Improve-the-documentation","page":"Contributing","title":"Improve the documentation","text":"","category":"section"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Chances are, if you asked (or answered) a question on the community forum, then it is a sign that the documentation could be improved. Moreover, since it is your question, you are probably the best-placed person to improve it!","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"The docs are written in Markdown and are built using Documenter.jl. You can find the source of all the docs here.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"If your change is small (like fixing typos, or one or two sentence corrections), the easiest way to do this is via GitHub's online editor. (GitHub has help on how to do this.)","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"If your change is larger, or touches multiple files, you will need to make the change locally and then use Git to submit a pull request. (See Contribute code to JuMP below for more on this.)","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"tip: Tip\nIf you need any help, come join the developer chatroom and we will walk you through the process.","category":"page"},{"location":"developers/contributing/#File-a-bug-report","page":"Contributing","title":"File a bug report","text":"","category":"section"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Another way to contribute to JuMP is to file bug reports.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Make sure you read the info in the box where you write the body of the issue before posting. You can also find a copy of that info here.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"tip: Tip\nIf you're unsure whether you have a real bug, post on the community forum first. Someone will either help you fix the problem, or let you know the most appropriate place to open a bug report.","category":"page"},{"location":"developers/contributing/#Contribute-code-to-JuMP","page":"Contributing","title":"Contribute code to JuMP","text":"","category":"section"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Finally, you can also contribute code to JuMP!","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"warning: Warning\nIf you do not have experience with Git, GitHub, and Julia development, the first steps can be a little daunting. However, there are lots of tutorials available online, including these for:GitHub\nGit and GitHub\nGit\nJulia package developmentIf you need any help, come join the developer chatroom and we will walk you through the process.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Once you are familiar with Git and GitHub, the workflow for contributing code to JuMP is similar to the following:","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 1: decide what to work on","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"The first step is to find an open issue (or open a new one) for the problem you want to solve. Then, before spending too much time on it, discuss what you are planning to do in the issue to see if other contributors are fine with your proposed changes. Getting feedback early can improve code quality, and avoid time spent writing code that does not get merged into JuMP.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"tip: Tip\nAt this point, remember to be patient and polite; you may get a lot of comments on your issue! However, do not be afraid! Comments mean that people are willing to help you improve the code that you are contributing to JuMP.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 2: fork JuMP","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Go to https://github.com/jump-dev/JuMP.jl and click the \"Fork\" button in the top-right corner. This will create a copy of JuMP under your GitHub account.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 3: install JuMP locally","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Open Julia and run:","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"] dev JuMP","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"This will download the JuMP Git repository to ~/.julia/dev/JuMP. If you're on Windows, this will be C:\\\\Users\\\\<my_name>\\\\.julia\\\\dev\\\\JuMP.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"warning: Warning\n] command means \"first type ] to enter the Julia pkg mode, then type the rest. Don't copy-paste the code directly.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 4: checkout a new branch","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nIn the following, replace any instance of GITHUB_ACCOUNT with your GitHub user name.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"The next step is to checkout a development branch. In a terminal (or command prompt on Windows), run:","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"$ cd ~/.julia/dev/JuMP\n\n$ git remote add GITHUB_ACCOUNT https://github.com/GITHUB_ACCOUNT/JuMP.jl.git\n\n$ git checkout master\n\n$ git pull\n\n$ git checkout -b my_new_branch","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"tip: Tip\nLines starting with $ mean \"run these in a terminal (command prompt on Windows).\"","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 5: make changes","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Now make any changes to the source code inside the ~/.julia/dev/JuMP directory.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Make sure you:","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Follow the Style guide and run JuliaFormatter\nAdd tests and documentation for any changes or new features","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"tip: Tip\nWhen you change the source code, you'll need to restart Julia for the changes to take effect. This is a pain, so install Revise.jl.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 6a: test your code changes","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"To test that your changes work, run the JuMP test-suite by opening Julia and running:","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"cd(\"~/.julia/dev/JuMP\")\n] activate .\n] test","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"warning: Warning\nRunning the tests might take a long time (~10–15 minutes).","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"tip: Tip\nIf you're using Revise.jl, you can also run the tests by calling include:include(\"test/runtests.jl\")This can be faster if you want to re-run the tests multiple times.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 6b: test your documentation changes","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Open Julia, then run:","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"cd(\"~/.julia/dev/JuMP/docs\")\n] activate .\ninclude(\"src/make.jl\")","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"warning: Warning\nBuilding the documentation might take a long time (~10 minutes).","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"tip: Tip\nIf there's a problem with the tests that you don't know how to fix, don't worry. Continue to step 5, and one of the JuMP contributors will comment on your pull request telling you how to fix things.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 7: make a pull request","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Once you've made changes, you're ready to push the changes to GitHub. Run:","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"$ cd ~/.julia/dev/JuMP\n\n$ git add .\n\n$ git commit -m \"A descriptive message of the changes\"\n\n$ git push -u GITHUB_ACCOUNT my_new_branch","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Then go to https://github.com/jump-dev/JuMP.jl and follow the instructions that pop up to open a pull request.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 8: respond to comments","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"At this point, remember to be patient and polite; you may get a lot of comments on your pull request! However, do not be afraid! A lot of comments means that people are willing to help you improve the code that you are contributing to JuMP.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"To respond to the comments, go back to step 5, make any changes, test the changes in step 6, and then make a new commit in step 7. Your PR will automatically update.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 9: cleaning up","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Once the PR is merged, clean-up your Git repository ready for the next contribution!","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"$ cd ~/.julia/dev/JuMP\n\n$ git checkout master\n\n$ git pull","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nIf you have suggestions to improve this guide, please make a pull request! It's particularly helpful if you do this after your first pull request because you'll know all the parts that could be explained better.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Thanks for contributing to JuMP!","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/linear/knapsack.jl\"","category":"page"},{"location":"tutorials/linear/knapsack/#The-knapsack-problem","page":"The knapsack problem","title":"The knapsack problem","text":"","category":"section"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"Formulate and solve a simple knapsack problem:","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"max sum(p_j x_j)\n st sum(w_j x_j) <= C\n    x binary","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_knapsack(; verbose = true)\n    profit = [5, 3, 2, 7, 4]\n    weight = [2, 8, 4, 2, 5]\n    capacity = 10\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:5], Bin)\n    # Objective: maximize profit\n    @objective(model, Max, profit' * x)\n    # Constraint: can carry all\n    @constraint(model, weight' * x <= capacity)\n    # Solve problem using MIP solver\n    optimize!(model)\n    if verbose\n        println(\"Objective is: \", objective_value(model))\n        println(\"Solution is:\")\n        for i in 1:5\n            print(\"x[$i] = \", value(x[i]))\n            println(\", p[$i]/w[$i] = \", profit[i] / weight[i])\n        end\n    end\n    Test.@test termination_status(model) == OPTIMAL\n    Test.@test primal_status(model) == FEASIBLE_POINT\n    Test.@test objective_value(model) == 16.0\n    return\nend\n\nexample_knapsack()","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"reference/constraints/#ConstraintAPI","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"More information can be found in the Constraints section of the manual.","category":"page"},{"location":"reference/constraints/#Macros","page":"Constraints","title":"Macros","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"@constraint\n@constraints\nConstraintRef\nAbstractConstraint\nScalarConstraint\nVectorConstraint","category":"page"},{"location":"reference/constraints/#JuMP.@constraint","page":"Constraints","title":"JuMP.@constraint","text":"@constraint(m::Model, expr, kw_args...)\n\nAdd a constraint described by the expression expr.\n\n@constraint(m::Model, ref[i=..., j=..., ...], expr, kw_args...)\n\nAdd a group of constraints described by the expression expr parametrized by i, j, ...\n\nThe expression expr can either be\n\nof the form func in set constraining the function func to belong to the set set which is either a MOI.AbstractSet or one of the JuMP shortcuts SecondOrderCone, RotatedSecondOrderCone and PSDCone, e.g. @constraint(model, [1, x-1, y-2] in SecondOrderCone()) constrains the norm of [x-1, y-2] be less than 1;\nof the form a sign b, where sign is one of ==, ≥, >=, ≤ and <= building the single constraint enforcing the comparison to hold for the expression a and b, e.g. @constraint(m, x^2 + y^2 == 1) constrains x and y to lie on the unit circle;\nof the form a ≤ b ≤ c or a ≥ b ≥ c (where ≤ and <= (resp. ≥ and >=) can be used interchangeably) constraining the paired the expression b to lie between a and c;\nof the forms @constraint(m, a .sign b) or @constraint(m, a .sign b .sign c) which broadcast the constraint creation to each element of the vectors.\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate constraint names. It corresponds to the constraint name for scalar constraints, otherwise, the constraint names are set to base_name[...] for each index ... of the axes axes.\ncontainer: Specify the container type.\n\nNote for extending the constraint macro\n\nEach constraint will be created using add_constraint(m, build_constraint(_error, func, set)) where\n\n_error is an error function showing the constraint call in addition to the error message given as argument,\nfunc is the expression that is constrained\nand set is the set in which it is constrained to belong.\n\nFor expr of the first type (i.e. @constraint(m, func in set)), func and set are passed unchanged to build_constraint but for the other types, they are determined from the expressions and signs. For instance, @constraint(m, x^2 + y^2 == 1) is transformed into add_constraint(m, build_constraint(_error, x^2 + y^2, MOI.EqualTo(1.0))).\n\nTo extend JuMP to accept new constraints of this form, it is necessary to add the corresponding methods to build_constraint. Note that this will likely mean that either func or set will be some custom type, rather than e.g. a Symbol, since we will likely want to dispatch on the type of the function or set appearing in the constraint.\n\nFor extensions that need to create constraints with more information than just func and set, an additional positional argument can be specified to @constraint that will then be passed on build_constraint. Hence, we can enable this syntax by defining extensions of build_constraint(_error, func, set, my_arg; kw_args...). This produces the user syntax: @constraint(model, ref[...], expr, my_arg, kw_args...).\n\n\n\n\n\n","category":"macro"},{"location":"reference/constraints/#JuMP.@constraints","page":"Constraints","title":"JuMP.@constraints","text":"@constraints(model, args...)\n\nAdds groups of constraints at once, in the same fashion as the @constraint macro.\n\nThe model must be the first argument, and multiple constraints can be added on multiple lines wrapped in a begin ... end block.\n\nThe macro returns a tuple containing the constraints that were defined.\n\nExamples\n\n@constraints(model, begin\n    x >= 1\n    y - w <= 2\n    sum_to_one[i=1:3], z[i] + y == 1\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/constraints/#JuMP.ConstraintRef","page":"Constraints","title":"JuMP.ConstraintRef","text":"ConstraintRef\n\nHolds a reference to the model and the corresponding MOI.ConstraintIndex.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.AbstractConstraint","page":"Constraints","title":"JuMP.AbstractConstraint","text":"abstract type AbstractConstraint\n\nAn abstract base type for all constraint types. AbstractConstraints store the function and set directly, unlike ConstraintRefs that are merely references to constraints stored in a model. AbstractConstraints do not need to be attached to a model.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.ScalarConstraint","page":"Constraints","title":"JuMP.ScalarConstraint","text":"struct ScalarConstraint\n\nThe data for a scalar constraint. The func field contains a JuMP object representing the function and the set field contains the MOI set. See also the documentation on JuMP's representation of constraints for more background.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.VectorConstraint","page":"Constraints","title":"JuMP.VectorConstraint","text":"struct VectorConstraint\n\nThe data for a vector constraint. The func field contains a JuMP object representing the function and the set field contains the MOI set. The shape field contains an AbstractShape matching the form in which the constraint was constructed (e.g., by using matrices or flat vectors). See also the documentation on JuMP's representation of constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#Names","page":"Constraints","title":"Names","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"name(::ConstraintRef{Model,<:JuMP._MOICON})\nset_name(::ConstraintRef{Model,<:JuMP._MOICON}, ::String)\nconstraint_by_name","category":"page"},{"location":"reference/constraints/#JuMP.name-Tuple{ConstraintRef{Model, var\"#s1007\", Shape} where {var\"#s1007\"<:(MathOptInterface.ConstraintIndex), Shape<:AbstractShape}}","page":"Constraints","title":"JuMP.name","text":"name(con_ref::ConstraintRef)\n\nGet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"reference/constraints/#JuMP.set_name-Tuple{ConstraintRef{Model, var\"#s1007\", Shape} where {var\"#s1007\"<:(MathOptInterface.ConstraintIndex), Shape<:AbstractShape}, String}","page":"Constraints","title":"JuMP.set_name","text":"set_name(con_ref::ConstraintRef, s::AbstractString)\n\nSet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"reference/constraints/#JuMP.constraint_by_name","page":"Constraints","title":"JuMP.constraint_by_name","text":"constraint_by_name(model::AbstractModel,\n                   name::String)::Union{ConstraintRef, Nothing}\n\nReturn the reference of the constraint with name attribute name or Nothing if no constraint has this name attribute. Throws an error if several constraints have name as their name attribute.\n\nconstraint_by_name(model::AbstractModel,\n                   name::String,\n                   F::Type{<:Union{AbstractJuMPScalar,\n                                   Vector{<:AbstractJuMPScalar},\n                                   MOI.AbstactFunction}},\n                   S::Type{<:MOI.AbstractSet})::Union{ConstraintRef, Nothing}\n\nSimilar to the method above, except that it throws an error if the constraint is not an F-in-S contraint where F is either the JuMP or MOI type of the function, and S is the MOI type of the set. This method is recommended if you know the type of the function and set since its returned type can be inferred while for the method above (i.e. without F and S), the exact return type of the constraint index cannot be inferred.\n\njulia> using JuMP\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x^2 == 1)\ncon : x² = 1.0\n\njulia> constraint_by_name(model, \"kon\")\n\njulia> constraint_by_name(model, \"con\")\ncon : x² = 1.0\n\njulia> constraint_by_name(model, \"con\", AffExpr, MOI.EqualTo{Float64})\n\njulia> constraint_by_name(model, \"con\", QuadExpr, MOI.EqualTo{Float64})\ncon : x² = 1.0\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#Modification","page":"Constraints","title":"Modification","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"normalized_coefficient\nset_normalized_coefficient\n\nnormalized_rhs\nset_normalized_rhs\n\nadd_to_function_constant","category":"page"},{"location":"reference/constraints/#JuMP.normalized_coefficient","page":"Constraints","title":"JuMP.normalized_coefficient","text":"normalized_coefficient(con_ref::ConstraintRef, variable::VariableRef)\n\nReturn the coefficient associated with variable in constraint after JuMP has normalized the constraint into its standard form. See also set_normalized_coefficient.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.set_normalized_coefficient","page":"Constraints","title":"JuMP.set_normalized_coefficient","text":"set_normalized_coefficient(con_ref::ConstraintRef, variable::VariableRef, value)\n\nSet the coefficient of variable in the constraint constraint to value.\n\nNote that prior to this step, JuMP will aggregate multiple terms containing the same variable. For example, given a constraint 2x + 3x <= 2, set_normalized_coefficient(con, x, 4) will create the constraint 4x <= 2.\n\nmodel = Model()\n@variable(model, x)\n@constraint(model, con, 2x + 3x <= 2)\nset_normalized_coefficient(con, x, 4)\ncon\n\n# output\n\ncon : 4 x <= 2.0\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.normalized_rhs","page":"Constraints","title":"JuMP.normalized_rhs","text":"normalized_rhs(con_ref::ConstraintRef)\n\nReturn the right-hand side term of con_ref after JuMP has converted the constraint into its normalized form. See also set_normalized_rhs.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.set_normalized_rhs","page":"Constraints","title":"JuMP.set_normalized_rhs","text":"set_normalized_rhs(con_ref::ConstraintRef, value)\n\nSet the right-hand side term of constraint to value.\n\nNote that prior to this step, JuMP will aggregate all constant terms onto the right-hand side of the constraint. For example, given a constraint 2x + 1 <= 2, set_normalized_rhs(con, 4) will create the constraint 2x <= 4, not 2x + 1 <= 4.\n\njulia> @constraint(model, con, 2x + 1 <= 2)\ncon : 2 x <= 1.0\n\njulia> set_normalized_rhs(con, 4)\n\njulia> con\ncon : 2 x <= 4.0\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.add_to_function_constant","page":"Constraints","title":"JuMP.add_to_function_constant","text":"add_to_function_constant(constraint::ConstraintRef, value)\n\nAdd value to the function constant term.\n\nNote that for scalar constraints, JuMP will aggregate all constant terms onto the right-hand side of the constraint so instead of modifying the function, the set will be translated by -value. For example, given a constraint 2x <= 3, add_to_function_constant(c, 4) will modify it to 2x <= -1.\n\nExamples\n\nFor scalar constraints, the set is translated by -value:\n\njulia> @constraint(model, con, 0 <= 2x - 1 <= 2)\ncon : 2 x ∈ [1.0, 3.0]\n\njulia> add_to_function_constant(con, 4)\n\njulia> con\ncon : 2 x ∈ [-3.0, -1.0]\n\nFor vector constraints, the constant is added to the function:\n\njulia> @constraint(model, con, [x + y, x, y] in SecondOrderCone())\ncon : [x + y, x, y] ∈ MathOptInterface.SecondOrderCone(3)\n\njulia> add_to_function_constant(con, [1, 2, 2])\n\njulia> con\ncon : [x + y + 1, x + 2, y + 2] ∈ MathOptInterface.SecondOrderCone(3)\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#Deletion","page":"Constraints","title":"Deletion","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"JuMP.delete\nis_valid\nConstraintNotOwned","category":"page"},{"location":"reference/constraints/#JuMP.delete","page":"Constraints","title":"JuMP.delete","text":"delete(model::Model, con_ref::ConstraintRef)\n\nDelete the constraint associated with constraint_ref from the model model.\n\nNote that delete does not unregister the name from the model, so adding a new constraint of the same name will throw an error. Use unregister to unregister the name after deletion as follows:\n\n@constraint(model, c, 2x <= 1)\ndelete(model, c)\nunregister(model, :c)\n\nSee also: unregister\n\n\n\n\n\ndelete(model::Model, con_refs::Vector{<:ConstraintRef})\n\nDelete the constraints associated with con_refs from the model model. Solvers may implement specialized methods for deleting multiple constraints of the same concrete type, i.e., when isconcretetype(eltype(con_refs)). These may be more efficient than repeatedly calling the single constraint delete method.\n\nSee also: unregister\n\n\n\n\n\ndelete(model::Model, variable_ref::VariableRef)\n\nDelete the variable associated with variable_ref from the model model.\n\nNote that delete does not unregister the name from the model, so adding a new variable of the same name will throw an error. Use unregister to unregister the name after deletion as follows:\n\n@variable(model, x)\ndelete(model, x)\nunregister(model, :x)\n\nSee also: unregister\n\n\n\n\n\ndelete(model::Model, variable_refs::Vector{VariableRef})\n\nDelete the variables associated with variable_refs from the model model. Solvers may implement methods for deleting multiple variables that are more efficient than repeatedly calling the single variable delete method.\n\nSee also: unregister\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.is_valid","page":"Constraints","title":"JuMP.is_valid","text":"is_valid(model::Model, con_ref::ConstraintRef{<:AbstractModel})\n\nReturn true if constraint_ref refers to a valid constraint in model.\n\n\n\n\n\nis_valid(model::Model, variable_ref::VariableRef)\n\nReturn true if variable refers to a valid variable in model.\n\n\n\n\n\nis_valid(model::Model, c::NonlinearConstraintRef)\n\nReturn true if c refers to a valid nonlinear constraint in model.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.ConstraintNotOwned","page":"Constraints","title":"JuMP.ConstraintNotOwned","text":"struct ConstraintNotOwned{C <: ConstraintRef} <: Exception\n    constraint_ref::C\nend\n\nThe constraint constraint_ref was used in a model different to owner_model(constraint_ref).\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#Query-constraints","page":"Constraints","title":"Query constraints","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"list_of_constraint_types\nall_constraints\nnum_constraints\nindex(::ConstraintRef)\noptimizer_index(::ConstraintRef{Model})\nconstraint_object","category":"page"},{"location":"reference/constraints/#JuMP.list_of_constraint_types","page":"Constraints","title":"JuMP.list_of_constraint_types","text":"list_of_constraint_types(model::Model)::Vector{Tuple{Type,Type}}\n\nReturn a list of tuples of the form (F, S) where F is a JuMP function type and S is an MOI set type such that all_constraints(model, F, S) returns a nonempty list.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> list_of_constraint_types(model)\n3-element Array{Tuple{Type,Type},1}:\n (GenericAffExpr{Float64,VariableRef}, MathOptInterface.LessThan{Float64})\n (VariableRef, MathOptInterface.GreaterThan{Float64})\n (VariableRef, MathOptInterface.ZeroOne)\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.all_constraints","page":"Constraints","title":"JuMP.all_constraints","text":"all_constraints(model::Model, function_type, set_type)::Vector{<:ConstraintRef}\n\nReturn a list of all constraints currently in the model where the function has type function_type and the set has type set_type. The constraints are ordered by creation time.\n\nSee also list_of_constraint_types and num_constraints.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> all_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex,MathOptInterface.GreaterThan{Float64}},ScalarShape},1}:\n x ≥ 0.0\n\njulia> all_constraints(model, VariableRef, MOI.ZeroOne)\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex,MathOptInterface.ZeroOne},ScalarShape},1}:\n x binary\n\njulia> all_constraints(model, AffExpr, MOI.LessThan{Float64})\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n 2 x ≤ 1.0\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.num_constraints","page":"Constraints","title":"JuMP.num_constraints","text":"num_constraints(model::Model, function_type, set_type)::Int64\n\nReturn the number of constraints currently in the model where the function has type function_type and the set has type set_type.\n\nSee also list_of_constraint_types and all_constraints.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @variable(model, y);\n\njulia> @constraint(model, y in MOI.GreaterThan(1.0));\n\njulia> @constraint(model, y <= 1.0);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> num_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n2\n\njulia> num_constraints(model, VariableRef, MOI.ZeroOne)\n1\n\njulia> num_constraints(model, AffExpr, MOI.LessThan{Float64})\n2\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.index-Tuple{ConstraintRef}","page":"Constraints","title":"JuMP.index","text":"index(cr::ConstraintRef)::MOI.ConstraintIndex\n\nReturn the index of the constraint that corresponds to cr in the MOI backend.\n\n\n\n\n\n","category":"method"},{"location":"reference/constraints/#JuMP.optimizer_index-Tuple{ConstraintRef{Model, C, Shape} where {C, Shape<:AbstractShape}}","page":"Constraints","title":"JuMP.optimizer_index","text":"optimizer_index(cr::ConstraintRef{Model})::MOI.ConstraintIndex\n\nReturn the index of the constraint that corresponds to cr in the optimizer model. It throws NoOptimizer if no optimizer is set and throws an ErrorException if the optimizer is set but is not attached or if the constraint is bridged.\n\n\n\n\n\n","category":"method"},{"location":"reference/constraints/#JuMP.constraint_object","page":"Constraints","title":"JuMP.constraint_object","text":"constraint_object(con_ref::ConstraintRef)\n\nReturn the underlying constraint data for the constraint referenced by ref.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#Start-values","page":"Constraints","title":"Start values","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"set_dual_start_value\ndual_start_value","category":"page"},{"location":"reference/constraints/#JuMP.set_dual_start_value","page":"Constraints","title":"JuMP.set_dual_start_value","text":"set_dual_start_value(con_ref::ConstraintRef, value)\n\nSet the dual start value (MOI attribute ConstraintDualStart) of the constraint con_ref to value. To remove a dual start value set it to nothing.\n\nSee also dual_start_value.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.dual_start_value","page":"Constraints","title":"JuMP.dual_start_value","text":"dual_start_value(con_ref::ConstraintRef)\n\nReturn the dual start value (MOI attribute ConstraintDualStart) of the constraint con_ref.\n\nNote: If no dual start value has been set, dual_start_value will return nothing.\n\nSee also set_dual_start_value.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#Special-sets","page":"Constraints","title":"Special sets","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"SecondOrderCone\nRotatedSecondOrderCone\nPSDCone\nSOS1\nSOS2\nSkewSymmetricMatrixSpace\nSkewSymmetricMatrixShape\nSymMatrixSpace\nmoi_set","category":"page"},{"location":"reference/constraints/#JuMP.SecondOrderCone","page":"Constraints","title":"JuMP.SecondOrderCone","text":"SecondOrderCone\n\nSecond order cone object that can be used to constrain the euclidean norm of a vector x to be less than or equal to a nonnegative scalar t. This is a shortcut for the MOI.SecondOrderCone.\n\nExamples\n\nThe following constrains (x-1 x-2)_2 le t and t ge 0:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, t)\nt\n\njulia> @constraint(model, [t, x-1, x-2] in SecondOrderCone())\n[t, x - 1, x - 2] ∈ MathOptInterface.SecondOrderCone(3)\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.RotatedSecondOrderCone","page":"Constraints","title":"JuMP.RotatedSecondOrderCone","text":"RotatedSecondOrderCone\n\nRotated second order cone object that can be used to constrain the square of the euclidean norm of a vector x to be less than or equal to 2tu where t and u are nonnegative scalars. This is a shortcut for the MOI.RotatedSecondOrderCone.\n\nExamples\n\nThe following constrains (x-1 x-2)_2 le 2tx and t x ge 0:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, t)\nt\n\njulia> @constraint(model, [t, x, x-1, x-2] in RotatedSecondOrderCone())\n[t, x, x - 1, x - 2] ∈ MathOptInterface.RotatedSecondOrderCone(4)\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.PSDCone","page":"Constraints","title":"JuMP.PSDCone","text":"PSDCone\n\nPositive semidefinite cone object that can be used to constrain a square matrix to be positive semidefinite in the @constraint macro. If the matrix has type Symmetric then the columns vectorization (the vector obtained by concatenating the columns) of its upper triangular part is constrained to belong to the MOI.PositiveSemidefiniteConeTriangle set, otherwise its column vectorization is constrained to belong to the MOI.PositiveSemidefiniteConeSquare set.\n\nExamples\n\nConsider the following example:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> a = [ x 2x\n            2x  x];\n\njulia> b = [1 2\n            2 4];\n\njulia> cref = @SDconstraint(model, a ⪰ b)\n[x - 1    2 x - 2;\n 2 x - 2  x - 4  ] ∈ PSDCone()\n\njulia> jump_function(constraint_object(cref))\n4-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n 2 x - 2\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeSquare(2)\n\nWe see in the output of the last command that the matrix the vectorization of the matrix is constrained to belong to the PositiveSemidefiniteConeSquare.\n\njulia> using LinearAlgebra # For Symmetric\n\njulia> cref = @constraint(model, Symmetric(a - b) in PSDCone())\n[x - 1    2 x - 2;\n 2 x - 2  x - 4  ] ∈ PSDCone()\n\njulia> jump_function(constraint_object(cref))\n3-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeTriangle(2)\n\nAs we see in the output of the last command, the vectorization of only the upper triangular part of the matrix is constrained to belong to the PositiveSemidefiniteConeSquare.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SOS1","page":"Constraints","title":"JuMP.SOS1","text":"SOS1\n\nSOS1 (Special Ordered Sets type 1) object than can be used to constrain a vector x to a set where at most 1 variable can take a non-zero value, all others being at 0. The weights, when specified, induce an ordering of the variables; as such, they should be unique values. The kth element in the set corresponds to the kth weight in weights. See here for a description of SOS constraints and their potential uses. This is a shortcut for the MathOptInterface.SOS1 set.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SOS2","page":"Constraints","title":"JuMP.SOS2","text":"SOS2\n\nSOS1 (Special Ordered Sets type 2) object than can be used to constrain a vector x to a set where at most 2 variables can take a non-zero value, all others being at 0. In addition, if two are non-zero these must be consecutive in their ordering. The weights induce an ordering of the variables; as such, they should be unique values. The kth element in the set corresponds to the kth weight in weights. See here for a description of SOS constraints and their potential uses. This is a shortcut for the MathOptInterface.SOS2 set.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SkewSymmetricMatrixSpace","page":"Constraints","title":"JuMP.SkewSymmetricMatrixSpace","text":"SkewSymmetricMatrixSpace()\n\nUse in the @variable macro to constrain a matrix of variables to be skew-symmetric.\n\nExamples\n\n@variable(model, Q[1:2, 1:2] in SkewSymmetricMatrixSpace())\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SkewSymmetricMatrixShape","page":"Constraints","title":"JuMP.SkewSymmetricMatrixShape","text":"SkewSymmetricMatrixShape\n\nShape object for a skew symmetric square matrix of side_dimension rows and columns. The vectorized form contains the entries of the upper-right triangular part of the matrix (without the diagonal) given column by column (or equivalently, the entries of the lower-left triangular part given row by row). The diagonal is zero.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SymMatrixSpace","page":"Constraints","title":"JuMP.SymMatrixSpace","text":"SymMatrixSpace()\n\nUse in the @variable macro to constrain a matrix of variables to be symmetric.\n\nExamples\n\njulia> @variable(model, Q[1:2, 1:2] in SymMatrixSpace())\n2×2 LinearAlgebra.Symmetric{VariableRef,Array{VariableRef,2}}:\n Q[1,1]  Q[1,2]\n Q[1,2]  Q[2,2]\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.moi_set","page":"Constraints","title":"JuMP.moi_set","text":"moi_set(constraint::AbstractConstraint)\n\nReturn the set of the constraint constraint in the function-in-set form as a MathOptInterface.AbstractSet.\n\nmoi_set(s::AbstractVectorSet, dim::Int)\n\nReturns the MOI set of dimension dim corresponding to the JuMP set s.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#Printing","page":"Constraints","title":"Printing","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"function_string\nconstraints_string\nin_set_string\nshow_constraints_summary","category":"page"},{"location":"reference/constraints/#JuMP.function_string","page":"Constraints","title":"JuMP.function_string","text":"function_string(\n    print_mode::Type{<:JuMP.PrintMode},\n    func::Union{JuMP.AbstractJuMPScalar,Vector{<:JuMP.AbstractJuMPScalar}},\n)\n\nReturn a String representing the function func using print mode print_mode.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.constraints_string","page":"Constraints","title":"JuMP.constraints_string","text":"constraints_string(print_mode, model::AbstractModel)::Vector{String}\n\nReturn a list of Strings describing each constraint of the model.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.in_set_string","page":"Constraints","title":"JuMP.in_set_string","text":"in_set_string(print_mode::Type{<:PrintMode}, set)\n\nReturn a String representing the membership to the set set using print mode print_mode.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.show_constraints_summary","page":"Constraints","title":"JuMP.show_constraints_summary","text":"show_constraints_summary(io::IO, model::AbstractModel)\n\nWrite to io a summary of the number of constraints.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/nonlinear/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/nonlinear/rosenbrock.jl\"","category":"page"},{"location":"tutorials/nonlinear/rosenbrock/#The-Rosenbrock-function","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"","category":"section"},{"location":"tutorials/nonlinear/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"A nonlinear example of the classical Rosenbrock function.","category":"page"},{"location":"tutorials/nonlinear/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"using JuMP\nimport Ipopt\nimport Test\n\nfunction example_rosenbrock()\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, x)\n    @variable(model, y)\n    @NLobjective(model, Min, (1 - x)^2 + 100 * (y - x^2)^2)\n    optimize!(model)\n\n    Test.@test termination_status(model) == LOCALLY_SOLVED\n    Test.@test primal_status(model) == FEASIBLE_POINT\n    Test.@test objective_value(model) ≈ 0.0 atol = 1e-10\n    Test.@test value(x) ≈ 1.0\n    Test.@test value(y) ≈ 1.0\n    return\nend\n\nexample_rosenbrock()","category":"page"},{"location":"tutorials/nonlinear/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"","category":"page"},{"location":"tutorials/nonlinear/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/linear/transp.jl\"","category":"page"},{"location":"tutorials/linear/transp/#The-transportation-problem","page":"The transportation problem","title":"The transportation problem","text":"","category":"section"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"Allocation of passenger cars to trains to minimize cars required or car-miles run. Based on:","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"Fourer, D.M. Gay and Brian W. Kernighan, A Modeling Language for Mathematical Programming, https://ampl.com/REFS/amplmod.ps.gz Appendix D.","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"Originally contributed by Louis Luangkesorn, January 30, 2015.","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_transp()\n    ORIG = [\"GARY\", \"CLEV\", \"PITT\"]\n    DEST = [\"FRA\", \"DET\", \"LAN\", \"WIN\", \"STL\", \"FRE\", \"LAF\"]\n    supply = [1_400, 2_600, 2_900]\n    demand = [900, 1_200, 600, 400, 1_700, 1_100, 1_000]\n    Test.@test sum(supply) == sum(demand)\n    cost = [\n        39 14 11 14 16 82 8\n        27 9 12 9 26 95 17\n        24 14 17 13 28 99 20\n    ]\n    model = Model(GLPK.Optimizer)\n    @variable(model, trans[1:length(ORIG), 1:length(DEST)] >= 0)\n    @objective(\n        model,\n        Min,\n        sum(\n            cost[i, j] * trans[i, j] for i in 1:length(ORIG),\n            j in 1:length(DEST)\n        )\n    )\n    @constraints(\n        model,\n        begin\n            [i in 1:length(ORIG)], sum(trans[i, :]) == supply[i]\n            [j in 1:length(DEST)], sum(trans[:, j]) == demand[j]\n        end\n    )\n    optimize!(model)\n    Test.@test termination_status(model) == OPTIMAL\n    Test.@test primal_status(model) == FEASIBLE_POINT\n    Test.@test objective_value(model) == 196200.0\n    println(\"The optimal solution is:\")\n    println(value.(trans))\n    return\nend\n\nexample_transp()","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/errors/#Errors","page":"Errors","title":"Errors","text":"","category":"section"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"When an MOI call fails on a model, precise errors should be thrown when possible instead of simply calling error with a message. The docstrings for the respective methods describe the errors that the implementation should throw in certain situations. This error-reporting system allows code to distinguish between internal errors (that should be shown to the user) and unsupported operations which may have automatic workarounds.","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"When an invalid index is used in an MOI call, an InvalidIndex is thrown:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"InvalidIndex","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.InvalidIndex","page":"Errors","title":"MathOptInterface.InvalidIndex","text":"struct InvalidIndex{IndexType<:Index} <: Exception\n    index::IndexType\nend\n\nAn error indicating that the index index is invalid.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"When an invalid result index is used to retrieve an attribute, a ResultIndexBoundsError is thrown:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"ResultIndexBoundsError\ncheck_result_index_bounds","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.ResultIndexBoundsError","page":"Errors","title":"MathOptInterface.ResultIndexBoundsError","text":"struct ResultIndexBoundsError{AttrType} <: Exception\n    attr::AttrType\n    result_count::Int\nend\n\nAn error indicating that the requested attribute attr could not be retrieved, because the solver returned too few results compared to what was requested. For instance, the user tries to retrieve VariablePrimal(2) when only one solution is available, or when the model is infeasible and has no solution.\n\nSee also: check_result_index_bounds.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.check_result_index_bounds","page":"Errors","title":"MathOptInterface.check_result_index_bounds","text":"check_result_index_bounds(model::ModelLike, attr)\n\nThis function checks whether enough results are available in the model for the requested attr, using its result_index field. If the model does not have sufficient results to answer the query, it throws a ResultIndexBoundsError.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"As discussed in JuMP mapping, for scalar constraint with a nonzero function constant, a ScalarFunctionConstantNotZero exception may be thrown:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"ScalarFunctionConstantNotZero","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.ScalarFunctionConstantNotZero","page":"Errors","title":"MathOptInterface.ScalarFunctionConstantNotZero","text":"struct ScalarFunctionConstantNotZero{T, F, S} <: Exception\n    constant::T\nend\n\nAn error indicating that the constant part of the function in the constraint F-in-S is nonzero.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"Some VariableIndex constraints cannot be combined on the same variable:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"LowerBoundAlreadySet\nUpperBoundAlreadySet","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.LowerBoundAlreadySet","page":"Errors","title":"MathOptInterface.LowerBoundAlreadySet","text":"LowerBoundAlreadySet{S1, S2}\n\nError thrown when setting a VariableIndex-in-S2 when a VariableIndex-in-S1 has already been added and the sets S1, S2 both set a lower bound, i.e. they are EqualTo, GreaterThan, Interval, Semicontinuous or Semiinteger.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.UpperBoundAlreadySet","page":"Errors","title":"MathOptInterface.UpperBoundAlreadySet","text":"UpperBoundAlreadySet{S1, S2}\n\nError thrown when setting a VariableIndex-in-S2 when a VariableIndex-in-S1 has already been added and the sets S1, S2 both set an upper bound, i.e. they are EqualTo, LessThan, Interval, Semicontinuous or Semiinteger.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"As discussed in AbstractCallback, trying to get attributes inside a callback may throw:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"OptimizeInProgress","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.OptimizeInProgress","page":"Errors","title":"MathOptInterface.OptimizeInProgress","text":"struct OptimizeInProgress{AttrType<:AnyAttribute} <: Exception\n    attr::AttrType\nend\n\nError thrown from optimizer when MOI.get(optimizer, attr) is called inside an AbstractCallback while it is only defined once optimize! has completed. This can only happen when is_set_by_optimize(attr) is true.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"Trying to submit the wrong type of AbstractSubmittable inside an AbstractCallback (e.g., a UserCut inside a LazyConstraintCallback) will throw:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"InvalidCallbackUsage","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.InvalidCallbackUsage","page":"Errors","title":"MathOptInterface.InvalidCallbackUsage","text":"struct InvalidCallbackUsage{C, S} <: Exception\n    callback::C\n    submittable::S\nend\n\nAn error indicating that submittable cannot be submitted inside callback.\n\nFor example, UserCut cannot be submitted inside LazyConstraintCallback.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"The rest of the errors defined in MOI fall in two categories represented by the following two abstract types:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"UnsupportedError\nNotAllowedError","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.UnsupportedError","page":"Errors","title":"MathOptInterface.UnsupportedError","text":"UnsupportedError <: Exception\n\nAbstract type for error thrown when an element is not supported by the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.NotAllowedError","page":"Errors","title":"MathOptInterface.NotAllowedError","text":"NotAllowedError <: Exception\n\nAbstract type for error thrown when an operation is supported but cannot be applied in the current state of the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"The different UnsupportedError and NotAllowedError are the following errors:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"UnsupportedAttribute\nSetAttributeNotAllowed\nAddVariableNotAllowed\nUnsupportedConstraint\nAddConstraintNotAllowed\nModifyConstraintNotAllowed\nModifyObjectiveNotAllowed\nDeleteNotAllowed\nUnsupportedSubmittable\nSubmitNotAllowed","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.UnsupportedAttribute","page":"Errors","title":"MathOptInterface.UnsupportedAttribute","text":"struct UnsupportedAttribute{AttrType} <: UnsupportedError\n    attr::AttrType\n    message::String\nend\n\nAn error indicating that the attribute attr is not supported by the model, i.e. that supports returns false.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.SetAttributeNotAllowed","page":"Errors","title":"MathOptInterface.SetAttributeNotAllowed","text":"struct SetAttributeNotAllowed{AttrType} <: NotAllowedError\n    attr::AttrType\n    message::String # Human-friendly explanation why the attribute cannot be set\nend\n\nAn error indicating that the attribute attr is supported (see supports) but cannot be set for some reason (see the error string).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.AddVariableNotAllowed","page":"Errors","title":"MathOptInterface.AddVariableNotAllowed","text":"struct AddVariableNotAllowed <: NotAllowedError\n    message::String # Human-friendly explanation why the attribute cannot be set\nend\n\nAn error indicating that variables cannot be added to the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.UnsupportedConstraint","page":"Errors","title":"MathOptInterface.UnsupportedConstraint","text":"struct UnsupportedConstraint{F<:AbstractFunction, S<:AbstractSet} <: UnsupportedError\n    message::String # Human-friendly explanation why the attribute cannot be set\nend\n\nAn error indicating that constraints of type F-in-S are not supported by the model, i.e. that supports_constraint returns false.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.AddConstraintNotAllowed","page":"Errors","title":"MathOptInterface.AddConstraintNotAllowed","text":"struct AddConstraintNotAllowed{F<:AbstractFunction, S<:AbstractSet} <: NotAllowedError\n    message::String # Human-friendly explanation why the attribute cannot be set\nend\n\nAn error indicating that constraints of type F-in-S are supported (see supports_constraint) but cannot be added.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.ModifyConstraintNotAllowed","page":"Errors","title":"MathOptInterface.ModifyConstraintNotAllowed","text":"struct ModifyConstraintNotAllowed{F<:AbstractFunction, S<:AbstractSet,\n                                  C<:AbstractFunctionModification} <: NotAllowedError\n    constraint_index::ConstraintIndex{F, S}\n    change::C\n    message::String\nend\n\nAn error indicating that the constraint modification change cannot be applied to the constraint of index ci.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.ModifyObjectiveNotAllowed","page":"Errors","title":"MathOptInterface.ModifyObjectiveNotAllowed","text":"struct ModifyObjectiveNotAllowed{C<:AbstractFunctionModification} <: NotAllowedError\n    change::C\n    message::String\nend\n\nAn error indicating that the objective modification change cannot be applied to the objective.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.DeleteNotAllowed","page":"Errors","title":"MathOptInterface.DeleteNotAllowed","text":"struct DeleteNotAllowed{IndexType <: Index} <: NotAllowedError\n    index::IndexType\n    message::String\nend\n\nAn error indicating that the index index cannot be deleted.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.UnsupportedSubmittable","page":"Errors","title":"MathOptInterface.UnsupportedSubmittable","text":"struct UnsupportedSubmittable{SubmitType} <: UnsupportedError\n    sub::SubmitType\n    message::String\nend\n\nAn error indicating that the submittable sub is not supported by the model, i.e. that supports returns false.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.SubmitNotAllowed","page":"Errors","title":"MathOptInterface.SubmitNotAllowed","text":"struct SubmitNotAllowed{SubmitTyp<:AbstractSubmittable} <: NotAllowedError\n    sub::SubmitType\n    message::String # Human-friendly explanation why the attribute cannot be set\nend\n\nAn error indicating that the submittable sub is supported (see supports) but cannot be added for some reason (see the error string).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"Note that setting the ConstraintFunction of a VariableIndex constraint is not allowed:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"SettingVariableIndexNotAllowed","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.SettingVariableIndexNotAllowed","page":"Errors","title":"MathOptInterface.SettingVariableIndexNotAllowed","text":"SettingVariableIndexNotAllowed()\n\nError type that should be thrown when the user calls set to change the ConstraintFunction of a VariableIndex constraint.\n\n\n\n\n\n","category":"type"},{"location":"installation/#Installation-Guide","page":"Installation Guide","title":"Installation Guide","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"This guide explains how to install Julia and  JuMP. If you have installation troubles, read the Common installation issues section below.","category":"page"},{"location":"installation/#Install-Julia","page":"Installation Guide","title":"Install Julia","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"JuMP is a package for Julia. To use JuMP, first download and install Julia.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"tip: Tip\nIf you  are new  to Julia, read our Getting started with Julia tutorial.","category":"page"},{"location":"installation/#Which-version-should-I-pick?","page":"Installation Guide","title":"Which version should I pick?","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"You can install the \"Current stable release\" or the \"Long-term support (LTS) release\".","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"The \"Current stable release\" is the latest release of Julia. It has access to newer features, and is likely faster.\nThe \"Long-term support release\" is an older version of Julia that has continued to receive bug and security fixes. However, it may not have the latest features or performance improvements.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"For most users, you should install the \"Current stable release\", and whenever Julia releases a new version of the current stable release, you should update your version of Julia. Note that any code you write on one version of the current stable release will continue to work on all subsequent releases.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"For users in restricted software environments (e.g., your enterprise IT controls what software you can install), you may be better off installing the long-term support release because you will not have to update Julia as frequently.","category":"page"},{"location":"installation/#Install-JuMP","page":"Installation Guide","title":"Install JuMP","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"From Julia, JuMP is installed using the built-in package manager:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.add(\"JuMP\")","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"tip: Tip\nWe recommend you create a Pkg environment for each project you use JuMP for, instead of adding lots of packages to the global environment. The Pkg manager documentation has more information on this topic.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"When we release a new version of JuMP, you can update with:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.update(\"JuMP\")","category":"page"},{"location":"installation/#Install-a-solver","page":"Installation Guide","title":"Install a solver","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"JuMP depends on solvers to solve optimization problems. Therefore, you will need to install one before you can solve problems with JuMP.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Install a solver using the Julia package manager, replacing \"Clp\" by the Julia package name as appropriate.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.add(\"Clp\")","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Once installed, you can use Clp as a solver with JuMP as follows, using set_optimizer_attributes to set solver-specific options:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"using JuMP\nusing Clp\nmodel = Model(Clp.Optimizer)\nset_optimizer_attributes(model, \"LogLevel\" => 1, \"PrimalTolerance\" => 1e-7)","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nMost packages follow the ModuleName.Optimizer naming convention, but exceptions may exist. See the README of the Julia package's GitHub repository for more details on how to use a particular solver, including any solver-specific options.","category":"page"},{"location":"installation/#Supported-solvers","page":"Installation Guide","title":"Supported solvers","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Most solvers are not written in Julia, and some require commercial licenses to use, so installation is often more complex.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"If a solver has Manual in the Installation column, the solver requires a manual installation step, such as downloading and installing a binary, or obtaining a commercial license. Consult the README of the relevant Julia package for more information.\nIf the solver has Manualᴹ in the Installation column, the solver requires an installation of MATLAB.\nIf the Installation column is missing an entry, installing the Julia package will download and install any relevant solver binaries automatically, and you shouldn't need to do anything other than Pkg.add.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Solvers with a missing entry in the Julia Package column are written in Julia. The link in the Solver column is the corresponding Julia package.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Solver Julia Package Installation License Supports\nAlpine.jl   Triad NS (MI)NLP\nArtelys Knitro KNITRO.jl Manual Comm. (MI)LP, (MI)SOCP, (MI)NLP\nBARON BARON.jl Manual Comm. (MI)NLP\nBonmin AmplNLWriter.jl  EPL (MI)NLP\nCbc Cbc.jl  EPL (MI)LP\nCDCS CDCS.jl Manualᴹ GPL LP, SOCP, SDP\nCDD CDDLib.jl  GPL LP\nClp Clp.jl  EPL LP\nCOSMO.jl   Apache LP, QP, SOCP, SDP\nCouenne AmplNLWriter.jl  EPL (MI)NLP\nCPLEX CPLEX.jl Manual Comm. (MI)LP, (MI)SOCP\nCSDP CSDP.jl  EPL LP, SDP\nEAGO.jl   MIT NLP\nECOS ECOS.jl  GPL LP, SOCP\nFICO Xpress Xpress.jl Manual Comm. (MI)LP, (MI)SOCP\nGLPK GLPK.jl  GPL (MI)LP\nGurobi Gurobi.jl Manual Comm. (MI)LP, (MI)SOCP\nHiGHS HiGHS.jl  MIT LP\nHypatia.jl   MIT LP, SOCP, SDP\nIpopt Ipopt.jl  EPL LP, QP, NLP\nJuniper.jl   MIT (MI)SOCP, (MI)NLP\nMadNLP.jl   MIT LP, QP, NLP\nMOSEK MosekTools.jl Manual Comm. (MI)LP, (MI)SOCP, SDP\nNLopt NLopt.jl  GPL LP, QP, NLP\nOSQP OSQP.jl  Apache LP, QP\nPATH PATHSolver.jl  MIT MCP\nPavito.jl   MPL-2 (MI)NLP\nProxSDP.jl   MIT LP, SOCP, SDP\nSCIP SCIP.jl  ZIB (MI)LP, (MI)NLP\nSCS SCS.jl  MIT LP, SOCP, SDP\nSDPA SDPA.jl, SDPAFamily.jl  GPL LP, SDP\nSDPNAL SDPNAL.jl Manualᴹ CC BY-SA LP, SDP\nSDPT3 SDPT3.jl Manualᴹ GPL LP, SOCP, SDP\nSeDuMi SeDuMi.jl Manualᴹ GPL LP, SOCP, SDP\nTulip.jl   MPL-2 LP","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Where:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"LP = Linear programming\nQP = Quadratic programming\nSOCP = Second-order conic programming (including problems with convex quadratic constraints or objective)\nMCP = Mixed-complementarity programming\nNLP = Nonlinear programming\nSDP = Semidefinite programming\n(MI)XXX = Mixed-integer equivalent of problem type XXX","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nDeveloped a solver or solver wrapper? This table is open for new contributions! Start by making a pull request to edit the installation.md file.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nDeveloping a solver or solver wrapper? See Models and the MathOptInterface docs for more details on how JuMP interacts with solvers. Please get in touch via the Developer Chatroom with any questions about connecting new solvers with JuMP.","category":"page"},{"location":"installation/#AMPL-based-solvers","page":"Installation Guide","title":"AMPL-based solvers","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Use AmplNLWriter to access solvers that support the nl format.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Some solvers, such as Bonmin and Couenne can be installed via the Julia package manager. Others need to be manually installed.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Consult the AMPL documentation for a complete list of supported solvers.","category":"page"},{"location":"installation/#GAMS-based-solvers","page":"Installation Guide","title":"GAMS-based solvers","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Use GAMS.jl to access solvers available through GAMS. Such solvers include: AlphaECP, Antigone, BARON, CONOPT, Couenne, LocalSolver, PATHNLP, SHOT, SNOPT, SoPlex. See a complete list here.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nGAMS.jl requires an installation of the commercial software GAMS for which a free community license exists.","category":"page"},{"location":"installation/#NEOS-based-solvers","page":"Installation Guide","title":"NEOS-based solvers","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Use NEOSServer.jl to access solvers available through the NEOS Server.","category":"page"},{"location":"installation/#Previously-supported-solvers","page":"Installation Guide","title":"Previously supported solvers","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"The following solvers were compatible with JuMP up to release 0.18 but are not yet compatible with the latest version because they do not implement the new MathOptInterface API:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Pajarito","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Please join the Developer Chatroom if you have interest in reviving a previously supported solver.","category":"page"},{"location":"installation/#Common-installation-issues","page":"Installation Guide","title":"Common installation issues","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"tip: Tip\nWhen in doubt, run import Pkg; Pkg.update() to see if updating your packages fixes the issue. Remember you will need to exit Julia and start a new session for the changes to take effect.","category":"page"},{"location":"installation/#Check-the-version-of-your-packages","page":"Installation Guide","title":"Check the version of your packages","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Each package is versioned with a three-part number of the form vX.Y.Z. You can check which versions you have installed with import Pkg; Pkg.status().","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"This should almost always be the most-recent release. You can check the releases of a package by going to the relevant GitHub page, and navigating to the \"releases\" page. For example, the list of JuMP releases is available at: https://github.com/jump-dev/JuMP.jl/releases.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"If you post on the community forum, please include the output of Pkg.status()!","category":"page"},{"location":"installation/#Unsatisfiable-requirements-detected","page":"Installation Guide","title":"Unsatisfiable requirements detected","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Did you get an error like Unsatisfiable requirements detected for package JuMP? The Pkg documentation has a section on how to understand and manage these conflicts.","category":"page"},{"location":"installation/#Installing-new-packages-can-make-JuMP-downgrade-to-an-earlier-version","page":"Installation Guide","title":"Installing new packages can make JuMP downgrade to an earlier version","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Another common complaint is that after adding a new package, code that previously worked no longer works.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"This usually happens because the new package is not compatible with the latest version of JuMP. Therefore, the package manager rolls-back JuMP to an earlier version! Here's an example.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"First, we add JuMP:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"(jump_example) pkg> add JuMP\n  Resolving package versions...\nUpdating `~/jump_example/Project.toml`\n  [4076af6c] + JuMP v0.21.5\nUpdating `~/jump_example/Manifest.toml`\n  ... lines omitted ...","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"The + JuMP v0.21.5 line indicates that JuMP has been added at version 0.21.5. However, watch what happens when we add JuMPeR:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"(jump_example) pkg> add JuMPeR\n  Resolving package versions...\nUpdating `~/jump_example/Project.toml`\n  [4076af6c] ↓ JuMP v0.21.5 ⇒ v0.18.6\n  [707a9f91] + JuMPeR v0.6.0\nUpdating `~/jump_example/Manifest.toml`\n  ... lines omitted ...","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"JuMPeR gets added at version 0.6.0 (+ JuMPeR v0.6.0), but JuMP gets downgraded from 0.21.5 to 0.18.6 (↓ JuMP v0.21.5 ⇒ v0.18.6)! The reason for this is that JuMPeR doesn't support a version of JuMP newer than 0.18.6.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"tip: Tip\nPay careful attention to the output of the package manager when adding new packages, especially when you see a package being downgraded!","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/linear/network_flows.jl\"","category":"page"},{"location":"tutorials/linear/network_flows/#Network-flow-problems","page":"Network flow problems","title":"Network flow problems","text":"","category":"section"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"In graph theory, a flow network (also known as a transportation network) is a directed graph where each edge has a capacity and each edge receives a flow. The amount of flow on an edge cannot exceed the capacity of the edge.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"Often in operations research, a directed graph is called a network, the vertices are called nodes and the edges are called arcs.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"A flow must satisfy the restriction that the amount of flow into a node equals the amount of flow out of it,  unless it is a source, which has only outgoing flow, or sink, which has only incoming flow.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"A network can be used to model traffic in a computer network, circulation with demands, fluids in pipes,  currents in an electrical circuit, or anything similar in which something travels through a network of nodes.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"using JuMP\nimport GLPK\nimport LinearAlgebra","category":"page"},{"location":"tutorials/linear/network_flows/#The-shortest-path-problem","page":"Network flow problems","title":"The shortest path problem","text":"","category":"section"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"Suppose that each arc (i j) of a graph is assigned a scalar cost a_ij, and suppose that we define the cost of a forward path to be the sum of the costs of its arcs.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"Given a pair of nodes, the shortest path problem is to find a forward path that connects these nodes and has minimum cost.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"beginaligned\nmin  sum_forall e(ij) in E a_ij times x_ij \nst  b(i) = sum_j x_ij - sum_k x_ki = begincases\n1 mboxif i is the starting node \n-1 mboxif i is the ending node \n0 mboxotherwise endcases \n x_e in 01  forall e in E\nendaligned","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"G = [\n    0 100 30 0 0\n    0 0 20 0 0\n    0 0 0 10 60\n    0 15 0 0 50\n    0 0 0 0 0\n]\n\nn = size(G)[1]\n\nshortest_path = Model(GLPK.Optimizer)\n\n@variable(shortest_path, x[1:n, 1:n], Bin)","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"Arcs with zero cost are not a part of the path as they do no exist","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"@constraint(shortest_path, [i = 1:n, j = 1:n; G[i, j] == 0], x[i, j] == 0)","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"Flow conservation constraint","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"@constraint(\n    shortest_path,\n    [i = 1:n; i != 1 && i != 2],\n    sum(x[i, :]) == sum(x[:, i])\n)","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"Flow coming out of source = 1","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"@constraint(shortest_path, sum(x[1, :]) - sum(x[:, 1]) == 1)","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"Flowing coming out of destination = -1 i.e. Flow entering destination = 1","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"@constraint(shortest_path, sum(x[2, :]) - sum(x[:, 2]) == -1)\n@objective(shortest_path, Min, LinearAlgebra.dot(G, x))\n\noptimize!(shortest_path)\nobjective_value(shortest_path)","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"value.(x)","category":"page"},{"location":"tutorials/linear/network_flows/#The-assignment-problem","page":"Network flow problems","title":"The assignment problem","text":"","category":"section"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"Suppose that there are n persons and n objects that we have to match on a one-to-one basis. There is a benefit or value a_ij for matching person i with object j, and we want to assign persons to objects so as to maximize the total benefit.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"There is also a restriction that person i can be assigned to object j only if (i j) belongs to a given set of pairs A.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"Mathematically, we want to find a set of person-object pairs (1 j_1) (n j_n) from A such that the objects j_1j_n are all distinct, and the total benefit sum_i=1^y a_ij_i is maximized.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"beginaligned\nmax  sum_(ij) in A a_ij times y_ij \nst  sum_j(ij) in A y_ij = 1  forall i = 12n \n sum_i(ij) in A y_ij = 1  forall j = 12n \n y_ij in 01  forall (ij) in 12k\nendaligned","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"G = [\n    6 4 5 0\n    0 3 6 0\n    5 0 4 3\n    7 5 5 5\n]\n\nn = size(G)[1]\n\nassignment = Model(GLPK.Optimizer)\n@variable(assignment, y[1:n, 1:n], Bin)","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"One person can only be assigned to one object","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"@constraint(assignment, [i = 1:n], sum(y[:, i]) == 1)","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"One object can only be assigned to one person","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"@constraint(assignment, [j = 1:n], sum(y[j, :]) == 1)\n@objective(assignment, Max, LinearAlgebra.dot(G, y))\n\noptimize!(assignment)\nobjective_value(assignment)","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"value.(y)","category":"page"},{"location":"tutorials/linear/network_flows/#The-max-flow-problem","page":"Network flow problems","title":"The max-flow problem","text":"","category":"section"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"In the max-flow problem, we have a graph with two special nodes: the source, denoted by s, and the sink, denoted by t.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"The objective is to move as much flow as possible from s into t while observing the capacity constraints.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"beginaligned\nmax  sum_v(sv) in E f(sv) \nst  sum_u(uv) in E f(uv)  = sum_w(vw) in E f(vw)  forall v in V - st \n f(uv) leq c(uv)  forall (uv) in E \n f(uv) geq 0  forall (uv) in E\nendaligned","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"G = [\n    0 3 2 2 0 0 0 0\n    0 0 0 0 5 1 0 0\n    0 0 0 0 1 3 1 0\n    0 0 0 0 0 1 0 0\n    0 0 0 0 0 0 0 4\n    0 0 0 0 0 0 0 2\n    0 0 0 0 0 0 0 4\n    0 0 0 0 0 0 0 0\n]\n\nn = size(G)[1]\n\nmax_flow = Model(GLPK.Optimizer)\n\n@variable(max_flow, f[1:n, 1:n] >= 0)","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"Capacity constraints","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"@constraint(max_flow, [i = 1:n, j = 1:n], f[i, j] <= G[i, j])","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"Flow conservation constraints","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"@constraint(max_flow, [i = 1:n; i != 1 && i != 8], sum(f[i, :]) == sum(f[:, i]))\n@objective(max_flow, Max, sum(f[1, :]))\n\noptimize!(max_flow)\nobjective_value(max_flow)","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"value.(f)","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"reference/solutions/#SolutionAPI","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"More information can be found in the Solutions section of the manual.","category":"page"},{"location":"reference/solutions/#Basic-utilities","page":"Solutions","title":"Basic utilities","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"JuMP.optimize!\nNoOptimizer\nOptimizeNotCalled\nsolution_summary","category":"page"},{"location":"reference/solutions/#JuMP.optimize!","page":"Solutions","title":"JuMP.optimize!","text":"optimize!(model::Model;\n          ignore_optimize_hook=(model.optimize_hook === nothing),\n          kwargs...)\n\nOptimize the model. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nKeyword arguments kwargs are passed to the optimize_hook. An error is thrown if optimize_hook is nothing and keyword arguments are provided.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.NoOptimizer","page":"Solutions","title":"JuMP.NoOptimizer","text":"struct NoOptimizer <: Exception end\n\nNo optimizer is set. The optimizer can be provided to the Model constructor or by calling set_optimizer.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#JuMP.OptimizeNotCalled","page":"Solutions","title":"JuMP.OptimizeNotCalled","text":"struct OptimizeNotCalled <: Exception end\n\nA result attribute cannot be queried before optimize! is called.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#JuMP.solution_summary","page":"Solutions","title":"JuMP.solution_summary","text":"solution_summary(model::Model; verbose::Bool = false)\n\nReturn a struct that can be used print a summary of the solution.\n\nIf verbose=true, write out the primal solution for every variable and the dual solution for every constraint, excluding those with empty names.\n\nExamples\n\nWhen called at the REPL, the summary is automatically printed:\n\njulia> solution_summary(model)\n[...]\n\nUse print to force the printing of the summary from inside a function:\n\nfunction foo(model)\n    print(solution_summary(model))\n    return\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#Termination-status","page":"Solutions","title":"Termination status","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"termination_status\nraw_status\nresult_count","category":"page"},{"location":"reference/solutions/#JuMP.termination_status","page":"Solutions","title":"JuMP.termination_status","text":"termination_status(model::Model)\n\nReturn a MOI.TerminationStatusCode describing why the solver stopped (i.e., the MOI.TerminationStatus attribute).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.raw_status","page":"Solutions","title":"JuMP.raw_status","text":"raw_status(model::Model)\n\nReturn the reason why the solver stopped in its own words (i.e., the MathOptInterface model attribute RawStatusString).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.result_count","page":"Solutions","title":"JuMP.result_count","text":"result_count(model::Model)\n\nReturn the number of results available to query after a call to optimize!.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#Primal-solutions","page":"Solutions","title":"Primal solutions","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"primal_status\nhas_values\nvalue","category":"page"},{"location":"reference/solutions/#JuMP.primal_status","page":"Solutions","title":"JuMP.primal_status","text":"primal_status(model::Model; result::Int = 1)\n\nReturn a MOI.ResultStatusCode describing the status of the most recent primal solution of the solver (i.e., the MOI.PrimalStatus attribute) associated with the result index result.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.has_values","page":"Solutions","title":"JuMP.has_values","text":"has_values(model::Model; result::Int = 1)\n\nReturn true if the solver has a primal solution in result index result available to query, otherwise return false.\n\nSee also value and result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.value","page":"Solutions","title":"JuMP.value","text":"value(con_ref::ConstraintRef; result::Int = 1)\n\nReturn the primal value of constraint con_ref associated with result index result of the most-recent solution returned by the solver.\n\nThat is, if con_ref is the reference of a constraint func-in-set, it returns the value of func evaluated at the value of the variables (given by value(::VariableRef)).\n\nUse has_values to check if a result exists before asking for values.\n\nSee also: result_count.\n\nNote\n\nFor scalar constraints, the constant is moved to the set so it is not taken into account in the primal value of the constraint. For instance, the constraint @constraint(model, 2x + 3y + 1 == 5) is transformed into 2x + 3y-in-MOI.EqualTo(4) so the value returned by this function is the evaluation of 2x + 3y. ```\n\n\n\n\n\nvalue(var_value::Function, con_ref::ConstraintRef)\n\nEvaluate the primal value of the constraint con_ref using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(v::VariableRef; result = 1)\n\nReturn the value of variable v associated with result index result of the most-recent returned by the solver.\n\nUse has_values to check if a result exists before asking for values.\n\nSee also: result_count.\n\n\n\n\n\nvalue(var_value::Function, v::VariableRef)\n\nEvaluate the value of the variable v as var_value(v).\n\n\n\n\n\nvalue(var_value::Function, ex::GenericAffExpr)\n\nEvaluate ex using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(v::GenericAffExpr; result::Int = 1)\n\nReturn the value of the GenericAffExpr v associated with result index result of the most-recent solution returned by the solver.\n\nSee also: result_count.\n\n\n\n\n\nvalue(var_value::Function, ex::GenericQuadExpr)\n\nEvaluate ex using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(v::GenericQuadExpr; result::Int = 1)\n\nReturn the value of the GenericQuadExpr v associated with result index result of the most-recent solution returned by the solver.\n\nReplaces getvalue for most use cases.\n\nSee also: result_count.\n\n\n\n\n\nvalue(p::NonlinearParameter)\n\nReturn the current value stored in the nonlinear parameter p.\n\nExample\n\nmodel = Model()\n@NLparameter(model, p == 10)\nvalue(p)\n\n# output\n10.0\n\n\n\n\n\nvalue(var_value::Function, ex::NonlinearExpression)\n\nEvaluate ex using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(ex::NonlinearExpression; result::Int = 1)\n\nReturn the value of the NonlinearExpression ex associated with result index result of the most-recent solution returned by the solver.\n\nReplaces getvalue for most use cases.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#Dual-solutions","page":"Solutions","title":"Dual solutions","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"dual_status\nhas_duals\ndual\nshadow_price\nreduced_cost","category":"page"},{"location":"reference/solutions/#JuMP.dual_status","page":"Solutions","title":"JuMP.dual_status","text":"dual_status(model::Model; result::Int = 1)\n\nReturn a MOI.ResultStatusCode describing the status of the most recent dual solution of the solver (i.e., the MOI.DualStatus attribute) associated with the result index result.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.has_duals","page":"Solutions","title":"JuMP.has_duals","text":"has_duals(model::Model; result::Int = 1)\n\nReturn true if the solver has a dual solution in result index result available to query, otherwise return false.\n\nSee also dual, shadow_price, and result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.dual","page":"Solutions","title":"JuMP.dual","text":"dual(con_ref::ConstraintRef; result::Int = 1)\n\nReturn the dual value of constraint con_ref associated with result index result of the most-recent solution returned by the solver.\n\nUse has_dual to check if a result exists before asking for values.\n\nSee also: result_count, shadow_price.\n\n\n\n\n\ndual(c::NonlinearConstraintRef)\n\nReturn the dual of the nonlinear constraint c.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.shadow_price","page":"Solutions","title":"JuMP.shadow_price","text":"shadow_price(con_ref::ConstraintRef)\n\nReturn the change in the objective from an infinitesimal relaxation of the constraint.\n\nThis value is computed from dual and can be queried only when has_duals is true and the objective sense is MIN_SENSE or MAX_SENSE (not FEASIBILITY_SENSE). For linear constraints, the shadow prices differ at most in sign from the dual value depending on the objective sense.\n\nSee also reduced_cost.\n\nNotes\n\nThe function simply translates signs from dual and does not validate the conditions needed to guarantee the sensitivity interpretation of the shadow price. The caller is responsible, e.g., for checking whether the solver converged to an optimal primal-dual pair or a proof of infeasibility.\nThe computation is based on the current objective sense of the model. If this has changed since the last solve, the results will be incorrect.\nRelaxation of equality constraints (and hence the shadow price) is defined based on which sense of the equality constraint is active.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.reduced_cost","page":"Solutions","title":"JuMP.reduced_cost","text":"reduced_cost(x::VariableRef)::Float64\n\nReturn the reduced cost associated with variable x.\n\nEquivalent to querying the shadow price of the active variable bound (if one exists and is active).\n\nSee also: shadow_price.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#Basic-attributes","page":"Solutions","title":"Basic attributes","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"objective_value\nobjective_bound\ndual_objective_value\nsolve_time\nrelative_gap\nsimplex_iterations\nbarrier_iterations\nnode_count","category":"page"},{"location":"reference/solutions/#JuMP.objective_value","page":"Solutions","title":"JuMP.objective_value","text":"objective_value(model::Model; result::Int = 1)\n\nReturn the objective value associated with result index result of the most-recent solution returned by the solver.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.objective_bound","page":"Solutions","title":"JuMP.objective_bound","text":"objective_bound(model::Model)\n\nReturn the best known bound on the optimal objective value after a call to optimize!(model).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.dual_objective_value","page":"Solutions","title":"JuMP.dual_objective_value","text":"dual_objective_value(model::Model; result::Int = 1)\n\nReturn the value of the objective of the dual problem associated with result index result of the most-recent solution returned by the solver.\n\nThrows MOI.UnsupportedAttribute{MOI.DualObjectiveValue} if the solver does not support this attribute.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.solve_time","page":"Solutions","title":"JuMP.solve_time","text":"solve_time(model::Model)\n\nIf available, returns the solve time reported by the solver. Returns \"ArgumentError: ModelLike of type Solver.Optimizer does not support accessing the attribute MathOptInterface.SolveTimeSec()\" if the attribute is not implemented.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.relative_gap","page":"Solutions","title":"JuMP.relative_gap","text":"relative_gap(model::Model)\n\nReturn the final relative optimality gap after a call to optimize!(model). Exact value depends upon implementation of MathOptInterface.RelativeGap() by the particular solver used for optimization.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.simplex_iterations","page":"Solutions","title":"JuMP.simplex_iterations","text":"simplex_iterations(model::Model)\n\nGets the cumulative number of simplex iterations during the most-recent optimization.\n\nSolvers must implement MOI.SimplexIterations() to use this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.barrier_iterations","page":"Solutions","title":"JuMP.barrier_iterations","text":"barrier_iterations(model::Model)\n\nGets the cumulative number of barrier iterations during the most recent optimization.\n\nSolvers must implement MOI.BarrierIterations() to use this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.node_count","page":"Solutions","title":"JuMP.node_count","text":"node_count(model::Model)\n\nGets the total number of branch-and-bound nodes explored during the most recent optimization in a Mixed Integer Program.\n\nSolvers must implement MOI.NodeCount() to use this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#ref_conflicts","page":"Solutions","title":"Conflicts","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"compute_conflict!\ncopy_conflict","category":"page"},{"location":"reference/solutions/#JuMP.compute_conflict!","page":"Solutions","title":"JuMP.compute_conflict!","text":"compute_conflict!(model::Model)\n\nCompute a conflict if the model is infeasible. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nThe status of the conflict can be checked with the MOI.ConflictStatus model attribute. Then, the status for each constraint can be queried with the MOI.ConstraintConflictStatus attribute.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.copy_conflict","page":"Solutions","title":"JuMP.copy_conflict","text":"copy_conflict(model::Model)\n\nReturn a copy of the current conflict for the model model and a ReferenceMap that can be used to obtain the variable and constraint reference of the new model corresponding to a given model's reference.\n\nThis is a convenience function that provides a filtering function for copy_model.\n\nNote\n\nModel copy is not supported in DIRECT mode, i.e. when a model is constructed using the direct_model constructor instead of the Model constructor. Moreover, independently on whether an optimizer was provided at model construction, the new model will have no optimizer, i.e., an optimizer will have to be provided to the new model in the optimize! call.\n\nExamples\n\nIn the following example, a model model is constructed with a variable x and two constraints cref and cref2. This model has no solution, as the two constraints are mutually exclusive. The solver is asked to compute a conflict with compute_conflict!. The parts of model participating in the conflict are then copied into a model new_model.\n\nmodel = Model() # You must use a solver that supports conflict refining/IIS\n# computation, like CPLEX or Gurobi\n@variable(model, x)\n@constraint(model, cref, x >= 2)\n@constraint(model, cref2, x <= 1)\n\ncompute_conflict!(model)\nif MOI.get(model, MOI.ConflictStatus()) != MOI.CONFLICT_FOUND\n    error(\"No conflict could be found for an infeasible model.\")\nend\n\nnew_model, reference_map = copy_conflict(model)\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#Sensitivity","page":"Solutions","title":"Sensitivity","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"lp_sensitivity_report\nSensitivityReport","category":"page"},{"location":"reference/solutions/#JuMP.lp_sensitivity_report","page":"Solutions","title":"JuMP.lp_sensitivity_report","text":"lp_sensitivity_report(model::Model; atol::Float64 = 1e-8)::SensitivityReport\n\nGiven a linear program model with a current optimal basis, return a SensitivityReport object, which maps:\n\nEvery variable reference to a tuple (d_lo, d_hi)::Tuple{Float64,Float64}, explaining how much the objective coefficient of the corresponding variable can change by, such that the original basis remains optimal.\nEvery constraint reference to a tuple (d_lo, d_hi)::Tuple{Float64,Float64}, explaining how much the right-hand side of the corresponding constraint can change by, such that the basis remains optimal.\n\nBoth tuples are relative, rather than absolute. So given a objective coefficient of 1.0 and a tuple (-0.5, 0.5), the objective coefficient can range between 1.0 - 0.5 an 1.0 + 0.5.\n\natol is the primal/dual optimality tolerance, and should match the tolerance of the solver used to compute the basis.\n\nNote: interval constraints are NOT supported.\n\nExample\n\nmodel = Model(GLPK.Optimizer)\n@variable(model, -1 <= x <= 2)\n@objective(model, Min, x)\noptimize!(model)\nreport = lp_sensitivity_report(model; atol = 1e-7)\ndx_lo, dx_hi = report[x]\nprintln(\n    \"The objective coefficient of `x` can decrease by $dx_lo or \" *\n    \"increase by $dx_hi.\"\n)\nc = LowerBoundRef(x)\ndRHS_lo, dRHS_hi = report[c]\nprintln(\n    \"The lower bound of `x` can decrease by $dRHS_lo or increase \" *\n    \"by $dRHS_hi.\"\n)\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.SensitivityReport","page":"Solutions","title":"JuMP.SensitivityReport","text":"SensitivityReport\n\nSee lp_sensitivity_report.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#Feasibility","page":"Solutions","title":"Feasibility","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"primal_feasibility_report","category":"page"},{"location":"reference/solutions/#JuMP.primal_feasibility_report","page":"Solutions","title":"JuMP.primal_feasibility_report","text":"primal_feasibility_report(\n    model::Model,\n    point::AbstractDict{VariableRef,Float64} = _last_primal_solution(model),\n    atol::Float64 = 0.0,\n    skip_missing::Bool = false,\n)::Dict{Any,Float64}\n\nGiven a dictionary point, which maps variables to primal values, return a dictionary whose keys are the constraints with an infeasibility greater than the supplied tolerance atol. The value corresponding to each key is the respective infeasibility. Infeasibility is defined as the distance between the primal value of the constraint (see MOI.ConstraintPrimal) and the nearest point by Euclidean distance in the corresponding set.\n\nNotes\n\nIf skip_missing = true, constraints containing variables that are not in point will be ignored.\nIf skip_missing = false and a partial primal solution is provided, an error will be thrown.\nIf no point is provided, the primal solution from the last time the model was solved is used.\n\nExamples\n\njulia> model = Model();\n\njulia> @variable(model, 0.5 <= x <= 1);\n\njulia> primal_feasibility_report(model, Dict(x => 0.2))\nDict{Any,Float64} with 1 entry:\n  x ≥ 0.5 => 0.3\n\n\n\n\n\nprimal_feasibility_report(\n    point::Function,\n    model::Model;\n    atol::Float64 = 0.0,\n    skip_missing::Bool = false,\n)\n\nA form of primal_feasibility_report where a function is passed as the first argument instead of a dictionary as the second argument.\n\nExamples\n\njulia> model = Model();\n\njulia> @variable(model, 0.5 <= x <= 1);\n\njulia> primal_feasibility_report(model) do v\n           return value(v)\n       end\nDict{Any,Float64} with 1 entry:\n    x ≥ 0.5 => 0.3\n\n\n\n\n\n","category":"function"},{"location":"tutorials/conic/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/conic/corr_sdp.jl\"","category":"page"},{"location":"tutorials/conic/corr_sdp/#The-correlation-problem","page":"The correlation problem","title":"The correlation problem","text":"","category":"section"},{"location":"tutorials/conic/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"Given three random variables A, B, C and given bounds on two of the three correlation coefficients:","category":"page"},{"location":"tutorials/conic/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"-0.2 <= ρ_AB <= -0.1\n0.4 <= ρ_BC <=  0.5","category":"page"},{"location":"tutorials/conic/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"We can use the following property of the correlations to determine bounds on ρ_AC by solving a SDP:","category":"page"},{"location":"tutorials/conic/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"|  1    ρ_AB  ρ_AC |\n| ρ_AB   1    ρ_BC |  ≽ 0\n| ρ_AC  ρ_BC   1   |","category":"page"},{"location":"tutorials/conic/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"using JuMP\nimport SCS\n\nfunction example_corr_sdp()\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, X[1:3, 1:3], PSD)\n    # Diagonal is 1s\n    @constraint(model, X[1, 1] == 1)\n    @constraint(model, X[2, 2] == 1)\n    @constraint(model, X[3, 3] == 1)\n    # Bounds on the known correlations\n    @constraint(model, X[1, 2] >= -0.2)\n    @constraint(model, X[1, 2] <= -0.1)\n    @constraint(model, X[2, 3] >= 0.4)\n    @constraint(model, X[2, 3] <= 0.5)\n    # Find upper bound\n    @objective(model, Max, X[1, 3])\n    optimize!(model)\n    println(\"An upper bound for X[1, 3] is $(value(X[1, 3]))\")\n    # Find lower bound\n    @objective(model, Min, X[1, 3])\n    optimize!(model)\n    println(\"A lower bound for X[1, 3] is $(value(X[1, 3]))\")\n    return\nend\n\nexample_corr_sdp()","category":"page"},{"location":"tutorials/conic/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"","category":"page"},{"location":"tutorials/conic/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/callbacks/#callbacks_manual","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"","category":"section"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"Many mixed-integer (linear, conic, and nonlinear) programming solvers offer the ability to modify the solve process. Examples include changing branching decisions in branch-and-bound, adding custom cutting planes, providing custom heuristics to find feasible solutions, or implementing on-demand separators to add new constraints only when they are violated by the current solution (also known as lazy constraints).","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"While historically this functionality has been limited to solver-specific interfaces, JuMP provides solver-independent support for three types of callbacks:","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"lazy constraints\nuser-cuts\nheuristic solutions","category":"page"},{"location":"manual/callbacks/#Available-solvers","page":"Solver-independent Callbacks","title":"Available solvers","text":"","category":"section"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"Solver-independent callback support is limited to a few solvers. This includes CPLEX, GLPK, Gurobi, and Xpress.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"warning: Warning\nWhile JuMP provides a solver-independent way of accessing callbacks, you should not assume that you will see identical behavior when running the same code on different solvers. For example, some solvers may ignore user-cuts for various reasons, while other solvers may add every user-cut. Read the underlying solver's callback documentation to understand details specific to each solver.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"tip: Tip\nThis page discusses solver-independent callbacks. However, each solver listed above also provides a solver-dependent callback to provide access to the full range of solver-specific features. Consult the solver's README for an example of how to use the solver-dependent callback. This will require you to understand the C interface of the solver.","category":"page"},{"location":"manual/callbacks/#Things-you-can-and-cannot-do-during-solver-independent-callbacks","page":"Solver-independent Callbacks","title":"Things you can and cannot do during solver-independent callbacks","text":"","category":"section"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"There is a limited range of things you can do during a callback. Only use the functions and macros explicitly stated in this page of the documentation, or in the Callbacks tutorial.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"Using any other part of the JuMP API (for example, adding a constraint with @constraint or modifying a variable bound with set_lower_bound) is undefined behavior, and your solver may throw an error, return an incorrect solution, or result in a segfault that aborts Julia.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"In each of the three solver-independent callbacks, there are two things you may query:","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"callback_node_status returns an MOI.CallbackNodeStatusCode enum indicating if the current primal solution is integer feasible.\ncallback_value returns the current primal solution of a variable.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"If you need to query any other information, use a solver-dependent callback instead. Each solver supporting a solver-dependent callback has information on how to use it in the README of their GitHub repository.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"If you want to modify the problem in a callback, you must use a lazy constraint.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"warning: Warning\nYou can only set each callback once. Calling set twice will over-write the earlier callback. In addition, if you use a solver-independent callback, you cannot set a solver-dependent callback.","category":"page"},{"location":"manual/callbacks/#Lazy-constraints","page":"Solver-independent Callbacks","title":"Lazy constraints","text":"","category":"section"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"Lazy constraints are useful when the full set of constraints is too large to explicitly include in the initial formulation. When a MIP solver reaches a new solution, for example with a heuristic or by solving a problem at a node in the branch-and-bound tree, it will give the user the chance to provide constraints that would make the current solution infeasible. For some more information about lazy constraints, see this blog post by Paul Rubin.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"A lazy constraint callback can be set using the following syntax:","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"model = Model(GLPK.Optimizer)\n@variable(model, x <= 10, Int)\n@objective(model, Max, x)\nfunction my_callback_function(cb_data)\n    status = callback_node_status(cb_data, model)\n    if status == MOI.CALLBACK_NODE_STATUS_FRACTIONAL\n        # `callback_value(cb_data, x)` is not integer (to some tolerance).\n        # If, for example, your lazy constraint generator requires an\n        # integer-feasible primal solution, you can add a `return` here.\n        return\n    elseif status == MOI.CALLBACK_NODE_STATUS_INTEGER\n        # `callback_value(cb_data, x)` is integer (to some tolerance).\n    else\n        @assert status == MOI.CALLBACK_NODE_STATUS_UNKNOWN\n        # `callback_value(cb_data, x)` might be fractional or integer.\n    end\n    x_val = callback_value(cb_data, x)\n    if x_val > 2 + 1e-6\n        con = @build_constraint(x <= 2)\n        MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n    end\nend\nMOI.set(model, MOI.LazyConstraintCallback(), my_callback_function)","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"info: Info\nThe lazy constraint callback may be called at fractional or integer nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every primal solution.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"warning: Warning\nOnly add a lazy constraint if your primal solution violates the constraint. Adding the lazy constraint irrespective of feasibility may result in the solver returning an incorrect solution, or lead to many constraints being added, slowing down the solution process.model = Model(GLPK.Optimizer)\n@variable(model, x <= 10, Int)\n@objective(model, Max, x)\nfunction bad_callback_function(cb_data)\n    # Don't do this!\n    con = @build_constraint(x <= 2)\n    MOI.submit(model, MOI.LazyConstraint(cb_data), con)\nend\nfunction good_callback_function(cb_data)\n    if callback_value(x) > 2\n        con = @build_constraint(x <= 2)\n        MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n    end\nend\nMOI.set(model, MOI.LazyConstraintCallback(), good_callback_function)","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"warning: Warning\nDuring the solve, a solver may visit a point that was cut off by a previous lazy constraint, for example, because the earlier lazy constraint was removed during presolve. However, the solver will not stop until it reaches a solution that satisfies all added lazy constraints.","category":"page"},{"location":"manual/callbacks/#User-cuts","page":"Solver-independent Callbacks","title":"User cuts","text":"","category":"section"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"User cuts, or simply cuts, provide a way for the user to tighten the LP relaxation using problem-specific knowledge that the solver cannot or is unable to infer from the model. Just like with lazy constraints, when a MIP solver reaches a new node in the branch-and-bound tree, it will give the user the chance to provide cuts to make the current relaxed (fractional) solution infeasible in the hopes of obtaining an integer solution. For more details about the difference between user cuts and lazy constraints see the aforementioned blog post.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"A user-cut callback can be set using the following syntax:","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"model = Model(GLPK.Optimizer)\n@variable(model, x <= 10.5, Int)\n@objective(model, Max, x)\nfunction my_callback_function(cb_data)\n    x_val = callback_value(cb_data, x)\n    con = @build_constraint(x <= floor(x_val))\n    MOI.submit(model, MOI.UserCut(cb_data), con)\nend\nMOI.set(model, MOI.UserCutCallback(), my_callback_function)","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"warning: Warning\nUser cuts must not change the set of integer feasible solutions. Equivalently, user cuts can only remove fractional solutions. If you add a cut that removes an integer solution (even one that is not optimal), the solver may return an incorrect solution.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"info: Info\nThe user-cut callback may be called at fractional nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every fractional primal solution.","category":"page"},{"location":"manual/callbacks/#Heuristic-solutions","page":"Solver-independent Callbacks","title":"Heuristic solutions","text":"","category":"section"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"Integer programming solvers frequently include heuristics that run at the nodes of the branch-and-bound tree. They aim to find integer solutions quicker than plain branch-and-bound would to tighten the bound, allowing us to fathom nodes quicker and to tighten the integrality gap.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"Some heuristics take integer solutions and explore their \"local neighborhood\" (for example, flipping binary variables, fix some variables and solve a smaller MILP) and others take fractional solutions and attempt to round them in an intelligent way.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"You may want to add a heuristic of your own if you have some special insight into the problem structure that the solver is not aware of, for example, you can consistently take fractional solutions and intelligently guess integer solutions from them.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"A heuristic solution callback can be set using the following syntax:","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"model = Model(GLPK.Optimizer)\n@variable(model, x <= 10.5, Int)\n@objective(model, Max, x)\nfunction my_callback_function(cb_data)\n    x_val = callback_value(cb_data, x)\n    status = MOI.submit(\n        model, MOI.HeuristicSolution(cb_data), [x], [floor(Int, x_val)]\n    )\n    println(\"I submitted a heuristic solution, and the status was: \", status)\nend\nMOI.set(model, MOI.HeuristicCallback(), my_callback_function)","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"The third argument to submit is a vector of JuMP variables, and the fourth argument is a vector of values corresponding to each variable.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"MOI.submit returns an enum that depends on whether the solver accepted the solution. The possible return codes are:","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"MOI.HEURISTIC_SOLUTION_ACCEPTED\nMOI.HEURISTIC_SOLUTION_REJECTED\nMOI.HEURISTIC_SOLUTION_UNKNOWN","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"warning: Warning\nSome solvers may accept partial solutions. Others require a feasible integer solution for every variable. If in doubt, provide a complete solution.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"info: Info\nThe heuristic solution callback may be called at fractional nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every fractional primal solution.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"DocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"manual/expressions/#Expressions","page":"Expressions","title":"Expressions","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"JuMP has three types of expressions: affine, quadratic, and nonlinear. These expressions can be inserted into constraints or into the objective. This is particularly useful if an expression is used in multiple places in the model.","category":"page"},{"location":"manual/expressions/#Affine-expressions","page":"Expressions","title":"Affine expressions","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"There are four ways of constructing an affine expression in JuMP: with the @expression macro, with operator overloading, with the AffExpr constructor, and with add_to_expression!.","category":"page"},{"location":"manual/expressions/#Macros","page":"Expressions","title":"Macros","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"The recommended way to create an affine expression is via the @expression macro.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = @expression(model, 2x + y - 1)\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"This expression can be used in the objective or added to a constraint. For example:","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"@objective(model, Min, 2 * ex - 1)\nobjective_function(model)\n\n# output\n\n4 x + 2 y - 3","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Just like variables and constraints, named expressions can also be created. For example","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x[i = 1:3])\n@expression(model, expr[i = 1:3], i * sum(x[j] for j in i:3))\nexpr\n\n# output\n\n3-element Vector{AffExpr}:\n x[1] + x[2] + x[3]\n 2 x[2] + 2 x[3]\n 3 x[3]","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"tip: Tip\nYou can read more about containers in the Containers section.","category":"page"},{"location":"manual/expressions/#Operator-overloading","page":"Expressions","title":"Operator overloading","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Expressions can also be created without macros. However, note that in some cases, this can be much slower that constructing an expression using macros.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = 2x + y - 1\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"manual/expressions/#Constructors","page":"Expressions","title":"Constructors","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"A third way to create an affine expression is by the AffExpr constructor. The first argument is the constant term, and the remaining arguments are variable-coefficient pairs.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = AffExpr(-1.0, x => 2.0, y => 1.0)\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"manual/expressions/#add_to_expression!","page":"Expressions","title":"add_to_expression!","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"The fourth way to create an affine expression is by using add_to_expression!. Compared to the operator overloading method, this approach is faster because it avoids constructing temporary objects. The @expression macro uses add_to_expression! behind-the-scenes.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = AffExpr(-1.0)\nadd_to_expression!(ex, 2.0, x)\nadd_to_expression!(ex, 1.0, y)\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"warning: Warning\nRead the section Initializing arrays for some cases to be careful about when using add_to_expression!.","category":"page"},{"location":"manual/expressions/#Removing-zero-terms","page":"Expressions","title":"Removing zero terms","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Use drop_zeros! to remove terms from an affine expression with a 0 coefficient.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @expression(model, ex, x + 1 - x)\n0 x + 1\n\njulia> drop_zeros!(ex)\n\njulia> ex\n1","category":"page"},{"location":"manual/expressions/#Coefficients","page":"Expressions","title":"Coefficients","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Use coefficient to return the coefficient associated with a variable in an affine expression.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @expression(model, ex, 2x + 1)\n2 x + 1\n\njulia> coefficient(ex, x)\n2.0\n\njulia> coefficient(ex, y)\n0.0","category":"page"},{"location":"manual/expressions/#Quadratic-expressions","page":"Expressions","title":"Quadratic expressions","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Like affine expressions, there are four ways of constructing a quadratic expression in JuMP: macros, operator overloading, constructors, and add_to_expression!.","category":"page"},{"location":"manual/expressions/#Macros-2","page":"Expressions","title":"Macros","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"The @expression macro can be used to create quadratic expressions by including quadratic terms.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = @expression(model, x^2 + 2 * x * y + y^2 + x + y - 1)\n\n# output\n\nx² + 2 y*x + y² + x + y - 1","category":"page"},{"location":"manual/expressions/#Operator-overloading-2","page":"Expressions","title":"Operator overloading","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Operator overloading can also be used to create quadratic expressions. The same performance warning (discussed in the affine expression section) applies.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = x^2 + 2 * x * y + y^2 + x + y - 1\n\n# output\n\nx² + 2 x*y + y² + x + y - 1","category":"page"},{"location":"manual/expressions/#Constructors-2","page":"Expressions","title":"Constructors","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Quadratic expressions can also be created using the QuadExpr constructor. The first argument is an affine expression, and the remaining arguments are pairs, where the first term is a JuMP.UnorderedPair and the second term is the coefficient.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\naff_expr = AffExpr(-1.0, x => 1.0, y => 1.0)\nquad_expr = QuadExpr(aff_expr, UnorderedPair(x, x) => 1.0,\n                     UnorderedPair(x, y) => 2.0, UnorderedPair(y, y) => 1.0)\n\n# output\n\nx² + 2 x*y + y² + x + y - 1","category":"page"},{"location":"manual/expressions/#add_to_expression!-2","page":"Expressions","title":"add_to_expression!","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Finally, add_to_expression! can also be used to add quadratic terms.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = QuadExpr(x + y - 1.0)\nadd_to_expression!(ex, 1.0, x, x)\nadd_to_expression!(ex, 2.0, x, y)\nadd_to_expression!(ex, 1.0, y, y)\n\n# output\n\nx² + 2 x*y + y² + x + y - 1","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"warning: Warning\nRead the section Initializing arrays for some cases to be careful about when using add_to_expression!.","category":"page"},{"location":"manual/expressions/#Removing-zero-terms-2","page":"Expressions","title":"Removing zero terms","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Use drop_zeros! to remove terms from a quadratic expression with a 0 coefficient.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @expression(model, ex, x^2 + x + 1 - x^2)\n0 x² + x + 1\n\njulia> drop_zeros!(ex)\n\njulia> ex\nx + 1","category":"page"},{"location":"manual/expressions/#Coefficients-2","page":"Expressions","title":"Coefficients","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Use coefficient to return the coefficient associated with a pair of variables in a quadratic expression.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @expression(model, ex, 2*x*y + 3*x)\n2 x*y + 3 x\n\njulia> coefficient(ex, x, y)\n2.0\n\njulia> coefficient(ex, x, x)\n0.0\n\njulia> coefficient(ex, y, x)\n2.0\n\njulia> coefficient(ex, x)\n3.0","category":"page"},{"location":"manual/expressions/#Nonlinear-expressions","page":"Expressions","title":"Nonlinear expressions","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Nonlinear expressions can be constructed only using the @NLexpression macro and can be used only in @NLobjective, @NLconstraint, and other @NLexpressions. Moreover, quadratic and affine expressions cannot be used in the nonlinear macros. For more details, see the Nonlinear Modeling section.","category":"page"},{"location":"manual/expressions/#Initializing-arrays","page":"Expressions","title":"Initializing arrays","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"JuMP implements zero(AffExpr) and one(AffExpr) to support various functions in LinearAlgebra (for example, accessing the off-diagonal of a Diagonal matrix).","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> zero(AffExpr)\n0\n\njulia> one(AffExpr)\n1","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"However, this can result in a subtle bug if you call add_to_expression! or the MutableArithmetics API on an element created by zeros or ones:","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> x = zeros(AffExpr, 2)\n2-element Vector{AffExpr}:\n 0\n 0\n\njulia> add_to_expression!(x[1], 1.1)\n1.1\n\njulia> x\n2-element Vector{AffExpr}:\n 1.1\n 1.1","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Notice how we modified x[1], but we also changed x[2]!","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"This happened because zeros(AffExpr, 2) calls zero(AffExpr) once to obtain a zero element, and then creates an appropriately sized array filled with the same element.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"This also happens with broadcasting calls containing a conversion of 0 or 1:","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> x = Vector{AffExpr}(undef, 2)\n2-element Vector{AffExpr}:\n #undef\n #undef\n\njulia> x .= 0\n2-element Vector{AffExpr}:\n 0\n 0\n\njulia> add_to_expression!(x[1], 1.1)\n1.1\n\njulia> x\n2-element Vector{AffExpr}:\n 1.1\n 1.1","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"The recommended way to create an array of empty expressions is as follows:","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> x = Vector{AffExpr}(undef, 2)\n2-element Vector{AffExpr}:\n #undef\n #undef\n\njulia> for i in eachindex(x)\n           x[i] = AffExpr(0.0)\n       end\n\njulia> add_to_expression!(x[1], 1.1)\n1.1\n\njulia> x\n2-element Vector{AffExpr}:\n 1.1\n 0","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Alternatively, use non-mutating operation to avoid updating x[1] in-place:","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> x = zeros(AffExpr, 2)\n2-element Vector{AffExpr}:\n 0\n 0\n\njulia> x[1] += 1.1\n1.1\n\njulia> x\n2-element Vector{AffExpr}:\n 1.1\n 0","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Note that for large expressions this will be slower due to the allocation of additional temporary objects.","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/nonlinear/space_shuttle_reentry_trajectory.jl\"","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/#Optimal-control-for-a-Space-Shuttle-reentry-trajectory","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"","category":"section"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"Originally Contributed by: Henrique Ferrolho","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"This tutorial demonstrates how to compute a reentry trajectory for the Space Shuttle, by formulating and solving a nonlinear programming problem. The problem was drawn from Chapter 6 of \"Practical Methods for Optimal Control and Estimation Using Nonlinear Programming\", by John T. Betts.","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"tip: Tip\nThis tutorial is a more-complicated version of the Rocket Control example. If you are new to solving nonlinear programs in JuMP, you may want to start there instead.","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"The motion of the vehicle is defined by the following set of DAEs:","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"beginaligned\ndoth  = v sin gamma  \ndotphi  = fracvr cos gamma sin psi  cos theta  \ndottheta  = fracvr cos gamma cos psi  \ndotv  = -fracDm - g sin gamma  \ndotgamma  = fracLm v cos(beta) + cos gamma left ( fracvr - fracgv right )  \ndotpsi  = frac1m v cos gamma L sin(beta) + fracvr cos theta cos gamma sin psi sin theta  \nq  le q_U  \nendaligned","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"where the aerodynamic heating on the vehicle wing leading edge is q = q_a q_r and the dynamic variables are","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"beginaligned\n     h  quad textaltitude (ft)     qquad   gamma quad textflight path angle (rad) \n  phi  quad textlongitude (rad)   qquad   psi   quad textazimuth (rad)           \ntheta  quad textlatitude (rad)    qquad   alpha quad textangle of attack (rad)   \n     v  quad textvelocity (ftsec) qquad   beta  quad textbank angle (rad)\nendaligned","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"The aerodynamic and atmospheric forces on the vehicle are specified by the following quantities (English units):","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"beginaligned\n           D  = frac12 c_D S rho v^2                  qquad  a_0  = -020704 \n           L  = frac12 c_L S rho v^2                  qquad  a_1  =  0029244 \n           g  = mu  r^2                                   qquad  mu  =  014076539 times 10^17 \n           r  = R_e + h                                     qquad  b_0  =  007854 \n        rho  = rho_0 exp-hh_r                         qquad  b_1  = -061592  times 10^-2 \n      rho_0  = 0002378                                    qquad  b_2  =  0621408 times 10^-3 \n         h_r  = 23800                                       qquad  q_r  =  17700 sqrtrho (00001 v)^307 \n         c_L  = a_0 + a_1 hatalpha                      qquad  q_a  =  c_0 + c_1 hatalpha + c_2 hatalpha^2 + c_3 hatalpha^3 \n         c_D  = b_0 + b_1 hatalpha + b_2 hatalpha^2 qquad  c_0  =  10672181 \nhatalpha  = 180 alpha  pi                            qquad  c_1  = -019213774 times 10^-1 \n         R_e  = 20902900                                    qquad  c_2  =  021286289 times 10^-3 \n           S  = 2690                                        qquad  c_3  = -010117249 times 10^-5\nendaligned","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"The reentry trajectory begins at an altitude where the aerodynamic forces are quite small with a weight of w = 203000 (lb) and mass m = w  g_0 (slug), where g_0 = 32174 (ft/sec^2). The initial conditions are as follows:","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"beginaligned\n     h  = 260000 text ft  qquad  v       = 25600 text ftsec \n  phi  = 0      text deg qquad  gamma  = -1    text deg    \ntheta  = 0      text deg qquad  psi    = 90    text deg\nendaligned","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"The final point on the reentry trajectory occurs at the unknown (free) time t_F, at the so-called terminal area energy management (TAEM) interface, which is defined by the conditions","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"h = 80000 text ft qquad v = 2500 text ftsec qquad gamma = -5 text deg","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"As explained in the book, our goal is to maximize the final cross-range, which is equivalent to maximizing the final latitude of the vehicle, i.e., J = theta(t_F).","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"(Image: Max cross-range shuttle reentry)","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/#Approach","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Approach","text":"","category":"section"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"We will use a discretized model of time, with a fixed number of discretized points, n. The decision variables at each point are going to be the state of the vehicle and the controls commanded to it. In addition, we will also make each time step size Delta t a decision variable; that way, we can either fix the time step size easily, or allow the solver to fine-tune the duration between each adjacent pair of points. Finally, in order to approximate the derivatives of the problem dynamics, we will use either rectangular or trapezoidal integration.","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"warning: Warning\nDo not try to actually land a Space Shuttle using this notebook! There's no mesh refinement going on, which can lead to unrealistic trajectories having position and velocity errors with orders of magnitude 10^4 ft and 10^2 ft/sec, respectively.","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"using JuMP\nimport Interpolations\nimport Ipopt\n\n# Global variables\nconst w = 203000.0  # weight (lb)\nconst g₀ = 32.174    # acceleration (ft/sec^2)\nconst m = w / g₀    # mass (slug)\n\n# Aerodynamic and atmospheric forces on the vehicle\nconst ρ₀ = 0.002378\nconst hᵣ = 23800.0\nconst Rₑ = 20902900.0\nconst μ = 0.14076539e17\nconst S = 2690.0\nconst a₀ = -0.20704\nconst a₁ = 0.029244\nconst b₀ = 0.07854\nconst b₁ = -0.61592e-2\nconst b₂ = 0.621408e-3\nconst c₀ = 1.0672181\nconst c₁ = -0.19213774e-1\nconst c₂ = 0.21286289e-3\nconst c₃ = -0.10117249e-5\n\n# Initial conditions\nconst h_s = 2.6          # altitude (ft) / 1e5\nconst ϕ_s = deg2rad(0)   # longitude (rad)\nconst θ_s = deg2rad(0)   # latitude (rad)\nconst v_s = 2.56         # velocity (ft/sec) / 1e4\nconst γ_s = deg2rad(-1)  # flight path angle (rad)\nconst ψ_s = deg2rad(90)  # azimuth (rad)\nconst α_s = deg2rad(0)   # angle of attack (rad)\nconst β_s = deg2rad(0)   # bank angle (rad)\nconst t_s = 1.00         # time step (sec)\n\n# Final conditions, the so-called Terminal Area Energy Management (TAEM)\nconst h_t = 0.8          # altitude (ft) / 1e5\nconst v_t = 0.25         # velocity (ft/sec) / 1e4\nconst γ_t = deg2rad(-5)  # flight path angle (rad)\n\n# Number of mesh points (knots) to be used\nconst n = 503\n\n# Integration scheme to be used for the dynamics\nconst integration_rule = \"rectangular\"\nnothing #hide","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"tip: Choose a good linear solver\nPicking a good linear solver is extremely important to maximize the performance of nonlinear solvers. For the best results, it is advised to experiment different linear solvers.For example, the linear solver MA27 is outdated and can be quite slow. MA57 is a much better alternative, especially for highly-sparse problems (such as trajectory optimization problems).","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"# Uncomment the lines below to pass user options to the solver\nuser_options = (\n# \"mu_strategy\" => \"monotone\",\n# \"linear_solver\" => \"ma27\",\n)\n\n# Create JuMP model, using Ipopt as the solver\nmodel = Model(optimizer_with_attributes(Ipopt.Optimizer, user_options...))\n\n@variables(model, begin\n    0 ≤ scaled_h[1:n]                # altitude (ft) / 1e5\n    ϕ[1:n]                # longitude (rad)\n    deg2rad(-89) ≤ θ[1:n] ≤ deg2rad(89)  # latitude (rad)\n    1e-4 ≤ scaled_v[1:n]                # velocity (ft/sec) / 1e4\n    deg2rad(-89) ≤ γ[1:n] ≤ deg2rad(89)  # flight path angle (rad)\n    ψ[1:n]                # azimuth (rad)\n    deg2rad(-90) ≤ α[1:n] ≤ deg2rad(90)  # angle of attack (rad)\n    deg2rad(-89) ≤ β[1:n] ≤ deg2rad(1)  # bank angle (rad)\n    #        3.5 ≤       Δt[1:n] ≤ 4.5          # time step (sec)\n    Δt[1:n] == 4.0         # time step (sec)\nend)","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"info: Info\nAbove you can find two alternatives for the Δt variables.The first one, 3.5 ≤ Δt[1:n] ≤ 4.5 (currently commented), allows some wiggle room for the solver to adjust the time step size between pairs of mesh points. This is neat because it allows the solver to figure out which parts of the flight require more dense discretization than others. (Remember, the number of discretized points is fixed, and this example does not implement mesh refinement.) However, this makes the problem more complex to solve, and therefore leads to a longer computation time.The second line, Δt[1:n] == 4.0, fixes the duration of every time step to exactly 4.0 seconds. This allows the problem to be solved faster. However, to do this we need to know beforehand that the close-to-optimal total duration of the flight is ~2009 seconds. Therefore, if we split the total duration in slices of 4.0 seconds, we know that we require n = 503 knots to discretize the whole trajectory.","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"# Fix initial conditions\nfix(scaled_h[1], h_s; force = true)\nfix(ϕ[1], ϕ_s; force = true)\nfix(θ[1], θ_s; force = true)\nfix(scaled_v[1], v_s; force = true)\nfix(γ[1], γ_s; force = true)\nfix(ψ[1], ψ_s; force = true)\n\n# Fix final conditions\nfix(scaled_h[n], h_t; force = true)\nfix(scaled_v[n], v_t; force = true)\nfix(γ[n], γ_t; force = true)\n\n# Initial guess: linear interpolation between boundary conditions\nx_s = [h_s, ϕ_s, θ_s, v_s, γ_s, ψ_s, α_s, β_s, t_s]\nx_t = [h_t, ϕ_s, θ_s, v_t, γ_t, ψ_s, α_s, β_s, t_s]\ninterp_linear = Interpolations.LinearInterpolation([1, n], [x_s, x_t])\ninitial_guess = mapreduce(transpose, vcat, interp_linear.(1:n))\nset_start_value.(all_variables(model), vec(initial_guess))\n\n# Functions to restore `h` and `v` to their true scale\n@NLexpression(model, h[j = 1:n], scaled_h[j] * 1e5)\n@NLexpression(model, v[j = 1:n], scaled_v[j] * 1e4)\n\n# Helper functions\n@NLexpression(model, c_L[j = 1:n], a₀ + a₁ * rad2deg(α[j]))\n@NLexpression(\n    model,\n    c_D[j = 1:n],\n    b₀ + b₁ * rad2deg(α[j]) + b₂ * rad2deg(α[j])^2\n)\n@NLexpression(model, ρ[j = 1:n], ρ₀ * exp(-h[j] / hᵣ))\n@NLexpression(model, D[j = 1:n], 0.5 * c_D[j] * S * ρ[j] * v[j]^2)\n@NLexpression(model, L[j = 1:n], 0.5 * c_L[j] * S * ρ[j] * v[j]^2)\n@NLexpression(model, r[j = 1:n], Rₑ + h[j])\n@NLexpression(model, g[j = 1:n], μ / r[j]^2)\n\n# Motion of the vehicle as a differential-algebraic system of equations (DAEs)\n@NLexpression(model, δh[j = 1:n], v[j] * sin(γ[j]))\n@NLexpression(\n    model,\n    δϕ[j = 1:n],\n    (v[j] / r[j]) * cos(γ[j]) * sin(ψ[j]) / cos(θ[j])\n)\n@NLexpression(model, δθ[j = 1:n], (v[j] / r[j]) * cos(γ[j]) * cos(ψ[j]))\n@NLexpression(model, δv[j = 1:n], -(D[j] / m) - g[j] * sin(γ[j]))\n@NLexpression(\n    model,\n    δγ[j = 1:n],\n    (L[j] / (m * v[j])) * cos(β[j]) +\n    cos(γ[j]) * ((v[j] / r[j]) - (g[j] / v[j]))\n)\n@NLexpression(\n    model,\n    δψ[j = 1:n],\n    (1 / (m * v[j] * cos(γ[j]))) * L[j] * sin(β[j]) +\n    (v[j] / (r[j] * cos(θ[j]))) * cos(γ[j]) * sin(ψ[j]) * sin(θ[j])\n)\n\n# System dynamics\nfor j in 2:n\n    i = j - 1  # index of previous knot\n\n    if integration_rule == \"rectangular\"\n        # Rectangular integration\n        @NLconstraint(model, h[j] == h[i] + Δt[i] * δh[i])\n        @NLconstraint(model, ϕ[j] == ϕ[i] + Δt[i] * δϕ[i])\n        @NLconstraint(model, θ[j] == θ[i] + Δt[i] * δθ[i])\n        @NLconstraint(model, v[j] == v[i] + Δt[i] * δv[i])\n        @NLconstraint(model, γ[j] == γ[i] + Δt[i] * δγ[i])\n        @NLconstraint(model, ψ[j] == ψ[i] + Δt[i] * δψ[i])\n    elseif integration_rule == \"trapezoidal\"\n        # Trapezoidal integration\n        @NLconstraint(model, h[j] == h[i] + 0.5 * Δt[i] * (δh[j] + δh[i]))\n        @NLconstraint(model, ϕ[j] == ϕ[i] + 0.5 * Δt[i] * (δϕ[j] + δϕ[i]))\n        @NLconstraint(model, θ[j] == θ[i] + 0.5 * Δt[i] * (δθ[j] + δθ[i]))\n        @NLconstraint(model, v[j] == v[i] + 0.5 * Δt[i] * (δv[j] + δv[i]))\n        @NLconstraint(model, γ[j] == γ[i] + 0.5 * Δt[i] * (δγ[j] + δγ[i]))\n        @NLconstraint(model, ψ[j] == ψ[i] + 0.5 * Δt[i] * (δψ[j] + δψ[i]))\n    else\n        @error \"Unexpected integration rule '$(integration_rule)'\"\n    end\nend\n\n# Objective: Maximize cross-range\n@objective(model, Max, θ[n])\n\nset_silent(model)  # Hide solver's verbose output\noptimize!(model)  # Solve for the control and state\n@assert termination_status(model) == LOCALLY_SOLVED\n\n# Show final cross-range of the solution\nprintln(\n    \"Final latitude θ = \",\n    round(objective_value(model) |> rad2deg, digits = 2),\n    \"°\",\n)","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/#Plotting-the-results","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Plotting the results","text":"","category":"section"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"using Plots","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"ts = cumsum([0; value.(Δt)])[1:end-1]\nnothing #hide","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"plt_altitude = plot(\n    ts,\n    value.(scaled_h),\n    legend = nothing,\n    title = \"Altitude (100,000 ft)\",\n)\nplt_longitude =\n    plot(ts, rad2deg.(value.(ϕ)), legend = nothing, title = \"Longitude (deg)\")\nplt_latitude =\n    plot(ts, rad2deg.(value.(θ)), legend = nothing, title = \"Latitude (deg)\")\nplt_velocity = plot(\n    ts,\n    value.(scaled_v),\n    legend = nothing,\n    title = \"Velocity (1000 ft/sec)\",\n)\nplt_flight_path =\n    plot(ts, rad2deg.(value.(γ)), legend = nothing, title = \"Flight Path (deg)\")\nplt_azimuth =\n    plot(ts, rad2deg.(value.(ψ)), legend = nothing, title = \"Azimuth (deg)\")\n\nplt = plot(\n    plt_altitude,\n    plt_velocity,\n    plt_longitude,\n    plt_flight_path,\n    plt_latitude,\n    plt_azimuth,\n    layout = grid(3, 2),\n    linewidth = 2,\n    size = (700, 700),\n)","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"function q(h, v, a)\n    ρ(h) = ρ₀ * exp(-h / hᵣ)\n    qᵣ(h, v) = 17700 * √ρ(h) * (0.0001 * v)^3.07\n    qₐ(a) = c₀ + c₁ * rad2deg(a) + c₂ * rad2deg(a)^2 + c₃ * rad2deg(a)^3\n    # Aerodynamic heating on the vehicle wing leading edge\n    return qₐ(a) * qᵣ(h, v)\nend\n\nplt_attack_angle = plot(\n    ts[1:end-1],\n    rad2deg.(value.(α)[1:end-1]),\n    legend = nothing,\n    title = \"Angle of Attack (deg)\",\n)\nplt_bank_angle = plot(\n    ts[1:end-1],\n    rad2deg.(value.(β)[1:end-1]),\n    legend = nothing,\n    title = \"Bank Angle (deg)\",\n)\nplt_heating = plot(\n    ts,\n    q.(value.(scaled_h) * 1e5, value.(scaled_v) * 1e4, value.(α)),\n    legend = nothing,\n    title = \"Heating (BTU/ft/ft/sec)\",\n)\n\nplt = plot(\n    plt_attack_angle,\n    plt_bank_angle,\n    plt_heating,\n    layout = grid(3, 1),\n    linewidth = 2,\n    size = (700, 700),\n)","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"plt = plot(\n    rad2deg.(value.(ϕ)),\n    rad2deg.(value.(θ)),\n    value.(scaled_h),\n    linewidth = 2,\n    legend = nothing,\n    title = \"Space Shuttle Reentry Trajectory\",\n    xlabel = \"Longitude (deg)\",\n    ylabel = \"Latitude (deg)\",\n    zlabel = \"Altitude (100,000 ft)\",\n)","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP, GLPK\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"background/algebraic_modeling_languages/#algebraic-modeling-language","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"JuMP is an algebraic modeling language for mathematical optimization written in the Julia language. In this page, we explain what an algebraic modeling language actually is.","category":"page"},{"location":"background/algebraic_modeling_languages/#What-is-an-algebraic-modeling-language?","page":"Algebraic modeling languages","title":"What is an algebraic modeling language?","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"If you have taken a class in mixed-integer linear programming, you will have seen a formulation like:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"beginaligned\nmin       c^top x \ntextst  A x = b  \n             x ge 0  \n             x_i in mathbbZ quad forall i in mathcalI\nendaligned","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"where c, A, and b are appropriately sized vectors and matrices of data, and mathcalI denotes the set of variables that are integer.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Solvers expect problems in a standard form like this because it limits the types of constraints that they need to consider. This makes writing a solver much easier.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"info: What is a solver?\nA solver is a software package that computes solutions to one or more classes of problems.For example, GLPK is a solver for linear programming (LP) and mixed integer programming (MIP) problems. It incorporates algorithms such as the simplex method and the interior-point method.JuMP currently supports a number of open-source and commercial solvers, which can be viewed in the Supported-solvers table.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Despite the textbook view of a linear program, you probably formulated problems algebraically like so:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"beginaligned\nmax       sumlimits_i = 1^n c_i x_i                   \ntextst  sumlimits_i = 1^n w_i x_i le b             \n             x_i ge 0 quad forall i = 1ldotsn          \n             x_i in mathbbZ quad forall i = 1ldotsn\nendaligned","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"info: Info\nDo you recognize this formulation? It's the knapsack problem.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Users prefer to write problems in algebraic form because it is more convenient. For example, we used le b, even though the standard form only supported constraints of the form Ax = b.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"We could convert our knapsack problem into the standard form by adding a new slack variable x_0:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"beginaligned\nmax       sumlimits_i = 1^n c_i x_i            \ntextst  x_0 + sumlimits_i = 1^n w_i x_i = b  \n             x_i ge 0 quad forall i = 0ldotsn   \n             x_i in mathbbZ quad forall i = 1ldotsn\nendaligned","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"However, as models get more complicated, this manual conversion becomes more and more error-prone.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"An algebraic modeling language is a tool that simplifies the translation between the algebraic form of the modeler, and the standard form of the solver.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Each algebraic modeling language has two main parts:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"A domain specific language for the user to write down problems in algebraic form.\nA converter from the algebraic form into a standard form supported by the solver (and back again).","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Part 2 is less trivial than it might seem, because each solver has a unique application programming interface (API) and data structure for representing optimization models and obtaining results.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"JuMP uses the MathOptInterface.jl package to abstract these differences between solvers.","category":"page"},{"location":"background/algebraic_modeling_languages/#What-is-MathOptInterface?","page":"Algebraic modeling languages","title":"What is MathOptInterface?","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"MathOptInterface (MOI) is an abstraction layer designed to provide an interface to mathematical optimization solvers so that users do not need to understand multiple solver-specific APIs. MOI can be used directly, or through a higher-level modeling interface like JuMP.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"There are three main parts to MathOptInterface:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"A solver-independent API that abstracts concepts such as adding and deleting variables and constraints, setting and getting parameters, and querying results. For more information on the MathOptInterface API, read the documentation.\nAn automatic rewriting system based on equivalent formulations of a constraint. For more information on this rewriting system, read the LazyBridgeOptimizer section of the manual, and our paper on arXiv.\nUtilities for managing how and when models are copied to solvers. For more information on this, read the CachingOptimizer section of the manual.","category":"page"},{"location":"background/algebraic_modeling_languages/#From-user-to-solver","page":"Algebraic modeling languages","title":"From user to solver","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"This section provides a brief summary of the steps that happen in order to translate the model that the user writes into a model that the solver understands.","category":"page"},{"location":"background/algebraic_modeling_languages/#Step-I:-writing-in-algebraic-form","page":"Algebraic modeling languages","title":"Step I: writing in algebraic form","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"JuMP provides the first part of an algebraic modeling language using the @variable, @objective, and @constraint macros.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"For example, here's how we write the knapsack problem in JuMP:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"julia> using JuMP, GLPK\n\njulia> function algebraic_knapsack(c, w, b)\n           n = length(c)\n           model = Model(GLPK.Optimizer)\n           @variable(model, x[1:n] >= 0, Int)\n           @objective(model, Max, sum(c[i] * x[i] for i = 1:n))\n           @constraint(model, sum(w[i] * x[i] for i = 1:n) <= b)\n           optimize!(model)\n           return value.(x)\n       end\nalgebraic_knapsack (generic function with 1 method)\n\njulia> algebraic_knapsack([1, 2], [0.5, 0.5], 1.25)\n2-element Vector{Float64}:\n 0.0\n 2.0","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"This formulation is compact, and it closely matches the algebraic formulation of the model we wrote out above.","category":"page"},{"location":"background/algebraic_modeling_languages/#Step-II:-algebraic-to-functional","page":"Algebraic modeling languages","title":"Step II: algebraic to functional","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"For the next step, JuMP's macros re-write the variables and constraints into a functional form. Here's what the JuMP code looks like after this step:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"julia> using JuMP, GLPK\n\njulia> function nonalgebraic_knapsack(c, w, b)\n           n = length(c)\n           model = Model(GLPK.Optimizer)\n           x = [VariableRef(model) for i = 1:n]\n           for i = 1:n\n               set_lower_bound(x[i], 0)\n               set_integer(x[i])\n               set_name(x[i], \"x[$i]\")\n           end\n           obj = AffExpr(0.0)\n           for i = 1:n\n               add_to_expression!(obj, c[i], x[i])\n           end\n           set_objective(model, MAX_SENSE, obj)\n           lhs = AffExpr(0.0)\n           for i = 1:n\n               add_to_expression!(lhs, w[i], x[i])\n           end\n           con = build_constraint(error, lhs, MOI.LessThan(b))\n           add_constraint(model, con)\n           optimize!(model)\n           return value.(x)\n       end\nnonalgebraic_knapsack (generic function with 1 method)\n\njulia> nonalgebraic_knapsack([1, 2], [0.5, 0.5], 1.25)\n2-element Vector{Float64}:\n 0.0\n 2.0","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Hopefully you agree that the macro version is much easier to read!","category":"page"},{"location":"background/algebraic_modeling_languages/#Part-III:-JuMP-to-MathOptInterface","page":"Algebraic modeling languages","title":"Part III: JuMP to MathOptInterface","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"In the third step, JuMP converts the functional form of the problem, i.e., nonalgebraic_knapsack, into the MathOptInterface API:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"julia> using MathOptInterface, GLPK\n\njulia> const MOI = MathOptInterface;\n\njulia> function mathoptinterface_knapsack(optimizer, c, w, b)\n           n = length(c)\n           model = MOI.instantiate(optimizer)\n           x = MOI.add_variables(model, n)\n           for i in 1:n\n               MOI.add_constraint(model, x[i], MOI.GreaterThan(0.0))\n               MOI.add_constraint(model, x[i], MOI.Integer())\n               MOI.set(model, MOI.VariableName(), x[i], \"x[$i]\")\n           end\n           MOI.set(model, MOI.ObjectiveSense(), MOI.MAX_SENSE)\n           obj = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(c, x), 0.0)\n           MOI.set(model, MOI.ObjectiveFunction{typeof(obj)}(), obj)\n           MOI.add_constraint(\n               model,\n               MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(w, x), 0.0),\n               MOI.LessThan(b),\n           )\n           MOI.optimize!(model)\n           return MOI.get.(model, MOI.VariablePrimal(), x)\n       end\nmathoptinterface_knapsack (generic function with 1 method)\n\njulia> mathoptinterface_knapsack(GLPK.Optimizer, [1.0, 2.0], [0.5, 0.5], 1.25)\n2-element Vector{Float64}:\n 0.0\n 2.0","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"The code is becoming more verbose and looking less like the mathematical formulation that we started with.","category":"page"},{"location":"background/algebraic_modeling_languages/#Step-IV:-MathOptInterface-to-GLPK","page":"Algebraic modeling languages","title":"Step IV: MathOptInterface to GLPK","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"As a final step, the GLPK.jl package converts the MathOptInterface form, i.e., mathoptinterface_knapsack, into a GLPK-specific API:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"julia> using GLPK\n\njulia> function glpk_knapsack(c, w, b)\n           n = length(c)\n           model = glp_create_prob()\n           glp_add_cols(model, n)\n           for i in 1:n\n               glp_set_col_bnds(model, i, GLP_LO, 0.0, GLP_DBL_MAX)\n               glp_set_col_kind(model, i, GLP_IV)\n               glp_set_col_name(model, i, \"x[$i]\")\n           end\n           glp_set_obj_dir(model, GLP_MAX)\n           for i in 1:n\n               glp_set_obj_coef(model, i, c[i])\n           end\n           glp_set_obj_coef(model, 0, 0.0)\n           glp_add_rows(model, 1)\n           glp_set_mat_row(\n               model,\n               1,\n               length(w),\n               Ref(Cint.(1:n), 0),\n               Ref(w, 0),\n           )\n           glp_set_row_bnds(model, 1, GLP_UP, -GLP_DBL_MAX, b)\n           simplex_options = glp_smcp()\n           glp_init_smcp(simplex_options)\n           simplex_options.msg_lev = GLP_MSG_ERR\n           glp_simplex(model, simplex_options)\n           options = glp_iocp()\n           glp_init_iocp(options)\n           options.msg_lev = GLP_MSG_ERR\n           glp_intopt(model, options)\n           x = glp_mip_col_val.(model, 1:n)\n           glp_delete_prob(model)\n           return x\n       end\nglpk_knapsack (generic function with 1 method)\n\njulia> glpk_knapsack([1.0, 2.0], [0.5, 0.5], 1.25)\n2-element Vector{Float64}:\n 0.0\n 2.0","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"We've now gone from a algebraic model that looked identical to the mathematical model we started with, to a verbose function that uses GLPK-specific functionality.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"The difference between algebraic_knapsack and glpk_knapsack highlights the benefit that algebraic modeling languages provide to users. Moreover, if we used a different solver, the solver-specific function would be entirely different. A key benefit of an algebraic modeling language is that you can change the solver without needing to rewrite the model.","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/standard_form/#Standard-form-problem","page":"Standard form problem","title":"Standard form problem","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"MathOptInterface represents optimization problems in the standard form:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"beginalign\n     min_x in mathbbR^n  f_0(x)\n    \n     textst  f_i(x)  in mathcalS_i  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"where:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"the functions f_0 f_1 ldots f_m are specified by AbstractFunction objects\nthe sets mathcalS_1 ldots mathcalS_m are specified by AbstractSet objects","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"tip: Tip\nFor more information on this standard form, read our paper.","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"MOI defines some commonly used functions and sets, but the interface is extensible to other sets recognized by the solver.","category":"page"},{"location":"moi/manual/standard_form/#Functions","page":"Standard form problem","title":"Functions","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"The function types implemented in MathOptInterface.jl are:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"VariableIndex: x_j, i.e., projection onto a single coordinate defined by a variable index j.\nVectorOfVariables: projection onto multiple coordinates (i.e., extracting a subvector).\nScalarAffineFunction: a^T x + b, where a is a vector and b scalar.\nVectorAffineFunction: A x + b, where A is a matrix and b is a vector.\nScalarQuadraticFunction: frac12 x^T Q x + a^T x + b, where Q is a symmetric matrix, a is a vector, and b is a constant.\nVectorQuadraticFunction: a vector of scalar-valued quadratic functions.","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"Extensions for nonlinear programming are present but not yet well documented.","category":"page"},{"location":"moi/manual/standard_form/#One-dimensional-sets","page":"Standard form problem","title":"One-dimensional sets","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"The one-dimensional set types implemented in MathOptInterface.jl are:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"LessThan(upper):  x in mathbbR  x le mboxupper \nGreaterThan(lower):  x in mathbbR  x ge mboxlower \nEqualTo(value):  x in mathbbR  x = mboxvalue \nInterval(lower, upper):  x in mathbbR  x in mboxlowermboxupper \nInteger(): mathbbZ\nZeroOne():  0 1 \nSemicontinuous(lower,upper):  0 cup mboxlowermboxupper\nSemiinteger(lower,upper):  0 cup mboxlowermboxlower+1ldotsmboxupper-1mboxupper","category":"page"},{"location":"moi/manual/standard_form/#Vector-cones","page":"Standard form problem","title":"Vector cones","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"The vector-valued set types implemented in MathOptInterface.jl are:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"Reals(dimension): mathbbR^mboxdimension\nZeros(dimension): 0^mboxdimension\nNonnegatives(dimension):  x in mathbbR^mboxdimension  x ge 0 \nNonpositives(dimension):  x in mathbbR^mboxdimension  x le 0 \nSecondOrderCone(dimension):  (tx) in mathbbR^mboxdimension  t ge lVert x rVert_2 \nRotatedSecondOrderCone(dimension):  (tux) in mathbbR^mboxdimension  2tu ge lVert x rVert_2^2 tu ge 0 \nExponentialCone():  (xyz) in mathbbR^3  y exp (xy) le z y  0 \nDualExponentialCone():  (uvw) in mathbbR^3  -u exp (vu) le exp(1) w u  0 \nGeometricMeanCone(dimension):  (tx) in mathbbR^n+1  x ge 0 t le sqrtnx_1 x_2 cdots x_n  where n is mboxdimension - 1\nPowerCone(exponent):  (xyz) in mathbbR^3  x^mboxexponent y^1-mboxexponent ge z xy ge 0 \nDualPowerCone(exponent):  (uvw) in mathbbR^3  fracumboxexponent^mboxexponentfracv1-mboxexponent^1-mboxexponent ge w uv ge 0 \nNormOneCone(dimension):  (tx) in mathbbR^mboxdimension  t ge lVert x rVert_1  where lVert x rVert_1 = sum_i lvert x_i rvert\nNormInfinityCone(dimension):  (tx) in mathbbR^mboxdimension  t ge lVert x rVert_infty  where lVert x rVert_infty = max_i lvert x_i rvert.\nRelativeEntropyCone(dimension):  (u v w) in mathbbR^mboxdimension  u ge sum_i w_i log (fracw_iv_i) v_i ge 0 w_i ge 0 ","category":"page"},{"location":"moi/manual/standard_form/#Matrix-cones","page":"Standard form problem","title":"Matrix cones","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"The matrix-valued set types implemented in MathOptInterface.jl are:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"RootDetConeTriangle(dimension):  (tX) in mathbbR^1+mboxdimension(1+mboxdimension)2  t le det(X)^1mboxdimension X mbox is the upper triangle of a PSD matrix \nRootDetConeSquare(dimension):  (tX) in mathbbR^1+mboxdimension^2  t le det(X)^1mboxdimension X mbox is a PSD matrix \nPositiveSemidefiniteConeTriangle(dimension):  X in mathbbR^mboxdimension(mboxdimension+1)2  X mbox is the upper triangle of a PSD matrix \nPositiveSemidefiniteConeSquare(dimension):  X in mathbbR^mboxdimension^2  X mbox is a PSD matrix \nLogDetConeTriangle(dimension):  (tuX) in mathbbR^2+mboxdimension(1+mboxdimension)2  t le ulog(det(Xu)) X mbox is the upper triangle of a PSD matrix u  0 \nLogDetConeSquare(dimension):  (tuX) in mathbbR^2+mboxdimension^2  t le u log(det(Xu)) X mbox is a PSD matrix u  0 \nNormSpectralCone(row_dim, column_dim):  (t X) in mathbbR^1 + mboxrow_dim times mboxcolumn_dim  t ge sigma_1(X) X mbox is a matrix with row_dim rows and column_dim columns \nNormNuclearCone(row_dim, column_dim):  (t X) in mathbbR^1 + mboxrow_dim times mboxcolumn_dim  t ge sum_i sigma_i(X) X mbox is a matrix with row_dim rows and column_dim columns ","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"Some of these cones can take two forms: XXXConeTriangle and XXXConeSquare.","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"In XXXConeTriangle sets, the matrix is assumed to be symmetric, and the elements are provided by a vector, in which the entries of the upper-right triangular part of the matrix are given column by column (or equivalently, the entries of the lower-left triangular part are given row by row).","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"In XXXConeSquare sets, the entries of the matrix are given column by column (or equivalently, row by row), and the matrix is constrained to be symmetric. As an example, given a 2-by-2 matrix of variables X and a one-dimensional variable t, we can specify a root-det constraint as [t, X11, X12, X22] ∈ RootDetConeTriangle or [t, X11, X12, X21, X22] ∈ RootDetConeSquare.","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"We provide both forms to enable flexibility for solvers who may natively support one or the other. Transformations between XXXConeTriangle and XXXConeSquare are handled by bridges, which removes the chance of conversion mistakes by users or solver developers.","category":"page"},{"location":"moi/manual/standard_form/#Multi-dimensional-sets-with-combinatorial-structure","page":"Standard form problem","title":"Multi-dimensional sets with combinatorial structure","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"SOS1(weights): A special ordered set of Type I.\nSOS2(weights): A special ordered set of Type II.\nIndicator(set): A set to specify indicator constraints.\nComplements(dimension): A set for mixed complementarity constraints.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/linear/factory_schedule.jl\"","category":"page"},{"location":"tutorials/linear/factory_schedule/#The-factory-schedule-example","page":"The factory schedule example","title":"The factory schedule example","text":"","category":"section"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"This is a Julia translation of part 5 from \"Introduction to Linear Programming with Python\" available at https://github.com/benalexkeen/Introduction-to-linear-programming","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"For 2 factories (A, B), minimize the cost of production over the course of 12 months while meeting monthly demand. Factory B has a planned outage during month 5.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"It was originally contributed by @Crghilardi.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_factory_schedule()\n    # Sets in the problem:\n    months, factories = 1:12, [:A, :B]\n    # This function takes a matrix and converts it to a JuMP container so we can\n    # refer to elements such as `d_max_cap[1, :A]`.\n    containerize(A::Matrix) = Containers.DenseAxisArray(A, months, factories)\n    # Maximum production capacity in (month, factory) [units/month]:\n    d_max_cap = containerize(\n        [\n            100000 50000\n            110000 55000\n            120000 60000\n            145000 100000\n            160000 0\n            140000 70000\n            155000 60000\n            200000 100000\n            210000 100000\n            197000 100000\n            80000 120000\n            150000 150000\n        ],\n    )\n    # Minimum production capacity in (month, factory) [units/month]:\n    d_min_cap = containerize(\n        [\n            20000 20000\n            20000 20000\n            20000 20000\n            20000 20000\n            20000 0\n            20000 20000\n            20000 20000\n            20000 20000\n            20000 20000\n            20000 20000\n            20000 20000\n            20000 20000\n        ],\n    )\n    # Variable cost of production in (month, factory) [$/unit]:\n    d_var_cost = containerize([\n        10 5\n        11 4\n        12 3\n        9 5\n        8 0\n        8 6\n        5 4\n        7 6\n        9 8\n        10 11\n        8 10\n        8 12\n    ])\n    # Fixed cost of production in (month, factory) # [$/month]:\n    d_fixed_cost = containerize(\n        [\n            500 600\n            500 600\n            500 600\n            500 600\n            500 0\n            500 600\n            500 600\n            500 600\n            500 600\n            500 600\n            500 600\n            500 600\n        ],\n    )\n    # Demand in each month [units/month]:\n    d_demand = [\n        120_000,\n        100_000,\n        130_000,\n        130_000,\n        140_000,\n        130_000,\n        150_000,\n        170_000,\n        200_000,\n        190_000,\n        140_000,\n        100_000,\n    ]\n    # The model!\n    model = Model(GLPK.Optimizer)\n    # Decision variables\n    @variables(model, begin\n        status[m in months, f in factories], Bin\n        production[m in months, f in factories], Int\n    end)\n    # The production cannot be less than minimum capacity.\n    @constraint(\n        model,\n        [m in months, f in factories],\n        production[m, f] >= d_min_cap[m, f] * status[m, f],\n    )\n    # The production cannot be more that maximum capacity.\n    @constraint(\n        model,\n        [m in months, f in factories],\n        production[m, f] <= d_max_cap[m, f] * status[m, f],\n    )\n    # The production must equal demand in a given month.\n    @constraint(model, [m in months], sum(production[m, :]) == d_demand[m])\n    # Factory B is shut down during month 5, so production and status are both\n    # zero.\n    fix(status[5, :B], 0.0)\n    fix(production[5, :B], 0.0)\n    # The objective is to minimize the cost of production across all time\n    ##periods.\n    @objective(\n        model,\n        Min,\n        sum(\n            d_fixed_cost[m, f] * status[m, f] +\n            d_var_cost[m, f] * production[m, f] for m in months, f in factories\n        )\n    )\n    # Optimize the problem\n    optimize!(model)\n    # Check the solution!\n    Test.@testset \"Check the solution against known optimal\" begin\n        Test.@test termination_status(model) == OPTIMAL\n        Test.@test objective_value(model) == 12_906_400.0\n        Test.@test value.(production)[1, :A] == 70_000\n        Test.@test value.(status)[1, :A] == 1\n        Test.@test value.(status)[5, :B] == 0\n        Test.@test value.(production)[5, :B] == 0\n    end\n    println(\"The production schedule is:\")\n    println(value.(production))\n    return\nend\n\nexample_factory_schedule()","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"moi/reference/variables/","page":"Variables","title":"Variables","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"moi/reference/variables/#Functions","page":"Variables","title":"Functions","text":"","category":"section"},{"location":"moi/reference/variables/","page":"Variables","title":"Variables","text":"add_variable\nadd_variables\nadd_constrained_variable\nadd_constrained_variables\nsupports_add_constrained_variable\nsupports_add_constrained_variables\nis_valid(::ModelLike,::VariableIndex)\ndelete(::ModelLike, ::VariableIndex)\ndelete(::ModelLike, ::Vector{VariableIndex})","category":"page"},{"location":"moi/reference/variables/#MathOptInterface.add_variable","page":"Variables","title":"MathOptInterface.add_variable","text":"add_variable(model::ModelLike)::VariableIndex\n\nAdd a scalar variable to the model, returning a variable index.\n\nA AddVariableNotAllowed error is thrown if adding variables cannot be done in the current state of the model model.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.add_variables","page":"Variables","title":"MathOptInterface.add_variables","text":"add_variables(model::ModelLike, n::Int)::Vector{VariableIndex}\n\nAdd n scalar variables to the model, returning a vector of variable indices.\n\nA AddVariableNotAllowed error is thrown if adding variables cannot be done in the current state of the model model.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.add_constrained_variable","page":"Variables","title":"MathOptInterface.add_constrained_variable","text":"add_constrained_variable(\n    model::ModelLike,\n    set::AbstractScalarSet\n)::Tuple{MOI.VariableIndex,\n         MOI.ConstraintIndex{MOI.VariableIndex, typeof(set)}}\n\nAdd to model a scalar variable constrained to belong to set, returning the index of the variable created and the index of the constraint constraining the variable to belong to set.\n\nBy default, this function falls back to creating a free variable with add_variable and then constraining it to belong to set with add_constraint.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.add_constrained_variables","page":"Variables","title":"MathOptInterface.add_constrained_variables","text":"add_constrained_variables(\n    model::ModelLike,\n    sets::AbstractVector{<:AbstractScalarSet}\n)::Tuple{\n    Vector{MOI.VariableIndex},\n    Vector{MOI.ConstraintIndex{MOI.VariableIndex,eltype(sets)}},\n}\n\nAdd to model scalar variables constrained to belong to sets, returning the indices of the variables created and the indices of the constraints constraining the variables to belong to each set in sets. That is, if it returns variables and constraints, constraints[i] is the index of the constraint constraining variable[i] to belong to sets[i].\n\nBy default, this function falls back to calling add_constrained_variable on each set.\n\n\n\n\n\nadd_constrained_variables(\n    model::ModelLike,\n    set::AbstractVectorSet,\n)::Tuple{\n    Vector{MOI.VariableIndex},\n    MOI.ConstraintIndex{MOI.VectorOfVariables,typeof(set)},\n}\n\nAdd to model a vector of variables constrained to belong to set, returning the indices of the variables created and the index of the constraint constraining the vector of variables to belong to set.\n\nBy default, this function falls back to creating free variables with add_variables and then constraining it to belong to set with add_constraint.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.supports_add_constrained_variable","page":"Variables","title":"MathOptInterface.supports_add_constrained_variable","text":"supports_add_constrained_variable(\n    model::ModelLike,\n    S::Type{<:AbstractScalarSet}\n)::Bool\n\nReturn a Bool indicating whether model supports constraining a variable to belong to a set of type S either on creation of the variable with add_constrained_variable or after the variable is created with add_constraint.\n\nBy default, this function falls back to supports_add_constrained_variables(model, Reals) && supports_constraint(model, MOI.VariableIndex, S) which is the correct definition for most models.\n\nExample\n\nSuppose that a solver supports only two kind of variables: binary variables and continuous variables with a lower bound. If the solver decides not to support VariableIndex-in-Binary and VariableIndex-in-GreaterThan constraints, it only has to implement add_constrained_variable for these two sets which prevents the user to add both a binary constraint and a lower bound on the same variable. Moreover, if the user adds a VariableIndex-in-GreaterThan constraint, implementing this interface (i.e., supports_add_constrained_variables) enables the constraint to be transparently bridged into a supported constraint.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.supports_add_constrained_variables","page":"Variables","title":"MathOptInterface.supports_add_constrained_variables","text":"supports_add_constrained_variables(\n    model::ModelLike,\n    S::Type{<:AbstractVectorSet}\n)::Bool\n\nReturn a Bool indicating whether model supports constraining a vector of variables to belong to a set of type S either on creation of the vector of variables with add_constrained_variables or after the variable is created with add_constraint.\n\nBy default, if S is Reals then this function returns true and otherwise, it falls back to supports_add_constrained_variables(model, Reals) && supports_constraint(model, MOI.VectorOfVariables, S) which is the correct definition for most models.\n\nExample\n\nIn the standard conic form (see Duality), the variables are grouped into several cones and the constraints are affine equality constraints. If Reals is not one of the cones supported by the solvers then it needs to implement supports_add_constrained_variables(::Optimizer, ::Type{Reals}) = false as free variables are not supported. The solvers should then implement supports_add_constrained_variables(::Optimizer, ::Type{<:SupportedCones}) = true where SupportedCones is the union of all cone types that are supported; it does not have to implement the method supports_constraint(::Type{VectorOfVariables}, Type{<:SupportedCones}) as it should return false and it's the default. This prevents the user to constrain the same variable in two different cones. When a VectorOfVariables-in-S is added, the variables of the vector have already been created so they already belong to given cones. If bridges are enabled, the constraint will therefore be bridged by adding slack variables in S and equality constraints ensuring that the slack variables are equal to the corresponding variables of the given constraint function.\n\nNote that there may also be sets for which !supports_add_constrained_variables(model, S) and supports_constraint(model, MOI.VectorOfVariables, S). For instance, suppose a solver supports positive semidefinite variable constraints and two types of variables: binary variables and nonnegative variables. Then the solver should support adding VectorOfVariables-in-PositiveSemidefiniteConeTriangle constraints, but it should not support creating variables constrained to belong to the PositiveSemidefiniteConeTriangle because the variables in PositiveSemidefiniteConeTriangle should first be created as either binary or non-negative.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.is_valid-Tuple{MathOptInterface.ModelLike, MathOptInterface.VariableIndex}","page":"Variables","title":"MathOptInterface.is_valid","text":"is_valid(model::ModelLike, index::Index)::Bool\n\nReturn a Bool indicating whether this index refers to a valid object in the model model.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/variables/#MathOptInterface.delete-Tuple{MathOptInterface.ModelLike, MathOptInterface.VariableIndex}","page":"Variables","title":"MathOptInterface.delete","text":"delete(model::ModelLike, index::Index)\n\nDelete the referenced object from the model. Throw DeleteNotAllowed if if index cannot be deleted.\n\nThe following modifications also take effect if Index is VariableIndex:\n\nIf index used in the objective function, it is removed from the function, i.e., it is substituted for zero.\nFor each func-in-set constraint of the model:\nIf func isa VariableIndex and func == index then the constraint is deleted.\nIf func isa VectorOfVariables and index in func.variables then\nif length(func.variables) == 1 is one, the constraint is deleted;\nif length(func.variables) > 1 and supports_dimension_update(set) then then the variable is removed from func and set is replaced by update_dimension(set, MOI.dimension(set) - 1).\nOtherwise, a DeleteNotAllowed error is thrown.\nOtherwise, the variable is removed from func, i.e., it is substituted for zero.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/variables/#MathOptInterface.delete-Tuple{MathOptInterface.ModelLike, Vector{MathOptInterface.VariableIndex}}","page":"Variables","title":"MathOptInterface.delete","text":"delete(model::ModelLike, indices::Vector{R<:Index}) where {R}\n\nDelete the referenced objects in the vector indices from the model. It may be assumed that R is a concrete type. The default fallback sequentially deletes the individual items in indices, although specialized implementations may be more efficient.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/variables/#Attributes","page":"Variables","title":"Attributes","text":"","category":"section"},{"location":"moi/reference/variables/","page":"Variables","title":"Variables","text":"AbstractVariableAttribute\nVariableName\nVariablePrimalStart\nVariablePrimal\nVariableBasisStatus","category":"page"},{"location":"moi/reference/variables/#MathOptInterface.AbstractVariableAttribute","page":"Variables","title":"MathOptInterface.AbstractVariableAttribute","text":"AbstractVariableAttribute\n\nAbstract supertype for attribute objects that can be used to set or get attributes (properties) of variables in the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/variables/#MathOptInterface.VariableName","page":"Variables","title":"MathOptInterface.VariableName","text":"VariableName()\n\nA variable attribute for a string identifying the variable. It is valid for two variables to have the same name; however, variables with duplicate names cannot be looked up using get. It has a default value of \"\" if not set`.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/variables/#MathOptInterface.VariablePrimalStart","page":"Variables","title":"MathOptInterface.VariablePrimalStart","text":"VariablePrimalStart()\n\nA variable attribute for the initial assignment to some primal variable's value that the optimizer may use to warm-start the solve. May be a number or nothing (unset).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/variables/#MathOptInterface.VariablePrimal","page":"Variables","title":"MathOptInterface.VariablePrimal","text":"VariablePrimal(result_index::Int = 1)\n\nA variable attribute for the assignment to some primal variable's value in result result_index. If result_index is omitted, it is 1 by default.\n\nIf the solver does not have a primal value for the variable because the result_index is beyond the available solutions (whose number is indicated by the ResultCount attribute), getting this attribute must throw a ResultIndexBoundsError. Otherwise, if the result is unavailable for another reason (for instance, only a dual solution is available), the result is undefined. Users should first check PrimalStatus before accessing the VariablePrimal attribute.\n\nSee ResultCount for information on how the results are ordered.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/variables/#MathOptInterface.VariableBasisStatus","page":"Variables","title":"MathOptInterface.VariableBasisStatus","text":"VariableBasisStatus(result_index::Int = 1)\n\nA variable attribute for the BasisStatusCode of a variable in result result_index, with respect to an available optimal solution basis.\n\nIf the solver does not have a basis statue for the variable because the result_index is beyond the available solutions (whose number is indicated by the ResultCount attribute), getting this attribute must throw a ResultIndexBoundsError. Otherwise, if the result is unavailable for another reason (for instance, only a dual solution is available), the result is undefined. Users should first check PrimalStatus before accessing the VariableBasisStatus attribute.\n\nSee ResultCount for information on how the results are ordered.\n\n\n\n\n\n","category":"type"},{"location":"reference/callbacks/#CallbackAPI","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"More information can be found in the Callbacks section of the manual.","category":"page"},{"location":"reference/callbacks/#Macros","page":"Callbacks","title":"Macros","text":"","category":"section"},{"location":"reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"@build_constraint","category":"page"},{"location":"reference/callbacks/#JuMP.@build_constraint","page":"Callbacks","title":"JuMP.@build_constraint","text":"@build_constraint(constraint_expr)\n\nConstructs a ScalarConstraint or VectorConstraint using the same machinery as @constraint but without adding the constraint to a model.\n\nConstraints using broadcast operators like x .<= 1 are also supported and will create arrays of ScalarConstraint or VectorConstraint.\n\nExamples\n\nmodel = Model();\n@variable(model, x);\n@build_constraint(2x >= 1)\n\n# output\nScalarConstraint{GenericAffExpr{Float64,VariableRef},MathOptInterface.GreaterThan{Float64}}(2 x, MathOptInterface.GreaterThan{Float64}(1.0))\n\n\n\n\n\n","category":"macro"},{"location":"reference/callbacks/#Callback-variable-primal","page":"Callbacks","title":"Callback variable primal","text":"","category":"section"},{"location":"reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"callback_value","category":"page"},{"location":"reference/callbacks/#JuMP.callback_value","page":"Callbacks","title":"JuMP.callback_value","text":"callback_value(cb_data, x::VariableRef)\n\nReturn the primal solution of a variable inside a callback.\n\ncb_data is the argument to the callback function, and the type is dependent on the solver.\n\n\n\n\n\ncallback_value(cb_data, expr::Union{GenericAffExpr, GenericQuadExpr})\n\nReturn the primal solution of an affine or quadratic expression inside a callback by getting the value for each variable appearing in the expression.\n\ncb_data is the argument to the callback function, and the type is dependent on the solver.\n\n\n\n\n\n","category":"function"},{"location":"reference/callbacks/#Callback-node-status","page":"Callbacks","title":"Callback node status","text":"","category":"section"},{"location":"reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"callback_node_status","category":"page"},{"location":"reference/callbacks/#JuMP.callback_node_status","page":"Callbacks","title":"JuMP.callback_node_status","text":"callback_node_status(cb_data, model::Model)\n\nReturn an MOI.CallbackNodeStatusCode enum, indicating if the current primal solution available from callback_value is integer feasible.\n\n\n\n\n\n","category":"function"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/background/infeasibility_certificates/#Infeasibility-certificates","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"","category":"section"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"When given a conic problem that is infeasible or unbounded, some solvers can produce a certificate of infeasibility. This page explains what a certificate of infeasibility is, and the related conventions that MathOptInterface adopts.","category":"page"},{"location":"moi/background/infeasibility_certificates/#Conic-duality","page":"Infeasibility certificates","title":"Conic duality","text":"","category":"section"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"MathOptInterface uses conic duality to define infeasibility certificates. A full explanation is given in the section Duality, but here is a brief overview.","category":"page"},{"location":"moi/background/infeasibility_certificates/#Minimization-problems","page":"Infeasibility certificates","title":"Minimization problems","text":"","category":"section"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"For a minimization problem in geometric conic form, the primal is:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"beginalign\n min_x in mathbbR^n  a_0^top x + b_0\n\n textst  A_i x + b_i  in mathcalC_i  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"and the dual is a maximization problem in standard conic form:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"beginalign\n max_y_1 ldots y_m  -sum_i=1^m b_i^top y_i + b_0\n\n textst  a_0 - sum_i=1^m A_i^top y_i  = 0\n\n  y_i  in mathcalC_i^*  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"where each mathcalC_i is a closed convex cone and mathcalC_i^* is its dual cone.","category":"page"},{"location":"moi/background/infeasibility_certificates/#Maximization-problems","page":"Infeasibility certificates","title":"Maximization problems","text":"","category":"section"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"For a maximization problem in geometric conic form, the primal is:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"beginalign\n max_x in mathbbR^n  a_0^top x + b_0\n\n textst  A_i x + b_i  in mathcalC_i  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"and the dual is a minimization problem in standard conic form:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"beginalign\n min_y_1 ldots y_m  sum_i=1^m b_i^top y_i + b_0\n\n textst  a_0 + sum_i=1^m A_i^top y_i  = 0\n\n  y_i  in mathcalC_i^*  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/infeasibility_certificates/#Unbounded-problems","page":"Infeasibility certificates","title":"Unbounded problems","text":"","category":"section"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"A problem is unbounded if and only if:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"there exists a feasible primal solution\nthe dual is infeasible.","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"A feasible primal solution—if one exists—can be obtained by setting ObjectiveSense to FEASIBILITY_SENSE before optimizing. Therefore, most solvers terminate after they prove the dual is infeasible via a certificate of dual infeasibility, but before they have found a feasible primal solution. This is also the reason that MathOptInterface defines the DUAL_INFEASIBLE status instead of UNBOUNDED.","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"A certificate of dual infeasibility is an improving ray of the primal problem. That is, there exists some vector d such that for all eta  0:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"A_i (x + eta d) + b_i in mathcalC_i  i = 1 ldots m","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"and (for minimization problems):","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"a_0^top (x + eta d) + b_0  a_0^top x + b_0","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"for any feasible point x. The latter simplifies to a_0^top d  0. For maximization problems, the inequality is reversed, so that a_0^top d  0.","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"If the solver has found a certificate of dual infeasibility:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"TerminationStatus must be DUAL_INFEASIBLE\nPrimalStatus must be INFEASIBILITY_CERTIFICATE\nVariablePrimal must be the corresponding value of d\nConstraintPrimal must be the corresponding value of A_i d\nObjectiveValue must be the value a_0^top d. Note that this is the value of the objective function at d, ignoring the constant b_0.","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"note: Note\nThe choice of whether to scale the ray d to have magnitude 1 is left to the solver.","category":"page"},{"location":"moi/background/infeasibility_certificates/#Infeasible-problems","page":"Infeasibility certificates","title":"Infeasible problems","text":"","category":"section"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"A certificate of primal infeasibility is an improving ray of the dual problem. However, because infeasibility is independent of the objective function, we first homogenize the primal problem by removing its objective.","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"For a minimization problem, a dual improving ray is some vector d such that for all eta  0:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"beginalign\n-sum_i=1^m A_i^top (y_i + eta d_i)  = 0 \n(y_i + eta d_i)  in mathcalC_i^*  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"and:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"-sum_i=1^m b_i^top (y_i + eta d_i)  -sum_i=1^m b_i^top y_i","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"for any feasible dual solution y. The latter simplifies to -sum_i=1^m b_i^top d_i  0. For a maximization problem, the inequality is sum_i=1^m b_i^top d_i  0. (Note that these are the same inequality, modulo a - sign.)","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"If the solver has found a certificate of primal infeasibility:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"TerminationStatus must be INFEASIBLE\nDualStatus must be INFEASIBILITY_CERTIFICATE\nConstraintDual must be the corresponding value of d\nDualObjectiveValue must be the value -sum_i=1^m b_i^top d_i for minimization problems and sum_i=1^m b_i^top d_i for maximization problems.","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"note: Note\nThe choice of whether to scale the ray d to have magnitude 1 is left to the solver.","category":"page"},{"location":"moi/background/infeasibility_certificates/#Infeasibility-certificates-of-variable-bounds","page":"Infeasibility certificates","title":"Infeasibility certificates of variable bounds","text":"","category":"section"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"Many linear solvers (e.g., Gurobi) do not provide explicit access to the primal infeasibility certificate of a variable bound. However, given a set of linear constraints:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"beginalign\nl_A le A x le u_A \nl_x le x le u_x\nendalign","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"the primal certificate of the variable bounds can be computed using the primal certificate associated with the affine constraints, d. (Note that d will have one element for each row of the A matrix, and that some or all of the elements in the vectors l_A and u_A may be pm infty. If both l_A and u_A are finite for some row, the corresponding element in `d  must be 0.)","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"Given d, compute bard = d^top A. If the bound is finite, a certificate for the lower variable bound of x_i is maxbard_i 0, and a certificate for the upper variable bound is minbard_i 0.","category":"page"},{"location":"release_notes/#Release-notes","page":"Release notes","title":"Release notes","text":"","category":"section"},{"location":"release_notes/#Version-0.22.2-(January-10,-2021)","page":"Release notes","title":"Version 0.22.2 (January 10, 2021)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"New features:\nThe function all_nl_constraints now returns all nonlinear constraints in a model\nstart_value and set_start_value can now be used to get and set the primal start for constraint references\nPlural macros now return a tuple containing the elements that were defined instead of nothing\nAnonymous variables are now printed as _[i] where i is the index of the variable instead of noname. Calling name(x) still returns \"\" so this is non-breaking.\nBug fixes:\nFixed handling of min and max in nonlinear expressions\nCartesianIndex is no longer allowed as a key for DenseAxisArrays.\nDocumentation, maintenance:\nImproved the performance of GenericAffExpr\nAdded a tutorial on the Travelling Salesperson Problem\nAdded a tutorial on querying the Hessian of a nonlinear program\nAdded documentation on using custom solver binaries.","category":"page"},{"location":"release_notes/#Version-0.22.1-(November-29,-2021)","page":"Release notes","title":"Version 0.22.1 (November 29, 2021)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"New features:\nExport OptimizationSense enum, with instances: MIN_SENSE, MAX_SENSE,  and FEASIBILITY_SENSE\nAdd Base.isempty(::Model) to match Base.empty(::Model)\nBug fixes:\nFix bug in container with tuples as indices\nFix bug in set_time_limit_sec\nDocumentation, maintenance\nAdd tutorial \"Design patterns for larger models\"\nRemove release notes section from PDF\nGeneral edits of the documentation and error messages","category":"page"},{"location":"release_notes/#Version-0.22.0-(November-10,-2021)","page":"Release notes","title":"Version 0.22.0 (November 10, 2021)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"JuMP v0.22 is a breaking release","category":"page"},{"location":"release_notes/#Breaking-changes","page":"Release notes","title":"Breaking changes","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"JuMP 0.22 contains a number of breaking changes. However, these should be invisible for the majority of users. You will mostly encounter these breaking changes if you: wrote a JuMP extension, accessed backend(model), or called  @SDconstraint.","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The breaking changes are as follows:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"MathOptInterface has been updated to v0.10.4. For users who have interacted with the MOI backend, this contains a large number of breaking changes. Read the MathOptInterface release notes for more details.\nThe bridge_constraints keyword argument to Model and set_optimizer has been renamed add_bridges to reflect that more thing were bridged than just constraints.\nThe backend(model) field now contains a concrete instance of a MOI.Utilities.CachingOptimizer instead of one with an abstractly typed optimizer field. In most cases, this will lead to improved performance. However, calling set_optimizer after backend invalidates the old backend. For example:\nmodel = Model()\nb = backend(model)\nset_optimizer(model, GLPK.Optimizer)\n@variable(model, x)\n# b is not updated with `x`! Get a new b by calling `backend` again.\nnew_b = backend(model)\nAll usages of @SDconstraint are deprecated. The new syntax is @constraint(model, X >= Y, PSDCone()).\nCreating a DenseAxisArray with a Number as an axis will now display a warning. This catches a common error in which users write @variable(model, x[length(S)]) instead of @variable(model, x[1:length(S)]).\nThe caching_mode argument to Model, e.g., Model(caching_mode = MOIU.MANUAL) mode has been removed. For more control over the optimizer, use direct_model instead.\nThe previously deprecated lp_objective_perturbation_range and lp_rhs_perturbation_range functions have been removed. Use lp_sensitivity_report instead.\nThe .m fields of NonlinearExpression and NonlinearParameter have been renamed to .model.\nInfinite variable bounds are now ignored. Thus, @variable(model, x <= Inf) will show has_upper_bound(x) == false. Previously, these bounds were passed through to the solvers which caused numerical issues for solvers expecting finite bounds.\nThe variable_type and constraint_type functions were removed. This should only affect users who previously wrote JuMP extensions. The functions can be deleted without consequence.\nThe internal functions moi_mode, moi_bridge_constraints, moi_add_constraint, and moi_add_to_function_constant are no longer exported.\nThe un-used method Containers.generate_container has been deleted.\nThe Containers API has been refactored, and _build_ref_sets is now public as Containers.build_ref_sets.\nThe parse_constraint_ methods for extending @constraint at parse time have been refactored in a breaking way. Consult the Extensions documentation for more details and examples.","category":"page"},{"location":"release_notes/#New-features","page":"Release notes","title":"New features","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The TerminationStatusCode and ResultStatusCode enums are now exported by JuMP. Prefer termination_status(model) == OPTIMAL instead of == MOI.OPTIMAL, although the MOI. prefix way still works.\nCopy a x::DenseAxisArray to an Array by calling Array(x).\nNonlinearExpression is now a subtype of AbstractJuMPScalar\nConstraints such as @constraint(model, x + 1 in MOI.Integer()) are now supported.\nprimal_feasibility_report now accepts a function as the first argument.\nScalar variables @variable(model, x[1:2] in MOI.Integer()) creates two variables, both of which are constrained to be in the set MOI.Integer.\nConic constraints can now be specified as inequalities under a different partial ordering. So @constraint(model, x - y in MOI.Nonnegatives()) can now be written as @constraint(model, x >= y, MOI.Nonnegatives()).\nNames are now set for vectorized constraints.","category":"page"},{"location":"release_notes/#Documentation,-maintenance-and-performance","page":"Release notes","title":"Documentation, maintenance and performance","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The documentation is now available as a PDF.\nThe documentation now includes a full copy of the MathOptInterface documentation to make it easy to link concepts between the docs. (The MathOptInterface documentation has also been significantly improved.)\nThe documentation contains a large number of improvements and clarifications on a range of topics. Thanks to @sshin23, @DilumAluthge, and @jlwether.\nThe documentation is now built with Julia 1.6 instead of 1.0.\nVarious error messages have been improved to be more readable.\nFixed a performance issue when show was called on a SparseAxisArray with a large number of elements.\nFixed a bug displaying barrier and simplex iterations in solution_summary.\nFixed a bug by implementing hash for DenseAxisArray and SparseAxisArray.\nNames are now only set if the solver supports them. Previously, this prevented solvers such as Ipopt from being used with direct_model.\nMutableArithmetics.Zero is converted into a 0.0 before being returned to the user. Previously, some calls to @expression would return the undocumented MutableArithmetics.Zero() object. One example is summing over an empty set @expression(model, sum(x[i] for i in 1:0)). You will now get 0.0 instead.\nAffExpr and QuadExpr can now be used with == 0 instead of iszero. This fixes a number of issues relating to Julia standard libraries such as LinearAlgebra and SparseArrays.\nFixed a bug when registering a user-defined function with splatting.","category":"page"},{"location":"release_notes/#Version-0.21.10-(September-4,-2021)","page":"Release notes","title":"Version 0.21.10 (September 4, 2021)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes. A summary of changes are as follows:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"New features:\nAdd add_NL_expression\nadd_NL_xxx functions now support AffExpr and QuadExpr as terms\nDocumentation, maintenance and performance:\nFix bug in solution_summary\nFix bug in relax_integrality\nImprove error message in lp_sensitivity_report","category":"page"},{"location":"release_notes/#Version-0.21.9-(August-1,-2021)","page":"Release notes","title":"Version 0.21.9 (August 1, 2021)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes. A summary of changes are as follows:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"New features:\nContainers now support arbitrary container types by passing the type to the container keyword and overloading Containers.container.\nis_valid now supports nonlinear constraints\nAdded unsafe_backend for querying the inner-most optimizer of a JuMP model.\nNonlinear parameters now support the plural @NLparameters macro.\nContainers (e.g., DenseAxisArray) can now be used in vector-valued constraints.\nDocumentation, maintenance and performance:\nVarious improvements to the documentation.","category":"page"},{"location":"release_notes/#Version-0.21.8-(May-8,-2021)","page":"Release notes","title":"Version 0.21.8 (May 8, 2021)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes. A summary of changes are as follows:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"New features:\nThe @constraint macro is now extendable in the same way as @variable.\nAffExpr and QuadExpr can now be used in nonlinear macros.\nBug fixes:\nFixed a bug in lp_sensitivity_report.\nFixed an inference issue when creating empty SparseAxisArrays.","category":"page"},{"location":"release_notes/#Version-0.21.7-(April-12,-2021)","page":"Release notes","title":"Version 0.21.7 (April 12, 2021)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes. A summary of changes are as follows:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"New features:\nAdded primal_feasibility_report, which can be used to check whether a primal point satisfies primal feasibility.\nAdded coefficient, which returns the coefficient associated with a variable in affine and quadratic expressions.\nAdded copy_conflict, which returns the IIS of an infeasible model.\nAdded solution_summary, which returns (and prints) a struct containing a summary of the solution.\nAllow AbstractVector in vector constraints instead of just Vector.\nAdded latex_formulation(model) which returns an object representing the latex formulation of a model. Use print(latex_formulation(model)) to print the formulation as a string.\nUser-defined functions in nonlinear expressions are now automatically registered to aid quick model prototyping. However, a warning is printed to encourage the manual registration.\nDenseAxisArray's now support broadcasting over multiple arrays.\nContainer indices can now be iterators of Base.SizeUnknown.\nBug fixes:\nFixed bug in rad2deg and deg2rad in nonlinear expressions.\nFixed a MethodError bug in Containers when forcing container type.\nAllow partial slicing of a DenseAxisArray, resolving an issue from 2014!\nFixed a bug printing variable names in IJulia.\nEnding an IJulia cell with model now prints a summary of the model (like in the REPL) not the latex formulation. Use print(model) to print the latex formulation.\nFixed a bug when copying models containing nested arrays.\nDocumentation, performance improvements, and general maintenance:\nTutorials are now part of the documentation, and more refactoring has taken place.\nAdded JuliaFormatter added as a code formatter.\nAdded some precompilation statements to reduce initial latency.\nVarious improvements to error messages to make them more helpful.\nImproved performance of value(::NonlinearExpression).\nImproved performance of fix(::VariableRef).","category":"page"},{"location":"release_notes/#Version-0.21.6-(January-29,-2021)","page":"Release notes","title":"Version 0.21.6 (January 29, 2021)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes. A summary of changes are as follows:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"New features:\nAdded support for skew symmetric variables via @variable(model, X[1:2, 1:2] in SkewSymmetricMatrixSpace()).\nlp_sensitivity_report has been added which significantly improves the performance of querying the sensitivity summary of an LP. lp_objective_perturbation_range and lp_rhs_perturbation_range are deprecated.\nDual warm-starts are now supported with set_dual_start_value and dual_start_value.\n∈ (\\in<tab>) can now be used in macros instead of = or in.\nUse haskey(model::Model, key::Symbol) to check if a name key is registered in a model.\nAdded unregister(model::Model, key::Symbol) to unregister a name key from model.\nAdded callback_node_status for use in callbacks.\nAdded print_bridge_graph to visualize the bridging graph generated by MathOptInterface.\nImproved error message for containers with duplicate indices.\nBug fixes:\nVarious fixes to pass tests on Julia 1.6.\nFixed a bug in the printing of nonlinear expressions in IJulia.\nFixed a bug when nonlinear expressions are passed to user-defined functions.\nSome internal functions that were previously exported are now no longer exported.\nFixed a bug when relaxing a fixed binary variable.\nFixed a StackOverflowError that occurred when SparseAxisArrays had a large number of elements.\nRemoved an unnecessary type assertion in list_of_constraint_types.\nFixed a bug when copying models with registered expressions.\nDocumentation and general maintenance:\nThe documentation has been significantly overhauled. It now has distinct sections for the manual, API reference, and examples. The existing examples in /examples have now been moved to /docs/src/examples and rewritten using Literate.jl, and they are now included in the documentation.\nJuliaFormatter has been applied to most of the codebase. This will continue to roll out over time, as we fix upstream issues in the formatter, and will eventually become compulsory.\nThe root cause of a large number of method invalidations has been resolved.\nWe switched continuous integration from Travis and Appveyor to GitHub Actions.","category":"page"},{"location":"release_notes/#Version-0.21.5-(September-18,-2020)","page":"Release notes","title":"Version 0.21.5 (September 18, 2020)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes. A summary of changes are as follows:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix deprecation warnings\nThrow DimensionMismatch for incompatibly sized functions and sets\nUnify treatment of keys(x) on JuMP containers","category":"page"},{"location":"release_notes/#Version-0.21.4-(September-14,-2020)","page":"Release notes","title":"Version 0.21.4 (September 14, 2020)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes. A summary of changes are as follows:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"New features:\nAdd debug info when adding unsupported constraints\nAdd relax_integrality for solving continuous relaxation\nAllow querying constraint conflicts\nBug fixes:\nDispatch on Real for MOI.submit\nImplement copy for CustomSet in tests\nDon't export private macros\nFix invalid assertion in nonlinear\nError if constraint has NaN right-hand side\nImprove speed of tests\nLots of work modularizing files in /test\nImprove line numbers in macro error messages\nPrint nonlinear subexpressions\nVarious documentation updates\nDependency updates:\nDatastructures 0.18\nMathOptFormat v0.5\nPrep for MathOptInterface 0.9.15","category":"page"},{"location":"release_notes/#Version-0.21.3-(June-18,-2020)","page":"Release notes","title":"Version 0.21.3 (June 18, 2020)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added Special Order Sets (SOS1 and SOS2) to JuMP with default weights to ease the creation of such constraints (#2212).\nAdded functions simplex_iterations, barrier_iterations and node_count (#2201).\nAdded function reduced_cost (#2205).\nImplemented callback_value for affine and quadratic expressions (#2231).\nSupport MutableArithmetics.Zero in objective and constraints (#2219).\nDocumentation improvements:\nMention tutorials in the docs (#2223).\nUpdate COIN-OR links (#2242).\nExplicit link to the documentation of MOI.FileFormats (#2253).\nTypo fixes (#2261).\nContainers improvements:\nFix Base.map for DenseAxisArray (#2235).\nThrow BoundsError if number of indices is incorrect for DenseAxisArray and SparseAxisArray (#2240).\nExtensibility improvements:\nImplement a set_objective method fallback that redirects to set_objective_sense and set_objective_function (#2247).\nAdd parse_constraint method with arbitrary number of arguments (#2051).\nAdd parse_constraint_expr and parse_constraint_head (#2228).","category":"page"},{"location":"release_notes/#Version-0.21.2-(April-2,-2020)","page":"Release notes","title":"Version 0.21.2 (April 2, 2020)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added relative_gap() to access MOI.RelativeGap() attribute (#2199).\nDocumentation fixes:\nAdded link to source for docstrings in the documentation (#2207).\nAdded docstring for @variables macro (#2216).\nTypo fixes (#2177, #2184, #2182).\nImplementation of methods for Base functions:\nImplemented Base.empty! for JuMP.Model (#2198).\nImplemented Base.conj for JuMP scalar types (#2209).\nBug fixes:\nFixed sum of expression with scalar product in macro (#2178).\nFixed writing of nonlinear models to MathOptFormat (#2181).\nFixed construction of empty SparseAxisArray (#2179).\nFixed constraint with zero function (#2188).","category":"page"},{"location":"release_notes/#Version-0.21.1-(Feb-18,-2020)","page":"Release notes","title":"Version 0.21.1 (Feb 18, 2020)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Improved the clarity of the with_optimizer deprecation warning.","category":"page"},{"location":"release_notes/#Version-0.21-(Feb-16,-2020)","page":"Release notes","title":"Version 0.21 (Feb 16, 2020)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Breaking changes:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Deprecated with_optimizer (#2090, #2084, #2141). You can replace with_optimizer by either nothing, optimizer_with_attributes or a closure:\nreplace with_optimizer(Ipopt.Optimizer) by Ipopt.Optimizer.\nreplace with_optimizer(Ipopt.Optimizer, max_cpu_time=60.0) by optimizer_with_attributes(Ipopt.Optimizer, \"max_cpu_time\" => 60.0).\nreplace with_optimizer(Gurobi.Optimizer, env) by () -> Gurobi.Optimizer(env).\nreplace with_optimizer(Gurobi.Optimizer, env, Presolve=0) by optimizer_with_attributes(() -> Gurobi.Optimizer(env), \"Presolve\" => 0).\nalternatively to optimizer_with_attributes, you can also set the attributes separately with set_optimizer_attribute.\nRenamed set_parameter and set_parameters to set_optimizer_attribute and set_optimizer_attributes (#2150).\nBroadcast should now be explicit inside macros. @SDconstraint(model, x >= 1) and @constraint(model, x + 1 in SecondOrderCone()) now throw an error instead of broadcasting 1 along the dimension of x (#2107).\n@SDconstraint(model, x >= 0) is now equivalent to @constraint(model, x in PSDCone()) instead of @constraint(model, (x .- 0) in PSDCone()) (#2107).\nThe macros now create the containers with map instead of for loops, as a consequence, containers created by @expression can now have any element type and containers of constraint references now have concrete element types when possible. This fixes a long-standing issue where @expression could only be used to generate a collection of linear expressions. Now it works for quadratic expressions as well (#2070).\nCalling deepcopy(::AbstractModel) now throws an error.\nThe constraint name is now printed in the model string (#2108).","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"New features:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added support for solver-independent and solver-specific callbacks (#2101).\nAdded write_to_file and read_from_file, supported formats are CBF, LP, MathOptFormat, MPS and SDPA (#2114).\nAdded support for complementarity constraints (#2132).\nAdded support for indicator constraints (#2092).\nAdded support for querying multiple solutions with the result keyword (#2100).\nAdded support for constraining variables on creation (#2128).\nAdded method delete that deletes a vector of variables at once if it is supported by the underlying solver (#2135).\nThe arithmetic between JuMP expression has be refactored into the MutableArithmetics package (#2107).\nImproved error on complex values in NLP (#1978).\nAdded an example of column generation (#2010).","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Bug fixes:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Incorrect coefficients generated when using Symmetric variables (#2102)","category":"page"},{"location":"release_notes/#Version-0.20.1-(Oct-18,-2019)","page":"Release notes","title":"Version 0.20.1 (Oct 18, 2019)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Add sections on @variables and @constraints in the documentation (#2062).\nFixed product of sparse matrices for Julia v1.3 (#2063).\nAdded set_objective_coefficient to modify the coefficient of a linear term of the objective function (#2008).\nAdded set_time_limit_sec, unset_time_limit_sec and time_limit_sec to set and query the time limit for the solver in seconds (#2053).","category":"page"},{"location":"release_notes/#Version-0.20.0-(Aug-24,-2019)","page":"Release notes","title":"Version 0.20.0 (Aug 24, 2019)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Documentation updates.\nNumerous bug fixes.\nBetter error messages (#1977, #1978, #1997, #2017).\nPerformance improvements (#1947, #2032).\nAdded LP sensitivity summary functions lp_objective_perturbation_range and lp_rhs_perturbation_range (#1917).\nAdded functions dual_objective_value, raw_status and set_parameter.\nAdded function set_objective_coefficient to modify the coefficient of a linear term of the objective (#2008).\nAdded functions set_normalized_rhs, normalized_rhs, and add_to_function_constant to modify and get the constant part of a constraint (#1935, #1960).\nAdded functions set_normalized_coefficient and normalized_coefficient to modify and get the coefficient of a linear term of a constraint (#1935, #1960).\nNumerous other improvements in MOI 0.9, see the NEWS.md file of MOI for more details.","category":"page"},{"location":"release_notes/#Version-0.19.2-(June-8,-2019)","page":"Release notes","title":"Version 0.19.2 (June 8, 2019)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug in derivatives that could arise in models with nested nonlinear subexpressions.","category":"page"},{"location":"release_notes/#Version-0.19.1-(May-12,-2019)","page":"Release notes","title":"Version 0.19.1 (May 12, 2019)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Usability and performance improvements.\nBug fixes.","category":"page"},{"location":"release_notes/#Version-0.19.0-(February-15,-2019)","page":"Release notes","title":"Version 0.19.0 (February 15, 2019)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"JuMP 0.19 contains significant breaking changes.","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Breaking changes:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"JuMP's abstraction layer for communicating with solvers changed from MathProgBase (MPB) to MathOptInterface (MOI). MOI addresses many longstanding design issues. (See @mlubin's slides from JuMP-dev 2018.) JuMP 0.19 is compatible only with solvers that have been updated for MOI. See the installation guide for a list of solvers that have and have not yet been updated.\nMost solvers have been renamed to PackageName.Optimizer. For example, GurobiSolver() is now Gurobi.Optimizer.\nSolvers are no longer added to a model via Model(solver = XXX(kwargs...)). Instead use Model(with_optimizer(XXX, kwargs...)). For example, Model(with_optimizer(Gurobi.Optimizer, OutputFlag=0)).\nJuMP containers (e.g., the objects returned by @variable) have been redesigned. Containers.SparseAxisArray replaces JuMPDict, JuMPArray was rewritten (inspired by AxisArrays) and renamed Containers.DenseAxisArray, and you can now request a container type with the container= keyword to the macros. See the corresponding documentation for more details.\nThe statuses returned by solvers have changed. See the possible status values here. The MOI statuses are much richer than the MPB statuses and can be used to distinguish between previously indistinguishable cases (e.g. did the solver have a feasible solution when it stopped because of the time limit?).\nStarting values are separate from result values. Use value to query the value of a variable in a solution. Use start_value and set_start_value to get and set an initial starting point provided to the solver. The solutions from previous solves are no longer automatically set as the starting points for the next solve.\nThe data structures for affine and quadratic expressions AffExpr and QuadExpr have changed. Internally, terms are stored in dictionaries instead of lists. Duplicate coefficients can no longer exist. Accessors and iteration methods have changed.\nJuMPNLPEvaluator no longer includes the linear and quadratic parts of the model in the evaluation calls. These are now handled separately to allow NLP solvers that support various types of constraints.\nJuMP solver-independent callbacks have been replaced by solver-specific callbacks. See your favorite solver for more details. (See the note below: No solver-specific callbacks are implemented yet.)\nThe norm() syntax is no longer recognized inside macros. Use the SecondOrderCone() set instead.\nJuMP no longer performs automatic transformation between special quadratic forms and second-order cone constraints. Support for these constraint classes depends on the solver.\nThe symbols :Min and :Max are no longer used as optimization senses. Instead, JuMP uses the OptimizationSense enum from MathOptInterface. @objective(model, Max, ...), @objective(model, Min, ...), @NLobjective(model, Max, ...), and @objective(model, Min, ...) remain valid, but @objective(m, :Max, ...) is no longer accepted.\nThe sign conventions for duals has changed in some cases for consistency with conic duality (see the documentation). The shadow_price helper method returns duals with signs that match conventional LP interpretations of dual values as sensitivities of the objective value to relaxations of constraints.\n@constraintref is no longer defined. Instead, create the appropriate container to hold constraint references manually. For example,\nconstraints = Dict() # Optionally, specify types for improved performance.\nfor i in 1:N\n  constraints[i] = @constraint(model, ...)\nend\nThe lowerbound, upperbound, and basename keyword arguments to the @variable macro have been renamed to lower_bound, upper_bound, and base_name, for consistency with JuMP's new style recommendations.\nWe rely on broadcasting syntax to apply accessors to collections of variables, e.g., value.(x) instead of getvalue(x) for collections. (Use value(x) when x is a scalar object.)","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"New features:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Splatting (like f(x...)) is recognized in restricted settings in nonlinear expressions.\nSupport for deleting constraints and variables.\nThe documentation has been completely rewritten using docstrings and Documenter.\nSupport for modeling mixed conic and quadratic models (e.g., conic models with quadratic objectives and bi-linear matrix inequalities).\nSignificantly improved support for modeling new types of constraints and for extending JuMP's macros.\nSupport for providing dual warm starts.\nImproved support for accessing solver-specific attributes (e.g., the irreducible inconsistent subsystem).\nExplicit control of whether symmetry-enforcing constraints are added to PSD constraints.\nSupport for modeling exponential cones.\nSignificant improvements in internal code quality and testing.\nStyle and naming guidelines.\nDirect mode and manual mode provide explicit control over when copies of a model are stored or regenerated. See the corresponding documentation.","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"There are known regressions from JuMP 0.18 that will be addressed in a future release (0.19.x or later):","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Performance regressions in model generation (issue). Please file an issue anyway if you notice a significant performance regression. We have plans to address a number of performance issues, but we might not be aware of all of them.\nFast incremental NLP solves are not yet reimplemented (issue).\nWe do not yet have an implementation of solver-specific callbacks.\nThe column generation syntax in @variable has been removed (i.e., the objective, coefficients, and inconstraints keyword arguments). Support for column generation will be re-introduced in a future release.\nThe ability to solve the continuous relaxation (i.e. via solve(model; relaxation = true)) is not yet reimplemented (issue).","category":"page"},{"location":"release_notes/#Version-0.18.5-(December-1,-2018)","page":"Release notes","title":"Version 0.18.5 (December 1, 2018)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Support views in some derivative evaluation functions.\nImproved compatibility with PackageCompiler.","category":"page"},{"location":"release_notes/#Version-0.18.4-(October-8,-2018)","page":"Release notes","title":"Version 0.18.4 (October 8, 2018)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug in model printing on Julia 0.7 and 1.0.","category":"page"},{"location":"release_notes/#Version-0.18.3-(October-1,-2018)","page":"Release notes","title":"Version 0.18.3 (October 1, 2018)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Add support for Julia v1.0 (Thanks @ExpandingMan)\nFix matrix expressions with quadratic functions (#1508)","category":"page"},{"location":"release_notes/#Version-0.18.2-(June-10,-2018)","page":"Release notes","title":"Version 0.18.2 (June 10, 2018)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug in second-order derivatives when expressions are present (#1319)\nFix a bug in @constraintref (#1330)","category":"page"},{"location":"release_notes/#Version-0.18.1-(April-9,-2018)","page":"Release notes","title":"Version 0.18.1 (April 9, 2018)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix for nested tuple destructuring (#1193)\nPreserve internal model when relaxation=true (#1209)\nMinor bug fixes and updates for example","category":"page"},{"location":"release_notes/#Version-0.18.0-(July-27,-2017)","page":"Release notes","title":"Version 0.18.0 (July 27, 2017)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Drop support for Julia 0.5.\nUpdate for ForwardDiff 0.5.\nMinor bug fixes.","category":"page"},{"location":"release_notes/#Version-0.17.1-(June-9,-2017)","page":"Release notes","title":"Version 0.17.1 (June 9, 2017)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Use of constructconstraint! in @SDconstraint.\nMinor bug fixes.","category":"page"},{"location":"release_notes/#Version-0.17.0-(May-27,-2017)","page":"Release notes","title":"Version 0.17.0 (May 27, 2017)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Breaking change: Mixing quadratic and conic constraints is no longer supported.\nBreaking change: The getvariable and getconstraint functions are replaced by indexing on the corresponding symbol. For instance, to access the variable with name x, one should now write mx instead of getvariable(m x). As a consequence, creating a variable and constraint with the same name now triggers a warning, and accessing one of them afterwards throws an error. This change is breaking only in the latter case.\nAddition of the getobjectivebound function that mirrors the functionality of the MathProgBase getobjbound function except that it takes into account transformations performed by JuMP.\nMinor bug fixes.","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The following changes are primarily of interest to developers of JuMP extensions:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The new syntax constraint(model expr in Cone) creates the constraint ensuring that expr is inside Cone. The Cone argument is passed to constructconstraint which enables the call to the dispatched to an extension.\nThe variable macro now calls constructvariable instead of directly calling the Variable constructor. Extra arguments and keyword arguments passed to variable are passed to constructvariable which enables the call to be dispatched to an extension.\nRefactor the internal function conicdata (used build the MathProgBase conic model) into smaller subfunctions to make these parts reusable by extensions.","category":"page"},{"location":"release_notes/#Version-0.16.2-(March-28,-2017)","page":"Release notes","title":"Version 0.16.2 (March 28, 2017)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Minor bug fixes and printing tweaks\nAddress deprecation warnings for Julia 0.6","category":"page"},{"location":"release_notes/#Version-0.16.1-(March-7,-2017)","page":"Release notes","title":"Version 0.16.1 (March 7, 2017)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Better support for AbstractArray in JuMP (Thanks @tkoolen)\nMinor bug fixes","category":"page"},{"location":"release_notes/#Version-0.16.0-(February-23,-2017)","page":"Release notes","title":"Version 0.16.0 (February 23, 2017)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Breaking change: JuMP no longer has a mechanism for selecting solvers by default (the previous mechanism was flawed and incompatible with Julia 0.6). Not specifying a solver before calling solve() will result in an error.\nBreaking change: User-defined functions are no longer global. The first argument to JuMPregister is now a JuMP Model object within whose scope the function will be registered. Calling JuMPregister without a Model now produces an error.\nBreaking change: Use the new JuMPfix method to fix a variable to a value or to update the value to which a variable is fixed. Calling setvalue on a fixed variable now results in an error in order to avoid silent behavior changes. (Thanks @joaquimg)\nNonlinear expressions now print out similarly to linear/quadratic expressions (useful for debugging!)\nNew category keyword to variable. Used for specifying categories of anonymous variables.\nCompatibility with Julia 0.6-dev.\nMinor fixes and improvements (Thanks @cossio, @ccoffrin, @blegat)","category":"page"},{"location":"release_notes/#Version-0.15.1-(January-31,-2017)","page":"Release notes","title":"Version 0.15.1 (January 31, 2017)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Bugfix for LinearConstraints and friends","category":"page"},{"location":"release_notes/#Version-0.15.0-(December-22,-2016)","page":"Release notes","title":"Version 0.15.0 (December 22, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Julia 0.5.0 is the minimum required version for this release.\nDocument support for BARON solver\nEnable info callbacks in more states than before, e.g. for recording solutions. New when argument to addinfocallback (#814, thanks @yeesian)\nImproved support for anonymous variables. This includes new warnings for potentially confusing use of the traditional non-anonymous syntax:\nWhen multiple variables in a model are given the same name\nWhen non-symbols are used as names, e.g., variable(m x11N)\nImprovements in iterating over JuMP containers (#836, thanks @IssamT)\nSupport for writing variable names in .lp file output (Thanks @leethargo)\nSupport for querying duals to SDP problems (Thanks @blegat)\nThe comprehension syntax with curly braces sum, prod, and norm2 has been deprecated in favor of Julia's native comprehension syntax sum(), prod() and norm() as previously announced. (For early adopters of the new syntax, norm2() was renamed to norm() without deprecation.)\nUnit tests rewritten to use Base.Test instead of FactCheck\nImproved support for operations with matrices of JuMP types (Thanks @ExpandingMan)\nThe syntax to halt a solver from inside a callback has changed from throw(CallbackAbort()) to return JuMPStopTheSolver\nMinor bug fixes","category":"page"},{"location":"release_notes/#Version-0.14.2-(December-12,-2016)","page":"Release notes","title":"Version 0.14.2 (December 12, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Allow singeton anonymous variables (includes bugfix)","category":"page"},{"location":"release_notes/#Version-0.14.1-(September-12,-2016)","page":"Release notes","title":"Version 0.14.1 (September 12, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"More consistent handling of states in informational callbacks, includes a new when parameter to addinfocallback for specifying in which state an informational callback should be called.","category":"page"},{"location":"release_notes/#Version-0.14.0-(August-7,-2016)","page":"Release notes","title":"Version 0.14.0 (August 7, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Compatibility with Julia 0.5 and ForwardDiff 0.2\nSupport for \"anonymous\" variables, constraints, expressions, and parameters, e.g., x = variable(m 1N) instead of variable(m x1N)\nSupport for retrieving constraints from a model by name via getconstraint\nNLconstraint now returns constraint references (as expected).\nSupport for vectorized expressions within lazy constraints\nOn Julia 0.5, parse new comprehension syntax sum(xi for i in 1N if isodd(i)) instead of sum xi i in 1N isodd(i) . The old syntax with curly braces will be deprecated in JuMP 0.15.\nNow possible to provide nonlinear expressions as \"raw\" Julia Expr objects instead of using JuMP's nonlinear macros. This input format is useful for programmatically generated expressions.\nsMathematical ProgrammingMathematical Optimization\nSupport for local cuts (Thanks to @madanim, Mehdi Madani)\nDocument Xpress interface developed by @joaquimg, Joaquim Dias Garcia\nMinor bug and deprecation fixes (Thanks @odow, @jrevels)","category":"page"},{"location":"release_notes/#Version-0.13.2-(May-16,-2016)","page":"Release notes","title":"Version 0.13.2 (May 16, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Compatibility update for MathProgBase","category":"page"},{"location":"release_notes/#Version-0.13.1-(May-3,-2016)","page":"Release notes","title":"Version 0.13.1 (May 3, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix broken deprecation for registerNLfunction.","category":"page"},{"location":"release_notes/#Version-0.13.0-(April-29,-2016)","page":"Release notes","title":"Version 0.13.0 (April 29, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Most exported methods and macros have been renamed to avoid camelCase. See the list of changes here. There is a 1-1 mapping from the old names to the new, and it is safe to simply replace the names to update existing models.\nSpecify variable lower/upper bounds in variable using the lowerbound and upperbound keyword arguments.\nChange name printed for variable using the basename keyword argument to variable.\nNew variables macro allows multiline declaration of groups of variables.\nA number of solver methods previously available only through MathProgBase are now exposed directly in JuMP. The fix was recorded live!\nCompatibility fixes with Julia 0.5.\nThe \"end\" indexing syntax is no longer supported within JuMPArrays which do not use 1-based indexing until upstream issues are resolved, see here.","category":"page"},{"location":"release_notes/#Version-0.12.2-(March-9,-2016)","page":"Release notes","title":"Version 0.12.2 (March 9, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Small fixes for nonlinear optimization","category":"page"},{"location":"release_notes/#Version-0.12.1-(March-1,-2016)","page":"Release notes","title":"Version 0.12.1 (March 1, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a regression in slicing for JuMPArrays (when not using 1-based indexing)","category":"page"},{"location":"release_notes/#Version-0.12.0-(February-27,-2016)","page":"Release notes","title":"Version 0.12.0 (February 27, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The automatic differentiation functionality has been completely rewritten with a number of user-facing changes:\ndefExpr and defNLExpr now take the model as the first argument. The previous one-argument version of defExpr is deprecated; all expressions should be named. E.g., replace defExpr(2x+y) with defExpr(jump_model my_expr 2x+y).\nJuMP no longer uses Julia's variable binding rules for efficiently re-solving a sequence of nonlinear models. Instead, we have introduced nonlinear parameters. This is a breaking change, so we have added a warning message when we detect models that may depend on the old behavior.\nSupport for user-defined functions integrated within nonlinear JuMP expressions.\nReplaced iteration over AffExpr with Number-like scalar iteration; previous iteration behavior is now available via linearterms(AffExpr).\nStopping the solver via throw(CallbackAbort()) from a callback no longer triggers an exception. Instead, solve() returns UserLimit status.\ngetDual() now works for conic problems (Thanks @emreyamangil.)","category":"page"},{"location":"release_notes/#Version-0.11.3-(February-4,-2016)","page":"Release notes","title":"Version 0.11.3 (February 4, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Bug-fix for problems with quadratic objectives and semidefinite constraints","category":"page"},{"location":"release_notes/#Version-0.11.2-(January-14,-2016)","page":"Release notes","title":"Version 0.11.2 (January 14, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Compatibility update for Mosek","category":"page"},{"location":"release_notes/#Version-0.11.1-(December-1,-2015)","page":"Release notes","title":"Version 0.11.1 (December 1, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Remove usage of @compat in tests.\nFix updating quadratic objectives for nonlinear models.","category":"page"},{"location":"release_notes/#Version-0.11.0-(November-30,-2015)","page":"Release notes","title":"Version 0.11.0 (November 30, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Julia 0.4.0 is the minimum required version for this release.\nFix for scoping semantics of index variables in sum{}. Index variables no longer leak into the surrounding scope.\nAddition of the solve(mModel relaxation=true) keyword argument to solve the standard continuous realaxation of model m\nThe getConstraintBounds() method allows access to the lower and upper bounds of all constraints in a (nonlinear) model.\nUpdate for breaking changes in MathProgBase","category":"page"},{"location":"release_notes/#Version-0.10.3-(November-20,-2015)","page":"Release notes","title":"Version 0.10.3 (November 20, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a rare error when parsing quadratic expressions\nFix Variable() constructor with default arguments\nDetect unrecognized keywords in solve()","category":"page"},{"location":"release_notes/#Version-0.10.2-(September-28,-2015)","page":"Release notes","title":"Version 0.10.2 (September 28, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix for deprecation warnings","category":"page"},{"location":"release_notes/#Version-0.10.1-(September-3,-2015)","page":"Release notes","title":"Version 0.10.1 (September 3, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixes for ambiguity warnings.\nFix for breaking change in precompilation syntax in Julia 0.4-pre","category":"page"},{"location":"release_notes/#Version-0.10.0-(August-31,-2015)","page":"Release notes","title":"Version 0.10.0 (August 31, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Support (on Julia 0.4 and later) for conditions in indexing defVar and addConstraint constructs, e.g. defVar(m xi=15j=15 i+j = 3)\nSupport for vectorized operations on Variables and expressions. See the documentation for details.\nNew getVar() method to access variables in a model by name\nSupport for semidefinite programming.\nDual solutions are now available for general nonlinear problems. You may call getDual on a reference object for a nonlinear constraint, and getDual on a variable object for Lagrange multipliers from active bounds.\nIntroduce warnings for two common performance traps: too many calls to getValue() on a collection of variables and use of the + operator in a loop to sum expressions.\nSecond-order cone constraints can be written directly with the norm() and norm2 syntax.\nImplement MathProgBase interface for querying Hessian-vector products.\nIteration over JuMPContainers is deprecated; instead, use the keys and values functions, and zip(keys(d)values(d)) for the old behavior.\ndefVar returns ArrayVariableN when each of N index sets are of the form 1nᵢ.\nModule precompilation: on Julia 0.4 and later, using JuMP is now much faster.","category":"page"},{"location":"release_notes/#Version-0.9.3-(August-11,-2015)","page":"Release notes","title":"Version 0.9.3 (August 11, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixes for FactCheck testing on julia v0.4.","category":"page"},{"location":"release_notes/#Version-0.9.2-(June-27,-2015)","page":"Release notes","title":"Version 0.9.2 (June 27, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix bug in @addConstraints.","category":"page"},{"location":"release_notes/#Version-0.9.1-(April-25,-2015)","page":"Release notes","title":"Version 0.9.1 (April 25, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix for Julia 0.4-dev.\nSmall infrastructure improvements for extensions.","category":"page"},{"location":"release_notes/#Version-0.9.0-(April-18,-2015)","page":"Release notes","title":"Version 0.9.0 (April 18, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Comparison operators for constructing constraints (e.g. 2x = 1) have been deprecated. Instead, construct the constraints explicitly in the addConstraint macro to add them to the model, or in the LinearConstraint macro to create a stand-alone linear constraint instance.\ngetValue() method implemented to compute the value of a nonlinear subexpression\nJuMP is now released under the Mozilla Public License version 2.0 (was previously LGPL). MPL is a copyleft license which is less restrictive than LGPL, especially for embedding JuMP within other applications.\nA number of performance improvements in ReverseDiffSparse for computing derivatives.\nMathProgBasegetsolvetime(m) now returns the solution time reported by the solver, if available. (Thanks @odow, Oscar Dowson)\nFormatting fix for LP format output. (Thanks @sbebo, Leonardo Taccari).","category":"page"},{"location":"release_notes/#Version-0.8.0-(February-17,-2015)","page":"Release notes","title":"Version 0.8.0 (February 17, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Nonlinear subexpressions now supported with the defNLExpr macro.\nSCS supported for solving second-order conic problems.\nsetXXXCallback family deprecated in favor of addXXXCallback.\nMultiple callbacks of the same type can be registered.\nAdded support for informational callbacks via addInfoCallback.\nA CallbackAbort exception can be thrown from callback to safely exit optimization.","category":"page"},{"location":"release_notes/#Version-0.7.4-(February-4,-2015)","page":"Release notes","title":"Version 0.7.4 (February 4, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Reduced costs and linear constraint duals are now accessible when quadratic constraints are present.\nTwo-sided nonlinear constraints are supported.\nMethods for accessing the number of variables and constraints in a model are renamed.\nNew default procedure for setting initial values in nonlinear optimization: project zero onto the variable bounds.\nSmall bug fixes.","category":"page"},{"location":"release_notes/#Version-0.7.3-(January-14,-2015)","page":"Release notes","title":"Version 0.7.3 (January 14, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a method ambiguity conflict with Compose.jl (cosmetic fix)","category":"page"},{"location":"release_notes/#Version-0.7.2-(January-9,-2015)","page":"Release notes","title":"Version 0.7.2 (January 9, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug in sum(JuMPDict)\nAdded the setCategory function to change a variables category (e.g. continuous or binary)","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"after construction, and getCategory to retrieve the variable category.","category":"page"},{"location":"release_notes/#Version-0.7.1-(January-2,-2015)","page":"Release notes","title":"Version 0.7.1 (January 2, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug in parsing linear expressions in macros. Affects only Julia 0.4 and later.","category":"page"},{"location":"release_notes/#Version-0.7.0-(December-29,-2014)","page":"Release notes","title":"Version 0.7.0 (December 29, 2014)","text":"","category":"section"},{"location":"release_notes/#Linear/quadratic/conic-programming","page":"Release notes","title":"Linear/quadratic/conic programming","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Breaking change: The syntax for column-wise model generation has been changed to use keyword arguments in defVar.\nOn Julia 0.4 and later, variables and coefficients may be multiplied in any order within macros. That is, variable*coefficient is now valid syntax.\nECOS supported for solving second-order conic problems.","category":"page"},{"location":"release_notes/#Nonlinear-programming","page":"Release notes","title":"Nonlinear programming","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Support for skipping model generation when solving a sequence of nonlinear models with changing data.\nFix a memory leak when solving a sequence of nonlinear models.\nThe addNLConstraint macro now supports the three-argument version to define sets of nonlinear constraints.\nKNITRO supported as a nonlinear solver.\nSpeed improvements for model generation.\nThe addNLConstraints macro supports adding multiple (groups of) constraints at once. Syntax is similar to addConstraints.\nDiscrete variables allowed in nonlinear problems for solvers which support them (currently only KNITRO).","category":"page"},{"location":"release_notes/#General","page":"Release notes","title":"General","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Starting values for variables may now be specified with defVar(m x start=value).\nThe setSolver function allows users to change the solver subsequent to model creation.\nSupport for \"fixed\" variables via the defVar(m x == 1) syntax.\nUnit tests rewritten to use FactCheck.jl, improved testing across solvers.","category":"page"},{"location":"release_notes/#Version-0.6.3-(October-19,-2014)","page":"Release notes","title":"Version 0.6.3 (October 19, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug in multiplying two AffExpr objects.","category":"page"},{"location":"release_notes/#Version-0.6.2-(October-11,-2014)","page":"Release notes","title":"Version 0.6.2 (October 11, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Further improvements and bug fixes for printing.\nFixed a bug in defExpr.\nSupport for accessing expression graphs through the MathProgBase NLP interface.","category":"page"},{"location":"release_notes/#Version-0.6.1-(September-19,-2014)","page":"Release notes","title":"Version 0.6.1 (September 19, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Improvements and bug fixes for printing.","category":"page"},{"location":"release_notes/#Version-0.6.0-(September-9,-2014)","page":"Release notes","title":"Version 0.6.0 (September 9, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Julia 0.3.0 is the minimum required version for this release.\nbuildInternalModel(mModel) added to build solver-level model in memory without optimizing.\nDeprecate load_model_only keyword argument to solve.\nAdd groups of constraints with addConstraints macro.\nUnicode operators now supported, including  for sum,  for prod, and /\nQuadratic constraints supported in addConstraint macro.\nQuadratic objectives supported in setObjective macro.\nMathProgBase solver-independent interface replaces Ipopt-specific interface for nonlinear problems\nBreaking change: IpoptOptions no longer supported to specify solver options, use m = Model(solver=IpoptSolver(options)) instead.\nNew solver interfaces: ECOS, NLopt, and nonlinear support for MOSEK\nNew option to control whether the lazy constraint callback is executed at each node in the B&B tree or just when feasible solutions are found\nAdd support for semicontinuous and semi-integer variables for those solvers that support them.\nAdd support for index dependencies (e.g. triangular indexing) in defVar, addConstraint, and defExpr (e.g. defVar(m xi=110j=i10)).\nThis required some changes to the internal structure of JuMP containers, which may break code that explicitly stored JuMPDict objects.","category":"page"},{"location":"release_notes/#Version-0.5.8-(September-24,-2014)","page":"Release notes","title":"Version 0.5.8 (September 24, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug with specifying solvers (affects Julia 0.2 only)","category":"page"},{"location":"release_notes/#Version-0.5.7-(September-5,-2014)","page":"Release notes","title":"Version 0.5.7 (September 5, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug in printing models","category":"page"},{"location":"release_notes/#Version-0.5.6-(September-2,-2014)","page":"Release notes","title":"Version 0.5.6 (September 2, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Add support for semicontinuous and semi-integer variables for those solvers that support them.\nBreaking change: Syntax for Variable() constructor has changed (use of this interface remains discouraged)\nUpdate for breaking changes in MathProgBase","category":"page"},{"location":"release_notes/#Version-0.5.5-(July-6,-2014)","page":"Release notes","title":"Version 0.5.5 (July 6, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix bug with problem modification: adding variables that did not appear in existing constraints or objective.","category":"page"},{"location":"release_notes/#Version-0.5.4-(June-19,-2014)","page":"Release notes","title":"Version 0.5.4 (June 19, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Update for breaking change in MathProgBase which reduces loading times for using JuMP\nFix error when MIPs not solved to optimality","category":"page"},{"location":"release_notes/#Version-0.5.3-(May-21,-2014)","page":"Release notes","title":"Version 0.5.3 (May 21, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Update for breaking change in ReverseDiffSparse","category":"page"},{"location":"release_notes/#Version-0.5.2-(May-9,-2014)","page":"Release notes","title":"Version 0.5.2 (May 9, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix compatibility with Julia 0.3 prerelease","category":"page"},{"location":"release_notes/#Version-0.5.1-(May-5,-2014)","page":"Release notes","title":"Version 0.5.1 (May 5, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug in coefficient handling inside lazy constraints and user cuts","category":"page"},{"location":"release_notes/#Version-0.5.0-(May-2,-2014)","page":"Release notes","title":"Version 0.5.0 (May 2, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Support for nonlinear optimization with exact, sparse second-order derivatives automatically computed. Ipopt is currently the only solver supported.\ngetValue for AffExpr and QuadExpr\nBreaking change: getSolverModel replaced by getInternalModel, which returns the internal MathProgBase-level model\nGroups of constraints can be specified with addConstraint (see documentation for details). This is not a breaking change.\ndot(JuMPDictVariableJuMPDictVariable) now returns the corresponding quadratic expression.","category":"page"},{"location":"release_notes/#Version-0.4.1-(March-24,-2014)","page":"Release notes","title":"Version 0.4.1 (March 24, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix bug where change in objective sense was ignored when re-solving a model.\nFix issue with handling zero coefficients in AffExpr.","category":"page"},{"location":"release_notes/#Version-0.4.0-(March-10,-2014)","page":"Release notes","title":"Version 0.4.0 (March 10, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Support for SOS1 and SOS2 constraints.\nSolver-independent callback for user heuristics.\ndot and sum implemented for JuMPDict objects. Now you can say addConstraint(m dot(ax) = b).\nDevelopers: support for extensions to JuMP. See definition of Model in srcJuMPjl for more details.\nOption to construct the low-level model before optimizing.","category":"page"},{"location":"release_notes/#Version-0.3.2-(February-17,-2014)","page":"Release notes","title":"Version 0.3.2 (February 17, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Improved model printing\nPreliminary support for IJulia output","category":"page"},{"location":"release_notes/#Version-0.3.1-(January-30,-2014)","page":"Release notes","title":"Version 0.3.1 (January 30, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Documentation updates\nSupport for MOSEK\nCPLEXLink renamed to CPLEX","category":"page"},{"location":"release_notes/#Version-0.3.0-(January-21,-2014)","page":"Release notes","title":"Version 0.3.0 (January 21, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Unbounded/infeasibility rays: getValue() will return the corresponding components of an unbounded ray when a model is unbounded, if supported by the selected solver. getDual() will return an infeasibility ray (Farkas proof) if a model is infeasible and the selected solver supports this feature.\nSolver-independent callbacks for user generated cuts.\nUse new interface for solver-independent QCQP.\nsetlazycallback renamed to setLazyCallback for consistency.","category":"page"},{"location":"release_notes/#Version-0.2.0-(December-15,-2013)","page":"Release notes","title":"Version 0.2.0 (December 15, 2013)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Breaking change: Objective sense is specified in setObjective instead of in the Model constructor.\nBreaking change: lpsolver and mipsolver merged into single solver option.\nProblem modification with efficient LP restarts and MIP warm-starts.\nRelatedly, column-wise modeling now supported.\nSolver-independent callbacks supported. Currently we support only a \"lazy constraint\" callback, which works with Gurobi, CPLEX, and GLPK. More callbacks coming soon.","category":"page"},{"location":"release_notes/#Version-0.1.2-(November-16,-2013)","page":"Release notes","title":"Version 0.1.2 (November 16, 2013)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Bug fixes for printing, improved error messages.\nAllow AffExpr to be used in macros; e.g., ex = y + z addConstraint(m x + 2*ex = 3)","category":"page"},{"location":"release_notes/#Version-0.1.1-(October-23,-2013)","page":"Release notes","title":"Version 0.1.1 (October 23, 2013)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Update for solver specification API changes in MathProgBase.","category":"page"},{"location":"release_notes/#Version-0.1.0-(October-3,-2013)","page":"Release notes","title":"Version 0.1.0 (October 3, 2013)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Initial public release.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\n    import GLPK\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/constraints/#jump_constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP is based on the MathOptInterface (MOI) API. Because of this, JuMP uses the following standard form to represent problems:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"beginalign\n     min_x in mathbbR^n  f_0(x)\n    \n     textst  f_i(x)  in mathcalS_i  i = 1 ldots m\nendalign","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Each constraint, f_i(x) in mathcalS_i, is composed of a function and a set. For example, instead of calling a^top x le b a less-than-or-equal-to constraint, we say that it is a scalar-affine-in-less-than constraint, where the function a^top x belongs to the less-than set (-infty b. We use the shorthand function-in-set to refer to constraints composed of different types of functions and sets.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"This page explains how to write various types of constraints in JuMP. For nonlinear constraints, see Nonlinear Modeling instead.","category":"page"},{"location":"manual/constraints/#Add-a-constraint","page":"Constraints","title":"Add a constraint","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Add a constraint to a JuMP model using the @constraint macro. The syntax to use depends on the type of constraint you wish to add.","category":"page"},{"location":"manual/constraints/#Add-a-linear-constraint","page":"Constraints","title":"Add a linear constraint","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Create linear constraints using the @constraint macro:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"model = Model()\n@variable(model, x[1:3])\n@constraint(model, c1, sum(x) <= 1)\n@constraint(model, c2, x[1] + 2 * x[3] >= 2)\n@constraint(model, c3, sum(i * x[i] for i in 1:3) == 3)\n@constraint(model, c4, 4 <= 2 * x[2] <= 5)\nprint(model)\n\n# output\n\nFeasibility\nSubject to\n c3 : x[1] + 2 x[2] + 3 x[3] = 3.0\n c2 : x[1] + 2 x[3] ≥ 2.0\n c1 : x[1] + x[2] + x[3] ≤ 1.0\n c4 : 2 x[2] ∈ [4.0, 5.0]","category":"page"},{"location":"manual/constraints/#Normalization","page":"Constraints","title":"Normalization","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP normalizes constraints by moving all of the terms containing variables to the left-hand side and all of the constant terms to the right-hand side. Thus, we get:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, c, 2x + 1 <= 4x + 4)\nc : -2 x <= 3.0","category":"page"},{"location":"manual/constraints/#quad_constraints","page":"Constraints","title":"Add a quadratic constraint","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In addition to affine functions, JuMP also supports constraints with quadratic terms. For example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[i=1:2])\n2-element Vector{VariableRef}:\n x[1]\n x[2]\n\njulia> @variable(model, t >= 0)\nt\n\njulia> @constraint(model, my_q, x[1]^2 + x[2]^2 <= t^2)\nmy_q : x[1]² + x[2]² - t² <= 0.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"tip: Tip\nBecause solvers can take advantage of the knowledge that a constraint is quadratic, prefer adding quadratic constraints using @constraint, rather than @NLconstraint.","category":"page"},{"location":"manual/constraints/#Vectorized-constraints","page":"Constraints","title":"Vectorized constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"You can also add constraints to JuMP using vectorized linear algebra. For example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[i=1:2])\n2-element Vector{VariableRef}:\n x[1]\n x[2]\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> b = [5, 6]\n2-element Vector{Int64}:\n 5\n 6\n\njulia> @constraint(model, con, A * x .== b)\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}, ScalarShape}}:\n con : x[1] + 2 x[2] = 5.0\n con : 3 x[1] + 4 x[2] = 6.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nMake sure to use Julia's dot syntax in front of the comparison operators (for example, .==, .>=, and .<=). If you use a comparison without the dot, an error will be thrown.","category":"page"},{"location":"manual/constraints/#Containers-of-constraints","page":"Constraints","title":"Containers of constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The @constraint macro supports creating collections of constraints. We'll cover some brief syntax here; read the Constraint containers section for more details:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Create arrays of constraints:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, c[i=1:3], x[i] <= i^2)\n3-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n c[1] : x[1] ≤ 1.0\n c[2] : x[2] ≤ 4.0\n c[3] : x[3] ≤ 9.0\n\njulia> c[2]\nc[2] : x[2] ≤ 4.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Sets can be any Julia type that supports iteration:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, c[i=2:3, [\"red\", \"blue\"]], x[i] <= i^2)\n2-dimensional DenseAxisArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape},2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, [\"red\", \"blue\"]\nAnd data, a 2×2 Matrix{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n c[2,red] : x[2] ≤ 4.0  c[2,blue] : x[2] ≤ 4.0\n c[3,red] : x[3] ≤ 9.0  c[3,blue] : x[3] ≤ 9.0\n\njulia> c[2, \"red\"]\nc[2,red] : x[2] ≤ 4.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Sets can depend upon previous indices:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, c[i=1:3, j=i:3], x[i] <= j)\nJuMP.Containers.SparseAxisArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}, 2, Tuple{Int64, Int64}} with 6 entries:\n  [1, 1]  =  c[1,1] : x[1] ≤ 1.0\n  [1, 2]  =  c[1,2] : x[1] ≤ 2.0\n  [1, 3]  =  c[1,3] : x[1] ≤ 3.0\n  [2, 2]  =  c[2,2] : x[2] ≤ 2.0\n  [2, 3]  =  c[2,3] : x[2] ≤ 3.0\n  [3, 3]  =  c[3,3] : x[3] ≤ 3.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"and you can filter elements in the sets using the ; syntax:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, c[i=1:9; mod(i, 3) == 0], x[i] <= i)\nJuMP.Containers.SparseAxisArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}, 1, Tuple{Int64}} with 3 entries:\n  [3]  =  c[3] : x[3] ≤ 3.0\n  [6]  =  c[6] : x[6] ≤ 6.0\n  [9]  =  c[9] : x[9] ≤ 9.0","category":"page"},{"location":"manual/constraints/#Registered-constraints","page":"Constraints","title":"Registered constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"When you create constraints, JuMP registers them inside the model using their corresponding symbol. Get a registered name using model[:key]:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, my_c, 2x <= 1)\nmy_c : 2 x ≤ 1.0\n\njulia> model\nA JuMP Model\nFeasibility problem with:\nVariable: 1\n`AffExpr`-in-`MathOptInterface.LessThan{Float64}`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: my_c, x\n\njulia> model[:my_c] === my_c\ntrue","category":"page"},{"location":"manual/constraints/#Anonymous-constraints","page":"Constraints","title":"Anonymous constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To reduce the likelihood of accidental bugs, and because JuMP registers constraints inside a model, creating two constraints with the same name is an error:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, c, 2x <= 1)\nc : 2 x <= 1.0\n\njulia> @constraint(model, c, 2x <= 1)\nERROR: An object of name c is already attached to this model. If this\n    is intended, consider using the anonymous construction syntax, e.g.,\n    `x = @variable(model, [1:N], ...)` where the name of the object does\n    not appear inside the macro.\n\n    Alternatively, use `unregister(model, :c)` to first unregister\n    the existing name from the model. Note that this will not delete the\n    object; it will just remove the reference at `model[:c]`.\n[...]","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A common reason for encountering this error is adding constraints in a loop.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"As a work-around, JuMP provides anonymous constraints. Create an anonymous constraint by omitting the name argument:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> c = @constraint(model, 2x <= 1)\n2 x <= 1.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Create a container of anonymous constraints by dropping the name in front of the [:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> c = @constraint(model, [i = 1:3], x[i] <= i)\n3-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n x[1] ≤ 1.0\n x[2] ≤ 2.0\n x[3] ≤ 3.0","category":"page"},{"location":"manual/constraints/#Constraint-names","page":"Constraints","title":"Constraint names","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In addition to the symbol that constraints are registered with, constraints have a String name that is used for printing and writing to file formats.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Get and set the name of a constraint using name(::JuMP.ConstraintRef) and set_name(::JuMP.ConstraintRef, ::String):","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model(); @variable(model, x);\n\njulia> @constraint(model, con, x <= 1)\ncon : x <= 1.0\n\njulia> name(con)\n\"con\"\n\njulia> set_name(con, \"my_con_name\")\n\njulia> con\nmy_con_name : x <= 1.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Override the default choice of name using the base_name keyword:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model(); @variable(model, x);\n\njulia> con = @constraint(model, [i=1:2], x <= i, base_name = \"my_con\")\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n my_con[1] : x ≤ 1.0\n my_con[2] : x ≤ 2.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note that names apply to each element of the container, not to the container of constraints:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> name(con[1])\n\"my_con[1]\"\n\njulia> set_name(con[1], \"c\")\n\njulia> con\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n c : x ≤ 1.0\n my_con[2] : x ≤ 2.0","category":"page"},{"location":"manual/constraints/#Retrieve-a-constraint-by-name","page":"Constraints","title":"Retrieve a constraint by name","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Retrieve a constraint from a model using constraint_by_name:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> constraint_by_name(model, \"c\")\nc : x ≤ 1.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If the name is not present, nothing will be returned:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> constraint_by_name(model, \"bad_name\")","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"You can only look up individual constraints using constraint_by_name. Something like this will not work:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model(); @variable(model, x);\n\njulia> con = @constraint(model, [i=1:2], x <= i, base_name = \"my_con\")\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n my_con[1] : x ≤ 1.0\n my_con[2] : x ≤ 2.0\n\njulia> constraint_by_name(model, \"my_con\")","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To look up a collection of constraints, do not use constraint_by_name. Instead, register them using the model[:key] = value syntax:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model(); @variable(model, x);\n\njulia> model[:con] = @constraint(model, [i=1:2], x <= i, base_name = \"my_con\")\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n my_con[1] : x ≤ 1.0\n my_con[2] : x ≤ 2.0\n\njulia> model[:con]\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n my_con[1] : x ≤ 1.0\n my_con[2] : x ≤ 2.0","category":"page"},{"location":"manual/constraints/#String-names,-symbolic-names,-and-bindings","page":"Constraints","title":"String names, symbolic names, and bindings","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"It's common for new users to experience confusion relating to constraints. Part of the problem is the difference between the name that a constraint is registered under and the String name used for printing.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Here's a summary of the differences:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Constraints are created using @constraint.\nConstraints can be named or anonymous.\nNamed constraints have the form @constraint(model, c, expr). For named constraints:\nThe String name of the constraint is set to \"c\".\nA Julia variable c is created that binds c to  the JuMP constraint.\nThe name :c is registered as a key in the model with the value c.\nAnonymous constraints have the form c = @constraint(model, expr). For anonymous constraints:\nThe String name of the constraint is set to \"\".\nYou control the name of the Julia variable used as the binding.\nNo name is registered as a key in the model.\nThe base_name keyword can override the String name of the constraint.\nYou can manually register names in the model via model[:key] = value.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Here's an example of the differences:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> c_binding = @constraint(model, 2x <= 1, base_name = \"c\")\nc : 2 x <= 1.0\n\njulia> model\nA JuMP Model\nFeasibility problem with:\nVariable: 1\n`AffExpr`-in-`MathOptInterface.LessThan{Float64}`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: x\n\njulia> c\nERROR: UndefVarError: c not defined\n\njulia> c_binding\nc : 2 x <= 1.0\n\njulia> name(c_binding)\n\"c\"\n\njulia> model[:c_register] = c_binding\nc : 2 x <= 1.0\n\njulia> model\nA JuMP Model\nFeasibility problem with:\nVariable: 1\n`AffExpr`-in-`MathOptInterface.LessThan{Float64}`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: c_register, x\n\njulia> model[:c_register]\nc : 2 x <= 1.0\n\njulia> model[:c_register] === c_binding\ntrue\n\njulia> c\nERROR: UndefVarError: c not defined","category":"page"},{"location":"manual/constraints/#The-@constraints-macro","page":"Constraints","title":"The @constraints macro","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If you have many @constraint calls, use the @constraints macro to improve readability:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraints(model, begin\n           2x <= 1\n           c, x >= -1\n       end)\n(2 x ≤ 1.0, c : x ≥ -1.0)\n\njulia> print(model)\nFeasibility\nSubject to\n c : x ≥ -1.0\n 2 x ≤ 1.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The @constraints macro returns a tuple of the constraints that were defined.","category":"page"},{"location":"manual/constraints/#constraint_duality","page":"Constraints","title":"Duality","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP adopts the notion of conic duality from MathOptInterface. For linear programs, a feasible dual on a >= constraint is nonnegative and a feasible dual on a <= constraint is nonpositive. If the constraint is an equality constraint, it depends on which direction is binding.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"warning: Warning\nJuMP's definition of duality is independent of the objective sense. That is, the sign of feasible duals associated with a constraint depends on the direction of the constraint and not whether the problem is maximization or minimization. This is a different convention from linear programming duality in some common textbooks. If you have a linear program, and you want the textbook definition, you probably want to use shadow_price and reduced_cost instead.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The dual value associated with a constraint in the most recent solution can be accessed using the dual function. Use has_duals to check if the model has a dual solution available to query. For example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model(GLPK.Optimizer);\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x <= 1)\ncon : x <= 1.0\n\njulia> @objective(model, Min, -2x)\n-2 x\n\njulia> has_duals(model)\nfalse\n\njulia> optimize!(model)\n\njulia> has_duals(model)\ntrue\n\njulia> dual(con)\n-2.0\n\njulia> @objective(model, Max, 2x)\n2 x\n\njulia> optimize!(model)\n\njulia> dual(con)\n-2.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To help users who may be less familiar with conic duality, JuMP provides shadow_price, which returns a value that can be interpreted as the improvement in the objective in response to an infinitesimal relaxation (on the scale of one unit) in the right-hand side of the constraint. shadow_price can be used only on linear constraints with a <=, >=, or == comparison operator.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In the example above, dual(con) returned -2.0 regardless of the optimization sense. However, in the second case when the optimization sense is Max, shadow_price returns:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> shadow_price(con)\n2.0","category":"page"},{"location":"manual/constraints/#Duals-of-variable-bounds","page":"Constraints","title":"Duals of variable bounds","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To query the dual variables associated with a variable bound, first obtain a constraint reference using one of UpperBoundRef, LowerBoundRef, or FixRef, and then call dual on the returned constraint reference. The reduced_cost function may simplify this process as it returns the shadow price of an active bound of a variable (or zero, if no active bound exists).","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model(GLPK.Optimizer);\n\njulia> @variable(model, x <= 1)\nx\n\njulia> @objective(model, Min, -2x)\n-2 x\n\njulia> optimize!(model)\n\njulia> dual(UpperBoundRef(x))\n-2.0\n\njulia> reduced_cost(x)\n-2.0","category":"page"},{"location":"manual/constraints/#Modify-a-constant-term","page":"Constraints","title":"Modify a constant term","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"This section explains how to modify the constant term in a constraint. There are multiple ways to achieve this goal; we explain three options.","category":"page"},{"location":"manual/constraints/#Option-1:-change-the-right-hand-side","page":"Constraints","title":"Option 1: change the right-hand side","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Use set_normalized_rhs to modify the right-hand side (constant) term of a linear or quadratic  constraint. Use normalized_rhs to query the right-hand side term.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0\n\njulia> set_normalized_rhs(con, 3)\n\njulia> con\ncon : 2 x <= 3.0\n\njulia> normalized_rhs(con)\n3.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"warning: Warning\nset_normalized_rhs sets the right-hand side term of the normalized constraint. See Normalization for more details.","category":"page"},{"location":"manual/constraints/#Option-2:-use-fixed-variables","page":"Constraints","title":"Option 2: use fixed variables","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If constraints are complicated, for example, they are composed of a number of components, each of which has a constant term, then it may be difficult to calculate what the right-hand side term is in the standard form.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For this situation, JuMP includes the ability to fix variables to a value using the fix function. Fixing a variable sets its lower and upper bound to the same value. Thus, changes in a constant term can be simulated by adding a new variable and fixing it to different values. Here is an example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, const_term)\nconst_term\n\njulia> @constraint(model, con, 2x <= const_term + 1)\ncon : 2 x - const_term <= 1.0\n\njulia> fix(const_term, 1.0)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The constraint con is now equivalent to 2x <= 2.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"warning: Warning\nFixed variables are not replaced with constants when communicating the problem to a solver. Therefore, even though const_term is fixed, it is still a decision variable, and so const_term * x is bilinear.","category":"page"},{"location":"manual/constraints/#Option-3:-modify-the-function's-constant-term","page":"Constraints","title":"Option 3: modify the function's constant term","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The third option is to use add_to_function_constant. The constant given is added to the function of a func-in-set constraint. In the following example, adding 2 to the function has the effect of removing 2 to the right-hand side:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0\n\njulia> add_to_function_constant(con, 2)\n\njulia> con\ncon : 2 x <= -1.0\n\njulia> normalized_rhs(con)\n-1.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In the case of interval constraints, the constant is removed from each bound:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 0 <= 2x + 1 <= 2)\ncon : 2 x ∈ [-1.0, 1.0]\n\njulia> add_to_function_constant(con, 3)\n\njulia> con\ncon : 2 x ∈ [-4.0, -2.0]","category":"page"},{"location":"manual/constraints/#Modify-a-variable-coefficient","page":"Constraints","title":"Modify a variable coefficient","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To modify the coefficients for a linear term (modifying the coefficient of a quadratic term is not supported) in a constraint, use set_normalized_coefficient. To query the current coefficient, use normalized_coefficient.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x[1] + x[2] <= 1)\ncon : 2 x[1] + x[2] ≤ 1.0\n\njulia> set_normalized_coefficient(con, x[2], 0)\n\njulia> con\ncon : 2 x[1] ≤ 1.0\n\njulia> normalized_coefficient(con, x[2])\n0.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"warning: Warning\nset_normalized_coefficient sets the coefficient of the normalized constraint. See Normalization for more details.","category":"page"},{"location":"manual/constraints/#Delete-a-constraint","page":"Constraints","title":"Delete a constraint","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Use delete to delete a constraint from a model. Use is_valid to check if a constraint belongs to a model and has not been deleted.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0\n\njulia> is_valid(model, con)\ntrue\n\njulia> delete(model, con)\n\njulia> is_valid(model, con)\nfalse","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Deleting a constraint does not unregister the symbolic reference from the model. Therefore, creating a new constraint of the same name will throw an error:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\nERROR: An object of name con is already attached to this model. If this\n    is intended, consider using the anonymous construction syntax, e.g.,\n    `x = @variable(model, [1:N], ...)` where the name of the object does\n    not appear inside the macro.\n\n    Alternatively, use `unregister(model, :con)` to first unregister\n    the existing name from the model. Note that this will not delete the\n    object; it will just remove the reference at `model[:con]`.\n[...]","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"After calling delete, call unregister to remove the symbolic reference:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> unregister(model, :con)\n\njulia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"info: Info\ndelete does not automatically unregister because we do not distinguish between names that are automatically registered by JuMP macros, and names that are manually registered by the user by setting values in object_dictionary. In addition, deleting a constraint and then adding a new constraint of the same name is an easy way to introduce bugs into your code.","category":"page"},{"location":"manual/constraints/#Start-values","page":"Constraints","title":"Start values","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Provide a starting value (also called warmstart) for a constraint's dual using set_dual_start_value.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The start value of a constraint's dual can be queried using dual_start_value. If no start value has been set, dual_start_value will return nothing.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x >= 10)\ncon : x ≥ 10.0\n\njulia> dual_start_value(con)\n\njulia> set_dual_start_value(con, 2)\n\njulia> dual_start_value(con)\n2.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Vector-valued constraints require a vector warmstart:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[1:3])\n3-element Vector{VariableRef}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, con, x in SecondOrderCone())\ncon : [x[1], x[2], x[3]] in MathOptInterface.SecondOrderCone(3)\n\njulia> dual_start_value(con)\n\njulia> set_dual_start_value(con, [1.0, 2.0, 3.0])\n\njulia> dual_start_value(con)\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To take the dual solution from the last solve and use it as the starting point for a new solve, use:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"for (F, S) in list_of_constraint_types(model)\n    for con in all_constraints(model, F, S)\n        set_dual_start_value(con, dual(con))\n    end\nend","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nSome constraints might not have well defined duals, hence you might need to filter (F, S) pairs.","category":"page"},{"location":"manual/constraints/#Constraint-containers","page":"Constraints","title":"Constraint containers","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Like Variable containers, JuMP provides a mechanism for building groups of constraints compactly. References to these groups of constraints are returned in containers. Three types of constraint containers are supported: Arrays, DenseAxisArrays, and SparseAxisArrays. We explain each of these in the following.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"tip: Tip\nYou can read more about containers in the Containers section.","category":"page"},{"location":"manual/constraints/#constraint_arrays","page":"Constraints","title":"Arrays","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"One way of adding a group of constraints compactly is the following:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con[i = 1:3], i * x <= i + 1)\n3-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n con[1] : x ≤ 2.0\n con[2] : 2 x ≤ 3.0\n con[3] : 3 x ≤ 4.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP returns references to the three constraints in an Array that is bound to the Julia variable con. This array can be accessed and sliced as you would with any Julia array:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> con[1]\ncon[1] : x <= 2.0\n\njulia> con[2:3]\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n con[2] : 2 x ≤ 3.0\n con[3] : 3 x ≤ 4.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Anonymous containers can also be constructed by dropping the name (for example, con) before the square brackets:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> con = @constraint(model, [i = 1:2], i * x <= i + 1)\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n x ≤ 2.0\n 2 x ≤ 3.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Just like @variable, JuMP will form an Array of constraints when it can determine at parse time that the indices are one-based integer ranges. Therefore con[1:b] will create an Array, but con[a:b] will not. A special case is con[Base.OneTo(n)] which will produce an Array. If JuMP cannot determine that the indices are one-based integer ranges (for example, in the case of con[a:b]), JuMP will create a DenseAxisArray instead.","category":"page"},{"location":"manual/constraints/#DenseAxisArrays","page":"Constraints","title":"DenseAxisArrays","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The syntax for constructing a DenseAxisArray of constraints is very similar to the syntax for constructing a DenseAxisArray of variables.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con[i = 1:2, j = 2:3], i * x <= j + 1)\n2-dimensional DenseAxisArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape},2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, 2:3\nAnd data, a 2×2 Matrix{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n con[1,2] : x ≤ 3.0    con[1,3] : x ≤ 4.0\n con[2,2] : 2 x ≤ 3.0  con[2,3] : 2 x ≤ 4.0","category":"page"},{"location":"manual/constraints/#SparseAxisArrays","page":"Constraints","title":"SparseAxisArrays","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The syntax for constructing a SparseAxisArray of constraints is very similar to the syntax for constructing a SparseAxisArray of variables.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con[i = 1:2, j = 1:2; i != j], i * x <= j + 1)\nJuMP.Containers.SparseAxisArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}, 2, Tuple{Int64, Int64}} with 2 entries:\n  [1, 2]  =  con[1,2] : x ≤ 3.0\n  [2, 1]  =  con[2,1] : 2 x ≤ 2.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"warning: Warning\nIf you have many index dimensions and a large amount of sparsity, read Performance considerations.","category":"page"},{"location":"manual/constraints/#Forcing-the-container-type","page":"Constraints","title":"Forcing the container type","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"When creating a container of constraints, JuMP will attempt to choose the tightest container type that can store the constraints. However, because this happens at parse time, it does not always make the best choice. Just like in @variable, you can force the type of container using the container keyword. For syntax and the reason behind this, take a look at the variable docs.","category":"page"},{"location":"manual/constraints/#Accessing-constraints-from-a-model","page":"Constraints","title":"Accessing constraints from a model","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Query the types of function-in-set constraints in a model using list_of_constraint_types:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[i=1:2] >= i, Int);\n\njulia> @constraint(model, x[1] + x[2] <= 1);\n\njulia> list_of_constraint_types(model)\n3-element Vector{Tuple{Type, Type}}:\n (AffExpr, MathOptInterface.LessThan{Float64})\n (VariableRef, MathOptInterface.GreaterThan{Float64})\n (VariableRef, MathOptInterface.Integer)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For a given combination of function and set type, use num_constraints to access the number of constraints and all_constraints to access a list of their references:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> num_constraints(model, VariableRef, MOI.Integer)\n2\n\njulia> cons = all_constraints(model, VariableRef, MOI.Integer)\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}, ScalarShape}}:\n x[1] integer\n x[2] integer","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Use constraint_object to get an instance of an AbstractConstraint object that stores the constraint data:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> con = constraint_object(cons[1])\nScalarConstraint{VariableRef, MathOptInterface.Integer}(x[1], MathOptInterface.Integer())\n\njulia> con.func\nx[1]\n\njulia> con.set\nMathOptInterface.Integer()","category":"page"},{"location":"manual/constraints/#MathOptInterface-constraints","page":"Constraints","title":"MathOptInterface constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Because JuMP is based on MathOptInterface, you can add any constraints supported by MathOptInterface using the function-in-set syntax. For a list of supported functions and sets, read Standard form problem.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nWe use MOI as an alias for the MathOptInterface module. This alias is defined by using JuMP. You may also define it in your code as follows:import MathOptInterface\nconst MOI = MathOptInterface","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For example, the following two constraints are equivalent:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, 2 * x[1] <= 1)\n2 x[1] ≤ 1.0\n\njulia> @constraint(model, 2 * x[1] in MOI.LessThan(1.0))\n2 x[1] ≤ 1.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"You can also use any set defined by MathOptInterface:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x - [1; 2; 3] in MOI.Nonnegatives(3))\n[x[1] - 1, x[2] - 2, x[3] - 3] ∈ MathOptInterface.Nonnegatives(3)\n\njulia> @constraint(model, x in MOI.ExponentialCone())\n[x[1], x[2], x[3]] ∈ MathOptInterface.ExponentialCone()","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"info: Info\nSimilar to how JuMP defines the <= and >= syntax as a convenience way to specify MOI.LessThan and MOI.GreaterThan constraints, the remaining sections in this page describe functions and syntax that have been added for the convenience of common modeling situations.","category":"page"},{"location":"manual/constraints/#Set-inequality-syntax","page":"Constraints","title":"Set inequality syntax","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For modeling convenience, the syntax @constraint(model, x >= y, Set()) is short-hand for @constraint(model, x - y in Set()). Therefore, the following calls are equivalent:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> y = [0.5, 0.75];\n\njulia> @constraint(model, x >= y, MOI.Nonnegatives(2))\n[x[1] - 0.5, x[2] - 0.75] ∈ MathOptInterface.Nonnegatives(2)\n\njulia> @constraint(model, y <= x, MOI.Nonnegatives(2))\n[x[1] - 0.5, x[2] - 0.75] ∈ MathOptInterface.Nonnegatives(2)\n\njulia> @constraint(model, x - y in MOI.Nonnegatives(2))\n[x[1] - 0.5, x[2] - 0.75] ∈ MathOptInterface.Nonnegatives(2)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Non-zero constants are not supported in this syntax:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x >= 1, MOI.Nonnegatives(2))\nERROR: Operation `sub_mul` between `Vector{VariableRef}` and `Int64` is not allowed. You should use broadcast.\nStacktrace:\n[...]","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Use instead:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x .- 1 >= 0, MOI.Nonnegatives(2))\n[x[1] - 1, x[2] - 1] ∈ MathOptInterface.Nonnegatives(2)","category":"page"},{"location":"manual/constraints/#Second-order-cone-constraints","page":"Constraints","title":"Second-order cone constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A SecondOrderCone constrains the variables t and x to the set:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"x_2 le t","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"and t ge 0. It can be added as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, t)\nt\n\njulia> @variable(model, x[1:2])\n2-element Vector{VariableRef}:\n x[1]\n x[2]\n\njulia> @constraint(model, [t; x] in SecondOrderCone())\n[t, x[1], x[2]] ∈ MathOptInterface.SecondOrderCone(3)","category":"page"},{"location":"manual/constraints/#Rotated-second-order-cone-constraints","page":"Constraints","title":"Rotated second-order cone constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A RotatedSecondOrderCone constrains the variables t, u, and x to the set:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"x_2^2 le 2 t cdot u","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"and t u ge 0. It can be added as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, t)\nt\n\njulia> @variable(model, u)\nu\n\njulia> @variable(model, x[1:2])\n2-element Vector{VariableRef}:\n x[1]\n x[2]\n\njulia> @constraint(model, [t; u; x] in RotatedSecondOrderCone())\n[t, u, x[1], x[2]] ∈ MathOptInterface.RotatedSecondOrderCone(4)","category":"page"},{"location":"manual/constraints/#Semi-integer-and-semi-continuous-variables","page":"Constraints","title":"Semi-integer and semi-continuous variables","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Semi-continuous variables are constrained to the set x in 0 cup l u.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Create a semi-continuous variable using the MOI.Semicontinuous set:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.Semicontinuous(1.5, 3.5))\nx in MathOptInterface.Semicontinuous{Float64}(1.5, 3.5)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Semi-integer variables  are constrained to the set x in 0 cup l l+1 dots u.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Create a semi-integer variable using the MOI.Semiinteger set:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.Semiinteger(1.0, 3.0))\nx in MathOptInterface.Semiinteger{Float64}(1.0, 3.0)","category":"page"},{"location":"manual/constraints/#Special-Ordered-Sets-of-Type-1","page":"Constraints","title":"Special Ordered Sets of Type 1","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In a Special Ordered Set of Type 1 (often denoted SOS-I or SOS1), at most one element can take a non-zero value.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Construct SOS-I constraints using the SOS1 set:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[1:3])\n3-element Vector{VariableRef}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in SOS1())\n[x[1], x[2], x[3]] in MathOptInterface.SOS1{Float64}([1.0, 2.0, 3.0])","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Although not required for feasibility, solvers can benefit from an ordering of the variables (for example, the variables represent different factories to build, at most one factory can be built, and the factories can be ordered according to cost). To induce an ordering, a vector of weights can be provided, and the variables are ordered according to their corresponding weight.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For example, in the constraint:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in SOS1([3.1, 1.2, 2.3]))\n[x[1], x[2], x[3]] in MathOptInterface.SOS1{Float64}([3.1, 1.2, 2.3])","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"the variables x have precedence x[2], x[3], x[1].","category":"page"},{"location":"manual/constraints/#Special-Ordered-Sets-of-Type-2","page":"Constraints","title":"Special Ordered Sets of Type 2","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In a Special Ordered Set of Type 2 (SOS-II), at most two elements can be non-zero, and if there are two non-zeros, they must be consecutive according to the ordering induced by a weight vector.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Construct SOS-II constraints using the SOS2 set:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in SOS2([3.0, 1.0, 2.0]))\n[x[1], x[2], x[3]] in MathOptInterface.SOS2{Float64}([3.0, 1.0, 2.0])","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The possible non-zero pairs are (x[1], x[3]) and (x[2], x[3]):","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If the weight vector is omitted, JuMP induces an ordering from 1:length(x):","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in SOS2())\n[x[1], x[2], x[3]] in MathOptInterface.SOS2{Float64}([1.0, 2.0, 3.0])","category":"page"},{"location":"manual/constraints/#Indicator-constraints","page":"Constraints","title":"Indicator constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Indicator constraints consist of a binary variable and a linear constraint. The constraint holds when the binary variable takes the value 1. The constraint may or may not hold when the binary variable takes the value 0.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To enforce the constraint x + y <= 1 when the binary variable a is 1, use:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @variable(model, a, Bin)\na\n\njulia> @constraint(model, a => {x + y <= 1})\na => {x + y ≤ 1.0}","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If the constraint must hold when a is zero, add ! or ¬ before the binary variable;","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, !a => {x + y <= 1})\n!a => {x + y ≤ 1.0}","category":"page"},{"location":"manual/constraints/#Semidefinite-constraints","page":"Constraints","title":"Semidefinite constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To constrain a matrix to be positive semidefinite (PSD), use PSDCone:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, X[1:2, 1:2])\n2×2 Matrix{VariableRef}:\n X[1,1]  X[1,2]\n X[2,1]  X[2,2]\n\njulia> @constraint(model, X >= 0, PSDCone())\n[X[1,1]  X[1,2];\n X[2,1]  X[2,2]] ∈ PSDCone()","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"tip: Tip\nWhere possible, prefer constructing a matrix of Semidefinite variables using the @variable macro, rather than adding a constraint like @constraint(model, X >= 0, PSDCone()). In some solvers, adding the constraint via @constraint is less efficient, and can result in additional intermediate variables and constraints being added to the model.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The inequality X >= Y between two square matrices X and Y is understood as constraining X - Y to be positive semidefinite.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> Y = [1 2; 2 1]\n2×2 Matrix{Int64}:\n 1  2\n 2  1\n\njulia> @constraint(model, X >= Y, PSDCone())\n[X[1,1] - 1  X[1,2] - 2;\n X[2,1] - 2  X[2,2] - 1] ∈ PSDCone()","category":"page"},{"location":"manual/constraints/#Symmetry","page":"Constraints","title":"Symmetry","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Solvers supporting PSD constraints usually expect to be given a matrix that is symbolically symmetric, that is, for which the expression in corresponding off-diagonal entries are the same. In our example, the expressions of entries (1, 2) and (2, 1) are respectively X[1,2] - 2 and X[2,1] - 2 which are different.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To bridge the gap between the constraint modeled and what the solver expects, solvers may add an equality constraint X[1,2] - 2 == X[2,1] - 2 to force symmetry. Use LinearAlgebra.Symmetric to explicitly tell the solver that the matrix is symmetric:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> import LinearAlgebra\n\njulia> Z = [X[1, 1] X[1, 2]; X[1, 2] X[2, 2]]\n2×2 Matrix{VariableRef}:\n X[1,1]  X[1,2]\n X[1,2]  X[2,2]\n\njulia> @constraint(model, LinearAlgebra.Symmetric(Z) >= 0, PSDCone())\n[X[1,1]  X[1,2];\n X[1,2]  X[2,2]] ∈ PSDCone()","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note that the lower triangular entries are ignored even if they are different so use it with caution:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, LinearAlgebra.Symmetric(X) >= 0, PSDCone())\n[X[1,1]  X[1,2];\n X[1,2]  X[2,2]] ∈ PSDCone()","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"(Note the (2, 1) element of the constraint is X[1,2], not X[2,1].)","category":"page"},{"location":"manual/constraints/#Complementarity-constraints","page":"Constraints","title":"Complementarity constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A mixed complementarity constraint F(x) ⟂ x consists of finding x in the interval [lb, ub], such that the following holds:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"F(x) == 0 if lb < x < ub\nF(x) >= 0 if lb == x\nF(x) <= 0 if x == ub","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP supports mixed complementarity constraints via complements(F(x), x) or F(x) ⟂ x in the @constraint macro. The interval set [lb, ub] is obtained from the variable bounds on x.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For example, to define the problem 2x - 1 ⟂ x with x ∈ [0, ∞), do:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x >= 0)\nx\n\njulia> @constraint(model, 2x - 1 ⟂ x)\n[2 x - 1, x] ∈ MathOptInterface.Complements(2)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"This problem has a unique solution at x = 0.5.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The perp operator ⟂ can be entered in most editors (and the Julia REPL) by typing \\perp<tab>.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"An alternative approach that does not require the ⟂ symbol uses the complements function as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, complements(2x - 1, x))\n[2 x - 1, x] ∈ MathOptInterface.Complements(2)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In both cases, the mapping F(x) is supplied as the first argument, and the matching variable x is supplied as the second.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Vector-valued complementarity constraints are also supported:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, -2 <= y[1:2] <= 2)\n2-element Vector{VariableRef}:\n y[1]\n y[2]\n\njulia> M = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> q = [5, 6]\n2-element Vector{Int64}:\n 5\n 6\n\njulia> @constraint(model, M * y + q ⟂ y)\n[y[1] + 2 y[2] + 5, 3 y[1] + 4 y[2] + 6, y[1], y[2]] ∈ MathOptInterface.Complements(4)","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/applications/power_systems.jl\"","category":"page"},{"location":"tutorials/applications/power_systems/#Power-Systems","page":"Power Systems","title":"Power Systems","text":"","category":"section"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Originally Contributed by: Yury Dvorkin and Miles Lubin","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"This tutorial demonstrates how to formulate basic power systems engineering models in JuMP.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"We will consider basic \"economic dispatch\" and \"unit commitment\" models without taking into account transmission constraints.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"For this tutorial, we use the following packages:","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"using JuMP\nimport DataFrames\nimport GLPK\nimport Plots\nimport StatsPlots","category":"page"},{"location":"tutorials/applications/power_systems/#Economic-dispatch","page":"Power Systems","title":"Economic dispatch","text":"","category":"section"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Economic dispatch (ED) is an optimization problem that minimizes the cost of supplying energy demand subject to operational constraints on power system assets. In its simplest modification, ED is an LP problem solved for an aggregated load and wind forecast and for a single infinitesimal moment.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Mathematically, the ED problem can be written as follows:","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"min sum_i in I c^g_i cdot g_i + c^w cdot w","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"where c_i and g_i are the incremental cost ($/MWh) and power output (MW) of the i^th generator, respectively, and c^w and w are the incremental cost ($/MWh) and wind power injection (MW), respectively.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Subject to the constraints:","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Minimum (g^min) and maximum (g^max) limits on power outputs of generators: g^min_i leq g_i leq g^max_i\nConstraint on the wind power injection: 0 leq w leq w^f where w and w^f are the wind power injection and wind power forecast, respectively.\nPower balance constraint: sum_i in I g_i + w = d^f where d^f is the demand forecast.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Further reading on ED models can be found in A. J. Wood, B. F. Wollenberg, and G. B. Sheblé, \"Power Generation, Operation and Control\", Wiley, 2013.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Define some input data about the test system.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"We define some thermal generators:","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"function ThermalGenerator(\n    min::Float64,\n    max::Float64,\n    fixed_cost::Float64,\n    variable_cost::Float64,\n)\n    return (\n        min = min,\n        max = max,\n        fixed_cost = fixed_cost,\n        variable_cost = variable_cost,\n    )\nend\n\ngenerators = [\n    ThermalGenerator(0.0, 1000.0, 1000.0, 50.0),\n    ThermalGenerator(300.0, 1000.0, 0.0, 100.0),\n]","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"A wind generator","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"WindGenerator(variable_cost::Float64) = (variable_cost = variable_cost,)\n\nwind_generator = WindGenerator(50.0)","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"And a scenario","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"function Scenario(demand::Float64, wind::Float64)\n    return (demand = demand, wind = wind)\nend\n\nscenario = Scenario(1500.0, 200.0)","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Create a function solve_ed, which solves the economic dispatch problem for a given set of input parameters.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"function solve_ed(generators::Vector, wind, scenario)\n    # Define the economic dispatch (ED) model\n    ed = Model(GLPK.Optimizer)\n    # Define decision variables\n    # power output of generators\n    N = length(generators)\n    @variable(ed, generators[i].min <= g[i = 1:N] <= generators[i].max)\n    # wind power injection\n    @variable(ed, 0 <= w <= scenario.wind)\n    # Define the objective function\n    @objective(\n        ed,\n        Min,\n        sum(generators[i].variable_cost * g[i] for i in 1:N) +\n        wind.variable_cost * w,\n    )\n    # Define the power balance constraint\n    @constraint(ed, sum(g[i] for i in 1:N) + w == scenario.demand)\n    # Solve statement\n    optimize!(ed)\n    # return the optimal value of the objective function and its minimizers\n    return (\n        g = value.(g),\n        w = value(w),\n        wind_spill = scenario.wind - value(w),\n        total_cost = objective_value(ed),\n    )\nend","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Solve the economic dispatch problem","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"solution = solve_ed(generators, wind_generator, scenario);\n\nprintln(\"Dispatch of Generators: \", solution.g, \" MW\")\nprintln(\"Dispatch of Wind: \", solution.w, \" MW\")\nprintln(\"Wind spillage: \", solution.wind_spill, \" MW\")\nprintln(\"Total cost: \\$\", solution.total_cost)","category":"page"},{"location":"tutorials/applications/power_systems/#Economic-dispatch-with-adjustable-incremental-costs","page":"Power Systems","title":"Economic dispatch with adjustable incremental costs","text":"","category":"section"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"In the following exercise we adjust the incremental cost of generator G1 and observe its impact on the total cost.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"function scale_generator_cost(g, scale)\n    return ThermalGenerator(g.min, g.max, g.fixed_cost, scale * g.variable_cost)\nend\n\nstart = time()\nc_g_scale_df = DataFrames.DataFrame(\n    # Scale factor\n    scale = Float64[],\n    # Dispatch of Generator 1 [MW]\n    dispatch_G1 = Float64[],\n    # Dispatch of Generator 2 [MW]\n    dispatch_G2 = Float64[],\n    # Dispatch of Wind [MW]\n    dispatch_wind = Float64[],\n    # Spillage of Wind [MW]\n    spillage_wind = Float64[],\n    # Total cost [$]\n    total_cost = Float64[],\n)\nfor c_g1_scale in 0.5:0.1:3.0\n    # Update the incremental cost of the first generator at every iteration.\n    new_generators = scale_generator_cost.(generators, [c_g1_scale, 1.0])\n    # Solve the ed problem with the updated incremental cost\n    sol = solve_ed(new_generators, wind_generator, scenario)\n    push!(\n        c_g_scale_df,\n        (c_g1_scale, sol.g[1], sol.g[2], sol.w, sol.wind_spill, sol.total_cost),\n    )\nend\nprint(string(\"elapsed time: \", time() - start, \" seconds\"))","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"c_g_scale_df","category":"page"},{"location":"tutorials/applications/power_systems/#Modifying-the-JuMP-model-in-place","page":"Power Systems","title":"Modifying the JuMP model in-place","text":"","category":"section"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Note that in the previous exercise we entirely rebuilt the optimization model at every iteration of the internal loop, which incurs an additional computational burden. This burden can be alleviated if instead of re-building the entire model, we modify a specific constraint(s) or the objective function, as it shown in the example below.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Compare the computing time in case of the above and below models.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"function solve_ed_inplace(\n    generators::Vector,\n    wind,\n    scenario,\n    scale::AbstractVector{Float64},\n)\n    obj_out = Float64[]\n    w_out = Float64[]\n    g1_out = Float64[]\n    g2_out = Float64[]\n    # This function only works for two generators\n    @assert length(generators) == 2\n    ed = Model(GLPK.Optimizer)\n    N = length(generators)\n    @variable(ed, generators[i].min <= g[i = 1:N] <= generators[i].max)\n    @variable(ed, 0 <= w <= scenario.wind)\n    @objective(\n        ed,\n        Min,\n        sum(generators[i].variable_cost * g[i] for i in 1:N) +\n        wind.variable_cost * w,\n    )\n    @constraint(ed, sum(g[i] for i in 1:N) + w == scenario.demand)\n    for c_g1_scale in scale\n        @objective(\n            ed,\n            Min,\n            c_g1_scale * generators[1].variable_cost * g[1] +\n            generators[2].variable_cost * g[2] +\n            wind.variable_cost * w,\n        )\n        optimize!(ed)\n        push!(obj_out, objective_value(ed))\n        push!(w_out, value(w))\n        push!(g1_out, value(g[1]))\n        push!(g2_out, value(g[2]))\n    end\n    df = DataFrames.DataFrame(\n        scale = scale,\n        dispatch_G1 = g1_out,\n        dispatch_G2 = g2_out,\n        dispatch_wind = w_out,\n        spillage_wind = scenario.wind .- w_out,\n        total_cost = obj_out,\n    )\n    return df\nend\n\nstart = time()\ninplace_df = solve_ed_inplace(generators, wind_generator, scenario, 0.5:0.1:3.0)\nprint(string(\"elapsed time: \", time() - start, \" seconds\"))","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Adjusting specific constraints or the objective function is faster than re-building the entire model.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"inplace_df","category":"page"},{"location":"tutorials/applications/power_systems/#Inefficient-usage-of-wind-generators","page":"Power Systems","title":"Inefficient usage of wind generators","text":"","category":"section"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"The economic dispatch problem does not perform commitment decisions and, thus, assumes that all generators must be dispatched at least at their minimum power output limit. This approach is not cost efficient and may lead to absurd decisions. For example, if d = sum_i in I g^min_i, the wind power injection must be zero, i.e. all available wind generation is spilled, to meet the minimum power output constraints on generators.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"In the following example, we adjust the total demand and observed how it affects wind spillage.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"demand_scale_df = DataFrames.DataFrame(\n    demand = Float64[],\n    dispatch_G1 = Float64[],\n    dispatch_G2 = Float64[],\n    dispatch_wind = Float64[],\n    spillage_wind = Float64[],\n    total_cost = Float64[],\n)\n\nfunction scale_demand(scenario, scale)\n    return Scenario(scale * scenario.demand, scenario.wind)\nend\n\nfor demand_scale in 0.2:0.1:1.5\n    new_scenario = scale_demand(scenario, demand_scale)\n    sol = solve_ed(generators, wind_generator, new_scenario)\n    push!(\n        demand_scale_df,\n        (\n            new_scenario.demand,\n            sol.g[1],\n            sol.g[2],\n            sol.w,\n            sol.wind_spill,\n            sol.total_cost,\n        ),\n    )\nend\n\ndemand_scale_df","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"dispatch_plot = StatsPlots.@df(\n    demand_scale_df,\n    Plots.plot(\n        :demand,\n        [:dispatch_G1, :dispatch_G2],\n        labels = [\"G1\" \"G2\"],\n        title = \"Thermal Dispatch\",\n        legend = :bottomright,\n        linewidth = 3,\n        xlabel = \"Demand\",\n        ylabel = \"Dispatch [MW]\",\n    ),\n)\n\nwind_plot = StatsPlots.@df(\n    demand_scale_df,\n    Plots.plot(\n        :demand,\n        [:dispatch_wind, :spillage_wind],\n        labels = [\"Dispatch\" \"Spillage\"],\n        title = \"Wind\",\n        legend = :bottomright,\n        linewidth = 3,\n        xlabel = \"Demand [MW]\",\n        ylabel = \"Energy [MW]\",\n    ),\n)\n\nPlots.plot(dispatch_plot, wind_plot)","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"This particular drawback can be overcome by introducing binary decisions on the \"on/off\" status of generators. This model is called unit commitment and considered later in these notes.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"For further reading on the interplay between wind generation and the minimum power output constraints of generators, we refer interested readers to R. Baldick, \"Wind and Energy Markets: A Case Study of Texas,\" IEEE Systems Journal, vol. 6, pp. 27-34, 2012.","category":"page"},{"location":"tutorials/applications/power_systems/#Unit-commitment","page":"Power Systems","title":"Unit commitment","text":"","category":"section"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"The Unit Commitment (UC) model can be obtained from ED model by introducing binary variable associated with each generator. This binary variable can attain two values: if it is \"1\", the generator is synchronized and, thus, can be dispatched, otherwise, i.e. if the binary variable is \"0\", that generator is not synchronized and its power output is set to 0.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"To obtain the mathematical formulation of the UC model, we will modify the constraints of the ED model as follows:","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"g^min_i cdot u_ti leq g_i leq g^max_i cdot u_ti","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"where u_i in 01 In this constraint, if u_i = 0, then g_i  = 0. On the other hand, if u_i = 1, then g^min_i leq g_i leq g^max_i.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"For further reading on the UC problem we refer interested readers to G. Morales-Espana, J. M. Latorre, and A. Ramos, \"Tight and Compact MILP Formulation for the Thermal Unit Commitment Problem,\" IEEE Transactions on Power Systems, vol. 28, pp. 4897-4908, 2013.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"In the following example we convert the ED model explained above to the UC model.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"function solve_uc(generators::Vector, wind, scenario)\n    uc = Model(GLPK.Optimizer)\n    N = length(generators)\n    @variable(uc, generators[i].min <= g[i = 1:N] <= generators[i].max)\n    @variable(uc, 0 <= w <= scenario.wind)\n    @constraint(uc, sum(g[i] for i in 1:N) + w == scenario.demand)\n    # !!! New: add binary on-off variables for each generator\n    @variable(uc, u[i = 1:N], Bin)\n    @constraint(uc, [i = 1:N], g[i] <= generators[i].max * u[i])\n    @constraint(uc, [i = 1:N], g[i] >= generators[i].min * u[i])\n    @objective(\n        uc,\n        Min,\n        sum(generators[i].variable_cost * g[i] for i in 1:N) +\n        wind.variable_cost * w +\n        # !!! new\n        sum(generators[i].fixed_cost * u[i] for i in 1:N)\n    )\n    optimize!(uc)\n    status = termination_status(uc)\n    if status != OPTIMAL\n        return (status = status,)\n    end\n    return (\n        status = status,\n        g = value.(g),\n        w = value(w),\n        wind_spill = scenario.wind - value(w),\n        u = value.(u),\n        total_cost = objective_value(uc),\n    )\nend","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Solve the economic dispatch problem","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"solution = solve_uc(generators, wind_generator, scenario)\n\nprintln(\"Dispatch of Generators: \", solution.g, \" MW\")\nprintln(\"Commitments of Generators: \", solution.u)\nprintln(\"Dispatch of Wind: \", solution.w, \" MW\")\nprintln(\"Wind spillage: \", solution.wind_spill, \" MW\")\nprintln(\"Total cost: \\$\", solution.total_cost)","category":"page"},{"location":"tutorials/applications/power_systems/#Unit-commitment-as-a-function-of-demand","page":"Power Systems","title":"Unit commitment as a function of demand","text":"","category":"section"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"After implementing the UC model, we can now assess the interplay between the minimum power output constraints on generators and wind generation.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"uc_df = DataFrames.DataFrame(\n    demand = Float64[],\n    commitment_G1 = Float64[],\n    commitment_G2 = Float64[],\n    dispatch_G1 = Float64[],\n    dispatch_G2 = Float64[],\n    dispatch_wind = Float64[],\n    spillage_wind = Float64[],\n    total_cost = Float64[],\n)\n\nfor demand_scale in 0.2:0.1:1.5\n    new_scenario = scale_demand(scenario, demand_scale)\n    sol = solve_uc(generators, wind_generator, new_scenario)\n    if sol.status == OPTIMAL\n        push!(\n            uc_df,\n            (\n                new_scenario.demand,\n                sol.u[1],\n                sol.u[2],\n                sol.g[1],\n                sol.g[2],\n                sol.w,\n                sol.wind_spill,\n                sol.total_cost,\n            ),\n        )\n    end\n    println(\"Status: $(sol.status) for demand_scale = $(demand_scale)\")\nend","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"uc_df","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"commitment_plot = StatsPlots.@df(\n    uc_df,\n    Plots.plot(\n        :demand,\n        [:commitment_G1, :commitment_G2],\n        labels = [\"G1\" \"G2\"],\n        title = \"Committment\",\n        legend = :bottomright,\n        linewidth = 3,\n        xlabel = \"Demand [MW]\",\n        ylabel = \"Commitment decision {0, 1}\",\n    ),\n)\n\ndispatch_plot = StatsPlots.@df(\n    uc_df,\n    Plots.plot(\n        :demand,\n        [:dispatch_G1, :dispatch_G2, :dispatch_wind],\n        labels = [\"G1\" \"G2\" \"Wind\"],\n        title = \"Dispatch [MW]\",\n        legend = :bottomright,\n        linewidth = 3,\n        xlabel = \"Demand\",\n        ylabel = \"Dispatch [MW]\",\n    ),\n)\n\nPlots.plot(commitment_plot, dispatch_plot)","category":"page"},{"location":"tutorials/applications/power_systems/#Nonlinear-economic-dispatch","page":"Power Systems","title":"Nonlinear economic dispatch","text":"","category":"section"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"As a final example, we modify our economic dispatch problem in two ways:","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"The thermal cost function is user-defined\nThe output of the wind is only the square-root of the dispatch","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"import Ipopt\n\n\"\"\"\n    thermal_cost_function(g)\n\nA user-defined thermal cost function in pure-Julia! You can include\nnonlinearities, and even things like control flow.\n\n!!! warning\n    It's still up to you to make sure that the function has a meaningful\n    derivative.\n\"\"\"\nfunction thermal_cost_function(g)\n    if g <= 500\n        return g\n    else\n        return g + 1e-2 * (g - 500)^2\n    end\nend\n\nfunction solve_nonlinear_ed(\n    generators::Vector,\n    wind,\n    scenario;\n    silent::Bool = false,\n)\n    model = Model(Ipopt.Optimizer)\n    if silent\n        set_silent(model)\n    end\n    register(model, :tcf, 1, thermal_cost_function; autodiff = true)\n    N = length(generators)\n    @variable(model, generators[i].min <= g[i = 1:N] <= generators[i].max)\n    @variable(model, 0 <= w <= scenario.wind)\n    @NLobjective(\n        model,\n        Min,\n        sum(generators[i].variable_cost * tcf(g[i]) for i in 1:N) +\n        wind.variable_cost * w,\n    )\n    @NLconstraint(model, sum(g[i] for i in 1:N) + sqrt(w) == scenario.demand)\n    optimize!(model)\n    return (\n        g = value.(g),\n        w = value(w),\n        wind_spill = scenario.wind - value(w),\n        total_cost = objective_value(model),\n    )\nend\n\nsolution = solve_nonlinear_ed(generators, wind_generator, scenario)","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Now let's see how the wind is dispatched as a function of the cost:","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"wind_cost = 0.0:1:100\nwind_dispatch = Float64[]\nfor c in wind_cost\n    sol = solve_nonlinear_ed(\n        generators,\n        WindGenerator(c),\n        scenario;\n        silent = true,\n    )\n    push!(wind_dispatch, sol.w)\nend\n\nPlots.plot(\n    wind_cost,\n    wind_dispatch,\n    xlabel = \"Cost\",\n    ylabel = \"Dispatch [MW]\",\n    label = false,\n)","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"moi/release_notes/#Release-notes","page":"Release notes","title":"Release notes","text":"","category":"section"},{"location":"moi/release_notes/#v0.10.7-(January-5,-2022)","page":"Release notes","title":"v0.10.7 (January 5, 2022)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes.","category":"page"},{"location":"moi/release_notes/#New-features","page":"Release notes","title":"New features","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added test for modifying the constant vector in a VectorAffineFunction-in-Zeros constraint.","category":"page"},{"location":"moi/release_notes/#Bug-fixes","page":"Release notes","title":"Bug fixes","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed the order in which sets are added to a LazyBridgeOptimizer. Compared to v0.10.6, this may result in bridged models being created with a different number (and order) of variables and constraints. However, it was necessary to fix cases which were previously rejected as unsupported, even though there was a valid bridge transformation.\nFixed an error message in FileFormats.CBF\nFixed comparison in test_linear_integration_Interval\nFixed errors for ConstraintPrimal in a CachingOptimizer\nFixed printing of models with non-Float64 coefficients.","category":"page"},{"location":"moi/release_notes/#Performance-and-maintenance","page":"Release notes","title":"Performance and maintenance","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Various improvements to reduce time-to-first-solve latency\nImproved error message when an optimizer does not support compute_conflict!","category":"page"},{"location":"moi/release_notes/#v0.10.6-(November-30,-2021)","page":"Release notes","title":"v0.10.6 (November 30, 2021)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes.","category":"page"},{"location":"moi/release_notes/#New-features-2","page":"Release notes","title":"New features","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added new documentation and tests for infeasibility certificates\nAdded a version control system for the tests in MOI.Test.runtests. Pass exclude_tests_after = v\"0.10.5\" to run tests added in v0.10.5 and earlier.\nMOI.Test.runtests now supports generic number types. To specify the number type T, pass MOI.Test.Config(T).\nAdded infeasible_status to MOI.Test.Config for solvers which return LOCALLY_INFEASIBLE\nCachingOptimizers now use a fallback for ConstraintPrimal. This should enable solvers using a CachingOptimizer to pass tests requiring ConstraintPrimal.","category":"page"},{"location":"moi/release_notes/#Bug-fixes-2","page":"Release notes","title":"Bug fixes","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a StackOverflow bug in copy_to\nFixed error thrown when nonconvex quadratic constraints cannot be bridged\nFixed a bug in copy_to for FileFormats.NL.Model\nFixed a bug in FileFormats.NL when printing large integers\nRemove a common test failure for LowerBoundAlreadySet tests\nUtilities.num_rows is now exported\nRemove parts of failing test_model_copy_to_xxx tests due to bridges","category":"page"},{"location":"moi/release_notes/#v0.10.5-(November-7,-2021)","page":"Release notes","title":"v0.10.5 (November 7, 2021)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes.","category":"page"},{"location":"moi/release_notes/#Maintenance","page":"Release notes","title":"Maintenance","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Make normalize_and_add_constraint more flexible\nFix getter in UniversalFallback\nUpdate paper BibTeX\nFix test_solve_conflict_zeroone_ii","category":"page"},{"location":"moi/release_notes/#v0.10.4-(October-26,-2021)","page":"Release notes","title":"v0.10.4 (October 26, 2021)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes.","category":"page"},{"location":"moi/release_notes/#New-features-3","page":"Release notes","title":"New features","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Add SolverVersion attribute\nAdd new tests:\ntest_solve_conflict_zeroone_ii\ntest_nonlinear_objective\nUtilities.VariablesContainer now supports ConstraintFunction and ConstraintSet\nThe documentation is now available as a PDF","category":"page"},{"location":"moi/release_notes/#Maintenance-2","page":"Release notes","title":"Maintenance","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Update to MutableArithmetics 0.3\nVarious improvements to the documentation","category":"page"},{"location":"moi/release_notes/#v0.10.3-(September-18,-2021)","page":"Release notes","title":"v0.10.3 (September 18, 2021)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes.","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fix bug which prevented callbacks from working through a CachingOptimizer\nFix bug in Test submodule","category":"page"},{"location":"moi/release_notes/#v0.10.2-(September-16,-2021)","page":"Release notes","title":"v0.10.2 (September 16, 2021)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes.","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Updated MathOptFormat to v1.0\nUpdated JSONSchema to v1.0\nAdded Utilities.set_with_dimension\nAdded two-argument optimize!(::AbstractOptimizer, ::ModelLike)\nThe experimental feature copy_to_and_optimize! has been removed\nDet bridges now support getting ConstraintFunction and ConstraintSet\nVarious minor bug fixes identified by improved testing","category":"page"},{"location":"moi/release_notes/#v0.10.1-(September-8,-2021)","page":"Release notes","title":"v0.10.1 (September 8, 2021)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes.","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Various fixes to MOI.Test","category":"page"},{"location":"moi/release_notes/#v0.10.0-(September-6,-2021)","page":"Release notes","title":"v0.10.0 (September 6, 2021)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"MOI v0.10 is a significant breaking release. There are a large number of user-visible breaking changes and code refactors, as well as a substantial number of new features.","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes.","category":"page"},{"location":"moi/release_notes/#Breaking-changes-in-MOI","page":"Release notes","title":"Breaking changes in MOI","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"SingleVariable has been removed; use VariableIndex instead\nSingleVariableConstraintNameError has been renamed to VariableIndexConstraintNameError\nSettingSingleVariableFunctionNotAllowed has been renamed to SettingVariableIndexFunctionNotAllowed\nVariableIndex constraints should not support ConstraintName\nVariableIndex constraints should not support ConstraintBasisStatus; implement VariableBasisStatus instead\nListOfConstraints has been renamed to ListOfConstraintTypesPresent\nListOfConstraintTypesPresent should now return Tuple{Type,Type} instead of Tuple{DataType,DataType}\nSolveTime has been renamed to SolveTimeSec\nIndicatorSet has been renamed to Indicator\nRawParameter has been renamed to RawOptimizerAttribute and now takes String instead of Any as the only argument\nThe .N field in result attributes has been renamed to .result_index\nThe .variable_index field in ScalarAffineTerm has been renamed to .variable\nThe .variable_index_1 field in ScalarQuadraticTerm has been renamed to .variable_1\nThe .variable_index_2 field in ScalarQuadraticTerm has been renamed to .variable_2\nThe order of affine_terms and quadratic_terms in ScalarQuadraticFunction and VectorQuadraticFunction have been reversed. Both functions now accept quadratic, affine, and constant terms in that order.\nThe index_value function has been removed. Use .value instead.\nisapprox has been removed for SOS1 and SOS2.\nThe dimension argument to Complements(dimension::Int) should now be the length of the corresponding function, instead of half the length. An ArgumentError is thrown if dimension is not even.\ncopy_to no longer takes keyword arguments:\ncopy_names: now copy names if they are supported by the destination solver\nfilter_constraints: use Utilities.ModelFilter instead\nwarn_attributes: never warn about optimizer attributes","category":"page"},{"location":"moi/release_notes/#Breaking-changes-in-Bridges","page":"Release notes","title":"Breaking changes in Bridges","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Constraint.RSOCBridge has been renamed to Constraint.RSOCtoSOCBridge\nConstraint.SOCRBridge has been renamed to Constraint.SOCtoRSOCBridge\nBridges now return vectors that can be modified by the user. Previously, some bridges returned views instead of copies.\nBridges.IndexInVector has been unified into a single type. Previously, there was a different type for each submodule within Bridges\nThe signature of indicator bridges has been fixed. Use MOI.Bridges.Constraint.IndicatortoSOS1{Float64}(model).","category":"page"},{"location":"moi/release_notes/#Breaking-changes-in-FileFormats","page":"Release notes","title":"Breaking changes in FileFormats","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"FileFormats.MOF.Model no longer accepts validate argument. Use the JSONSchema package to validate the MOF file. See the documentation for more information.","category":"page"},{"location":"moi/release_notes/#Breaking-changes-in-Utilities","page":"Release notes","title":"Breaking changes in Utilities","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"The datastructure of Utilities.Model (and models created with Utilities.@model) has been significantly refactored in a breaking way. This includes the way that objecive functions and variable-related information is stored.\nUtilities.supports_default_copy has been renamed to supports_incremental_interface\nUtilities.automatic_copy_to has been renamed to Utilities.default_copy_to\nThe allocate-load API has been removed\nCachingOptimizers are now initialized as EMPTY_OPTIMIZER instead of ATTACHED_OPTIMIZER. If your code relies on the optimizer being attached, call MOIU.attach_optimizer(model) after creation.\nThe field names of Utilities.IndexMap have been renamed to var_map and con_map. Accessing these fields directly is considered a private detail that may change. Use the public getindex and setindex! API instead.\nThe size argument to Utilities.CleverDicts.CleverDict(::Integer) has been removed.\nThe size argument to Utilities.IndexMap(::Integer) has been removed.\nUtilities.DoubleDicts have been significantly refactored. Consult the source code for details.\nUtilities.test_models_equal has been moved to MOI.Test","category":"page"},{"location":"moi/release_notes/#Breaking-changes-in-Test","page":"Release notes","title":"Breaking changes in Test","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"MOI.Test has been renamed to MOI.DeprecatedTest\nAn entirely new MOI.Test submodule has been written. See the documentation for details. The new MOI.Test submodule may find many bugs in the implementations of existing solvers that were previously untested.","category":"page"},{"location":"moi/release_notes/#Other-changes:","page":"Release notes","title":"Other changes:","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"attribute_value_type has been added\ncopy_to_and_optimize! has been added\nVariableBasisStatus has been added\nprint(model) now prints a human-readable description of the model\nVarious improvements to the FileFormats submodule\nFileFormats.CBF was refactored and received bugfixes\nSupport for MathOptFormat v0.6 was added in FileFormats.MOF\nFileFormats.MPS has had bugfixes and support for more features such as OBJSENSE and objective constants.\nFileFormats.NL has been added to support nonlinear files\nImproved type inference throughout to reduce latency","category":"page"},{"location":"moi/release_notes/#Updating","page":"Release notes","title":"Updating","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"A helpful script when updating is:","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"for (root, dirs, files) in walkdir(\".\")\n    for file in files\n        if !endswith(file, \".jl\")\n            continue\n        end\n        path = joinpath(root, file)\n        s = read(path, String)\n        for pair in [\n            \".variable_index\" => \".variable\",\n            \"RawParameter\" => \"RawOptimizerAttribute\",\n            \"ListOfConstraints\" => \"ListOfConstraintTypesPresent\",\n            \"TestConfig\" => \"Config\",\n            \"attr.N\" => \"attr.result_index\",\n            \"SolveTime\" => \"SolveTimeSec\",\n            \"DataType\" => \"Type\",\n            \"Utilities.supports_default_copy_to\" =>\n                \"supports_incremental_interface\",\n            \"SingleVariableConstraintNameError\" =>\n                \"VariableIndexConstraintNameError\",\n            \"SettingSingleVariableFunctionNotAllowed\" =>\n                \"SettingVariableIndexFunctionNotAllowed\",\n            \"automatic_copy_to\" => \"default_copy_to\",\n        ]\n            s = replace(s, pair)\n        end\n        write(path, s)\n    end\nend","category":"page"},{"location":"moi/release_notes/#v0.9.22-(May-22,-2021)","page":"Release notes","title":"v0.9.22 (May 22, 2021)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"This release contains backports from the ongoing development of the v0.10 release. For a detailed list of the closed issues and pull requests from this release, see the tag notes.","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Improved type inference in Utilities, Bridges and FileFormats submodules to reduce latency.\nImproved performance of Utilities.is_canonical.\nFixed Utilities.pass_nonvariable_constraints with bridged variables.\nFixed performance regression of Utilities.Model.\nFixed ordering of objective setting in parser.","category":"page"},{"location":"moi/release_notes/#v0.9.21-(April-23,-2021)","page":"Release notes","title":"v0.9.21 (April 23, 2021)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes.","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added supports_shift_constant.\nImprove performance of bridging quadratic constraints.\nAdd precompilation statements.\nLarge improvements to the documentation.\nFix a variety of inference issues, benefiting precompilation and reducing initial latency.\nRawParameters are now ignored when resetting a CachingOptimizer. Previously, changing the underlying optimizer after RawParameters were set would throw an errror.\nUtilities.AbstractModel is being refactored. This may break users interacting with private fields of a model generated using @model.","category":"page"},{"location":"moi/release_notes/#v0.9.20-(February-20,-2021)","page":"Release notes","title":"v0.9.20 (February 20, 2021)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes.","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Improved performance of Utilities.ScalarFunctionIterator\nAdded support for compute_conflict to MOI layers\nAdded test with zero off-diagonal quadratic term in objective\nFixed double deletion of nested bridged SingleVariable/VectorOfVariables constraints\nFixed modification of un-set objective\nFixed function modification with duplicate terms\nMade unit tests abort without failing if the problem class is not supported\nFormatted code with JuliaFormatter\nClarified BasisStatusCode's docstring","category":"page"},{"location":"moi/release_notes/#v0.9.19-(December-1,-2020)","page":"Release notes","title":"v0.9.19 (December 1, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes.","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added CallbackNodeStatus attribute\nAdded bridge from GreaterThan or LessThan to Interval\nAdded tests for infeasibility certificates and double optimize\nFixed support for Julia v1.6\nRe-organized MOI docs and added documentation for adding a test","category":"page"},{"location":"moi/release_notes/#v0.9.18-(November-3,-2020)","page":"Release notes","title":"v0.9.18 (November 3, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes.","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Various improvements for working with complex numbers\nAdded GeoMeantoRelEntrBridge to bridge a geomean constraint to a relative entropy constraint","category":"page"},{"location":"moi/release_notes/#v0.9.17-(September-21,-2020)","page":"Release notes","title":"v0.9.17 (September 21, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes.","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed CleverDict with variable of negative index value\nImplement supports_add_constrained_variable for MockOptimizer","category":"page"},{"location":"moi/release_notes/#v0.9.16-(September-17,-2020)","page":"Release notes","title":"v0.9.16 (September 17, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes.","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Various fixes:\n32-bit support\nCleverDict with abstract value type\nChecks in test suite","category":"page"},{"location":"moi/release_notes/#v0.9.15-(September-14,-2020)","page":"Release notes","title":"v0.9.15 (September 14, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"For a detailed list of the closed issues and pull requests from this release, see the tag notes.","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"A summary of changes are as follows:","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Bridges improvements:\n(R)SOCtoNonConvexQuad bridge\nZeroOne bridge\nUse supports_add_constrained_variable in LazyBridgeOptimizer\nExposed VariableBridgeCost and ConstraintBridgeCost attributes\nPrioritize constraining variables on creation according to these costs\nRefactor bridge debugging\nLarge performance improvements across all submodules\nLots of documentation improvements\nFileFormats improvements:\nUpdate MathOptFormat to v0.5\nFix supported objectives in FileFormats\nTesting improvements:\nAdd name option for basic_constraint_test\nBug fixes and missing methods\nAdd length for iterators\nFix bug with duplicate terms\nFix order of LinearOfConstraintIndices","category":"page"},{"location":"moi/release_notes/#v0.9.14-(May-30,-2020)","page":"Release notes","title":"v0.9.14 (May 30, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Add a solver-independent interface for accessing the set of conflicting constraints an Irreducible Inconsistent Subsystem (#1056).\nBump JSONSchema dependency from v0.2 to v0.3 (#1090).\nDocumentation improvements:\nFix typos (#1054, #1060, #1061, #1064, #1069, #1070).\nRemove the outdated recommendation for a package implementing MOI for a solver XXX to be called MathOptInterfaceXXX (#1087).\nUtilities improvements:\nFix is_canonical for quadratic functions (#1081, #1089).\nImplement add_constrained_variable[s] for CachingOptimizer so that it is added as constrained variables to the underlying optimizer (#1084).\nAdd support for custom objective functions for UniversalFallback (#1086).\nDeterministic ordering of constraints in UniversalFallback (#1088).\nTesting improvements:\nAdd NormOneCone/NormInfinityCone tests (#1045).\nBridges improvements:\nAdd bridges from Semiinteger and Semicontinuous (#1059).\nImplement getting ConstraintSet for Variable.FlipSignBridge (#1066).\nFix setting ConstraintFunction for Constraint.ScalarizeBridge (#1093).\nFix NormOne/NormInf bridges with nonzero constants (#1045).\nFix StackOverflow in debug (#1063).\nFileFormats improvements:\n[SDPA] Implement the extension for integer variables (#1079).\n[SDPA] Ignore comments aftere m and nblocks and detect dat-s extension (#1077).\n[SDPA] No scaling of off-diagonal coefficient (#1076).\n[SDPA] Add missing negation of constant (#1075).","category":"page"},{"location":"moi/release_notes/#v0.9.13-(March-24,-2020)","page":"Release notes","title":"v0.9.13 (March 24, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added tests for Semicontinuous and Semiinteger variables (#1033).\nAdded tests for using ExprGraphs from NLP evaluators (#1043).\nUpdate version compatibilities of depedencies (#1034, #1051, #1052).\nFixed typos in documentation (#1044).","category":"page"},{"location":"moi/release_notes/#v0.9.12-(February-28,-2020)","page":"Release notes","title":"v0.9.12 (February 28, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed writing NLPBlock in MathOptFormat (#1037).\nFixed MockOptimizer for result attributes with non-one result index (#1039).\nUpdated test template with instantiate (#1032).","category":"page"},{"location":"moi/release_notes/#v0.9.11-(February-21,-2020)","page":"Release notes","title":"v0.9.11 (February 21, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Add an option for the model created by Utilities.@model to be a subtype of AbstractOptimizer (#1031).\nDescribed dual cone in docstrings of GeoMeanCone and RelativeEntropyCone (#1018, #1028).\nFixed typos in documentation (#1022, #1024).\nFixed warning of unsupported attribute (#1027).\nAdded more rootdet/logdet conic tests (#1026).\nImplemented ConstraintDual for Constraint.GeoMeanBridge, Constraint.RootDetBridge and Constraint.LogDetBridge and test duals in tests with GeoMeanCone and RootDetConeTriangle and LogDetConeTriangle cones (#1025, #1026).","category":"page"},{"location":"moi/release_notes/#v0.9.10-(January-31,-2020)","page":"Release notes","title":"v0.9.10 (January 31, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added OptimizerWithAttributes grouping an optimizer constructor and a list of optimizer attributes (#1008).\nAdded RelativeEntropyCone with corresponding bridge into exponential cone constraints (#993).\nAdded NormSpectralCone and NormNuclearCone with corresponding bridges into positive semidefinite constraints (#976).\nAdded supports_constrained_variable(s) (#1004).\nAdded dual_set_type (#1002).\nAdded tests for vector specialized version of delete (#989, #1011).\nAdded PSD3 test (#1007).\nClarified dual solution of Tests.pow1v and Tests.pow1f (#1013).\nAdded support for EqualTo and Zero in Bridges.Constraint.SplitIntervalBridge (#1005).\nFixed Utilities.vectorize for empty vector (#1003).\nFixed free variables in LP writer (#1006).","category":"page"},{"location":"moi/release_notes/#v0.9.9-(December-29,-2019)","page":"Release notes","title":"v0.9.9 (December 29, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Incorporated MathOptFormat.jl as the FileFormats submodule. FileFormats provides readers and writers for a number of standard file formats and MOF, a file format specialized for MOI (#969).\nImproved performance of deletion of vector of variables in MOI.Utilities.Model (#983).\nUpdated to MutableArithmetics v0.2 (#981).\nAdded MutableArithmetics.promote_operation allocation tests (#975).\nFixed inference issue on Julia v1.1 (#982).","category":"page"},{"location":"moi/release_notes/#v0.9.8-(December-19,-2019)","page":"Release notes","title":"v0.9.8 (December 19, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Implemented MutableArithmetics API (#924).\nFixed callbacks with CachingOptimizer (#959).\nFixed MOI.dimension for MOI.Complements (#948).\nAdded fallback for add_variables (#972).\nAdded is_diagonal_vectorized_index utility (#965).\nImproved linear constraints display in manual (#963, #964).\nBridges improvements:\nAdded IndicatorSet to SOS1 bridge (#877).\nAdded support for starting values for Variable.VectorizeBridge (#944).\nFixed MOI.add_constraints with non-bridged variable constraint on bridged variable (#951).\nFixed corner cases and docstring of geomean bridge (#961, #962, #966).\nFixed choice between variable or constraint bridges for constrained variables (#973).\nImprove performance of bridge shortest path (#945, #946, #956).\nAdded docstring for test_delete_bridge (#954).\nAdded Variable bridge tests (#952).","category":"page"},{"location":"moi/release_notes/#v0.9.7-(October-30,-2019)","page":"Release notes","title":"v0.9.7 (October 30, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Implemented _result_index_field for NLPBlockDual (#934).\nFixed copy of model with starting values for vector constraints (#941).\nBridges improvements:\nImproved performance of add_bridge and added has_bridge (#935).\nAdded AbstractSetMapBridge for bridges between sets S1, S2 such that there is a linear map A such that A*S1 = S2 (#933).\nAdded support for starting values for FlipSignBridge, VectorizeBridge, ScalarizeBridge, SlackBridge, SplitIntervalBridge, RSOCBridge, SOCRBridge NormInfinityBridge, SOCtoPSDBridge and RSOCtoPSDBridge (#933, #936, #937, #938, #939).","category":"page"},{"location":"moi/release_notes/#v0.9.6-(October-25,-2019)","page":"Release notes","title":"v0.9.6 (October 25, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added complementarity constraints (#913).\nAllowed ModelLike objects as value of attributes (#928).\nTesting improvements:\nAdded dual_objective_value option to MOI.Test.TestConfig (#922).\nAdded InvalidIndex tests in basic_constraint_tests (#921).\nAdded tests for the constant term in indicator constraint (#929).\nBridges improvements:\nAdded support for starting values for functionize bridges (#923).\nAdded variable indices context to variable bridges (#920).\nFixed a typo in printing o debug_supports (#927).","category":"page"},{"location":"moi/release_notes/#v0.9.5-(October-9,-2019)","page":"Release notes","title":"v0.9.5 (October 9, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Clarified PrimalStatus/DualStatus to be NO_SOLUTION if result_index is out of bounds (#912).\nAdded tolerance for checks  and use ResultCount + 1 for the result_index in MOI.Test.solve_result_status (#910, #917).\nUse 0.5 instead of 2.0 for power in PowerCone in basic_constraint_test (#916).\nBridges improvements:\nAdded debug utilities for unsupported variable/constraint/objective (#861).\nFixed deletion of variables in bridged VectorOfVariables constraints (#909).\nFixed result_index with objective bridges (#911).","category":"page"},{"location":"moi/release_notes/#v0.9.4-(October-2,-2019)","page":"Release notes","title":"v0.9.4 (October 2, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added solver-independent MIP callbacks (#782).\nImplements submit for Utilities.CachingOptimizer and Bridges.AbstractBridgeOptimizer (#906).\nAdded tests for result count of solution attributes (#901, #904).\nAdded NumberOfThreads attribute (#892).\nAdded Utilities.get_bounds to get the bounds on a variable (#890).\nAdded a note on duplicate coefficients in documentation (#581).\nAdded result index in ConstraintBasisStatus (#898).\nAdded extension dictionary to Utilities.Model (#884, #895).\nFixed deletion of constrained variables for CachingOptimizer (#905).\nImplemented Utilities.shift_constraint for Test.UnknownScalarSet (#896).\nBridges improvements:\nAdded Variable.RSOCtoSOCBridge (#907).\nImplemented MOI.get for ConstraintFunction/ConstraintSet for Bridges.Constraint.SquareBridge (#899).","category":"page"},{"location":"moi/release_notes/#v0.9.3-(September-20,-2019)","page":"Release notes","title":"v0.9.3 (September 20, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed ambiguity detected in Julia v1.3 (#891, #893).\nFixed missing sets from ListOfSupportedConstraints (#880).\nFixed copy of VectorOfVariables constraints with duplicate indices (#886).\nAdded extension dictionary to MOIU.Model (#884).\nImplemented MOI.get for function and set for GeoMeanBridge (#888).\nUpdated documentation for SingleVariable indices and bridges (#885).\nTesting improvements:\nAdded more comprehensive tests for names (#882).\nAdded tests for SingleVariable duals (#883).\nAdded tests for DualExponentialCone and DualPowerCone (#873).\nImprovements for arbitary coefficient type:\nFixed == for sets with mutable fields (#887).\nRemoved some Float64 assumptions in bridges (#878).\nAutomatic selection of Constraint.[Scalar|Vector]FunctionizeBridge (#889).","category":"page"},{"location":"moi/release_notes/#v0.9.2-(September-5,-2019)","page":"Release notes","title":"v0.9.2 (September 5, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Implemented model printing for MOI.ModelLike and specialized it for models defined in MOI (864).\nGeneralized contlinear tests for arbitary coefficient type (#855).\nFixed supports_constraint for Semiinteger and Semicontinuous and supports for ObjectiveFunction (#859).\nFixed Allocate-Load copy for single variable constraints (#856).\nBridges improvements:\nAdd objective bridges (#789).\nFixed Variable.RSOCtoPSDBridge for dimension 2 (#869).\nAdded Variable.SOCtoRSOCBridge (#865).\nAdded Constraint.SOCRBridge and disable MOI.Bridges.Constraint.SOCtoPSDBridge (#751).\nFixed added_constraint_types for Contraint.LogDetBridge and Constraint.RootDetBridge (#870).","category":"page"},{"location":"moi/release_notes/#v0.9.1-(August-22,-2019)","page":"Release notes","title":"v0.9.1 (August 22, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fix support for Julia v1.2 (#834).\nL1 and L∞ norm epigraph cones and corresponding bridges to LP were added (#818).\nAdded tests to MOI.Test.nametest (#833).\nFix MOI.Test.soc3test for solvers not supporting infeasibility certificates (#839).\nImplements operate for operators * and / between vector function and constant (#837).\nImplements show for MOI.Utilities.IndexMap (#847).\nFix corner cases for mapping of variables in MOI.Utilities.CachingOptimizer and substitution of variables in MOI.Bridges.AbstractBridgeOptimizer (#848).\nFix transformation of constant terms for MOI.Bridges.Constraint.SOCtoPSDBridge and MOI.Bridges.Constraint.RSOCtoPSDBridge (#840).","category":"page"},{"location":"moi/release_notes/#v0.9.0-(August-13,-2019)","page":"Release notes","title":"v0.9.0 (August 13, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Support for Julia v0.6 and v0.7 was dropped (#714, #717).\nA MOI.Utilities.Model implementation of ModelLike, this should replace most use cases of MOI.Utilities.@model (#781).\nadd_constrained_variable and add_constrained_variables were added (#759).\nSupport for indicator constraints was added (#709, #712).\nDualObjectiveValue attribute was added (#473).\nRawParameter attribute was added (#733).\nA dual_set function was added (#804).\nA Benchmarks submodule was added to facilitate solver benchmarking (#769).\nA submit function was added, this may for intance allow the user to submit solutions or cuts to the solver from a callback (#775).\nThe field of ObjectiveValue was renamed to result_index (#729).\nThe _constant and Utilities.getconstant function were renamed to constant\nREDUCTION_CERTIFICATE result status was added (#734).\nAbstract matrix sets were added (#731).\nTesting improvements:\nThe testing guideline was updated (#728).\nQuadratic tests were added (#697).\nUnit tests for RawStatusString, SolveTime, Silent and SolverName were added (#726, #741).\nA rotated second-order cone test was added (#759).\nA power cone test was added (#768).\nTests for ZeroOne variables with variable bounds were added (#772).\nAn unbounded test was added (#773).\nExisting tests had a few updates (#702, #703, #763).\nDocumentation improvements:\nAdded a section on CachingOptimizer (#777).\nAdded a section on UniversalFallback, Model and @model (#762).\nTransition the knapsack example to a doctest with MockOptimizer (#786).\nUtilities improvements:\nA CleverDict utility was added for a vector that automatically transform into a dictionary once a first index is removed (#767).\nThe Utilities.constant function was renamed to Utilities.constant_vector (#740).\nImplement optimizer attributes for CachingOptimizer (#745).\nRename Utilities.add_scalar_constraint to Utilities.normalize_and_add_constraint (#801).\noperate with vcat, SingleVariable and VectorOfVariables now returns a VectorOfVariables (#616).\nFix a type piracy of operate (#784).\nThe load_constraint fallback signature was fixed (#760).\nThe set_dot function was extended to work with sparse arrays (#805).\nBridges improvements:\nThe bridges no longer store the constraint function and set before it is briged, the bridges now have to implement ConstraintFunction and ConstraintSet if the user wants to recover them. As a consequence, the @bridge macro was removed (#722).\nBridge are now instantiated with a bridge_constraint function instead of using a constructor (#730).\nFix constraint attributes for bridges (#699).\nConstraint bridges were moved to the Bridges/Constraint submodule so they should now inherit from MOI.Bridges.Constraint.Abstract and should implement MOI.Bridges.Constraint.concrete_bridge_type instead of MOI.Bridges.concrete_bridge_type (#756).\nVariable bridges were added in (#759).\nVarious improvements (#746, #747).","category":"page"},{"location":"moi/release_notes/#v0.8.4-(March-13,-2019)","page":"Release notes","title":"v0.8.4 (March 13, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Performance improvement in default_copy_to and bridge optimizer (#696).\nAdd Silent and implement setting optimizer attributes in caching and mock optimizers (#695).\nAdd functionize bridges (SingleVariable and VectorOfVariables) (#659).\nMinor typo fixes (#694).","category":"page"},{"location":"moi/release_notes/#v0.8.3-(March-6,-2019)","page":"Release notes","title":"v0.8.3 (March 6, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Use zero constant in scalar constraint function of MOI.Test.copytest (#691).\nFix variable deletion with SingleVariable objective function (#690).\nFix LazyBridgeOptimizer with bridges that add no constraints (#689).\nError message improvements (#673, #685, #686, #688).\nDocumentation improvements (#682, #683, #687).\nBasis status:\nRemove VariableBasisStatus (#679).\nTest ConstraintBasisStatus and implement it in bridges (#678).\nFix inference of NumberOfVariables and NumberOfConstraints (#677).\nImplement division between a quadratic function and a number (#675).","category":"page"},{"location":"moi/release_notes/#v0.8.2-(February-7,-2019)","page":"Release notes","title":"v0.8.2 (February 7, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Add RawStatusString attribute (#629).\nDo not set names to the optimizer but only to the cache in CachingOptimizer (#638).\nMake scalar MOI functions act as scalars in broadcast (#646).\nAdd function utilities:\nImplement Base.zero (#634), Base.iszero (#643), add missing arithmetic operations (#644, #645) and fix division (#648).\nAdd a vectorize function that turns a vector of ScalarAffineFunction into a VectorAffineFunction (#642).\nImprove support for starting values:\nShow a warning in copy when starting values are not supported instead of throwing an error (#630).\nFix UniversalFallback for getting an variable or constraint attribute set to no indices (#623).\nAdd a test in contlineartest with partially set VariablePrimalStart.\nBridges improvements:\nFix StackOverFlow in LazyBridgeOptimizer when there is a cycle in the graph of bridges.\nAdd Slack bridges (#610, #650).\nAdd FlipSign bridges (#658).\nAdd tests with duplicate coefficients in ScalarAffineFunction and VectorAffineFunction (#639).\nUse tolerance to compare VariablePrimal in rotatedsoc1 test (#632).\nUse a zero constant in ScalarAffineFunction of constraints in psdt2 (#622).","category":"page"},{"location":"moi/release_notes/#v0.8.1-(January-7,-2019)","page":"Release notes","title":"v0.8.1 (January 7, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Adding an NLP objective now overrides any objective set using the ObjectiveFunction attribute (#619).\nRename fullbridgeoptimizer into full_bridge_optimizer (#621).\nAllow custom constraint types with full_bridge_optimizer (#617).\nAdd Vectorize bridge which transforms scalar linear constraints into vector linear constraints (#615).","category":"page"},{"location":"moi/release_notes/#v0.8.0-(December-18,-2018)","page":"Release notes","title":"v0.8.0 (December 18, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Rename all enum values to follow the JuMP naming guidelines for constants, e.g., Optimal becomes OPTIMAL, and DualInfeasible becomes DUAL_INFEASIBLE.\nRename CachingOptimizer methods for style compliance.\nAdd an MOI.TerminationStatusCode called ALMOST_DUAL_INFEASIBLE.","category":"page"},{"location":"moi/release_notes/#v0.7.0-(December-13,-2018)","page":"Release notes","title":"v0.7.0 (December 13, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Test that MOI.TerminationStatus is MOI.OptimizeNotCalled before MOI.optimize! is called.\nCheck supports_default_copy_to in tests (#594).\nKey pieces of information like optimality, infeasibility, etc., are now reported through TerminationStatusCode. It is typically no longer necessary to check the result statuses in addition to the termination status.\nAdd perspective dimension to log-det cone (#593).","category":"page"},{"location":"moi/release_notes/#v0.6.4-(November-27,-2018)","page":"Release notes","title":"v0.6.4 (November 27, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Add OptimizeNotCalled termination status (#577) and improve documentation of other statuses (#575).\nAdd a solver naming guideline (#578).\nMake FeasibilitySense the default ObjectiveSense (#579).\nFix Utilities.@model and Bridges.@bridge macros for functions and sets defined outside MOI (#582).\nDocument solver-specific attributes (#580) and implement them in Utilities.CachingOptimizer (#565).","category":"page"},{"location":"moi/release_notes/#v0.6.3-(November-16,-2018)","page":"Release notes","title":"v0.6.3 (November 16, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Variables and constraints are now allowed to have duplicate names. An error is thrown only on lookup. This change breaks some existing tests. (#549)\nAttributes may now be partially set (some values could be nothing). (#563)\nPerformance improvements in Utilities.Model (#549, #567, #568)\nFix bug in QuadtoSOC (#558).\nNew supports_default_copy_to method that optimizers should implement to control caching behavior.\nDocumentation improvements.","category":"page"},{"location":"moi/release_notes/#v0.6.2-(October-26,-2018)","page":"Release notes","title":"v0.6.2 (October 26, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Improve hygiene of @model macro (#544).\nFix bug in copy tests (#543).\nFix bug in UniversalFallback attribute getter (#540).\nAllow all correct solutions for solve_blank_obj unit test (#537).\nAdd errors for Allocate-Load and bad constraints (#534).\n[performance] Add specialized implementation of hash for VariableIndex (#533).\n[performance] Construct the name to object dictionaries lazily in model (#535).\nAdd the QuadtoSOC bridge which transforms ScalarQuadraticFunction constraints into RotatedSecondOrderCone (#483).","category":"page"},{"location":"moi/release_notes/#v0.6.1-(September-22,-2018)","page":"Release notes","title":"v0.6.1 (September 22, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Enable PositiveSemidefiniteConeSquare set and quadratic functions in MOIB.fullbridgeoptimizer (#524).\nAdd warning in the bridge between PositiveSemidefiniteConeSquare and PositiveSemidefiniteConeTriangle when the matrix is almost symmetric (#522).\nModify MOIT.copytest to not add multiples constraints on the same variable (#521).\nAdd missing keyword argument in one of MOIU.add_scalar_constraint methods (#520).","category":"page"},{"location":"moi/release_notes/#v0.6.0-(August-30,-2018)","page":"Release notes","title":"v0.6.0 (August 30, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"The MOIU.@model and MOIB.@bridge macros now support functions and sets defined in external modules. As a consequence, function and set names in the macro arguments need to be prefixed by module name.\nRename functions according to the JuMP style guide:\ncopy! with keyword arguments copynames and warnattributes -> copy_to with keyword arguments copy_names and warn_attributes;\nset! -> set;\naddvariable[s]! -> add_variable[s];\nsupportsconstraint -> supports_constraint;\naddconstraint[s]! -> add_constraint[s];\nisvalid -> is_valid;\nisempty -> is_empty;\nBase.delete! -> delete;\nmodify! -> modify;\ntransform! -> transform;\ninitialize! -> initialize;\nwrite -> write_to_file; and\nread! -> read_from_file.\nRemove free! (use Base.finalize instead).\nAdd the SquarePSD bridge which transforms PositiveSemidefiniteConeTriangle constraints into PositiveSemidefiniteConeTriangle.\nAdd result fallback for ConstraintDual of variable-wise constraint, ConstraintPrimal and ObjectiveValue.\nAdd tests for ObjectiveBound.\nAdd test for empty rows in vector linear constraint.\nRework errors: CannotError has been renamed NotAllowedError and the distinction between UnsupportedError and NotAllowedError is now about whether the element is not supported (i.e. it cannot be copied a model containing this element) or the operation is not allowed (either because it is not implemented, because it cannot be performemd in the current state of the model, because it cannot be performed for a specific index, ...)\ncanget is removed. NoSolution is added as a result status to indicate that the solver does not have either a primal or dual solution available (See #479).","category":"page"},{"location":"moi/release_notes/#v0.5.0-(August-5,-2018)","page":"Release notes","title":"v0.5.0 (August 5, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fix names with CachingOptimizer.\nCleanup thanks to @mohamed82008.\nAdded a universal fallback for constraints.\nFast utilities for function canonicalization thanks to @rdeits.\nRenamed dimension field to side_dimension in the context of matrix-like sets.\nNew and improved tests for cases like duplicate terms and ObjectiveBound.\nRemoved cantransform, canaddconstraint, canaddvariable, canset, canmodify, and candelete functions from the API. They are replaced by a new set of errors that are thrown: Subtypes of UnsupportedError indicate unsupported operations, while subtypes of CannotError indicate operations that cannot be performed in the current state.\nThe API for copy! is updated to remove the CopyResult type.\nUpdates for the new JuMP style guide.","category":"page"},{"location":"moi/release_notes/#v0.4.1-(June-28,-2018)","page":"Release notes","title":"v0.4.1 (June 28, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixes vector function modification on 32 bits.\nFixes Bellman-Ford algorithm for bridges.\nAdded an NLP test with FeasibilitySense.\nUpdate modification documentation.","category":"page"},{"location":"moi/release_notes/#v0.4.0-(June-23,-2018)","page":"Release notes","title":"v0.4.0 (June 23, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Helper constructors for VectorAffineTerm and VectorQuadraticTerm.\nAdded modify_lhs to TestConfig.\nAdditional unit tests for optimizers.\nAdded a type parameter to CachingOptimizer for the optimizer field.\nNew API for problem modification (#388)\nTests pass without deprecation warnings on Julia 0.7.\nSmall fixes and documentation updates.","category":"page"},{"location":"moi/release_notes/#v0.3.0-(May-25,-2018)","page":"Release notes","title":"v0.3.0 (May 25, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Functions have been redefined to use arrays-of-structs instead of structs-of-arrays.\nImprovements to MockOptimizer.\nSignificant changes to Bridges.\nNew and improved unit tests.\nFixes for Julia 0.7.","category":"page"},{"location":"moi/release_notes/#v0.2.0-(April-24,-2018)","page":"Release notes","title":"v0.2.0 (April 24, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Improvements to and better coverage of Tests.\nDocumentation fixes.\nSolverName attribute.\nChanges to the NLP interface (new definition of variable order and arrays of structs for bound pairs and sparsity patterns).\nAddition of NLP tests.\nIntroduction of UniversalFallback.\ncopynames keyword argument to MOI.copy!.\nAdd Bridges submodule.","category":"page"},{"location":"moi/release_notes/#v0.1.0-(February-28,-2018)","page":"Release notes","title":"v0.1.0 (February 28, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Initial public release.\nThe framework for MOI was developed at the JuMP-dev workshop at MIT in June 2017 as a sorely needed replacement for MathProgBase.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/conic/logistic_regression.jl\"","category":"page"},{"location":"tutorials/conic/logistic_regression/#Logistic-regression","page":"Logistic regression","title":"Logistic regression","text":"","category":"section"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"Originally Contributed by: François Pacaud","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"This tutorial shows how to solve a logistic regression problem with JuMP. Logistic regression is a well known method in machine learning, useful when we want to classify binary variables with the help of a given set of features. To this goal, we find the optimal combination of features maximizing the (log)-likelihood onto a training set. From a modern optimization glance, the resulting problem is convex and differentiable. On a modern optimization glance, it is even conic representable.","category":"page"},{"location":"tutorials/conic/logistic_regression/#Formulating-the-logistic-regression-problem","page":"Logistic regression","title":"Formulating the logistic regression problem","text":"","category":"section"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"Suppose we have a set of training data-point i = 1 cdots n, where for each i we have a vector of features x_i in mathbbR^p and a categorical observation y_i in -1 1.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"The log-likelihood is given by","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"l(theta) = sum_i=1^n log(dfrac11 + exp(-y_i theta^top x_i))","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"and the optimal theta minimizes the logistic loss function:","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"min_theta sum_i=1^n log(1 + exp(-y_i theta^top x_i))","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"Most of the time, instead of solving directly the previous optimization problem, we prefer to add a regularization term:","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"min_theta sum_i=1^n log(1 + exp(-y_i theta^top x_i)) + lambda  theta ","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"with lambda in mathbbR_+ a penalty and  a norm function. By adding such a regularization term, we avoid overfitting on the training set and usually achieve a greater score in cross-validation.","category":"page"},{"location":"tutorials/conic/logistic_regression/#Reformulation-as-a-conic-optimization-problem","page":"Logistic regression","title":"Reformulation as a conic optimization problem","text":"","category":"section"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"By introducing auxiliary variables t_1 cdots t_n and r, the optimization problem is equivalent to","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"beginaligned\nmin_t r theta  sum_i=1^n t_i + lambda r \ntextsubject to   quad t_i geq log(1 + exp(- y_i theta^top x_i)) \n                    quad r geq theta\nendaligned","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"Now, the trick is to reformulate the constraints t_i geq log(1 + exp(- y_i theta^top x_i)) with the help of the exponential cone","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"K_exp =  (x y z) in mathbbR^3   y exp(x  y) leq z  ","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"Indeed, by passing to the exponential, we see that for all i=1 cdots n, the constraint t_i geq log(1 + exp(- y_i theta^top x_i)) is equivalent to","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"exp(-t_i) + exp(u_i - t_i) leq 1","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"with u_i = -y_i theta^top x_i. Then, by adding two auxiliary variables z_i1 and z_i2 such that z_i1 geq exp(u_i-t_i) and z_i2 geq exp(-t_i), we get the equivalent formulation","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"left\nbeginaligned\n(u_i -t_i  1 z_i1)  in  K_exp  \n(-t_i  1 z_i2)  in  K_exp  \nz_i1 + z_i2  leq  1\nendaligned\nright","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"In this setting, the conic version of the logistic regression problems writes out","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"beginaligned\nmin_t z r theta   sum_i=1^n t_i + lambda r \ntextsubject to   quad  (u_i -t_i  1 z_i1)  in  K_exp  \n                    quad  (-t_i  1 z_i2)  in  K_exp  \n                    quad  z_i1 + z_i2  leq  1 \n                    quad u_i = -y_i x_i^top theta \n                    quad r geq theta\nendaligned","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"and thus encompasses 3n + p + 1 variables and 3n + 1 constraints (u_i = -y_i theta^top x_i is only a virtual constraint used to clarify the notation). Thus, if n gg 1, we get a large number of variables and constraints.","category":"page"},{"location":"tutorials/conic/logistic_regression/#Fitting-logistic-regression-with-a-conic-solver","page":"Logistic regression","title":"Fitting logistic regression with a conic solver","text":"","category":"section"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"It is now time to pass to the implementation. We choose SCS as a conic solver.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"using JuMP\nimport Random\nimport SCS","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"info: Info\nThis tutorial uses sets from MathOptInterface. By default, JuMP exports the MOI symbol as an alias for the MathOptInterface.jl package. We recommend making this more explicit in your code by adding the following lines:import MathOptInterface\nconst MOI = MathOptInterface","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"Random.seed!(2713);\nnothing #hide","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"We start by implementing a function to generate a fake dataset, and where we could tune the correlation between the feature variables. The function is a direct transcription of the one used in this blog post.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"function generate_dataset(n_samples = 100, n_features = 10; shift = 0.0)\n    X = randn(n_samples, n_features)\n    w = randn(n_features)\n    y = sign.(X * w)\n    X .+= 0.8 * randn(n_samples, n_features) # add noise\n    X .+= shift # shift the points in the feature space\n    X = hcat(X, ones(n_samples, 1))\n    return X, y\nend","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"We write a softplus function to formulate each constraint t geq log(1 + exp(u)) with two exponential cones.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"function softplus(model, t, u)\n    z = @variable(model, [1:2], lower_bound = 0.0)\n    @constraint(model, sum(z) <= 1.0)\n    @constraint(model, [u - t, 1, z[1]] in MOI.ExponentialCone())\n    @constraint(model, [-t, 1, z[2]] in MOI.ExponentialCone())\nend","category":"page"},{"location":"tutorials/conic/logistic_regression/#\\ell_2-regularized-logistic-regression","page":"Logistic regression","title":"ell_2 regularized logistic regression","text":"","category":"section"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"Then, with the help of the softplus function, we could write our optimization model. In the ell_2 regularization case, the constraint r geq theta_2 rewrites as a second order cone constraint.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"function build_logit_model(X, y, λ)\n    n, p = size(X)\n    model = Model()\n    @variable(model, θ[1:p])\n    @variable(model, t[1:n])\n    for i in 1:n\n        u = -(X[i, :]' * θ) * y[i]\n        softplus(model, t[i], u)\n    end\n    # Add ℓ2 regularization\n    @variable(model, 0.0 <= reg)\n    @constraint(model, [reg; θ] in SecondOrderCone())\n    # Define objective\n    @objective(model, Min, sum(t) + λ * reg)\n    return model\nend","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"We generate the dataset.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"warning: Warning\nBe careful here, for large n and p SCS could fail to converge!","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"n, p = 200, 10\nX, y = generate_dataset(n, p, shift = 10.0);\n\n# We could now solve the logistic regression problem\nλ = 10.0\nmodel = build_logit_model(X, y, λ)\nset_optimizer(model, SCS.Optimizer)\nset_silent(model)\nJuMP.optimize!(model)","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"θ♯ = JuMP.value.(model[:θ])","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"It appears that the speed of convergence is not that impacted by the correlation of the dataset, nor by the penalty lambda.","category":"page"},{"location":"tutorials/conic/logistic_regression/#\\ell_1-regularized-logistic-regression","page":"Logistic regression","title":"ell_1 regularized logistic regression","text":"","category":"section"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"We now formulate the logistic problem with a ell_1 regularization term. The ell_1 regularization ensures sparsity in the optimal solution of the resulting optimization problem. Luckily, the ell_1 norm is implemented as a set in MathOptInterface. Thus, we could formulate the sparse logistic regression problem with the help of a MOI.NormOneCone set.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"function build_sparse_logit_model(X, y, λ)\n    n, p = size(X)\n    model = Model()\n    @variable(model, θ[1:p])\n    @variable(model, t[1:n])\n    for i in 1:n\n        u = -(X[i, :]' * θ) * y[i]\n        softplus(model, t[i], u)\n    end\n    # Add ℓ1 regularization\n    @variable(model, 0.0 <= reg)\n    @constraint(model, [reg; θ] in MOI.NormOneCone(p + 1))\n    # Define objective\n    @objective(model, Min, sum(t) + λ * reg)\n    return model\nend\n\n# Auxiliary function to count non-null components:\ncount_nonzero(v::Vector; tol = 1e-6) = sum(abs.(v) .>= tol)\n\n# We solve the sparse logistic regression problem on the same dataset as before.\nλ = 10.0\nsparse_model = build_sparse_logit_model(X, y, λ)\nset_optimizer(sparse_model, SCS.Optimizer)\nset_silent(sparse_model)\nJuMP.optimize!(sparse_model)","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"θ♯ = JuMP.value.(sparse_model[:θ])\nprintln(\n    \"Number of non-zero components: \",\n    count_nonzero(θ♯),\n    \" (out of \",\n    p,\n    \" features)\",\n)","category":"page"},{"location":"tutorials/conic/logistic_regression/#Extensions","page":"Logistic regression","title":"Extensions","text":"","category":"section"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"A direct extension would be to consider the sparse logistic regression with hard thresholding, which, on contrary to the soft version using a ell_1 regularization, adds an explicit cardinality constraint in its formulation:","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"beginaligned\nmin_theta   sum_i=1^n log(1 + exp(-y_i theta^top x_i)) + lambda  theta _2^2 \ntextsubject to   quad  theta _0 = k\nendaligned","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"where k is the maximum number of non-zero components in the vector theta, and _0 is the ell_0 pseudo-norm:","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":" x_0 = i   x_i neq 0","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"The cardinality constraint theta_0 leq k could be reformulated with binary variables. Thus the hard sparse regression problem could be solved by any solver supporting mixed integer conic problems.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<img class=\"display-light-only\" src=\"assets/logo-with-text.svg\" alt=\"JuMP logo\"/>\n<img class=\"display-dark-only\" src=\"assets/logo-dark-with-text.svg\" alt=\"JuMP logo\"/>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"# These comments do not display in the HTML output.\n# See https://github.com/JuliaDocs/Documenter.jl/issues/674.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the documentation for JuMP!","category":"page"},{"location":"#What-is-JuMP?","page":"Introduction","title":"What is JuMP?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP is a domain-specific modeling language for mathematical optimization embedded in Julia. It currently supports a number of open-source and commercial solvers for a variety of problem classes, including linear, mixed-integer, second-order conic, semidefinite, and nonlinear programming.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Tip\nIf you aren't sure if you should use JuMP, read Should I use JuMP?.","category":"page"},{"location":"#Resources-for-getting-started","page":"Introduction","title":"Resources for getting started","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There are few ways to get started with JuMP:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Read the Installation Guide.\nRead the introductory tutorials Getting started with Julia and Getting started with JuMP.\nBrowse some of our modeling tutorials, including classics such as The diet problem, or the Maximum likelihood estimation problem using nonlinear programming.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Tip\nNeed help? Join the community forum to search for answers to commonly asked questions.Before asking a question, make sure to read the post make it easier to help you, which contains a number of tips on how to ask a good question.","category":"page"},{"location":"#How-the-documentation-is-structured","page":"Introduction","title":"How the documentation is structured","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Having a high-level overview of how this documentation is structured will help you know where to look for certain things.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Tutorials contain worked examples of solving problems with JuMP. Start here if you are new to JuMP, or you have a particular problem class you want to model.\nThe Manual contains short code-snippets that explain how to achieve specific tasks in JuMP. Look here if you want to know how to achieve a particular task, such as how to Delete a variable or how to Modify an objective coefficient.\nThe API Reference contains a complete list of the functions you can use in JuMP. Look here if you want to know how to use a particular function.\nThe Background information section contains background reading material to provide context to JuMP. Look here if you want an understanding of what JuMP is and why we created it, rather than how to use it.\nThe Developer docs section contains information for people contributing to JuMP development or writing JuMP extensions. Don't worry about this section if you are using JuMP to formulate and solve problems as a user.\nThe MathOptInterface section is a self-contained copy of the documentation for MathOptInterface. Look here for functions and constants beginning with MOI., as well as for general information on how MathOptInterface works.","category":"page"},{"location":"#Citing-JuMP","page":"Introduction","title":"Citing JuMP","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you find JuMP useful in your work, we kindly request that you cite the following paper (pdf):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@article{DunningHuchetteLubin2017,\nauthor = {Iain Dunning and Joey Huchette and Miles Lubin},\ntitle = {JuMP: A Modeling Language for Mathematical Optimization},\njournal = {SIAM Review},\nvolume = {59},\nnumber = {2},\npages = {295-320},\nyear = {2017},\ndoi = {10.1137/15M1020575},\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For an earlier work where we presented a prototype implementation of JuMP, see here:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@article{LubinDunningIJOC,\nauthor = {Miles Lubin and Iain Dunning},\ntitle = {Computing in Operations Research Using Julia},\njournal = {INFORMS Journal on Computing},\nvolume = {27},\nnumber = {2},\npages = {238-248},\nyear = {2015},\ndoi = {10.1287/ijoc.2014.0623},\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A preprint of this paper is freely available.","category":"page"},{"location":"#NumFOCUS","page":"Introduction","title":"NumFOCUS","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: NumFOCUS logo)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP is a Sponsored Project of NumFOCUS, a 501(c)(3) nonprofit charity in the United States. NumFOCUS provides JuMP with fiscal, legal, and administrative support to help ensure the health and sustainability of the project. Visit numfocus.org for more information.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can support JuMP by donating.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Donations to JuMP are managed by NumFOCUS. For donors in the United States, your gift is tax-deductible to the extent provided by law. As with any donation, you should consult with your tax adviser about your particular tax situation.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP's largest expense is the annual JuMP-dev workshop. Donations will help us provide travel support for JuMP-dev attendees and take advantage of other opportunities that arise to support JuMP development.","category":"page"},{"location":"moi/background/motivation/#Motivation","page":"Motivation","title":"Motivation","text":"","category":"section"},{"location":"moi/background/motivation/","page":"Motivation","title":"Motivation","text":"MathOptInterface (MOI) is a replacement for MathProgBase, the first-generation abstraction layer for mathematical optimization previously used by JuMP and Convex.jl.","category":"page"},{"location":"moi/background/motivation/","page":"Motivation","title":"Motivation","text":"To address a number of limitations of MathProgBase, MOI is designed to:","category":"page"},{"location":"moi/background/motivation/","page":"Motivation","title":"Motivation","text":"Be simple and extensible\nunifying linear, quadratic, and conic optimization,\nseamlessly facilitating extensions to essentially arbitrary constraints and functions (e.g., indicator constraints, complementarity constraints, and piecewise-linear functions)\nBe fast\nby allowing access to a solver's in-memory representation of a problem without writing intermediate files (when possible)\nby using multiple dispatch and avoiding requiring containers of nonconcrete types\nAllow a solver to return multiple results (e.g., a pool of solutions)\nAllow a solver to return extra arbitrary information via attributes (e.g., variable- and constraint-wise membership in an irreducible inconsistent subset for infeasibility analysis)\nProvide a greatly expanded set of status codes explaining what happened during the optimization procedure\nEnable a solver to more precisely specify which problem classes it supports\nEnable both primal and dual warm starts\nEnable adding and removing both variables and constraints by indices that are not required to be consecutive\nEnable any modification that the solver supports to an existing model\nAvoid requiring the solver wrapper to store an additional copy of the problem data","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/algorithms/benders_lazy_constraints.jl\"","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/#benders_decomposition_lazy","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"","category":"section"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"Originally Contributed by: Mathieu Besançon","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"This notebook describes how to implement the Benders decomposition in JuMP using lazy constraints. We keep the same notation and problem form as the first notebook Benders decomposition.","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"beginaligned\n textmaximize quad c_1^T x+c_2^T v \n textsubject to quad A_1 x+ A_2 v preceq b \n x succeq 0 x in mathbbZ^n \n v succeq 0 v in mathbbR^p \nendaligned","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"where b in mathbbR^m, A_1 in mathbbR^m times n, A_2 in mathbbR^m times p and mathbbZ is the set of integers.","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"Here the symbol succeq (preceq) stands for element-wise greater (less) than or equal to. Any mixed integer programming problem can be written in the form above.","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"For a detailed explanation on the Benders decomposition algorithm, see the introduction notebook.","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/#Lazy-constraints","page":"Benders decomposition (via callbacks)","title":"Lazy constraints","text":"","category":"section"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"Some optimization solvers allow users to interact with them during the solution process by providing user-defined functions which are triggered under certain conditions.","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"The generic term for these functions is callback.","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"In integer optimization, the main callback types are lazy constraints, user-cuts and heuristic solutions. See the Callbacks section for an introduction on how to use them.","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"Some callbacks define a new constraint which is only activated when necessary, i.e., when a current solution does not respect them. It can avoid building an optimization model with too many constraints up-front.","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"This is the case for Benders decomposition, since the sub-problem defines an exponential number of primal vertices and therefore dual cuts.","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"A detailed explanation on the distinction between user-cuts and lazy constraints is also available on Paul Rubin's blog. He also describes this approach to Benders Decomposition.","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"We use the data from the original notebook and change the solution algorithm to leverage lazy constraints:","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"Step 1 (Initialization)\nStep 2 (defining the subproblem model)\nStep 3 (registering the lazy constraint of the subproblem)","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/#Input-data","page":"Benders decomposition (via callbacks)","title":"Input data","text":"","category":"section"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"The input data is from page 139, Integer programming by Garfinkel and Nemhauser[1].","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"c1 = [-1; -4]\nc2 = [-2; -3]\n\ndim_x = length(c1)\ndim_u = length(c2)\n\nb = [-2; -3]\n\nA1 = [\n    1 -3\n    -1 -3\n]\nA2 = [\n    1 -2\n    -1 -1\n]\n\nM = 1000;\nnothing #hide","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/#Implementation","page":"Benders decomposition (via callbacks)","title":"Implementation","text":"","category":"section"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"using JuMP\nimport GLPK\nimport Test","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"info: Info\nThis tutorial uses the MathOptInterface API. By default, JuMP exports the MOI symbol as an alias for the MathOptInterface.jl package. We recommend making this more explicit in your code by adding the following lines:import MathOptInterface\nconst MOI = MathOptInterface","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"Subproblem creation","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"function build_subproblem()\n    sub_problem_model = Model(GLPK.Optimizer)\n    @variable(sub_problem_model, u[1:dim_u] >= 0)\n    @constraint(\n        sub_problem_model,\n        constr_ref_subproblem[j = 1:size(A2, 2)],\n        A2[:, j]' * u >= c2[j],\n    )\n    return (sub_problem_model, u)\nend","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/#Master-Problem-Description","page":"Benders decomposition (via callbacks)","title":"Master Problem Description","text":"","category":"section"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"master_problem_model = Model(GLPK.Optimizer)\n@variable(master_problem_model, 0 <= x[1:dim_x] <= 1e6, Int)\n@variable(master_problem_model, t <= 1e6)\n@objective(master_problem_model, Max, t)\nprint(master_problem_model)","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"(sub_problem_model, u) = build_subproblem();\nnothing #hide","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"Track the calls to the callback","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"iter_num = 0","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"Define lazy constraints","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"function benders_lazy_constraint_callback(cb_data)\n    global iter_num\n    iter_num += 1\n    println(\"Iteration number = \", iter_num)\n\n    x_current = callback_value.(Ref(cb_data), x)\n    fm_current = callback_value(cb_data, t)\n\n    c_sub = b - A1 * x_current\n    @objective(sub_problem_model, Min, c1' * x_current + c_sub' * u)\n    optimize!(sub_problem_model)\n\n    print(\"\\nThe current subproblem model is \\n\")\n    print(sub_problem_model)\n\n    t_status_sub = termination_status(sub_problem_model)\n    p_status_sub = primal_status(sub_problem_model)\n\n    fs_x_current = objective_value(sub_problem_model)\n\n    u_current = value.(u)\n\n    γ = b' * u_current\n\n    if p_status_sub == FEASIBLE_POINT && fs_x_current ≈ fm_current # we are done\n        @info(\"No additional constraint from the subproblem\")\n    end\n\n    if p_status_sub == FEASIBLE_POINT && fs_x_current < fm_current\n        println(\n            \"\\nThere is a suboptimal vertex, add the corresponding constraint\",\n        )\n        cv = A1' * u_current - c1\n        new_optimality_cons = @build_constraint(t + cv' * x <= γ)\n        MOI.submit(\n            master_problem_model,\n            MOI.LazyConstraint(cb_data),\n            new_optimality_cons,\n        )\n    end\n\n    if t_status_sub == INFEASIBLE_OR_UNBOUNDED\n        println(\n            \"\\nThere is an  extreme ray, adding the corresponding constraint\",\n        )\n        ce = A1' * u_current\n        new_feasibility_cons = @build_constraint(dot(ce, x) <= γ)\n        MOI.submit(\n            master_problem_model,\n            MOI.LazyConstraint(cb_data),\n            new_feasibility_cons,\n        )\n    end\nend\n\nMOI.set(\n    master_problem_model,\n    MOI.LazyConstraintCallback(),\n    benders_lazy_constraint_callback,\n)\n\noptimize!(master_problem_model)\n\nt_status = termination_status(master_problem_model)\np_status = primal_status(master_problem_model)\n\nif p_status == INFEASIBLE_POINT\n    println(\"The problem is infeasible :-(\")\nend\n\nif t_status == INFEASIBLE_OR_UNBOUNDED\n    fm_current = M\n    x_current = M * ones(dim_x)\nend\n\nif p_status == FEASIBLE_POINT\n    fm_current = value(t)\n    x_current = value.(x)\nend\n\nTest.@test value(t) ≈ -4 #hide\n\nprintln(\n    \"Status of the master problem is \",\n    t_status,\n    \"\\nwith fm_current = \",\n    fm_current,\n    \"\\nx_current = \",\n    x_current,\n)","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/#References","page":"Benders decomposition (via callbacks)","title":"References","text":"","category":"section"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"<a id='c1'></a>","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"Garfinkel, R. & Nemhauser, G. L. Integer programming. (Wiley, 1972).","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"","category":"page"},{"location":"tutorials/algorithms/benders_lazy_constraints/","page":"Benders decomposition (via callbacks)","title":"Benders decomposition (via callbacks)","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"developers/extensions/#extensions_manual","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"JuMP provides a variety of ways to extend the basic modeling functionality.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"tip: Tip\nThis documentation in this section is still a work-in-progress. The best place to look for ideas and help when writing a new JuMP extension are existing JuMP extensions. Examples include:BilevelJuMP.jl\nColuna.jl\nInfiniteOpt.jl\nPlasmo.jl\nPolyJuMP.jl\nSDDP.jl\nStochasticPrograms.jl\nSumOfSquares.jl\nvOptGeneric.jl","category":"page"},{"location":"developers/extensions/#Define-a-new-set","page":"Extensions","title":"Define a new set","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"To define a new set for JuMP, subtype MOI.AbstractScalarSet or MOI.AbstractVectorSet and implement Base.copy for the set. That's it!","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"struct _NewVectorSet <: MOI.AbstractVectorSet\n    dimension::Int\nend\nBase.copy(x::_NewVectorSet) = x\n\nmodel = Model()\n@variable(model, x[1:2])\n@constraint(model, x in _NewVectorSet(2))\n\n# output\n\n[x[1], x[2]] ∈ _NewVectorSet(2)","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"However, for vector-sets, this requires the user to specify the dimension argument to their set, even though we could infer it from the length of x!","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"You can make a more user-friendly set by subtyping AbstractVectorSet and implementing moi_set.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"struct NewVectorSet <: JuMP.AbstractVectorSet end\nJuMP.moi_set(::NewVectorSet, dim::Int) = _NewVectorSet(dim)\n\nmodel = Model()\n@variable(model, x[1:2])\n@constraint(model, x in NewVectorSet())\n\n# output\n\n[x[1], x[2]] ∈ _NewVectorSet(2)","category":"page"},{"location":"developers/extensions/#Extend-[@variable](@ref)","page":"Extensions","title":"Extend @variable","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Just as Bin and Int create binary and integer variables, you can extend the @variable macro to create new types of variables. Here is an explanation by example, where we create a AddTwice type, that creates a tuple of two JuMP variables instead of a single variable.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"First, create a new struct. This can be anything. Our struct holds a VariableInfo object that stores bound information, and whether the variable is binary or integer.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> struct AddTwice\n           info::JuMP.VariableInfo\n       end","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Second, implement build_variable, which takes ::Type{AddTwice} as an argument, and returns an instance of AddTwice. Note that you can also receive keyword arguments.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> function JuMP.build_variable(\n           _err::Function,\n           info::JuMP.VariableInfo,\n           ::Type{AddTwice};\n           kwargs...\n       )\n           println(\"Can also use $kwargs here.\")\n           return AddTwice(info)\n       end","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Third, implement add_variable, which takes the instance of AddTwice from the previous step, and returns something. Typically, you will want to call add_variable here. For example, our AddTwice call is going to add two JuMP variables.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> function JuMP.add_variable(\n           model::JuMP.Model,\n           duplicate::AddTwice,\n           name::String,\n       )\n           a = JuMP.add_variable(\n               model,\n               JuMP.ScalarVariable(duplicate.info),\n               name * \"_a\",\n            )\n           b = JuMP.add_variable(\n               model,\n               JuMP.ScalarVariable(duplicate.info),\n               name * \"_b\",\n            )\n           return (a, b)\n       end","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Now AddTwice can be passed to @variable similar to Bin or Int. However, now it adds two variables instead of one!","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> model = Model();\n\njulia> @variable(model, x[i=1:2], AddTwice, kw=i)\nCan also use Base.Iterators.Pairs(:kw => 1) here.\nCan also use Base.Iterators.Pairs(:kw => 2) here.\n2-element Vector{Tuple{VariableRef, VariableRef}}:\n (x[1]_a, x[1]_b)\n (x[2]_a, x[2]_b)\n\njulia> num_variables(model)\n4\n\njulia> first(x[1])\nx[1]_a\n\njulia> last(x[2])\nx[2]_b","category":"page"},{"location":"developers/extensions/#Extend-[@constraint](@ref)","page":"Extensions","title":"Extend @constraint","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"The @constraint macro has three steps that can be intercepted and extended: parse time, build time, and add time.","category":"page"},{"location":"developers/extensions/#Parse","page":"Extensions","title":"Parse","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"To extend the @constraint macro at parse time, implement one of the following methods:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"parse_constraint_head\nparse_constraint_call","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"warning: Warning\nExtending the constraint macro at parse time is an advanced operation and has the potential to interfere with existing JuMP syntax. Please discuss with the developer chatroom before publishing any code that implements these methods.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"parse_constraint_head should be implemented to intercept an expression based on the .head field of Base.Expr. For example:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> using JuMP\n\njulia> const MutableArithmetics = JuMP._MA;\n\njulia> model = Model(); @variable(model, x);\n\njulia> function JuMP.parse_constraint_head(\n           _error::Function,\n           ::Val{:(:=)},\n           lhs,\n           rhs,\n       )\n           println(\"Rewriting := as ==\")\n           new_lhs, parse_code = MutableArithmetics.rewrite(lhs)\n           build_code = :(\n               build_constraint($(_error), $(new_lhs), MOI.EqualTo($(rhs)))\n           )\n           return false, parse_code, build_code\n       end\n\njulia> @constraint(model, x + x := 1.0)\nRewriting := as ==\n2 x = 1.0","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"parse_constraint_call should be implemented to intercept an expression of the form Expr(:call, op, args...). For example:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> using JuMP\n\njulia> const MutableArithmetics = JuMP._MA;\n\njulia> model = Model(); @variable(model, x);\n\njulia> function JuMP.parse_constraint_call(\n           _error::Function,\n           is_vectorized::Bool,\n           ::Val{:my_equal_to},\n           lhs,\n           rhs,\n       )\n           println(\"Rewriting my_equal_to to ==\")\n           new_lhs, parse_code = MutableArithmetics.rewrite(lhs)\n           build_code = if is_vectorized\n               :(build_constraint($(_error), $(new_lhs), MOI.EqualTo($(rhs)))\n           )\n           else\n               :(build_constraint.($(_error), $(new_lhs), MOI.EqualTo($(rhs))))\n           end\n           return parse_code, build_code\n       end\n\njulia> @constraint(model, my_equal_to(x + x, 1.0))\nRewriting my_equal_to to ==\n2 x = 1.0","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"tip: Tip\nWhen parsing a constraint you can recurse into sub-constraint (e.g., the {expr} in z => {x <= 1}) by calling parse_constraint.","category":"page"},{"location":"developers/extensions/#Build","page":"Extensions","title":"Build","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"To extend the @constraint macro at build time, implement a new build_constraint method.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"This may mean implementing a method for a specific function or set created at parse time, or it may mean implementing a method which handles additional positional arguments.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"build_constraint must return an AbstractConstraint, which can either be an AbstractConstraint already supported by JuMP, e.g., ScalarConstraint or VectorConstraint, or a custom AbstractConstraint with a corresponding add_constraint method (see Add).","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"tip: Tip\nThe easiest way to extend @constraint is via an additional positional argument to build_constraint.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Here is an example of adding extra arguments to build_constraint:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> model = Model(); @variable(model, x);\n\njulia> struct MyConstrType end\n\njulia> function JuMP.build_constraint(\n            _error::Function,\n            f::JuMP.GenericAffExpr,\n            set::MOI.EqualTo,\n            extra::Type{MyConstrType};\n            d = 0,\n       )\n            new_set = MOI.LessThan(set.value + d)\n            return JuMP.build_constraint(_error, f, new_set)\n       end\n\njulia> @constraint(model, my_con, x == 0, MyConstrType, d = 2)\nmy_con : x ≤ 2.0","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"note: Note\nOnly a single positional argument can be given to a particular constraint. Extensions that seek to pass multiple arguments (e.g., Foo and Bar) should combine them into one argument type (e.g., FooBar).","category":"page"},{"location":"developers/extensions/#extension_add_constraint","page":"Extensions","title":"Add","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"build_constraint returns an AbstractConstraint object. To extend @constraint at add time, define a subtype of AbstractConstraint, implement build_constraint to return an instance of the new type, and then implement add_constraint.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Here is an example:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> model = Model(); @variable(model, x);\n\njulia> struct MyTag\n           name::String\n       end\n\njulia> struct MyConstraint{S} <: AbstractConstraint\n           name::String\n           f::AffExpr\n           s::S\n       end\n\njulia> function JuMP.build_constraint(\n            _error::Function,\n            f::AffExpr,\n            set::MOI.AbstractScalarSet,\n            extra::MyTag,\n       )\n            return MyConstraint(extra.name, f, set)\n       end\n\njulia> function JuMP.add_constraint(\n            model::Model,\n            con::MyConstraint,\n            name::String,\n       )\n            return add_constraint(\n                model,\n                ScalarConstraint(con.f, con.s),\n                \"$(con.name)[$(name)]\",\n            )\n       end\n\njulia> @constraint(model, my_con, 2x <= 1, MyTag(\"my_prefix\"))\nmy_prefix[my_con] : 2 x - 1 ≤ 0.0","category":"page"},{"location":"developers/extensions/#The-extension-dictionary","page":"Extensions","title":"The extension dictionary","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Every JuMP model has a field .ext::Dict{Symbol,Any} that can be used by extensions. This is useful if your extensions to @variable and @constraint need to store information between calls.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"The most common way to initialize a model with information in the .ext dictionary is to provide a new constructor:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> function MyModel()\n           model = Model()\n           model.ext[:MyModel] = 1\n           return model\n       end\nMyModel (generic function with 1 method)\n\njulia> model = MyModel()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> model.ext\nDict{Symbol, Any} with 1 entry:\n  :MyModel => 1","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"If you define extension data, implement copy_extension_data to support copy_model.","category":"page"},{"location":"developers/extensions/#Defining-new-JuMP-models","page":"Extensions","title":"Defining new JuMP models","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"If extending individual calls to @variable and @constraint is not sufficient, it is possible to implement a new model via a subtype of AbstractModel. You can also define new AbstractVariableRefs to create different types of JuMP variables.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"warning: Warning\nExtending JuMP in this manner is an advanced operation. We strongly encourage you to consider how you can use the methods mentioned in the previous sections to achieve your aims instead of defining new model and variable types. Consult the developer chatroom before starting work on this.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"If you define new types, you will need to implement a considerable number of methods, and doing so will require a detailed understanding of the JuMP internals. Therefore, the list of methods to implement is currently undocumented.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"The easiest way to extend JuMP by defining a new model type is to follow an existing example. A simple example to follow is the JuMPExtension module in the JuMP test suite. The best example of an external JuMP extension that implements an AbstractModel is InfiniteOpt.jl.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/tutorials/manipulating_expressions/#Manipulating-expressions","page":"Manipulating expressions","title":"Manipulating expressions","text":"","category":"section"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"This guide highlights a syntactically appealing way to build expressions at the MOI level, but also to look at their contents. It may be especially useful when writing models or bridge code.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/#Creating-functions","page":"Manipulating expressions","title":"Creating functions","text":"","category":"section"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"This section details the ways to create functions with MathOptInterface.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/#Creating-scalar-affine-functions","page":"Manipulating expressions","title":"Creating scalar affine functions","text":"","category":"section"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"The simplest scalar function is simply a variable:","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> x = MOI.add_variable(model) # Create the variable x\nMathOptInterface.VariableIndex(1)","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"This type of function is extremely simple; to express more complex functions, other types must be used. For instance, a ScalarAffineFunction is a sum of linear terms (a factor times a variable) and a constant. Such an object can be built using the standard constructor:","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> f = MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1, x)], 2) # x + 2\nMathOptInterface.ScalarAffineFunction{Int64}(MathOptInterface.ScalarAffineTerm{Int64}[MathOptInterface.ScalarAffineTerm{Int64}(1, MathOptInterface.VariableIndex(1))], 2)","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"However, you can also use operators to build the same scalar function:","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> f = x + 2\nMathOptInterface.ScalarAffineFunction{Int64}(MathOptInterface.ScalarAffineTerm{Int64}[MathOptInterface.ScalarAffineTerm{Int64}(1, MathOptInterface.VariableIndex(1))], 2)","category":"page"},{"location":"moi/tutorials/manipulating_expressions/#Creating-scalar-quadratic-functions","page":"Manipulating expressions","title":"Creating scalar quadratic functions","text":"","category":"section"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"Scalar quadratic functions are stored in ScalarQuadraticFunction objects, in a way that is highly similar to scalar affine functions. You can obtain a quadratic function as a product of affine functions:","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> 1 * x * x\nMathOptInterface.ScalarQuadraticFunction{Int64}(MathOptInterface.ScalarQuadraticTerm{Int64}[MathOptInterface.ScalarQuadraticTerm{Int64}(2, MathOptInterface.VariableIndex(1), MathOptInterface.VariableIndex(1))], MathOptInterface.ScalarAffineTerm{Int64}[], 0)\n\njulia> f * f  # (x + 2)²\nMathOptInterface.ScalarQuadraticFunction{Int64}(MathOptInterface.ScalarQuadraticTerm{Int64}[MathOptInterface.ScalarQuadraticTerm{Int64}(2, MathOptInterface.VariableIndex(1), MathOptInterface.VariableIndex(1))], MathOptInterface.ScalarAffineTerm{Int64}[MathOptInterface.ScalarAffineTerm{Int64}(2, MathOptInterface.VariableIndex(1)), MathOptInterface.ScalarAffineTerm{Int64}(2, MathOptInterface.VariableIndex(1))], 4)\n\njulia> f^2  # (x + 2)² too\nMathOptInterface.ScalarQuadraticFunction{Int64}(MathOptInterface.ScalarQuadraticTerm{Int64}[MathOptInterface.ScalarQuadraticTerm{Int64}(2, MathOptInterface.VariableIndex(1), MathOptInterface.VariableIndex(1))], MathOptInterface.ScalarAffineTerm{Int64}[MathOptInterface.ScalarAffineTerm{Int64}(2, MathOptInterface.VariableIndex(1)), MathOptInterface.ScalarAffineTerm{Int64}(2, MathOptInterface.VariableIndex(1))], 4)","category":"page"},{"location":"moi/tutorials/manipulating_expressions/#Creating-vector-functions","page":"Manipulating expressions","title":"Creating vector functions","text":"","category":"section"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"A vector function is a function with several values, irrespective of the number of input variables. Similarly to scalar functions, there are three main types of vector functions: VectorOfVariables, VectorAffineFunction, and VectorQuadraticFunction.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"The easiest way to create a vector function is to stack several scalar functions using Utilities.vectorize. It takes a vector as input, and the generated vector function (of the most appropriate type) has each dimension corresponding to a dimension of the vector.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> g = MOI.Utilities.vectorize([f, 2 * f])\nMathOptInterface.VectorAffineFunction{Int64}(MathOptInterface.VectorAffineTerm{Int64}[MathOptInterface.VectorAffineTerm{Int64}(1, MathOptInterface.ScalarAffineTerm{Int64}(1, MathOptInterface.VariableIndex(1))), MathOptInterface.VectorAffineTerm{Int64}(2, MathOptInterface.ScalarAffineTerm{Int64}(2, MathOptInterface.VariableIndex(1)))], [2, 4])","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"warning: Warning\nUtilities.vectorize only takes a vector of similar scalar functions: you cannot mix VariableIndex and ScalarAffineFunction, for instance. In practice, it means that Utilities.vectorize([x, f]) does not work; you should rather use Utilities.vectorize([1 * x, f]) instead to only have ScalarAffineFunction objects.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/#Canonicalizing-functions","page":"Manipulating expressions","title":"Canonicalizing functions","text":"","category":"section"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"In more advanced use cases, you might need to ensure that a function is \"canonical\". Functions are stored as an array of terms, but there is no check that these terms are redundant: a ScalarAffineFunction object might have two terms with the same variable, like x + x + 1. These terms could be merged without changing the semantics of the function: 2x + 1.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"Working with these objects might be cumbersome. Canonicalization helps maintain redundancy to zero.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"Utilities.is_canonical checks whether a function is already in its canonical form:","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> MOI.Utilities.is_canonical(f + f) # (x + 2) + (x + 2) is stored as x + x + 4\nfalse","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"Utilities.canonical returns the equivalent canonical version of the function:","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> MOI.Utilities.canonical(f + f) # Returns 2x + 4\nMathOptInterface.ScalarAffineFunction{Int64}(MathOptInterface.ScalarAffineTerm{Int64}[MathOptInterface.ScalarAffineTerm{Int64}(2, MathOptInterface.VariableIndex(1))], 4)","category":"page"},{"location":"moi/tutorials/manipulating_expressions/#Exploring-functions","page":"Manipulating expressions","title":"Exploring functions","text":"","category":"section"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"At some point, you might need to dig into a function, for instance to map it into solver constructs.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/#Vector-functions","page":"Manipulating expressions","title":"Vector functions","text":"","category":"section"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"Utilities.scalarize returns a vector of scalar functions from a vector function:","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> MOI.Utilities.scalarize(g) # Returns a vector [f, 2 * f].\n2-element Vector{MathOptInterface.ScalarAffineFunction{Int64}}:\n MathOptInterface.ScalarAffineFunction{Int64}(MathOptInterface.ScalarAffineTerm{Int64}[MathOptInterface.ScalarAffineTerm{Int64}(1, MathOptInterface.VariableIndex(1))], 2)\n MathOptInterface.ScalarAffineFunction{Int64}(MathOptInterface.ScalarAffineTerm{Int64}[MathOptInterface.ScalarAffineTerm{Int64}(2, MathOptInterface.VariableIndex(1))], 4)","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"note: Note\nUtilities.eachscalar returns an iterator on the dimensions, which serves the same purpose as Utilities.scalarize.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"output_dimension returns the number of dimensions of the output of a function:","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> MOI.output_dimension(g)\n2","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/getting_started/getting_started_with_sets_and_indexing.jl\"","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Getting-started-with-sets-and-indexing","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Most introductory courses to linear programming will teach you to identify sets over which the decision variables and constraints are indexed. Therefore, it is common to write variables such as x_i for all i in I.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"A common stumbling block for new users to JuMP is that JuMP does not provide specialized syntax for constructing and manipulating these sets.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"We made this decision because Julia already provides a wealth of data structures for working with sets.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"In contrast, because tools like AMPL are stand-alone software packages, they had to define their own syntax for set construction and manipulation. Indeed, the AMPL Book has two entire chapters devoted to sets and indexing (V: Simple Sets and Indexing, and VI: Compound Sets and Indexing).","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"The purpose of this tutorial is to demonstrate a variety of ways in which you can construct and manipulate sets for optimization models.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"If you haven't already, you should first read Getting started with JuMP.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"using JuMP","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Unordered-sets","page":"Getting started with sets and indexing","title":"Unordered sets","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Unordered sets are useful to describe non-numeric indices, such as the names of cities or types of products.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"The most common way to construct a set is by creating a vector:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"animals = [\"dog\", \"cat\", \"chicken\", \"cow\", \"pig\"]\nmodel = Model()\n@variable(model, x[animals])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"We can also use things like the keys of a dictionary:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"weight_of_animals = Dict(\n    \"dog\" => 20.0,\n    \"cat\" => 5.0,\n    \"chicken\" => 2.0,\n    \"cow\" => 720.0,\n    \"pig\" => 150.0,\n)\nanimal_keys = keys(weight_of_animals)\nmodel = Model()\n@variable(model, x[animal_keys])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"A third option is to use Julia's Set object.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"animal_set = Set()\nfor animal in keys(weight_of_animals)\n    push!(animal_set, animal)\nend\nanimal_set","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"The nice thing about Sets is that they automatically remove duplicates:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"push!(animal_set, \"dog\")\nanimal_set","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Note how dog does not appear twice.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"model = Model()\n@variable(model, x[animal_set])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Sets-of-numbers","page":"Getting started with sets and indexing","title":"Sets of numbers","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Sets of numbers are useful to decribe sets that are ordered, such as years or elements in a vector. The easiest way to create sets of numbers is to use Julia's range syntax.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"These can start at 1:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"model = Model()\n@variable(model, x[1:4])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"but they don't have to:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"model = Model()\n@variable(model, x[2012:2021])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Ranges also have a start:step:stop syntax. So the Olympic years are:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"model = Model()\n@variable(model, x[1896:4:2020])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Sets-of-other-things","page":"Getting started with sets and indexing","title":"Sets of other things","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"An important observation is that you can have any Julia type as the element of a set. It doesn't have to be a String or a Number. For example, you can have tuples:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"sources = [\"A\", \"B\", \"C\"]\nsinks = [\"D\", \"E\"]\nS = [(source, sink) for source in sources, sink in sinks]\nmodel = Model()\n@variable(model, x[S])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"x[(\"A\", \"D\")]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"For multi-dimensional sets, you can use JuMP's syntax for constructing Containers:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"model = Model()\n@variable(model, x[sources, sinks])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"x[\"A\", \"D\"]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"info: Info\nNote how we indexed x[\"A\", \"D\"] instead of x[(\"A\", \"D\")] as above.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Set-operations","page":"Getting started with sets and indexing","title":"Set operations","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Julia has built-in support for set operations such as union, intersect, and  setdiff.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Therefore, to create a set of all years in which the summer Olympics were held, we can use:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"baseline = 1896:4:2020\ncancelled = [1916, 1940, 1944, 2020]\noff_year = [2021]\nolympic_years = union(setdiff(baseline, cancelled), off_year)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"You can also find the number of elements (i.e., the cardinality) in a set using length:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"length(olympic_years)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Set-membership-operations","page":"Getting started with sets and indexing","title":"Set membership operations","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"To compute membership of sets, use the in function.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"2000 in olympic_years","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"2001 in olympic_years","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Indexing-expressions","page":"Getting started with sets and indexing","title":"Indexing expressions","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Use Julia's generator syntax to compute new sets, such as the list of Olympic years that are divisible by 3:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"olympic_3_years = [year for year in olympic_years if mod(year, 3) == 0]\nmodel = Model()\n@variable(model, x[olympic_3_years])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Alternatively, use JuMP's syntax for constructing Containers:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"model = Model()\n@variable(model, x[year in olympic_years; mod(year, 3) == 0])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Compound-sets","page":"Getting started with sets and indexing","title":"Compound sets","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Consider a transportation problem in which we need to ship goods between cities. We have been provided a list of cities:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"cities = [\"Auckland\", \"Wellington\", \"Christchurch\", \"Dunedin\"]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"and a distance matrix which records the shipping distance between pairs of cities. If we can't ship between two cities, the distance is 0.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"distances = [0 643 1071 1426; 0 0 436 790; 0 0 0 360; 1426 0 0 0]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Let's have a look at ways we could write a model with an objective function to minimize the total shipping cost. For simplicity, we'll ignore all constraints.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Fix-unused-variables","page":"Getting started with sets and indexing","title":"Fix unused variables","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"One approach is to fix all variables that we can't use to zero. Most solvers are smart-enough to remove these during a presolve phase, so it has a very small impact on performance:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"N = length(cities)\nmodel = Model()\n@variable(model, x[1:N, 1:N] >= 0)\nfor i in 1:N, j in 1:N\n    if distances[i, j] == 0\n        fix(x[i, j], 0.0; force = true)\n    end\nend\n@objective(model, Min, sum(distances[i, j] * x[i, j] for i in 1:N, j in 1:N))","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Filtered-summation","page":"Getting started with sets and indexing","title":"Filtered summation","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Another approach is to define filters whenever we want to sum over our decision variables:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"N = length(cities)\nmodel = Model()\n@variable(model, x[1:N, 1:N] >= 0)\n@objective(\n    model,\n    Min,\n    sum(\n        distances[i, j] * x[i, j] for i in 1:N, j in 1:N if distances[i, j] > 0\n    ),\n)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Filtered-indexing","page":"Getting started with sets and indexing","title":"Filtered indexing","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"We could also use JuMP's support for Containers:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"N = length(cities)\nmodel = Model()\n@variable(model, x[i = 1:N, j = 1:N; distances[i, j] > 0])\n@objective(model, Min, sum(distances[i...] * x[i] for i in eachindex(x)))","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"note: Note\nThe i... is called  a \"splat\". It converts a tuple like (1, 2) into two indices like distances[1, 2].","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Converting-to-a-different-data-structure","page":"Getting started with sets and indexing","title":"Converting to a different data structure","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Another approach, and one that is often the most readable, is to convert the data you have into something that is easier to work with. Originally, we had a vector of strings and a matrix of distances. What we really need is something that maps usable origin-destination pairs to distances. A dictionary is an obvious choice:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"routes = Dict(\n    (a, b) => distances[i, j] for\n    (i, a) in enumerate(cities), (j, b) in enumerate(cities) if\n    distances[i, j] > 0\n)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Then, we can create our model like so:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"model = Model()\n@variable(model, x[keys(routes)])\n@objective(model, Min, sum(v * x[k] for (k, v) in routes))","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"This has a number of benefits over the other approaches, including a compacter algebraic model and variables that are named in a more meaningful way.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"tip: Tip\nIf you're struggling to formulate a problem using the available syntax in JuMP, it's probably a sign that you should convert your data into a different form.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Next-steps","page":"Getting started with sets and indexing","title":"Next steps","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"The purpose of this tutorial was to show how JuMP does not have specialized syntax for set creation and manipulation. Instead, you should use the tools provided by Julia itself.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"This is both an opportunity and a challenge, because you are free to pick the syntax and data structures that best suit your problem, but for new users it can be daunting to decide which structure to use.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Read through some of the other JuMP tutorials to get inspiration and ideas for how you can use Julia's syntax and data structures to your advantage.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"tutorials/linear/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/linear/urban_plan.jl\"","category":"page"},{"location":"tutorials/linear/urban_plan/#The-urban-planning-problem","page":"The urban planning problem","title":"The urban planning problem","text":"","category":"section"},{"location":"tutorials/linear/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"An \"urban planning\" problem based on an example from puzzlor.","category":"page"},{"location":"tutorials/linear/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_urban_plan()\n    model = Model(GLPK.Optimizer)\n    # x is indexed by row and column\n    @variable(model, 0 <= x[1:5, 1:5] <= 1, Int)\n    # y is indexed by R or C, the points, and an index in 1:5. Note how JuMP\n    # allows indexing on arbitrary sets.\n    rowcol = [\"R\", \"C\"]\n    points = [5, 4, 3, -3, -4, -5]\n    @variable(model, 0 <= y[rowcol, points, 1:5] <= 1, Int)\n    # Objective - combine the positive and negative parts\n    @objective(\n        model,\n        Max,\n        sum(\n            3 * (y[\"R\", 3, i] + y[\"C\", 3, i]) +\n            1 * (y[\"R\", 4, i] + y[\"C\", 4, i]) +\n            1 * (y[\"R\", 5, i] + y[\"C\", 5, i]) -\n            3 * (y[\"R\", -3, i] + y[\"C\", -3, i]) -\n            1 * (y[\"R\", -4, i] + y[\"C\", -4, i]) -\n            1 * (y[\"R\", -5, i] + y[\"C\", -5, i]) for i in 1:5\n        )\n    )\n    # Constrain the number of residential lots\n    @constraint(model, sum(x) == 12)\n    # Add the constraints that link the auxiliary y variables to the x variables\n    for i in 1:5\n        @constraints(model, begin\n            # Rows\n            y[\"R\", 5, i] <= 1 / 5 * sum(x[i, :]) # sum = 5\n            y[\"R\", 4, i] <= 1 / 4 * sum(x[i, :]) # sum = 4\n            y[\"R\", 3, i] <= 1 / 3 * sum(x[i, :]) # sum = 3\n            y[\"R\", -3, i] >= 1 - 1 / 3 * sum(x[i, :]) # sum = 2\n            y[\"R\", -4, i] >= 1 - 1 / 2 * sum(x[i, :]) # sum = 1\n            y[\"R\", -5, i] >= 1 - 1 / 1 * sum(x[i, :]) # sum = 0\n            # Columns\n            y[\"C\", 5, i] <= 1 / 5 * sum(x[:, i]) # sum = 5\n            y[\"C\", 4, i] <= 1 / 4 * sum(x[:, i]) # sum = 4\n            y[\"C\", 3, i] <= 1 / 3 * sum(x[:, i]) # sum = 3\n            y[\"C\", -3, i] >= 1 - 1 / 3 * sum(x[:, i]) # sum = 2\n            y[\"C\", -4, i] >= 1 - 1 / 2 * sum(x[:, i]) # sum = 1\n            y[\"C\", -5, i] >= 1 - 1 / 1 * sum(x[:, i]) # sum = 0\n        end)\n    end\n    # Solve it\n    optimize!(model)\n    Test.@test termination_status(model) == OPTIMAL\n    Test.@test primal_status(model) == FEASIBLE_POINT\n    Test.@test objective_value(model) ≈ 14.0\n    return\nend\n\nexample_urban_plan()","category":"page"},{"location":"tutorials/linear/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"","category":"page"},{"location":"tutorials/linear/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Bridges/overview/#The-Bridges-submodule","page":"Overview","title":"The Bridges submodule","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"The Bridges module simplifies the process of converting models between equivalent formulations.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"tip: Tip\nRead our paper for more details on how bridges are implemented.","category":"page"},{"location":"moi/submodules/Bridges/overview/#Why-bridges?","page":"Overview","title":"Why bridges?","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"A constraint can often be written in a number of equivalent formulations. For example, the constraint l le a^top x le u (ScalarAffineFunction-in-Interval) could be re-formulated as two constraints: a^top x ge l (ScalarAffineFunction-in-GreaterThan) and a^top x le u (ScalarAffineFunction-in-LessThan). An alternative re-formulation is to add a dummy variable y with the constraints l le y le u (VariableIndex-in-Interval) and a^top x - y = 0 (ScalarAffineFunction-in-EqualTo).","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"To avoid each solver having to code these transformations manually, MathOptInterface provides bridges.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"A bridge is a small transformation from one constraint type to another (potentially collection of) constraint type.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Because these bridges are included in MathOptInterface, they can be re-used by any optimizer. Some bridges also implement constraint modifications and constraint primal and dual translations.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Several bridges can be used in combination to transform a single constraint into a form that the solver may understand. Choosing the bridges to use takes the form of finding a shortest path in the hypergraph of bridges. The methodology is detailed in the MOI paper.","category":"page"},{"location":"moi/submodules/Bridges/overview/#The-three-types-of-bridges","page":"Overview","title":"The three types of bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"There are three types of bridges in MathOptInterface:","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Constraint bridges\nVariable bridges\nObjective bridges","category":"page"},{"location":"moi/submodules/Bridges/overview/#Constraint-bridges","page":"Overview","title":"Constraint bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Constraint bridges convert constraints formulated by the user into an equivalent form supported by the solver. Constraint bridges are subtypes of Bridges.Constraint.AbstractBridge.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"The equivalent formulation may add constraints (and possibly also variables) in the underlying model.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"In particular, constraint bridges can focus on rewriting the function of a constraint, and do not change the set. Function bridges are subtypes of Bridges.Constraint.AbstractFunctionConversionBridge.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Read the list of implemented constraint bridges for more details on the types of transformations that are available. Function bridges are Bridges.Constraint.ScalarFunctionizeBridge and Bridges.Constraint.VectorFunctionizeBridge.","category":"page"},{"location":"moi/submodules/Bridges/overview/#variable_bridges","page":"Overview","title":"Variable bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Variable bridges convert variables added by the user, either free with add_variable/add_variables, or constrained with add_constrained_variable/add_constrained_variables, into an equivalent form supported by the solver. Variable bridges are subtypes of Bridges.Variable.AbstractBridge.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"The equivalent formulation may add constraints (and possibly also variables) in the underlying model.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Read the list of implemented variable bridges for more details on the types of transformations that are available.","category":"page"},{"location":"moi/submodules/Bridges/overview/#Objective-bridges","page":"Overview","title":"Objective bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Objective bridges convert the ObjectiveFunction set by the user into an equivalent form supported by the solver. Objective bridges are subtypes of Bridges.Objective.AbstractBridge.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"The equivalent formulation may add constraints (and possibly also variables) in the underlying model.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Read the list of implemented objective bridges for more details on the types of transformations that are available.","category":"page"},{"location":"moi/submodules/Bridges/overview/#Bridges.full_bridge_optimizer","page":"Overview","title":"Bridges.full_bridge_optimizer","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"tip: Tip\nUnless you have an advanced use-case, this is probably the only function you need to care about.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"To enable the full power of MathOptInterface's bridges, wrap an optimizer in a Bridges.full_bridge_optimizer.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"julia> inner_optimizer = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> optimizer = MOI.Bridges.full_bridge_optimizer(inner_optimizer, Float64)\nMOIB.LazyBridgeOptimizer{MOIU.Model{Float64}}\nwith 0 variable bridges\nwith 0 constraint bridges\nwith 0 objective bridges\nwith inner model MOIU.Model{Float64}","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"That's all you have to do! Use optimizer as normal, and bridging will happen lazily behind the scenes. By lazily, we mean that bridging will only happen if the constraint is not supported by the inner_optimizer.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"info: Info\nMost bridges are added by default in Bridges.full_bridge_optimizer. However, for technical reasons, some bridges are not added by default. Three examples include Bridges.Constraint.SOCtoPSDBridge, Bridges.Constraint.SOCtoNonConvexQuadBridge and Bridges.Constraint.RSOCtoNonConvexQuadBridge. See the docs of those bridges for more information.","category":"page"},{"location":"moi/submodules/Bridges/overview/#Add-a-single-bridge","page":"Overview","title":"Add a single bridge","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"If you don't want to use Bridges.full_bridge_optimizer, you can wrap an optimizer in a single bridge.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"However, this will force the constraint to be bridged, even if the inner_optimizer supports it.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"julia> inner_optimizer = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> optimizer = MOI.Bridges.Constraint.SplitInterval{Float64}(inner_optimizer)\nMOIB.Constraint.SingleBridgeOptimizer{MOIB.Constraint.SplitIntervalBridge{Float64, F, S, LS, US} where {F<:MOI.AbstractFunction, S<:MOI.AbstractSet, LS<:MOI.AbstractSet, US<:MOI.AbstractSet}, MOIU.Model{Float64}}\nwith 0 constraint bridges\nwith inner model MOIU.Model{Float64}\n\njulia> x = MOI.add_variable(optimizer)\nMOI.VariableIndex(1)\n\njulia> MOI.add_constraint(optimizer, x, MOI.Interval(0.0, 1.0))\nMathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64}}(1)\n\njulia> MOI.get(optimizer, MOI.ListOfConstraintTypesPresent())\n1-element Vector{Tuple{Type, Type}}:\n (MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64})\n\njulia> MOI.get(inner_optimizer, MOI.ListOfConstraintTypesPresent())\n2-element Vector{Tuple{Type, Type}}:\n (MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64})\n (MathOptInterface.VariableIndex, MathOptInterface.LessThan{Float64})","category":"page"},{"location":"moi/submodules/Bridges/overview/#Bridges.LazyBridgeOptimizer","page":"Overview","title":"Bridges.LazyBridgeOptimizer","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"If you don't want to use Bridges.full_bridge_optimizer, but you need more than a single bridge (or you want the bridging to happen lazily), you can manually construct a Bridges.LazyBridgeOptimizer.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"First, wrap an inner optimizer:","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"julia> inner_optimizer = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> optimizer = MOI.Bridges.LazyBridgeOptimizer(inner_optimizer)\nMOIB.LazyBridgeOptimizer{MOIU.Model{Float64}}\nwith 0 variable bridges\nwith 0 constraint bridges\nwith 0 objective bridges\nwith inner model MOIU.Model{Float64}","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Then use Bridges.add_bridge to add individual bridges:","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Bridges.add_bridge(optimizer, MOI.Bridges.Constraint.SplitIntervalBridge{Float64})\n\njulia> MOI.Bridges.add_bridge(optimizer, MOI.Bridges.Objective.FunctionizeBridge{Float64})","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Now the constraints will be bridged only if needed:","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"julia> x = MOI.add_variable(optimizer)\nMOI.VariableIndex(1)\n\njulia> MOI.add_constraint(optimizer, x, MOI.Interval(0.0, 1.0))\nMathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64}}(1)\n\njulia> MOI.get(optimizer, MOI.ListOfConstraintTypesPresent())\n1-element Vector{Tuple{Type, Type}}:\n (MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64})\n\njulia> MOI.get(inner_optimizer, MOI.ListOfConstraintTypesPresent())\n1-element Vector{Tuple{Type, Type}}:\n (MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64})","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/getting_started/getting_started_with_data_and_plotting.jl\"","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Getting-started-with-data-and-plotting","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"In this tutorial we will learn how to read tabular data into Julia, and some of the basics of plotting.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"If you're new to Julia, start by reading Getting started with Julia and Getting started with JuMP first.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"note: Note\nThere are multiple ways to read the same kind of data into Julia. This tutorial focuses on DataFrames.jl because it provides the ecosystem to work with most of the required file types in a straightforward manner.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Before we get started, we need this constant to point to where the data files are.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"const DATA_DIR = joinpath(@__DIR__, \"data\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Where-to-get-help","page":"Getting started with data and plotting","title":"Where to get help","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Read the documentation","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Plots.jl: http://docs.juliaplots.org/latest/\nCSV.jl: http://csv.juliadata.org/stable\nDataFrames.jl: https://dataframes.juliadata.org/stable/","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Preliminaries","page":"Getting started with data and plotting","title":"Preliminaries","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"To get started, we need to install some packages.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#DataFrames.jl","page":"Getting started with data and plotting","title":"DataFrames.jl","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The DataFrames package provides a set of tools for working with tabular data. It is available through the Julia package manager.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"using Pkg\nPkg.add(\"DataFrames\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"import DataFrames","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"!!! info What is a DataFrame?     A DataFrame is a data structure like a table or spreadsheet. You can use     it for storing and exploring a set of related data values. Think of it as     a smarter array for holding tabular data.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Plots.jl","page":"Getting started with data and plotting","title":"Plots.jl","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The Plots package provides a set of tools for plotting. It is available through the Julia package manager.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"using Pkg\nPkg.add(\"Plots\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"import Plots","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#CSV-.jl","page":"Getting started with data and plotting","title":"CSV .jl","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"CSV and other delimited text files can be read by the CSV.jl package.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Pkg.add(\"CSV\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"import CSV","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#DataFrame-basics","page":"Getting started with data and plotting","title":"DataFrame basics","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"To read a CSV file into a DataFrame, we use the CSV.read function.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df = CSV.read(joinpath(DATA_DIR, \"StarWars.csv\"), DataFrames.DataFrame)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Let's try plotting some of this data","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Plots.scatter(\n    csv_df.Weight,\n    csv_df.Height,\n    xlabel = \"Weight\",\n    ylabel = \"Height\",\n)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"That doesn't look right. What happened? If you look at the dataframe above, it read Weight in as a String column because there are \"NA\" fields. Let's correct that, by telling CSV to consider \"NA\" as missing.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df = CSV.read(\n    joinpath(DATA_DIR, \"StarWars.csv\"),\n    DataFrames.DataFrame,\n    missingstring = \"NA\",\n)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Then let's re-plot our data","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Plots.scatter(\n    csv_df.Weight,\n    csv_df.Height,\n    title = \"Height vs Weight of StarWars characters\",\n    xlabel = \"Weight\",\n    ylabel = \"Height\",\n    label = false,\n    ylims = (0, 3),\n)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Better!","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"tip: Tip\nRead the CSV documentation for other parsing options.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"DataFrames.jl supports manipulation using functions similar to pandas. For example, split the dataframe into groups based on eye-color:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"by_eyecolor = DataFrames.groupby(csv_df, :Eyecolor)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Then recombine into a single dataframe based on a function operating over the split dataframes:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"eyecolor_count = DataFrames.combine(by_eyecolor) do df\n    return DataFrames.nrow(df)\nend","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"We can rename columns:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"DataFrames.rename!(eyecolor_count, :x1 => :count)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Drop some missing rows:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"DataFrames.dropmissing!(eyecolor_count, :Eyecolor)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Then we can visualize the data:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"sort!(eyecolor_count, :count, rev = true)\nPlots.bar(\n    eyecolor_count.Eyecolor,\n    eyecolor_count.count,\n    xlabel = \"Eyecolor\",\n    ylabel = \"Number of characters\",\n    label = false,\n)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Other-Delimited-Files","page":"Getting started with data and plotting","title":"Other Delimited Files","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"We can also use the CSV.jl package to read any other delimited text file format.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"By default, CSV.File will try to detect a file's delimiter from the first 10 lines of the file.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Candidate delimiters include ',', '\\t', ' ', '|', ';', and ':'. If it can't auto-detect the delimiter, it will assume ','.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Let's take the example of space separated data.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"ss_df = CSV.read(joinpath(DATA_DIR, \"Cereal.txt\"), DataFrames.DataFrame)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"We can also specify the delimiter by passing the delim argument.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"delim_df = CSV.read(\n    joinpath(DATA_DIR, \"Soccer.txt\"),\n    DataFrames.DataFrame,\n    delim = \"::\",\n)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Working-with-DataFrames","page":"Getting started with data and plotting","title":"Working with DataFrames","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Now that we have read the required data into a DataFrame, let us look at some basic operations we can perform on it.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Querying-Basic-Information","page":"Getting started with data and plotting","title":"Querying Basic Information","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The size function gets us the dimensions of the DataFrame:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"DataFrames.size(ss_df)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"We can also use the nrow and ncol functions to get the number of rows and columns respectively:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"DataFrames.nrow(ss_df), DataFrames.ncol(ss_df)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The describe function gives basic summary statistics of data in a DataFrame:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"DataFrames.describe(ss_df)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Names of every column can be obtained by the names function:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"DataFrames.names(ss_df)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Corresponding data types are obtained using the broadcasted eltype function:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"eltype.(ss_df)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Accessing-the-Data","page":"Getting started with data and plotting","title":"Accessing the Data","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Similar to regular arrays, we use numerical indexing to access elements of a DataFrame:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df[1, 1]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The following are different ways to access a column:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df[!, 1]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df[!, :Name]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df.Name","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df[:, 1] # Note that this creates a copy.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The following are different ways to access a row:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df[1:1, :]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df[1, :] # This produces a DataFrameRow.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"We can change the values just as we normally assign values.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Assign a range to scalar:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df[1:3, :Height] .= 1.83","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Assign a vector:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df[4:6, :Height] = [1.8, 1.6, 1.8]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"tip: Tip\nThere are a lot more things which can be done with a DataFrame. Read the docs for more information.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"For information on dplyr-type syntax:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Read the DataFrames.jl documentation\nCheck out DataFramesMeta.jl","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Example:-the-passport-problem","page":"Getting started with data and plotting","title":"Example: the passport problem","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Let's now apply what we have learned to solve a real problem.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Data-manipulation","page":"Getting started with data and plotting","title":"Data manipulation","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The Passport Index Dataset lists travel visa requirements for 199 countries, in .csv format. Our task is to find the minimum number of passports required to visit all countries.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"passport_data = CSV.read(\n    joinpath(DATA_DIR, \"passport-index-matrix.csv\"),\n    DataFrames.DataFrame,\n)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"In this dataset, the first column represents a passport (=from) and each remaining column represents a foreign country (=to).","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The values in each cell are as follows:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"3 = visa-free travel\n2 = eTA is required\n1 = visa can be obtained on arrival\n0 = visa is required\n-1 is for all instances where passport and destination are the same","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Our task is to find out the minimum number of passports needed to visit every country without requiring a visa.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The values we are interested in are -1 and 3. Let's modify the dataframe so that the -1 and 3 are 1 (true), and all others are 0 (false):","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"function modifier(x)\n    if x == -1 || x == 3\n        return 1\n    else\n        return 0\n    end\nend\n\nfor country in passport_data.Passport\n    passport_data[!, country] = modifier.(passport_data[!, country])\nend\n\npassport_data","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The values in the cells now represent:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"1 = no visa required for travel\n0 = visa required for travel","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#JuMP-Modeling","page":"Getting started with data and plotting","title":"JuMP Modeling","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"To model the problem as a mixed-integer linear program, we need a binary decision variable x_c for each country c. x_c is 1 if we select passport c and 0 otherwise. Our objective is to minimize the sum sum x_c over all countries.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Since we wish to visit all the countries, for every country, we must own at least one passport that lets us travel to that country visa free. For one destination, this can be mathematically represented as sum_c in C a_cd cdot x_d geq 1, where a is the passport_data dataframe.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Thus, we can represent this problem using the following model:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"beginaligned\nmin  sum_c in C x_c \ntextst  sum_c in C a_cd x_c geq 1  forall d in C \n x_c in 01  forall c in C\nendaligned","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"We'll now solve the problem using JuMP:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"using JuMP\nimport GLPK","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"First, create the set of countries:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"C = passport_data.Passport","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Then, create the model and initialize the decision variables:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"model = Model(GLPK.Optimizer)\n@variable(model, x[C], Bin)\n@objective(model, Min, sum(x))\n@constraint(model, [d in C], passport_data[!, d]' * x >= 1)\nmodel","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Now optimize!","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"optimize!(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"We can use the solution_summary function to get an overview of the solution:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"solution_summary(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Solution","page":"Getting started with data and plotting","title":"Solution","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Let's  have a look at the solution in more detail:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"println(\"Minimum number of passports needed: \", objective_value(model))","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"println(\"Optimal passports:\")\nfor c in C\n    if value(x[c]) > 0.5\n        println(\" * \", c)\n    end\nend","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Interesting! We need some passports, like Australia and the United States, which have widespread access to a large number of countries. However, we also need passports like North Korea which only have visa-free access to a very limited number of countries.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"note: Note\nWe use value(x[c]) > 0.5 rather than value(x[c]) == 1 to avoid excluding solutions like x[c] = 0.99999 that are \"1\" to some tolerance.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"developers/style/#Style-guide-and-design-principles","page":"Style Guide","title":"Style guide and design principles","text":"","category":"section"},{"location":"developers/style/#Style-guide","page":"Style Guide","title":"Style guide","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"This section describes the coding style rules that apply to JuMP code and that we recommend for JuMP models and surrounding Julia code. The motivations for a style guide include:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"conveying best practices for writing readable and maintainable code\nreducing the amount of time spent on bike-shedding by establishing basic naming and formatting conventions\nlowering the barrier for new contributors by codifying the existing practices (e.g., you can be more confident your code will pass review if you follow the style guide)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"In some cases, the JuMP style guide diverges from the Julia style guide. All such cases will be explicitly noted and justified.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"The JuMP style guide adopts many recommendations from the Google style guides.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"info: Info\nThe style guide is always a work in progress, and not all JuMP code follows the rules. When modifying JuMP, please fix the style violations of the surrounding code (i.e., leave the code tidier than when you started). If large changes are needed, consider separating them into another PR.","category":"page"},{"location":"developers/style/#JuliaFormatter","page":"Style Guide","title":"JuliaFormatter","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"JuMP uses JuliaFormatter.jl as an autoformatting tool.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"We use the options contained in .JuliaFormatter.toml.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"To format code, cd to the JuMP directory, then run:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"] add JuliaFormatter@0.13.2\nusing JuliaFormatter\nformat(\"src\")\nformat(\"test\")","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"info: Info\nA continuous integration check verifies that all PRs made to JuMP have passed the formatter.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"The following sections outline extra style guide points that are not fixed automatically by JuliaFormatter.","category":"page"},{"location":"developers/style/#Whitespace","page":"Style Guide","title":"Whitespace","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For conciseness, never use more than one blank line within a function, and never begin a function with a blank line.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"function foo(x)\n    y = 2 * x\n\n\n    return y\nend\n\nfunction foo(x)\n\n    y = 2 * x\n    return y\nend","category":"page"},{"location":"developers/style/#Juxtaposed-multiplication","page":"Style Guide","title":"Juxtaposed multiplication","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Only use juxtaposed multiplication when the right-hand side is a symbol.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"2x  # Acceptable if there are space constraints.\n2 * x  # This is preferred if space is not an issue.\n2 * (x + 1)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"2(x + 1)","category":"page"},{"location":"developers/style/#Empty-vectors","page":"Style Guide","title":"Empty vectors","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For a type T, T[] and Vector{T}() are equivalent ways to create an empty vector with element type T. Prefer T[] because it is more concise.","category":"page"},{"location":"developers/style/#Comments","page":"Style Guide","title":"Comments","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For non-native speakers and for general clarity, comments in code must be proper English sentences with appropriate punctuation.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"# This is a comment demonstrating a good comment.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"# a bad comment","category":"page"},{"location":"developers/style/#JuMP-macro-syntax","page":"Style Guide","title":"JuMP macro syntax","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For consistency, always use parentheses.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable model x >= 0","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For consistency, always use constant * variable as opposed to variable * constant. This makes it easier to read models in ambiguous cases like a * x.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"a = 4\n@constraint(model, 3 * x <= 1)\n@constraint(model, a * x <= 1)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"a = 4\n@constraint(model, x * 3 <= 1)\n@constraint(model, x * a <= 1)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"In order to reduce boilerplate code, prefer the plural form of macros over lots of repeated calls to singular forms.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variables(model, begin\n    x >= 0\n    y >= 1\n    z <= 2\nend)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0)\n@variable(model, y >= 1)\n@variable(model, z <= 2)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"An exception is made for calls with many keyword arguments, since these need to be enclosed in parentheses in order to parse properly.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Acceptable:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0, start = 0.0, base_name = \"my_x\")\n@variable(model, y >= 1, start = 2.0)\n@variable(model, z <= 2, start = -1.0)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Also acceptable:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variables(model, begin\n    x >= 0, (start = 0.0, base_name = \"my_x\")\n    y >= 1, (start = 2.0)\n    z <= 2, (start = -1.0)\nend)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"While we always use in for for-loops, it is acceptable to use = in the container declarations of JuMP macros.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Okay:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x[i=1:3])","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Also okay:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x[i in 1:3])","category":"page"},{"location":"developers/style/#Naming","page":"Style Guide","title":"Naming","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"module SomeModule end\nfunction some_function end\nconst SOME_CONSTANT = ...\nstruct SomeStruct\n  some_field::SomeType\nend\n@enum SomeEnum ENUM_VALUE_A ENUM_VALUE_B\nsome_local_variable = ...\nsome_file.jl # Except for ModuleName.jl.","category":"page"},{"location":"developers/style/#Exported-and-non-exported-names","page":"Style Guide","title":"Exported and non-exported names","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Begin private module level functions and constants with an underscore. All other objects in the scope of a module should be exported. (See JuMP.jl for an example of how to do this.)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Names beginning with an underscore should only be used for distinguishing between exported (public) and non-exported (private) objects. Therefore, never begin the name of a local variable with an underscore.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"module MyModule\n\nexport public_function, PUBLIC_CONSTANT\n\nfunction _private_function()\n    local_variable = 1\n    return\nend\n\nfunction public_function end\n\nconst _PRIVATE_CONSTANT = 3.14159\nconst PUBLIC_CONSTANT = 1.41421\n\nend","category":"page"},{"location":"developers/style/#Use-of-underscores-within-names","page":"Style Guide","title":"Use of underscores within names","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"The Julia style guide recommends avoiding underscores \"when readable\", for example, haskey, isequal, remotecall, and remotecall_fetch. This convention creates the potential for unnecessary bikeshedding and also forces the user to recall the presence/absence of an underscore, e.g., \"was that argument named basename or base_name?\". For consistency, always use underscores in variable names and function names to separate words.","category":"page"},{"location":"developers/style/#Use-of-!","page":"Style Guide","title":"Use of !","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Julia has a convention of appending ! to a function name if the function modifies its arguments. We recommend to:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Omit ! when the name itself makes it clear that modification is taking place, e.g., add_constraint and set_name. We depart from the Julia style guide because ! does not provide a reader with any additional information in this case, and adherence to this convention is not uniform even in base Julia itself (consider Base.println and Base.finalize).\nUse ! in all other cases. In particular it can be used to distinguish between modifying and non-modifying variants of the same function like scale and scale!.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Note that ! is not a self-documenting feature because it is still ambiguous which arguments are modified when multiple arguments are present. Be sure to document which arguments are modified in the method's docstring.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"See also the Julia style guide recommendations for ordering of function arguments.","category":"page"},{"location":"developers/style/#Abbreviations","page":"Style Guide","title":"Abbreviations","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Abbreviate names to make the code more readable, not to save typing. Don't arbitrarily delete letters from a word to abbreviate it (e.g., indx). Use abbreviations consistently within a body of code (e.g., do not mix con and constr, idx and indx).","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Common abbreviations:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"num for number\ncon for constraint","category":"page"},{"location":"developers/style/#No-one-letter-variable-names","page":"Style Guide","title":"No one-letter variable names","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Where possible, avoid one-letter variable names.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Use model = Model() instead of m = Model()","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Exceptions are made for indices in loops.","category":"page"},{"location":"developers/style/#User-facing-MethodError","page":"Style Guide","title":"User-facing MethodError","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Specifying argument types for methods is mostly optional in Julia, which means that it's possible to find out that you are working with unexpected types deep in the call chain. Avoid this situation or handle it with a helpful error message. A user should see a MethodError only for methods that they called directly.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"_internal_function(x::Integer) = x + 1\n# The user sees a MethodError for _internal_function when calling\n# public_function(\"a string\"). This is not very helpful.\npublic_function(x) = _internal_function(x)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"_internal_function(x::Integer) = x + 1\n# The user sees a MethodError for public_function when calling\n# public_function(\"a string\"). This is easy to understand.\npublic_function(x::Integer) = _internal_function(x)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"If it is hard to provide an error message at the top of the call chain, then the following pattern is also ok:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"_internal_function(x::Integer) = x + 1\nfunction _internal_function(x)\n    error(\n        \"Internal error. This probably means that you called \" *\n        \"public_function() with the wrong type.\",\n    )\nend\npublic_function(x) = _internal_function(x)","category":"page"},{"location":"developers/style/#@enum-vs.-Symbol","page":"Style Guide","title":"@enum vs. Symbol","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"The @enum macro lets you define types with a finite number of values that are explicitly enumerated (like enum in C/C++). Symbols are lightweight strings that are used to represent identifiers in Julia (for example, :x).","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@enum provides type safety and can have docstrings attached to explain the possible values. Use @enums when applicable, e.g., for reporting statuses. Use strings to provide long-form additional information like error messages.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Use of Symbol should typically be reserved for identifiers, e.g., for lookup in the JuMP model (model[:my_variable]).","category":"page"},{"location":"developers/style/#using-vs.-import","page":"Style Guide","title":"using vs. import","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"using ModuleName brings all symbols exported by the module ModuleName into scope, while import ModuleName brings only the module itself into scope. (See the Julia manual) for examples and more details.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For the same reason that from <module> import * is not recommended in python (PEP 8), avoid using ModuleName except in throw-away scripts or at the REPL. The using statement makes it harder to track where symbols come from and exposes the code to ambiguities when two modules export the same symbol.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Prefer using ModuleName: x, p to import ModuleName.x, ModuleName.p and import MyModule: x, p because the import versions allow method extension without qualifying with the module name.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Similarly, using ModuleName: ModuleName is an acceptable substitute for import ModuleName, because it does not bring all symbols exported by ModuleName into scope. However, we prefer import ModuleName for consistency.","category":"page"},{"location":"developers/style/#Documentation","page":"Style Guide","title":"Documentation","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"This section describes the writing style that should be used when writing documentation for JuMP (and supporting packages).","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"We can recommend the documentation style guides by Divio, Google, and Write the Docs as general reading for those writing documentation. This guide delegates a thorough handling of the topic to those guides and instead elaborates on the points more specific to Julia and documentation that use Documenter.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Be concise\nUse lists instead of long sentences\nUse numbered lists when describing a sequence, e.g., (1) do X, (2) then Y\nUse bullet points when the items are not ordered\nExample code should be covered by doctests\nWhen a word is a Julia symbol and not an English word, enclose it with backticks. In addition, if it has a docstring in this doc add a link using @ref. If it is a plural, add the \"s\" after the closing backtick. For example,\n[`VariableRef`](@ref)s\nUse @meta blocks for TODOs and other comments that shouldn't be visible to readers. For example,\n```@meta\n# TODO: Mention also X, Y, and Z.\n```","category":"page"},{"location":"developers/style/#Docstrings","page":"Style Guide","title":"Docstrings","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Every exported object needs a docstring\nAll examples in docstrings should be jldoctests\nAlways use complete English sentences with proper punctuation\nDo not terminate lists with punctuation (e.g., as in this doc)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Here is an example:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"\"\"\"\n    signature(args; kwargs...)\n\nShort sentence describing the function.\n\nOptional: add a slightly longer paragraph describing the function.\n\n## Notes\n\n - List any notes that the user should be aware of\n\n## Examples\n\n```jldoctest\njulia> 1 + 1\n2\n```\n\"\"\"","category":"page"},{"location":"developers/style/#Testing","page":"Style Guide","title":"Testing","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Use a module to encapsulate tests, and structure all tests as functions. This avoids leaking local variables between tests.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Here is a basic skeleton:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"module TestPkg\n\nusing Test\n\n_helper_function() = 2\n\nfunction test_addition()\n    @test 1 + 1 == _helper_function()\nend\n\nfunction runtests()\n    for name in names(@__MODULE__; all = true)\n        if startswith(\"$(name)\", \"test_\")\n            @testset \"$(name)\" begin\n                getfield(@__MODULE__, name)()\n            end\n        end\n    end\nend\n\nend # TestPkg\n\nTestPkg.runtests()","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Break the tests into multiple files, with one module per file, so that subsets of the codebase can be tested by calling include with the relevant file.","category":"page"},{"location":"developers/style/#Design-principles","page":"Style Guide","title":"Design principles","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"TODO: How to structure and test large JuMP models, libraries that use JuMP.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For how to write a solver, see MOI.","category":"page"},{"location":"developers/roadmap/#Development-roadmap","page":"Roadmap","title":"Development roadmap","text":"","category":"section"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"This page is not JuMP documentation per se but are notes for the JuMP community. The JuMP developers have compiled this roadmap document to share their plans and goals. Contributions to roadmap issues are especially invited.","category":"page"},{"location":"developers/roadmap/#JuMP-1.0","page":"Roadmap","title":"JuMP 1.0","text":"","category":"section"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"JuMP 1.0 will be ready to release roughly when all of these tasks are completed. Some but not all of these tasks are summarized in the JuMP 1.0 milestone.","category":"page"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"Create a website for JuMP (Done: jump.dev)\nDeprecate the JuliaOpt organization and move repositories to the JuMP-dev organization (Done)\nAddress major regressions from JuMP 0.18\nPerformance (#1403,              #1654,              #1607)\nCallbacks (Done: see examples/callbacks.jl)\nColumn generation syntax (Done: see examples/cutting_stock_column_generation.jl)\nSupport for second-order cones in Gurobi, CPLEX, and Xpress (Done)\nFix issues that we promised MOI would fix\nChecking feasibility of solutions (Done: #2466)\nAccessing IIS (Done: see Conflicts)\nAccessing multiple results from solvers (Done: Gurobi#392)\nDual warm-starts (Done: #2214)\nAddress \"easy\" usability issues\nLine numbers in error messages (Done: #2276)\nLP sensitivity summary (Done: see Sensitivity analysis for LP)\nInferred element types for collections in macros (Done: #2070)\nExpose solver-independent options from JuMP (Done: see set_silent etc.)\nImprove the documentation (#1062)\nSeparate how-to, concept explanation, and technical reference following the Divio recommendations (Done)\nFully integrate JuMPTutorials with JuMP's documentation (Done)\nDeveloper experience\nGet JuMP's unit tests running faster. See #1745. (Done)\nAll solvers should complete the transition to MOI (Done)\nProvide packages for installing Bonmin and Couenne (Done)\nMathOptFormat 1.0 (Done)","category":"page"},{"location":"developers/roadmap/#MOI-1.0","page":"Roadmap","title":"MOI 1.0","text":"","category":"section"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"# TODO: List MOI 1.0 items here.","category":"page"},{"location":"developers/roadmap/#Beyond-JuMP-1.0","page":"Roadmap","title":"Beyond JuMP 1.0","text":"","category":"section"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"# TODO: Copy over list of items not tied to JuMP 1.0. These should have more\n# elaborate explanations so that potential contributors know what we mean,\n# i.e., a few sentences each or a link to a document/issue.","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Bridges/implementation/#Bridge-interface","page":"Implementation","title":"Bridge interface","text":"","category":"section"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"To be usable by a bridge optimizer, a bridge must implement the following functions:","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"Bridges.added_constrained_variable_types\nBridges.added_constraint_types","category":"page"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.added_constrained_variable_types","page":"Implementation","title":"MathOptInterface.Bridges.added_constrained_variable_types","text":"added_constrained_variable_types(\n    BT::Type{<:Variable.AbstractBridge},\n)::Vector{Tuple{Type}}\n\nReturn a list of the types of constrained variables that bridges of concrete type BT add. This is used by the LazyBridgeOptimizer.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.added_constraint_types","page":"Implementation","title":"MathOptInterface.Bridges.added_constraint_types","text":"added_constraint_types(\n    BT::Type{<:Constraint.AbstractBridge},\n)::Vector{Tuple{Type, Type}}\n\nReturn a list of the types of constraints that bridges of concrete type BT add. This is used by the LazyBridgeOptimizer.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"Additionally, variable bridges must implement:","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"Bridges.Variable.supports_constrained_variable\nBridges.Variable.concrete_bridge_type\nBridges.Variable.bridge_constrained_variable","category":"page"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.Variable.supports_constrained_variable","page":"Implementation","title":"MathOptInterface.Bridges.Variable.supports_constrained_variable","text":"supports_constrained_variable(\n    ::Type{<:AbstractBridge},\n    ::Type{<:MOI.AbstractSet},\n)::Bool\n\nReturn a Bool indicating whether the bridges of type BT support bridging constrained variables in S.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.Variable.concrete_bridge_type","page":"Implementation","title":"MathOptInterface.Bridges.Variable.concrete_bridge_type","text":"concrete_bridge_type(\n    BT::Type{<:AbstractBridge},\n    S::Type{<:MOI.AbstractSet},\n)::Type\n\nReturn the concrete type of the bridge supporting variables in S constraints. This function can only be called if MOI.supports_constrained_variable(BT, S) is true.\n\nExamples\n\nAs a variable in MathOptInterface.GreaterThan is bridged into variables in MathOptInterface.Nonnegatives by the VectorizeBridge:\n\nMOI.Bridges.Variable.concrete_bridge_type(\n    MOI.Bridges.Variable.VectorizeBridge{Float64},\n    MOI.GreaterThan{Float64},\n)\n\n# output\n\nMathOptInterface.Bridges.Variable.VectorizeBridge{Float64, MathOptInterface.Nonnegatives}\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.Variable.bridge_constrained_variable","page":"Implementation","title":"MathOptInterface.Bridges.Variable.bridge_constrained_variable","text":"bridge_constrained_variable(\n    BT::Type{<:AbstractBridge},\n    model::MOI.ModelLike,\n    set::MOI.AbstractSet,\n)\n\nBridge the constrained variable in set using bridge BT to model and returns a bridge object of type BT. The bridge type BT should be a concrete type, that is, all the type parameters of the bridge should be set. Use concrete_bridge_type to obtain a concrete type for given set types.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"constraint bridges must implement:","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"supports_constraint(::Type{<:Bridges.Constraint.AbstractBridge}, ::Type{<:AbstractFunction}, ::Type{<:AbstractSet})\nBridges.Constraint.concrete_bridge_type\nBridges.Constraint.bridge_constraint","category":"page"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.supports_constraint-Tuple{Type{var\"#s1007\"} where var\"#s1007\"<:MathOptInterface.Bridges.Constraint.AbstractBridge, Type{var\"#s1006\"} where var\"#s1006\"<:MathOptInterface.AbstractFunction, Type{var\"#s1005\"} where var\"#s1005\"<:MathOptInterface.AbstractSet}","page":"Implementation","title":"MathOptInterface.supports_constraint","text":"MOI.supports_constraint(\n    BT::Type{<:AbstractBridge},\n    F::Type{<:MOI.AbstractFunction},\n    S::Type{<:MOI.AbstractSet},\n)::Bool\n\nReturn a Bool indicating whether the bridges of type BT support bridging F-in-S constraints.\n\n\n\n\n\n","category":"method"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.Constraint.concrete_bridge_type","page":"Implementation","title":"MathOptInterface.Bridges.Constraint.concrete_bridge_type","text":"concrete_bridge_type(\n    BT::Type{<:AbstractBridge},\n    F::Type{<:MOI.AbstractFunction},\n    S::Type{<:MOI.AbstractSet}\n)::Type\n\nReturn the concrete type of the bridge supporting F-in-S constraints. This function can only be called if MOI.supports_constraint(BT, F, S) is true.\n\nExamples\n\nAs a MathOptInterface.VariableIndex-in-MathOptInterface.Interval constraint is bridged into a MathOptInterface.VariableIndex-in-MathOptInterface.GreaterThan and a MathOptInterface.VariableIndex-in-MathOptInterface.LessThan by the SplitIntervalBridge:\n\nMOI.Bridges.Constraint.concrete_bridge_type(\n    MOI.Bridges.Constraint.SplitIntervalBridge{Float64},\n    MOI.VariableIndex,\n    MOI.Interval{Float64},\n)\n\n# output\n\nMathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64, MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64}, MathOptInterface.GreaterThan{Float64}, MathOptInterface.LessThan{Float64}}\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.Constraint.bridge_constraint","page":"Implementation","title":"MathOptInterface.Bridges.Constraint.bridge_constraint","text":"bridge_constraint(\n    BT::Type{<:AbstractBridge},\n    model::MOI.ModelLike,\n    func::AbstractFunction,\n    set::MOI.AbstractSet,\n)\n\nBridge the constraint func-in-set using bridge BT to model and returns a bridge object of type BT. The bridge type BT should be a concrete type, that is, all the type parameters of the bridge should be set. Use concrete_bridge_type to obtain a concrete type for given function and set types.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"and objective bridges must implement:","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"Bridges.set_objective_function_type\nBridges.Objective.concrete_bridge_type\nBridges.Objective.bridge_objective","category":"page"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.set_objective_function_type","page":"Implementation","title":"MathOptInterface.Bridges.set_objective_function_type","text":"set_objective_function_type(\n    BT::Type{<:Objective.AbstractBridge},\n)::Type{<:MOI.AbstractScalarFunction}\n\nReturn the type of objective function that bridges of concrete type BT set. This is used by the LazyBridgeOptimizer.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.Objective.concrete_bridge_type","page":"Implementation","title":"MathOptInterface.Bridges.Objective.concrete_bridge_type","text":"concrete_bridge_type(\n    BT::Type{<:MOI.Bridges.Objective.AbstractBridge},\n    F::Type{<:MOI.AbstractScalarFunction},\n)::Type\n\nReturn the concrete type of the bridge supporting objective functions of type F. This function can only be called if MOI.supports_objective_function(BT, F) is true.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.Bridges.Objective.bridge_objective","page":"Implementation","title":"MathOptInterface.Bridges.Objective.bridge_objective","text":"bridge_objective(\n    BT::Type{<:MOI.Bridges.Objective.AbstractBridge},\n    model::MOI.ModelLike,\n    func::MOI.AbstractScalarFunction,\n)\n\nBridge the objective function func using bridge BT to model and returns a bridge object of type BT. The bridge type BT should be a concrete type, that is, all the type parameters of the bridge should be set. Use concrete_bridge_type to obtain a concrete type for a given function type.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"When querying the NumberOfVariables, NumberOfConstraints ListOfVariableIndices, and ListOfConstraintIndices, the variables and constraints created by the bridges in the underlying model are hidden by the bridge optimizer. For this purpose, the bridge must provide access to the variables and constraints it has created by implementing the following methods of get:","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"get(::Bridges.Constraint.AbstractBridge, ::NumberOfVariables)\nget(::Bridges.Constraint.AbstractBridge, ::ListOfVariableIndices)\nget(::Bridges.AbstractBridge, ::NumberOfConstraints)\nget(::Bridges.AbstractBridge, ::ListOfConstraintIndices)","category":"page"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.get-Tuple{MathOptInterface.Bridges.Constraint.AbstractBridge, MathOptInterface.NumberOfVariables}","page":"Implementation","title":"MathOptInterface.get","text":"MOI.get(b::AbstractBridge, ::MOI.NumberOfVariables)\n\nThe number of variables created by the bridge b in the model.\n\n\n\n\n\n","category":"method"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.get-Tuple{MathOptInterface.Bridges.Constraint.AbstractBridge, MathOptInterface.ListOfVariableIndices}","page":"Implementation","title":"MathOptInterface.get","text":"MOI.get(b::AbstractBridge, ::MOI.ListOfVariableIndices)\n\nThe list of variables created by the bridge b in the model.\n\n\n\n\n\n","category":"method"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.get-Tuple{MathOptInterface.Bridges.AbstractBridge, MathOptInterface.NumberOfConstraints}","page":"Implementation","title":"MathOptInterface.get","text":"MOI.get(b::AbstractBridge, ::MOI.NumberOfConstraints{F, S}) where {F, S}\n\nThe number of constraints of the type F-in-S created by the bridge b in the model.\n\n\n\n\n\n","category":"method"},{"location":"moi/submodules/Bridges/implementation/#MathOptInterface.get-Tuple{MathOptInterface.Bridges.AbstractBridge, MathOptInterface.ListOfConstraintIndices}","page":"Implementation","title":"MathOptInterface.get","text":"MOI.get(b::AbstractBridge, ::MOI.ListOfConstraintIndices{F, S}) where {F, S}\n\nA Vector{ConstraintIndex{F,S}} with indices of all constraints of type F-inS created by the bride b in the model (i.e., of length equal to the value of NumberOfConstraints{F,S}()).\n\n\n\n\n\n","category":"method"},{"location":"moi/submodules/Bridges/implementation/#SetMap-bridges","page":"Implementation","title":"SetMap bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"Implementing a constraint bridge relying on linear transformation between two sets is easier thanks to the SetMap interface. The bridge simply needs to be a subtype of [Bridges.Variable.SetMapBridge] for a variable bridge and [Bridges.Constraint.SetMapBridge] for a constraint bridge and the linear transformation is represented with Bridges.map_set, Bridges.map_function, Bridges.inverse_map_set, Bridges.inverse_map_function, Bridges.adjoint_map_function and Bridges.inverse_adjoint_map_function. Note that the implementing last 4 methods is optional in the sense that if they are not implemented, bridging constraint would still work but some features would be missing as described in the docstrings. See [L20, Section 2.1.2] for more details including [L20, Example 2.1.1] that illustrates the idea for Bridges.Variable.SOCtoRSOCBridge, Bridges.Variable.RSOCtoSOCBridge, Bridges.Constraint.SOCtoRSOCBridge and Bridges.Constraint.RSOCtoSOCBridge.","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"[L20] Legat, Benoît. Set Programming: Theory and Computation. PhD thesis. 2020.","category":"page"},{"location":"tutorials/nonlinear/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/nonlinear/clnlbeam.jl\"","category":"page"},{"location":"tutorials/nonlinear/clnlbeam/#The-clnlbeam-problem","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"","category":"section"},{"location":"tutorials/nonlinear/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"Based on an AMPL model by Hande Y. Benson","category":"page"},{"location":"tutorials/nonlinear/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"Copyright (C) 2001 Princeton University All Rights Reserved","category":"page"},{"location":"tutorials/nonlinear/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that the copyright notice and this permission notice appear in all supporting documentation.","category":"page"},{"location":"tutorials/nonlinear/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"Source: H. Maurer and H.D. Mittelman, \"The non-linear beam via optimal control with bound state variables\", Optimal Control Applications and Methods 12, pp. 19-31, 1991.","category":"page"},{"location":"tutorials/nonlinear/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"using JuMP\nimport Ipopt\n\nfunction example_clnlbeam()\n    N = 1000\n    h = 1 / N\n    alpha = 350\n    model = Model(Ipopt.Optimizer)\n    @variables(model, begin\n        -1 <= t[1:(N+1)] <= 1\n        -0.05 <= x[1:(N+1)] <= 0.05\n        u[1:(N+1)]\n    end)\n    @NLobjective(\n        model,\n        Min,\n        sum(\n            0.5 * h * (u[i+1]^2 + u[i]^2) +\n            0.5 * alpha * h * (cos(t[i+1]) + cos(t[i])) for i in 1:N\n        ),\n    )\n    @NLconstraint(\n        model,\n        [i = 1:N],\n        x[i+1] - x[i] - 0.5 * h * (sin(t[i+1]) + sin(t[i])) == 0,\n    )\n    @constraint(\n        model,\n        [i = 1:N],\n        t[i+1] - t[i] - 0.5 * h * u[i+1] - 0.5 * h * u[i] == 0,\n    )\n    optimize!(model)\n    println(\"\"\"\n    termination_status = $(termination_status(model))\n    primal_status      = $(primal_status(model))\n    objective_value    = $(objective_value(model))\n    \"\"\")\n    return\nend\n\nexample_clnlbeam()","category":"page"},{"location":"tutorials/nonlinear/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"","category":"page"},{"location":"tutorials/nonlinear/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Benchmarks/overview/#The-Benchmarks-submodule","page":"Overview","title":"The Benchmarks submodule","text":"","category":"section"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"To aid the development of efficient solver wrappers, MathOptInterface provides benchmarking functionality. Benchmarking a wrapper follows a two-step process.","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"First, prior to making changes, run and save the benchmark results on a given benchmark suite as follows:","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"using SolverPackage  # Replace with your choice of solver.\n\nusing MathOptInterface\nconst MOI = MathOptInterface\n\nsuite = MOI.Benchmarks.suite() do\n    SolverPackage.Optimizer()\nend\n\nMOI.Benchmarks.create_baseline(\n    suite, \"current\"; directory = \"/tmp\", verbose = true\n)","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"Use the exclude argument to Benchmarks.suite to exclude benchmarks that the solver doesn't support.","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"Second, after making changes to the package, re-run the benchmark suite and compare to the prior saved results:","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"using SolverPackage, MathOptInterface\n\nconst MOI = MathOptInterface\n\nsuite = MOI.Benchmarks.suite() do\n    SolverPackage.Optimizer()\nend\n\nMOI.Benchmarks.compare_against_baseline(\n    suite, \"current\"; directory = \"/tmp\", verbose = true\n)","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"This comparison will create a report detailing improvements and regressions.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Test/overview/#test_module","page":"Overview","title":"The Test submodule","text":"","category":"section"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"The Test submodule provides tools to help solvers implement unit tests in order to ensure they implement the MathOptInterface API correctly, and to check for solver-correctness.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"We use a centralized repository of tests, so that if we find a bug in one solver, instead of adding a test to that particular repository, we add it here so that all solvers can benefit.","category":"page"},{"location":"moi/submodules/Test/overview/#How-to-test-a-solver","page":"Overview","title":"How to test a solver","text":"","category":"section"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"The skeleton below can be used for the wrapper test file of a solver named FooBar.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"# ============================ /test/MOI_wrapper.jl ============================\nmodule TestFooBar\n\nimport FooBar\nusing MathOptInterface\nusing Test\n\nconst MOI = MathOptInterface\n\nconst OPTIMIZER = MOI.instantiate(\n    MOI.OptimizerWithAttributes(FooBar.Optimizer, MOI.Silent() => true),\n)\n\nconst BRIDGED = MOI.instantiate(\n    MOI.OptimizerWithAttributes(FooBar.Optimizer, MOI.Silent() => true),\n    with_bridge_type = Float64,\n)\n\n# See the docstring of MOI.Test.Config for other arguments.\nconst CONFIG = MOI.Test.Config(\n    # Modify tolerances as necessary.\n    atol = 1e-6,\n    rtol = 1e-6,\n    # Use MOI.LOCALLY_SOLVED for local solvers.\n    optimal_status = MOI.OPTIMAL,\n    # Pass attributes or MOI functions to `exclude` to skip tests that\n    # rely on this functionality.\n    exclude = Any[MOI.VariableName, MOI.delete],\n)\n\n\"\"\"\n    runtests()\n\nThis function runs all functions in the this Module starting with `test_`.\n\"\"\"\nfunction runtests()\n    for name in names(@__MODULE__; all = true)\n        if startswith(\"$(name)\", \"test_\")\n            @testset \"$(name)\" begin\n                getfield(@__MODULE__, name)()\n            end\n        end\n    end\nend\n\n\"\"\"\n    test_runtests()\n\nThis function runs all the tests in MathOptInterface.Test.\n\nPass arguments to `exclude` to skip tests for functionality that is not\nimplemented or that your solver doesn't support.\n\"\"\"\nfunction test_runtests()\n    MOI.Test.runtests(\n        BRIDGED,\n        CONFIG,\n        exclude = [\n            \"test_attribute_NumberOfThreads\",\n            \"test_quadratic_\",\n        ],\n        # This argument is useful to prevent tests from failing on future\n        # releases of MOI that add new tests. Don't let this number get too far\n        # behind the current MOI release though! You should periodically check\n        # for new tests in order to fix bugs and implement new features.\n        exclude_tests_after = v\"0.10.5\",\n    )\n    return\nend\n\n\"\"\"\n    test_SolverName()\n\nYou can also write new tests for solver-specific functionality. Write each new\ntest as a function with a name beginning with `test_`.\n\"\"\"\nfunction test_SolverName()\n    @test MOI.get(FooBar.Optimizer(), MOI.SolverName()) == \"FooBar\"\n    return\nend\n\nend # module TestFooBar\n\n# This line at tne end of the file runs all the tests!\nTestFooBar.runtests()","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Then modify your runtests.jl file to include the MOI_wrapper.jl file:","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"# ============================ /test/runtests.jl ============================\n\nusing Test\n\n@testset \"MOI\" begin\n    include(\"test/MOI_wrapper.jl\")\nend","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"info: Info\nThe optimizer BRIDGED constructed with instantiate automatically bridges constraints that are not supported by OPTIMIZER using the bridges listed in Bridges. It is recommended for an implementation of MOI to only support constraints that are natively supported by the solver and let bridges transform the constraint to the appropriate form. For this reason it is expected that tests may not pass if OPTIMIZER is used instead of BRIDGED.","category":"page"},{"location":"moi/submodules/Test/overview/#How-to-debug-a-failing-test","page":"Overview","title":"How to debug a failing test","text":"","category":"section"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"When writing a solver, it's likely that you will initially fail many tests! Some failures will be bugs, but other failures you may choose to exclude.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"There are two ways to exclude tests:","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Exclude tests whose names contain a string using:\nMOI.Test.runtests(\n    model,\n    config;\n    exclude = String[\"test_to_exclude\", \"test_conic_\"],\n)\nThis will exclude tests whose name contains either of the two strings provided.\nExclude tests which rely on specific functionality using:\nMOI.Test.Config(exclude = Any[MOI.VariableName, MOI.optimize!])\nThis will exclude tests which use the MOI.VariableName attribute, or which call MOI.optimize!.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Each test that fails can be independently called as:","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"model = FooBar.Optimizer()\nconfig = MOI.Test.Config()\nMOI.empty!(model)\nMOI.Test.test_category_name_that_failed(model, config)","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"You can look-up the source code of the test that failed by searching for it in the src/Test/test_category.jl file.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"tip: Tip\nEach test function also has a docstring that explains what the test is for. Use ? MOI.Test.test_category_name_that_failed from the REPL to read it.","category":"page"},{"location":"moi/submodules/Test/overview/#How-to-add-a-test","page":"Overview","title":"How to add a test","text":"","category":"section"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"To detect bugs in solvers, we add new tests to MOI.Test.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"As an example, ECOS errored calling optimize! twice in a row. (See ECOS.jl PR #72.) We could add a test to ECOS.jl, but that would only stop us from re-introducing the bug to ECOS.jl in the future, but it would not catch other solvers in the ecosystem with the same bug! Instead, if we add a test to MOI.Test, then all solvers will also check that they handle a double optimize call!","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"For this test, we care about correctness, rather than performance. therefore, we don't expect solvers to efficiently decide that they have already solved the problem, only that calling optimize! twice doesn't throw an error or give the wrong answer.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Step 1","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Install the MathOptInterface julia package in dev mode (ref):","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"julia> ]\n(@v1.6) pkg> dev MathOptInterface","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Step 2","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"From here on, proceed with making the following changes in the ~/.julia/dev/MathOptInterface folder (or equivalent dev path on your machine).","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Step 3","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Since the double-optimize error involves solving an optimization problem, add a new test to src/Test/UnitTests/solve.jl:","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"\"\"\"\n    test_unit_optimize!_twice(model::MOI.ModelLike, config::Config)\n\nTest that calling `MOI.optimize!` twice does not error.\n\nThis problem was first detected in ECOS.jl PR#72:\nhttps://github.com/jump-dev/ECOS.jl/pull/72\n\"\"\"\nfunction test_unit_optimize!_twice(\n    model::MOI.ModelLike,\n    config::Config{T},\n) where {T}\n    # Use the `@requires` macro to check conditions that the test function\n    # requires in order to run. Models failing this `@requires` check will\n    # silently skip the test.\n    @requires MOI.supports_constraint(\n        model,\n        MOI.VariableIndex,\n        MOI.GreaterThan{Float64},\n    )\n    @requires _supports(config, MOI.optimize!)\n    # If needed, you can test that the model is empty at the start of the test.\n    # You can assume that this will be the case for tests run via `runtests`.\n    # User's calling tests individually need to call `MOI.empty!` themselves.\n    @test MOI.is_empty(model)\n    # Create a simple model. Try to make this as simple as possible so that the\n    # majority of solvers can run the test.\n    x = MOI.add_variable(model)\n    MOI.add_constraint(model, x, MOI.GreaterThan(one(T)))\n    MOI.set(model, MOI.ObjectiveSense(), MOI.MIN_SENSE)\n    MOI.set(\n        model,\n        MOI.ObjectiveFunction{MOI.VariableIndex}(),\n        x,\n    )\n    # The main component of the test: does calling `optimize!` twice error?\n    MOI.optimize!(model)\n    MOI.optimize!(model)\n    # Check we have a solution.\n    @test MOI.get(model, MOI.TerminationStatus()) == MOI.OPTIMAL\n    # There is a three-argument version of `Base.isapprox` for checking\n    # approximate equality based on the tolerances defined in `config`:\n    @test isapprox(MOI.get(model, MOI.VariablePrimal(), x), one(T), config)\n    # For code-style, these tests should always `return` `nothing`.\n    return\nend","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"info: Info\nMake sure the function is agnoistic to the number type T! Don't assume it is a Float64 capable solver!","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"We also need to write a test for the test. Place this function immediately below the test you just wrote in the same file:","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"function setup_test(\n    ::typeof(test_unit_optimize!_twice),\n    model::MOI.Utilities.MockOptimizer,\n    ::Config,\n)\n    MOI.Utilities.set_mock_optimize!(\n        model,\n        (mock::MOI.Utilities.MockOptimizer) -> MOIU.mock_optimize!(\n            mock,\n            MOI.OPTIMAL,\n            (MOI.FEASIBLE_POINT, [1.0]),\n        ),\n    )\n    return\nend","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Finally, you also need to implement Test.version_added. If we added this test when the latest released version of MOI was v0.10.5, define:","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"version_added(::typeof(test_unit_optimize!_twice)) = v\"0.10.6\"","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Step 6","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Commit the changes to git from ~/.julia/dev/MathOptInterface and submit the PR for review.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"tip: Tip\nIf you need help writing a test, open an issue on GitHub, or ask the Developer Chatroom","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/linear/callbacks.jl\"","category":"page"},{"location":"tutorials/linear/callbacks/#callbacks_tutorial","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"The purpose of the tutorial is to demonstrate the various solver-independent and solver-dependent callbacks that are supported by JuMP.","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"The tutorial uses the following packages:","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"using JuMP\nimport GLPK\nimport Random","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"info: Info\nThis tutorial uses the MathOptInterface API. By default, JuMP exports the MOI symbol as an alias for the MathOptInterface.jl package. We recommend making this more explicit in your code by adding the following lines:import MathOptInterface\nconst MOI = MathOptInterface","category":"page"},{"location":"tutorials/linear/callbacks/#Lazy-constraints","page":"Callbacks","title":"Lazy constraints","text":"","category":"section"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using a lazy constraint callback.","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_lazy_constraint()\n    model = Model(GLPK.Optimizer)\n    @variable(model, 0 <= x <= 2.5, Int)\n    @variable(model, 0 <= y <= 2.5, Int)\n    @objective(model, Max, y)\n    lazy_called = false\n    function my_callback_function(cb_data)\n        lazy_called = true\n        x_val = callback_value(cb_data, x)\n        y_val = callback_value(cb_data, y)\n        println(\"Called from (x, y) = ($x_val, $y_val)\")\n        status = callback_node_status(cb_data, model)\n        if status == MOI.CALLBACK_NODE_STATUS_FRACTIONAL\n            println(\" - Solution is integer infeasible!\")\n        elseif status == MOI.CALLBACK_NODE_STATUS_INTEGER\n            println(\" - Solution is integer feasible!\")\n        else\n            @assert status == MOI.CALLBACK_NODE_STATUS_UNKNOWN\n            println(\" - I don't know if the solution is integer feasible :(\")\n        end\n        if y_val - x_val > 1 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        elseif y_val + x_val > 3 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        end\n    end\n    MOI.set(model, MOI.LazyConstraintCallback(), my_callback_function)\n    optimize!(model)\n    println(\"Optimal solution (x, y) = ($(value(x)), $(value(y)))\")\n    return\nend\n\nexample_lazy_constraint()","category":"page"},{"location":"tutorials/linear/callbacks/#User-cuts","page":"Callbacks","title":"User-cuts","text":"","category":"section"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using a user-cut callback.","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_user_cut_constraint()\n    Random.seed!(1)\n    N = 30\n    item_weights, item_values = rand(N), rand(N)\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:N], Bin)\n    @constraint(model, sum(item_weights[i] * x[i] for i in 1:N) <= 10)\n    @objective(model, Max, sum(item_values[i] * x[i] for i in 1:N))\n    callback_called = false\n    function my_callback_function(cb_data)\n        callback_called = true\n        x_vals = callback_value.(Ref(cb_data), x)\n        accumulated = sum(item_weights[i] for i = 1:N if x_vals[i] > 1e-4)\n        println(\"Called with accumulated = $(accumulated)\")\n        n_terms = sum(1 for i = 1:N if x_vals[i] > 1e-4)\n        if accumulated > 10\n            con = @build_constraint(\n                sum(x[i] for i = 1:N if x_vals[i] > 0.5) <= n_terms - 1\n            )\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.UserCut(cb_data), con)\n        end\n    end\n    MOI.set(model, MOI.UserCutCallback(), my_callback_function)\n    optimize!(model)\n    @show callback_called\n    return\nend\n\nexample_user_cut_constraint()","category":"page"},{"location":"tutorials/linear/callbacks/#Heuristic-solutions","page":"Callbacks","title":"Heuristic solutions","text":"","category":"section"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using a heuristic solution callback.","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_heuristic_solution()\n    Random.seed!(1)\n    N = 30\n    item_weights, item_values = rand(N), rand(N)\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:N], Bin)\n    @constraint(model, sum(item_weights[i] * x[i] for i in 1:N) <= 10)\n    @objective(model, Max, sum(item_values[i] * x[i] for i in 1:N))\n    callback_called = false\n    function my_callback_function(cb_data)\n        callback_called = true\n        x_vals = callback_value.(Ref(cb_data), x)\n        ret =\n            MOI.submit(model, MOI.HeuristicSolution(cb_data), x, floor.(x_vals))\n        println(\"Heuristic solution status = $(ret)\")\n    end\n    MOI.set(model, MOI.HeuristicCallback(), my_callback_function)\n    optimize!(model)\n    return\nend\n\nexample_heuristic_solution()","category":"page"},{"location":"tutorials/linear/callbacks/#GLPK-solver-dependent-callback","page":"Callbacks","title":"GLPK solver-dependent callback","text":"","category":"section"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using GLPK's solver-dependent callback.","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_solver_dependent_callback()\n    model = Model(GLPK.Optimizer)\n    @variable(model, 0 <= x <= 2.5, Int)\n    @variable(model, 0 <= y <= 2.5, Int)\n    @objective(model, Max, y)\n    lazy_called = false\n    function my_callback_function(cb_data)\n        lazy_called = true\n        reason = GLPK.glp_ios_reason(cb_data.tree)\n        println(\"Called from reason = $(reason)\")\n        if reason != GLPK.GLP_IROWGEN\n            return\n        end\n        x_val = callback_value(cb_data, x)\n        y_val = callback_value(cb_data, y)\n        if y_val - x_val > 1 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        elseif y_val + x_val > 3 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        end\n    end\n    MOI.set(model, GLPK.CallbackFunction(), my_callback_function)\n    optimize!(model)\n    return\nend\n\nexample_solver_dependent_callback()","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/nlp/#Nonlinear-Modeling","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP has support for general smooth nonlinear (convex and nonconvex) optimization problems. JuMP is able to provide exact, sparse second-order derivatives to solvers. This information can improve solver accuracy and performance.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"There are three main changes to solve nonlinear programs in JuMP.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use @NLobjective instead of @objective\nUse @NLconstraint instead of @constraint\nUse @NLexpression instead of @expression","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"info: Info\nThere are some restrictions on what syntax you can use in the @NLxxx macros. Make sure to read the Syntax notes.","category":"page"},{"location":"manual/nlp/#Set-a-nonlinear-objective","page":"Nonlinear Modeling","title":"Set a nonlinear objective","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use @NLobjective to set a nonlinear objective.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLobjective(model, Min, exp(x[1]) - sqrt(x[2]))","category":"page"},{"location":"manual/nlp/#Add-a-nonlinear-constraint","page":"Nonlinear Modeling","title":"Add a nonlinear constraint","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use @NLconstraint to add a nonlinear constraint.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLconstraint(model, exp(x[1]) <= 1)\nexp(x[1]) - 1.0 ≤ 0\n\njulia> @NLconstraint(model, [i = 1:2], x[i]^i >= i)\n2-element Vector{NonlinearConstraintRef{ScalarShape}}:\n x[1] ^ 1.0 - 1.0 ≥ 0\n x[2] ^ 2.0 - 2.0 ≥ 0\n\njulia> @NLconstraint(model, con[i = 1:2], prod(x[j] for j = 1:i) == i)\n2-element Vector{NonlinearConstraintRef{ScalarShape}}:\n (*)(x[1]) - 1.0 = 0\n x[1] * x[2] - 2.0 = 0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"info: Info\nYou can only create nonlinear constraints with <=, >=, and ==. More general Nonlinear-in-Set constraints are not supported.","category":"page"},{"location":"manual/nlp/#Create-a-nonlinear-expression","page":"Nonlinear Modeling","title":"Create a nonlinear expression","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use @NLexpression to create nonlinear expression objects. The syntax is identical to @expression, except that the expression can contain nonlinear terms.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> expr = @NLexpression(model, exp(x[1]) + sqrt(x[2]))\nsubexpression[1]: exp(x[1]) + sqrt(x[2])\n\njulia> my_anon_expr = @NLexpression(model, [i = 1:2], sin(x[i]))\n2-element Vector{NonlinearExpression}:\n subexpression[2]: sin(x[1])\n subexpression[3]: sin(x[2])\n\njulia> @NLexpression(model, my_expr[i = 1:2], sin(x[i]))\n2-element Vector{NonlinearExpression}:\n subexpression[4]: sin(x[1])\n subexpression[5]: sin(x[2])","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear expression can be used in @NLobjective, @NLconstraint, and even nested in other @NLexpressions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLobjective(model, Min, expr^2 + 1)\n\njulia> @NLconstraint(model, [i = 1:2], my_expr[i] <= i)\n2-element Vector{NonlinearConstraintRef{ScalarShape}}:\n subexpression[4] - 1.0 ≤ 0\n subexpression[5] - 2.0 ≤ 0\n\njulia> @NLexpression(model, nested[i = 1:2], sin(my_expr[i]))\n2-element Vector{NonlinearExpression}:\n subexpression[6]: sin(subexpression[4])\n subexpression[7]: sin(subexpression[5])","category":"page"},{"location":"manual/nlp/#Create-a-nonlinear-parameter","page":"Nonlinear Modeling","title":"Create a nonlinear parameter","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For nonlinear models only, JuMP offers a syntax for explicit \"parameter\" objects, which are constants in the model that can be efficiently updated between solves.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear parameters are declared by using the @NLparameter macro and may be indexed by arbitrary sets analogously to JuMP variables and expressions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The initial value of the parameter must be provided on the right-hand side of the == sign.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLparameter(model, p[i = 1:2] == i)\n2-element Vector{NonlinearParameter}:\n parameter[1] == 1.0\n parameter[2] == 2.0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Create anonymous parameters using the value keyword:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> anon_parameter = @NLparameter(model, value = 1)\nparameter[3] == 1.0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"info: Info\nA parameter is not an optimization variable. It must be fixed to a value with ==. If you want a parameter that is <= or >=, create a variable instead using @variable.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use value and set_value to query or update the value of a parameter.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> value.(p)\n2-element Vector{Float64}:\n 1.0\n 2.0\n\njulia> set_value(p[2], 3.0)\n3.0\n\njulia> value.(p)\n2-element Vector{Float64}:\n 1.0\n 3.0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear parameters can be used within nonlinear macros only:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @objective(model, Max, p[1] * x)\nERROR: MethodError: no method matching *(::NonlinearParameter, ::VariableRef)\n[...]\n\njulia> @NLobjective(model, Max, p[1] * x)\n\njulia> @expression(model, my_expr, p[1] * x^2)\nERROR: MethodError: no method matching *(::NonlinearParameter, ::QuadExpr)\nClosest candidates are:\n[...]\n\njulia> @NLexpression(model, my_nl_expr, p[1] * x^2)\nsubexpression[1]: parameter[1] * x ^ 2.0","category":"page"},{"location":"manual/nlp/#When-to-use-a-parameter","page":"Nonlinear Modeling","title":"When to use a parameter","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear parameters are useful when solving nonlinear models in a sequence:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP, Ipopt\nmodel = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, z)\n@NLparameter(model, x == 1.0)\n@NLobjective(model, Min, (z - x)^2)\noptimize!(model)\n@show value(z) # Equals 1.0.\n\n# Now, update the value of x to solve a different problem.\nset_value(x, 5.0)\noptimize!(model)\n@show value(z) # Equals 5.0\nnothing #hide","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"info: Info\nUsing nonlinear parameters can be faster than creating a new model from scratch with updated data because JuMP is able to avoid repeating a number of steps in processing the model before handing it off to the solver.","category":"page"},{"location":"manual/nlp/#Syntax-notes","page":"Nonlinear Modeling","title":"Syntax notes","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The syntax accepted in nonlinear macros is more restricted than the syntax for linear and quadratic macros. We note some important points below.","category":"page"},{"location":"manual/nlp/#No-operator-overloading","page":"Nonlinear Modeling","title":"No operator overloading","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"There is no operator overloading provided to build up nonlinear expressions. For example, if x is a JuMP variable, the code 3x will return an AffExpr object that can be used inside of future expressions and linear constraints. However, the code sin(x) is an error. All nonlinear expressions must be inside of macros.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> expr = sin(x) + 1\nERROR: sin is not defined for type AbstractVariableRef. Are you trying to build a nonlinear problem? Make sure you use @NLconstraint/@NLobjective.\n[...]\n\njulia> expr = @NLexpression(model, sin(x) + 1)\nsubexpression[1]: sin(x) + 1.0","category":"page"},{"location":"manual/nlp/#Scalar-operations-only","page":"Nonlinear Modeling","title":"Scalar operations only","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Except for the splatting syntax discussed below, all expressions must be simple scalar operations. You cannot use dot, matrix-vector products, vector slices, etc.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLobjective(model, Min, c' * x + 3y)\nERROR: Unexpected array [1 2] in nonlinear expression. Nonlinear expressions may contain only scalar expressions.\n[...]","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Translate vector operations into explicit sum() operations:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLobjective(model, Min, sum(c[i] * x[i] for i = 1:2) + 3y)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Or use an @expression:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @expression(model, expr, c' * x)\nx[1] + 2 x[2]\n\njulia> @NLobjective(model, Min, expr + 3y)\n","category":"page"},{"location":"manual/nlp/#Splatting","page":"Nonlinear Modeling","title":"Splatting","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The splatting operator   ... is recognized in a very restricted setting for expanding function   arguments. The expression splatted can be only a symbol. More complex   expressions are not recognized.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x[1:3]);\n\njulia> @NLconstraint(model, *(x...) <= 1.0)\nx[1] * x[2] * x[3] - 1.0 ≤ 0\n\njulia> @NLconstraint(model, *((x / 2)...) <= 0.0)\nERROR: LoadError: Unexpected expression in (*)(x / 2...). JuMP supports splatting only symbols. For example, x... is ok, but (x + 1)..., [x; y]... and g(f(y)...) are not.","category":"page"},{"location":"manual/nlp/#User-defined-Functions","page":"Nonlinear Modeling","title":"User-defined Functions","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP's library of recognized univariate functions is derived from the Calculus.jl package.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"In addition to this list of functions, it is possible to register custom user-defined nonlinear functions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"tip: Tip\nUser-defined functions can be used anywhere in @NLobjective, @NLconstraint, and @NLexpression.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"tip: Tip\nJuMP will attempt to automatically register functions it detects in your nonlinear expressions, which usually means manually registering a function is not needed. Two exceptions are if you want to provide custom derivatives, or if the function is not available in the scope of the nonlinear expression.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nUser-defined functions must return a scalar output. For a work-around, see User-defined functions with vector outputs.","category":"page"},{"location":"manual/nlp/#Automatic-differentiation","page":"Nonlinear Modeling","title":"Automatic differentiation","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP does not support black-box optimization, so all user-defined functions must provide derivatives in some form.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Fortunately, JuMP supports automatic differentiation of user-defined functions, a feature to our knowledge not available in any comparable modeling systems.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"info: Info\nAutomatic differentiation is not finite differencing. JuMP's automatically computed derivatives are not subject to approximation error.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP uses ForwardDiff.jl to perform automatic differentiation; see the ForwardDiff.jl documentation for a description of how to write a function suitable for automatic differentiation.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nGet an error like No method matching Float64(::ForwardDiff.Dual)? Read this section, and see the guidelines at ForwardDiff.jl.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The most common error is that your user-defined function is not generic with respect to the number type, that is, don't assume that the input to the function is Float64.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"f(x::Float64) = 2 * x  # This will not work.\nf(x::Real)    = 2 * x  # This is good.\nf(x)          = 2 * x  # This is also good.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Another reason you may encounter this error is if you create arrays inside your function which are Float64.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"function bad_f(x...)\n    y = zeros(length(x))  # This constructs an array of `Float64`!\n    for i = 1:length(x)\n        y[i] = x[i]^i\n    end\n    return sum(y)\nend\n\nfunction good_f(x::T...) where {T<:Real}\n    y = zeros(T, length(x))  # Construct an array of type `T` instead!\n    for i = 1:length(x)\n        y[i] = x[i]^i\n    end\n    return sum(y)\nend","category":"page"},{"location":"manual/nlp/#Register-a-function","page":"Nonlinear Modeling","title":"Register a function","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"To register a user-defined function with derivatives computed by automatic differentiation, use the register method as in the following example:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP #hide\nsquare(x) = x^2\nf(x, y) = (x - 1)^2 + (y - 2)^2\n\nmodel = Model()\n\nregister(model, :square, 1, square; autodiff = true)\nregister(model, :my_f, 2, f; autodiff = true)\n\n@variable(model, x[1:2] >= 0.5)\n@NLobjective(model, Min, my_f(x[1], square(x[2])))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The above code creates a JuMP model with the objective function (x[1] - 1)^2 + (x[2]^2 - 2)^2. The arguments to register are:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The model for which the functions are registered.\nA Julia symbol object which serves as the name of the user-defined function in JuMP expressions.\nThe number of input arguments that the function takes.\nThe Julia method which computes the function\nA flag to instruct JuMP to compute exact gradients automatically.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"tip: Tip\nThe symbol :my_f doesn't have to match the name of the function f. However, it's more readable if it does. Make sure you use my_f and not f in the macros.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nIf you use multi-variate user-defined functions, JuMP will disable second-derivative information. This can lead to significant slow-downs in some cases. Only use a user-defined function if you cannot write out the expression algebraically in the macro.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nUser-defined functions cannot be re-registered and will not update if you modify the underlying Julia function. If you want to change a user-defined function between solves, rebuild the model or use a different name. To use a different name programmatically, see Raw expression input.","category":"page"},{"location":"manual/nlp/#Register-a-function-and-gradient","page":"Nonlinear Modeling","title":"Register a function and gradient","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Forward-mode automatic differentiation as implemented by ForwardDiff.jl has a computational cost that scales linearly with the number of input dimensions. As such, it is not the most efficient way to compute gradients of user-defined functions if the number of input arguments is large. In this case, users may want to provide their own routines for evaluating gradients.","category":"page"},{"location":"manual/nlp/#Univariate-functions","page":"Nonlinear Modeling","title":"Univariate functions","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For univariate functions, the gradient function ∇f returns a number that represents the first-order derivative:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP #hide\nf(x) = x^2\n∇f(x) = 2x\nmodel = Model()\nregister(model, :my_square, 1, f, ∇f; autodiff = true)\n@variable(model, x >= 0)\n@NLobjective(model, Min, my_square(x))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"If autodiff = true, JuMP will use automatic differentiation to compute the hessian.","category":"page"},{"location":"manual/nlp/#Multivariate-functions","page":"Nonlinear Modeling","title":"Multivariate functions","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For multivariate functions, the gradient function ∇f must take a gradient vector as the first argument that is filled in-place:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP #hide\nf(x, y) = (x - 1)^2 + (y - 2)^2\nfunction ∇f(g::AbstractVector{T}, x::T, y::T) where {T}\n    g[1] = 2 * (x - 1)\n    g[2] = 2 * (y - 2)\n    return\nend\n\nmodel = Model()\nregister(model, :my_square, 2, f, ∇f)\n@variable(model, x[1:2] >= 0)\n@NLobjective(model, Min, my_square(x[1], x[2]))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nMake sure the first argument to ∇f supports an AbstractVector, and do not assume the input is Float64.","category":"page"},{"location":"manual/nlp/#Register-a-function,-gradient,-and-hessian","page":"Nonlinear Modeling","title":"Register a function, gradient, and hessian","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nThe ability to explicitly register a hessian is only available for univariate functions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Instead of automatically differentiating the hessian, you can instead pass a function which returns a number representing the second-order derivative.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP #hide\nf(x) = x^2\n∇f(x) = 2x\n∇²f(x) = 2\nmodel = Model()\nregister(model, :my_square, 1, f, ∇f, ∇²f)\n@variable(model, x >= 0)\n@NLobjective(model, Min, my_square(x))","category":"page"},{"location":"manual/nlp/#User-defined-functions-with-vector-inputs","page":"Nonlinear Modeling","title":"User-defined functions with vector inputs","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"User-defined functions which take vectors as input arguments (for example, f(x::Vector)) are not supported. Instead, use Julia's splatting syntax to create a function with scalar arguments. For example, instead of","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"f(x::Vector) = sum(x[i]^i for i in 1:length(x))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"define:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"f(x...) = sum(x[i]^i for i in 1:length(x))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This function f can be used in a JuMP model as follows:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP #hide\nmodel = Model()\n@variable(model, x[1:5] >= 0)\nf(x...) = sum(x[i]^i for i in 1:length(x))\nregister(model, :f, 5, f; autodiff = true)\n@NLobjective(model, Min, f(x...))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"tip: Tip\nMake sure to read the syntax restrictions of Splatting.","category":"page"},{"location":"manual/nlp/#Factors-affecting-solution-time","page":"Nonlinear Modeling","title":"Factors affecting solution time","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The execution time when solving a nonlinear programming problem can be divided into two parts, the time spent in the optimization algorithm (the solver) and the time spent evaluating the nonlinear functions and corresponding derivatives. Ipopt explicitly displays these two timings in its output, for example:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Total CPU secs in IPOPT (w/o function evaluations)   =      7.412\nTotal CPU secs in NLP function evaluations           =      2.083","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For Ipopt in particular, one can improve the performance by installing advanced sparse linear algebra packages, see Installation Guide. For other solvers, see their respective documentation for performance tips.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The function evaluation time, on the other hand, is the responsibility of the modeling language. JuMP computes derivatives by using reverse-mode automatic differentiation with graph coloring methods for exploiting sparsity of the Hessian matrix [1]. As a conservative bound, JuMP's performance here currently may be expected to be within a factor of 5 of AMPL's.","category":"page"},{"location":"manual/nlp/#Querying-derivatives-from-a-JuMP-model","page":"Nonlinear Modeling","title":"Querying derivatives from a JuMP model","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For some advanced use cases, one may want to directly query the derivatives of a JuMP model instead of handing the problem off to a solver. Internally, JuMP implements the MOI.AbstractNLPEvaluator interface. To obtain an NLP evaluator object from a JuMP model, use NLPEvaluator. index returns the MOI.VariableIndex corresponding to a JuMP variable. MOI.VariableIndex itself is a type-safe wrapper for Int64 (stored in the .value field.)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For example:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"raw_index(v::MOI.VariableIndex) = v.value\nmodel = Model()\n@variable(model, x)\n@variable(model, y)\n@NLobjective(model, Min, sin(x) + sin(y))\nvalues = zeros(2)\nx_index = raw_index(JuMP.index(x))\ny_index = raw_index(JuMP.index(y))\nvalues[x_index] = 2.0\nvalues[y_index] = 3.0\nd = NLPEvaluator(model)\nMOI.initialize(d, [:Grad])\nMOI.eval_objective(d, values) # == sin(2.0) + sin(3.0)\n\n# output\n1.0504174348855488","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"∇f = zeros(2)\nMOI.eval_objective_gradient(d, ∇f, values)\n(∇f[x_index], ∇f[y_index]) # == (cos(2.0), cos(3.0))\n\n# output\n(-0.4161468365471424, -0.9899924966004454)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Only nonlinear constraints (those added with @NLconstraint), and nonlinear objectives (added with @NLobjective) exist in the scope of the NLPEvaluator.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The NLPEvaluator does not evaluate derivatives of linear or quadratic constraints or objectives.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The index method applied to a nonlinear constraint reference object returns its index as a NonlinearConstraintIndex. The .value field of NonlinearConstraintIndex stores the raw integer index. For example:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @NLconstraint(model, cons1, sin(x) <= 1);\n\njulia> @NLconstraint(model, cons2, x + 5 == 10);\n\njulia> typeof(cons1)\nNonlinearConstraintRef{ScalarShape} (alias for ConstraintRef{Model, NonlinearConstraintIndex, ScalarShape})\n\njulia> index(cons1)\nNonlinearConstraintIndex(1)\n\njulia> index(cons2)\nNonlinearConstraintIndex(2)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"# TODO: Provide a link for how to access the linear and quadratic parts of the\n# model.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Note that for one-sided nonlinear constraints, JuMP subtracts any values on the right-hand side when computing expressions. In other words, one-sided nonlinear constraints are always transformed to have a right-hand side of zero.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This method of querying derivatives directly from a JuMP model is convenient for interacting with the model in a structured way, for example, for accessing derivatives of specific variables. For example, in statistical maximum likelihood estimation problems, one is often interested in the Hessian matrix at the optimal solution, which can be queried using the NLPEvaluator.","category":"page"},{"location":"manual/nlp/#Raw-expression-input","page":"Nonlinear Modeling","title":"Raw expression input","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nThis section requires advanced knowledge of Julia's Expr. You should read the Expressions and evaluation section of the Julia documentation first.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"In addition to the @NLexpression, @NLobjective and @NLconstraint macros, it is also possible to provide Julia Expr objects directly by using add_NL_expression, set_NL_objective and add_NL_constraint.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This input form may be useful if the expressions are generated programmatically.","category":"page"},{"location":"manual/nlp/#Add-a-nonlinear-expression","page":"Nonlinear Modeling","title":"Add a nonlinear expression","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use add_NL_expression to add a nonlinear expression to the model.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @variable(model, x)\nx\n\njulia> expr = :($(x) + sin($(x)^2))\n:(x + sin(x ^ 2))\n\njulia> expr_ref = add_NL_expression(model, expr)\nsubexpression[1]: x + sin(x ^ 2.0)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This is equivalent to","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> expr_ref = @NLexpression(model, x + sin(x^2))\nsubexpression[1]: x + sin(x ^ 2.0)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"note: Note\nYou must interpolate the variables directly into the expression expr.","category":"page"},{"location":"manual/nlp/#Set-the-objective-function","page":"Nonlinear Modeling","title":"Set the objective function","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use set_NL_objective to set a nonlinear objective.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> expr = :($(x) + $(x)^2)\n:(x + x ^ 2)\n\njulia> set_NL_objective(model, MIN_SENSE, expr)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This is equivalent to","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLobjective(model, Min, x + x^2)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"note: Note\nYou must use MIN_SENSE or MAX_SENSE instead of Min and Max.","category":"page"},{"location":"manual/nlp/#Add-a-constraint","page":"Nonlinear Modeling","title":"Add a constraint","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use add_NL_constraint to add a nonlinear constraint.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> expr = :($(x) + $(x)^2)\n:(x + x ^ 2)\n\njulia> add_NL_constraint(model, :($(expr) <= 1))\n(x + x ^ 2.0) - 1.0 ≤ 0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This is equivalent to","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLconstraint(model, Min, x + x^2 <= 1)\n(x + x ^ 2.0) - 1.0 ≤ 0","category":"page"},{"location":"manual/nlp/#More-complicated-examples","page":"Nonlinear Modeling","title":"More complicated examples","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Raw expression input is most useful when the expressions are generated programmatically, often in conjunction with user-defined functions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"As an example, we construct a model with the nonlinear constraints f(x) <= 1, where f(x) = x^2 and f(x) = sin(x)^2:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> function main(functions::Vector{Function})\n           model = Model()\n           @variable(model, x)\n           for (i, f) in enumerate(functions)\n               f_sym = Symbol(\"f_$(i)\")\n               register(model, f_sym, 1, f; autodiff = true)\n               add_NL_constraint(model, :($(f_sym)($(x)) <= 1))\n           end\n           print(model)\n           return\n       end\nmain (generic function with 1 method)\n\njulia> main([x -> x^2, x -> sin(x)^2])\nFeasibility\nSubject to\n f_1(x) - 1.0 ≤ 0\n f_2(x) - 1.0 ≤ 0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"As another example, we construct a model with the constraint x^2 + sin(x)^2 <= 1:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> function main(functions::Vector{Function})\n           model = Model()\n           @variable(model, x)\n           expr = Expr(:call, :+)\n           for (i, f) in enumerate(functions)\n               f_sym = Symbol(\"f_$(i)\")\n               register(model, f_sym, 1, f; autodiff = true)\n               push!(expr.args, :($(f_sym)($(x))))\n           end\n           add_NL_constraint(model, :($(expr) <= 1))\n           print(model)\n           return\n       end\nmain (generic function with 1 method)\n\njulia> main([x -> x^2, x -> sin(x)^2])\nFeasibility\nSubject to\n (f_1(x) + f_2(x)) - 1.0 ≤ 0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"[1]: Dunning, Huchette, and Lubin, \"JuMP: A Modeling Language for Mathematical Optimization\", SIAM Review, PDF.","category":"page"},{"location":"tutorials/nonlinear/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/nonlinear/qcp.jl\"","category":"page"},{"location":"tutorials/nonlinear/qcp/#Quadratically-constrained-programs","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"","category":"section"},{"location":"tutorials/nonlinear/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"A simple quadratically constrained program based on an example from Gurobi.","category":"page"},{"location":"tutorials/nonlinear/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"using JuMP\nimport Ipopt\nimport Test\n\nfunction example_qcp(; verbose = true)\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, x)\n    @variable(model, y >= 0)\n    @variable(model, z >= 0)\n    @objective(model, Max, x)\n    @constraint(model, x + y + z == 1)\n    @constraint(model, x * x + y * y - z * z <= 0)\n    @constraint(model, x * x - y * z <= 0)\n    optimize!(model)\n    if verbose\n        print(model)\n        println(\"Objective value: \", objective_value(model))\n        println(\"x = \", value(x))\n        println(\"y = \", value(y))\n    end\n    Test.@test termination_status(model) == LOCALLY_SOLVED\n    Test.@test primal_status(model) == FEASIBLE_POINT\n    Test.@test objective_value(model) ≈ 0.32699 atol = 1e-5\n    Test.@test value(x) ≈ 0.32699 atol = 1e-5\n    Test.@test value(y) ≈ 0.25707 atol = 1e-5\n    return\nend\n\nexample_qcp()","category":"page"},{"location":"tutorials/nonlinear/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"","category":"page"},{"location":"tutorials/nonlinear/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/tutorials/latency/#Latency","page":"Latency","title":"Latency","text":"","category":"section"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"MathOptInterface suffers the \"time-to-first-solve\" problem of start-up latency.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"This hurts both the user- and developer-experience of MathOptInterface. In the first case, because simple models have a multi-second delay before solving, and in the latter, because our tests take so long to run!","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"This page contains some advice on profiling and fixing latency-related problems in the MathOptInterface.jl repository.","category":"page"},{"location":"moi/tutorials/latency/#Background","page":"Latency","title":"Background","text":"","category":"section"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Before reading this part of the documentation, you should familiarize yourself with the reasons for latency in Julia and how to fix them.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Read the blogposts on julialang.org on precompilation and SnoopCompile\nRead the SnoopCompile documentation.\nWatch Tim Holy's talk at JuliaCon 2021\nWatch the package development workshop at JuliaCon 2021","category":"page"},{"location":"moi/tutorials/latency/#Causes","page":"Latency","title":"Causes","text":"","category":"section"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"There are three main causes of latency in MathOptInterface:","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"A large number of types\nLack of method ownership\nType-instability in the bridge layer","category":"page"},{"location":"moi/tutorials/latency/#A-large-number-of-types","page":"Latency","title":"A large number of types","text":"","category":"section"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Julia is very good at specializing method calls based on the input type. Each specialization has a compilation cost, but the benefit of faster run-time performance.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"The best-case scenario is for a method to be called a large number of times with a single set of argument types. The worst-case scenario is for a method to be called a single time for a large set of argument types.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Because of MathOptInterface's function-in-set formulation, we fall into the worst-case situation.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"This is a fundamental limitation of Julia, so there isn't much we can do about it. However, if we can precompile MathOptInterface, much of the cost can be shifted from start-up latency to the time it takes to precompile a package on installation.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"However, there are two things which make MathOptInterface hard to precompile...","category":"page"},{"location":"moi/tutorials/latency/#Lack-of-method-ownership","page":"Latency","title":"Lack of method ownership","text":"","category":"section"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Lack of method ownership happens when a call is made using a mix of structs and methods from different modules. Because of this, no single module \"owns\" the method that is being dispatched, and so it cannot be precompiled.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"tip: Tip\nThis is a slightly simplified explanation. Read the precompilation tutorial for a more in-depth discussion on back-edges.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Unfortunately, the design of MOI means that this is a frequent occurrence! We have a bunch of types in MOI.Utilities that wrap types defined in external packages (i.e., the Optimizers), which implement methods of functions defined in MOI (e.g., add_variable, add_constraint).","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Here's a simple example of method-ownership in practice:","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"module MyMOI\nstruct Wrapper{T}\n    inner::T\nend\noptimize!(x::Wrapper) = optimize!(x.inner)\nend  # MyMOI\n\nmodule MyOptimizer\nusing ..MyMOI\nstruct Optimizer end\nMyMOI.optimize!(x::Optimizer) = 1\nend  # MyOptimizer\n\nusing SnoopCompile\nmodel = MyMOI.Wrapper(MyOptimizer.Optimizer())\n\njulia> tinf = @snoopi_deep MyMOI.optimize!(model)\nInferenceTimingNode: 0.008256/0.008543 on InferenceFrameInfo for Core.Compiler.Timings.ROOT() with 1 direct children","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"The result is that there was one method that required type inference. If we visualize tinf:","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"using ProfileView\nProfileView.view(flamegraph(tinf))","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"we see a flamegraph with a large red-bar indicating that the method MyMOI.optimize(MyMOI.Wrapper{MyOptimizer.Optimizer}) cannot be precompiled.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"To fix this, we need to designate a module to \"own\" that method (i.e., create a back-edge). The easiest way to do this is for MyOptimizer to call MyMOI.optimize(MyMOI.Wrapper{MyOptimizer.Optimizer}) during using MyOptimizer. Let's see that in practice:","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"module MyMOI\nstruct Wrapper{T}\n    inner::T\nend\noptimize(x::Wrapper) = optimize(x.inner)\nend  # MyMOI\n\nmodule MyOptimizer\nusing ..MyMOI\nstruct Optimizer end\nMyMOI.optimize(x::Optimizer) = 1\n# The syntax of this let-while loop is very particular:\n#  * `let ... end` keeps everything local to avoid polluting the MyOptimizer\n#    namespace\n#  * `while true ... break end` runs the code once, and forces Julia to compile\n#    the inner loop, rather than interpret it.\nlet\n    while true\n        model = MyMOI.Wrapper(Optimizer())\n        MyMOI.optimize(model)\n        break\n    end\nend\nend  # MyOptimizer\n\nusing SnoopCompile\nmodel = MyMOI.Wrapper(MyOptimizer.Optimizer())\n\njulia> tinf = @snoopi_deep MyMOI.optimize(model)\nInferenceTimingNode: 0.006822/0.006822 on InferenceFrameInfo for Core.Compiler.Timings.ROOT() with 0 direct children","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"There are now 0 direct children that required type inference because the method was already stored in MyOptimizer!","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Unfortunately, this trick only works if the call-chain is fully inferrable. If there are breaks (due to type instability), then the benefit of doing this is reduced. And unfortunately for us, the design of MathOptInterface has a lot of type instabilities...","category":"page"},{"location":"moi/tutorials/latency/#Type-instability-in-the-bridge-layer","page":"Latency","title":"Type instability in the bridge layer","text":"","category":"section"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Most of MathOptInterface is pretty good at ensuring type-stability. However, a key component is not type stable, and that is the bridging layer.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"In particular, the bridging layer defines Bridges.LazyBridgeOptimizer, which has fields like:","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"struct LazyBridgeOptimizer\n    constraint_bridge_types::Vector{Any}\n    constraint_node::Dict{Tuple{Type,Type},ConstraintNode}\n    constraint_types::Vector{Tuple{Type,Type}}\nend","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"This is because the LazyBridgeOptimizer needs to be able to deal with any function-in-set type passed to it, and we also allow users to pass additional bridges that they defined in external packages.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"So to recap, MathOptInterface suffers package latency because:","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"there are a large number of types and functions...\nand these are split between multiple modules, including external packages...\nand there are type-instabilities like those in the bridging layer.","category":"page"},{"location":"moi/tutorials/latency/#Resolutions","page":"Latency","title":"Resolutions","text":"","category":"section"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"There are no magic solutions to reduce latency. Issue #1313 tracks progress on reducing latency in MathOptInterface.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"A useful script is the following (replace GLPK as needed):","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"using MathOptInterface, GLPK\nconst MOI = MathOptInterface\n\nfunction example_diet(optimizer, bridge)\n    category_data = [\n        1800.0 2200.0;\n          91.0    Inf;\n           0.0   65.0;\n           0.0 1779.0\n    ]\n    cost = [2.49, 2.89, 1.50, 1.89, 2.09, 1.99, 2.49, 0.89, 1.59]\n    food_data = [\n        410 24 26 730;\n        420 32 10 1190;\n        560 20 32 1800;\n        380  4 19 270;\n        320 12 10 930;\n        320 15 12 820;\n        320 31 12 1230;\n        100  8 2.5 125;\n        330  8 10 180\n    ]\n    bridge_model = if bridge\n        MOI.instantiate(optimizer; with_bridge_type=Float64)\n    else\n        MOI.instantiate(optimizer)\n    end\n    model = MOI.Utilities.CachingOptimizer(\n        MOI.Utilities.UniversalFallback(MOI.Utilities.Model{Float64}()),\n        MOI.Utilities.AUTOMATIC,\n    )\n    MOI.Utilities.reset_optimizer(model, bridge_model)\n    MOI.set(model, MOI.Silent(), true)\n    nutrition = MOI.add_variables(model, size(category_data, 1))\n    for (i, v) in enumerate(nutrition)\n        MOI.add_constraint(model, v, MOI.GreaterThan(category_data[i, 1]))\n        MOI.add_constraint(model, v, MOI.LessThan(category_data[i, 2]))\n    end\n    buy = MOI.add_variables(model, size(food_data, 1))\n    MOI.add_constraint.(model, buy, MOI.GreaterThan(0.0))\n    MOI.set(model, MOI.ObjectiveSense(), MOI.MIN_SENSE)\n    f = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(cost, buy), 0.0)\n    MOI.set(model, MOI.ObjectiveFunction{typeof(f)}(), f)\n    for (j, n) in enumerate(nutrition)\n        f = MOI.ScalarAffineFunction(\n            MOI.ScalarAffineTerm.(food_data[:, j], buy),\n            0.0,\n        )\n        push!(f.terms, MOI.ScalarAffineTerm(-1.0, n))\n        MOI.add_constraint(model, f, MOI.EqualTo(0.0))\n    end\n    MOI.optimize!(model)\n    term_status = MOI.get(model, MOI.TerminationStatus())\n    @assert term_status == MOI.OPTIMAL\n    MOI.add_constraint(\n        model,\n        MOI.ScalarAffineFunction(\n            MOI.ScalarAffineTerm.(1.0, [buy[end-1], buy[end]]),\n            0.0,\n        ),\n        MOI.LessThan(6.0),\n    )\n    MOI.optimize!(model)\n    @assert MOI.get(model, MOI.TerminationStatus()) == MOI.INFEASIBLE\n    return\nend\n\nif length(ARGS) > 0\n    bridge = get(ARGS, 2, \"\") != \"--no-bridge\"\n    println(\"Running: $(ARGS[1]) $(get(ARGS, 2, \"\"))\")\n    @time example_diet(GLPK.Optimizer, bridge)\n    @time example_diet(GLPK.Optimizer, bridge)\n    exit(0)\nend","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"You can create a flame-graph via","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"using SnoopComile\ntinf = @snoopi_deep example_diet(GLPK.Optimizer, true)\nusing ProfileView\nProfileView.view(flamegraph(tinf))","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Here's how things looked in mid-August 2021: (Image: flamegraph)","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"There are a few opportunities for improvement (non-red flames, particularly on the right). But the main problem is a large red (non-precompilable due to method ownership) flame.","category":"page"},{"location":"tutorials/conic/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/conic/max_cut_sdp.jl\"","category":"page"},{"location":"tutorials/conic/max_cut_sdp/#SDP-relaxations:-max-cut","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"","category":"section"},{"location":"tutorials/conic/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"Solves a semidefinite programming relaxation of the MAXCUT graph problem:","category":"page"},{"location":"tutorials/conic/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"max   0.25 * L•X\ns.t.  diag(X) == e\n      X ≽ 0","category":"page"},{"location":"tutorials/conic/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"Where L is the weighted graph Laplacian. Uses this relaxation to generate a solution to the original MAXCUT problem using the method from the paper:","category":"page"},{"location":"tutorials/conic/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"Goemans, M. X., & Williamson, D. P. (1995). Improved approximation algorithms for maximum cut and satisfiability problems using semidefinite programming. Journal of the ACM (JACM), 42(6), 1115-1145.","category":"page"},{"location":"tutorials/conic/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"using JuMP\nimport LinearAlgebra\nimport Random\nimport SCS\nimport Test\n\nfunction solve_max_cut_sdp(num_vertex, weights)\n    # Calculate the (weighted) Lapacian of the graph: L = D - W.\n    laplacian = LinearAlgebra.diagm(0 => weights * ones(num_vertex)) - weights\n    # Solve the SDP relaxation\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, X[1:num_vertex, 1:num_vertex], PSD)\n    @objective(model, Max, 1 / 4 * LinearAlgebra.dot(laplacian, X))\n    @constraint(model, LinearAlgebra.diag(X) .== 1)\n    optimize!(model)\n    # Compute the Cholesky factorization of X, i.e., X = V^T V.\n    opt_X = LinearAlgebra.Hermitian(value.(X), :U)  # Tell Julia its PSD.\n    factorization = LinearAlgebra.cholesky(opt_X, Val(true); check = false)\n    V = (factorization.P * factorization.L)'\n    # Normalize columns.\n    for i in 1:num_vertex\n        V[:, i] ./= LinearAlgebra.norm(V[:, i])\n    end\n    # Generate random vector on unit sphere.\n    Random.seed!(num_vertex)\n    r = rand(num_vertex)\n    r /= LinearAlgebra.norm(r)\n    # Iterate over vertices, and assign each vertex to a side of cut.\n    cut = ones(num_vertex)\n    for i in 1:num_vertex\n        if LinearAlgebra.dot(r, V[:, i]) <= 0\n            cut[i] = -1\n        end\n    end\n\n    return cut, 0.25 * sum(laplacian .* (cut * cut'))\nend\n\nfunction example_max_cut_sdp()\n    #   [1] --- 5 --- [2]\n    #\n    # Solution:\n    #  (S, S′)  = ({1}, {2})\n    cut, cutval = solve_max_cut_sdp(2, [0.0 5.0; 5.0 0.0])\n    Test.@test cut[1] != cut[2]\n    #   [1] --- 5 --- [2]\n    #    |  \\          |\n    #    |    \\        |\n    #    7      6      1\n    #    |        \\    |\n    #    |          \\  |\n    #   [3] --- 1 --- [4]\n    #\n    # Solution:\n    #  (S, S′)  = ({1}, {2, 3, 4})\n    W = [\n        0.0 5.0 7.0 6.0\n        5.0 0.0 0.0 1.0\n        7.0 0.0 0.0 1.0\n        6.0 1.0 1.0 0.0\n    ]\n    cut, cutval = solve_max_cut_sdp(4, W)\n    Test.@test cut[1] != cut[2]\n    Test.@test cut[2] == cut[3] == cut[4]\n    #   [1] --- 1 --- [2]\n    #    |             |\n    #    |             |\n    #    5             9\n    #    |             |\n    #    |             |\n    #   [3] --- 2 --- [4]\n    #\n    # Solution:\n    #  (S, S′)  = ({1, 4}, {2, 3})\n    W = [\n        0.0 1.0 5.0 0.0\n        1.0 0.0 0.0 9.0\n        5.0 0.0 0.0 2.0\n        0.0 9.0 2.0 0.0\n    ]\n    cut, cutval = solve_max_cut_sdp(4, W)\n    Test.@test cut[1] == cut[4]\n    Test.@test cut[2] == cut[3]\n    Test.@test cut[1] != cut[2]\n    return\nend\n\nexample_max_cut_sdp()","category":"page"},{"location":"tutorials/conic/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"","category":"page"},{"location":"tutorials/conic/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"moi/manual/variables/#Add-a-variable","page":"Variables","title":"Add a variable","text":"","category":"section"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"Use add_variable to add a single variable.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"julia> x = MOI.add_variable(model)\nMathOptInterface.VariableIndex(1)","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"add_variable returns a VariableIndex type, which is used to refer to the added variable in other calls.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"Check if a VariableIndex is valid using is_valid.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"julia> MOI.is_valid(model, x)\ntrue","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"Use add_variables to add a number of variables.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"julia> y = MOI.add_variables(model, 2)\n2-element Vector{MathOptInterface.VariableIndex}:\n MathOptInterface.VariableIndex(2)\n MathOptInterface.VariableIndex(3)","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"warning: Warning\nThe integer does not necessarily corresond to the column inside an optimizer!","category":"page"},{"location":"moi/manual/variables/#Delete-a-variable","page":"Variables","title":"Delete a variable","text":"","category":"section"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"Delete a variable using delete.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"julia> MOI.delete(model, x)\n\njulia> MOI.is_valid(model, x)\nfalse","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"warning: Warning\nNot all ModelLike models support deleting variables. A DeleteNotAllowed error is thrown if this is not supported.","category":"page"},{"location":"moi/manual/variables/#Variable-attributes","page":"Variables","title":"Variable attributes","text":"","category":"section"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"The following attributes are available for variables:","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"VariableName\nVariablePrimalStart\nVariablePrimal","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"Get and set these attributes using get and set.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"julia> MOI.set(model, MOI.VariableName(), x, \"var_x\")\n\njulia> MOI.get(model, MOI.VariableName(), x)\n\"var_x\"","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\n\n    # For compatibility with both Julia 1.0.5 and 1.5.2\n    # Upon the Julia LTS version becoming 1.6, these imports could be dropped,\n    # and all ScalarAffineTerm and VariableIndex instances in doctests below\n    # could be replaced with MOI.ScalarAffineTerm and MOI.VariableIndex\n    # Check discussion at PR 1184: https://github.com/jump-dev/MathOptInterface.jl/pull/1184#discussion_r515300914\n    import MathOptInterface.ScalarAffineTerm\n    import MathOptInterface.VariableIndex\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Utilities/reference/#Utilities.Model","page":"API Reference","title":"Utilities.Model","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.Model","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.Model","page":"API Reference","title":"MathOptInterface.Utilities.Model","text":"An implementation of ModelLike that supports all functions and sets defined in MOI. It is parameterized by the coefficient type.\n\nExamples\n\nmodel = Model{Float64}()\nx = add_variable(model)\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#Utilities.UniversalFallback","page":"API Reference","title":"Utilities.UniversalFallback","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.UniversalFallback","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.UniversalFallback","page":"API Reference","title":"MathOptInterface.Utilities.UniversalFallback","text":"UniversalFallback\n\nThe UniversalFallback can be applied on a MathOptInterface.ModelLike model to create the model UniversalFallback(model) supporting any constraint and attribute. This allows to have a specialized implementation in model for performance critical constraints and attributes while still supporting other attributes with a small performance penalty. Note that model is unaware of constraints and attributes stored by UniversalFallback so this is not appropriate if model is an optimizer (for this reason, MathOptInterface.optimize! has not been implemented). In that case, optimizer bridges should be used instead.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#Utilities.@model","page":"API Reference","title":"Utilities.@model","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.@model\nUtilities.GenericModel\nUtilities.GenericOptimizer\nUtilities.@struct_of_constraints_by_function_types\nUtilities.@struct_of_constraints_by_set_types\nUtilities.struct_of_constraint_code","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.@model","page":"API Reference","title":"MathOptInterface.Utilities.@model","text":"macro model(\n    model_name,\n    scalar_sets,\n    typed_scalar_sets,\n    vector_sets,\n    typed_vector_sets,\n    scalar_functions,\n    typed_scalar_functions,\n    vector_functions,\n    typed_vector_functions,\n    is_optimizer = false\n)\n\nCreates a type model_name implementing the MOI model interface and containing scalar_sets scalar sets typed_scalar_sets typed scalar sets, vector_sets vector sets, typed_vector_sets typed vector sets, scalar_functions scalar functions, typed_scalar_functions typed scalar functions, vector_functions vector functions and typed_vector_functions typed vector functions. To give no set/function, write (), to give one set S, write (S,).\n\nThe function MathOptInterface.VariableIndex should not be given in scalar_functions. The model supports MathOptInterface.VariableIndex-in-S constraints where S is MathOptInterface.EqualTo, MathOptInterface.GreaterThan, MathOptInterface.LessThan, MathOptInterface.Interval, MathOptInterface.Integer, MathOptInterface.ZeroOne, MathOptInterface.Semicontinuous or MathOptInterface.Semiinteger. The sets supported with the MathOptInterface.VariableIndex cannot be controlled from the macro, use the UniversalFallback to support more sets.\n\nThis macro creates a model specialized for specific types of constraint, by defining specialized structures and methods. To create a model that, in addition to be optimized for specific constraints, also support arbitrary constraints and attributes, use UniversalFallback.\n\nIf is_optimizer = true, the resulting struct is a of GenericOptimizer, which is a subtype of MathOptInterface.AbstractOptimizer, otherwise, it is a GenericModel, which is a subtype of MathOptInterface.ModelLike.\n\nExamples\n\nThe model describing an linear program would be:\n\n@model(LPModel,                                                   # Name of model\n      (),                                                         # untyped scalar sets\n      (MOI.EqualTo, MOI.GreaterThan, MOI.LessThan, MOI.Interval), #   typed scalar sets\n      (MOI.Zeros, MOI.Nonnegatives, MOI.Nonpositives),            # untyped vector sets\n      (),                                                         #   typed vector sets\n      (),                                                         # untyped scalar functions\n      (MOI.ScalarAffineFunction,),                                #   typed scalar functions\n      (MOI.VectorOfVariables,),                                   # untyped vector functions\n      (MOI.VectorAffineFunction,),                                #   typed vector functions\n      false\n    )\n\nLet MOI denote MathOptInterface, MOIU denote MOI.Utilities. The macro would create the following types with struct_of_constraint_code:\n\nstruct LPModelScalarConstraints{T, C1, C2, C3, C4} <: MOIU.StructOfConstraints\n    moi_equalto::C1\n    moi_greaterthan::C2\n    moi_lessthan::C3\n    moi_interval::C4\nend\nstruct LPModelVectorConstraints{T, C1, C2, C3} <: MOIU.StructOfConstraints\n    moi_zeros::C1\n    moi_nonnegatives::C2\n    moi_nonpositives::C3\nend\nstruct LPModelFunctionConstraints{T} <: MOIU.StructOfConstraints\n    moi_scalaraffinefunction::LPModelScalarConstraints{\n        T,\n        MOIU.VectorOfConstraints{MOI.ScalarAffineFunction{T}, MOI.EqualTo{T}},\n        MOIU.VectorOfConstraints{MOI.ScalarAffineFunction{T}, MOI.GreaterThan{T}},\n        MOIU.VectorOfConstraints{MOI.ScalarAffineFunction{T}, MOI.LessThan{T}},\n        MOIU.VectorOfConstraints{MOI.ScalarAffineFunction{T}, MOI.Interval{T}}\n    }\n    moi_vectorofvariables::LPModelVectorConstraints{\n        T,\n        MOIU.VectorOfConstraints{MOI.VectorOfVariables, MOI.Zeros},\n        MOIU.VectorOfConstraints{MOI.VectorOfVariables, MOI.Nonnegatives},\n        MOIU.VectorOfConstraints{MOI.VectorOfVariables, MOI.Nonpositives}\n    }\n    moi_vectoraffinefunction::LPModelVectorConstraints{\n        T,\n        MOIU.VectorOfConstraints{MOI.VectorAffineFunction{T}, MOI.Zeros},\n        MOIU.VectorOfConstraints{MOI.VectorAffineFunction{T}, MOI.Nonnegatives},\n        MOIU.VectorOfConstraints{MOI.VectorAffineFunction{T}, MOI.Nonpositives}\n    }\nend\nconst LPModel{T} = MOIU.GenericModel{T,MOIU.ObjectiveContainer{T},MOIU.VariablesContainer{T},LPModelFunctionConstraints{T}}\n\nThe type LPModel implements the MathOptInterface API except methods specific to optimizers like optimize! or get with VariablePrimal.\n\n\n\n\n\n","category":"macro"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.GenericModel","page":"API Reference","title":"MathOptInterface.Utilities.GenericModel","text":"mutable struct GenericModel{T,O,V,C} <: AbstractModelLike{T}\n\nImplements a model supporting coefficients of type T and:\n\nAn objective function stored in .objective::O\nVariables and VariableIndex constraints stored in .variable_bounds::V\nF-in-S constraints (excluding VariableIndex constraints) stored in .constraints::C\n\nAll interactions should take place via the MOI interface, so the types O, V, and C should implement the API as needed for their functionality.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.GenericOptimizer","page":"API Reference","title":"MathOptInterface.Utilities.GenericOptimizer","text":"mutable struct GenericOptimizer{T,O,V,C} <: AbstractOptimizer{T}\n\nImplements a model supporting coefficients of type T and:\n\nAn objective function stored in .objective::O\nVariables and VariableIndex constraints stored in .variable_bounds::V\nF-in-S constraints (excluding VariableIndex constraints) stored in .constraints::C\n\nAll interactions should take place via the MOI interface, so the types O, V, and C should implement the API as needed for their functionality.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.@struct_of_constraints_by_function_types","page":"API Reference","title":"MathOptInterface.Utilities.@struct_of_constraints_by_function_types","text":"Utilities.@struct_of_constraints_by_function_types(name, func_types...)\n\nGiven a vector of n function types (F1, F2,..., Fn) in func_types, defines a subtype of StructOfConstraints of name name and which type parameters {T, C1, C2, ..., Cn}. It contains n field where the ith field has type Ci and stores the constraints of function type Fi.\n\nThe expression Fi can also be a union in which case any constraint for which the function type is in the union is stored in the field with type Ci.\n\n\n\n\n\n","category":"macro"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.@struct_of_constraints_by_set_types","page":"API Reference","title":"MathOptInterface.Utilities.@struct_of_constraints_by_set_types","text":"Utilities.@struct_of_constraints_by_set_types(name, func_types...)\n\nGiven a vector of n set types (S1, S2,..., Sn) in func_types, defines a subtype of StructOfConstraints of name name and which type parameters {T, C1, C2, ..., Cn}. It contains n field where the ith field has type Ci and stores the constraints of set type Si. The expression Si can also be a union in which case any constraint for which the set type is in the union is stored in the field with type Ci. This can be useful if Ci is a MatrixOfConstraints in order to concatenate the coefficients of constraints of several different set types in the same matrix.\n\n\n\n\n\n","category":"macro"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.struct_of_constraint_code","page":"API Reference","title":"MathOptInterface.Utilities.struct_of_constraint_code","text":"struct_of_constraint_code(struct_name, types, field_types = nothing)\n\nGiven a vector of n Union{SymbolFun,_UnionSymbolFS{SymbolFun}} or Union{SymbolSet,_UnionSymbolFS{SymbolSet}} in types, defines a subtype of StructOfConstraints of name name and which type parameters {T, F1, F2, ..., Fn} if field_types is nothing and a {T} otherwise. It contains n field where the ith field has type Ci if field_types is nothing and type field_types[i] otherwise. If types is vector of Union{SymbolFun,_UnionSymbolFS{SymbolFun}} (resp. Union{SymbolSet,_UnionSymbolFS{SymbolSet}}) then the constraints of that function (resp. set) type are stored in the corresponding field.\n\nThis function is used by the macros @model, @struct_of_constraints_by_function_types and @struct_of_constraints_by_set_types.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#Caching-optimizer","page":"API Reference","title":"Caching optimizer","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.CachingOptimizer\nUtilities.attach_optimizer\nUtilities.reset_optimizer\nUtilities.drop_optimizer\nUtilities.state\nUtilities.mode","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.CachingOptimizer","page":"API Reference","title":"MathOptInterface.Utilities.CachingOptimizer","text":"CachingOptimizer\n\nCachingOptimizer is an intermediate layer that stores a cache of the model and links it with an optimizer. It supports incremental model construction and modification even when the optimizer doesn't.\n\nA CachingOptimizer may be in one of three possible states (CachingOptimizerState):\n\nNO_OPTIMIZER: The CachingOptimizer does not have any optimizer.\nEMPTY_OPTIMIZER: The CachingOptimizer has an empty optimizer. The optimizer is not synchronized with the cached model.\nATTACHED_OPTIMIZER: The CachingOptimizer has an optimizer, and it is synchronized with the cached model.\n\nA CachingOptimizer has two modes of operation (CachingOptimizerMode):\n\nMANUAL: The only methods that change the state of the CachingOptimizer are Utilities.reset_optimizer, Utilities.drop_optimizer, and Utilities.attach_optimizer. Attempting to perform an operation in the incorrect state results in an error.\nAUTOMATIC: The CachingOptimizer changes its state when necessary. For example, optimize! will automatically call attach_optimizer (an optimizer must have been previously set). Attempting to add a constraint or perform a modification not supported by the optimizer results in a drop to EMPTY_OPTIMIZER mode.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.attach_optimizer","page":"API Reference","title":"MathOptInterface.Utilities.attach_optimizer","text":"attach_optimizer(model::CachingOptimizer)\n\nAttaches the optimizer to model, copying all model data into it. Can be called only from the EMPTY_OPTIMIZER state. If the copy succeeds, the CachingOptimizer will be in state ATTACHED_OPTIMIZER after the call, otherwise an error is thrown; see MathOptInterface.copy_to for more details on which errors can be thrown.\n\n\n\n\n\nMOIU.attach_optimizer(model::Model)\n\nCall MOIU.attach_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.reset_optimizer","page":"API Reference","title":"MathOptInterface.Utilities.reset_optimizer","text":"reset_optimizer(m::CachingOptimizer, optimizer::MOI.AbstractOptimizer)\n\nSets or resets m to have the given empty optimizer optimizer.\n\nCan be called from any state. An assertion error will be thrown if optimizer is not empty.\n\nThe CachingOptimizer m will be in state EMPTY_OPTIMIZER after the call.\n\n\n\n\n\nreset_optimizer(m::CachingOptimizer)\n\nDetaches and empties the current optimizer. Can be called from ATTACHED_OPTIMIZER or EMPTY_OPTIMIZER state. The CachingOptimizer will be in state EMPTY_OPTIMIZER after the call.\n\n\n\n\n\nMOIU.reset_optimizer(model::Model, optimizer::MOI.AbstractOptimizer)\n\nCall MOIU.reset_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\nMOIU.reset_optimizer(model::Model)\n\nCall MOIU.reset_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.drop_optimizer","page":"API Reference","title":"MathOptInterface.Utilities.drop_optimizer","text":"drop_optimizer(m::CachingOptimizer)\n\nDrops the optimizer, if one is present. Can be called from any state. The CachingOptimizer will be in state NO_OPTIMIZER after the call.\n\n\n\n\n\nMOIU.drop_optimizer(model::Model)\n\nCall MOIU.drop_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.state","page":"API Reference","title":"MathOptInterface.Utilities.state","text":"state(m::CachingOptimizer)::CachingOptimizerState\n\nReturns the state of the CachingOptimizer m. See Utilities.CachingOptimizer.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.mode","page":"API Reference","title":"MathOptInterface.Utilities.mode","text":"mode(m::CachingOptimizer)::CachingOptimizerMode\n\nReturns the operating mode of the CachingOptimizer m. See Utilities.CachingOptimizer.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#Mock-optimizer","page":"API Reference","title":"Mock optimizer","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.MockOptimizer","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.MockOptimizer","page":"API Reference","title":"MathOptInterface.Utilities.MockOptimizer","text":"MockOptimizer\n\nMockOptimizer is a fake optimizer especially useful for testing. Its main feature is that it can store the values that should be returned for each attribute.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#Printing","page":"API Reference","title":"Printing","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.latex_formulation","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.latex_formulation","page":"API Reference","title":"MathOptInterface.Utilities.latex_formulation","text":"latex_formulation(model::MOI.ModelLike; kwargs...)\n\nWrap model in a type so that it can be pretty-printed as text/latex in a notebook like IJulia, or in Documenter.\n\nTo render the model, end the cell with latex_formulation(model), or call display(latex_formulation(model)) in to force the display of the model from inside a function.\n\nPossible keyword arguments are:\n\nsimplify_coefficients : Simplify coefficients if possible by omitting them or removing trailing zeros.\ndefault_name : The name given to variables with an empty name.\nprint_types : Print the MOI type of each function and set for clarity.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#Copy-utilities","page":"API Reference","title":"Copy utilities","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.default_copy_to\nUtilities.IndexMap\nUtilities.identity_index_map\nUtilities.ModelFilter","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.default_copy_to","page":"API Reference","title":"MathOptInterface.Utilities.default_copy_to","text":"default_copy_to(dest::MOI.ModelLike, src::MOI.ModelLike)\n\nA default implementation of MOI.copy_to(dest, src) for models that implement the incremental interface, i.e., MOI.supports_incremental_interface returns true.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.IndexMap","page":"API Reference","title":"MathOptInterface.Utilities.IndexMap","text":"IndexMap()\n\nThe dictionary-like object returned by MathOptInterface.copy_to.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.identity_index_map","page":"API Reference","title":"MathOptInterface.Utilities.identity_index_map","text":"identity_index_map(model::MOI.ModelLike)\n\nReturn an IndexMap that maps all variable and constraint indices of model to themselves.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.ModelFilter","page":"API Reference","title":"MathOptInterface.Utilities.ModelFilter","text":"ModelFilter(filter::Function, model::MOI.ModelLike)\n\nA layer to filter out various components of model.\n\nThe filter function takes a single argument, which is eacy element from the list returned by the attributes below. It returns true if the element should be visible in the filtered model and false otherwise.\n\nThe components that are filtered are:\n\nEntire constraint types via:\nMOI.ListOfConstraintTypesPresent\nIndividual constraints via:\nMOI.ListOfConstraintIndices{F,S}\nSpecific attributes via:\nMOI.ListOfModelAttributesSet\nMOI.ListOfConstraintAttributesSet\nMOI.ListOfVariableAttributesSet\n\nwarning: Warning\nThe list of attributes filtered may change in a future release. You should write functions that are generic and not limited to the five types listed above. Thus, you should probably define a fallback filter(::Any) = true.\n\nSee below for examples of how this works.\n\nnote: Note\nThis layer has a limited scope. It is intended by be used in conjunction with MOI.copy_to.\n\nExample: copy model excluding integer constraints\n\nUse the do syntax to provide a single function.\n\nfiltered_src = MOI.Utilities.ModelFilter(src) do item\n    return item != (MOI.VariableIndex, MOI.Integer)\nend\nMOI.copy_to(dest, filtered_src)\n\nExample: copy model excluding names\n\nUse type dispatch to simplify the implementation:\n\nmy_filter(::Any) = true  # Note the generic fallback!\nmy_filter(::MOI.VariableName) = false\nmy_filter(::MOI.ConstraintName) = false\nfiltered_src = MOI.Utilities.ModelFilter(my_filter, src)\nMOI.copy_to(dest, filtered_src)\n\nExample: copy irreducible infeasible subsystem\n\nmy_filter(::Any) = true  # Note the generic fallback!\nfunction my_filter(ci::MOI.ConstraintIndex)\n    status = MOI.get(dest, MOI.ConstraintConflictStatus(), ci)\n    return status != MOI.NOT_IN_CONFLICT\nend\nfiltered_src = MOI.Utilities.ModelFilter(my_filter, src)\nMOI.copy_to(dest, filtered_src)\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MatrixOfConstraints","page":"API Reference","title":"MatrixOfConstraints","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.MatrixOfConstraints","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.MatrixOfConstraints","page":"API Reference","title":"MathOptInterface.Utilities.MatrixOfConstraints","text":"mutable struct MatrixOfConstraints{T,AT,BT,ST} <: MOI.ModelLike\n    coefficients::AT\n    constants::BT\n    sets::ST\n    caches::Vector{Any}\n    are_indices_mapped::Vector{BitSet}\n    final_touch::Bool\nend\n\nRepresent ScalarAffineFunction and VectorAffinefunction constraints in a matrix form where the linear coefficients of the functions are stored in the coefficients field, the constants of the functions or sets are stored in the constants field. Additional information about the sets are stored in the sets field.\n\nThis model can only be used as the constraints field of a MOI.Utilities.AbstractModel.\n\nWhen the constraints are added, they are stored in the caches field. They are only loaded in the coefficients and constants fields once MOI.Utilities.final_touch is called. For this reason, MatrixOfConstraints should not be used by an incremental interface. Use MOI.copy_to instead.\n\nThe constraints can be added in two different ways:\n\nWith add_constraint, in which case a canonicalized copy of the function is stored in caches.\nWith pass_nonvariable_constraints, in which case the functions and sets are stored themselves in caches without mapping the variable indices. The corresponding index in caches is added in are_indices_mapped. This avoids doing a copy of the function in case the getter of CanonicalConstraintFunction does not make a copy for the source model, e.g., this is the case of VectorOfConstraints.\n\nWe illustrate this with an example. Suppose a model is copied from a src::MOI.Utilities.Model to a bridged model with a MatrixOfConstraints. For all the types that are not bridged, the constraints will be copied with pass_nonvariable_constraints. Hence the functions stored in caches are exactly the same as the ones stored in src. This is ok since this is only during the copy_to operation during which src cannot be modified. On the other hand, for the types that are bridged, the functions added may contain duplicates even if the functions did not contain duplicates in src so duplicates are removed with MOI.Utilities.canonical.\n\nInterface\n\nThe .coefficients::AT type must implement:\n\nAT()\nMOI.empty(::AT)!\nMOI.Utilities.add_column\nMOI.Utilities.set_number_of_rows\nMOI.Utilities.allocate_terms\nMOI.Utilities.load_terms\nMOI.Utilities.final_touch\n\nThe .constants::BT type must implement:\n\nBT()\nBase.empty!(::BT)\nBase.resize(::BT)\nMOI.Utilities.load_constants\nMOI.Utilities.function_constants\nMOI.Utilities.set_from_constants\n\nThe .sets::ST type must implement:\n\nST()\nMOI.is_empty(::ST)\nMOI.empty(::ST)\nMOI.dimension(::ST)\nMOI.is_valid(::ST, ::MOI.ConstraintIndex)\nMOI.get(::ST, ::MOI.ListOfConstraintTypesPresent)\nMOI.get(::ST, ::MOI.NumberOfConstraints)\nMOI.get(::ST, ::MOI.ListOfConstraintIndices)\nMOI.Utilities.set_types\nMOI.Utilities.set_index\nMOI.Utilities.add_set\nMOI.Utilities.rows\nMOI.Utilities.final_touch\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#.coefficients","page":"API Reference","title":".coefficients","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.add_column\nUtilities.allocate_terms\nUtilities.set_number_of_rows\nUtilities.load_terms\nUtilities.final_touch\nUtilities.extract_function","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.add_column","page":"API Reference","title":"MathOptInterface.Utilities.add_column","text":"add_column(coefficients)::Nothing\n\nTell coefficients to pre-allocate datastructures as needed to store one column.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.allocate_terms","page":"API Reference","title":"MathOptInterface.Utilities.allocate_terms","text":"allocate_terms(coefficients, index_map, func)::Nothing\n\nTell coefficients that the terms of the function func where the variable indices are mapped with index_map will be loaded with load_terms.\n\nThe function func must be canonicalized before calling allocate_terms. See is_canonical.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.set_number_of_rows","page":"API Reference","title":"MathOptInterface.Utilities.set_number_of_rows","text":"set_number_of_rows(coefficients, n)::Nothing\n\nTell coefficients to pre-allocate datastructures as needed to store n rows.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.load_terms","page":"API Reference","title":"MathOptInterface.Utilities.load_terms","text":"load_terms(coefficients, index_map, func, offset)::Nothing\n\nLoads the terms of func to coefficients, mapping the variable indices with index_map.\n\nThe ith dimension of func is loaded at the (offset + i)th row of coefficients.\n\nThe function must be allocated first with allocate_terms.\n\nThe function func must be canonicalized, see is_canonical.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.final_touch","page":"API Reference","title":"MathOptInterface.Utilities.final_touch","text":"final_touch(coefficients)::Nothing\n\nInforms the coefficients that all functions have been added with load_terms. No more modification is allowed unless MOI.empty! is called.\n\nfinal_touch(sets)::Nothing\n\nInforms the sets that all functions have been added with add_set. No more modification is allowed unless MOI.empty! is called.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.extract_function","page":"API Reference","title":"MathOptInterface.Utilities.extract_function","text":"extract_function(coefficients, row::Integer, constant::T) where {T}\n\nReturn the MOI.ScalarAffineFunction{T} function corresponding to row row in coefficients.\n\nextract_function(\n    coefficients,\n    rows::UnitRange,\n    constants::Vector{T},\n) where{T}\n\nReturn the MOI.VectorAffineFunction{T} function corresponding to rows rows in coefficients.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.MutableSparseMatrixCSC\nUtilities.AbstractIndexing\nUtilities.ZeroBasedIndexing\nUtilities.OneBasedIndexing","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.MutableSparseMatrixCSC","page":"API Reference","title":"MathOptInterface.Utilities.MutableSparseMatrixCSC","text":"mutable struct MutableSparseMatrixCSC{Tv,Ti<:Integer,I<:AbstractIndexing}\n    indexing::I\n    m::Int\n    n::Int\n    colptr::Vector{Ti}\n    rowval::Vector{Ti}\n    nzval::Vector{Tv}\nend\n\nMatrix type loading sparse matrices in the Compressed Sparse Column format. The indexing used is indexing, see AbstractIndexing. The other fields have the same meaning than for SparseArrays.SparseMatrixCSC except that the indexing is different unless indexing is OneBasedIndexing.\n\nThe matrix is loaded in 5 steps:\n\nMOI.empty! is called.\nMOI.Utilities.add_column and MOI.Utilities.allocate_terms are called in any order.\nMOI.Utilities.set_number_of_rows is called.\nMOI.Utilities.load_terms is called for each affine function.\nMOI.Utilities.final_touch is called.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.AbstractIndexing","page":"API Reference","title":"MathOptInterface.Utilities.AbstractIndexing","text":"abstract type AbstractIndexing end\n\nIndexing to be used for storing the row and column indices of MutableSparseMatrixCSC. See ZeroBasedIndexing and OneBasedIndexing.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.ZeroBasedIndexing","page":"API Reference","title":"MathOptInterface.Utilities.ZeroBasedIndexing","text":"struct ZeroBasedIndexing <: AbstractIndexing end\n\nZero-based indexing: the ith row or column has index i - 1. This is useful when the vectors of row and column indices need to be communicated to a library using zero-based indexing such as C libraries.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.OneBasedIndexing","page":"API Reference","title":"MathOptInterface.Utilities.OneBasedIndexing","text":"struct ZeroBasedIndexing <: AbstractIndexing end\n\nOne-based indexing: the ith row or column has index i. This enables an allocation-free conversion of MutableSparseMatrixCSC to SparseArrays.SparseMatrixCSC.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#.constants","page":"API Reference","title":".constants","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.load_constants\nUtilities.function_constants\nUtilities.set_from_constants","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.load_constants","page":"API Reference","title":"MathOptInterface.Utilities.load_constants","text":"load_constants(constants, offset, func_or_set)::Nothing\n\nThis function loads the constants of func_or_set in constants at an offset of offset. Where offset is the sum of the dimensions of the constraints already loaded. The storage should be preallocated with resize! before calling this function.\n\nThis function should be implemented to be usable as storage of constants for MatrixOfConstraints.\n\nThe constants are loaded in three steps:\n\nBase.empty! is called.\nBase.resize! is called with the sum of the dimensions of all constraints.\nMOI.Utilities.load_constants is called for each function for vector constraint or set for scalar constraint.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.function_constants","page":"API Reference","title":"MathOptInterface.Utilities.function_constants","text":"function_constants(constants, rows)\n\nThis function returns the function constants that were loaded with load_constants at the rows rows.\n\nThis function should be implemented to be usable as storage of constants for MatrixOfConstraints.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.set_from_constants","page":"API Reference","title":"MathOptInterface.Utilities.set_from_constants","text":"set_from_constants(constants, S::Type, rows)::S\n\nThis function returns an instance of the set S for which the constants where loaded with load_constants at the rows rows.\n\nThis function should be implemented to be usable as storage of constants for MatrixOfConstraints.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.Hyperrectangle","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.Hyperrectangle","page":"API Reference","title":"MathOptInterface.Utilities.Hyperrectangle","text":"struct Hyperrectangle{T} <: AbstractVectorBounds\n    lower::Vector{T}\n    upper::Vector{T}\nend\n\nA struct for the .constants field in MatrixOfConstraints.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#.sets","page":"API Reference","title":".sets","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.set_index\nUtilities.set_types\nUtilities.add_set\nUtilities.rows\nUtilities.num_rows\nUtilities.set_with_dimension","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.set_index","page":"API Reference","title":"MathOptInterface.Utilities.set_index","text":"set_index(sets, ::Type{S})::Union{Int,Nothing} where {S<:MOI.AbstractSet}\n\nReturn an integer corresponding to the index of the set type in the list given by set_types.\n\nIf S is not part of the list, return nothing.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.set_types","page":"API Reference","title":"MathOptInterface.Utilities.set_types","text":"set_types(sets)::Vector{Type}\n\nReturn the list of the types of the sets allowed in sets.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.add_set","page":"API Reference","title":"MathOptInterface.Utilities.add_set","text":"add_set(sets, i)::Int64\n\nAdd a scalar set of type index i.\n\nadd_set(sets, i, dim)::Int64\n\nAdd a vector set of type index i and dimension dim.\n\nBoth methods return a unique Int64 of the set that can be used to reference this set.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.rows","page":"API Reference","title":"MathOptInterface.Utilities.rows","text":"rows(sets, ci::MOI.ConstraintIndex)::Union{Int,UnitRange{Int}}\n\nReturn the rows in 1:MOI.dimension(sets) corresponding to the set of id ci.value.\n\nFor scalar sets, this returns an Int. For vector sets, this returns an UnitRange{Int}.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.num_rows","page":"API Reference","title":"MathOptInterface.Utilities.num_rows","text":"num_rows(sets::OrderedProductOfSets, ::Type{S}) where {S}\n\nReturn the number of rows corresponding to a set of type S. That is, it is the sum of the dimensions of the sets of type S.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.set_with_dimension","page":"API Reference","title":"MathOptInterface.Utilities.set_with_dimension","text":"set_with_dimension(::Type{S}, dim) where {S<:MOI.AbstractVectorSet}\n\nReturns the instance of S of MathOptInterface.dimension dim. This needs to be implemented for sets of type S to be useable with MatrixOfConstraints.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.ProductOfSets\nUtilities.MixOfScalarSets\nUtilities.@mix_of_scalar_sets\nUtilities.OrderedProductOfSets\nUtilities.@product_of_sets","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.ProductOfSets","page":"API Reference","title":"MathOptInterface.Utilities.ProductOfSets","text":"abstract type ProductOfSets{T} end\n\nRepresents a cartesian product of sets of given types.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.MixOfScalarSets","page":"API Reference","title":"MathOptInterface.Utilities.MixOfScalarSets","text":"abstract type MixOfScalarSets{T} <: ProductOfSets{T} end\n\nProduct of scalar sets in the order the constraints are added, mixing the constraints of different types.\n\nUse @mix_of_scalar_sets to generate a new subtype.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.@mix_of_scalar_sets","page":"API Reference","title":"MathOptInterface.Utilities.@mix_of_scalar_sets","text":"@mix_of_scalar_sets(name, set_types...)\n\nGenerate a new MixOfScalarSets subtype.\n\nExample\n\n@mix_of_scalar_sets(\n    MixedIntegerLinearProgramSets,\n    MOI.GreaterThan{T},\n    MOI.LessThan{T},\n    MOI.EqualTo{T},\n    MOI.Integer,\n)\n\n\n\n\n\n","category":"macro"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.OrderedProductOfSets","page":"API Reference","title":"MathOptInterface.Utilities.OrderedProductOfSets","text":"abstract type OrderedProductOfSets{T} <: ProductOfSets{T} end\n\nProduct of sets in the order the constraints are added, grouping the constraints of the same types contiguously.\n\nUse @product_of_sets to generate new subtypes.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.@product_of_sets","page":"API Reference","title":"MathOptInterface.Utilities.@product_of_sets","text":"@product_of_sets(name, set_types...)\n\nGenerate a new OrderedProductOfSets subtype.\n\nExample\n\n@product_of_sets(\n    LinearOrthants,\n    MOI.Zeros,\n    MOI.Nonnegatives,\n    MOI.Nonpositives,\n    MOI.ZeroOne,\n)\n\n\n\n\n\n","category":"macro"},{"location":"moi/submodules/Utilities/reference/#Fallbacks","page":"API Reference","title":"Fallbacks","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.get_fallback","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.get_fallback","page":"API Reference","title":"MathOptInterface.Utilities.get_fallback","text":"get_fallback(model::MOI.ModelLike, ::MOI.ObjectiveValue)\n\nCompute the objective function value using the VariablePrimal results and the ObjectiveFunction value.\n\n\n\n\n\nget_fallback(model::MOI.ModelLike, ::MOI.DualObjectiveValue, T::Type)::T\n\nCompute the dual objective value of type T using the ConstraintDual results and the ConstraintFunction and ConstraintSet values. Note that the nonlinear part of the model is ignored.\n\n\n\n\n\nget_fallback(model::MOI.ModelLike, ::MOI.ConstraintPrimal,\n             constraint_index::MOI.ConstraintIndex)\n\nCompute the value of the function of the constraint of index constraint_index using the VariablePrimal results and the ConstraintFunction values.\n\n\n\n\n\nget_fallback(model::MOI.ModelLike, attr::MOI.ConstraintDual,\n             ci::MOI.ConstraintIndex{Union{MOI.VariableIndex,\n                                           MOI.VectorOfVariables}})\n\nCompute the dual of the constraint of index ci using the ConstraintDual of other constraints and the ConstraintFunction values. Throws an error if some constraints are quadratic or if there is one another MOI.VariableIndex-in-S or MOI.VectorOfVariables-in-S constraint with one of the variables in the function of the constraint ci.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#Function-utilities","page":"API Reference","title":"Function utilities","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following utilities are available for functions:","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.eval_variables\nUtilities.map_indices\nUtilities.substitute_variables\nUtilities.filter_variables\nUtilities.remove_variable\nUtilities.all_coefficients\nUtilities.unsafe_add\nUtilities.isapprox_zero\nUtilities.modify_function\nUtilities.zero_with_output_dimension","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.eval_variables","page":"API Reference","title":"MathOptInterface.Utilities.eval_variables","text":"eval_variables(varval::Function, f::AbstractFunction)\n\nReturns the value of function f if each variable index vi is evaluated as varval(vi). Note that varval should return a number, see substitute_variables for a similar function where varval returns a function.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.map_indices","page":"API Reference","title":"MathOptInterface.Utilities.map_indices","text":"map_indices(index_map::Function, attr::MOI.AnyAttribute, x::X)::X where {X}\n\nSubstitute any MOI.VariableIndex (resp. MOI.ConstraintIndex) in x by the MOI.VariableIndex (resp. MOI.ConstraintIndex) of the same type given by index_map(x).\n\nWhen to implement this method for new types X\n\nThis function is used by implementations of MOI.copy_to on constraint functions, attribute values and submittable values. If you define a new attribute whose values x::X contain variable or constraint indices, you must also implement this function.\n\n\n\n\n\nmap_indices(\n    variable_map::AbstractDict{T,T},\n    x::X,\n)::X where {T<:MOI.Index,X}\n\nShortcut for map_indices(vi -> variable_map[vi], x).\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.substitute_variables","page":"API Reference","title":"MathOptInterface.Utilities.substitute_variables","text":"substitute_variables(variable_map::Function, x)\n\nSubstitute any MOI.VariableIndex in x by variable_map(x). The variable_map function returns either MOI.VariableIndex or MOI.ScalarAffineFunction, see eval_variables for a similar function where variable_map returns a number.\n\nThis function is used by bridge optimizers on constraint functions, attribute values and submittable values when at least one variable bridge is used hence it needs to be implemented for custom types that are meant to be used as attribute or submittable value.\n\nWARNING: Don't use substitude_variables(::Function, ...) because Julia will not specialize on this. Use instead substitude_variables(::F, ...) where {F<:Function}.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.filter_variables","page":"API Reference","title":"MathOptInterface.Utilities.filter_variables","text":"filter_variables(keep::Function, f::AbstractFunction)\n\nReturn a new function f with the variable vi such that !keep(vi) removed.\n\nWARNING: Don't define filter_variables(::Function, ...) because Julia will not specialize on this. Define instead filter_variables(::F, ...) where {F<:Function}.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.remove_variable","page":"API Reference","title":"MathOptInterface.Utilities.remove_variable","text":"remove_variable(f::AbstractFunction, vi::VariableIndex)\n\nReturn a new function f with the variable vi removed.\n\n\n\n\n\nremove_variable(f::MOI.AbstractFunction, s::MOI.AbstractSet, vi::MOI.VariableIndex)\n\nReturn a tuple (g, t) representing the constraint f-in-s with the variable vi removed. That is, the terms containing the variable vi in the function f are removed and the dimension of the set s is updated if needed (e.g. when f is a VectorOfVariables with vi being one of the variables).\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.all_coefficients","page":"API Reference","title":"MathOptInterface.Utilities.all_coefficients","text":"all_coefficients(p::Function, f::MOI.AbstractFunction)\n\nDetermine whether predicate p returns true for all coefficients of f, returning false as soon as the first coefficient of f for which p returns false is encountered (short-circuiting). Similar to all.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.unsafe_add","page":"API Reference","title":"MathOptInterface.Utilities.unsafe_add","text":"unsafe_add(t1::MOI.ScalarAffineTerm, t2::MOI.ScalarAffineTerm)\n\nSums the coefficients of t1 and t2 and returns an output MOI.ScalarAffineTerm. It is unsafe because it uses the variable of t1 as the variable of the output without checking that it is equal to that of t2.\n\n\n\n\n\nunsafe_add(t1::MOI.ScalarQuadraticTerm, t2::MOI.ScalarQuadraticTerm)\n\nSums the coefficients of t1 and t2 and returns an output MOI.ScalarQuadraticTerm. It is unsafe because it uses the variable's of t1 as the variable's of the output without checking that they are the same (up to permutation) to those of t2.\n\n\n\n\n\nunsafe_add(t1::MOI.VectorAffineTerm, t2::MOI.VectorAffineTerm)\n\nSums the coefficients of t1 and t2 and returns an output MOI.VectorAffineTerm. It is unsafe because it uses the output_index and variable of t1 as the output_index and variable of the output term without checking that they are equal to those of t2.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.isapprox_zero","page":"API Reference","title":"MathOptInterface.Utilities.isapprox_zero","text":"isapprox_zero(f::MOI.AbstractFunction, tol)\n\nReturn a Bool indicating whether the function f is approximately zero using tol as a tolerance.\n\nImportant note\n\nThis function assumes that f does not contain any duplicate terms, you might want to first call canonical if that is not guaranteed. For instance, given\n\nf = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([1, -1], [x, x]), 0)`.\n\nthen isapprox_zero(f) is false but isapprox_zero(MOIU.canonical(f)) is true.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.modify_function","page":"API Reference","title":"MathOptInterface.Utilities.modify_function","text":"modify_function(f::AbstractFunction, change::AbstractFunctionModification)\n\nReturn a new function f modified according to change.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.zero_with_output_dimension","page":"API Reference","title":"MathOptInterface.Utilities.zero_with_output_dimension","text":"zero_with_output_dimension(::Type{T}, output_dimension::Integer) where {T}\n\nCreate an instance of type T with the output dimension output_dimension.\n\nThis is mostly useful in Bridges, when code needs to be agnostic to the type of vector-valued function that is passed in.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following functions can be used to canonicalize a function:","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.is_canonical\nUtilities.canonical\nUtilities.canonicalize!","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.is_canonical","page":"API Reference","title":"MathOptInterface.Utilities.is_canonical","text":"is_canonical(f::Union{ScalarAffineFunction, VectorAffineFunction})\n\nReturns a Bool indicating whether the function is in canonical form. See canonical.\n\n\n\n\n\nis_canonical(f::Union{ScalarQuadraticFunction, VectorQuadraticFunction})\n\nReturns a Bool indicating whether the function is in canonical form. See canonical.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.canonical","page":"API Reference","title":"MathOptInterface.Utilities.canonical","text":"canonical(\n    f::Union{\n        ScalarAffineFunction,\n        VectorAffineFunction,\n        ScalarQuadraticFunction,\n        VectorQuadraticFunction,\n    },\n)\n\nReturns the function in a canonical form, i.e.\n\nA term appear only once.\nThe coefficients are nonzero.\nThe terms appear in increasing order of variable where there the order of the variables is the order of their value.\nFor a AbstractVectorFunction, the terms are sorted in ascending order of output index.\n\nThe output of canonical can be assumed to be a copy of f, even for VectorOfVariables.\n\nExamples\n\nIf x (resp. y, z) is VariableIndex(1) (resp. 2, 3). The canonical representation of ScalarAffineFunction([y, x, z, x, z], [2, 1, 3, -2, -3], 5) is ScalarAffineFunction([x, y], [-1, 2], 5).\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.canonicalize!","page":"API Reference","title":"MathOptInterface.Utilities.canonicalize!","text":"canonicalize!(f::Union{ScalarAffineFunction, VectorAffineFunction})\n\nConvert a function to canonical form in-place, without allocating a copy to hold the result. See canonical.\n\n\n\n\n\ncanonicalize!(f::Union{ScalarQuadraticFunction, VectorQuadraticFunction})\n\nConvert a function to canonical form in-place, without allocating a copy to hold the result. See canonical.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following functions can be used to manipulate functions with basic algebra:","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.scalar_type\nUtilities.scalarize\nUtilities.eachscalar\nUtilities.promote_operation\nUtilities.operate\nUtilities.operate!\nUtilities.operate_output_index!\nUtilities.vectorize","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.scalar_type","page":"API Reference","title":"MathOptInterface.Utilities.scalar_type","text":"scalar_type(F::Type{<:MOI.AbstractVectorFunction})\n\nType of functions obtained by indexing objects obtained by calling eachscalar on functions of type F.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.scalarize","page":"API Reference","title":"MathOptInterface.Utilities.scalarize","text":"scalarize(func::MOI.VectorOfVariables, ignore_constants::Bool = false)\n\nReturns a vector of scalar functions making up the vector function in the form of a Vector{MOI.SingleVariable}.\n\nSee also eachscalar.\n\n\n\n\n\nscalarize(func::MOI.VectorAffineFunction{T}, ignore_constants::Bool = false)\n\nReturns a vector of scalar functions making up the vector function in the form of a Vector{MOI.ScalarAffineFunction{T}}.\n\nSee also eachscalar.\n\n\n\n\n\nscalarize(func::MOI.VectorQuadraticFunction{T}, ignore_constants::Bool = false)\n\nReturns a vector of scalar functions making up the vector function in the form of a Vector{MOI.ScalarQuadraticFunction{T}}.\n\nSee also eachscalar.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.eachscalar","page":"API Reference","title":"MathOptInterface.Utilities.eachscalar","text":"eachscalar(f::MOI.AbstractVectorFunction)\n\nReturns an iterator for the scalar components of the vector function.\n\nSee also scalarize.\n\n\n\n\n\neachscalar(f::MOI.AbstractVector)\n\nReturns an iterator for the scalar components of the vector.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.promote_operation","page":"API Reference","title":"MathOptInterface.Utilities.promote_operation","text":"promote_operation(\n    op::Function,\n    ::Type{T},\n    ArgsTypes::Type{<:Union{T, MOI.AbstractFunction}}...,\n) where {T}\n\nReturns the type of the MOI.AbstractFunction returned to the call operate(op, T, args...) where the types of the arguments args are ArgsTypes.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.operate","page":"API Reference","title":"MathOptInterface.Utilities.operate","text":"operate(\n    op::Function,\n    ::Type{T},\n    args::Union{T,MOI.AbstractFunction}...,\n)::MOI.AbstractFunction where {T}\n\nReturns an MOI.AbstractFunction representing the function resulting from the operation op(args...) on functions of coefficient type T. No argument can be modified.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.operate!","page":"API Reference","title":"MathOptInterface.Utilities.operate!","text":"operate!(\n    op::Function,\n    ::Type{T},\n    args::Union{T, MOI.AbstractFunction}...,\n)::MOI.AbstractFunction where {T}\n\nReturns an MOI.AbstractFunction representing the function resulting from the operation op(args...) on functions of coefficient type T. The first argument can be modified. The return type is the same than the method operate(op, T, args...) without !.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.operate_output_index!","page":"API Reference","title":"MathOptInterface.Utilities.operate_output_index!","text":"operate_output_index!(\n    op::Function,\n    ::Type{T},\n    output_index::Integer,\n    func::MOI.AbstractVectorFunction\n    args::Union{T, MOI.AbstractScalarFunction}...\n)::MOI.AbstractFunction where {T}\n\nReturns an MOI.AbstractVectorFunction where the function at output_index is the result of the operation op applied to the function at output_index of func and args. The functions at output index different to output_index are the same as the functions at the same output index in func. The first argument can be modified.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.vectorize","page":"API Reference","title":"MathOptInterface.Utilities.vectorize","text":"vectorize(x::AbstractVector{MOI.VariableIndex})\n\nReturns the vector of scalar affine functions in the form of a MOI.VectorAffineFunction{T}.\n\n\n\n\n\nvectorize(funcs::AbstractVector{MOI.ScalarAffineFunction{T}}) where T\n\nReturns the vector of scalar affine functions in the form of a MOI.VectorAffineFunction{T}.\n\n\n\n\n\nvectorize(funcs::AbstractVector{MOI.ScalarQuadraticFunction{T}}) where T\n\nReturns the vector of scalar quadratic functions in the form of a MOI.VectorQuadraticFunction{T}.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#Constraint-utilities","page":"API Reference","title":"Constraint utilities","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following utilities are available for moving the function constant to the set for scalar constraints:","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.shift_constant\nUtilities.supports_shift_constant\nUtilities.normalize_and_add_constraint\nUtilities.normalize_constant","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.shift_constant","page":"API Reference","title":"MathOptInterface.Utilities.shift_constant","text":"shift_constant(set::MOI.AbstractScalarSet, offset)\n\nReturns a new scalar set new_set such that func-in-set is equivalent to func + offset-in-new_set.\n\nOnly define this function if it makes sense to!\n\nUse supports_shift_constant to check if the set supports shifting:\n\nif supports_shift_constant(typeof(old_set))\n    new_set = shift_constant(old_set, offset)\n    f.constant = 0\n    add_constraint(model, f, new_set)\nelse\n    add_constraint(model, f, old_set)\nend\n\nSee also supports_shift_constant.\n\nExamples\n\nThe call shift_constant(MOI.Interval(-2, 3), 1) is equal to MOI.Interval(-1, 4).\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.supports_shift_constant","page":"API Reference","title":"MathOptInterface.Utilities.supports_shift_constant","text":"supports_shift_constant(::Type{S}) where {S<:MOI.AbstractSet}\n\nReturn true if shift_constant is defined for set S.\n\nSee also shift_constant.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.normalize_and_add_constraint","page":"API Reference","title":"MathOptInterface.Utilities.normalize_and_add_constraint","text":"normalize_and_add_constraint(\n    model::MOI.ModelLike,\n    func::MOI.AbstractScalarFunction,\n    set::MOI.AbstractScalarSet;\n    allow_modify_function::Bool = false,\n)\n\nAdds the scalar constraint obtained by moving the constant term in func to the set in model. If allow_modify_function is true then the function func can be modified.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.normalize_constant","page":"API Reference","title":"MathOptInterface.Utilities.normalize_constant","text":"normalize_constant(\n    func::MOI.AbstractScalarFunction,\n    set::MOI.AbstractScalarSet;\n    allow_modify_function::Bool = false,\n)\n\nReturn the func-in-set constraint in normalized form. That is, if func is MOI.ScalarQuadraticFunction or MOI.ScalarAffineFunction, the constant is moved to the set. If allow_modify_function is true then the function func can be modified.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following utility identifies those constraints imposing bounds on a given variable, and returns those bound values:","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.get_bounds","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.get_bounds","page":"API Reference","title":"MathOptInterface.Utilities.get_bounds","text":"get_bounds(model::MOI.ModelLike, ::Type{T}, x::MOI.VariableIndex)\n\nReturn a tuple (lb, ub) of type Tuple{T, T}, where lb and ub are lower  and upper bounds, respectively, imposed on x in model.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following utilities are useful when working with symmetric matrix cones.","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.is_diagonal_vectorized_index\nUtilities.side_dimension_for_vectorized_dimension","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.is_diagonal_vectorized_index","page":"API Reference","title":"MathOptInterface.Utilities.is_diagonal_vectorized_index","text":"is_diagonal_vectorized_index(index::Base.Integer)\n\nReturn whether index is the index of a diagonal element in a MOI.AbstractSymmetricMatrixSetTriangle set.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.side_dimension_for_vectorized_dimension","page":"API Reference","title":"MathOptInterface.Utilities.side_dimension_for_vectorized_dimension","text":"side_dimension_for_vectorized_dimension(n::Integer)\n\nReturn the dimension d such that MOI.dimension(MOI.PositiveSemidefiniteConeTriangle(d)) is n.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#DoubleDicts","page":"API Reference","title":"DoubleDicts","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.DoubleDicts.DoubleDict\nUtilities.DoubleDicts.DoubleDictInner\nUtilities.DoubleDicts.IndexDoubleDict\nUtilities.DoubleDicts.IndexDoubleDictInner","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.DoubleDicts.DoubleDict","page":"API Reference","title":"MathOptInterface.Utilities.DoubleDicts.DoubleDict","text":"DoubleDict{V}\n\nAn optimized dictionary to map MOI.ConstraintIndex to values of type V.\n\nWorks as a AbstractDict{MOI.ConstraintIndex,V} with minimal differences.\n\nIf V is also a MOI.ConstraintIndex, use IndexDoubleDict.\n\nNote that MOI.ConstraintIndex is not a concrete type, opposed to MOI.ConstraintIndex{MOI.VariableIndex, MOI.Integers}, which is a concrete type.\n\nWhen looping through multiple keys of the same Function-in-Set type, use\n\ninner = dict[F, S]\n\nto return a type-stable DoubleDictInner.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.DoubleDicts.DoubleDictInner","page":"API Reference","title":"MathOptInterface.Utilities.DoubleDicts.DoubleDictInner","text":"DoubleDictInner{F,S,V}\n\nA type stable inner dictionary of DoubleDict.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.DoubleDicts.IndexDoubleDict","page":"API Reference","title":"MathOptInterface.Utilities.DoubleDicts.IndexDoubleDict","text":"IndexDoubleDict\n\nA specialized version of [DoubleDict] in which the values are of type MOI.ConstraintIndex\n\nWhen looping through multiple keys of the same Function-in-Set type, use\n\ninner = dict[F, S]\n\nto return a type-stable IndexDoubleDictInner.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.DoubleDicts.IndexDoubleDictInner","page":"API Reference","title":"MathOptInterface.Utilities.DoubleDicts.IndexDoubleDictInner","text":"IndexDoubleDictInner{F,S}\n\nA type stable inner dictionary of IndexDoubleDict.\n\n\n\n\n\n","category":"type"},{"location":"reference/objectives/#ObjectiveAPI","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"reference/objectives/","page":"Objectives","title":"Objectives","text":"More information can be found in the Objectives section of the manual.","category":"page"},{"location":"reference/objectives/#Objective-functions","page":"Objectives","title":"Objective functions","text":"","category":"section"},{"location":"reference/objectives/","page":"Objectives","title":"Objectives","text":"@objective\nobjective_function\nset_objective_function\nset_objective_coefficient\nset_objective\nobjective_function_type\nobjective_function_string\nshow_objective_function_summary","category":"page"},{"location":"reference/objectives/#JuMP.@objective","page":"Objectives","title":"JuMP.@objective","text":"@objective(model::Model, sense, func)\n\nSet the objective sense to sense and objective function to func. The objective sense can be either Min, Max, MathOptInterface.MIN_SENSE, MathOptInterface.MAX_SENSE or MathOptInterface.FEASIBILITY_SENSE; see MathOptInterface.ObjectiveSense. In order to set the sense programmatically, i.e., when sense is a Julia variable whose value is the sense, one of the three MathOptInterface.ObjectiveSense values should be used. The function func can be a single JuMP variable, an affine expression of JuMP variables or a quadratic expression of JuMP variables.\n\nExamples\n\nTo minimize the value of the variable x, do as follows:\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @objective(model, Min, x)\nx\n\nTo maximize the value of the affine expression 2x - 1, do as follows:\n\njulia> @objective(model, Max, 2x - 1)\n2 x - 1\n\nTo set a quadratic objective and set the objective sense programmatically, do as follows:\n\njulia> sense = MIN_SENSE\nMIN_SENSE::OptimizationSense = 0\n\njulia> @objective(model, sense, x^2 - 2x + 1)\nx² - 2 x + 1\n\n\n\n\n\n","category":"macro"},{"location":"reference/objectives/#JuMP.objective_function","page":"Objectives","title":"JuMP.objective_function","text":"objective_function(model::Model,\n               T::Type{<:AbstractJuMPScalar}=objective_function_type(model))\n\nReturn an object of type T representing the objective function. Error if the objective is not convertible to type T.\n\nExamples\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @objective(model, Min, 2x + 1)\n2 x + 1\n\njulia> objective_function(model, AffExpr)\n2 x + 1\n\njulia> objective_function(model, QuadExpr)\n2 x + 1\n\njulia> typeof(objective_function(model, QuadExpr))\nGenericQuadExpr{Float64,VariableRef}\n\nWe see with the last two commands that even if the objective function is affine, as it is convertible to a quadratic function, it can be queried as a quadratic function and the result is quadratic.\n\nHowever, it is not convertible to a variable.\n\njulia> objective_function(model, VariableRef)\nERROR: InexactError: convert(MathOptInterface.VariableIndex, MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 1.0))\n[...]\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.set_objective_function","page":"Objectives","title":"JuMP.set_objective_function","text":"set_objective_function(\n    model::Model,\n    func::Union{AbstractJuMPScalar, MathOptInterface.AbstractScalarFunction})\n\nSets the objective function of the model to the given function. See set_objective_sense to set the objective sense. These are low-level functions; the recommended way to set the objective is with the @objective macro.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.set_objective_coefficient","page":"Objectives","title":"JuMP.set_objective_coefficient","text":"set_objective_coefficient(model::Model, variable::VariableRef, coefficient::Real)\n\nSet the linear objective coefficient associated with Variable to coefficient.\n\nNote: this function will throw an error if a nonlinear objective is set.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.set_objective","page":"Objectives","title":"JuMP.set_objective","text":"set_objective(model::AbstractModel, sense::MOI.OptimizationSense, func)\n\nThe functional equivalent of the @objective macro.\n\nSets the objective sense and objective function simultaneously, and is equivalent to:\n\nset_objective_sense(model, sense)\nset_objective_function(model, func)\n\nExamples\n\nmodel = Model()\n@variable(model, x)\nset_objective(model, MIN_SENSE, x)\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.objective_function_type","page":"Objectives","title":"JuMP.objective_function_type","text":"objective_function_type(model::Model)::AbstractJuMPScalar\n\nReturn the type of the objective function.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.objective_function_string","page":"Objectives","title":"JuMP.objective_function_string","text":"objective_function_string(print_mode, model::AbstractModel)::String\n\nReturn a String describing the objective function of the model.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.show_objective_function_summary","page":"Objectives","title":"JuMP.show_objective_function_summary","text":"show_objective_function_summary(io::IO, model::AbstractModel)\n\nWrite to io a summary of the objective function type.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#Objective-sense","page":"Objectives","title":"Objective sense","text":"","category":"section"},{"location":"reference/objectives/","page":"Objectives","title":"Objectives","text":"objective_sense\nset_objective_sense","category":"page"},{"location":"reference/objectives/#JuMP.objective_sense","page":"Objectives","title":"JuMP.objective_sense","text":"objective_sense(model::Model)::MOI.OptimizationSense\n\nReturn the objective sense.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.set_objective_sense","page":"Objectives","title":"JuMP.set_objective_sense","text":"set_objective_sense(model::Model, sense::MOI.OptimizationSense)\n\nSets the objective sense of the model to the given sense. See set_objective_function to set the objective function. These are low-level functions; the recommended way to set the objective is with the @objective macro.\n\n\n\n\n\n","category":"function"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"moi/manual/constraints/#Add-a-constraint","page":"Constraints","title":"Add a constraint","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Use add_constraint to add a single constraint.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> c = MOI.add_constraint(model, MOI.VectorOfVariables(x), MOI.Nonnegatives(2))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.Nonnegatives}(1)","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"add_constraint returns a ConstraintIndex type, which is used to refer to the added constraint in other calls.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Check if a ConstraintIndex is valid using is_valid.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> MOI.is_valid(model, c)\ntrue","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Use add_constraints to add a number of constraints of the same type.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> c = MOI.add_constraints(\n           model,\n           [x[1], x[2]],\n           [MOI.GreaterThan(0.0), MOI.GreaterThan(1.0)]\n       )\n2-element Vector{MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64}}}:\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64}}(1)\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64}}(2)","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"This time, a vector of ConstraintIndex are returned.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Use supports_constraint to check if the model supports adding a constraint type.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> MOI.supports_constraint(\n           model,\n           MOI.VariableIndex,\n           MOI.GreaterThan{Float64},\n       )\ntrue","category":"page"},{"location":"moi/manual/constraints/#Delete-a-constraint","page":"Constraints","title":"Delete a constraint","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Use delete to delete a constraint.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> MOI.delete(model, c)\n\njulia> MOI.is_valid(model, c)\nfalse","category":"page"},{"location":"moi/manual/constraints/#Constraint-attributes","page":"Constraints","title":"Constraint attributes","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"The following attributes are available for constraints:","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"ConstraintName\nConstraintPrimalStart\nConstraintDualStart\nConstraintPrimal\nConstraintDual\nConstraintBasisStatus\nConstraintFunction\nCanonicalConstraintFunction\nConstraintSet","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Get and set these attributes using get and set.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> MOI.set(model, MOI.ConstraintName(), c, \"con_c\")\n\njulia> MOI.get(model, MOI.ConstraintName(), c)\n\"con_c\"","category":"page"},{"location":"moi/manual/constraints/#Constraints-by-function-set-pairs","page":"Constraints","title":"Constraints by function-set pairs","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Below is a list of common constraint types and how they are represented as function-set pairs in MOI. In the notation below, x is a vector of decision variables, x_i is a scalar decision variable, alpha beta are scalar constants, a b are constant vectors, A is a constant matrix and mathbbR_+ (resp. mathbbR_-) is the set of nonnegative (resp. nonpositive) real numbers.","category":"page"},{"location":"moi/manual/constraints/#Linear-constraints","page":"Constraints","title":"Linear constraints","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Mathematical Constraint MOI Function MOI Set\na^Tx le beta ScalarAffineFunction LessThan\na^Tx ge alpha ScalarAffineFunction GreaterThan\na^Tx = beta ScalarAffineFunction EqualTo\nalpha le a^Tx le beta ScalarAffineFunction Interval\nx_i le beta VariableIndex LessThan\nx_i ge alpha VariableIndex GreaterThan\nx_i = beta VariableIndex EqualTo\nalpha le x_i le beta VariableIndex Interval\nAx + b in mathbbR_+^n VectorAffineFunction Nonnegatives\nAx + b in mathbbR_-^n VectorAffineFunction Nonpositives\nAx + b = 0 VectorAffineFunction Zeros","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"By convention, solvers are not expected to support nonzero constant terms in the ScalarAffineFunctions the first four rows above, because they are redundant with the parameters of the sets. For example, encode 2x + 1 le 2 as 2x le 1.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Constraints with VariableIndex in LessThan, GreaterThan, EqualTo, or Interval sets have a natural interpretation as variable bounds. As such, it is typically not natural to impose multiple lower- or upper-bounds on the same variable, and the solver interfaces will throw respectively LowerBoundAlreadySet or UpperBoundAlreadySet.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Moreover, adding two VariableIndex constraints on the same variable with the same set is impossible because they share the same index as it is the index of the variable, see ConstraintIndex.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"It is natural, however, to impose upper- and lower-bounds separately as two different constraints on a single variable. The difference between imposing bounds by using a single Interval constraint and by using separate LessThan and GreaterThan constraints is that the latter will allow the solver to return separate dual multipliers for the two bounds, while the former will allow the solver to return only a single dual for the interval constraint.","category":"page"},{"location":"moi/manual/constraints/#Conic-constraints","page":"Constraints","title":"Conic constraints","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Mathematical Constraint MOI Function MOI Set\nlVert Ax + brVert_2 le c^Tx + d VectorAffineFunction SecondOrderCone\ny ge lVert x rVert_2 VectorOfVariables SecondOrderCone\n2yz ge lVert x rVert_2^2 yz ge 0 VectorOfVariables RotatedSecondOrderCone\n(a_1^Tx + b_1a_2^Tx + b_2a_3^Tx + b_3) in mathcalE VectorAffineFunction ExponentialCone\nA(x) in mathcalS_+ VectorAffineFunction PositiveSemidefiniteConeTriangle\nB(x) in mathcalS_+ VectorAffineFunction PositiveSemidefiniteConeSquare\nx in mathcalS_+ VectorOfVariables PositiveSemidefiniteConeTriangle\nx in mathcalS_+ VectorOfVariables PositiveSemidefiniteConeSquare","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"where mathcalE is the exponential cone (see ExponentialCone), mathcalS_+ is the set of positive semidefinite symmetric matrices, A is an affine map that outputs symmetric matrices and B is an affine map that outputs square matrices.","category":"page"},{"location":"moi/manual/constraints/#Quadratic-constraints","page":"Constraints","title":"Quadratic constraints","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Mathematical Constraint MOI Function MOI Set\nx^TQx + a^Tx + b ge 0 ScalarQuadraticFunction GreaterThan\nx^TQx + a^Tx + b le 0 ScalarQuadraticFunction LessThan\nx^TQx + a^Tx + b = 0 ScalarQuadraticFunction EqualTo\nBilinear matrix inequality VectorQuadraticFunction PositiveSemidefiniteCone...","category":"page"},{"location":"moi/manual/constraints/#Discrete-and-logical-constraints","page":"Constraints","title":"Discrete and logical constraints","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Mathematical Constraint MOI Function MOI Set\nx_i in mathbbZ VariableIndex Integer\nx_i in 01 VariableIndex ZeroOne\nx_i in 0 cup lu VariableIndex Semicontinuous\nx_i in 0 cup ll+1ldotsu-1u VariableIndex Semiinteger\nAt most one component of x can be nonzero VectorOfVariables SOS1\nAt most two components of x can be nonzero, and if so they must be adjacent components VectorOfVariables SOS2\ny = 1 implies a^T x in S VectorAffineFunction Indicator","category":"page"},{"location":"moi/manual/constraints/#JuMP-mapping","page":"Constraints","title":"JuMP mapping","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"The following bullet points show examples of how JuMP constraints are translated into MOI function-set pairs:","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"@constraint(m, 2x + y <= 10) becomes ScalarAffineFunction-in-LessThan\n@constraint(m, 2x + y >= 10) becomes ScalarAffineFunction-in-GreaterThan\n@constraint(m, 2x + y == 10) becomes ScalarAffineFunction-in-EqualTo\n@constraint(m, 0 <= 2x + y <= 10) becomes ScalarAffineFunction-in-Interval\n@constraint(m, 2x + y in ArbitrarySet()) becomes ScalarAffineFunction-in-ArbitrarySet.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Variable bounds are handled in a similar fashion:","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"@variable(m, x <= 1) becomes VariableIndex-in-LessThan\n@variable(m, x >= 1) becomes VariableIndex-in-GreaterThan","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"One notable difference is that a variable with an upper and lower bound is translated into two constraints, rather than an interval. i.e.:","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"@variable(m, 0 <= x <= 1) becomes VariableIndex-in-LessThan and  VariableIndex-in-GreaterThan.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/linear/sudoku.jl\"","category":"page"},{"location":"tutorials/linear/sudoku/#Sudoku","page":"Sudoku","title":"Sudoku","text":"","category":"section"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Originally Contributed by: Iain Dunning","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Sudoku is a popular number puzzle. The goal is to place the digits 1,...,9 on a nine-by-nine grid, with some of the digits already filled in. Your solution must satisfy the following rules:","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"The numbers 1 to 9 must appear in each 3x3 square\nThe numbers 1 to 9 must appear in each row\nThe numbers 1 to 9 must appear in each column","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Here is a partially solved Sudoku problem:","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"(Image: Partially solved Sudoku)","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Solving a Sudoku isn't an optimization problem with an objective; its actually a feasibility problem: we wish to find a feasible solution that satisfies these rules. You can think of it as an optimization problem with an objective of 0.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"We can model this problem using 0-1 integer programming: a problem where all the decision variables are binary. We'll use JuMP to create the model, and then we can solve it with any integer programming solver.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"using JuMP\nusing GLPK","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"We will define a binary variable (a variable that is either 0 or 1) for each possible number in each possible cell. The meaning of each variable is as follows: x[i,j,k] = 1  if and only if cell (i,j) has number k, where i is the row and j is the column.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Create a model","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"sudoku = Model(GLPK.Optimizer)","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Create our variables","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"@variable(sudoku, x[i = 1:9, j = 1:9, k = 1:9], Bin)","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Now we can begin to add our constraints. We'll actually start with something obvious to us as humans, but what we need to enforce: that there can be only one number per cell.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"for i in 1:9  ## For each row\n    for j in 1:9  ## and each column\n        # Sum across all the possible digits. One and only one of the digits\n        # can be in this cell, so the sum must be equal to one.\n        @constraint(sudoku, sum(x[i, j, k] for k in 1:9) == 1)\n    end\nend","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Next we'll add the constraints for the rows and the columns. These constraints are all very similar, so much so that we can actually add them at the same time.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"for ind in 1:9  ## Each row, OR each column\n    for k in 1:9  ## Each digit\n        # Sum across columns (j) - row constraint\n        @constraint(sudoku, sum(x[ind, j, k] for j in 1:9) == 1)\n        # Sum across rows (i) - column constraint\n        @constraint(sudoku, sum(x[i, ind, k] for i in 1:9) == 1)\n    end\nend","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Finally, we have the to enforce the constraint that each digit appears once in each of the nine 3x3 sub-grids. Our strategy will be to index over the top-left corners of each 3x3 square with for loops, then sum over the squares.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"for i in 1:3:7\n    for j in 1:3:7\n        for k in 1:9\n            # i is the top left row, j is the top left column.\n            # We'll sum from i to i+2, e.g. i=4, r=4, 5, 6.\n            @constraint(\n                sudoku,\n                sum(x[r, c, k] for r in i:(i+2), c in j:(j+2)) == 1\n            )\n        end\n    end\nend","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"The final step is to add the initial solution as a set of constraints. We'll solve the problem that is in the picture at the start of the tutorial. We'll put a 0 if there is no digit in that location.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"The given digits","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"init_sol = [\n    5 3 0 0 7 0 0 0 0\n    6 0 0 1 9 5 0 0 0\n    0 9 8 0 0 0 0 6 0\n    8 0 0 0 6 0 0 0 3\n    4 0 0 8 0 3 0 0 1\n    7 0 0 0 2 0 0 0 6\n    0 6 0 0 0 0 2 8 0\n    0 0 0 4 1 9 0 0 5\n    0 0 0 0 8 0 0 7 9\n]\nfor i in 1:9\n    for j in 1:9\n        # If the space isn't empty\n        if init_sol[i, j] != 0\n            # Then the corresponding variable for that digit and location must\n            # be 1.\n            fix(x[i, j, init_sol[i, j]], 1; force = true)\n        end\n    end\nend","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"solve problem","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"optimize!(sudoku)","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Extract the values of x","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"x_val = value.(x)","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Create a matrix to store the solution","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"sol = zeros(Int, 9, 9)  # 9x9 matrix of integers\nfor i in 1:9\n    for j in 1:9\n        for k in 1:9\n            # Integer programs are solved as a series of linear programs so the\n            # values might not be precisely 0 and 1. We can round them to\n            # the nearest integer to make it easier.\n            if round(Int, x_val[i, j, k]) == 1\n                sol[i, j] = k\n            end\n        end\n    end\nend","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Display the solution","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"sol","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Which is the correct solution:","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"(Image: Solved Sudoku)","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/getting_started/performance_tips.jl\"","category":"page"},{"location":"tutorials/getting_started/performance_tips/#Performance-tips","page":"Performance tips","title":"Performance tips","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"By now you should have read the other \"getting started\" tutorials. You're almost ready to write your own models, but before you do so there are some important things to be aware of.","category":"page"},{"location":"tutorials/getting_started/performance_tips/#Read-the-Julia-performance-tips","page":"Performance tips","title":"Read the Julia performance tips","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"The first thing to do is read the Performance tips section of the Julia manual. The most important rule is to avoid global variables! This is particularly important if you're learning JuMP after using a language like MATLAB.","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"using JuMP  # hide\nusing GLPK  # hide","category":"page"},{"location":"tutorials/getting_started/performance_tips/#The-\"time-to-first-solve\"-issue","page":"Performance tips","title":"The \"time-to-first-solve\" issue","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Similar to the infamous time-to-first-plot plotting problem, JuMP suffers from time-to-first-solve latency. This latency occurs because the first time you call JuMP code in each session, Julia needs to compile a lot of code specific to your problem. This issue is actively being worked on, but there are a few things you can do to improve things.","category":"page"},{"location":"tutorials/getting_started/performance_tips/#Don't-call-JuMP-from-the-command-line","page":"Performance tips","title":"Don't call JuMP from the command line","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"In other languages, you might be used to a workflow like:","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"$ julia my_script.jl","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"This doesn't work for JuMP, because we have to pay the compilation latency every time you run the script. Instead, use one of the suggested workflows from the Julia documentation.","category":"page"},{"location":"tutorials/getting_started/performance_tips/#Disable-bridges-if-none-are-being-used","page":"Performance tips","title":"Disable bridges if none are being used","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"At present, the majority of the latency problems are caused by JuMP's bridging mechanism. If you only use constraints that are natively supported by the solver, you can disable bridges by passing add_bridges = false to Model.","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"model = Model(GLPK.Optimizer; add_bridges = false)","category":"page"},{"location":"tutorials/getting_started/performance_tips/#Use-PackageCompiler","page":"Performance tips","title":"Use PackageCompiler","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"As a final option, consider using PackageCompiler.jl to create a custom sysimage.","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"This is a good option if you have finished prototyping a model, and you now want to call it frequently from the command line without paying the compilation price.","category":"page"},{"location":"tutorials/getting_started/performance_tips/#Use-macros-to-build-expressions","page":"Performance tips","title":"Use macros to build expressions","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/#What","page":"Performance tips","title":"What","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Use JuMP's macros (or add_to_expression!) to build expressions. Avoid constructing expressions outside the macros.","category":"page"},{"location":"tutorials/getting_started/performance_tips/#Why","page":"Performance tips","title":"Why","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Constructing an expression outside the macro results in intermediate copies of the expression. For example,","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"x[1] + x[2] + x[3]","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"is equivalent to","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"a = x[1]\nb = a + x[2]\nc = b + x[3]","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Since we only care about c, the a and b expressions are not needed and constructing them slows the program down!","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"JuMP's macros rewrite the expressions to operate in-place and avoid these extra copies. Because they allocate less memory, they are faster, particularly for large expressions.","category":"page"},{"location":"tutorials/getting_started/performance_tips/#Example","page":"Performance tips","title":"Example","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"model = Model()\n@variable(model, x[1:3])","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Here's what happens if we construct the expression outside the macro:","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"@allocated x[1] + x[2] + x[3]","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"info: Info\nThe @allocated measures how many bytes were allocated during the evaluation of an expression. Fewer is better.","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"If we use the @expression macro, we get many fewer allocations:","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"@allocated @expression(model, x[1] + x[2] + x[3])","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/tutorials/example/#Solving-a-problem-using-MathOptInterface","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"In this tutorial we demonstrate how to use MathOptInterface to solve the binary-constrained knapsack problem:","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"beginaligned\nmax   c^top x       \nst   w^top x le C \n         x_i in 01quad forall i=1ldotsn\nendaligned","category":"page"},{"location":"moi/tutorials/example/#Required-packages","page":"Solving a problem using MathOptInterface","title":"Required packages","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"Load the MathOptInterface module and define the shorthand MOI:","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"using MathOptInterface\nconst MOI = MathOptInterface","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"As an optimizer, we choose GLPK:","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"using GLPK\noptimizer = GLPK.Optimizer()","category":"page"},{"location":"moi/tutorials/example/#Define-the-data","page":"Solving a problem using MathOptInterface","title":"Define the data","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"We first define the constants of the problem:","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> c = [1.0, 2.0, 3.0]\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n\njulia> w = [0.3, 0.5, 1.0]\n3-element Vector{Float64}:\n 0.3\n 0.5\n 1.0\n\njulia> C = 3.2\n3.2","category":"page"},{"location":"moi/tutorials/example/#Add-the-variables","page":"Solving a problem using MathOptInterface","title":"Add the variables","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> x = MOI.add_variables(optimizer, length(c));","category":"page"},{"location":"moi/tutorials/example/#set_objective_example","page":"Solving a problem using MathOptInterface","title":"Set the objective","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> MOI.set(\n           optimizer,\n           MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n           MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(c, x), 0.0),\n       );\n\njulia> MOI.set(optimizer, MOI.ObjectiveSense(), MOI.MAX_SENSE)","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"tip: Tip\nMOI.ScalarAffineTerm.(c, x) is a shortcut for [MOI.ScalarAffineTerm(c[i], x[i]) for i = 1:3]. This is Julia's broadcast syntax in action, and is used quite often throughout MOI.","category":"page"},{"location":"moi/tutorials/example/#Add-the-constraints","page":"Solving a problem using MathOptInterface","title":"Add the constraints","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"We add the knapsack constraint and integrality constraints:","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> MOI.add_constraint(\n           optimizer,\n           MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(w, x), 0.0),\n           MOI.LessThan(C),\n       );","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"Add integrality constraints:","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> for x_i in x\n           MOI.add_constraint(optimizer, x_i, MOI.ZeroOne())\n       end","category":"page"},{"location":"moi/tutorials/example/#Optimize-the-model","page":"Solving a problem using MathOptInterface","title":"Optimize the model","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> MOI.optimize!(optimizer)","category":"page"},{"location":"moi/tutorials/example/#Understand-why-the-solver-stopped","page":"Solving a problem using MathOptInterface","title":"Understand why the solver stopped","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"The first thing to check after optimization is why the solver stopped, e.g., did it stop because of a time limit or did it stop because it found the optimal solution?","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> MOI.get(optimizer, MOI.TerminationStatus())\nOPTIMAL::TerminationStatusCode = 1","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"Looks like we found an optimal solution!","category":"page"},{"location":"moi/tutorials/example/#Understand-what-solution-was-returned","page":"Solving a problem using MathOptInterface","title":"Understand what solution was returned","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> MOI.get(optimizer, MOI.ResultCount())\n1\n\njulia> MOI.get(optimizer, MOI.PrimalStatus())\nFEASIBLE_POINT::ResultStatusCode = 1\n\njulia> MOI.get(optimizer, MOI.DualStatus())\nNO_SOLUTION::ResultStatusCode = 0","category":"page"},{"location":"moi/tutorials/example/#Query-the-objective","page":"Solving a problem using MathOptInterface","title":"Query the objective","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"What is its objective value?","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> MOI.get(optimizer, MOI.ObjectiveValue())\n6.0","category":"page"},{"location":"moi/tutorials/example/#Query-the-primal-solution","page":"Solving a problem using MathOptInterface","title":"Query the primal solution","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"And what is the value of the variables x?","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> MOI.get(optimizer, MOI.VariablePrimal(), x)\n3-element Vector{Float64}:\n 1.0\n 1.0\n 1.0","category":"page"},{"location":"moi/submodules/Benchmarks/reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\n\n    # For compatibility with both Julia 1.0.5 and 1.5.2\n    # Upon the Julia LTS version becoming 1.6, these imports could be dropped,\n    # and all ScalarAffineTerm and VariableIndex instances in doctests below\n    # could be replaced with MOI.ScalarAffineTerm and MOI.VariableIndex\n    # Check discussion at PR 1184: https://github.com/jump-dev/MathOptInterface.jl/pull/1184#discussion_r515300914\n    import MathOptInterface.ScalarAffineTerm\n    import MathOptInterface.VariableIndex\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Benchmarks/reference/#Benchmarks","page":"API Reference","title":"Benchmarks","text":"","category":"section"},{"location":"moi/submodules/Benchmarks/reference/","page":"API Reference","title":"API Reference","text":"Functions to help benchmark the performance of solver wrappers. See The Benchmarks submodule for more details.","category":"page"},{"location":"moi/submodules/Benchmarks/reference/","page":"API Reference","title":"API Reference","text":"Benchmarks.suite\nBenchmarks.create_baseline\nBenchmarks.compare_against_baseline","category":"page"},{"location":"moi/submodules/Benchmarks/reference/#MathOptInterface.Benchmarks.suite","page":"API Reference","title":"MathOptInterface.Benchmarks.suite","text":"suite(\n    new_model::Function;\n    exclude::Vector{Regex} = Regex[]\n)\n\nCreate a suite of benchmarks. new_model should be a function that takes no arguments, and returns a new instance of the optimizer you wish to benchmark.\n\nUse exclude to exclude a subset of benchmarks.\n\nExamples\n\nsuite() do\n    GLPK.Optimizer()\nend\nsuite(exclude = [r\"delete\"]) do\n    Gurobi.Optimizer(OutputFlag=0)\nend\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Benchmarks/reference/#MathOptInterface.Benchmarks.create_baseline","page":"API Reference","title":"MathOptInterface.Benchmarks.create_baseline","text":"create_baseline(suite, name::String; directory::String = \"\"; kwargs...)\n\nRun all benchmarks in suite and save to files called name in directory.\n\nExtra kwargs are based to BenchmarkTools.run.\n\nExamples\n\nmy_suite = suite(() -> GLPK.Optimizer())\ncreate_baseline(my_suite, \"glpk_master\"; directory = \"/tmp\", verbose = true)\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Benchmarks/reference/#MathOptInterface.Benchmarks.compare_against_baseline","page":"API Reference","title":"MathOptInterface.Benchmarks.compare_against_baseline","text":"compare_against_baseline(\n    suite, name::String; directory::String = \"\",\n    report_filename::String = \"report.txt\"\n)\n\nRun all benchmarks in suite and compare against files called name in directory that were created by a call to create_baseline.\n\nA report summarizing the comparison is written to report_filename in directory.\n\nExtra kwargs are based to BenchmarkTools.run.\n\nExamples\n\nmy_suite = suite(() -> GLPK.Optimizer())\ncompare_against_baseline(\n    my_suite, \"glpk_master\"; directory = \"/tmp\", verbose = true\n)\n\n\n\n\n\n","category":"function"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/tutorials/bridging_constraint/#Implementing-a-constraint-bridge","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"This guide outlines the basic steps to create a new bridge from a constraint expressed in the formalism Function-in-Set.","category":"page"},{"location":"moi/tutorials/bridging_constraint/#Preliminaries","page":"Implementing a constraint bridge","title":"Preliminaries","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"First, decide on the set you want to bridge. Then, study its properties: the most important one is whether the set is scalar or vector, which impacts the dimensionality of the functions that can be used with the set.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"A scalar function only has one dimension. MOI defines three types of scalar functions: a variable (VariableIndex), an affine function (ScalarAffineFunction), or a quadratic function (ScalarQuadraticFunction).\nA vector function has several dimensions (at least one). MOI defines three types of vector functions: several variables (VectorOfVariables), an affine function (VectorAffineFunction), or a quadratic function (VectorQuadraticFunction). The main difference with scalar functions is that the order of dimensions can be very important: for instance, in an indicator constraint (Indicator), the first dimension indicates whether the constraint about the second dimension is active.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"To explain how to implement a bridge, we present the example of Bridges.Constraint.FlipSignBridge. This bridge maps <= (LessThan) constraints to >= (GreaterThan) constraints. This corresponds to reversing the sign of the inequality. We focus on scalar affine functions (we disregard the cases of a single variable or of quadratic functions). This example is a simplified version of the code included in MOI.","category":"page"},{"location":"moi/tutorials/bridging_constraint/#Four-mandatory-parts-in-a-constraint-bridge","page":"Implementing a constraint bridge","title":"Four mandatory parts in a constraint bridge","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"The first part of a constraint bridge is a new concrete subtype of Bridges.Constraint.AbstractBridge. This type must have fields to store all the new variables and constraints that the bridge will add. Typically, these types are parametrized by the type of the coefficients in the model.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"Then, three sets of functions must be defined:","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"Bridges.Constraint.bridge_constraint: this function implements the bridge and creates the required variables and constraints.\nsupports_constraint: these functions must return true when the combination of function and set is supported by the bridge. By default, the base implementation always returns false and the bridge does not have to provide this implementation.\nBridges.added_constrained_variable_types and Bridges.added_constraint_types: these functions return the types of variables and constraints that this bridge adds. They are used to compute the set of other bridges that are required to use the one you are defining, if need be.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"More functions can be implemented, for instance to retrieve properties from the bridge or deleting a bridged constraint.","category":"page"},{"location":"moi/tutorials/bridging_constraint/#.-Structure-for-the-bridge","page":"Implementing a constraint bridge","title":"1. Structure for the bridge","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"A typical struct behind a bridge depends on the type of the coefficients that are used for the model (typically Float64, but coefficients might also be integers or complex numbers).","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"This structure must hold a reference to all the variables and the constraints that are created as part of the bridge.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"The type of this structure is used throughout MOI as an identifier for the bridge. It is passed as argument to most functions related to bridges.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"The best practice is to have the name of this type end with Bridge.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"In our example, the bridge maps any ScalarAffineFunction{T}-in-LessThan{T} constraint to a single ScalarAffineFunction{T}-in-GreaterThan{T} constraint. The affine function has coefficients of type T. The bridge is parametrized with T, so that the constraint that the bridge creates also has coefficients of type T.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"struct SignBridge{T<:Number} <: Bridges.Constraint.AbstractBridge\n    constraint::ConstraintIndex{ScalarAffineFunction{T}, GreaterThan{T}}\nend","category":"page"},{"location":"moi/tutorials/bridging_constraint/#.-Bridge-creation","page":"Implementing a constraint bridge","title":"2. Bridge creation","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"The function Bridges.Constraint.bridge_constraint is called whenever the bridge is instantiated for a specific model, with the given function and set. The arguments to bridge_constraint are similar to add_constraint, with the exception of the first argument: it is the Type of the struct defined in the first step (for our example, Type{SignBridge{T}}).","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"bridge_constraint returns an instance of the struct defined in the first step. the first step.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"In our example, the bridge constraint could be defined as:","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"function Bridges.Constraint.bridge_constraint(\n    ::Type{SignBridge{T}}, # Bridge to use.\n    model::ModelLike, # Model to which the constraint is being added.\n    f::ScalarAffineFunction{T}, # Function to rewrite.\n    s::LessThan{T}, # Set to rewrite.\n) where {T}\n    # Create the variables and constraints required for the bridge.\n    con = add_constraint(model, -f, GreaterThan(-s.upper))\n\n    # Return an instance of the bridge type with a reference to all the\n    # variables and constraints that were created in this function.\n    return SignBridge(con)\nend","category":"page"},{"location":"moi/tutorials/bridging_constraint/#.-Supported-constraint-types","page":"Implementing a constraint bridge","title":"3. Supported constraint types","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"The function supports_constraint determines whether the bridge type supports a given combination of function and set.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"This function must closely match bridge_constraint, because it will not be called if supports_constraint returns false.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"function supports_constraint(\n    ::Type{SignBridge{T}}, # Bridge to use.\n    ::Type{ScalarAffineFunction{T}}, # Function to rewrite.\n    ::Type{LessThan{T}}, # Set to rewrite.\n) where {T}\n    # Do some computation to ensure that the constraint is supported.\n    # Typically, you can directly return true.\n    return true\nend","category":"page"},{"location":"moi/tutorials/bridging_constraint/#.-Metadata-about-the-bridge","page":"Implementing a constraint bridge","title":"4. Metadata about the bridge","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"To determine whether a bridge can be used, MOI uses a shortest-path algorithm that uses the variable types and the constraints that the bridge can create. This information is communicated from the bridge to MOI using the functions Bridges.added_constrained_variable_types and Bridges.added_constraint_types. Both return lists of tuples: either a list of 1-tuples containing the variable types (typically, ZeroOne or Integer) or a list of 2-tuples contained the functions and sets (like ScalarAffineFunction{T}-GreaterThan).","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"For our example, the bridge does not create any constrained variables, and only ScalarAffineFunction{T}-in-GreaterThan{T} constraints:","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"function Bridges.added_constrained_variable_types(::Type{SignBridge{T}}) where {T}\n    # The bridge does not create variables, return an empty list of tuples:\n    return Tuple{Type}[]\nend\n\nfunction Bridges.added_constraint_types(::Type{SignBridge{T}}) where {T}\n    return Tuple{Type,Type}[\n        # One element per F-in-S the bridge creates.\n        (ScalarAffineFunction{T}, GreaterThan{T}),\n    ]\nend","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"A bridge that creates binary variables would rather have this definition of added_constrained_variable_types:","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"function Bridges.added_constrained_variable_types(::Type{SomeBridge{T}}) where {T}\n    # The bridge only creates binary variables:\n    return Tuple{Type}[(ZeroOne,)]\nend","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"warning: Warning\nIf you declare the creation of constrained variables in added_constrained_variable_types, the corresponding constraint type VariableIndex must not be indicated in added_constraint_types. This would restrict the use of the bridge to solvers that can add such a constraint after the variable is created.More concretely, if you declare in added_constrained_variable_types that your bridge creates binary variables (ZeroOne), and if you never add such a constraint afterward (you do not call add_constraint(model, var, ZeroOne())), then you must not list (VariableIndex, ZeroOne) in added_constraint_types.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"Typically, the function Bridges.Constraint.concrete_bridge_type does not have to be defined for most bridges.","category":"page"},{"location":"moi/tutorials/bridging_constraint/#Bridge-registration","page":"Implementing a constraint bridge","title":"Bridge registration","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"For a bridge to be used by MOI, it must be known by MOI.","category":"page"},{"location":"moi/tutorials/bridging_constraint/#SingleBridgeOptimizer","page":"Implementing a constraint bridge","title":"SingleBridgeOptimizer","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"The first way to do so is to create a single-bridge optimizer. This type of optimizer wraps another optimizer and adds the possibility to use only one bridge. It is especially useful when unit testing bridges.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"It is common practice to use the same name as the type defined for the bridge (SignBridge, in our example) without the suffix Bridge.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"const Sign{T,OT<: ModelLike} =\n    SingleBridgeOptimizer{SignBridge{T}, OT}","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"In the context of unit tests, this bridge is used in conjunction with a Utilities.MockOptimizer:","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"mock = Utilities.MockOptimizer(\n    Utilities.UniversalFallback(Utilities.Model{Float64}()),\n)\nbridged_mock = Sign{Float64}(mock)","category":"page"},{"location":"moi/tutorials/bridging_constraint/#New-bridge-for-a-LazyBridgeOptimizer","page":"Implementing a constraint bridge","title":"New bridge for a LazyBridgeOptimizer","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"Typical user-facing models for MOI are based on Bridges.LazyBridgeOptimizer. For instance, this type of model is returned by Bridges.full_bridge_optimizer. These models can be added more bridges by using Bridges.add_bridge:","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"inner_optimizer = Utilities.Model{Float64}()\noptimizer = Bridges.full_bridge_optimizer(inner_optimizer, Float64)\nBridges.add_bridge(optimizer, SignBridge{Float64})","category":"page"},{"location":"moi/tutorials/bridging_constraint/#Bridge-improvements","page":"Implementing a constraint bridge","title":"Bridge improvements","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/#Attribute-retrieval","page":"Implementing a constraint bridge","title":"Attribute retrieval","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"Like models, bridges have attributes that can be retrieved using get and set. The most important ones are the number of variables and constraints, but also the lists of variables and constraints.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"In our example, we only have one constraint and only have to implement the NumberOfConstraints and ListOfConstraintIndices attributes:","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"function get(\n    ::SignBridge{T},\n    ::NumberOfConstraints{\n        ScalarAffineFunction{T},\n        GreaterThan{T},\n    },\n) where {T}\n    return 1\nend\n\nfunction get(\n    bridge::SignBridge{T},\n    ::ListOfConstraintIndices{\n        ScalarAffineFunction{T},\n        GreaterThan{T},\n    },\n) where {T}\n    return [bridge.constraint]\nend","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"You must implement one such pair of functions for each type of constraint the bridge adds to the model.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"warning: Warning\nAvoid returning a list from the bridge object without copying it. Users must be able to change the contents of the returned list without altering the bridge object.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"For variables, the situation is simpler. If your bridge creates new variables, you must implement the NumberOfVariables and ListOfVariableIndices attributes. However, these attributes do not have parameters, unlike their constraint counterparts. Only two functions suffice:","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"function get(\n    ::SignBridge{T},\n    ::NumberOfVariables,\n) where {T}\n    return 0\nend\n\nfunction get(\n    ::SignBridge{T},\n    ::ListOfVariableIndices,\n) where {T}\n    return VariableIndex[]\nend","category":"page"},{"location":"moi/tutorials/bridging_constraint/#Model-modifications","page":"Implementing a constraint bridge","title":"Model modifications","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"To avoid copying the model when the user request to change a constraint, MOI provides modify. Bridges can also implement this API to allow certain changes, such as coefficient changes.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"In our case, a modification of a coefficient in the original constraint (i.e. replacing the value of the coefficient of a variable in the affine function) must be transmitted to the constraint created by the bridge, but with a sign change.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"function modify(\n    model::ModelLike,\n    bridge::SignBridge,\n    change::ScalarCoefficientChange,\n)\n    modify(\n        model,\n        bridge.constraint,\n        ScalarCoefficientChange(change.variable, -change.new_coefficient),\n    )\n    return\nend","category":"page"},{"location":"moi/tutorials/bridging_constraint/#Bridge-deletion","page":"Implementing a constraint bridge","title":"Bridge deletion","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"When a bridge is deleted, the constraints it added must be deleted too.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"function delete(model::ModelLike, bridge::SignBridge)\n    delete(model, bridge.constraint)\n    return\nend","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/tutorials/implementing/#Implementing-a-solver-interface","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"This guide outlines the basic steps to implement an interface to MathOptInterface for a new solver.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"danger: Danger\nImplementing an interface to MathOptInterface for a new solver is a lot of work. Before starting, we recommend that you join the Developer chatroom and explain a little bit about the solver you are wrapping. If you have questions that are not answered by this guide, please ask them in the Developer chatroom so we can improve this guide!","category":"page"},{"location":"moi/tutorials/implementing/#A-note-on-the-API","page":"Implementing a solver interface","title":"A note on the API","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The API of MathOptInterface is large and varied. In order to support the diversity of solvers and use-cases, we make heavy use of duck-typing. That is, solvers are not expected to implement the full API, nor is there a well-defined minimal subset of what must be implemented. Instead, you should implement the API as necessary in order to make the solver function as you require.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The main reason for using duck-typing is that solvers work in different ways and target different use-cases.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For example:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Some solvers support incremental problem construction, support modification after a solve, and have native support for things like variable names.\nOther solvers are \"one-shot\" solvers that require all of the problem data to construct and solve the problem in a single function call. They do not support modification or things like variable names.\nOther \"solvers\" are not solvers at all, but things like file readers. These may only support functions like read_from_file, and may not even support the ability to add variables or constraints directly!\nFinally, some \"solvers\" are layers which take a problem as input, transform it according to some rules, and pass the transformed problem to an inner solver.","category":"page"},{"location":"moi/tutorials/implementing/#Preliminaries","page":"Implementing a solver interface","title":"Preliminaries","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Before starting on your wrapper, you should do some background research and make the solver accessible via Julia.","category":"page"},{"location":"moi/tutorials/implementing/#Decide-if-MathOptInterface-is-right-for-you","page":"Implementing a solver interface","title":"Decide if MathOptInterface is right for you","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The first step in writing a wrapper is to decide whether implementing an interface is the right thing to do.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"MathOptInterface is an abstraction layer for unifying constrained mathematical optimization solvers. If your solver doesn't fit in the category, i.e., it implements a derivative-free algorithm for unconstrained objective functions, MathOptInterface may not be the right tool for the job.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nIf you're not sure whether you should write an interface, ask in the Developer chatroom.","category":"page"},{"location":"moi/tutorials/implementing/#Find-a-similar-solver-already-wrapped","page":"Implementing a solver interface","title":"Find a similar solver already wrapped","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The next step is to find (if possible) a similar solver that is already wrapped. Although not strictly necessary, this will be a good place to look for inspiration when implementing your wrapper.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The JuMP documentation has a good list of solvers, along with the problem classes they support.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nIf you're not sure which solver is most similar, ask in the Developer chatroom.","category":"page"},{"location":"moi/tutorials/implementing/#Create-a-low-level-interface","page":"Implementing a solver interface","title":"Create a low-level interface","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Before writing a MathOptInterface wrapper, you first need to be able to call the solver from Julia.","category":"page"},{"location":"moi/tutorials/implementing/#Wrapping-solvers-written-in-Julia","page":"Implementing a solver interface","title":"Wrapping solvers written in Julia","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If your solver is written in Julia, there's nothing to do here! Go to the next section.","category":"page"},{"location":"moi/tutorials/implementing/#Wrapping-solvers-written-in-C","page":"Implementing a solver interface","title":"Wrapping solvers written in C","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Julia is well suited to wrapping solvers written in C.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"info: Info\nThis is not true for C++. If you have a solver written in C++, first write a C interface, then wrap the C interface.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Before writing a MathOptInterface wrapper, there are a few extra steps.","category":"page"},{"location":"moi/tutorials/implementing/#Create-a-JLL","page":"Implementing a solver interface","title":"Create a JLL","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If the C code is publicly available under an open-source license, create a JLL package via Yggdrasil. The easiest way to do this is to copy an existing solver. Good examples to follow are the COIN-OR solvers.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"warning: Warning\nBuilding the solver via Yggdrasil is non-trivial. Please ask the Developer chatroom for help.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If the code is commercial or not publicly available, the user will need to manually install the solver. See Gurobi.jl or CPLEX.jl for examples of how to structure this.","category":"page"},{"location":"moi/tutorials/implementing/#implement_clang","page":"Implementing a solver interface","title":"Use Clang.jl to wrap the C API","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The next step is to use Clang.jl to automatically wrap the C API. The easiest way to do this is to follow an example. Good examples to follow are Cbc.jl and HiGHS.jl.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Sometimes, you will need to make manual modifications to the resulting files.","category":"page"},{"location":"moi/tutorials/implementing/#Solvers-written-in-other-languages","page":"Implementing a solver interface","title":"Solvers written in other languages","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Ask the Developer chatroom for advice. You may be able to use one of the JuliaInterop packages to call out to the solver.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For example, SeDuMi.jl uses MATLAB.jl to call the SeDuMi solver written in MATLAB.","category":"page"},{"location":"moi/tutorials/implementing/#Structuring-the-package","page":"Implementing a solver interface","title":"Structuring the package","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Structure your wrapper as a Julia package. Consult the Julia documentation if you haven't done this before.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"MOI solver interfaces may be in the same package as the solver itself (either the C wrapper if the solver is accessible through C, or the Julia code if the solver is written in Julia, for example), or in a separate package which depends on the solver package.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"note: Note\nThe JuMP core contributors request that you do not use \"JuMP\" in the name of your package without prior consent.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Your package should have the following structure:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"/.github\n    /workflows\n        ci.yml\n        format_check.yml\n        TagBot.yml\n/gen\n    gen.jl  # Code to wrap the C API\n/src\n    NewSolver.jl\n    /gen\n        libnewsolver_api.jl\n        libnewsolver_common.jl\n    /MOI_wrapper\n        MOI_wrapper.jl\n        other_files.jl\n/test\n    runtests.jl\n    /MOI_wrapper\n        MOI_wrapper.jl\n.gitignore\n.JuliaFormatter.toml\nREADME.md\nLICENSE.md\nProject.toml","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The /.github folder contains the scripts for GitHub actions. The easiest way to write these is to copy the ones from an existing solver.\nThe /gen and /src/gen folders are only needed if you are wrapping a solver written in C.\nThe /src/MOI_wrapper folder contains the Julia code for the MOI wrapper.\nThe /test folder contains code for testing your package. See Setup tests for more information.\nThe .JuliaFormatter.toml and .github/workflows/format_check.yml enforce code formatting using JuliaFormatter.jl. Check existing solvers or JuMP.jl for details.","category":"page"},{"location":"moi/tutorials/implementing/#Documentation","page":"Implementing a solver interface","title":"Documentation","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Your package must include documentation explaining how to use the package. The easiest approach is to include documentation in your README.md. A more involved option is to use Documenter.jl.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Examples of packages with README-based documentation include:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Cbc.jl\nHiGHS.jl\nSCS.jl","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Examples of packages with Documenter-based documentation include:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Alpine.jl\nCOSMO.jl\nJuniper.jl","category":"page"},{"location":"moi/tutorials/implementing/#Setup-tests","page":"Implementing a solver interface","title":"Setup tests","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The best way to implement an interface to MathOptInterface is via test-driven development.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The MOI.Test submodule contains a large test suite to help check that you have implemented things correctly.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Follow the guide How to test a solver to set up the tests for your package.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nRun the tests frequently when developing. However, at the start there is going to be a lot of errors! Start by excluding large classes of tests (e.g., exclude = [\"test_basic_\", \"test_model_\"], implement any missing methods until the tests pass, then remove an exclusion and repeat.","category":"page"},{"location":"moi/tutorials/implementing/#Initial-code","page":"Implementing a solver interface","title":"Initial code","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"By this point, you should have a package setup with tests, formatting, and access to the underlying solver. Now it's time to start writing the wrapper.","category":"page"},{"location":"moi/tutorials/implementing/#The-Optimizer-object","page":"Implementing a solver interface","title":"The Optimizer object","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The first object to create is a subtype of AbstractOptimizer. This type is going to store everything related to the problem.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"By convention, these optimizers should not be exported and should be named PackageName.Optimizer.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"import MathOptInterface\nconst MOI = MathOptInterface\n\nstruct Optimizer <: MOI.AbstractOptimizer\n    # Fields go here\nend","category":"page"},{"location":"moi/tutorials/implementing/#Optimizer-objects-for-C-solvers","page":"Implementing a solver interface","title":"Optimizer objects for C solvers","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"warning: Warning\nThis section is important if you wrap a solver written in C.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Wrapping a solver written in C will require the use of pointers, and for you to manually free the solver's memory when the Optimizer is garbage collected by Julia.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Never pass a pointer directly to a Julia ccall function.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Instead, store the pointer as a field in your Optimizer, and implement Base.cconvert and Base.unsafe_convert. Then you can pass Optimizer to any ccall function that expects the pointer.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"In addition, make sure you implement a finalizer for each model you create.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If newsolver_createProblem() is the low-level function that creates the problem pointer in C, and newsolver_freeProblem(::Ptr{Cvoid}) is the low-level function that frees memory associated with the pointer, your Optimizer() function should look like this:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"struct Optimizer <: MOI.AbstractOptimizer\n    ptr::Ptr{Cvoid}\n\n    function Optimizer()\n        ptr = newsolver_createProblem()\n        model = Optimizer(ptr)\n        finalizer(model) do m\n            newsolver_freeProblem(m)\n            return\n        end\n        return model\n    end\nend\n\nBase.cconvert(::Type{Ptr{Cvoid}}, model::Optimizer) = model\nBase.unsafe_convert(::Type{Ptr{Cvoid}}, model::Optimizer) = model.ptr","category":"page"},{"location":"moi/tutorials/implementing/#Implement-methods-for-Optimizer","page":"Implementing a solver interface","title":"Implement methods for Optimizer","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"All Optimizers must implement the following methods:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"empty!\nis_empty\noptimize!","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Other methods, detailed below, are optional or depend on how you implement the interface.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nFor this and all future methods, read the docstrings to understand what each method does, what it expects as input, and what it produces as output. If it isn't clear, let us know and we will improve the docstrings! It is also very helpful to look at an existing wrapper for a similar solver.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"You should also implement Base.show(::IO, ::Optimizer) to print a nice string when someone prints your model. For example","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"function Base.show(io::IO, model::Optimizer)\n    return print(io, \"NewSolver with the pointer $(model.ptr)\")\nend","category":"page"},{"location":"moi/tutorials/implementing/#Implement-attributes","page":"Implementing a solver interface","title":"Implement attributes","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"MathOptInterface uses attributes to manage different aspects of the problem.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For each attribute","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"get gets the current value of the attribute\nset sets a new value of the attribute. Not all attributes can be set. For example, the user can't modify the SolverName.\nsupports returns a Bool indicating whether the solver supports the attribute.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"info: Info\nUse attribute_value_type to check the value expected by a given attribute. You should make sure that your get function correctly infers to this type (or a subtype of it).","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Each column in the table indicates whether you need to implement the particular method for each attribute.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Attribute get set supports\nSolverName Yes No No\nSolverVersion Yes No No\nRawSolver Yes No No\nName Yes Yes Yes\nSilent Yes Yes Yes\nTimeLimitSec Yes Yes Yes\nRawOptimizerAttribute Yes Yes Yes\nNumberOfThreads Yes Yes Yes","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For example:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"function MOI.get(model::Optimizer, ::MOI.Silent)\n    return # true if MOI.Silent is set\nend\n\nfunction MOI.set(model::Optimizer, ::MOI.Silent, v::Bool)\n    if v\n        # Set a parameter to turn off printing\n    else\n        # Restore the default printing\n    end\n    return\nend\n\nMOI.supports(::Optimizer, ::MOI.Silent) = true","category":"page"},{"location":"moi/tutorials/implementing/#Define-supports_constraint","page":"Implementing a solver interface","title":"Define supports_constraint","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The next step is to define which constraints and objective functions you plan to support.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For each function-set constraint pair, define supports_constraint:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"function MOI.supports_constraint(\n    ::Optimizer,\n    ::Type{MOI.VariableIndex},\n    ::Type{MOI.ZeroOne},\n)\n    return true\nend","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"To make this easier, you may want to use Unions:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"function MOI.supports_constraint(\n    ::Optimizer,\n    ::Type{MOI.VariableIndex},\n    ::Type{<:Union{MOI.LessThan,MOI.GreaterThan,MOI.EqualTo}},\n)\n    return true\nend","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nOnly support a constraint if your solver has native support for it.","category":"page"},{"location":"moi/tutorials/implementing/#The-big-decision:-copy-to-or-incremental-modifications?","page":"Implementing a solver interface","title":"The big decision: copy-to or incremental modifications?","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Now you need to decide whether to support incremental modification or not.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Incremental modification means that the user can add variables and constraints one-by-one without needing to rebuild the entire problem, and they can modify the problem data after an optimize! call. Supporting incremental modification means implementing functions like add_variable and add_constraint.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The alternative is to accept the problem data in a single copy_to function call, afterwhich it cannot be modified. Because copy_to sees all of the data at once, it can typically call a more efficient function to load data into the underlying solver.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Good examples of solvers supporting incremental modification are MILP solvers like GLPK.jl and Gurobi.jl. Examples of copy_to solvers are AmplNLWriter.jl and SCS.jl","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"It is possible to implement both approaches, but you should probably start with one for simplicity.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nOnly support incremental modification if your solver has native support for it.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"In general, supporting incremental modification is more work, and it usually requires some extra book-keeping. However, it provides a more efficient interface to the solver if the problem is going to be resolved multiple times with small modifications. Moreover, once you've implemented incremental modification, it's usually not much extra work to add a copy_to interface. The converse is not true.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nIf this is your first time writing an interface, start with copy_to.","category":"page"},{"location":"moi/tutorials/implementing/#The-copy_to-interface","page":"Implementing a solver interface","title":"The copy_to interface","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"To implement the copy_to interface, implement the following function:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"copy_to","category":"page"},{"location":"moi/tutorials/implementing/#The-incremental-interface","page":"Implementing a solver interface","title":"The incremental interface","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"warning: Warning\nWriting this interface is a lot of work. The easiest way is to consult the source code of a similar solver!","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"To implement the incremental interface, implement the following functions:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"add_variable\nadd_variables\nadd_constraint\nadd_constraints\nis_valid\ndelete","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"info: Info\nSolvers do not have to support AbstractScalarFunction in GreaterThan, LessThan, EqualTo, or Interval with a nonzero constant in the function. Throw ScalarFunctionConstantNotZero if the function constant is not zero.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"In addition, you should implement the following model attributes:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Attribute get set supports\nListOfModelAttributesSet Yes No No\nObjectiveFunctionType Yes No No\nObjectiveFunction Yes Yes Yes\nObjectiveSense Yes Yes Yes\nName Yes Yes Yes","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Variable-related attributes:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Attribute get set supports\nListOfVariableAttributesSet Yes No No\nNumberOfVariables Yes No No\nListOfVariableIndices Yes No No","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Constraint-related attributes:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Attribute get set supports\nListOfConstraintAttributesSet Yes No No\nNumberOfConstraints Yes No No\nListOfConstraintTypesPresent Yes No No\nConstraintFunction Yes Yes No\nConstraintSet Yes Yes No","category":"page"},{"location":"moi/tutorials/implementing/#Modifications","page":"Implementing a solver interface","title":"Modifications","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If your solver supports modifying data in-place, implement modify for the following AbstractModifications:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"ScalarConstantChange\nScalarCoefficientChange\nVectorConstantChange\nMultirowChange","category":"page"},{"location":"moi/tutorials/implementing/#Variables-constrained-on-creation","page":"Implementing a solver interface","title":"Variables constrained on creation","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Some solvers require variables be associated with a set when they are created. This conflicts with the incremental modification approach, since you cannot first add a free variable and then constrain it to the set.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If this is the case, implement:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"add_constrained_variable\nadd_constrained_variables\nsupports_add_constrained_variables","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"By default, MathOptInterface assumes solvers support free variables. If your solver does not support free variables, define:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"MOI.supports_add_constrained_variables(::Optimizer, ::Type{Reals}) = false","category":"page"},{"location":"moi/tutorials/implementing/#Incremental-and-copy_to","page":"Implementing a solver interface","title":"Incremental and copy_to","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If you implement the incremental interface, you have the option of also implementing copy_to.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If you don't want to implement copy_to, e.g., because the solver has no API for building the problem in a single function call, define the following fallback:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"MOI.supports_incremental_interface(::Optimizer) = true\n\nfunction MOI.copy_to(dest::Optimizer, src::MOI.ModelLike)\n    return MOI.Utilities.default_copy_to(dest, src)\nend","category":"page"},{"location":"moi/tutorials/implementing/#implement_names","page":"Implementing a solver interface","title":"Names","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Regardless of which interface you implement, you have the option of implementing the Name attribute for variables and constraints:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Attribute get set supports\nVariableName Yes Yes Yes\nConstraintName Yes Yes Yes","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If you implement names, you must also implement the following three methods:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"function MOI.get(model::Optimizer, ::Type{MOI.VariableIndex}, name::String)\n    return # The variable named `name`.\nend\n\nfunction MOI.get(model::Optimizer, ::Type{MOI.ConstraintIndex}, name::String)\n    return # The constraint any type named `name`.\nend\n\nfunction MOI.get(\n    model::Optimizer,\n    ::Type{MOI.ConstraintIndex{F,S}},\n    name::String,\n) where {F,S}\n    return # The constraint of type F-in-S named `name`.\nend","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"These methods have the following rules:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If there is no variable or constraint with the name, return nothing\nIf there is a single variable or constraint with that name, return the variable or constraint\nIf there are multiple variables or constraints with the name, throw an error.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"warning: Warning\nYou should not implement ConstraintName for VariableIndex constraints. If you implement ConstraintName for other constraints, you can add the following two methods to disable ConstraintName for VariableIndex constraints.function MOI.supports(\n    ::Optimizer,\n    ::MOI.ConstraintName,\n    ::Type{<:MOI.ConstraintIndex{MOI.VariableIndex,<:MOI.AbstractScalarSet}},\n)\n    return throw(MOI.VariableIndexConstraintNameError())\nend\nfunction MOI.set(\n    ::Optimizer,\n    ::MOI.ConstraintName,\n    ::MOI.ConstraintIndex{MOI.VariableIndex,<:MOI.AbstractScalarSet},\n    ::String,\n)\n    return throw(MOI.VariableIndexConstraintNameError())\nend","category":"page"},{"location":"moi/tutorials/implementing/#Solutions","page":"Implementing a solver interface","title":"Solutions","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Implement optimize! to solve the model:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"optimize!","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"All Optimizers must implement the following attributes:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"DualStatus\nPrimalStatus\nRawStatusString\nResultCount\nTerminationStatus","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"info: Info\nYou only need to implement get for solution attributes. Don't implement set or supports.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"note: Note\nSolver wrappers should document how the low-level statuses map to the MOI statuses. Statuses like NEARLY_FEASIBLE_POINT and INFEASIBLE_POINT, are designed to be used when the solver explicitly indicates that relaxed tolerances are satisfied or the returned point is infeasible, respectively.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"You should also implement the following attributes:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"ObjectiveValue\nSolveTimeSec\nVariablePrimal","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nAttributes like VariablePrimal and ObjectiveValue are indexed by the result count. Use MOI.check_result_index_bounds(model, attr) to throw an error if the attribute is not available.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If your solver returns dual solutions, implement:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"ConstraintDual\nDualObjectiveValue","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For integer solvers, implement:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"ObjectiveBound\nRelativeGap","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If applicable, implement:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"SimplexIterations\nBarrierIterations\nNodeCount","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If your solver uses the Simplex method, implement:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"ConstraintBasisStatus","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If your solver accepts primal or dual warm-starts, implement:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"VariablePrimalStart\nConstraintDualStart","category":"page"},{"location":"moi/tutorials/implementing/#Other-tips","page":"Implementing a solver interface","title":"Other tips","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Here are some other points to be aware of when writing your wrapper.","category":"page"},{"location":"moi/tutorials/implementing/#Unsupported-constraints-at-runtime","page":"Implementing a solver interface","title":"Unsupported constraints at runtime","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"In some cases, your solver may support a particular type of constraint (e.g., quadratic constraints), but only if the data meets some condition (e.g., it is convex).","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"In this case, declare that you support the constraint, and throw AddConstraintNotAllowed.","category":"page"},{"location":"moi/tutorials/implementing/#Dealing-with-multiple-variable-bounds","page":"Implementing a solver interface","title":"Dealing with multiple variable bounds","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"MathOptInterface uses VariableIndex constraints to represent variable bounds. Defining multiple variable bounds on a single variable is not allowed.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Throw LowerBoundAlreadySet or UpperBoundAlreadySet if the user adds a constraint that results in multiple bounds.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Only throw if the constraints conflict. It is okay to add VariableIndex-in-GreaterThan and then VariableIndex-in-LessThan, but not VariableIndex-in-Interval and then VariableIndex-in-LessThan,","category":"page"},{"location":"moi/tutorials/implementing/#Expect-duplicate-coefficients","page":"Implementing a solver interface","title":"Expect duplicate coefficients","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Solvers must expect that functions such as ScalarAffineFunction and VectorQuadraticFunction may contain duplicate coefficents.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For example, ScalarAffineFunction([ScalarAffineTerm(x, 1), ScalarAffineTerm(x, 1)], 0.0).","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Use Utilities.canonical to return a new function with the duplicate coefficients aggregated together.","category":"page"},{"location":"moi/tutorials/implementing/#Don't-modify-user-data","page":"Implementing a solver interface","title":"Don't modify user-data","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"All data passed to the solver must be copied immediately to internal data structures. Solvers may not modify any input vectors and must assume that input vectors will not be modified by users in the future.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"This applies, for example, to the terms vector in ScalarAffineFunction. Vectors returned to the user, e.g., via ObjectiveFunction or ConstraintFunction attributes, must not be modified by the solver afterwards. The in-place version of get! can be used by users to avoid extra copies in this case.","category":"page"},{"location":"moi/tutorials/implementing/#Column-Generation","page":"Implementing a solver interface","title":"Column Generation","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"There is no special interface for column generation. If the solver has a special API for setting coefficients in existing constraints when adding a new variable, it is possible to queue modifications and new variables and then call the solver's API once all of the new coefficients are known.","category":"page"},{"location":"moi/tutorials/implementing/#Solver-specific-attributes","page":"Implementing a solver interface","title":"Solver-specific attributes","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"You don't need to restrict yourself to the attributes defined in the MathOptInterface.jl package.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Solver-specific attributes should be specified by creating an appropriate subtype of AbstractModelAttribute, AbstractOptimizerAttribute, AbstractVariableAttribute, or AbstractConstraintAttribute.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For example, Gurobi.jl adds attributes for multiobjective optimization by defining:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"struct NumberOfObjectives <: MOI.AbstractModelAttribute end\n\nfunction MOI.set(model::Optimizer, ::NumberOfObjectives, n::Integer)\n    # Code to set NumberOfObjectives\n    return\nend\n\nfunction MOI.get(model::Optimizer, ::NumberOfObjectives)\n    n = # Code to get NumberOfObjectives\n    return n\nend","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Then, the user can write:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"model = Gurobi.Optimizer()\nMOI.set(model, Gurobi.NumberofObjectives(), 3)","category":"page"},{"location":"moi/#moi_documentation","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"warning: Warning\nThis documentation in this section is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v0.10.7. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/#What-is-MathOptInterface?","page":"Introduction","title":"What is MathOptInterface?","text":"","category":"section"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"MathOptInterface.jl (MOI) is an abstraction layer designed to provide a unified interface to mathematical optimization solvers so that users do not need to understand multiple solver-specific APIs.","category":"page"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"tip: Tip\nThis documentation is aimed at developers writing software interfaces to solvers and modeling languages using the MathOptInterface API. If you are a user interested in solving optimization problems, we encourage you instead to use MOI through a higher-level modeling interface like JuMP or Convex.jl.","category":"page"},{"location":"moi/#How-the-documentation-is-structured","page":"Introduction","title":"How the documentation is structured","text":"","category":"section"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"Having a high-level overview of how this documentation is structured will help you know where to look for certain things.","category":"page"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"The Tutorials section contains articles on how to use and implement the MathOptInteraface API. Look here if you want to write a model in MOI, or write an interface to a new solver.\nThe Manual contains short code-snippets that explain how to use the MOI API. Look here for more details on particular areas of MOI.\nThe Background section contains articles on the theory behind MathOptInterface. Look here if you want to understand why, rather than how.\nThe API Reference contains a complete list of functions and types that comprise the MOI API. Look here is you want to know how to use (or implement) a particular function.\nThe Submodules section contains stand-alone documentation for each of the submodules within MOI. These submodules are not required to interface a solver with MOI, but they make the job much easier.","category":"page"},{"location":"moi/#Citing-MathOptInterface","page":"Introduction","title":"Citing MathOptInterface","text":"","category":"section"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"A paper describing the design and features of MathOptInterface is available on arXiv.","category":"page"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"If you find MathOptInterface useful in your work, we kindly request that you cite the following paper:","category":"page"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"@article{legat2021mathoptinterface,\n    title={{MathOptInterface}: a data structure for mathematical optimization problems},\n    author={Legat, Beno{\\^\\i}t and Dowson, Oscar and Garcia, Joaquim Dias and Lubin, Miles},\n    journal={INFORMS Journal on Computing},\n    year={2021},\n    doi={10.1287/ijoc.2021.1067},\n    publisher={INFORMS}\n}","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/modification/#Problem-modification","page":"Problem modification","title":"Problem modification","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"In addition to adding and deleting constraints and variables, MathOptInterface supports modifying, in-place, coefficients in the constraints and the objective function of a model.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"These modifications can be grouped into two categories:","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"modifications which replace the set of function of a constraint with a new set or function\nmodifications which change, in-place, a component of a function","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"warning: Warning\nSolve ModelLike objects do not support problem modification.","category":"page"},{"location":"moi/manual/modification/#Modify-the-set-of-a-constraint","page":"Problem modification","title":"Modify the set of a constraint","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use set and ConstraintSet to modify the set of a constraint by replacing it with a new instance of the same type.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 0.0),\n           MOI.EqualTo(1.0),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}(1)\n\njulia> MOI.set(model, MOI.ConstraintSet(), c, MOI.EqualTo(2.0));\n\njulia> MOI.get(model, MOI.ConstraintSet(), c) == MOI.EqualTo(2.0)\ntrue","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"However, the following will fail as the new set is of a different type to the original set:","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> MOI.set(model, MOI.ConstraintSet(), c, MOI.GreaterThan(2.0))\nERROR: [...]","category":"page"},{"location":"moi/manual/modification/#Special-cases:-set-transforms","page":"Problem modification","title":"Special cases: set transforms","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"If our constraint is an affine inequality, then this corresponds to modifying the right-hand side of a constraint in linear programming.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"In some special cases, solvers may support efficiently changing the set of a constraint (for example, from LessThan to GreaterThan). For these cases, MathOptInterface provides the transform method.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"The transform function returns a new constraint index, and the old constraint index (i.e., c) is no longer valid.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 0.0),\n           MOI.LessThan(1.0),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}(1)\n\njulia> new_c = MOI.transform(model, c, MOI.GreaterThan(2.0));\n\njulia> MOI.is_valid(model, c)\nfalse\n\njulia> MOI.is_valid(model, new_c)\ntrue","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"note: Note\ntransform cannot be called with a set of the same type. Use set instead.","category":"page"},{"location":"moi/manual/modification/#Modify-the-function-of-a-constraint","page":"Problem modification","title":"Modify the function of a constraint","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use set and ConstraintFunction to modify the function of a constraint by replacing it with a new instance of the same type.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 0.0),\n           MOI.EqualTo(1.0),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}(1)\n\njulia> new_f = MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(2.0, x)], 1.0);\n\njulia> MOI.set(model, MOI.ConstraintFunction(), c, new_f);\n\njulia> MOI.get(model, MOI.ConstraintFunction(), c) ≈ new_f\ntrue","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"However, the following will fail as the new function is of a different type to the original function:","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> MOI.set(model, MOI.ConstraintFunction(), c, x)\nERROR: [...]","category":"page"},{"location":"moi/manual/modification/#Modify-constant-term-in-a-scalar-function","page":"Problem modification","title":"Modify constant term in a scalar function","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use modify and ScalarConstantChange to modify the constant term in a ScalarAffineFunction or ScalarQuadraticFunction.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 0.0),\n           MOI.EqualTo(1.0),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}(1)\n\njulia> MOI.modify(model, c, MOI.ScalarConstantChange(1.0));\n\njulia> new_f = MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 1.0);\n\njulia> MOI.get(model, MOI.ConstraintFunction(), c) ≈ new_f\ntrue","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"tip: Tip\nScalarConstantChange can also be used to modify the objective function by passing an instance of ObjectiveFunction instead of the constraint index c as we saw above.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> MOI.set(\n           model,\n           MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n           new_f,\n       );\n\njulia> MOI.modify(\n           model,\n           MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n           MOI.ScalarConstantChange(-1.0)\n       );\n\njulia> MOI.get(\n           model,\n           MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n       ) ≈ MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], -1.0)\ntrue","category":"page"},{"location":"moi/manual/modification/#Modify-constant-terms-in-a-vector-function","page":"Problem modification","title":"Modify constant terms in a vector function","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use modify and VectorConstantChange to modify the constant vector in a VectorAffineFunction or VectorQuadraticFunction.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.VectorAffineFunction([\n                   MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(1.0, x)),\n                   MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(2.0, x)),\n               ],\n               [0.0, 0.0],\n           ),\n           MOI.Nonnegatives(2),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}(1)\n\njulia> MOI.modify(model, c, MOI.VectorConstantChange([3.0, 4.0]));\n\njulia> new_f = MOI.VectorAffineFunction(\n           [\n        MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(1.0, x)),\n        MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(2.0, x)),\n           ],\n           [3.0, 4.0],\n       );\n\njulia> MOI.get(model, MOI.ConstraintFunction(), c) ≈ new_f\ntrue","category":"page"},{"location":"moi/manual/modification/#Modify-affine-coefficients-in-a-scalar-function","page":"Problem modification","title":"Modify affine coefficients in a scalar function","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use modify and ScalarCoefficientChange to modify the affine coefficient of a ScalarAffineFunction or ScalarQuadraticFunction.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 0.0),\n           MOI.EqualTo(1.0),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}(1)\n\njulia> MOI.modify(model, c, MOI.ScalarCoefficientChange(x, 2.0));\n\njulia> new_f = MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(2.0, x)], 0.0);\n\njulia> MOI.get(model, MOI.ConstraintFunction(), c) ≈ new_f\ntrue","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"tip: Tip\nScalarCoefficientChange can also be used to modify the objective function by passing an instance of ObjectiveFunction instead of the constraint index c as we saw above.","category":"page"},{"location":"moi/manual/modification/#Modify-affine-coefficients-in-a-vector-function","page":"Problem modification","title":"Modify affine coefficients in a vector function","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use modify and MultirowChange to modify a vector of affine coefficients in a VectorAffineFunction or a VectorQuadraticFunction.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.VectorAffineFunction([\n                   MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(1.0, x)),\n                   MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(2.0, x)),\n               ],\n               [0.0, 0.0],\n           ),\n           MOI.Nonnegatives(2),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}(1)\n\njulia> MOI.modify(model, c, MOI.MultirowChange(x, [(1, 3.0), (2, 4.0)]));\n\njulia> new_f = MOI.VectorAffineFunction(\n           [\n        MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(3.0, x)),\n        MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(4.0, x)),\n           ],\n           [0.0, 0.0],\n       );\n\njulia> MOI.get(model, MOI.ConstraintFunction(), c) ≈ new_f\ntrue","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/conic/experiment_design.jl\"","category":"page"},{"location":"tutorials/conic/experiment_design/#Experiment-design","page":"Experiment design","title":"Experiment design","text":"","category":"section"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"Originally Contributed by: Arpit Bhatia, Chris Coey","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"This tutorial covers experiment design examples (D-optimal, A-optimal, and E-optimal) from section 7.5 of the book Convex Optimization by Boyd and Vandenberghe.","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"The tutorial uses the following packages","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"using JuMP\nimport SCS\nimport LinearAlgebra\nimport Random","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"info: Info\nThis tutorial uses sets from MathOptInterface. By default, JuMP exports the MOI symbol as an alias for the MathOptInterface.jl package. We recommend making this more explicit in your code by adding the following lines:import MathOptInterface\nconst MOI = MathOptInterface","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"We set a seed so the random numbers are repeatable:","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"Random.seed!(1234)","category":"page"},{"location":"tutorials/conic/experiment_design/#The-relaxed-experiment-design-problem","page":"Experiment design","title":"The relaxed experiment design problem","text":"","category":"section"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"The basic experiment design problem is as follows.","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"Given the menu of possible choices for experiments, v_1 ldots v_p, and the total number m of experiments to be carried out, choose the numbers of each type of experiment, i.e., m_1 ldots m_p to make the error covariance E small (in  some sense).","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"The variables m_1 ldots m_p must, of course, be integers and sum to m the given total number of experiments. This leads to the optimization problem:","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"beginaligned\nminleft(mathrmwrt mathbfS_+^nright)  E=left(sum_j=1^p m_j v_j v_j^Tright)^-1 \ntextsubject to  m_i geq 0 \n sumlimits_i=1^p m_i = m \n m_i in mathbbZquad i=1ldotsp\nendaligned","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"The basic experiment design problem can be a hard combinatorial problem when m, the total number of experiments, is comparable to n, since in this case the m_i are all small integers.","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"In the case when m is large compared to n, however, a good approximate solution can be found by ignoring, or relaxing, the constraint that the m_i are integers.","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"Let lambda_i=m_i  m which is the fraction of the total number of experiments for which a_j=v_i or the relative frequency of experiment i. We can express the error covariance in terms of lambda_i as:","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"E=frac1mleft(sum_i=1^p lambda_i v_i v_i^Tright)^-1","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"The vector lambda in mathbfR^p satisfies lambda succeq 0 mathbf1^T lambda=1 and also, each lambda_i is an integer multiple of 1  m. By ignoring this last constraint, we arrive at the problem:","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"beginaligned\nminleft(mathrmwrt mathbfS_+^nright)  E=(1  m)left(sum_i=1^p lambda_i v_i v_i^Tright)^-1 \ntextsubject toquad  lambda succeq 0 \n mathbf1^T lambda=1\nendaligned","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"Several scalarizations have been proposed for the experiment design problem, which is a vector optimization problem over the positive semidefinite cone.","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"q = 4 # dimension of estimate space\np = 8 # number of experimental vectors\nnmax = 3 # upper bound on lambda\nn = 12\n\nV = randn(q, p)\n\neye = Matrix{Float64}(LinearAlgebra.I, q, q);\nnothing #hide","category":"page"},{"location":"tutorials/conic/experiment_design/#A-optimal-design","page":"Experiment design","title":"A-optimal design","text":"","category":"section"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"In A-optimal experiment design, we minimize tr E, the trace of the covariance matrix. This objective is simply the mean of the norm of the error squared:","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"mathbfEe_2^2=mathbfE operatornametrleft(e e^Tright)=operatornametr E","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"The A-optimal experiment design problem in SDP form is","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"beginaligned\nmin  mathbf1^T u \ntextsubject to  leftbeginalignedsum_i=1^p lambda_i v_i v_i^T  e_k  e_k^T  u_kendalignedright succeq 0 quad k=1 ldots n \n lambda succeq 0 \n  mathbf1^T lambda=1\nendaligned","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"aOpt = Model(SCS.Optimizer)\nset_silent(aOpt)\n@variable(aOpt, np[1:p], lower_bound = 0, upper_bound = nmax)\n@variable(aOpt, u[1:q], lower_bound = 0)\n@constraint(aOpt, sum(np) <= n)\nfor i in 1:q\n    matrix = [\n        V*LinearAlgebra.diagm(0 => np ./ n)*V' eye[:, i]\n        eye[i, :]' u[i]\n    ]\n    @constraint(aOpt, matrix >= 0, PSDCone())\nend\n@objective(aOpt, Min, sum(u))\noptimize!(aOpt)\nobjective_value(aOpt)","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"value.(np)","category":"page"},{"location":"tutorials/conic/experiment_design/#E-optimal-design","page":"Experiment design","title":"E-optimal design","text":"","category":"section"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"In E -optimal design, we minimize the norm of the error covariance matrix, i.e. the maximum eigenvalue of E.","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"Since the diameter (twice the longest semi-axis) of the confidence ellipsoid mathcalE is proportional to E_2^1  2, minimizing E_2 can be interpreted geometrically as minimizing the diameter of the confidence ellipsoid.","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"E-optimal design can also be interpreted as minimizing the maximum variance of q^T e, over all q with q_2=1. The E-optimal experiment design problem in SDP form is:","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"beginaligned\nmin  t \ntextsubject to  sum_i=1^p lambda_i v_i v_i^T succeq t I \n lambda succeq 0 \n mathbf1^T lambda=1\nendaligned","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"eOpt = Model(SCS.Optimizer)\nset_silent(eOpt)\n@variable(eOpt, 0 <= np[1:p] <= nmax)\n@variable(eOpt, t)\n@constraint(\n    eOpt,\n    V * LinearAlgebra.diagm(0 => np ./ n) * V' - (t .* eye) >= 0,\n    PSDCone(),\n)\n@constraint(eOpt, sum(np) <= n)\n@objective(eOpt, Max, t)\noptimize!(eOpt)\nobjective_value(eOpt)","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"value.(np)","category":"page"},{"location":"tutorials/conic/experiment_design/#D-optimal-design","page":"Experiment design","title":"D-optimal design","text":"","category":"section"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"The most widely used scalarization is called D -optimal design, in which we minimize the determinant of the error covariance matrix E. This corresponds to designing the experiment to minimize the volume of the resulting confidence ellipsoid (for a fixed confidence level). Ignoring the constant factor 1  m in E, and taking the logarithm of the objective, we can pose this problem as convex optimization problem:","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"beginaligned\nmin  log operatornamedetleft(sum_i=1^p lambda_i v_i v_i^Tright)^-1 \ntextsubject to  lambda succeq 0 \n mathbf1^T lambda=1\nendaligned","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"dOpt = Model(SCS.Optimizer)\nset_silent(dOpt)\n@variable(dOpt, np[1:p], lower_bound = 0, upper_bound = nmax)\n@variable(dOpt, t)\n@objective(dOpt, Max, t)\n@constraint(dOpt, sum(np) <= n)\nE = V * LinearAlgebra.diagm(0 => np ./ n) * V'\n@constraint(\n    dOpt,\n    [t, 1, (E[i, j] for i in 1:q for j in 1:i)...] in MOI.LogDetConeTriangle(q)\n)\noptimize!(dOpt)\nobjective_value(dOpt)","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"value.(np)","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"developers/custom_solver_binaries/#How-to-use-a-custom-binary","page":"Custom binaries","title":"How to use a custom binary","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Many solvers are not written in Julia, but instead in languages like C or C++. JuMP interacts with these solvers through binary dependencies.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"For many open-source solvers, we automatically install the appropriate binary when you run Pkg.add(\"Solver\"). For example, Pkg.add(\"ECOS\") will also install the ECOS binary.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"This page explains how this installation works, and how you can use a custom binary.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"compat: Compat\nThese instructions require Julia 1.6 or later.","category":"page"},{"location":"developers/custom_solver_binaries/#Background","page":"Custom binaries","title":"Background","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Each solver that JuMP supports is structured as a Julia package. For example, the interface for the ECOS solver is provided by the ECOS.jl package.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"tip: Tip\nThis page uses the example of ECOS.jl because it is simple to compile. Other solvers follow similar conventions. For example, the interface to the Clp solver is provided by Clp.jl.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"The ECOS.jl package provides an interface between the C API of ECOS and MathOptInterface. However, it does not handle the installation of the solver binary; that is the job for a JLL package.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"A JLL is a Julia package that wraps a pre-compiled binary. Binaries are built using Yggdrasil (for example, ECOS) and hosted in the JuliaBinaryWrappers GitHub repository (for example, ECOS_jll.jl).","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"JLL packages contain little code. Their only job is to dlopen a dynamic library, along with any dependencies.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"JLL packages manage their binary dependencies using Julia's artifact system. Each JLL package has an Artifacts.toml file which describes where to find each binary artifact for each different platform that it might be installed on. Here is the Artifacts.toml file for ECOS_jll.jl.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"The binaries installed by the JLL package should be sufficient for most users. In rare cases, however, you may require a custom binary. The two main reasons to use a custom binary are:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"You want a binary with custom compilation settings (for example, debugging)\nYou want a binary with a set of dependencies that are not available on Yggdrasil (for example, a commerial solver like Gurobi or CPLEX).","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"The following sections explain how to replace the binaries provided by a JLL package with the custom ones you have compiled. As a reminder, we use ECOS as an example for simplicity, but the steps are the same for other solvers.","category":"page"},{"location":"developers/custom_solver_binaries/#jll_structure","page":"Custom binaries","title":"Explore the JLL you want to override","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"The first step is to explore the structure and filenames of the JLL package we want to override.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Find the location of the files using .artifact_dir:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"julia> using ECOS_jll\n\njulia> ECOS_jll.artifact_dir\n\"/Users/oscar/.julia/artifacts/2addb75332eff5a1657b46bb6bf30d2410bc7ecf\"","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"tip: Tip\nThis path may be different on other machines.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Here is what it contains:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"julia> readdir(ECOS_jll.artifact_dir)\n4-element Vector{String}:\n \"include\"\n \"lib\"\n \"logs\"\n \"share\"\n\njulia> readdir(joinpath(ECOS_jll.artifact_dir, \"lib\"))\n1-element Vector{String}:\n \"libecos.dylib\"","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Other solvers may have a bin directory containing executables. To use a custom binary of ECOS, we need to replace /lib/libecos.dylib with our custom binary.","category":"page"},{"location":"developers/custom_solver_binaries/#compile_ecos","page":"Custom binaries","title":"Compile a custom binary","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"The next step is to compile a custom binary. Because ECOS is written in C with no dependencies, this is easy to do if you have a C compiler:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"oscar@Oscars-MBP jll_example % git clone https://github.com/embotech/ecos.git\n[... lines omitted ...]\noscar@Oscars-MBP jll_example % cd ecos\noscar@Oscars-MBP ecos % make shared\n[... many lines omitted...]\noscar@Oscars-MBP ecos % mkdir lib\noscar@Oscars-MBP ecos % cp libecos.dylib lib","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"warning: Warning\nCompiling custom solver binaries is an advanced operation. Due to the complexities of compiling various solvers, the JuMP community is unable to help you diagnose and fix compilation issues.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"After this compilation step, we now have a folder /tmp/jll_example/ecos that contains lib and include directories with the same files as ECOS_jll:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"julia> readdir(joinpath(\"ecos\", \"lib\"))\n1-element Vector{String}:\n \"libecos.dylib\"","category":"page"},{"location":"developers/custom_solver_binaries/#Overriding-a-single-library","page":"Custom binaries","title":"Overriding a single library","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"To override the libecos library, we need to know what ECOS_jll calls it. (In most cases, it will also be libecos, but not always.)","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"There are two ways you can check.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Check the bottom of the JLL's GitHub README. For example, ECOS_jll has a single LibraryProduct called libecos.\nType ECOS_jll. and the press the [TAB] key twice to auto-complete available options:\njulia> ECOS_jll.\nLIBPATH           PATH_list          best_wrapper       get_libecos_path   libecos_handle\nLIBPATH_list      __init__           dev_jll            is_available       libecos_path\nPATH              artifact_dir       find_artifact_dir  libecos\nHere you can see there is libecos, and more usefully for us, libecos_path.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Once you know the name of the variable to override (the one that ends in _path), use  Preferences.jl to specify a new path:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"using Preferences\nset_preferences!(\n    \"LocalPreferences.toml\",\n    \"ECOS_jll\",\n    \"libecos_path\" => \"/tmp/jll_example/ecos/lib/libecos\"\n)","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"This will create a file in your current directory called LocalPreferences.toml with the contents:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"[ECOS_jll]\nlibecos_path = \"/tmp/jll_example/ecos/lib/libecos\"","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Now if you restart Julia, you will see:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"julia> using ECOS_jll\n\njulia> ECOS_jll.libecos\n\"/tmp/jll_example/ecos/lib/libecos\"","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"To go back to using the default library, just delete the LocalPreferences.toml file.","category":"page"},{"location":"developers/custom_solver_binaries/#Overriding-an-entire-artifact","page":"Custom binaries","title":"Overriding an entire artifact","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Sometimes a solver may provide a number of libraries and executables, and specifying the path for each of the becomes tedious. In this case, we can use Julia's Override.toml to replace an entire artifact.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Overriding an entire artifact requires you to replicate the structure and contents of the JLL package that we explored above.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"In most cases you need only reproduce the include, lib, and bin directories (if they exist). You can safely ignore any logs or share directories. Take careful note of what files each directory contains and what they are called.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"For our ECOS example, we already reproduced the structure when we compiled ECOS.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"So, now we need to tell Julia to use our custom installation instead of the default. We can do this by making an override file at ~/.julia/artifacts/Overrides.toml.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Overrides.toml has the following content:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"# Override for ECOS_jll\n2addb75332eff5a1657b46bb6bf30d2410bc7ecf = \"/tmp/jll_example/ecos\"","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"where 2addb75332eff5a1657b46bb6bf30d2410bc7ecf is the folder from the original ECOS_jll.artifact_dir and \"/tmp/jll_example/ecos\" is the location of our new installation. Replace these as appropriate for your system.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"If you restart Julia after creating the override file, you will see:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"julia> using ECOS_jll\n\njulia> ECOS_jll.artifact_dir\n\"/tmp/jll_example/ecos\"","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Now when we use ECOS it will use our custom binary.","category":"page"},{"location":"developers/custom_solver_binaries/#Using-Cbc-with-a-custom-binary","page":"Custom binaries","title":"Using Cbc with a custom binary","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"As a second example, we demonstrate how to use Cbc.jl with a custom binary.","category":"page"},{"location":"developers/custom_solver_binaries/#Explore-the-JLL-you-want-to-override","page":"Custom binaries","title":"Explore the JLL you want to override","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"First, let's check where Cbc_jll is installed:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"julia> using Cbc_jll\n\njulia> Cbc_jll.artifact_dir\n\"/Users/oscar/.julia/artifacts/e481bc81db5e229ba1f52b2b4bd57484204b1b06\"\n\njulia> readdir(Cbc_jll.artifact_dir)\n5-element Vector{String}:\n \"bin\"\n \"include\"\n \"lib\"\n \"logs\"\n \"share\"\n\njulia> readdir(joinpath(Cbc_jll.artifact_dir, \"bin\"))\n1-element Vector{String}:\n \"cbc\"\n\njulia> readdir(joinpath(Cbc_jll.artifact_dir, \"lib\"))\n10-element Vector{String}:\n \"libCbc.3.10.5.dylib\"\n \"libCbc.3.dylib\"\n \"libCbc.dylib\"\n \"libCbcSolver.3.10.5.dylib\"\n \"libCbcSolver.3.dylib\"\n \"libCbcSolver.dylib\"\n \"libOsiCbc.3.10.5.dylib\"\n \"libOsiCbc.3.dylib\"\n \"libOsiCbc.dylib\"\n \"pkgconfig\"","category":"page"},{"location":"developers/custom_solver_binaries/#Compile-a-custom-binary","page":"Custom binaries","title":"Compile a custom binary","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Next, we need to compile Cbc. Cbc can be difficult to compile (it has a lot of dependencies), but for macOS users there is a homebrew recipe:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"(base) oscar@Oscars-MBP jll_example % brew install cbc\n[ ... lines omitted ... ]\n(base) oscar@Oscars-MBP jll_example % brew list cbc\n/usr/local/Cellar/cbc/2.10.5/bin/cbc\n/usr/local/Cellar/cbc/2.10.5/include/cbc/ (76 files)\n/usr/local/Cellar/cbc/2.10.5/lib/libCbc.3.10.5.dylib\n/usr/local/Cellar/cbc/2.10.5/lib/libCbcSolver.3.10.5.dylib\n/usr/local/Cellar/cbc/2.10.5/lib/libOsiCbc.3.10.5.dylib\n/usr/local/Cellar/cbc/2.10.5/lib/pkgconfig/ (2 files)\n/usr/local/Cellar/cbc/2.10.5/lib/ (6 other files)\n/usr/local/Cellar/cbc/2.10.5/share/cbc/ (59 files)\n/usr/local/Cellar/cbc/2.10.5/share/coin/ (4 files)","category":"page"},{"location":"developers/custom_solver_binaries/#Override-single-libraries","page":"Custom binaries","title":"Override single libraries","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"To use Preferences.jl to override specific libraries we first check the names of each library in Cbc_jll:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"julia> Cbc_jll.\nLIBPATH               cbc                    get_libcbcsolver_path  libOsiCbc_path\nLIBPATH_list          cbc_path               is_available           libcbcsolver\nPATH                  dev_jll                libCbc                 libcbcsolver_handle\nPATH_list             find_artifact_dir      libCbc_handle          libcbcsolver_path\n__init__              get_cbc_path           libCbc_path\nartifact_dir          get_libCbc_path        libOsiCbc\nbest_wrapper          get_libOsiCbc_path     libOsiCbc_handle","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Then we add the following to LocalPreferences.toml:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"[Cbc_jll]\ncbc_path = \"/usr/local/Cellar/cbc/2.10.5/bin/cbc\"\nlibCbc_path = \"/usr/local/Cellar/cbc/2.10.5/lib/libCbc.3.10.5\"\nlibOsiCbc_path = \"/usr/local/Cellar/cbc/2.10.5/lib/libOsiCbc.3.10.5\"\nlibcbcsolver_path = \"/usr/local/Cellar/cbc/2.10.5/lib/libCbcSolver.3.10.5\"","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"info: Info\nNote that capitalization matters, so libcbcsolver_path corresponds to libCbcSolver.3.10.5.","category":"page"},{"location":"developers/custom_solver_binaries/#Override-entire-artifact","page":"Custom binaries","title":"Override entire artifact","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"To use the homebrew install as our custom binary we add the following to ~/.julia/artifacts/Overrides.toml:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"# Override for Cbc_jll\ne481bc81db5e229ba1f52b2b4bd57484204b1b06 = \"/usr/local/Cellar/cbc/2.10.5\"","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP, GLPK, SCS\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/models/#jump_models","page":"Models","title":"Models","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"JuMP models are the fundamental building block that we use to construct optimization problems. They hold things like the variables and constraints, as well as which solver to use and even solution information.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"info: Info\nJuMP uses \"optimizer\" as a synonym for \"solver.\" Our convention is to use \"solver\" to refer to the underlying software, and use \"optimizer\" to refer to the Julia object that wraps the solver. For example, GLPK is a solver, and GLPK.Optimizer is an optimizer.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"tip: Tip\nSee Supported solvers for a list of available solvers.","category":"page"},{"location":"manual/models/#Create-a-model","page":"Models","title":"Create a model","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Create a model by passing an optimizer to Model:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(GLPK.Optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: GLPK","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"If you don't know which optimizer you will be using at creation time, create a model without an optimizer, and then call set_optimizer at any time prior to optimize!:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> set_optimizer(model, GLPK.Optimizer)","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"tip: Tip\nDon't know what the fields Model mode and CachingOptimizer state mean? Read the Backends section.","category":"page"},{"location":"manual/models/#What-is-the-difference?","page":"Models","title":"What is the difference?","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"For most models, there is no difference between passing the optimizer to Model, and calling set_optimizer.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"However, if an optimizer does not support a constraint in the model, the timing of when an error will be thrown can differ:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"If you pass an optimizer, an error will be thrown when you try to add the constraint.\nIf you call set_optimizer, an error will be thrown when you try to solve the model via optimize!.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Therefore, most users should pass an optimizer to Model because it provides the earliest warning that your solver is not suitable for the model you are trying to build. However, if you are modifying a problem by adding and deleting different constraint types, you may need to use set_optimizer. See Switching optimizer for the relaxed problem for an example of when this is useful.","category":"page"},{"location":"manual/models/#Reducing-time-to-first-solve-latency","page":"Models","title":"Reducing time-to-first-solve latency","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"By default, JuMP uses bridges to reformulate the model you are building into an equivalent model supported by the solver.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"However, if your model is already supported by the solver, bridges add latency (read The \"time-to-first-solve\" issue). This is particularly noticeable for small models.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"To reduce the \"time-to-first-solve\", try passing add_bridges = false.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(GLPK.Optimizer; add_bridges = false);","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"or","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model();\n\njulia> set_optimizer(model, GLPK.Optimizer; add_bridges = false)","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"However, be wary! If your model and solver combination needs bridges, an error will be thrown:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(SCS.Optimizer; add_bridges = false);\n\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, 2x <= 1)\nERROR: Constraints of type MathOptInterface.ScalarAffineFunction{Float64}-in-MathOptInterface.LessThan{Float64} are not supported by the solver.\n\nIf you expected the solver to support your problem, you may have an error in your formulation. Otherwise, consider using a different solver.\n\nThe list of available solvers, along with the problem types they support, is available at https://jump.dev/JuMP.jl/stable/installation/#Supported-solvers.\n[...]","category":"page"},{"location":"manual/models/#Solvers-which-expect-environments","page":"Models","title":"Solvers which expect environments","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Some solvers accept (or require) positional arguments such as a license environment or a path to a binary executable. For these solvers, you can pass a function to Model which takes zero arguments and returns an instance of the optimizer.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A common use-case for this is passing an environment to Gurobi:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> grb_env = Gurobi.Env();\n\njulia> model = Model(() -> Gurobi.Optimizer(grb_env))\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: Gurobi","category":"page"},{"location":"manual/models/#solver_options","page":"Models","title":"Solver options","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"JuMP uses \"attribute\" as a synonym for \"option.\" Use optimizer_with_attributes to create an optimizer with some attributes initialized:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 0))\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: GLPK","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Alternatively, use set_optimizer_attribute to set an attribute after the model has been created:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(GLPK.Optimizer);\n\njulia> set_optimizer_attribute(model, \"msg_lev\", 0)\n\njulia> get_optimizer_attribute(model, \"msg_lev\")\n0","category":"page"},{"location":"manual/models/#Print-the-model","page":"Models","title":"Print the model","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"By default, show(model) will print a summary of the problem:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(); @variable(model, x >= 0); @objective(model, Max, x);\n\njulia> model\nA JuMP Model\nMaximization problem with:\nVariable: 1\nObjective function type: VariableRef\n`VariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: x","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use print to print the formulation of the model (in IJulia, this will render as LaTeX.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> print(model)\nMax x\nSubject to\n x ≥ 0.0","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"warning: Warning\nThis format is specific to JuMP and may change in any future release. It is not intended to be an instance format. To write the model to a file, use write_to_file instead.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use latex_formulation to display the model in LaTeX form.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> latex_formulation(model)\n$$ \\begin{aligned}\n\\max\\quad & x\\\\\n\\text{Subject to} \\quad & x \\geq 0.0\\\\\n\\end{aligned} $$","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"In IJulia (and Documenter), ending a cell in with latex_formulation will render the model in LaTeX!","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"using JuMP                # hide\nmodel = Model()           # hide\n@variable(model, x >= 0)  # hide\n@objective(model, Max, x) # hide\nlatex_formulation(model)","category":"page"},{"location":"manual/models/#Turn-off-output","page":"Models","title":"Turn off output","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use set_silent and unset_silent to disable or enable printing output from the solver.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(GLPK.Optimizer);\n\njulia> set_silent(model)\n\njulia> unset_silent(model)","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"tip: Tip\nMost solvers will also have a solver-specific option to provide finer-grained control over the output. Consult their README's for details.","category":"page"},{"location":"manual/models/#Set-a-time-limit","page":"Models","title":"Set a time limit","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use set_time_limit_sec, unset_time_limit_sec, and time_limit_sec to manage time limits.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(GLPK.Optimizer);\n\njulia> set_time_limit_sec(model, 60.0)\n\n\njulia> time_limit_sec(model)\n60.0\n\njulia> unset_time_limit_sec(model)\n\njulia> time_limit_sec(model)\n2.147483647e6","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"info: Info\nSome solvers do not support time limits. In these cases, an error will be thrown.","category":"page"},{"location":"manual/models/#Write-a-model-to-file","page":"Models","title":"Write a model to file","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"JuMP can write models to a variety of file-formats using write_to_file and Base.write.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"For most common file formats, the file type will be detected from the extension. For example, here is how to write an MPS file:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> write_to_file(model, \"model.mps\")","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"To write to a specific io::IO, use Base.write. Specify the file type by passing a MOI.FileFormats.FileFormat enum.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> write(io, model; format = MOI.FileFormats.FORMAT_MPS)","category":"page"},{"location":"manual/models/#Read-a-model-from-file","page":"Models","title":"Read a model from file","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"JuMP models can be created from file formats using read_from_file and Base.read.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = read_from_file(\"model.mps\")\nA JuMP Model\nMinimization problem with:\nVariables: 0\nObjective function type: AffExpr\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> seekstart(io);\n\njulia> model2 = read(io, Model; format = MOI.FileFormats.FORMAT_MPS)\nA JuMP Model\nMinimization problem with:\nVariables: 0\nObjective function type: AffExpr\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"note: Note\nBecause file formats do not serialize the containers of JuMP variables and constraints, the names in the model will not be registered. Therefore, you cannot access named variables and constraints via model[:x]. Instead, use variable_by_name or constraint_by_name to access specific variables or constraints.","category":"page"},{"location":"manual/models/#Relax-integrality","page":"Models","title":"Relax integrality","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use relax_integrality to remove any integrality constraints from the model, such as integer and binary restrictions on variables. relax_integrality returns a function that can be later called with zero arguments to re-add the removed constraints:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model();\n\njulia> @variable(model, x, Int)\nx\n\njulia> num_constraints(model, VariableRef, MOI.Integer)\n1\n\njulia> undo = relax_integrality(model);\n\njulia> num_constraints(model, VariableRef, MOI.Integer)\n0\n\njulia> undo()\n\njulia> num_constraints(model, VariableRef, MOI.Integer)\n1","category":"page"},{"location":"manual/models/#Switching-optimizer-for-the-relaxed-problem","page":"Models","title":"Switching optimizer for the relaxed problem","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"A common reason for relaxing integrality is to compute dual variables of the relaxed problem. However, some mixed-integer linear solvers (for example, Cbc) do not return dual solutions, even if the problem does not have integrality restrictions.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Therefore, after relax_integrality you should call set_optimizer with a solver that does support dual solutions, such as Clp.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"For example, instead of:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"using JuMP, Cbc\nmodel = Model(Cbc.Optimizer)\n@variable(model, x, Int)\nundo = relax_integrality(model)\noptimize!(model)\nreduced_cost(x)  # Errors","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"do:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"using JuMP, Cbc, Clp\nmodel = Model(Cbc.Optimizer)\n@variable(model, x, Int)\nundo = relax_integrality(model)\nset_optimizer(model, Clp.Optimizer)\noptimize!(model)\nreduced_cost(x)  # Works","category":"page"},{"location":"manual/models/#Backends","page":"Models","title":"Backends","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"info: Info\nThis section discusses advanced features of JuMP. For new users, you may want to skip this section. You don't need to know how JuMP manages problems behind the scenes to create and solve JuMP models.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A JuMP Model is a thin layer around a backend of type MOI.ModelLike that stores the optimization problem and acts as the optimization solver.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"However, if you construct a model like Model(GLPK.Optimizer), the backend is not a GLPK.Optimizer, but a more complicated object.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"From JuMP, the MOI backend can be accessed using the backend function. Let's see what the backend of a JuMP Model is:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(GLPK.Optimizer);\n\njulia> b = backend(model)\nMOIU.CachingOptimizer{MOIB.LazyBridgeOptimizer{GLPK.Optimizer}, MOIU.UniversalFallback{MOIU.Model{Float64}}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.UniversalFallback{MOIU.Model{Float64}}\n  fallback for MOIU.Model{Float64}\nwith optimizer MOIB.LazyBridgeOptimizer{GLPK.Optimizer}\n  with 0 variable bridges\n  with 0 constraint bridges\n  with 0 objective bridges\n  with inner model A GLPK model","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Uh oh! Even though we passed a GLPK.Optimizer, the backend is a much more complicated object.","category":"page"},{"location":"manual/models/#CachingOptimizer","page":"Models","title":"CachingOptimizer","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"A MOIU.CachingOptimizer is a layer that abstracts the difference between solvers that support incremental modification (for example, they support adding variables one-by-one), and solvers that require the entire problem in a single API call (for example, they only accept the A, b and c matrices of a linear program).","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"It has two parts:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A cache, where the model can be built and modified incrementally\njulia> b.model_cache\nMOIU.UniversalFallback{MOIU.Model{Float64}}\nfallback for MOIU.Model{Float64}\nAn optimizer, which is used to solve the problem\njulia> b.optimizer\nMOIB.LazyBridgeOptimizer{GLPK.Optimizer}\nwith 0 variable bridges\nwith 0 constraint bridges\nwith 0 objective bridges\nwith inner model A GLPK model","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"info: Info\nThe LazyBridgeOptimizer section explains what a LazyBridgeOptimizer is.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"The CachingOptimizer has logic to decide when to copy the problem from the cache to the optimizer, and when it can efficiently update the optimizer in-place.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A CachingOptimizer may be in one of three possible states:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"NO_OPTIMIZER: The CachingOptimizer does not have any optimizer.\nEMPTY_OPTIMIZER: The CachingOptimizer has an empty optimizer, and it is not synchronized with the cached model.\nATTACHED_OPTIMIZER: The CachingOptimizer has an optimizer, and it is synchronized with the cached model.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A CachingOptimizer has two modes of operation:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"AUTOMATIC: The CachingOptimizer changes its state when necessary. For example, optimize! will automatically call attach_optimizer (an optimizer must have been previously set). Attempting to add a constraint or perform a modification not supported by the optimizer results in a drop to EMPTY_OPTIMIZER mode.\nMANUAL: The user must change the state of the CachingOptimizer using MOIU.reset_optimizer(::JuMP.Model), MOIU.drop_optimizer(::JuMP.Model), and MOIU.attach_optimizer(::JuMP.Model). Attempting to perform an operation in the incorrect state results in an error.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"By default Model will create a CachingOptimizer in AUTOMATIC mode.","category":"page"},{"location":"manual/models/#LazyBridgeOptimizer","page":"Models","title":"LazyBridgeOptimizer","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"The second layer that JuMP applies automatically is a LazyBridgeOptimizer. A LazyBridgeOptimizer is an MOI layer that attempts to transform the problem from the formulation provided by the user into an equivalent problem supported by the solver. This may involve adding new variables and constraints to the optimizer. The transformations are selected from a set of known recipes called bridges.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A common example of a bridge is one that splits an interval constraint like @constraint(model, 1 <= x + y <= 2) into two constraints, @constraint(model, x + y >= 1) and @constraint(model, x + y <= 2).","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use the add_bridges = false keyword to remove the bridging layer:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(GLPK.Optimizer; add_bridges = false)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: GLPK\n\njulia> backend(model)\nMOIU.CachingOptimizer{GLPK.Optimizer, MOIU.UniversalFallback{MOIU.Model{Float64}}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.UniversalFallback{MOIU.Model{Float64}}\n  fallback for MOIU.Model{Float64}\nwith optimizer A GLPK model","category":"page"},{"location":"manual/models/#Unsafe-backend","page":"Models","title":"Unsafe backend","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"In some advanced use-cases, it is necessary to work with the inner optimization model directly. To access this model, use unsafe_backend:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> backend(model)\nMOIU.CachingOptimizer{MOIB.LazyBridgeOptimizer{GLPK.Optimizer}, MOIU.UniversalFallback{MOIU.Model{Float64}}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.UniversalFallback{MOIU.Model{Float64}}\n  fallback for MOIU.Model{Float64}\nwith optimizer MOIB.LazyBridgeOptimizer{GLPK.Optimizer}\n  with 0 variable bridges\n  with 0 constraint bridges\n  with 0 objective bridges\n  with inner model A GLPK model\n\njulia> unsafe_backend(model)\nA GLPK model","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"warning: Warning\nbackend and unsafe_backend are advanced routines. Read their docstrings to understand the caveats of their usage, and only call them if you wish to access low-level solver-specific functions.","category":"page"},{"location":"manual/models/#Direct-mode","page":"Models","title":"Direct mode","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Using a CachingOptimizer results in an additional copy of the model being stored by JuMP in the .model_cache field. To avoid this overhead, create a JuMP model using direct_model:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = direct_model(GLPK.Optimizer())\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: DIRECT\nSolver name: GLPK","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"warning: Warning\nSolvers that do not support incremental modification do not support direct_model. An error will be thrown, telling you to use a CachingOptimizer instead.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"The benefit of using direct_model is that there are no extra layers (for example, Cachingoptimizer or LazyBridgeOptimizer) between model and the provided optimizer:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> backend(model)\nA GLPK model","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A downside of direct mode is that there is no bridging layer. Therefore, only constraints which are natively supported by the solver are supported. For example, GLPK.jl does not implement constraints of the form l <= a' x <= u.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> @variable(model, x[1:2]);\n\njulia> @constraint(model, 1 <= x[1] + x[2] <= 2)\nERROR: Constraints of type MathOptInterface.ScalarAffineFunction{Float64}-in-MathOptInterface.Interval{Float64} are not supported by the solver.\n\nIf you expected the solver to support your problem, you may have an error in your formulation. Otherwise, consider using a different solver.\n\nThe list of available solvers, along with the problem types they support, is available at https://jump.dev/JuMP.jl/stable/installation/#Supported-solvers.\n[...]","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/background/duality/#Duality","page":"Duality","title":"Duality","text":"","category":"section"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"Conic duality is the starting point for MOI's duality conventions. When all functions are affine (or coordinate projections), and all constraint sets are closed convex cones, the model may be called a conic optimization problem.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"For a minimization problem in geometric conic form, the primal is:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n min_x in mathbbR^n  a_0^T x + b_0\n\n textst  A_i x + b_i  in mathcalC_i  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"and the dual is a maximization problem in standard conic form:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n max_y_1 ldots y_m  -sum_i=1^m b_i^T y_i + b_0\n\n textst  a_0 - sum_i=1^m A_i^T y_i  = 0\n\n  y_i  in mathcalC_i^*  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"where each mathcalC_i is a closed convex cone and mathcalC_i^* is its dual cone.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"For a maximization problem in geometric conic form, the primal is:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n max_x in mathbbR^n  a_0^T x + b_0\n\n textst  A_i x + b_i  in mathcalC_i  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"and the dual is a minimization problem in standard conic form:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n min_y_1 ldots y_m  sum_i=1^m b_i^T y_i + b_0\n\n textst  a_0 + sum_i=1^m A_i^T y_i  = 0\n\n  y_i  in mathcalC_i^*  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"A linear inequality constraint a^T x + b ge c is equivalent to a^T x + b - c in mathbbR_+, and a^T x + b le c is equivalent to a^T x + b - c in mathbbR_-. Variable-wise constraints are affine constraints with the appropriate identity mapping in place of A_i.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"For the special case of minimization LPs, the MOI primal form can be stated as:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n min_x in mathbbR^n  a_0^T x + b_0\n\n textst\nA_1 x  ge b_1\n A_2 x  le b_2\n A_3 x  = b_3\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"By applying the stated transformations to conic form, taking the dual, and transforming back into linear inequality form, one obtains the following dual:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n max_y_1y_2y_3  b_1^Ty_1 + b_2^Ty_2 + b_3^Ty_3 + b_0\n\n textst\nA_1^Ty_1 + A_2^Ty_2 + A_3^Ty_3  = a_0\n y_1 ge 0\n y_2 le 0\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"For maximization LPs, the MOI primal form can be stated as:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n max_x in mathbbR^n  a_0^T x + b_0\n\n textst\nA_1 x  ge b_1\n A_2 x  le b_2\n A_3 x  = b_3\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"and similarly, the dual is:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n min_y_1y_2y_3  -b_1^Ty_1 - b_2^Ty_2 - b_3^Ty_3 + b_0\n\n textst\nA_1^Ty_1 + A_2^Ty_2 + A_3^Ty_3  = -a_0\n y_1 ge 0\n y_2 le 0\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"warning: Warning\nFor the LP case, the signs of the feasible dual variables depend only on the sense of the corresponding primal inequality and not on the objective sense.","category":"page"},{"location":"moi/background/duality/#Duality-and-scalar-product","page":"Duality","title":"Duality and scalar product","text":"","category":"section"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"The scalar product is different from the canonical one for the sets PositiveSemidefiniteConeTriangle, LogDetConeTriangle, RootDetConeTriangle.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"If the set C_i of the section Duality is one of these three cones, then the rows of the matrix A_i corresponding to off-diagonal entries are twice the value of the coefficients field in the VectorAffineFunction for the corresponding rows. See PositiveSemidefiniteConeTriangle for details.","category":"page"},{"location":"moi/background/duality/#Dual-for-problems-with-quadratic-functions","page":"Duality","title":"Dual for problems with quadratic functions","text":"","category":"section"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"Given a problem with quadratic functions:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign*\n min_x in mathbbR^n  frac12x^TQ_0x + a_0^T x + b_0\n\n textst  frac12x^TQ_ix + a_i^T x + b_i  in mathcalC_i  i = 1 ldots m\nendalign*","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"with cones mathcalC_i subseteq mathbbR for i = 1 ldots m, consider the Lagrangian function","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"L(x y) = frac12x^TQ_0x + a_0^T x + b_0 - sum_i = 1^m y_i (frac12x^TQ_ix + a_i^T x + b_i)","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"A pair of primal-dual variables (x^star y^star) is optimal if","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"x^star is a minimizer of\nmin_x in mathbbR^n L(x y^star)\nThat is,\n0 = nabla_x L(x y^star) = Q_0x + a_0 - sum_i = 1^m y_i^star (Q_ix + a_i)\nand y^star is a maximizer of\nmax_y_i in mathcalC_i^* L(x^star y)\nThat is, for all i = 1 ldots m, frac12x^TQ_ix + a_i^T x + b_i is either zero or in the normal cone of mathcalC_i^* at y^star. For instance, if mathcalC_i is  x in mathbbR  x le 0 , this means that if frac12x^TQ_ix + a_i^T x + b_i is nonzero at x^star then y_i^star = 0. This is the classical complementary slackness condition.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"If mathcalC_i is a vector set, the discussion remains valid with y_i(frac12x^TQ_ix + a_i^T x + b_i) replaced with the scalar product between y_i and the vector of scalar-valued quadratic functions.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"note: Note\nFor quadratic programs with only affine constraints, the optimality condition nabla_x L(x y^star) = 0 can be simplified as follows:0 = nabla_x L(x y^star) = Q_0x + a_0 - sum_i = 1^m y_i^star a_iwhich givesQ_0x = sum_i = 1^m y_i^star a_i - a_0 The Lagrangian functionL(x y) = frac12x^TQ_0x + a_0^T x + b_0 - sum_i = 1^m y_i (a_i^T x + b_i)can be rewritten asL(x y) = frac12x^TQ_0x - (sum_i = 1^m y_i a_i^T - a_0^T) x + b_0 - sum_i = 1^m y_i (a_i^T x + b_i)which, using the optimality condition nabla_x L(x y^star) = 0, can be simplified asL(x y) = -frac12x^TQ_0x + b_0 - sum_i = 1^m y_i (a_i^T x + b_i)","category":"page"},{"location":"moi/background/naming_conventions/","page":"Naming conventions","title":"Naming conventions","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/background/naming_conventions/#Naming-conventions","page":"Naming conventions","title":"Naming conventions","text":"","category":"section"},{"location":"moi/background/naming_conventions/","page":"Naming conventions","title":"Naming conventions","text":"MOI follows several conventions for naming functions and structures. These  should also be followed by packages extending MOI.","category":"page"},{"location":"moi/background/naming_conventions/#Sets","page":"Naming conventions","title":"Sets","text":"","category":"section"},{"location":"moi/background/naming_conventions/","page":"Naming conventions","title":"Naming conventions","text":"Sets encode the structure of constraints. Their names should follow the  following conventions: ","category":"page"},{"location":"moi/background/naming_conventions/","page":"Naming conventions","title":"Naming conventions","text":"Abstract types in the set hierarchy should begin with Abstract and end in Set, e.g., AbstractScalarSet, AbstractVectorSet.\nVector-valued conic sets should end with Cone, e.g., NormInfinityCone, SecondOrderCone.\nVector-valued Cartesian products should be plural and not end in Cone, e.g., Nonnegatives, not NonnegativeCone.\nMatrix-valued conic sets should provide two representations: ConeSquare and ConeTriangle, e.g., RootDetConeTriangle and RootDetConeSquare. See Matrix cones for more details.\nScalar sets should be singular, not plural, e.g., Integer, not  Integers.\nAs much as possible, the names should follow established conventions in the  domain where this set is used: for instance, convex sets should have names  close to those of CVX, and  constraint-programming sets should follow  MiniZinc's constraints.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/algorithms/benders_decomposition.jl\"","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/#benders_decomposition_classical","page":"Benders decomposition","title":"Benders decomposition","text":"","category":"section"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Originally Contributed by: Shuvomoy Das Gupta","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"This notebook describes how to implement Benders decomposition in JuMP, which is a large scale optimization scheme.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"We only discuss the classical approach (using loops) here. Read Benders decomposition (via callbacks) for an alternative approach.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"To illustrate an implementation of the Benders decomposition in JuMP, we apply it to the following general mixed integer problem:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"beginaligned\n textmaximize quad c_1^T x+c_2^T v \n textsubject to quad A_1 x+ A_2 v preceq b \n x succeq 0 x in mathbbZ^n \n v succeq 0 v in mathbbR^p \nendaligned","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"where b in mathbbR^m, A_1 in mathbbR^m times n, A_2 in mathbbR^m times p and mathbbZ is the set of integers.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Here the symbol succeq (preceq) stands for element-wise greater (less) than or equal to. Any mixed integer programming problem can be written in the form above.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"We want to write the Benders decomposition algorithm for the problem above. Consider the polyhedron u in mathbbR^m A_2^T u succeq 0 u succeq 0. Assume the set of vertices and extreme rays of the polyhedron is denoted by P and Q respectively.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Assume on the kth iteration the subset of vertices of the polyhedron mentioned is denoted by T(k) and the subset of extreme rays are denoted by Q(k), which will be generated by the Benders decomposition problem below.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/#The-algorithm","page":"Benders decomposition","title":"The algorithm","text":"","category":"section"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Step 1 (Initialization)","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"We start with T(1)=Q(1)=emptyset. Let f_m^(1) be arbitrarily large and x^(1) be any non-negative integer vector and go to Step 2.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Step 2 (Solving the master problem)","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Solve the master problem, f_textm^(k) =","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"beginaligned\ntextmaximize quad t \ntextsubject to quad forall baru in T(k) qquad t + (A_1^T baru - c_1)^T x leq b^T baru \n  forall bary in Q(k) qquad (A_1 ^T bary)^T x leq b^T bary \n  qquad qquad qquad  x succeq 0 x in mathbbZ^n\nendaligned","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Let the maximizer corresponding to the objective value f_textm^(k) be denoted by x^(k). Now there are three possibilities:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"If f_textm^(k)=-infty, i.e., the master problem is infeasible, then the original problem is infeasible and sadly, we are done.\nIf f_textm^(k)=infty, i.e. the master problem is unbounded above, then we take f_textm^(k) to be arbitrarily large and x^(k) to be a corresponding feasible solution. Go to Step 3.\nIf f_textm^(k) is finite, then we collect t^(k) and x^(k) and go to Step 3.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Step 3 (Solving the subproblem and add Benders cut when needed)","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Solve the subproblem, f_s(x^(k)) =","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"beginaligned\n  c_1^T x^(k) +  textminimize   (b-A_1 x^(k))^T u \n   textsubject to  A_2^T u succeq c_2 \n    u succeq 0 u in mathbbR^m\nendaligned","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Let the minimizer corresponding to the objective value f_s(x^(k)) be denoted by u^(k). There are three possibilities:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"If f_s(x^(k)) = infty, the original problem is either infeasible or unbounded. We quit from Benders algorithm and use special purpose algorithm to find a feasible solution if there exists one.\nIf f_s(x^(k)) = - infty, we arrive at an extreme ray y^(k). We add the Benders cut corresponding to this extreme ray (A_1 ^T y^(k))^T x leq b^T y^(k) to the master problem, i.e., Q(k+1)= Q(k) cup y^(k). Take k=k+1 and go to Step 3.\nIf f_s(x^(k)) is finite, then\nIf f_s(x^(k))=f_m^(k) we arrive at the optimal solution.  The optimum objective value of the original problem is f_s(x^(k))=f_m^(k),  an optimal x is x^(k) and an optimal v is the dual values for the  second constraints of the subproblem. We are happily done!\nIf f_s(x^(k))  f_m^(k) we get an suboptimal vertex u^(k). We add  the corresponding Benders cut u_0 + (A_1^T u^(k) - c_1)^T x leq b^T u^(k)  to the master problem, i.e., T(k+1) = T(k) cup u^(k). Take k=k+1  and go to Step 3.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"For a more general approach to Bender's Decomposition you can have a look at Mathieu Besançon's blog.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/#Input-data","page":"Benders decomposition","title":"Input data","text":"","category":"section"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"The input data is from page 139, Integer programming by Garfinkel and Nemhauser[1].","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"c1 = [-1; -4]\nc2 = [-2; -3]\n\ndim_x = length(c1)\ndim_u = length(c2)\n\nb = [-2; -3]\n\nA1 = [\n    1 -3\n    -1 -3\n]\nA2 = [\n    1 -2\n    -1 -1\n]\n\nM = 1000;\nnothing #hide","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/#Implementation","page":"Benders decomposition","title":"Implementation","text":"","category":"section"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"There are two ways we can implement Benders decomposition in JuMP:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Classical approach: Adding the Benders cuts in a loop\nModern approach: Adding the Benders cuts as lazy constraints","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"This tutorial implements the classical approach.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"The classical approach may be inferior to the modern one, because the solver","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"might revisit previously eliminated solution\nmight discard the optimal solution to the original problem in favor of a better but ultimately infeasible solution to the relaxed one.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"For more details on the comparison between the two approaches, see Paul Rubin's blog on Benders Decomposition.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Let's describe the master problem first. Note that there are no constraints, which we will added later using Benders decomposition.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/#Loading-the-necessary-packages","page":"Benders decomposition","title":"Loading the necessary packages","text":"","category":"section"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"using JuMP\nimport GLPK\nimport Test","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/#Master-problem-description","page":"Benders decomposition","title":"Master problem description","text":"","category":"section"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"master_problem_model = Model(GLPK.Optimizer)\n@variable(master_problem_model, 0 <= x[1:dim_x] <= 1e6, Int)\n@variable(master_problem_model, t <= 1e6)\n@objective(master_problem_model, Max, t)\nglobal iter_num = 1\n\nprint(master_problem_model)","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Here is the loop that checks the status of the master problem and the subproblem and then adds necessary Benders cuts accordingly.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"iter_num = 1\n\nwhile true\n    println(\"\\n-----------------------\")\n    println(\"Iteration number = \", iter_num)\n    println(\"-----------------------\\n\")\n    println(\"The current master problem is\")\n    print(master_problem_model)\n\n    optimize!(master_problem_model)\n\n    t_status = termination_status(master_problem_model)\n    p_status = primal_status(master_problem_model)\n\n    if p_status == INFEASIBLE_POINT\n        println(\"The problem is infeasible :-(\")\n        break\n    end\n\n    (fm_current, x_current) = if t_status == INFEASIBLE_OR_UNBOUNDED\n        (M, M * ones(dim_x))\n    elseif p_status == FEASIBLE_POINT\n        (value(t), value.(x))\n    else\n        error(\"Unexpected status: $((t_status, p_status))\")\n    end\n\n    println(\n        \"Status of the master problem is \",\n        t_status,\n        \"\\nwith fm_current = \",\n        fm_current,\n        \"\\nx_current = \",\n        x_current,\n    )\n\n    sub_problem_model = Model(GLPK.Optimizer)\n\n    c_sub = b - A1 * x_current\n\n    local u = @variable(sub_problem_model, u[1:dim_u] >= 0)\n\n    @constraint(\n        sub_problem_model,\n        constr_ref_subproblem[j = 1:size(A2, 2)],\n        A2[:, j]' * u >= c2[j],\n    )\n    # The second argument of @constraint macro,\n    # constr_ref_subproblem[j=1:size(A2,2)] means that the j-th constraint is\n    # referenced by constr_ref_subproblem[j].\n\n    @objective(sub_problem_model, Min, c1' * x_current + c_sub' * u)\n\n    print(\"\\nThe current subproblem model is \\n\")\n    print(sub_problem_model)\n\n    optimize!(sub_problem_model)\n\n    t_status_sub = termination_status(sub_problem_model)\n    p_status_sub = primal_status(sub_problem_model)\n\n    fs_x_current = objective_value(sub_problem_model)\n\n    u_current = value.(u)\n\n    γ = b' * u_current\n\n    println(\n        \"Status of the subproblem is \",\n        t_status_sub,\n        \"\\nwith fs_x_current = \",\n        fs_x_current,\n        \"\\nand fm_current = \",\n        fm_current,\n    )\n\n    if p_status_sub == FEASIBLE_POINT && fs_x_current == fm_current # we are done\n        Test.@test value(t) ≈ -4 #hide\n        println(\"\\n################################################\")\n        println(\"Optimal solution of the original problem found\")\n        println(\"The optimal objective value t is \", fm_current)\n        println(\"The optimal x is \", x_current)\n        println(\"The optimal v is \", dual.(constr_ref_subproblem))\n        println(\"################################################\\n\")\n        break\n    end\n\n    if p_status_sub == FEASIBLE_POINT && fs_x_current < fm_current\n        println(\n            \"\\nThere is a suboptimal vertex, add the corresponding constraint\",\n        )\n        cv = A1' * u_current - c1\n        @constraint(master_problem_model, t + cv' * x <= γ)\n        println(\"t + \", cv, \"ᵀ x <= \", γ)\n    end\n\n    if t_status_sub == INFEASIBLE_OR_UNBOUNDED\n        println(\n            \"\\nThere is an  extreme ray, adding the corresponding constraint\",\n        )\n        ce = A1' * u_current\n        @constraint(master_problem_model, ce' * x <= γ)\n        println(ce, \"ᵀ x <= \", γ)\n    end\n\n    global iter_num += 1\nend","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/#References","page":"Benders decomposition","title":"References","text":"","category":"section"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"<a id='c1'></a>","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Garfinkel, R. & Nemhauser, G. L. Integer programming. (Wiley, 1972).","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"tutorials/conic/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/conic/cluster.jl\"","category":"page"},{"location":"tutorials/conic/cluster/#K-means-clustering-via-SDP","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"","category":"section"},{"location":"tutorials/conic/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"From \"Approximating K-means-type clustering via semidefinite programming\" By Jiming Peng and Yu Wei.","category":"page"},{"location":"tutorials/conic/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"Given a set of points a_1 ldots a_m  in R_n, allocate them to k clusters.","category":"page"},{"location":"tutorials/conic/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"using JuMP\nimport LinearAlgebra\nimport SCS\n\nfunction example_cluster(; verbose = true)\n    # Data points\n    n = 2\n    m = 6\n    a = Any[\n        [2.0, 2.0],\n        [2.5, 2.1],\n        [7.0, 7.0],\n        [2.2, 2.3],\n        [6.8, 7.0],\n        [7.2, 7.5],\n    ]\n    k = 2\n    # Weight matrix\n    W = zeros(m, m)\n    for i in 1:m\n        for j in i+1:m\n            W[i, j] = W[j, i] = exp(-LinearAlgebra.norm(a[i] - a[j]) / 1.0)\n        end\n    end\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    # Z >= 0, PSD\n    @variable(model, Z[1:m, 1:m], PSD)\n    @constraint(model, Z .>= 0)\n    # min Tr(W(I-Z))\n    I = Matrix(1.0 * LinearAlgebra.I, m, m)\n    @objective(model, Min, LinearAlgebra.tr(W * (I - Z)))\n    # Z e = e\n    @constraint(model, Z * ones(m) .== ones(m))\n    # Tr(Z) = k\n    @constraint(model, LinearAlgebra.tr(Z) == k)\n    optimize!(model)\n    Z_val = value.(Z)\n    # A simple rounding scheme\n    which_cluster = zeros(Int, m)\n    num_clusters = 0\n    for i in 1:m\n        if Z_val[i, i] <= 1e-3\n            continue\n        elseif which_cluster[i] == 0\n            num_clusters += 1\n            which_cluster[i] = num_clusters\n            for j in i+1:m\n                if LinearAlgebra.norm(Z_val[i, j] - Z_val[i, i]) <= 1e-3\n                    which_cluster[j] = num_clusters\n                end\n            end\n        end\n    end\n    if verbose\n        # Print results\n        for cluster in 1:k\n            println(\"Cluster $cluster\")\n            for i in 1:m\n                if which_cluster[i] == cluster\n                    println(a[i])\n                end\n            end\n        end\n    end\n    return\nend\n\nexample_cluster()","category":"page"},{"location":"tutorials/conic/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"","category":"page"},{"location":"tutorials/conic/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/conic/tips_and_tricks.jl\"","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Tips-and-Tricks","page":"Tips and Tricks","title":"Tips and Tricks","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"This tutorial is aimed at providing a simplistic introduction to conic programming using JuMP.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"It uses the following packages:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"using JuMP\nimport SCS\nimport LinearAlgebra","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"info: Info\nThis tutorial uses sets from MathOptInterface. By default, JuMP exports the MOI symbol as an alias for the MathOptInterface.jl package. We recommend making this more explicit in your code by adding the following lines:import MathOptInterface\nconst MOI = MathOptInterface","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"import Random      # hide\nRandom.seed!(1234) # hide\nnothing            # hide","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"tip: Tip\nA good resource for learning more about functions which can be modeled using cones is the MOSEK Modeling Cookbook.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#What-is-a-cone?","page":"Tips and Tricks","title":"What is a cone?","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A subset C of a vector space V is a cone if forall x in C and positive scalars lambda  0, the product lambda x in C.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A cone C is a convex cone if lambda x + (1 - lambda) y in C, for any lambda in 0 1, and any x y in C.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#What-is-a-conic-program?","page":"Tips and Tricks","title":"What is a conic program?","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Conic programming problems are convex optimization problems in which a convex function is minimized over the intersection of an affine subspace and a convex cone. An example of a conic-form minimization problems, in the primal form is:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\n min_x in mathbbR^n  a_0^T x + b_0 \n textst  A_i x + b_i  in mathcalC_i  i = 1 ldots m\nendaligned","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The corresponding dual problem is:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\n max_y_1 ldots y_m  -sum_i=1^m b_i^T y_i + b_0 \n textst  a_0 - sum_i=1^m A_i^T y_i  = 0 \n  y_i  in mathcalC_i^*  i = 1 ldots m\nendaligned","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"where each mathcalC_i is a closed convex cone and mathcalC_i^* is its dual cone.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Second-Order-Cone","page":"Tips and Tricks","title":"Second-Order Cone","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The Second-Order Cone (or Lorentz Cone) of dimension n is of the form:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Q^n =  (t x) in mathbbR^n  t ge x_2 ","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Example","page":"Tips and Tricks","title":"Example","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Minimize the L2 norm of a vector x.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"model = Model()\n@variable(model, x[1:3])\n@variable(model, norm_x)\n@constraint(model, [norm_x; x] in SecondOrderCone())\n@objective(model, Min, norm_x)","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Rotated-Second-Order-Cone","page":"Tips and Tricks","title":"Rotated Second-Order Cone","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A Second-Order Cone rotated by pi4 in the (x_1x_2) plane is called a Rotated Second-Order Cone. It is of the form:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Q_r^n =  (tux) in mathbbR^n  2tu ge x_2^2 tu ge 0 ","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Example-2","page":"Tips and Tricks","title":"Example","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Given a set of predictors x, and observations y, find the parameter theta that minimizes the sum of squares loss between y_i and theta x_i.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"x = [1.0, 2.0, 3.0, 4.0]\ny = [0.45, 1.04, 1.51, 1.97]\nmodel = Model()\n@variable(model, θ)\n@variable(model, loss)\n@constraint(model, [loss; 0.5; θ .* x .- y] in RotatedSecondOrderCone())\n@objective(model, Min, loss)","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Exponential-Cone","page":"Tips and Tricks","title":"Exponential Cone","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"An Exponential Cone is a set of the form:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"K_exp =  (xyz) in mathbbR^3  y exp (xy) le z y  0 ","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"model = Model()\n@variable(model, x[1:3] >= 0)\n@constraint(model, x in MOI.ExponentialCone())\n@objective(model, Min, x[3])","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Example:-Entropy-Maximization","page":"Tips and Tricks","title":"Example: Entropy Maximization","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The entropy maximization problem consists of maximizing the entropy function, H(x) = -xlogx subject to linear inequality constraints.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\n max  - sum_i=1^n x_i log x_i \n textst  mathbf1 x = 1 \n  Ax leq b\nendaligned","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"We can model this problem using an exponential cone by using the following transformation:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"tleq -xlogx iff tleq xlog(1x)  iff (t x 1) in K_exp","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Thus, our problem becomes,","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\n max  1^Tt \n textst  Ax leq b \n  1^T x = 1 \n  (t_i x_i 1) in K_exp  forall i = 1 ldots n \nendaligned","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"n = 15\nm = 10\nA = randn(m, n)\nb = rand(m, 1)\n\nmodel = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, t[1:n])\n@variable(model, x[1:n])\n@objective(model, Max, sum(t))\n@constraint(model, sum(x) == 1)\n@constraint(model, A * x .<= b)\n@constraint(model, con[i = 1:n], [t[i], x[i], 1] in MOI.ExponentialCone())\noptimize!(model)","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"objective_value(model)","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Positive-Semidefinite-Cone","page":"Tips and Tricks","title":"Positive Semidefinite Cone","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The set of positive semidefinite matrices (PSD) of dimension n form a cone in mathbbR^n. We write this set mathematically as:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"mathcalS_+^n =  X in mathcalS^n mid z^T X z geq 0  forall zin mathbbR^n ","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A PSD cone is represented in JuMP using the MOI sets PositiveSemidefiniteConeTriangle (for upper triangle of a PSD matrix) and PositiveSemidefiniteConeSquare (for a complete PSD matrix). However, it is preferable to use the PSDCone shortcut as illustrated below.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Example:-largest-eigenvalue-of-a-symmetric-matrix","page":"Tips and Tricks","title":"Example: largest eigenvalue of a symmetric matrix","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Suppose A has eigenvalues lambda_1 geq lambda_2 ldots geq lambda_n. Then the matrix t I-A has eigenvalues t-lambda_1 t-lambda_2 ldots t-lambda_n. Note that t I-A is PSD exactly when all these eigenvalues are non-negative, and this happens for values t geq lambda_1. Thus, we can model the problem of finding the largest eigenvalue of a symmetric matrix as:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\nlambda_1 = min t \ntext  st  t I-A succeq 0\nendaligned","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A = [3 2 4; 2 0 2; 4 2 3]\nI = Matrix{Float64}(LinearAlgebra.I, 3, 3)\nmodel = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, t)\n@objective(model, Min, t)\n@constraint(model, t .* I - A in PSDCone())\n\noptimize!(model)","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"objective_value(model)","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Other-Cones-and-Functions","page":"Tips and Tricks","title":"Other Cones and Functions","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"For other cones supported by JuMP, check out the MathOptInterface Manual.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/linear/facility_location.jl\"","category":"page"},{"location":"tutorials/linear/facility_location/#The-facility-location-problem","page":"The facility location problem","title":"The facility location problem","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"It was originally contributed by Mathieu Tanneau (@mtanneau) and Alexis Montoison (@amontoison).","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"using JuMP\nimport GLPK\nimport LinearAlgebra\nimport Plots\nimport Random","category":"page"},{"location":"tutorials/linear/facility_location/#Uncapacitated-facility-location","page":"The facility location problem","title":"Uncapacitated facility location","text":"","category":"section"},{"location":"tutorials/linear/facility_location/#Problem-description","page":"The facility location problem","title":"Problem description","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"We are given","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"A set M=1 dots m of clients\nA set N= 1 dots n of sites where a facility can be built","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Decision variables Decision variables are split into two categories:","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Binary variable y_j indicates whether facility j is built or not\nBinary variable x_i j indicates whether client i is assigned to facility j","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Objective The objective is to minimize the total cost of serving all clients. This costs breaks down into two components:","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Fixed cost of building a facility.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"In this example, this cost is f_j = 1  forall j.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Cost of serving clients from the assigned facility.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"In this example, the cost c_i j of serving client i from facility j is the Euclidean distance between the two.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Constraints","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Each customer must be served by exactly one facility\nA facility cannot serve any client unless it is open","category":"page"},{"location":"tutorials/linear/facility_location/#MILP-formulation","page":"The facility location problem","title":"MILP formulation","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"The problem can be formulated as the following MILP:","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"beginaligned\nmin_x y    \nsum_i j c_i j x_i j +\nsum_j f_j y_j \nst \nsum_j x_i j = 1  forall i in M \n x_i j leq y_j  forall i in M j in N \n x_i j y_j in 0 1  forall i in M j in N\nendaligned","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"where the first set of constraints ensures that each client is served exactly once, and the second set of constraints ensures that no client is served from an unopened facility.","category":"page"},{"location":"tutorials/linear/facility_location/#Problem-data","page":"The facility location problem","title":"Problem data","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Random.seed!(314)\n\n# number of clients\nm = 12\n# number of facility locations\nn = 5\n\n# Clients' locations\nXc = rand(m)\nYc = rand(m)\n\n# Facilities' potential locations\nXf = rand(n)\nYf = rand(n)\n\n# Fixed costs\nf = ones(n);\n\n# Distance\nc = zeros(m, n)\nfor i in 1:m\n    for j in 1:n\n        c[i, j] = LinearAlgebra.norm([Xc[i] - Xf[j], Yc[i] - Yf[j]], 2)\n    end\nend","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Display the data","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Plots.scatter(\n    Xc,\n    Yc,\n    label = \"Clients\",\n    markershape = :circle,\n    markercolor = :blue,\n)\nPlots.scatter!(\n    Xf,\n    Yf,\n    label = \"Facility\",\n    markershape = :square,\n    markercolor = :white,\n    markersize = 6,\n    markerstrokecolor = :red,\n    markerstrokewidth = 2,\n)","category":"page"},{"location":"tutorials/linear/facility_location/#JuMP-implementation","page":"The facility location problem","title":"JuMP implementation","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Create a JuMP model","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"ufl = Model(GLPK.Optimizer)","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Variables","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"@variable(ufl, y[1:n], Bin);\n@variable(ufl, x[1:m, 1:n], Bin);\nnothing #hide","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Each client is served exactly once","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"@constraint(ufl, client_service[i in 1:m], sum(x[i, j] for j in 1:n) == 1);\nnothing #hide","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"A facility must be open to serve a client","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"@constraint(ufl, open_facility[i in 1:m, j in 1:n], x[i, j] <= y[j]);\nnothing #hide","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Objective","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"@objective(ufl, Min, f'y + sum(c .* x));\nnothing #hide","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Solve the uncapacitated facility location problem with GLPK","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"optimize!(ufl)\nprintln(\"Optimal value: \", objective_value(ufl))","category":"page"},{"location":"tutorials/linear/facility_location/#Visualizing-the-solution","page":"The facility location problem","title":"Visualizing the solution","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"The threshold 1e-5 ensure that edges between clients and facilities are drawn when x[i, j] ≈ 1.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"x_ = value.(x) .> 1 - 1e-5\ny_ = value.(y) .> 1 - 1e-5","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Display clients","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"p = Plots.scatter(\n    Xc,\n    Yc,\n    markershape = :circle,\n    markercolor = :blue,\n    label = nothing,\n)","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Show open facility","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"mc = [(y_[j] ? :red : :white) for j in 1:n]\nPlots.scatter!(\n    Xf,\n    Yf,\n    markershape = :square,\n    markercolor = mc,\n    markersize = 6,\n    markerstrokecolor = :red,\n    markerstrokewidth = 2,\n    label = nothing,\n)","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Show client-facility assignment","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"for i in 1:m\n    for j in 1:n\n        if x_[i, j] == 1\n            Plots.plot!(\n                [Xc[i], Xf[j]],\n                [Yc[i], Yf[j]],\n                color = :black,\n                label = nothing,\n            )\n        end\n    end\nend\n\np","category":"page"},{"location":"tutorials/linear/facility_location/#Capacitated-facility-location","page":"The facility location problem","title":"Capacitated facility location","text":"","category":"section"},{"location":"tutorials/linear/facility_location/#Problem-formulation","page":"The facility location problem","title":"Problem formulation","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"The capacitated variant introduces a capacity constraint on each facility, i.e., clients have a certain level of demand to be served, while each facility only has finite capacity which cannot be exceeded.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Specifically,","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"The demand of client i is denoted by a_i geq 0\nThe capacity of facility j is denoted by q_j geq 0","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"The capacity constraints then write","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"beginaligned\nsum_i a_i x_i j leq q_j y_j  forall j in N\nendaligned","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Note that, if y_j is set to 0, the capacity constraint above automatically forces x_i j to 0.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Thus, the capacitated facility location can be formulated as follows","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"beginaligned\nmin_x y    \nsum_i j c_i j x_i j +\nsum_j f_j y_j \nst \nsum_j x_i j = 1  forall i in M \n sum_i a_i x_i j leq q_j y_j  forall j in N \n x_i j y_j in 0 1  forall i in M j in N\nendaligned","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"For simplicity, we will assume that there is enough capacity to serve the demand,  i.e., there exists at least one feasible solution.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Demands","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"a = rand(1:3, m);\nnothing #hide","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Capacities","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"q = rand(5:10, n);\nnothing #hide","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Display the data","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Plots.scatter(\n    Xc,\n    Yc,\n    label = nothing,\n    markershape = :circle,\n    markercolor = :blue,\n    markersize = 2 .* (2 .+ a),\n)\n\nPlots.scatter!(\n    Xf,\n    Yf,\n    label = nothing,\n    markershape = :rect,\n    markercolor = :white,\n    markersize = q,\n    markerstrokecolor = :red,\n    markerstrokewidth = 2,\n)","category":"page"},{"location":"tutorials/linear/facility_location/#JuMP-implementation-2","page":"The facility location problem","title":"JuMP implementation","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Create a JuMP model","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"cfl = Model(GLPK.Optimizer)","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Variables","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"@variable(cfl, y[1:n], Bin);\n@variable(cfl, x[1:m, 1:n], Bin);\nnothing #hide","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Each client is served exactly once","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"@constraint(cfl, client_service[i in 1:m], sum(x[i, :]) == 1);\nnothing #hide","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Capacity constraint","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"@constraint(cfl, capacity, x'a .<= (q .* y));\nnothing #hide","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Objective","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"@objective(cfl, Min, f'y + sum(c .* x));\nnothing #hide","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Solve the problem","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"optimize!(cfl)\nprintln(\"Optimal value: \", objective_value(cfl))","category":"page"},{"location":"tutorials/linear/facility_location/#Visualizing-the-solution-2","page":"The facility location problem","title":"Visualizing the solution","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"The threshold 1e-5 ensure that edges between clients and facilities are drawn when x[i, j] ≈ 1.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"x_ = value.(x) .> 1 - 1e-5;\ny_ = value.(y) .> 1 - 1e-5;\nnothing #hide","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Display the solution","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"p = Plots.scatter(\n    Xc,\n    Yc,\n    label = nothing,\n    markershape = :circle,\n    markercolor = :blue,\n    markersize = 2 .* (2 .+ a),\n)\n\nmc = [(y_[j] ? :red : :white) for j in 1:n]\nPlots.scatter!(\n    Xf,\n    Yf,\n    label = nothing,\n    markershape = :rect,\n    markercolor = mc,\n    markersize = q,\n    markerstrokecolor = :red,\n    markerstrokewidth = 2,\n)","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Show client-facility assignment","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"for i in 1:m\n    for j in 1:n\n        if x_[i, j] == 1\n            Plots.plot!(\n                [Xc[i], Xf[j]],\n                [Yc[i], Yf[j]],\n                color = :black,\n                label = nothing,\n            )\n            break\n        end\n    end\nend\np","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"reference/nlp/#NonlinearAPI","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"More information can be found in the Nonlinear Modeling section of the manual.","category":"page"},{"location":"reference/nlp/#ref_nl_constraints","page":"Nonlinear Modeling","title":"Constraints","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLconstraint\n@NLconstraints\nNonlinearConstraintIndex\nnum_nl_constraints\nadd_NL_constraint\nall_nl_constraints","category":"page"},{"location":"reference/nlp/#JuMP.@NLconstraint","page":"Nonlinear Modeling","title":"JuMP.@NLconstraint","text":"@NLconstraint(m::Model, expr)\n\nAdd a constraint described by the nonlinear expression expr. See also @constraint. For example:\n\n@NLconstraint(model, sin(x) <= 1)\n@NLconstraint(model, [i = 1:3], sin(i * x) <= 1 / i)\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.@NLconstraints","page":"Nonlinear Modeling","title":"JuMP.@NLconstraints","text":"@NLconstraints(model, args...)\n\nAdds multiple nonlinear constraints to model at once, in the same fashion as the @NLconstraint macro.\n\nThe model must be the first argument, and multiple constraints can be added on multiple lines wrapped in a begin ... end block.\n\nThe macro returns a tuple containing the constraints that were defined.\n\nExamples\n\n@NLconstraints(model, begin\n    t >= sqrt(x^2 + y^2)\n    [i = 1:2], z[i] <= log(a[i])\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.NonlinearConstraintIndex","page":"Nonlinear Modeling","title":"JuMP.NonlinearConstraintIndex","text":"NonlinearConstraintIndex(index::Int64)\n\nA struct to refer to the 1-indexed nonlinear constraint index.\n\n\n\n\n\n","category":"type"},{"location":"reference/nlp/#JuMP.num_nl_constraints","page":"Nonlinear Modeling","title":"JuMP.num_nl_constraints","text":"num_nl_constraints(model::Model)\n\nReturns the number of nonlinear constraints associated with the model.\n\n\n\n\n\n","category":"function"},{"location":"reference/nlp/#JuMP.add_NL_constraint","page":"Nonlinear Modeling","title":"JuMP.add_NL_constraint","text":"add_NL_constraint(model::Model, expr::Expr)\n\nAdd a nonlinear constraint described by the Julia expression ex to model.\n\nThis function is most useful if the expression ex is generated programmatically, and you cannot use @NLconstraint.\n\nNotes\n\nYou must interpolate the variables directly into the expression expr.\n\nExamples\n\njulia> add_NL_constraint(model, :($(x) + $(x)^2 <= 1))\n(x + x ^ 2.0) - 1.0 ≤ 0\n\n\n\n\n\n","category":"function"},{"location":"reference/nlp/#JuMP.all_nl_constraints","page":"Nonlinear Modeling","title":"JuMP.all_nl_constraints","text":"all_nl_constraints(model::Model)\n\nReturn a vector of all nonlinear constraint references in the model in the order they were added to the model.\n\n\n\n\n\n","category":"function"},{"location":"reference/nlp/#ref_nl_expressions","page":"Nonlinear Modeling","title":"Expressions","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLexpression\n@NLexpressions\nNonlinearExpression\nadd_NL_expression","category":"page"},{"location":"reference/nlp/#JuMP.@NLexpression","page":"Nonlinear Modeling","title":"JuMP.@NLexpression","text":"@NLexpression(args...)\n\nEfficiently build a nonlinear expression which can then be inserted in other nonlinear constraints and the objective. See also [@expression]. For example:\n\n@NLexpression(model, my_expr, sin(x)^2 + cos(x^2))\n@NLconstraint(model, my_expr + y >= 5)\n@NLobjective(model, Min, my_expr)\n\nIndexing over sets and anonymous expressions are also supported:\n\n@NLexpression(m, my_expr_1[i=1:3], sin(i * x))\nmy_expr_2 = @NLexpression(m, log(1 + sum(exp(x[i])) for i in 1:2))\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.@NLexpressions","page":"Nonlinear Modeling","title":"JuMP.@NLexpressions","text":"@NLexpressions(model, args...)\n\nAdds multiple nonlinear expressions to model at once, in the same fashion as the @NLexpression macro.\n\nThe model must be the first argument, and multiple expressions can be added on multiple lines wrapped in a begin ... end block.\n\nThe macro returns a tuple containing the expressions that were defined.\n\nExamples\n\n@NLexpressions(model, begin\n    my_expr, sqrt(x^2 + y^2)\n    my_expr_1[i = 1:2], log(a[i]) - z[i]\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.NonlinearExpression","page":"Nonlinear Modeling","title":"JuMP.NonlinearExpression","text":"NonlinearExpression <: AbstractJuMPScalar\n\nA struct to represent a nonlinear expression.\n\nCreate an expression using @NLexpression.\n\n\n\n\n\n","category":"type"},{"location":"reference/nlp/#JuMP.add_NL_expression","page":"Nonlinear Modeling","title":"JuMP.add_NL_expression","text":"add_NL_expression(model::Model, expr::Expr)\n\nAdd a nonlinear expression expr to model.\n\nThis function is most useful if the expression expr is generated programmatically, and you cannot use @NLexpression.\n\nNotes\n\nYou must interpolate the variables directly into the expression expr.\n\nExamples\n\njulia> add_NL_expression(model, :($(x) + $(x)^2))\nsubexpression[1]: x + x ^ 2.0\n\n\n\n\n\n","category":"function"},{"location":"reference/nlp/#ref_nl_objectives","page":"Nonlinear Modeling","title":"Objectives","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLobjective\nset_NL_objective","category":"page"},{"location":"reference/nlp/#JuMP.@NLobjective","page":"Nonlinear Modeling","title":"JuMP.@NLobjective","text":"@NLobjective(model, sense, expression)\n\nAdd a nonlinear objective to model with optimization sense sense. sense must be Max or Min.\n\nExample\n\n@NLobjective(model, Max, 2x + 1 + sin(x))\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.set_NL_objective","page":"Nonlinear Modeling","title":"JuMP.set_NL_objective","text":"set_NL_objective(model::Model, sense::MOI.OptimizationSense, expr::Expr)\n\nSet the nonlinear objective of model to the expression expr, with the optimization sense sense.\n\nThis function is most useful if the expression expr is generated programmatically, and you cannot use @NLobjective.\n\nNotes\n\nYou must interpolate the variables directly into the expression expr.\nYou must use MIN_SENSE or MAX_SENSE instead of Min and Max.\n\nExamples\n\njulia> set_NL_objective(model, MIN_SENSE, :($(x) + $(x)^2))\n\n\n\n\n\n","category":"function"},{"location":"reference/nlp/#ref_nl_parameters","page":"Nonlinear Modeling","title":"Parameters","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLparameter\n@NLparameters\nNonlinearParameter\nvalue(::JuMP.NonlinearParameter)\nset_value(::JuMP.NonlinearParameter, ::Number)","category":"page"},{"location":"reference/nlp/#JuMP.@NLparameter","page":"Nonlinear Modeling","title":"JuMP.@NLparameter","text":"@NLparameter(model, param == value)\n\nCreate and return a nonlinear parameter param attached to the model model with initial value set to value. Nonlinear parameters may be used only in nonlinear expressions.\n\nExample\n\nmodel = Model()\n@NLparameter(model, x == 10)\nvalue(x)\n\n# output\n10.0\n\n@NLparameter(model, value = param_value)\n\nCreate and return an anonymous nonlinear parameter param attached to the model model with initial value set to param_value. Nonlinear parameters may be used only in nonlinear expressions.\n\nExample\n\nmodel = Model()\nx = @NLparameter(model, value = 10)\nvalue(x)\n\n# output\n10.0\n\n@NLparameter(model, param_collection[...] == value_expr)\n\nCreate and return a collection of nonlinear parameters param_collection attached to the model model with initial value set to value_expr (may depend on index sets). Uses the same syntax for specifying index sets as @variable.\n\nExample\n\nmodel = Model()\n@NLparameter(model, y[i = 1:10] == 2 * i)\nvalue(y[9])\n\n# output\n18.0\n\n@NLparameter(model, [...] == value_expr)\n\nCreate and return an anonymous collection of nonlinear parameters attached to the model model with initial value set to value_expr (may depend on index sets). Uses the same syntax for specifying index sets as @variable.\n\nExample\n\nmodel = Model()\ny = @NLparameter(model, [i = 1:10] == 2 * i)\nvalue(y[9])\n\n# output\n18.0\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.@NLparameters","page":"Nonlinear Modeling","title":"JuMP.@NLparameters","text":" @NLparameters(model, args...)\n\nCreate and return multiple nonlinear parameters attached to model model, in the same fashion as @NLparameter macro.\n\nThe model must be the first argument, and multiple parameters can be added on multiple lines wrapped in a begin ... end block. Distinct parameters need to be placed on separate lines as in the following example.\n\nThe macro returns a tuple containing the parameters that were defined.\n\nExample\n\nmodel = Model()\n@NLparameters(model, begin\n    x == 10\n    b == 156\nend)\nvalue(x)\n\n# output\n10.0\n\n\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.NonlinearParameter","page":"Nonlinear Modeling","title":"JuMP.NonlinearParameter","text":"NonlinearParameter <: AbstractJuMPScalar\n\nA struct to represent a nonlinear parameter.\n\nCreate a parameter using @NLparameter.\n\n\n\n\n\n","category":"type"},{"location":"reference/nlp/#JuMP.value-Tuple{NonlinearParameter}","page":"Nonlinear Modeling","title":"JuMP.value","text":"value(p::NonlinearParameter)\n\nReturn the current value stored in the nonlinear parameter p.\n\nExample\n\nmodel = Model()\n@NLparameter(model, p == 10)\nvalue(p)\n\n# output\n10.0\n\n\n\n\n\n","category":"method"},{"location":"reference/nlp/#JuMP.set_value-Tuple{NonlinearParameter, Number}","page":"Nonlinear Modeling","title":"JuMP.set_value","text":"set_value(p::NonlinearParameter, v::Number)\n\nStore the value v in the nonlinear parameter p.\n\nExample\n\nmodel = Model()\n@NLparameter(model, p == 0)\nset_value(p, 5)\nvalue(p)\n\n# output\n5.0\n\n\n\n\n\n","category":"method"},{"location":"reference/nlp/#User-defined-functions","page":"Nonlinear Modeling","title":"User-defined functions","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"register","category":"page"},{"location":"reference/nlp/#JuMP.register","page":"Nonlinear Modeling","title":"JuMP.register","text":"register(\n    model::Model,\n    s::Symbol,\n    dimension::Integer,\n    f::Function;\n    autodiff:Bool = false,\n)\n\nRegister the user-defined function f that takes dimension arguments in model as the symbol s.\n\nThe function f must support all subtypes of Real as arguments. Do not assume that the inputs are Float64.\n\nNotes\n\nFor this method, you must explicitly set autodiff = true, because no user-provided gradient function ∇f is given.\nSecond-derivative information is only computed if dimension == 1.\ns does not have to be the same symbol as f, but it is generally more readable if it is.\n\nExamples\n\nmodel = Model()\n@variable(model, x)\nf(x::T) where {T<:Real} = x^2\nregister(model, :foo, 1, f; autodiff = true)\n@NLobjective(model, Min, foo(x))\n\nmodel = Model()\n@variable(model, x[1:2])\ng(x::T, y::T) where {T<:Real} = x * y\nregister(model, :g, 2, g; autodiff = true)\n@NLobjective(model, Min, g(x[1], x[2]))\n\n\n\n\n\nregister(\n    model::Model,\n    s::Symbol,\n    dimension::Integer,\n    f::Function,\n    ∇f::Function;\n    autodiff:Bool = false,\n)\n\nRegister the user-defined function f that takes dimension arguments in model as the symbol s. In addition, provide a gradient function ∇f.\n\nThe functions fand ∇f must support all subtypes of Real as arguments. Do not assume that the inputs are Float64.\n\nNotes\n\nIf the function f is univariate (i.e., dimension == 1), ∇f must return a number which represents the first-order derivative of the function f.\nIf the function f is multi-variate, ∇f must have a signature matching ∇f(g::AbstractVector{T}, args::T...) where {T<:Real}, where the first argument is a vector g that is modified in-place with the gradient.\nIf autodiff = true and dimension == 1, use automatic differentiation to compute the second-order derivative information. If autodiff = false, only first-order derivative information will be used.\ns does not have to be the same symbol as f, but it is generally more readable if it is.\n\nExamples\n\nmodel = Model()\n@variable(model, x)\nf(x::T) where {T<:Real} = x^2\n∇f(x::T) where {T<:Real} = 2 * x\nregister(model, :foo, 1, f, ∇f; autodiff = true)\n@NLobjective(model, Min, foo(x))\n\nmodel = Model()\n@variable(model, x[1:2])\ng(x::T, y::T) where {T<:Real} = x * y\nfunction ∇g(g::AbstractVector{T}, x::T, y::T) where {T<:Real}\n    g[1] = y\n    g[2] = x\n    return\nend\nregister(model, :g, 2, g, ∇g; autodiff = true)\n@NLobjective(model, Min, g(x[1], x[2]))\n\n\n\n\n\nregister(\n    model::Model,\n    s::Symbol,\n    dimension::Integer,\n    f::Function,\n    ∇f::Function,\n    ∇²f::Function,\n)\n\nRegister the user-defined function f that takes dimension arguments in model as the symbol s. In addition, provide a gradient function ∇f and a hessian function ∇²f.\n\n∇f and ∇²f must return numbers corresponding to the first- and second-order derivatives of the function f respectively.\n\nNotes\n\nBecause automatic differentiation is not used, you can assume the inputs are all Float64.\nThis method will throw an error if dimension > 1.\ns does not have to be the same symbol as f, but it is generally more readable if it is.\n\nExamples\n\nmodel = Model()\n@variable(model, x)\nf(x::Float64) = x^2\n∇f(x::Float64) = 2 * x\n∇²f(x::Float64) = 2.0\nregister(model, :foo, 1, f, ∇f, ∇²f)\n@NLobjective(model, Min, foo(x))\n\n\n\n\n\n","category":"function"},{"location":"reference/nlp/#Derivatives","page":"Nonlinear Modeling","title":"Derivatives","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"NLPEvaluator","category":"page"},{"location":"reference/nlp/#JuMP.NLPEvaluator","page":"Nonlinear Modeling","title":"JuMP.NLPEvaluator","text":"NLPEvaluator(m::Model)\n\nReturn an MOI.AbstractNLPEvaluator constructed from the model model.\n\nBefore using, you must initialize the evaluator using MOI.initialize.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/getting_started/getting_started_with_julia.jl\"","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Getting-started-with-Julia","page":"Getting started with Julia","title":"Getting started with Julia","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Because JuMP is embedded in Julia, knowing some basic Julia is important before you start learning JuMP.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nThis tutorial is designed to provide a minimalist crash course in the basics of Julia. You can find resources that provide a more comprehensive introduction to Julia here.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Where-to-get-help","page":"Getting started with Julia","title":"Where to get help","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Read the documentation\nJuMP https://jump.dev/JuMP.jl/stable/\nJulia https://docs.julialang.org/en/v1/\nAsk (or browse) the Julia community forum: https://discourse.julialang.org\nIf the question is JuMP-related, ask in the Optimization (Mathematical) section, or tag your question with \"jump\"","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"To access the built-in help at the REPL, type ?, followed by the name of the function to lookup:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"help?> help\nsearch: help schedule Channel hasfield check_belongs_to_model @threadcall AbstractChannel searchsortedlast\n\n Welcome to Julia 1.6.2. The full manual is available at\n\n https://docs.julialang.org\n\n as well as many great tutorials and learning resources:\n\n https://julialang.org/learning/\n\n For help on a specific function or macro, type ? followed by its name, e.g. ?cos, or ?@time, and press enter. Type ; to enter shell mode, ] to enter package mode.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Installing-Julia","page":"Getting started with Julia","title":"Installing Julia","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"To install Julia, download the latest stable release, then follow the platform specific install instructions.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nUnless you know otherwise, you probably want the 64-bit version.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Next, you need an IDE to develop in. VS Code is a popular choice, so follow these install instructions.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Numbers-and-arithmetic","page":"Getting started with Julia","title":"Numbers and arithmetic","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Since we want to solve optimization problems, we're going to be using a lot of math. Luckily, Julia is great for math, with all the usual operators:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"@show 1 + 1\n@show 1 - 2\n@show 2 * 2\n@show 4 / 5\n@show 3^2\nnothing #hide","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nThe @ in front of something indicates that it is a macro, which is a special type of function. In this case, @show prints the expression as typed (e.g., 1 - 2), as well as the evaluation of the expression (-1).","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Did you notice how Julia didn't print .0 after some of the numbers? Julia is a dynamic language, which means you never have to explicitly declare the type of a variable. However, in the background, Julia is giving each variable a type. Check the type of something using the typeof function:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"@show typeof(1)\n@show typeof(1.0)\nnothing #hide","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Here 1 is an Int64, which is an integer with 64 bits of precision, and 1.0 is a Float64, which is a floating point number with 64-bits of precision.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nIf you aren't familiar with floating point numbers, make sure to read the Floating point numbers section.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"We create complex numbers using im:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"x = 2 + 1im\n@show real(x)\n@show imag(x)\n@show typeof(x)\n@show x * (1 - 2im)\nnothing #hide","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nThe curly brackets surround what we call the parameters of a type. You can read Complex{Int64}  as \"a complex number, where the real and imaginary parts are represented by Int64.\" If we call typeof(1.0 + 2.0im) it will be Complex{Float64}, which a complex number with the parts represented by Float64.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"There are also some cool things like an irrational representation of π.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"π","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nTo make π (and most other Greek letters), type \\pi and then press [TAB].","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(π)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"However, if we do math with irrational numbers, they get converted to Float64:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(2π / 3)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Floating-point-numbers","page":"Getting started with Julia","title":"Floating point numbers","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"warning: Warning\nIf you aren't familiar with floating point numbers, make sure to read this section carefully.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A Float64 is a floating point approximation of a real number using 64-bits of information.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Because it is an approximation, things we know hold true in mathematics don't hold true in a computer! For example:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"0.1 * 3 == 0.3","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"sin(2π / 3) == √3 / 2","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nGet √ by typing \\sqrt then press [TAB].","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Let's see what the differences are:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"0.1 * 3 - 0.3","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"sin(2π / 3) - √3 / 2","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"They are small, but not zero!","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"One way of explaining this difference is to consider how we would write 1 / 3 and 2 / 3 using only four digits after the decimal point. We would write 1 / 3 as 0.3333, and 2 / 3 as 0.6667. So, despite the fact that 2 * (1 / 3) == 2 / 3, 2 * 0.3333 == 0.6666 != 0.6667.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Let's try that again using ≈ (\\approx + [TAB]) instead of ==:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"0.1 * 3 ≈ 0.3","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"sin(2π / 3) ≈ √3 / 2","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"≈ is a clever way of calling the isapprox function:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"isapprox(sin(2π / 3), √3 / 2; atol = 1e-8)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"warning: Warning\nFloating point is the reason solvers use tolerances when they solve optimization models. A common mistake you're likely to make is checking whether a binary variable is 0 using value(z) == 0. Always remember to use something like isapprox when comparing floating point numbers.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Note that isapprox will always return false if one of the number being compared is 0 and atol is zero (its default value).","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"1e-300 ≈ 0.0","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"so always set a nonzero value of atol if one of the arguments can be zero.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"isapprox(1e-9, 0.0, atol = 1e-8)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nGurobi has a good series of articles on the implications of floating point in optimization if you want to read more.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"If you aren't careful, floating point arithmetic can throw up all manner of issues. For example:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"1 + 1e-16 == 1","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"It even turns out that floating point numbers aren't associative!","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"(1 + 1e-16) - 1e-16 == 1 + (1e-16 - 1e-16)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"It's important to note that this issue isn't Julia-specific. It happens in every programming language (try it out in Python).","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Vectors,-matrices-and-arrays","page":"Getting started with Julia","title":"Vectors, matrices and arrays","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Similar to Matlab, Julia has native support for vectors, matrices and tensors; all of which are represented by arrays of different dimensions. Vectors are constructed by comma-separated elements surrounded by square brackets:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"b = [5, 6]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Matrices can by constructed with spaces separating the columns, and semicolons separating the rows:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A = [1.0 2.0; 3.0 4.0]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"We can do linear algebra:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"x = A \\ b","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nHere is floating point at work again! x is approximately [-4, 4.5].","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A * x","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A * x ≈ b","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Note that when multiplying vectors and matrices, dimensions matter. For example, you can't multiply a vector by a vector:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"try                         #hide\n    b * b\ncatch err                   #hide\n    showerror(stderr, err)  #hide\nend                         #hide","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"But multiplying transposes works:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"b' * b","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"b * b'","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Other-common-types","page":"Getting started with Julia","title":"Other common types","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/#Strings","page":"Getting started with Julia","title":"Strings","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Double quotes are used for strings:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(\"This is Julia\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Unicode is fine in strings:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(\"π is about 3.1415\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Use println to print a string:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"println(\"Hello, World!\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Use $() to interpolate values into a string:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"x = 123\nprintln(\"The value of x is: $(x)\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Symbols","page":"Getting started with Julia","title":"Symbols","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Julia Symbols are a data structure from the compiler that represent Julia identifiers (i.e., variable names).","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"println(\"The value of x is: $(eval(:x))\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nWe used eval here to demonstrate how Julia links Symbols to variables. However, avoid calling eval in your code. It is usually a sign that your code is doing something that could be more easily achieved a different way. The Community Forum is a good place to ask for advice on alternative approaches.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(:x)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"You can think of a Symbol as a String that takes up less memory, and that can't be modified.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Convert between String and Symbol using their constructors:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"String(:abc)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Symbol(\"abc\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nSymbols are often (ab)used to stand in for a String or an Enum, when one of the former is likely a better choice. The JuMP Style guide recommends reserving Symbols for identifiers. See @enum vs. Symbol for more.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Tuples","page":"Getting started with Julia","title":"Tuples","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Julia makes extensive use of a simple data structure called Tuples. Tuples are immutable collections of values. For example:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"t = (\"hello\", 1.2, :foo)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(t)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Tuples can be accessed by index, similar to arrays:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"t[2]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"And they can be \"unpacked\" like so:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"a, b, c = t\nb","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The values can also be given names, which is a convenient way of making light-weight data structures.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"t = (word = \"hello\", num = 1.2, sym = :foo)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Values can be accessed using dot syntax:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"t.word","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Dictionaries","page":"Getting started with Julia","title":"Dictionaries","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Similar to Python, Julia has native support for dictionaries. Dictionaries provide a very generic way of mapping keys to values.  For example, a map of integers to strings:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d1 = Dict(1 => \"A\", 2 => \"B\", 4 => \"D\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nType-stuff again: Dict{Int64,String} is a dictionary with Int64 keys and String values.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Looking up a values uses the bracket syntax:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d1[2]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dictionaries support non-integer keys and can mix data types:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dict(\"A\" => 1, \"B\" => 2.5, \"D\" => 2 - 3im)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nJulia types form a hierarchy. Here the value type of the dictionary is Number, which is a generalization of Int64, Float64, and Complex{Int}. Leaf nodes in this hierarchy are called \"concrete\" types, and all others are called \"Abstract\". In general, having variables with abstract types like Number can lead to slower code, so you should try to make sure every element in a dictionary or vector is the same type. For example, in this case we could represent every element as a Complex{Float64}:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dict(\"A\" => 1.0 + 0.0im, \"B\" => 2.5 + 0.0im, \"D\" => 2.0 - 3.0im)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dictionaries can be nested:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d2 = Dict(\"A\" => 1, \"B\" => 2, \"D\" => Dict(:foo => 3, :bar => 4))","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d2[\"B\"]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d2[\"D\"][:foo]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Structs","page":"Getting started with Julia","title":"Structs","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"You can define custom datastructures with struct:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"struct MyStruct\n    x::Int\n    y::String\n    z::Dict{Int,Int}\nend\n\na = MyStruct(1, \"a\", Dict(2 => 3))","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"a.x","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"By default, these are not mutable","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"try                         #hide\n    a.x = 2\ncatch err                   #hide\n    showerror(stderr, err)  #hide\nend                         #hide","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"However, you can declare a mutable struct which is mutable:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"mutable struct MyStructMutable\n    x::Int\n    y::String\n    z::Dict{Int,Int}\nend\n\na = MyStructMutable(1, \"a\", Dict(2 => 3))\na.x","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"a.x = 2\n\na","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Loops","page":"Getting started with Julia","title":"Loops","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Julia has native support for for-each style loops with the syntax for <value> in <collection> end:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"for i in 1:5\n    println(i)\nend","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nRanges are constructed as start:stop, or start:step:stop.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"for i in 1.2:1.1:5.6\n    println(i)\nend","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"This for-each loop also works with dictionaries:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"for (key, value) in Dict(\"A\" => 1, \"B\" => 2.5, \"D\" => 2 - 3im)\n    println(\"$(key): $(value)\")\nend","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Note that in contrast to vector languages like Matlab and R, loops do not result in a significant performance degradation in Julia.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Control-flow","page":"Getting started with Julia","title":"Control flow","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Julia control flow is similar to Matlab, using the keywords if-elseif-else-end, and the logical operators || and && for or and and respectively:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"for i in 0:5:15\n    if i < 5\n        println(\"$(i) is less than 5\")\n    elseif i < 10\n        println(\"$(i) is less than 10\")\n    else\n        if i == 10\n            println(\"the value is 10\")\n        else\n            println(\"$(i) is bigger than 10\")\n        end\n    end\nend","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Comprehensions","page":"Getting started with Julia","title":"Comprehensions","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Similar to languages like Haskell and Python, Julia supports the use of simple loops in the construction of arrays and dictionaries, called comprehensions.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A list of increasing integers:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"[i for i in 1:5]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Matrices can be built by including multiple indices:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"[i * j for i in 1:5, j in 5:10]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Conditional statements can be used to filter out some values:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"[i for i in 1:10 if i % 2 == 1]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A similar syntax can be used for building dictionaries:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dict(\"$(i)\" => i for i in 1:10 if i % 2 == 1)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Functions","page":"Getting started with Julia","title":"Functions","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A simple function is defined as follows:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function print_hello()\n    return println(\"hello\")\nend\nprint_hello()","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Arguments can be added to a function:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function print_it(x)\n    return println(x)\nend\nprint_it(\"hello\")\nprint_it(1.234)\nprint_it(:my_id)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Optional keyword arguments are also possible:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function print_it(x; prefix = \"value:\")\n    return println(\"$(prefix) $(x)\")\nend\nprint_it(1.234)\nprint_it(1.234, prefix = \"val:\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The keyword return is used to specify the return values of a function:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function mult(x; y = 2.0)\n    return x * y\nend\n\nmult(4.0)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"mult(4.0, y = 5.0)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Anonymous-functions","page":"Getting started with Julia","title":"Anonymous functions","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The syntax input -> output creates an anonymous function. These are most useful when passed to other functions. For example:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"f = x -> x^2\nf(2)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"map(x -> x^2, 1:4)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Type-parameters","page":"Getting started with Julia","title":"Type parameters","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"We can constrain the inputs to a function using type parameters, which are :: followed by the type of the input we want. For example:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function foo(x::Int)\n    return x^2\nend\n\nfunction foo(x::Float64)\n    return exp(x)\nend\n\nfunction foo(x::Number)\n    return x + 1\nend\n\n@show foo(2)\n@show foo(2.0)\n@show foo(1 + 1im)\nnothing #hide","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"But what happens if we call foo with something we haven't defined it for?","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"try                         #hide\n    foo([1, 2, 3])\ncatch err                   #hide\n    showerror(stderr, err)  #hide\nend                         #hide","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"We get a dreaded MethodError! A MethodError means that you passed a function something that didn't match the type that it was expecting. In this case, the error message says that it doesn't know how to handle an Vector{Int64}, but it does know how to handle Float64, Int64, and Number.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nRead the \"Closest candidates\" part of the error message carefully to get a hint as to what was expected.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Broadcasting","page":"Getting started with Julia","title":"Broadcasting","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"In the example above, we didn't define what to do if f was passed a Vector. Luckily, Julia provides a convenient syntax for mapping f element-wise over arrays! Just add a . between the name of the function and the opening (. This works for any function, including functions with multiple arguments. For example:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"f.([1, 2, 3])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nGet a MethodError when calling a function that takes a Vector, Matrix, or Array? Try broadcasting it!","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Mutable-vs-immutable-objects","page":"Getting started with Julia","title":"Mutable vs immutable objects","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Some types in Julia are mutable, which means you can change the values inside them. A good example is an array. You can modify the contents of an array without having to make a new array.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"In contrast, types like Float64 are immutable. You can't modify the contents of a Float64.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"This is something to be aware of when passing types into functions. For example:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function mutability_example(mutable_type::Vector{Int}, immutable_type::Int)\n    mutable_type[1] += 1\n    immutable_type += 1\n    return\nend\n\nmutable_type = [1, 2, 3]\nimmutable_type = 1\n\nmutability_example(mutable_type, immutable_type)\n\nprintln(\"mutable_type: $(mutable_type)\")\nprintln(\"immutable_type: $(immutable_type)\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Because Vector{Int} is a mutable type, modifying the variable inside the function changed the value outside of the function. In contrast, the change to immutable_type didn't modify the value outside the function.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"You can check mutability with the isimmutable function:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"isimmutable([1, 2, 3])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"isimmutable(1)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#The-package-manager","page":"Getting started with Julia","title":"The package manager","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/#Installing-packages","page":"Getting started with Julia","title":"Installing packages","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"No matter how wonderful Julia's base language is, at some point you will want to use an extension package.  Some of these are built-in, for example random number generation is available in the Random package in the standard library. These packages are loaded with the commands using and import.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"using Random  # The equivalent of Python's `from Random import *`\nimport Random  # The equivalent of Python's `import Random`\n\nRandom.seed!(33)\n\n[rand() for i in 1:10]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The Package Manager is used to install packages that are not part of Julia's standard library.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"For example the following can be used to install JuMP,","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"using Pkg\nPkg.add(\"JuMP\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"For a complete list of registered Julia packages see the package listing at JuliaHub.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"From time to you may wish to use a Julia package that is not registered.  In this case a git repository URL can be used to install the package.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"using Pkg\nPkg.add(\"https://github.com/user-name/MyPackage.jl.git\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Package-environments","page":"Getting started with Julia","title":"Package environments","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"By default, Pkg.add will add packages to Julia's global environment. However, Julia also has built-in support for virtual environments.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Activate a virtual environment with:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"import Pkg; Pkg.activate(\"/path/to/environment\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"You can see what packages are installed in the current environment with Pkg.status().","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nWe strongly recommend you create a Pkg environment for each project that you create in Julia, and add only the packages that you need, instead of adding lots of packages to the global environment. The Pkg manager documentation has more information on this topic.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/standard_form/#Standard-form","page":"Standard form","title":"Standard form","text":"","category":"section"},{"location":"moi/reference/standard_form/#Functions","page":"Standard form","title":"Functions","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"AbstractFunction\nAbstractScalarFunction\nAbstractVectorFunction\nVariableIndex\nVectorOfVariables\nScalarAffineTerm\nScalarAffineFunction\nVectorAffineTerm\nVectorAffineFunction\nScalarQuadraticTerm\nScalarQuadraticFunction\nVectorQuadraticTerm\nVectorQuadraticFunction","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractFunction","page":"Standard form","title":"MathOptInterface.AbstractFunction","text":"AbstractFunction\n\nAbstract supertype for function objects.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractScalarFunction","page":"Standard form","title":"MathOptInterface.AbstractScalarFunction","text":"AbstractScalarFunction\n\nAbstract supertype for scalar-valued function objects.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractVectorFunction","page":"Standard form","title":"MathOptInterface.AbstractVectorFunction","text":"AbstractVectorFunction\n\nAbstract supertype for vector-valued function objects.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VariableIndex","page":"Standard form","title":"MathOptInterface.VariableIndex","text":"VariableIndex\n\nA type-safe wrapper for Int64 for use in referencing variables in a model. To allow for deletion, indices need not be consecutive.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VectorOfVariables","page":"Standard form","title":"MathOptInterface.VectorOfVariables","text":"VectorOfVariables(variables)\n\nThe function that extracts the vector of variables referenced by variables, a Vector{VariableIndex}. This function is naturally be used for constraints that apply to groups of variables, such as an \"all different\" constraint, an indicator constraint, or a complementarity constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ScalarAffineTerm","page":"Standard form","title":"MathOptInterface.ScalarAffineTerm","text":"struct ScalarAffineTerm{T}\n    coefficient::T\n    variable::VariableIndex\nend\n\nRepresents c x_i where c is coefficient and x_i is the variable identified by variable.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ScalarAffineFunction","page":"Standard form","title":"MathOptInterface.ScalarAffineFunction","text":"ScalarAffineFunction{T}(terms, constant)\n\nThe scalar-valued affine function a^T x + b, where:\n\na is a sparse vector specified by a list of ScalarAffineTerm structs.\nb is a scalar specified by constant::T\n\nDuplicate variable indices in terms are accepted, and the corresponding coefficients are summed together.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VectorAffineTerm","page":"Standard form","title":"MathOptInterface.VectorAffineTerm","text":"struct VectorAffineTerm{T}\n    output_index::Int64\n    scalar_term::ScalarAffineTerm{T}\nend\n\nA ScalarAffineTerm plus its index of the output component of a VectorAffineFunction or VectorQuadraticFunction. output_index can also be interpreted as a row index into a sparse matrix, where the scalar_term contains the column index and coefficient.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VectorAffineFunction","page":"Standard form","title":"MathOptInterface.VectorAffineFunction","text":"VectorAffineFunction{T}(terms, constants)\n\nThe vector-valued affine function A x + b, where:\n\nA is a sparse matrix specified by a list of VectorAffineTerm objects.\nb is a vector specified by constants\n\nDuplicate indices in the A are accepted, and the corresponding coefficients are summed together.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ScalarQuadraticTerm","page":"Standard form","title":"MathOptInterface.ScalarQuadraticTerm","text":"struct ScalarQuadraticTerm{T}\n    coefficient::T\n    variable_1::VariableIndex\n    variable_2::VariableIndex\nend\n\nRepresents c x_i x_j where c is coefficient, x_i is the variable identified by variable_1 and x_j is the variable identified by variable_2.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ScalarQuadraticFunction","page":"Standard form","title":"MathOptInterface.ScalarQuadraticFunction","text":"ScalarQuadraticFunction{T}(quadratic_terms, affine_terms, constant)\n\nThe scalar-valued quadratic function frac12x^TQx + a^T x + b, where:\n\na is a sparse vector specified by a list of ScalarAffineTerm structs.\nb is a scalar specified by constant.\nQ is a symmetric matrix specified by a list of ScalarQuadraticTerm structs.\n\nDuplicate indices in a or Q are accepted, and the corresponding coefficients are summed together. \"Mirrored\" indices (q,r) and (r,q) (where r and q are VariableIndexes) are considered duplicates; only one need be specified.\n\nFor example, for two scalar variables y z, the quadratic expression yz + y^2 is represented by the terms ScalarQuadraticTerm.([1.0, 2.0], [y, y], [z, y]).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VectorQuadraticTerm","page":"Standard form","title":"MathOptInterface.VectorQuadraticTerm","text":"struct VectorQuadraticTerm{T}\n    output_index::Int64\n    scalar_term::ScalarQuadraticTerm{T}\nend\n\nA ScalarQuadraticTerm plus its index of the output component of a VectorQuadraticFunction. Each output component corresponds to a distinct sparse matrix Q_i.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VectorQuadraticFunction","page":"Standard form","title":"MathOptInterface.VectorQuadraticFunction","text":"VectorQuadraticFunction{T}(quadratic_terms, affine_terms, constants)\n\nThe vector-valued quadratic function with ith component (\"output index\") defined as frac12x^TQ_ix + a_i^T x + b_i, where:\n\na_i is a sparse vector specified by the VectorAffineTerms with output_index == i.\nb_i is a scalar specified by constants[i]\nQ_i is a symmetric matrix specified by the VectorQuadraticTerm with output_index == i.\n\nDuplicate indices in a_i or Q_i are accepted, and the corresponding coefficients are summed together. \"Mirrored\" indices (q,r) and (r,q) (where r and q are VariableIndexes) are considered duplicates; only one need be specified.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#Utilities","page":"Standard form","title":"Utilities","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"output_dimension\nconstant(f::Union{ScalarAffineFunction, ScalarQuadraticFunction})\nconstant(f::Union{VectorAffineFunction, VectorQuadraticFunction})\nconstant(f::VariableIndex, ::Type)\nconstant(f::VectorOfVariables, T::Type)","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.output_dimension","page":"Standard form","title":"MathOptInterface.output_dimension","text":"output_dimension(f::AbstractFunction)\n\nReturn 1 if f has a scalar output and the number of output components if f has a vector output.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.constant-Tuple{Union{MathOptInterface.ScalarAffineFunction, MathOptInterface.ScalarQuadraticFunction}}","page":"Standard form","title":"MathOptInterface.constant","text":"constant(f::Union{ScalarAffineFunction, ScalarQuadraticFunction})\n\nReturns the constant term of the scalar function\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/standard_form/#MathOptInterface.constant-Tuple{Union{MathOptInterface.VectorAffineFunction, MathOptInterface.VectorQuadraticFunction}}","page":"Standard form","title":"MathOptInterface.constant","text":"constant(f::Union{VectorAffineFunction, VectorQuadraticFunction})\n\nReturns the vector of constant terms of the vector function\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/standard_form/#MathOptInterface.constant-Tuple{MathOptInterface.VariableIndex, Type}","page":"Standard form","title":"MathOptInterface.constant","text":"constant(f::VariableIndex, ::Type{T}) where {T}\n\nThe constant term of a VariableIndex function is the zero value of the specified type T.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/standard_form/#MathOptInterface.constant-Tuple{MathOptInterface.VectorOfVariables, Type}","page":"Standard form","title":"MathOptInterface.constant","text":"constant(f::VectorOfVariables, ::Type{T}) where {T}\n\nThe constant term of a VectorOfVariables function is a vector of zero values of the specified type T.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/standard_form/#Sets","page":"Standard form","title":"Sets","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"AbstractSet\nAbstractScalarSet\nAbstractVectorSet","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractSet","page":"Standard form","title":"MathOptInterface.AbstractSet","text":"AbstractSet\n\nAbstract supertype for set objects used to encode constraints. A set object should not contain any VariableIndex or ConstraintIndex as the set is passed unmodifed during copy_to.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractScalarSet","page":"Standard form","title":"MathOptInterface.AbstractScalarSet","text":"AbstractScalarSet\n\nAbstract supertype for subsets of mathbbR.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractVectorSet","page":"Standard form","title":"MathOptInterface.AbstractVectorSet","text":"AbstractVectorSet\n\nAbstract supertype for subsets of mathbbR^n for some n.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#Utilities-2","page":"Standard form","title":"Utilities","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"dimension\ndual_set\ndual_set_type\nconstant(s::EqualTo)\nsupports_dimension_update\nupdate_dimension","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.dimension","page":"Standard form","title":"MathOptInterface.dimension","text":"dimension(s::AbstractSet)\n\nReturn the output_dimension that an AbstractFunction should have to be used with the set s.\n\nExamples\n\njulia> dimension(Reals(4))\n4\n\njulia> dimension(LessThan(3.0))\n1\n\njulia> dimension(PositiveSemidefiniteConeTriangle(2))\n3\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.dual_set","page":"Standard form","title":"MathOptInterface.dual_set","text":"dual_set(s::AbstractSet)\n\nReturn the dual set of s, that is the dual cone of the set. This follows the definition of duality discussed in Duality.\n\nSee Dual cone for more information.\n\nIf the dual cone is not defined it returns an error.\n\nExamples\n\njulia> dual_set(Reals(4))\nZeros(4)\n\njulia> dual_set(SecondOrderCone(5))\nSecondOrderCone(5)\n\njulia> dual_set(ExponentialCone())\nDualExponentialCone()\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.dual_set_type","page":"Standard form","title":"MathOptInterface.dual_set_type","text":"dual_set_type(S::Type{<:AbstractSet})\n\nReturn the type of dual set of sets of type S, as returned by dual_set. If the dual cone is not defined it returns an error.\n\nExamples\n\njulia> dual_set_type(Reals)\nZeros\n\njulia> dual_set_type(SecondOrderCone)\nSecondOrderCone\n\njulia> dual_set_type(ExponentialCone)\nDualExponentialCone\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.constant-Tuple{MathOptInterface.EqualTo}","page":"Standard form","title":"MathOptInterface.constant","text":"constant(s::Union{EqualTo, GreaterThan, LessThan})\n\nReturns the constant of the set.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/standard_form/#MathOptInterface.supports_dimension_update","page":"Standard form","title":"MathOptInterface.supports_dimension_update","text":"supports_dimension_update(S::Type{<:MOI.AbstractVectorSet})\n\nReturn a Bool indicating whether the elimination of any dimension of n-dimensional sets of type S give an n-1-dimensional set S. By default, this function returns false so it should only be implemented for sets that supports dimension update.\n\nFor instance, supports_dimension_update(MOI.Nonnegatives} is true because the elimination of any dimension of the n-dimensional nonnegative orthant gives the n-1-dimensional nonnegative orthant. However supports_dimension_update(MOI.ExponentialCone} is false.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.update_dimension","page":"Standard form","title":"MathOptInterface.update_dimension","text":"update_dimension(s::AbstractVectorSet, new_dim)\n\nReturns a set with the dimension modified to new_dim.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#Scalar-sets","page":"Standard form","title":"Scalar sets","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"List of recognized scalar sets.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"GreaterThan\nLessThan\nEqualTo\nInterval\nInteger\nZeroOne\nSemicontinuous\nSemiinteger","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.GreaterThan","page":"Standard form","title":"MathOptInterface.GreaterThan","text":"GreaterThan{T <: Real}(lower::T)\n\nThe set lowerinfty) subseteq mathbbR.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.LessThan","page":"Standard form","title":"MathOptInterface.LessThan","text":"LessThan{T <: Real}(upper::T)\n\nThe set (-inftyupper subseteq mathbbR.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.EqualTo","page":"Standard form","title":"MathOptInterface.EqualTo","text":"EqualTo{T <: Number}(value::T)\n\nThe set containing the single point x in mathbbR where x is given by value.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Interval","page":"Standard form","title":"MathOptInterface.Interval","text":"Interval{T <: Real}(lower::T,upper::T)\n\nThe interval lower upper subseteq mathbbR. If lower or upper is -Inf or Inf, respectively, the set is interpreted as a one-sided interval.\n\nInterval(s::GreaterThan{<:AbstractFloat})\n\nConstruct a (right-unbounded) Interval equivalent to the given GreaterThan set.\n\nInterval(s::LessThan{<:AbstractFloat})\n\nConstruct a (left-unbounded) Interval equivalent to the given LessThan set.\n\nInterval(s::EqualTo{<:Real})\n\nConstruct a (degenerate) Interval equivalent to the given EqualTo set.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Integer","page":"Standard form","title":"MathOptInterface.Integer","text":"Integer()\n\nThe set of integers mathbbZ.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ZeroOne","page":"Standard form","title":"MathOptInterface.ZeroOne","text":"ZeroOne()\n\nThe set  0 1 .\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Semicontinuous","page":"Standard form","title":"MathOptInterface.Semicontinuous","text":"Semicontinuous{T <: Real}(lower::T,upper::T)\n\nThe set 0 cup lowerupper.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Semiinteger","page":"Standard form","title":"MathOptInterface.Semiinteger","text":"Semiinteger{T <: Real}(lower::T,upper::T)\n\nThe set 0 cup lowerlower+1ldotsupper-1upper.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#Vector-sets","page":"Standard form","title":"Vector sets","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"List of recognized vector sets.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"Reals\nZeros\nNonnegatives\nNonpositives\nNormInfinityCone\nNormOneCone\nSecondOrderCone\nRotatedSecondOrderCone\nGeometricMeanCone\nExponentialCone\nDualExponentialCone\nPowerCone\nDualPowerCone\nRelativeEntropyCone\nNormSpectralCone\nNormNuclearCone\nSOS1\nSOS2\nIndicator\nComplements","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.Reals","page":"Standard form","title":"MathOptInterface.Reals","text":"Reals(dimension)\n\nThe set mathbbR^dimension (containing all points) of dimension dimension.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Zeros","page":"Standard form","title":"MathOptInterface.Zeros","text":"Zeros(dimension)\n\nThe set  0 ^dimension (containing only the origin) of dimension dimension.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Nonnegatives","page":"Standard form","title":"MathOptInterface.Nonnegatives","text":"Nonnegatives(dimension)\n\nThe nonnegative orthant  x in mathbbR^dimension  x ge 0  of dimension dimension.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Nonpositives","page":"Standard form","title":"MathOptInterface.Nonpositives","text":"Nonpositives(dimension)\n\nThe nonpositive orthant  x in mathbbR^dimension  x le 0  of dimension dimension.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.NormInfinityCone","page":"Standard form","title":"MathOptInterface.NormInfinityCone","text":"NormInfinityCone(dimension)\n\nThe ell_infty-norm cone  (tx) in mathbbR^dimension  t ge lVert x rVert_infty = max_i lvert x_i rvert  of dimension dimension.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.NormOneCone","page":"Standard form","title":"MathOptInterface.NormOneCone","text":"NormOneCone(dimension)\n\nThe ell_1-norm cone  (tx) in mathbbR^dimension  t ge lVert x rVert_1 = sum_i lvert x_i rvert  of dimension dimension.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.SecondOrderCone","page":"Standard form","title":"MathOptInterface.SecondOrderCone","text":"SecondOrderCone(dimension)\n\nThe second-order cone (or Lorenz cone or ell_2-norm cone)  (tx) in mathbbR^dimension  t ge lVert x rVert_2  of dimension dimension.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.RotatedSecondOrderCone","page":"Standard form","title":"MathOptInterface.RotatedSecondOrderCone","text":"RotatedSecondOrderCone(dimension)\n\nThe rotated second-order cone  (tux) in mathbbR^dimension  2tu ge lVert x rVert_2^2 tu ge 0  of dimension dimension.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.GeometricMeanCone","page":"Standard form","title":"MathOptInterface.GeometricMeanCone","text":"GeometricMeanCone(dimension)\n\nThe geometric mean cone  (tx) in mathbbR^n+1  x ge 0 t le sqrtnx_1 x_2 cdots x_n , where dimension = n + 1 >= 2.\n\nDuality note\n\nThe dual of the geometric mean cone is  (u v) in mathbbR^n+1  u le 0 v ge 0 -u le n sqrtnprod_i v_i , where dimension = n + 1 >= 2.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ExponentialCone","page":"Standard form","title":"MathOptInterface.ExponentialCone","text":"ExponentialCone()\n\nThe 3-dimensional exponential cone  (xyz) in mathbbR^3  y exp (xy) le z y  0 .\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.DualExponentialCone","page":"Standard form","title":"MathOptInterface.DualExponentialCone","text":"DualExponentialCone()\n\nThe 3-dimensional dual exponential cone  (uvw) in mathbbR^3  -u exp (vu) le exp(1) w u  0 .\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.PowerCone","page":"Standard form","title":"MathOptInterface.PowerCone","text":"PowerCone{T <: Real}(exponent::T)\n\nThe 3-dimensional power cone  (xyz) in mathbbR^3  x^exponent y^1-exponent ge z x ge 0 y ge 0  with parameter exponent.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.DualPowerCone","page":"Standard form","title":"MathOptInterface.DualPowerCone","text":"DualPowerCone{T <: Real}(exponent::T)\n\nThe 3-dimensional power cone  (uvw) in mathbbR^3  (fracuexponent)^exponent (fracv1-exponent)^1-exponent ge w u ge 0 v ge 0  with parameter exponent.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.RelativeEntropyCone","page":"Standard form","title":"MathOptInterface.RelativeEntropyCone","text":"RelativeEntropyCone(dimension)\n\nThe relative entropy cone  (u v w) in mathbbR^1+2n  u ge sum_i=1^n w_i log(fracw_iv_i) v_i ge 0 w_i ge 0 , where dimension = 2n + 1 >= 1.\n\nDuality note\n\nThe dual of the relative entropy cone is  (u v w) in mathbbR^1+2n  forall i w_i ge u (log (fracuv_i) - 1) v_i ge 0 u  0  of dimension dimension=2n+1.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.NormSpectralCone","page":"Standard form","title":"MathOptInterface.NormSpectralCone","text":"NormSpectralCone(row_dim, column_dim)\n\nThe epigraph of the matrix spectral norm (maximum singular value function)  (t X) in mathbbR^1 + row_dim times column_dim  t ge sigma_1(X) , where sigma_i is the ith singular value of the matrix X of row dimension row_dim and column dimension column_dim.\n\nThe matrix X is vectorized by stacking the columns, matching the behavior of Julia's vec function.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.NormNuclearCone","page":"Standard form","title":"MathOptInterface.NormNuclearCone","text":"NormNuclearCone(row_dim, column_dim)\n\nThe epigraph of the matrix nuclear norm (sum of singular values function)  (t X) in mathbbR^1 + row_dim times column_dim  t ge sum_i sigma_i(X) , where sigma_i is the ith singular value of the matrix X of row dimension row_dim and column dimension column_dim.\n\nThe matrix X is vectorized by stacking the columns, matching the behavior of Julia's vec function.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.SOS1","page":"Standard form","title":"MathOptInterface.SOS1","text":"SOS1{T <: Real}(weights::Vector{T})\n\nThe set corresponding to the special ordered set (SOS) constraint of type 1. Of the variables in the set, at most one can be nonzero. The weights induce an ordering of the variables; as such, they should be unique values. The kth element in the set corresponds to the kth weight in weights. See here for a description of SOS constraints and their potential uses.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.SOS2","page":"Standard form","title":"MathOptInterface.SOS2","text":"SOS2{T <: Real}(weights::Vector{T})\n\nThe set corresponding to the special ordered set (SOS) constraint of type 2. Of the variables in the set, at most two can be nonzero, and if two are nonzero, they must be adjacent in the ordering of the set. The weights induce an ordering of the variables; as such, they should be unique values. The kth element in the set corresponds to the kth weight in weights. See here for a description of SOS constraints and their potential uses.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Indicator","page":"Standard form","title":"MathOptInterface.Indicator","text":"Indicator{A<:ActivationCondition,S<:AbstractScalarSet}(set::S)\n\nThe set corresponding to an indicator constraint.\n\nWhen A is ACTIVATE_ON_ZERO, this means: (y x) in 0 1 times mathbbR^n  y = 0 implies x in set\n\nWhen A is ACTIVATE_ON_ONE, this means: (y x) in 0 1 times mathbbR^n  y = 1 implies x in set\n\nNotes\n\nMost solvers expect that the first row of the function is interpretable as a variable index x_i (e.g., 1.0 * x + 0.0). An error will be thrown if this is not the case.\n\nExample\n\nThe constraint (y x) in 0 1 times mathbbR^2  y = 1 implies x_1 + x_2 leq 9  is defined as\n\nf = MOI.VectorAffineFunction(\n    [\n        MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(1.0, y)),\n        MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(1.0, x1)),\n        MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(1.0, x2)),\n    ],\n    [0.0, 0.0],\n)\ns = MOI.Indicator{MOI.ACTIVATE_ON_ONE}(MOI.LessThan(9.0))\nMOI.add_constraint(model, f, s)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Complements","page":"Standard form","title":"MathOptInterface.Complements","text":"Complements(dimension::Base.Integer)\n\nThe set corresponding to a mixed complementarity constraint.\n\nComplementarity constraints should be specified with an AbstractVectorFunction-in-Complements(dimension) constraint.\n\nThe dimension of the vector-valued function F must be dimension. This defines a complementarity constraint between the scalar function F[i] and the variable in F[i + dimension/2]. Thus, F[i + dimension/2] must be interpretable as a single variable x_i (e.g., 1.0 * x + 0.0), and dimension must be even.\n\nThe mixed complementarity problem consists of finding x_i in the interval [lb, ub] (i.e., in the set Interval(lb, ub)), such that the following holds:\n\nF_i(x) == 0 if lb_i < x_i < ub_i\nF_i(x) >= 0 if lb_i == x_i\nF_i(x) <= 0 if x_i == ub_i\n\nClassically, the bounding set for x_i is Interval(0, Inf), which recovers: 0 <= F_i(x) ⟂ x_i >= 0, where the ⟂ operator implies F_i(x) * x_i = 0.\n\nExamples\n\nThe problem:\n\nx -in- Interval(-1, 1)\n[-4 * x - 3, x] -in- Complements(2)\n\ndefines the mixed complementarity problem where the following holds:\n\n-4 * x - 3 == 0 if -1 < x < 1\n-4 * x - 3 >= 0 if x == -1\n-4 * x - 3 <= 0 if x == 1\n\nThere are three solutions:\n\nx = -3/4 with F(x) = 0\nx = -1 with F(x) = 1\nx = 1 with F(x) = -7\n\nThe function F can also be defined in terms of single variables. For example, the problem:\n\n[x_3, x_4] -in- Nonnegatives(2)\n[x_1, x_2, x_3, x_4] -in- Complements(4)\n\ndefines the complementarity problem where 0 <= x_1 ⟂ x_3 >= 0 and 0 <= x_2 ⟂ x_4 >= 0.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#Matrix-sets","page":"Standard form","title":"Matrix sets","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"Matrix sets are vectorized in order to be subtypes of AbstractVectorSet.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"For sets of symmetric matrices, storing both the (i, j) and (j, i) elements is redundant. Use the AbstractSymmetricMatrixSetTriangle set to represent only the vectorization of the upper triangular part of the matrix.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"When the matrix of expressions constrained to be in the set is not symmetric, and hence additional constraints are needed to force the equality of the (i, j) and (j, i) elements, use the AbstractSymmetricMatrixSetSquare set.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"The Bridges.Constraint.SquareBridge can transform a set from the square form to the triangular_form by adding appropriate constraints if the (i, j) and (j, i) expressions are different.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"AbstractSymmetricMatrixSetTriangle\nAbstractSymmetricMatrixSetSquare\nside_dimension\ntriangular_form","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractSymmetricMatrixSetTriangle","page":"Standard form","title":"MathOptInterface.AbstractSymmetricMatrixSetTriangle","text":"abstract type AbstractSymmetricMatrixSetTriangle <: AbstractVectorSet end\n\nAbstract supertype for subsets of the (vectorized) cone of symmetric matrices, with side_dimension rows and columns. The entries of the upper-right triangular part of the matrix are given column by column (or equivalently, the entries of the lower-left triangular part are given row by row). A vectorized cone of dimension n corresponds to a square matrix with side dimension sqrt14 + 2 n - 12. (Because a d times d matrix has d(d + 1)  2 elements in the upper or lower triangle.)\n\nExamples\n\nThe matrix\n\nbeginbmatrix\n  1  2  4\n  2  3  5\n  4  5  6\nendbmatrix\n\nhas side_dimension 3 and vectorization (1 2 3 4 5 6).\n\nNote\n\nTwo packed storage formats exist for symmetric matrices, the respective orders of the entries are:\n\nupper triangular column by column (or lower triangular row by row);\nlower triangular column by column (or upper triangular row by row).\n\nThe advantage of the first format is the mapping between the (i, j) matrix indices and the k index of the vectorized form. It is simpler and does not depend on the side dimension of the matrix. Indeed,\n\nthe entry of matrix indices (i, j) has vectorized index k = div((j - 1) * j, 2) + i if i leq j and k = div((i - 1) * i, 2) + j if j leq i;\nand the entry with vectorized index k has matrix indices i = div(1 + isqrt(8k - 7), 2) and j = k - div((i - 1) * i, 2) or j = div(1 + isqrt(8k - 7), 2) and i = k - div((j - 1) * j, 2).\n\nDuality note\n\nThe scalar product for the symmetric matrix in its vectorized form is the sum of the pairwise product of the diagonal entries plus twice the sum of the pairwise product of the upper diagonal entries; see [p. 634, 1]. This has important consequence for duality.\n\nConsider for example the following problem (PositiveSemidefiniteConeTriangle is a subtype of AbstractSymmetricMatrixSetTriangle)\n\nbeginalign*\n     max_x in mathbbR  x\n    \n     textst \n    (1 -x 1)  in textPositiveSemidefiniteConeTriangle(2)\nendalign*\n\nThe dual is the following problem\n\nbeginalign*\n     min_x in mathbbR^3  y_1 + y_3\n    \n     textst  2y_2  = 1\n      y  in textPositiveSemidefiniteConeTriangle(2)\nendalign*\n\nWhy do we use 2y_2 in the dual constraint instead of y_2 ? The reason is that 2y_2 is the scalar product between y and the symmetric matrix whose vectorized form is (0 1 0). Indeed, with our modified scalar products we have\n\nlangle\n(0 1 0)\n(y_1 y_2 y_3)\nrangle\n=\nmathrmtrace\nbeginpmatrix\n  0  1\n  1  0\nendpmatrix\nbeginpmatrix\n  y_1  y_2\n  y_2  y_3\nendpmatrix\n= 2y_2\n\nReferences\n\n[1] Boyd, S. and Vandenberghe, L.. Convex optimization. Cambridge university press, 2004.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractSymmetricMatrixSetSquare","page":"Standard form","title":"MathOptInterface.AbstractSymmetricMatrixSetSquare","text":"abstract type AbstractSymmetricMatrixSetSquare <: AbstractVectorSet end\n\nAbstract supertype for subsets of the (vectorized) cone of symmetric matrices, with side_dimension rows and columns. The entries of the matrix are given column by column (or equivalently, row by row). The matrix is both constrained to be symmetric and to have its triangular_form belong to the corresponding set. That is, if the functions in entries (i j) and (j i) are different, then a constraint will be added to make sure that the entries are equal.\n\nExamples\n\nPositiveSemidefiniteConeSquare is a subtype of AbstractSymmetricMatrixSetSquare and constraining the matrix\n\nbeginbmatrix\n  1  -y\n  -z  0\nendbmatrix\n\nto be symmetric positive semidefinite can be achieved by constraining the vector (1 -z -y 0) (or (1 -y -z 0)) to belong to the PositiveSemidefiniteConeSquare(2). It both constrains y = z and (1 -y 0) (or (1 -z 0)) to be in PositiveSemidefiniteConeTriangle(2), since triangular_form(PositiveSemidefiniteConeSquare) is PositiveSemidefiniteConeTriangle.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.side_dimension","page":"Standard form","title":"MathOptInterface.side_dimension","text":"side_dimension(set::Union{AbstractSymmetricMatrixSetTriangle,\n                          AbstractSymmetricMatrixSetSquare})\n\nSide dimension of the matrices in set. By convention, it should be stored in the side_dimension field but if it is not the case for a subtype of AbstractSymmetricMatrixSetTriangle, the method should be implemented for this subtype.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.triangular_form","page":"Standard form","title":"MathOptInterface.triangular_form","text":"triangular_form(S::Type{<:AbstractSymmetricMatrixSetSquare})\ntriangular_form(set::AbstractSymmetricMatrixSetSquare)\n\nReturn the AbstractSymmetricMatrixSetTriangle corresponding to the vectorization of the upper triangular part of matrices in the AbstractSymmetricMatrixSetSquare set.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"List of recognized matrix sets.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"PositiveSemidefiniteConeTriangle\nPositiveSemidefiniteConeSquare\nLogDetConeTriangle\nLogDetConeSquare\nRootDetConeTriangle\nRootDetConeSquare","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeTriangle","page":"Standard form","title":"MathOptInterface.PositiveSemidefiniteConeTriangle","text":"PositiveSemidefiniteConeTriangle(side_dimension) <: AbstractSymmetricMatrixSetTriangle\n\nThe (vectorized) cone of symmetric positive semidefinite matrices, with side_dimension rows and columns.\n\nSee AbstractSymmetricMatrixSetTriangle for more details on the vectorized form.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeSquare","page":"Standard form","title":"MathOptInterface.PositiveSemidefiniteConeSquare","text":"PositiveSemidefiniteConeSquare(side_dimension) <: AbstractSymmetricMatrixSetSquare\n\nThe cone of symmetric positive semidefinite matrices, with side length side_dimension.\n\nSee AbstractSymmetricMatrixSetSquare for more details on the vectorized form.\n\nThe entries of the matrix are given column by column (or equivalently, row by row).\n\nThe matrix is both constrained to be symmetric and to be positive semidefinite. That is, if the functions in entries (i j) and (j i) are different, then a constraint will be added to make sure that the entries are equal.\n\nExamples\n\nConstraining the matrix\n\nbeginbmatrix\n  1  -y\n  -z  0\nendbmatrix\n\nto be symmetric positive semidefinite can be achieved by constraining the vector (1 -z -y 0) (or (1 -y -z 0)) to belong to the PositiveSemidefiniteConeSquare(2).\n\nIt both constrains y = z and (1 -y 0) (or (1 -z 0)) to be in PositiveSemidefiniteConeTriangle(2).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.LogDetConeTriangle","page":"Standard form","title":"MathOptInterface.LogDetConeTriangle","text":"LogDetConeTriangle(side_dimension)\n\nThe log-determinant cone  (t u X) in mathbbR^2 + d(d+1)2  t le u log(det(Xu)) u  0 , where the matrix X is represented in the same symmetric packed format as in the PositiveSemidefiniteConeTriangle.\n\nThe argument side_dimension is the side dimension of the matrix X, i.e., its number of rows or columns.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.LogDetConeSquare","page":"Standard form","title":"MathOptInterface.LogDetConeSquare","text":"LogDetConeSquare(side_dimension)\n\nThe log-determinant cone  (t u X) in mathbbR^2 + d^2  t le u log(det(Xu)) X text symmetric u  0 , where the matrix X is represented in the same format as in the PositiveSemidefiniteConeSquare.\n\nSimilarly to PositiveSemidefiniteConeSquare, constraints are added to ensure that X is symmetric.\n\nThe argument side_dimension is the side dimension of the matrix X, i.e., its number of rows or columns.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.RootDetConeTriangle","page":"Standard form","title":"MathOptInterface.RootDetConeTriangle","text":"RootDetConeTriangle(side_dimension)\n\nThe root-determinant cone  (t X) in mathbbR^1 + d(d+1)2  t le det(X)^1d , where the matrix X is represented in the same symmetric packed format as in the PositiveSemidefiniteConeTriangle.\n\nThe argument side_dimension is the side dimension of the matrix X, i.e., its number of rows or columns.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.RootDetConeSquare","page":"Standard form","title":"MathOptInterface.RootDetConeSquare","text":"RootDetConeSquare(side_dimension)\n\nThe root-determinant cone  (t X) in mathbbR^1 + d^2  t le det(X)^1d X text symmetric , where the matrix X is represented in the same format as PositiveSemidefiniteConeSquare.\n\nSimilarly to PositiveSemidefiniteConeSquare, constraints are added to ensure that X is symmetric.\n\nThe argument side_dimension is the side dimension of the matrix X, i.e., its number of rows or columns.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/linear/tips_and_tricks.jl\"","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Tips-and-tricks","page":"Tips and tricks","title":"Tips and tricks","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"tip: Tip\nA good source of tips is the Mosek Modeling Cookbook.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This tutorial collates some tips and tricks you can use when formulating mixed-integer programs. It uses the following packages:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"using JuMP","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Boolean-operators","page":"Tips and tricks","title":"Boolean operators","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Binary variables can be used to construct logical operators. Here are some example.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Or","page":"Tips and tricks","title":"Or","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x_3 = x_1 lor x_2","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:3], Bin)\n@constraints(model, begin\n    x[1] <= x[3]\n    x[2] <= x[3]\n    x[3] <= x[1] + x[2]\nend)","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#And","page":"Tips and tricks","title":"And","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x_3 = x_1 land x_2","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:3], Bin)\n@constraints(model, begin\n    x[3] <= x[1]\n    x[3] <= x[2]\n    x[3] >= x[1] + x[2] - 1\nend)","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Not","page":"Tips and tricks","title":"Not","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x_1 neg x_2","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2], Bin)\n@constraint(model, x[1] == 1 - x[2])","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Implies","page":"Tips and tricks","title":"Implies","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x_1 implies x_2","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2], Bin)\n@constraint(model, x[1] <= x[2])","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Disjunctions","page":"Tips and tricks","title":"Disjunctions","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/#Problem","page":"Tips and tricks","title":"Problem","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Suppose that we have two constraints a^top x leq b and c^top x leq d, and we want at least one to hold.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Trick","page":"Tips and tricks","title":"Trick","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Introduce a \"big-M\" multiplied by a binary variable to relax one of the constraints.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example Either x_1 leq 1 or x_2 leq 2.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2])\n@variable(model, y, Bin)\nM = 100\n@constraint(model, x[1] <= 1 + M * y)\n@constraint(model, x[2] <= 2 + M * (1 - y))","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"warning: Warning\nIf M is too small, the solution may be suboptimal. If M is too big, the solver may encounter numerical issues. Try to use domain knowledge to choose an M that is just right. Gurobi has a good documentation section on this topic.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Indicator-constraints","page":"Tips and tricks","title":"Indicator constraints","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/#Problem-2","page":"Tips and tricks","title":"Problem","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Suppose we want to model that a certain linear inequality must be satisfied when some other event occurs, i.e., for a binary variable z, we want to model the implication:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"z = 1 implies a^Tx leq b","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Trick-1","page":"Tips and tricks","title":"Trick 1","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Some solvers have native support for indicator constraints.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x_1 + x_2 leq 1 if z = 1.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2])\n@variable(model, z, Bin)\n@constraint(model, z => {sum(x) <= 1})","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x_1 + x_2 leq 1 if z = 0.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2])\n@variable(model, z, Bin)\n@constraint(model, !z => {sum(x) <= 1})","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Trick-2","page":"Tips and tricks","title":"Trick 2","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"If the solver doesn't support indicator constraints, you an use the big-M trick.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x_1 + x_2 leq 1 if z = 1.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2])\n@variable(model, z, Bin)\nM = 100\n@constraint(model, sum(x) <= 1 + M * (1 - z))","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x_1 + x_2 leq 1 if z = 0.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2])\n@variable(model, z, Bin)\nM = 100\n@constraint(model, sum(x) <= 1 + M * z)","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Semi-continuous-variables","page":"Tips and tricks","title":"Semi-continuous variables","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"info: Info\nThis section uses sets from MathOptInterface. By default, JuMP exports the MOI symbol as an alias for the MathOptInterface.jl package. We recommend making this more explicit in your code by adding the following lines:import MathOptInterface\nconst MOI = MathOptInterface","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A semi-continuous variable is a continuous variable between bounds lu that also can assume the value zero. ie. x in 0 cup lu","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x in 0cup 1 2","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x in MOI.Semicontinuous(1.0, 2.0))","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Semi-integer-variables","page":"Tips and tricks","title":"Semi-integer variables","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A semi-integer variable is a variable which assumes integer values between bounds lu and can also assume the value zero: x in 0 cup l u cap mathbbZ","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x in MOI.Semiinteger(5.0, 10.0))","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Special-Ordered-Sets-of-Type-I","page":"Tips and tricks","title":"Special Ordered Sets of Type I","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A Special Ordered Set of Type I is a set of variables, at most one of which can take a non-zero value, all others being at 0.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"They most frequently apply where a set of variables are actually binary variables. In other words, we have to choose at most one from a set of possibilities.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:3], Bin)\n@constraint(model, x in SOS1())","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"You can optionally pass SOS1 a weight vector like","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"@constraint(model, x in SOS1([0.2, 0.5, 0.3]))","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"If the decision variables are related and have a physical ordering, then the weight vector, although not used directly in the constraint, can help the solver make a better decision in the solution process.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#tip_sos2","page":"Tips and tricks","title":"Special Ordered Sets of Type II","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A Special Ordered Set of type 2 is a set of non-negative variables, of which at most two can be non-zero, and if two are non-zero these must be consecutive in their ordering.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:3])\n@constraint(model, x in SOS2([3.0, 1.0, 2.0]))","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"The ordering provided by the weight vector is more important in this case as the variables need to be consecutive according to the ordering. For example, in the above constraint, the possible pairs are:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Consecutive\n(x[1] and x[3]) as they correspond to 3 and 2 resp. and thus can be non-zero\n(x[2] and x[3]) as they correspond to 1 and 2 resp. and thus can be non-zero\nNon-consecutive\n(x[1] and x[2]) as they correspond to 3 and 1 resp. and thus cannot be non-zero","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Piecewise-linear-approximations","page":"Tips and tricks","title":"Piecewise linear approximations","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"SOSII constraints are most often used to form piecewise linear approximations of a function.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Given a set of points for x:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x̂ = -1:0.5:2","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"and a set of corresponding points for y:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"ŷ = x̂ .^ 2","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"the piecewise linear approximation is constructed by representing x and y as convex combinations of x̂ and ŷ.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"N = length(x̂)\nmodel = Model()\n@variable(model, -1 <= x <= 2)\n@variable(model, y)\n@variable(model, 0 <= λ[1:N] <= 1)\n@objective(model, Max, y)\n@constraints(model, begin\n    x == sum(x̂[i] * λ[i] for i in 1:N)\n    y == sum(ŷ[i] * λ[i] for i in 1:N)\n    sum(λ) == 1\n    λ in SOS2()\nend)","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"reference/variables/#VariableAPI","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"More information can be found in the Variables section of the manual.","category":"page"},{"location":"reference/variables/#Macros","page":"Variables","title":"Macros","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"@variable\n@variables","category":"page"},{"location":"reference/variables/#JuMP.@variable","page":"Variables","title":"JuMP.@variable","text":"@variable(model, kw_args...)\n\nAdd an anonymous variable to the model model described by the keyword arguments kw_args and returns the variable.\n\n@variable(model, expr, args..., kw_args...)\n\nAdd a variable to the model model described by the expression expr, the positional arguments args and the keyword arguments kw_args. The expression expr can either be (note that in the following the symbol <= can be used instead of ≤, the symbol >=can be used instead of ≥, the symbol in can be used instead of ∈)\n\nof the form varexpr creating variables described by varexpr;\nof the form varexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb);\nof the form varexpr == value creating variables described by varexpr with fixed values given by value; or\nof the form lb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub.\nof the form varexpr ∈ set creating variables described by varexpr constrained to belong to set, see Variables constrained on creation.\n\nThe expression varexpr can either be\n\nof the form varname creating a scalar real variable of name varname;\nof the form varname[...] or [...] creating a container of variables.\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\nSymmetric: Only available when creating a square matrix of variables, i.e. when varexpr is of the form varname[1:n,1:n] or varname[i=1:n,j=1:n]. It creates a symmetric matrix of variable, that is, it only creates a new variable for varname[i,j] with i ≤ j and sets varname[j,i] to the same variable as varname[i,j]. It is equivalent to using varexpr in SymMatrixSpace() as expr.\nPSD: The square matrix of variable is both Symmetric and constrained to be positive semidefinite. It is equivalent to using varexpr in PSDCone() as expr.\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes.\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\nvariable_type: See the \"Note for extending the variable macro\" section below.\nset: Equivalent to using varexpr in value as expr where value is the value of the keyword argument.\ncontainer: Specify the container type.\n\nExamples\n\nThe following are equivalent ways of creating a variable x of name x with lower bound 0:\n\n# Specify everything in `expr`\n@variable(model, x >= 0)\n# Specify the lower bound using a keyword argument\n@variable(model, x, lower_bound=0)\n# Specify everything in `kw_args`\nx = @variable(model, base_name=\"x\", lower_bound=0)\n\nThe following are equivalent ways of creating a DenseAxisArray of index set [:a, :b] and with respective upper bounds 2 and 3 and names x[a] and x[b]. The upper bound can either be specified in expr:\n\nub = Dict(:a => 2, :b => 3)\n@variable(model, x[i=keys(ub)] <= ub[i])\n\n# output\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{VariableRef,1}:\n x[a]\n x[b]\n\nor it can be specified with the upper_bound keyword argument:\n\n@variable(model, y[i=keys(ub)], upper_bound=ub[i])\n\n# output\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{VariableRef,1}:\n y[a]\n y[b]\n\n\n\n\n\n","category":"macro"},{"location":"reference/variables/#JuMP.@variables","page":"Variables","title":"JuMP.@variables","text":"@variables(model, args...)\n\nAdds multiple variables to model at once, in the same fashion as the @variable macro.\n\nThe model must be the first argument, and multiple variables can be added on multiple lines wrapped in a begin ... end block.\n\nThe macro returns a tuple containing the variables that were defined.\n\nExamples\n\n@variables(model, begin\n    x\n    y[i = 1:2] >= 0, (start = i)\n    z, Bin, (start = 0, base_name = \"Z\")\nend)\n\nnote: Note\nKeyword arguments must be contained within parentheses (refer to the example above).\n\n\n\n\n\n","category":"macro"},{"location":"reference/variables/#Basic-utilities","page":"Variables","title":"Basic utilities","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"VariableRef\nnum_variables\nall_variables\nowner_model\nindex(::VariableRef)\noptimizer_index(::VariableRef)\ncheck_belongs_to_model\nVariableNotOwned\nVariableConstrainedOnCreation\nVariablesConstrainedOnCreation","category":"page"},{"location":"reference/variables/#JuMP.VariableRef","page":"Variables","title":"JuMP.VariableRef","text":"VariableRef <: AbstractVariableRef\n\nHolds a reference to the model and the corresponding MOI.VariableIndex.\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.num_variables","page":"Variables","title":"JuMP.num_variables","text":"num_variables(model::Model)::Int64\n\nReturns number of variables in model.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.all_variables","page":"Variables","title":"JuMP.all_variables","text":"all_variables(model::Model)::Vector{VariableRef}\n\nReturns a list of all variables currently in the model. The variables are ordered by creation time.\n\nExample\n\nmodel = Model()\n@variable(model, x)\n@variable(model, y)\nall_variables(model)\n\n# output\n\n2-element Array{VariableRef,1}:\n x\n y\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.owner_model","page":"Variables","title":"JuMP.owner_model","text":"owner_model(s::AbstractJuMPScalar)\n\nReturn the model owning the scalar s.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.index-Tuple{VariableRef}","page":"Variables","title":"JuMP.index","text":"index(v::VariableRef)::MOI.VariableIndex\n\nReturn the index of the variable that corresponds to v in the MOI backend.\n\n\n\n\n\n","category":"method"},{"location":"reference/variables/#JuMP.optimizer_index-Tuple{VariableRef}","page":"Variables","title":"JuMP.optimizer_index","text":"optimizer_index(v::VariableRef)::MOI.VariableIndex\n\nReturn the index of the variable that corresponds to v in the optimizer model. It throws NoOptimizer if no optimizer is set and throws an ErrorException if the optimizer is set but is not attached.\n\n\n\n\n\n","category":"method"},{"location":"reference/variables/#JuMP.check_belongs_to_model","page":"Variables","title":"JuMP.check_belongs_to_model","text":"check_belongs_to_model(func::AbstractJuMPScalar, model::AbstractModel)\n\nThrow VariableNotOwned if the owner_model of one of the variables of the function func is not model.\n\ncheck_belongs_to_model(constraint::AbstractConstraint, model::AbstractModel)\n\nThrow VariableNotOwned if the owner_model of one of the variables of the constraint constraint is not model.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.VariableNotOwned","page":"Variables","title":"JuMP.VariableNotOwned","text":"struct VariableNotOwned{V <: AbstractVariableRef} <: Exception\n    variable::V\nend\n\nThe variable variable was used in a model different to owner_model(variable).\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.VariableConstrainedOnCreation","page":"Variables","title":"JuMP.VariableConstrainedOnCreation","text":"VariablesConstrainedOnCreation <: AbstractVariable\n\nVariable scalar_variables constrained to belong to set. Adding this variable can be understood as doing:\n\nfunction JuMP.add_variable(model::Model, variable::JuMP.VariableConstrainedOnCreation, names)\n    var_ref = JuMP.add_variable(model, variable.scalar_variable, name)\n    JuMP.add_constraint(model, JuMP.VectorConstraint(var_ref, variable.set))\n    return var_ref\nend\n\nbut adds the variables with MOI.add_constrained_variable(model, variable.set) instead. See the MOI documentation for the difference between adding the variables with MOI.add_constrained_variable and adding them with MOI.add_variable and adding the constraint separately.\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.VariablesConstrainedOnCreation","page":"Variables","title":"JuMP.VariablesConstrainedOnCreation","text":"VariablesConstrainedOnCreation <: AbstractVariable\n\nVector of variables scalar_variables constrained to belong to set. Adding this variable can be thought as doing:\n\nfunction JuMP.add_variable(model::Model, variable::JuMP.VariablesConstrainedOnCreation, names)\n    var_refs = JuMP.add_variable.(model, variable.scalar_variables,\n                                  JuMP.vectorize(names, variable.shape))\n    JuMP.add_constraint(model, JuMP.VectorConstraint(var_refs, variable.set))\n    return JuMP.reshape_vector(var_refs, variable.shape)\nend\n\nbut adds the variables with MOI.add_constrained_variables(model, variable.set) instead. See the MOI documentation for the difference between adding the variables with MOI.add_constrained_variables and adding them with MOI.add_variables and adding the constraint separately.\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#Names","page":"Variables","title":"Names","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"name(::JuMP.VariableRef)\nset_name(::JuMP.VariableRef, ::String)\nvariable_by_name","category":"page"},{"location":"reference/variables/#JuMP.name-Tuple{VariableRef}","page":"Variables","title":"JuMP.name","text":"name(v::VariableRef)::String\n\nGet a variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"reference/variables/#JuMP.set_name-Tuple{VariableRef, String}","page":"Variables","title":"JuMP.set_name","text":"set_name(v::VariableRef, s::AbstractString)\n\nSet a variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"reference/variables/#JuMP.variable_by_name","page":"Variables","title":"JuMP.variable_by_name","text":"variable_by_name(model::AbstractModel,\n                 name::String)::Union{AbstractVariableRef, Nothing}\n\nReturns the reference of the variable with name attribute name or Nothing if no variable has this name attribute. Throws an error if several variables have name as their name attribute.\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> variable_by_name(model, \"x\")\nx\n\njulia> @variable(model, base_name=\"x\")\nx\n\njulia> variable_by_name(model, \"x\")\nERROR: Multiple variables have the name x.\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] get(::MOIU.Model{Float64}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/model.jl:222\n [3] get at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/universalfallback.jl:201 [inlined]\n [4] get(::MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.AbstractOptimizer,MathOptInterface.Utilities.UniversalFallback{MOIU.Model{Float64}}}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/cachingoptimizer.jl:490\n [5] variable_by_name(::Model, ::String) at /home/blegat/.julia/dev/JuMP/src/variables.jl:268\n [6] top-level scope at none:0\n\njulia> var = @variable(model, base_name=\"y\")\ny\n\njulia> variable_by_name(model, \"y\")\ny\n\njulia> set_name(var, \"z\")\n\njulia> variable_by_name(model, \"y\")\n\njulia> variable_by_name(model, \"z\")\nz\n\njulia> @variable(model, u[1:2])\n2-element Array{VariableRef,1}:\n u[1]\n u[2]\n\njulia> variable_by_name(model, \"u[2]\")\nu[2]\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Start-values","page":"Variables","title":"Start values","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"set_start_value\nstart_value","category":"page"},{"location":"reference/variables/#JuMP.set_start_value","page":"Variables","title":"JuMP.set_start_value","text":"set_start_value(con_ref::ConstraintRef, value)\n\nSet the primal start value (MOI.ConstraintPrimalStart) of the constraint con_ref to value. To remove a primal start value set it to nothing.\n\nSee also start_value.\n\n\n\n\n\nset_start_value(variable::VariableRef, value::Union{Real,Nothing})\n\nSet the start value (MOI attribute VariablePrimalStart) of the variable to value.\n\nPass nothing to unset the start value.\n\nNote: VariablePrimalStarts are sometimes called \"MIP-starts\" or \"warmstarts\".\n\nSee also start_value.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.start_value","page":"Variables","title":"JuMP.start_value","text":"start_value(con_ref::ConstraintRef)\n\nReturn the primal start value (MOI.ConstraintPrimalStart) of the constraint con_ref.\n\nNote: If no primal start value has been set, start_value will return nothing.\n\nSee also set_start_value.\n\n\n\n\n\nstart_value(v::VariableRef)\n\nReturn the start value (MOI attribute VariablePrimalStart) of the variable v.\n\nNote: VariablePrimalStarts are sometimes called \"MIP-starts\" or \"warmstarts\".\n\nSee also set_start_value.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Lower-bounds","page":"Variables","title":"Lower bounds","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"has_lower_bound\nlower_bound\nset_lower_bound\ndelete_lower_bound\nLowerBoundRef","category":"page"},{"location":"reference/variables/#JuMP.has_lower_bound","page":"Variables","title":"JuMP.has_lower_bound","text":"has_lower_bound(v::VariableRef)\n\nReturn true if v has a lower bound. If true, the lower bound can be queried with lower_bound.\n\nSee also LowerBoundRef, lower_bound, set_lower_bound, delete_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.lower_bound","page":"Variables","title":"JuMP.lower_bound","text":"lower_bound(v::VariableRef)\n\nReturn the lower bound of a variable. Error if one does not exist.\n\nSee also LowerBoundRef, has_lower_bound, set_lower_bound, delete_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.set_lower_bound","page":"Variables","title":"JuMP.set_lower_bound","text":"set_lower_bound(v::VariableRef, lower::Number)\n\nSet the lower bound of a variable. If one does not exist, create a new lower bound constraint.\n\nSee also LowerBoundRef, has_lower_bound, lower_bound, delete_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.delete_lower_bound","page":"Variables","title":"JuMP.delete_lower_bound","text":"delete_lower_bound(v::VariableRef)\n\nDelete the lower bound constraint of a variable.\n\nSee also LowerBoundRef, has_lower_bound, lower_bound, set_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.LowerBoundRef","page":"Variables","title":"JuMP.LowerBoundRef","text":"LowerBoundRef(v::VariableRef)\n\nReturn a constraint reference to the lower bound constraint of v. Errors if one does not exist.\n\nSee also has_lower_bound, lower_bound, set_lower_bound, delete_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Upper-bounds","page":"Variables","title":"Upper bounds","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"has_upper_bound\nupper_bound\nset_upper_bound\ndelete_upper_bound\nUpperBoundRef","category":"page"},{"location":"reference/variables/#JuMP.has_upper_bound","page":"Variables","title":"JuMP.has_upper_bound","text":"has_upper_bound(v::VariableRef)\n\nReturn true if v has a upper bound. If true, the upper bound can be queried with upper_bound.\n\nSee also UpperBoundRef, upper_bound, set_upper_bound, delete_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.upper_bound","page":"Variables","title":"JuMP.upper_bound","text":"upper_bound(v::VariableRef)\n\nReturn the upper bound of a variable. Error if one does not exist.\n\nSee also UpperBoundRef, has_upper_bound, set_upper_bound, delete_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.set_upper_bound","page":"Variables","title":"JuMP.set_upper_bound","text":"set_upper_bound(v::VariableRef,upper::Number)\n\nSet the upper bound of a variable. If one does not exist, create an upper bound constraint.\n\nSee also UpperBoundRef, has_upper_bound, upper_bound, delete_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.delete_upper_bound","page":"Variables","title":"JuMP.delete_upper_bound","text":"delete_upper_bound(v::VariableRef)\n\nDelete the upper bound constraint of a variable.\n\nSee also UpperBoundRef, has_upper_bound, upper_bound, set_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.UpperBoundRef","page":"Variables","title":"JuMP.UpperBoundRef","text":"UpperBoundRef(v::VariableRef)\n\nReturn a constraint reference to the upper bound constraint of v. Errors if one does not exist.\n\nSee also has_upper_bound, upper_bound, set_upper_bound, delete_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Fixed-bounds","page":"Variables","title":"Fixed bounds","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"is_fixed\nfix_value\nfix\nunfix\nFixRef","category":"page"},{"location":"reference/variables/#JuMP.is_fixed","page":"Variables","title":"JuMP.is_fixed","text":"is_fixed(v::VariableRef)\n\nReturn true if v is a fixed variable. If true, the fixed value can be queried with fix_value.\n\nSee also FixRef, fix_value, fix, unfix.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.fix_value","page":"Variables","title":"JuMP.fix_value","text":"fix_value(v::VariableRef)\n\nReturn the value to which a variable is fixed. Error if one does not exist.\n\nSee also FixRef, is_fixed, fix, unfix.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.fix","page":"Variables","title":"JuMP.fix","text":"fix(v::VariableRef, value::Number; force::Bool = false)\n\nFix a variable to a value. Update the fixing constraint if one exists, otherwise create a new one.\n\nIf the variable already has variable bounds and force=false, calling fix will throw an error. If force=true, existing variable bounds will be deleted, and the fixing constraint will be added. Note a variable will have no bounds after a call to unfix.\n\nSee also FixRef, is_fixed, fix_value, unfix.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.unfix","page":"Variables","title":"JuMP.unfix","text":"unfix(v::VariableRef)\n\nDelete the fixing constraint of a variable.\n\nSee also FixRef, is_fixed, fix_value, fix.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.FixRef","page":"Variables","title":"JuMP.FixRef","text":"FixRef(v::VariableRef)\n\nReturn a constraint reference to the constraint fixing the value of v. Errors if one does not exist.\n\nSee also is_fixed, fix_value, fix, unfix.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Integer-variables","page":"Variables","title":"Integer variables","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"is_integer\nset_integer\nunset_integer\nIntegerRef","category":"page"},{"location":"reference/variables/#JuMP.is_integer","page":"Variables","title":"JuMP.is_integer","text":"is_integer(v::VariableRef)\n\nReturn true if v is constrained to be integer.\n\nSee also IntegerRef, set_integer, unset_integer.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.set_integer","page":"Variables","title":"JuMP.set_integer","text":"set_integer(variable_ref::VariableRef)\n\nAdd an integrality constraint on the variable variable_ref.\n\nSee also IntegerRef, is_integer, unset_integer.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.unset_integer","page":"Variables","title":"JuMP.unset_integer","text":"unset_integer(variable_ref::VariableRef)\n\nRemove the integrality constraint on the variable variable_ref.\n\nSee also IntegerRef, is_integer, set_integer.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.IntegerRef","page":"Variables","title":"JuMP.IntegerRef","text":"IntegerRef(v::VariableRef)\n\nReturn a constraint reference to the constraint constraining v to be integer. Errors if one does not exist.\n\nSee also is_integer, set_integer, unset_integer.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Binary-variables","page":"Variables","title":"Binary variables","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"is_binary\nset_binary\nunset_binary\nBinaryRef","category":"page"},{"location":"reference/variables/#JuMP.is_binary","page":"Variables","title":"JuMP.is_binary","text":"is_binary(v::VariableRef)\n\nReturn true if v is constrained to be binary.\n\nSee also BinaryRef, set_binary, unset_binary.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.set_binary","page":"Variables","title":"JuMP.set_binary","text":"set_binary(v::VariableRef)\n\nAdd a constraint on the variable v that it must take values in the set 01.\n\nSee also BinaryRef, is_binary, unset_binary.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.unset_binary","page":"Variables","title":"JuMP.unset_binary","text":"unset_binary(variable_ref::VariableRef)\n\nRemove the binary constraint on the variable variable_ref.\n\nSee also BinaryRef, is_binary, set_binary.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.BinaryRef","page":"Variables","title":"JuMP.BinaryRef","text":"BinaryRef(v::VariableRef)\n\nReturn a constraint reference to the constraint constraining v to be binary. Errors if one does not exist.\n\nSee also is_binary, set_binary, unset_binary.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Integrality-utilities","page":"Variables","title":"Integrality utilities","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"relax_integrality","category":"page"},{"location":"reference/variables/#JuMP.relax_integrality","page":"Variables","title":"JuMP.relax_integrality","text":"relax_integrality(model::Model)\n\nModifies model to \"relax\" all binary and integrality constraints on variables. Specifically,\n\nBinary constraints are deleted, and variable bounds are tightened if necessary to ensure the variable is constrained to the interval 0 1.\nIntegrality constraints are deleted without modifying variable bounds.\nAn error is thrown if semi-continuous or semi-integer constraints are present (support may be added for these in the future).\nAll other constraints are ignored (left in place). This includes discrete constraints like SOS and indicator constraints.\n\nReturns a function that can be called without any arguments to restore the original model. The behavior of this function is undefined if additional changes are made to the affected variables in the meantime.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x, Bin);\n\njulia> @variable(model, 1 <= y <= 10, Int);\n\njulia> @objective(model, Min, x + y);\n\njulia> undo_relax = relax_integrality(model);\n\njulia> print(model)\nMin x + y\nSubject to\n x ≥ 0.0\n y ≥ 1.0\n x ≤ 1.0\n y ≤ 10.0\n\njulia> undo_relax()\n\njulia> print(model)\nMin x + y\nSubject to\n y ≥ 1.0\n y ≤ 10.0\n y integer\n x binary\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Extensions","page":"Variables","title":"Extensions","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"AbstractVariable\nAbstractVariableRef\nparse_one_operator_variable","category":"page"},{"location":"reference/variables/#JuMP.AbstractVariable","page":"Variables","title":"JuMP.AbstractVariable","text":"AbstractVariable\n\nVariable returned by build_variable. It represents a variable that has not been added yet to any model. It can be added to a given model with add_variable.\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.AbstractVariableRef","page":"Variables","title":"JuMP.AbstractVariableRef","text":"AbstractVariableRef\n\nVariable returned by add_variable. Affine (resp. quadratic) operations with variables of type V<:AbstractVariableRef and coefficients of type T     create a GenericAffExpr{T,V} (resp. GenericQuadExpr{T,V}).\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.parse_one_operator_variable","page":"Variables","title":"JuMP.parse_one_operator_variable","text":"parse_one_operator_variable(_error::Function, infoexpr::_VariableInfoExpr, sense::Val{S}, value) where S\n\nUpdate infoexr for a variable expression in the @variable macro of the form variable name S value.\n\n\n\n\n\n","category":"function"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"The most significant part of MOI is the definition of the model API that is used to specify an instance of an optimization problem (e.g., by adding variables and constraints). Objects that implement the model API must inherit from the ModelLike abstract type.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"Notably missing from the model API is the method to solve an optimization problem. ModelLike objects may store an instance (e.g., in memory or backed by a file format) without being linked to a particular solver. In addition to the model API, MOI defines AbstractOptimizer and provides methods to solve the model and interact with solutions. See the Solutions section for more details.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"info: Info\nThroughout the rest of the manual, model is used as a generic ModelLike, and optimizer is used as a generic AbstractOptimizer.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"tip: Tip\nMOI does not export functions, but for brevity we often omit qualifying names with the MOI module. Best practice is to haveusing MathOptInterface\nconst MOI = MathOptInterfaceand prefix all MOI methods with MOI. in user code. If a name is also available in base Julia, we always explicitly use the module prefix, for example, with MOI.get.","category":"page"},{"location":"moi/manual/models/#Attributes","page":"Models","title":"Attributes","text":"","category":"section"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"Attributes are properties of the model that can be queried and modified. These include constants such as the number of variables in a model NumberOfVariables), and properties of variables and constraints such as the name of a variable (VariableName).","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"There are four types of attributes:","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"Model attributes (subtypes of AbstractModelAttribute) refer to properties of a model.\nOptimizer attributes (subtypes of AbstractOptimizerAttribute) refer to properties of an optimizer.\nConstraint attributes (subtypes of AbstractConstraintAttribute) refer to properties of an individual constraint.\nVariable attributes (subtypes of AbstractVariableAttribute) refer to properties of an individual variable.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"Some attributes are values that can be queried by the user but not modified, while other attributes can be modified by the user.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"All interactions with attributes occur through the get and set functions.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"Consult the docstsrings of each attribute for information on what it represents.","category":"page"},{"location":"moi/manual/models/#ModelLike-API","page":"Models","title":"ModelLike API","text":"","category":"section"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"The following attributes are available:","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"ListOfConstraintAttributesSet\nListOfConstraintIndices\nListOfConstraintTypesPresent\nListOfModelAttributesSet\nListOfVariableAttributesSet\nListOfVariableIndices\nNumberOfConstraints\nNumberOfVariables\nName\nObjectiveFunction\nObjectiveFunctionType\nObjectiveSense","category":"page"},{"location":"moi/manual/models/#AbstractOptimizer-API","page":"Models","title":"AbstractOptimizer API","text":"","category":"section"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"The following attributes are available:","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"DualStatus\nPrimalStatus\nRawStatusString\nResultCount\nTerminationStatus\nBarrierIterations\nDualObjectiveValue\nNodeCount\nNumberOfThreads\nObjectiveBound\nObjectiveValue\nRelativeGap\nRawOptimizerAttribute\nRawSolver\nSilent\nSimplexIterations\nSolverName\nSolverVersion\nSolveTimeSec\nTimeLimitSec","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/nonlinear/portfolio.jl\"","category":"page"},{"location":"tutorials/nonlinear/portfolio/#Quadratic-portfolio-optimization","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"","category":"section"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Optimization models play an increasingly important role in financial decisions. Many computational finance problems can be solved efficiently using modern optimization techniques.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"This tutorial solves the famous Markowitz Portfolio Optimization problem with data from lecture notes from a course taught at Georgia Tech by Shabir Ahmed.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"This tutorial uses the following packages","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"using JuMP\nimport Ipopt\nimport Statistics","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Suppose we are considering investing 1000 dollars in three non-dividend paying stocks, IBM (IBM), Walmart (WMT), and Southern Electric (SEHI), for a one-month period.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"We will use the initial money to buy shares of the three stocks at the current market prices, hold these for one month, and sell the shares off at the prevailing market prices at the end of the month.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"As a rational investor, we hope to make some profit out of this endeavor, i.e., the return on our investment should be positive.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Suppose we bought a stock at p dollars per share in the beginning of the month, and sold it off at s dollars per share at the end of the month. Then the one-month return on a share of the stock is fracs-pp.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Since the stock prices are quite uncertain, so is the end-of-month return on our investment. Our goal is to invest in such a way that the expected end-of-month return is at least $50 or 5%. Furthermore, we want to make sure that the “risk” of not achieving our desired return is minimum.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Note that we are solving the problem under the following assumptions:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"We can trade any continuum of shares.\nNo short-selling is allowed.\nThere are no transaction costs.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"We model this problem by taking decision variables x_i i=123 denoting the dollars invested in each of the 3 stocks.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Let us denote by tilder_i the random variable corresponding to the monthly return (increase in the stock price) per dollar for stock i.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Then, the return (or profit) on x_i dollars invested in stock i is tilder_i x_i and the total (random) return on our investment is sum_i=1^3 tilder_i x_i The expected return on our investment is then mathbbEleftsum_i=1^3 tilder_i x_iright=sum_i=1^3 overliner_i x_i where overliner_i is the expected value of the tilder_i","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Now we need to quantify the notion of “risk” in our investment.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Markowitz, in his Nobel prize winning work, showed that a rational investor’s notion of minimizing risk can be closely approximated by minimizing the variance of the return of the investment portfolio. This variance is given by:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"operatornameVarleftsum_i=1^3 tilder_i x_iright = sum_i=1^3 sum_j=1^3 x_i x_j sigma_i j","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"where sigma_i j is the covariance of the return of stock i with stock j.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Note that the right hand side of the equation is the most reduced form of the expression and we have not shown the intermediate steps involved in getting to this form. We can also write this equation as:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"operatornameVarleftsum_i=1^3 tilder_i x_iright =x^T Q x","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Where Q is the covariance matrix for the random vector tilder.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Finally, we can write the model as:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"beginaligned\nmin x^T Q x \ntext  st  sum_i=1^3 x_i leq 100000 \noverliner^T x geq 5000 \nx geq 0\nendaligned","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"After that long discussion, let's now use JuMP to solve the portfolio optimization problem for the data given below.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Month IBM WMT SEHI\nNovember-00 93.043 51.826 1.063\nDecember-00 84.585 52.823 0.938\nJanuary-01 111.453 56.477 1.000\nFebruary-01 99.525 49.805 0.938\nMarch-01 95.819 50.287 1.438\nApril-01 114.708 51.521 1.700\nMay-01 111.515 51.531 2.540\nJune-01 113.211 48.664 2.390\nJuly-01 104.942 55.744 3.120\nAugust-01 99.827 47.916 2.980\nSeptember-01 91.607 49.438 1.900\nOctober-01 107.937 51.336 1.750\nNovember-01 115.590 55.081 1.800","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"stock_data = [\n    93.043 51.826 1.063\n    84.585 52.823 0.938\n    111.453 56.477 1.000\n    99.525 49.805 0.938\n    95.819 50.287 1.438\n    114.708 51.521 1.700\n    111.515 51.531 2.540\n    113.211 48.664 2.390\n    104.942 55.744 3.120\n    99.827 47.916 2.980\n    91.607 49.438 1.900\n    107.937 51.336 1.750\n    115.590 55.081 1.800\n]","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Calculating stock returns","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"stock_returns = Array{Float64}(undef, 12, 3)\nfor i in 1:12\n    stock_returns[i, :] =\n        (stock_data[i+1, :] .- stock_data[i, :]) ./ stock_data[i, :]\nend\nstock_returns","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Calculating the expected value of monthly return:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"r = Statistics.mean(stock_returns, dims = 1)","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Calculating the covariance matrix Q","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"Q = Statistics.cov(stock_returns)","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"JuMP Model","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"portfolio = Model(Ipopt.Optimizer)\nset_silent(portfolio)\n@variable(portfolio, x[1:3] >= 0)\n@objective(portfolio, Min, x' * Q * x)\n@constraint(portfolio, sum(x) <= 1000)\n@constraint(portfolio, sum(r[i] * x[i] for i in 1:3) >= 50)\noptimize!(portfolio)\n\nobjective_value(portfolio)","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"value.(x)","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Quadratic portfolio optimization","title":"Quadratic portfolio optimization","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"reference/models/#ModelAPI","page":"Models","title":"Models","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"More information can be found in the Models section of the manual.","category":"page"},{"location":"reference/models/#Constructors","page":"Models","title":"Constructors","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"Model\ndirect_model","category":"page"},{"location":"reference/models/#JuMP.Model","page":"Models","title":"JuMP.Model","text":"Model\n\nA mathematical model of an optimization problem.\n\n\n\n\n\n","category":"type"},{"location":"reference/models/#JuMP.direct_model","page":"Models","title":"JuMP.direct_model","text":"direct_model(backend::MOI.ModelLike)\n\nReturn a new JuMP model using backend to store the model and solve it.\n\nAs opposed to the Model constructor, no cache of the model is stored outside of backend and no bridges are automatically applied to backend.\n\nNotes\n\nThe absence of a cache reduces the memory footprint but, it is important to bear in mind the following implications of creating models using this direct mode:\n\nWhen backend does not support an operation, such as modifying constraints or adding variables/constraints after solving, an error is thrown. For models created using the Model constructor, such situations can be dealt with by storing the modifications in a cache and loading them into the optimizer when optimize! is called.\nNo constraint bridging is supported by default.\nThe optimizer used cannot be changed the model is constructed.\nThe model created cannot be copied.\n\n\n\n\n\ndirect_model(factory::MOI.OptimizerWithAttributes)\n\nCreate a direct_model using factory, a MOI.OptimizerWithAttributes object created by optimizer_with_attributes.\n\nExample\n\nmodel = direct_model(\n    optimizer_with_attributes(\n        Gurobi.Optimizer,\n        \"Presolve\" => 0,\n        \"OutputFlag\" => 1,\n    )\n)\n\nis equivalent to:\n\nmodel = direct_model(Gurobi.Optimizer())\nset_optimizer_attribute(model, \"Presolve\", 0)\nset_optimizer_attribute(model, \"OutputFlag\", 1)\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Enums","page":"Models","title":"Enums","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"ModelMode\nAUTOMATIC\nMANUAL\nDIRECT","category":"page"},{"location":"reference/models/#JuMP.ModelMode","page":"Models","title":"JuMP.ModelMode","text":"ModelMode\n\nAn enum to describe the state of the CachingOptimizer inside a JuMP model.\n\n\n\n\n\n","category":"type"},{"location":"reference/models/#JuMP.AUTOMATIC","page":"Models","title":"JuMP.AUTOMATIC","text":"moi_backend field holds a CachingOptimizer in AUTOMATIC mode.\n\n\n\n\n\n","category":"constant"},{"location":"reference/models/#JuMP.MANUAL","page":"Models","title":"JuMP.MANUAL","text":"moi_backend field holds a CachingOptimizer in MANUAL mode.\n\n\n\n\n\n","category":"constant"},{"location":"reference/models/#JuMP.DIRECT","page":"Models","title":"JuMP.DIRECT","text":"moi_backend field holds an AbstractOptimizer. No extra copy of the model is stored. The moi_backend must support add_constraint etc.\n\n\n\n\n\n","category":"constant"},{"location":"reference/models/#Basic-functions","page":"Models","title":"Basic functions","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"backend\nunsafe_backend\nname(::AbstractModel)\nsolver_name\nBase.empty!(::Model)\nBase.isempty(::Model)\nmode\nobject_dictionary\nunregister\nlatex_formulation","category":"page"},{"location":"reference/models/#JuMP.backend","page":"Models","title":"JuMP.backend","text":"backend(model::Model)\n\nReturn the lower-level MathOptInterface model that sits underneath JuMP. This model depends on which operating mode JuMP is in (see mode).\n\nIf JuMP is in DIRECT mode (i.e., the model was created using direct_model), the backend will be the optimizer passed to direct_model.\nIf JuMP is in MANUAL or AUTOMATIC mode, the backend is a MOI.Utilities.CachingOptimizer.\n\nThis function should only be used by advanced users looking to access low-level MathOptInterface or solver-specific functionality.\n\nNotes\n\nIf JuMP is not in DIRECT mode, the type returned by backend may change between any JuMP releases. Therefore, only use the public API exposed by MathOptInterface, and do not access internal fields. If you require access to the innermost optimizer, see unsafe_backend. Alternatively, use direct_model to create a JuMP model in DIRECT mode.\n\nSee also: unsafe_backend.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.unsafe_backend","page":"Models","title":"JuMP.unsafe_backend","text":"unsafe_backend(model::Model)\n\nReturn the innermost optimizer associated with the JuMP model model.\n\nThis function should only be used by advanced users looking to access low-level solver-specific functionality. It has a high-risk of incorrect usage. We strongly suggest you use the alternative suggested below.\n\nSee also: backend.\n\nUnsafe behavior\n\nThis function is unsafe for two main reasons.\n\nFirst, the formulation and order of variables and constraints in the unsafe backend may be different to the variables and constraints in model. This can happen because of bridges, or because the solver requires the variables or constraints in a specific order. In addition, the variable or constraint index returned by index at the JuMP level may be different to the index of the corresponding variable or constraint in the unsafe_backend. There is no solution to this. Use the alternative suggested below instead.\n\nSecond, the unsafe_backend may be empty, or lack some modifications made to the JuMP model. Thus, before calling unsafe_backend you should first call MOI.Utilities.attach_optimizer to ensure that the backend is synchronized with the JuMP model.\n\nMOI.Utilities.attach_optimizer(model)\ninner = unsafe_backend(model)\n\nMoreover, if you modify the JuMP model, the reference you have to the backend (i.e., inner in the example above) may be out-dated, and you should call MOI.Utilities.attach_optimizer again.\n\nThis function is also unsafe in the reverse direction: if you modify the unsafe backend, e.g., by adding a new constraint to inner, the changes may be silently discarded by JuMP when the JuMP model is modified or solved.\n\nAlternative\n\nInstead of unsafe_backend, create a model using direct_model and call backend instead.\n\nFor example, instead of:\n\nmodel = Model(GLPK.Optimizer)\n@variable(model, x >= 0)\nMOI.Utilities.attach_optimizer(model)\nglpk = unsafe_backend(model)\n\nUse:\n\nmodel = direct_model(GLPK.Optimizer())\n@variable(model, x >= 0)\nglpk = backend(model)  # No need to call `attach_optimizer`.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.name-Tuple{AbstractModel}","page":"Models","title":"JuMP.name","text":"name(model::AbstractModel)\n\nReturn the MOI.Name attribute of model's backend, or a default if empty.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#JuMP.solver_name","page":"Models","title":"JuMP.solver_name","text":"solver_name(model::Model)\n\nIf available, returns the SolverName property of the underlying optimizer.\n\nReturns \"No optimizer attached\" in AUTOMATIC or MANUAL modes when no optimizer is attached.\n\nReturns \"SolverName() attribute not implemented by the optimizer.\" if the attribute is not implemented.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Base.empty!-Tuple{Model}","page":"Models","title":"Base.empty!","text":"empty!(model::Model)::Model\n\nEmpty the model, that is, remove all variables, constraints and model attributes but not optimizer attributes. Always return the argument.\n\nNote: removes extensions data.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#Base.isempty-Tuple{Model}","page":"Models","title":"Base.isempty","text":"isempty(model::Model)\n\nVerifies whether the model is empty, that is, whether the MOI backend is empty and whether the model is in the same state as at its creation apart from optimizer attributes.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#JuMP.mode","page":"Models","title":"JuMP.mode","text":"mode(model::Model)\n\nReturn the ModelMode (DIRECT, AUTOMATIC, or MANUAL) of model.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.object_dictionary","page":"Models","title":"JuMP.object_dictionary","text":"object_dictionary(model::Model)\n\nReturn the dictionary that maps the symbol name of a variable, constraint, or expression to the corresponding object.\n\nObjects are registered to a specific symbol in the macros. For example, @variable(model, x[1:2, 1:2]) registers the array of variables x to the symbol :x.\n\nThis method should be defined for any subtype of AbstractModel.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.unregister","page":"Models","title":"JuMP.unregister","text":"unregister(model::Model, key::Symbol)\n\nUnregister the name key from model so that a new variable, constraint, or expression can be created with the same key.\n\nNote that this will not delete the object model[key]; it will just remove the reference at model[key]. To delete the object, use\n\ndelete(model, model[key])\nunregister(model, key)\n\nSee also: object_dictionary.\n\nExamples\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, x)\nERROR: An object of name x is already attached to this model. If\nthis is intended, consider using the anonymous construction syntax,\ne.g., `x = @variable(model, [1:N], ...)` where the name of the object\ndoes not appear inside the macro.\n\nAlternatively, use `unregister(model, :x)` to first unregister the\nexisting name from the model. Note that this will not delete the object;\nit will just remove the reference at `model[:x]`.\n[...]\n\njulia> num_variables(model)\n1\n\njulia> unregister(model, :x)\n\njulia> @variable(model, x)\nx\n\njulia> num_variables(model)\n2\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.latex_formulation","page":"Models","title":"JuMP.latex_formulation","text":"latex_formulation(model::AbstractModel)\n\nWrap model in a type so that it can be pretty-printed as text/latex in a notebook like IJulia, or in Documenter.\n\nTo render the model, end the cell with latex_formulation(model), or call display(latex_formulation(model)) in to force the display of the model from inside a function.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Working-with-attributes","page":"Models","title":"Working with attributes","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"set_optimizer\noptimizer_with_attributes\nget_optimizer_attribute\nset_optimizer_attribute\nset_optimizer_attributes\nset_silent\nunset_silent\nset_time_limit_sec\nunset_time_limit_sec\ntime_limit_sec","category":"page"},{"location":"reference/models/#JuMP.set_optimizer","page":"Models","title":"JuMP.set_optimizer","text":"set_optimizer(\n    model::Model,\n    optimizer_factory;\n    add_bridges::Bool = true,\n)\n\nCreates an empty MathOptInterface.AbstractOptimizer instance by calling optimizer_factory() and sets it as the optimizer of model. Specifically, optimizer_factory must be callable with zero arguments and return an empty MathOptInterface.AbstractOptimizer.\n\nIf add_bridges is true, constraints and objectives that are not supported by the optimizer are automatically bridged to equivalent supported formulation. Passing add_bridges = false can improve performance if the solver natively supports all of the elements in model.\n\nSee set_optimizer_attributes and set_optimizer_attribute for setting solver-specific parameters of the optimizer.\n\nExamples\n\nmodel = Model()\nset_optimizer(model, GLPK.Optimizer)\nset_optimizer(model, GLPK.Optimizer; add_bridges = false)\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.optimizer_with_attributes","page":"Models","title":"JuMP.optimizer_with_attributes","text":"optimizer_with_attributes(optimizer_constructor, attrs::Pair...)\n\nGroups an optimizer constructor with the list of attributes attrs. Note that it is equivalent to MOI.OptimizerWithAttributes.\n\nWhen provided to the Model constructor or to set_optimizer, it creates an optimizer by calling optimizer_constructor(), and then sets the attributes using set_optimizer_attribute.\n\nExample\n\nmodel = Model(\n    optimizer_with_attributes(\n        Gurobi.Optimizer, \"Presolve\" => 0, \"OutputFlag\" => 1\n    )\n)\n\nis equivalent to:\n\nmodel = Model(Gurobi.Optimizer)\nset_optimizer_attribute(model, \"Presolve\", 0)\nset_optimizer_attribute(model, \"OutputFlag\", 1)\n\nNote\n\nThe string names of the attributes are specific to each solver. One should consult the solver's documentation to find the attributes of interest.\n\nSee also: set_optimizer_attribute, set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.get_optimizer_attribute","page":"Models","title":"JuMP.get_optimizer_attribute","text":"get_optimizer_attribute(model, name::String)\n\nReturn the value associated with the solver-specific attribute named name.\n\nNote that this is equivalent to get_optimizer_attribute(model, MOI.RawOptimizerAttribute(name)).\n\nExample\n\nget_optimizer_attribute(model, \"SolverSpecificAttributeName\")\n\nSee also: set_optimizer_attribute, set_optimizer_attributes.\n\n\n\n\n\nget_optimizer_attribute(\n    model::Model, attr::MOI.AbstractOptimizerAttribute\n)\n\nReturn the value of the solver-specific attribute attr in model.\n\nExample\n\nget_optimizer_attribute(model, MOI.Silent())\n\nSee also: set_optimizer_attribute, set_optimizer_attributes.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.set_optimizer_attribute","page":"Models","title":"JuMP.set_optimizer_attribute","text":"set_optimizer_attribute(model::Model, name::String, value)\n\nSets solver-specific attribute identified by name to value.\n\nNote that this is equivalent to set_optimizer_attribute(model, MOI.RawOptimizerAttribute(name), value).\n\nExample\n\nset_optimizer_attribute(model, \"SolverSpecificAttributeName\", true)\n\nSee also: set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\nset_optimizer_attribute(\n    model::Model,\n    attr::MOI.AbstractOptimizerAttribute,\n    value,\n)\n\nSet the solver-specific attribute attr in model to value.\n\nExample\n\nset_optimizer_attribute(model, MOI.Silent(), true)\n\nSee also: set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.set_optimizer_attributes","page":"Models","title":"JuMP.set_optimizer_attributes","text":"set_optimizer_attributes(model::Model, pairs::Pair...)\n\nGiven a list of attribute => value pairs, calls set_optimizer_attribute(model, attribute, value) for each pair.\n\nExample\n\nmodel = Model(Ipopt.Optimizer)\nset_optimizer_attributes(model, \"tol\" => 1e-4, \"max_iter\" => 100)\n\nis equivalent to:\n\nmodel = Model(Ipopt.Optimizer)\nset_optimizer_attribute(model, \"tol\", 1e-4)\nset_optimizer_attribute(model, \"max_iter\", 100)\n\nSee also: set_optimizer_attribute, get_optimizer_attribute.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.set_silent","page":"Models","title":"JuMP.set_silent","text":"set_silent(model::Model)\n\nTakes precedence over any other attribute controlling verbosity and requires the solver to produce no output.\n\nSee also: unset_silent.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.unset_silent","page":"Models","title":"JuMP.unset_silent","text":"unset_silent(model::Model)\n\nNeutralize the effect of the set_silent function and let the solver attributes control the verbosity.\n\nSee also: set_silent.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.set_time_limit_sec","page":"Models","title":"JuMP.set_time_limit_sec","text":"set_time_limit_sec(model::Model, limit::Float64)\n\nSet the time limit (in seconds) of the solver.\n\nCan be unset using unset_time_limit_sec or with limit set to nothing.\n\nSee also: unset_time_limit_sec, time_limit_sec.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.unset_time_limit_sec","page":"Models","title":"JuMP.unset_time_limit_sec","text":"unset_time_limit_sec(model::Model)\n\nUnset the time limit of the solver.\n\nSee also: set_time_limit_sec, time_limit_sec.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.time_limit_sec","page":"Models","title":"JuMP.time_limit_sec","text":"time_limit_sec(model::Model)\n\nReturn the time limit (in seconds) of the model.\n\nReturns nothing if unset.\n\nSee also: set_time_limit_sec, unset_time_limit_sec.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Copying","page":"Models","title":"Copying","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"ReferenceMap\ncopy_model\ncopy_extension_data\nBase.copy(::AbstractModel)","category":"page"},{"location":"reference/models/#JuMP.ReferenceMap","page":"Models","title":"JuMP.ReferenceMap","text":"ReferenceMap\n\nMapping between variable and constraint reference of a model and its copy. The reference of the copied model can be obtained by indexing the map with the reference of the corresponding reference of the original model.\n\n\n\n\n\n","category":"type"},{"location":"reference/models/#JuMP.copy_model","page":"Models","title":"JuMP.copy_model","text":"copy_model(model::Model; filter_constraints::Union{Nothing, Function}=nothing)\n\nReturn a copy of the model model and a ReferenceMap that can be used to obtain the variable and constraint reference of the new model corresponding to a given model's reference. A Base.copy(::AbstractModel) method has also been implemented, it is similar to copy_model but does not return the reference map.\n\nIf the filter_constraints argument is given, only the constraints for which this function returns true will be copied. This function is given a constraint reference as argument.\n\nNote\n\nModel copy is not supported in DIRECT mode, i.e. when a model is constructed using the direct_model constructor instead of the Model constructor. Moreover, independently on whether an optimizer was provided at model construction, the new model will have no optimizer, i.e., an optimizer will have to be provided to the new model in the optimize! call.\n\nExamples\n\nIn the following example, a model model is constructed with a variable x and a constraint cref. It is then copied into a model new_model with the new references assigned to x_new and cref_new.\n\nmodel = Model()\n@variable(model, x)\n@constraint(model, cref, x == 2)\n\nnew_model, reference_map = copy_model(model)\nx_new = reference_map[x]\ncref_new = reference_map[cref]\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.copy_extension_data","page":"Models","title":"JuMP.copy_extension_data","text":"copy_extension_data(data, new_model::AbstractModel, model::AbstractModel)\n\nReturn a copy of the extension data data of the model model to the extension data of the new model new_model.\n\nA method should be added for any JuMP extension storing data in the ext field.\n\nwarning: Warning\nDo not engage in type piracy by implementing this method for types of data that you did not define! JuMP extensions should store types that they define in model.ext, rather than regular Julia types.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Base.copy-Tuple{AbstractModel}","page":"Models","title":"Base.copy","text":"copy(model::AbstractModel)\n\nReturn a copy of the model model. It is similar to copy_model except that it does not return the mapping between the references of model and its copy.\n\nNote\n\nModel copy is not supported in DIRECT mode, i.e. when a model is constructed using the direct_model constructor instead of the Model constructor. Moreover, independently on whether an optimizer was provided at model construction, the new model will have no optimizer, i.e., an optimizer will have to be provided to the new model in the optimize! call.\n\nExamples\n\nIn the following example, a model model is constructed with a variable x and a constraint cref. It is then copied into a model new_model with the new references assigned to x_new and cref_new.\n\nmodel = Model()\n@variable(model, x)\n@constraint(model, cref, x == 2)\n\nnew_model = copy(model)\nx_new = model[:x]\ncref_new = model[:cref]\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#I/O","page":"Models","title":"I/O","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"write_to_file\nBase.write(::IO, ::Model; ::MOI.FileFormats.FileFormat)\nread_from_file\nBase.read(::IO, ::Type{Model}; ::MOI.FileFormats.FileFormat)","category":"page"},{"location":"reference/models/#JuMP.write_to_file","page":"Models","title":"JuMP.write_to_file","text":"write_to_file(\n    model::Model,\n    filename::String;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_AUTOMATIC\n)\n\nWrite the JuMP model model to filename in the format format.\n\nIf the filename ends in .gz, it will be compressed using Gzip. If the filename ends in .bz2, it will be compressed using BZip2.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Base.write-Tuple{IO, Model}","page":"Models","title":"Base.write","text":"Base.write(\n    io::IO,\n    model::Model;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_MOF\n)\n\nWrite the JuMP model model to io in the format format.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#JuMP.read_from_file","page":"Models","title":"JuMP.read_from_file","text":"read_from_file(\n    filename::String;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_AUTOMATIC\n)\n\nReturn a JuMP model read from filename in the format format.\n\nIf the filename ends in .gz, it will be uncompressed using Gzip. If the filename ends in .bz2, it will be uncompressed using BZip2.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Base.read-Tuple{IO, Type{Model}}","page":"Models","title":"Base.read","text":"Base.read(io::IO, ::Type{Model}; format::MOI.FileFormats.FileFormat)\n\nReturn a JuMP model read from io in the format format.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#Caching-Optimizer","page":"Models","title":"Caching Optimizer","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"MOIU.reset_optimizer(::JuMP.Model)\nMOIU.drop_optimizer(::JuMP.Model)\nMOIU.attach_optimizer(::JuMP.Model)","category":"page"},{"location":"reference/models/#MathOptInterface.Utilities.reset_optimizer-Tuple{Model}","page":"Models","title":"MathOptInterface.Utilities.reset_optimizer","text":"MOIU.reset_optimizer(model::Model)\n\nCall MOIU.reset_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#MathOptInterface.Utilities.drop_optimizer-Tuple{Model}","page":"Models","title":"MathOptInterface.Utilities.drop_optimizer","text":"MOIU.drop_optimizer(model::Model)\n\nCall MOIU.drop_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#MathOptInterface.Utilities.attach_optimizer-Tuple{Model}","page":"Models","title":"MathOptInterface.Utilities.attach_optimizer","text":"MOIU.attach_optimizer(model::Model)\n\nCall MOIU.attach_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#Bridge-tools","page":"Models","title":"Bridge tools","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"bridge_constraints\nprint_bridge_graph","category":"page"},{"location":"reference/models/#JuMP.bridge_constraints","page":"Models","title":"JuMP.bridge_constraints","text":"bridge_constraints(model::Model)\n\nWhen in direct mode, return false. When in manual or automatic mode, return a Bool indicating whether the optimizer is set and unsupported constraints are automatically bridged to equivalent supported constraints when an appropriate transformation is available.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.print_bridge_graph","page":"Models","title":"JuMP.print_bridge_graph","text":" print_bridge_graph([io::IO,] model::Model)\n\nPrint the hyper-graph containing all variable, constraint, and objective types that could be obtained by bridging the variables, constraints, and objectives that are present in the model.\n\nEach node in the hyper-graph corresponds to a variable, constraint, or objective type.\n\nVariable nodes are indicated by [ ]\nConstraint nodes are indicated by ( )\nObjective nodes are indicated by | |\n\nThe number inside each pair of brackets is an index of the node in the hyper-graph.\n\nNote that this hyper-graph is the full list of possible transformations. When the bridged model is created, we select the shortest hyper-path(s) from this graph, so many nodes may be un-used.\n\nFor more information, see Legat, B., Dowson, O., Garcia, J., and Lubin, M. (2020).  \"MathOptInterface: a data structure for mathematical optimization problems.\" URL: https://arxiv.org/abs/2002.03447\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Extension-tools","page":"Models","title":"Extension tools","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"AbstractModel\noperator_warn\nerror_if_direct_mode","category":"page"},{"location":"reference/models/#JuMP.AbstractModel","page":"Models","title":"JuMP.AbstractModel","text":"AbstractModel\n\nAn abstract type that should be subtyped for users creating JuMP extensions.\n\n\n\n\n\n","category":"type"},{"location":"reference/models/#JuMP.operator_warn","page":"Models","title":"JuMP.operator_warn","text":"operator_warn(model::AbstractModel)\noperator_warn(model::Model)\n\nThis function is called on the model whenever two affine expressions are added together without using destructive_add!, and at least one of the two expressions has more than 50 terms.\n\nFor the case of Model, if this function is called more than 20,000 times then a warning is generated once.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.error_if_direct_mode","page":"Models","title":"JuMP.error_if_direct_mode","text":"error_if_direct_mode(model::Model, func::Symbol)\n\nErrors if model is in direct mode during a call from the function named func.\n\nUsed internally within JuMP, or by JuMP extensions who do not want to support models in direct mode.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/conic/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/conic/min_distortion.jl\"","category":"page"},{"location":"tutorials/conic/min_distortion/#The-minimum-distortion-problem","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"","category":"section"},{"location":"tutorials/conic/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"This example arises from computational geometry, in particular the problem of embedding a general finite metric space into a euclidean space.","category":"page"},{"location":"tutorials/conic/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"It is known that the 4-point metric space defined by the star graph:","category":"page"},{"location":"tutorials/conic/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"x\n \\\\\n  x — x\n /\nx","category":"page"},{"location":"tutorials/conic/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"where distances are computed by length of the shortest path between vertices, cannot be exactly embedded into a euclidean space of any dimension.","category":"page"},{"location":"tutorials/conic/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"Here we will formulate and solve an SDP to compute the best possible embedding, that is, the embedding f() that minimizes the distortion c such that","category":"page"},{"location":"tutorials/conic/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"(1 / c) * D(a, b) ≤ ||f(a) - f(b)|| ≤ D(a, b)","category":"page"},{"location":"tutorials/conic/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"for all points (a, b), where D(a, b) is the distance in the metric space.","category":"page"},{"location":"tutorials/conic/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"Any embedding can be characterized by its Gram matrix Q, which is PSD, and","category":"page"},{"location":"tutorials/conic/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"||f(a) - f(b)||^2 = Q[a, a] + Q[b, b] - 2 * Q[a, b]","category":"page"},{"location":"tutorials/conic/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"We can therefore constrain","category":"page"},{"location":"tutorials/conic/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"D[i, j]^2 ≤ Q[i, i] + Q[j, j] - 2 * Q[i, j] ≤ c^2 * D[i, j]^2","category":"page"},{"location":"tutorials/conic/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"and minimize c^2, which gives us the SDP formulation below.","category":"page"},{"location":"tutorials/conic/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"For more detail, see \"Lectures on discrete geometry\" by J. Matoušek, Springer, 2002, pp. 378-379.","category":"page"},{"location":"tutorials/conic/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"using JuMP\nimport SCS\nimport Test\n\nfunction example_min_distortion()\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    D = [\n        0.0 1.0 1.0 1.0\n        1.0 0.0 2.0 2.0\n        1.0 2.0 0.0 2.0\n        1.0 2.0 2.0 0.0\n    ]\n    @variable(model, c² >= 1.0)\n    @variable(model, Q[1:4, 1:4], PSD)\n    for i in 1:4\n        for j in (i+1):4\n            @constraint(model, D[i, j]^2 <= Q[i, i] + Q[j, j] - 2 * Q[i, j])\n            @constraint(\n                model,\n                Q[i, i] + Q[j, j] - 2 * Q[i, j] <= c² * D[i, j]^2\n            )\n        end\n    end\n    @objective(model, Min, c²)\n    optimize!(model)\n    Test.@test termination_status(model) == OPTIMAL\n    Test.@test primal_status(model) == FEASIBLE_POINT\n    Test.@test objective_value(model) ≈ 4 / 3 atol = 1e-4\n    return\nend\n\nexample_min_distortion()","category":"page"},{"location":"tutorials/conic/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"","category":"page"},{"location":"tutorials/conic/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"moi/reference/modification/","page":"Modifications","title":"Modifications","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    using MathOptInterface\n    const MOI = MathOptInterface\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/modification/#Modifications","page":"Modifications","title":"Modifications","text":"","category":"section"},{"location":"moi/reference/modification/","page":"Modifications","title":"Modifications","text":"modify\nAbstractFunctionModification\nScalarConstantChange\nVectorConstantChange\nScalarCoefficientChange\nMultirowChange","category":"page"},{"location":"moi/reference/modification/#MathOptInterface.modify","page":"Modifications","title":"MathOptInterface.modify","text":"Constraint Function\n\nmodify(model::ModelLike, ci::ConstraintIndex, change::AbstractFunctionModification)\n\nApply the modification specified by change to the function of constraint ci.\n\nAn ModifyConstraintNotAllowed error is thrown if modifying constraints is not supported by the model model.\n\nExamples\n\nmodify(model, ci, ScalarConstantChange(10.0))\n\nObjective Function\n\nmodify(model::ModelLike, ::ObjectiveFunction, change::AbstractFunctionModification)\n\nApply the modification specified by change to the objective function of model. To change the function completely, call set instead.\n\nAn ModifyObjectiveNotAllowed error is thrown if modifying objectives is not supported by the model model.\n\nExamples\n\nmodify(model, ObjectiveFunction{ScalarAffineFunction{Float64}}(), ScalarConstantChange(10.0))\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/modification/#MathOptInterface.AbstractFunctionModification","page":"Modifications","title":"MathOptInterface.AbstractFunctionModification","text":"AbstractFunctionModification\n\nAn abstract supertype for structs which specify partial modifications to functions, to be used for making small modifications instead of replacing the functions entirely.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/modification/#MathOptInterface.ScalarConstantChange","page":"Modifications","title":"MathOptInterface.ScalarConstantChange","text":"ScalarConstantChange{T}(new_constant::T)\n\nA struct used to request a change in the constant term of a scalar-valued function. Applicable to ScalarAffineFunction and ScalarQuadraticFunction.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/modification/#MathOptInterface.VectorConstantChange","page":"Modifications","title":"MathOptInterface.VectorConstantChange","text":"VectorConstantChange{T}(new_constant::Vector{T})\n\nA struct used to request a change in the constant vector of a vector-valued function. Applicable to VectorAffineFunction and VectorQuadraticFunction.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/modification/#MathOptInterface.ScalarCoefficientChange","page":"Modifications","title":"MathOptInterface.ScalarCoefficientChange","text":"ScalarCoefficientChange{T}(variable::VariableIndex, new_coefficient::T)\n\nA struct used to request a change in the linear coefficient of a single variable in a scalar-valued function. Applicable to ScalarAffineFunction and ScalarQuadraticFunction.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/modification/#MathOptInterface.MultirowChange","page":"Modifications","title":"MathOptInterface.MultirowChange","text":"MultirowChange{T}(variable::VariableIndex, new_coefficients::Vector{Tuple{Int64, T}})\n\nA struct used to request a change in the linear coefficients of a single variable in a vector-valued function. New coefficients are specified by (output_index, coefficient) tuples. Applicable to VectorAffineFunction and VectorQuadraticFunction.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/conic/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/conic/min_ellipse.jl\"","category":"page"},{"location":"tutorials/conic/min_ellipse/#Minimum-ellipses","page":"Minimum ellipses","title":"Minimum ellipses","text":"","category":"section"},{"location":"tutorials/conic/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"This example is from the Boyd & Vandenberghe book \"Convex Optimization\". Given a set of ellipses centered on the origin","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"E(A) = { u | u^T inv(A) u <= 1 }","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"find a \"minimal\" ellipse that contains the provided ellipses.","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"We can formulate this as an SDP:","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"minimize    trace(WX)\nsubject to  X >= A_i,    i = 1,...,m\n            X PSD","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"where W is a PD matrix of weights to choose between different solutions.","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"using JuMP\nimport LinearAlgebra\nimport SCS\nimport Test\n\nfunction example_min_ellipse()\n    # We will use three ellipses: two \"simple\" ones, and a random one.\n    As = [\n        [2.0 0.0; 0.0 1.0],\n        [1.0 0.0; 0.0 3.0],\n        [2.86715 1.60645; 1.60645 1.12639],\n    ]\n    # We change the weights to see different solutions, if they exist\n    weights = [1.0 0.0; 0.0 1.0]\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, X[i = 1:2, j = 1:2], PSD)\n    @objective(model, Min, LinearAlgebra.tr(weights * X))\n    @constraint(model, [As_i in As], X >= As_i, PSDCone())\n    optimize!(model)\n    Test.@test termination_status(model) == OPTIMAL\n    Test.@test primal_status(model) == FEASIBLE_POINT\n    Test.@test objective_value(model) ≈ 6.46233 atol = 1e-5\n    Test.@test value.(X) ≈ [3.1651 0.8022; 0.8022 3.2972] atol = 1e-4\n    return\nend\n\nexample_min_ellipse()","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/nonlinear/tips_and_tricks.jl\"","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/#Tips-and-tricks","page":"Tips and tricks","title":"Tips and tricks","text":"","category":"section"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This example collates some tips and tricks you can use when formulating nonlinear programs. It uses the following packages:","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"using JuMP\nimport Ipopt\nimport Test","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/#User-defined-functions-with-vector-outputs","page":"Tips and tricks","title":"User-defined functions with vector outputs","text":"","category":"section"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A common situation is to have a user-defined function like the following that returns multiple outputs (we define function_calls to keep track of how many times we call this method):","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"function_calls = 0\nfunction foo(x, y)\n    global function_calls += 1\n    common_term = x^2 + y^2\n    term_1 = sqrt(1 + common_term)\n    term_2 = common_term\n    return term_1, term_2\nend","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"For example, the first term might be used in the objective, and the second term might be used in a constraint, and often they share work that is expensive to evaluate.","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This is a problem for JuMP, because it requires user-defined functions to return a single number. One option is to define two separate functions, the first returning the first argument, and the second returning the second argument.","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"foo_1(x, y) = foo(x, y)[1]\nfoo_2(x, y) = foo(x, y)[2]","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"However, if the common term is expensive to compute, this approach is wasteful because it will evaluate the expensive term twice. Let's have a look at how many times we evaluate x^2 + y^2 during a solve:","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, x[1:2] >= 0, start = 0.1)\nregister(model, :foo_1, 2, foo_1; autodiff = true)\nregister(model, :foo_2, 2, foo_2; autodiff = true)\n@NLobjective(model, Max, foo_1(x[1], x[2]))\n@NLconstraint(model, foo_2(x[1], x[2]) <= 2)\nfunction_calls = 0\noptimize!(model)\nTest.@test objective_value(model) ≈ √3 atol = 1e-4\nTest.@test value.(x) ≈ [1.0, 1.0] atol = 1e-4\nprintln(\"Naive approach: function calls = $(function_calls)\")","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"An alternative approach is to use memoization, which uses a cache to store the result of function evaluations. We can write a memoization function as follows:","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"\"\"\"\n    memoize(foo::Function, n_outputs::Int)\n\nTake a function `foo` and return a vector of length `n_outputs`, where each\nelement is a function that returns the `i`'th output of `foo`.\n\nTo avoid duplication of work, cache the most-recent evaluations of `foo`.\nBecause `foo_i` is auto-differentiated with ForwardDiff, our cache needs to\nwork when `x` is a `Float64` and a `ForwardDiff.Dual`.\n\"\"\"\nfunction memoize(foo::Function, n_outputs::Int)\n    last_x, last_f = nothing, nothing\n    last_dx, last_dfdx = nothing, nothing\n    function foo_i(i, x::T...) where {T<:Real}\n        if T == Float64\n            if x != last_x\n                last_x, last_f = x, foo(x...)\n            end\n            return last_f[i]::T\n        else\n            if x != last_dx\n                last_dx, last_dfdx = x, foo(x...)\n            end\n            return last_dfdx[i]::T\n        end\n    end\n    return [(x...) -> foo_i(i, x...) for i in 1:n_outputs]\nend","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Let's see how it works. First, construct the memoized versions of foo:","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"memoized_foo = memoize(foo, 2)","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Now try evaluating the first element of memoized_foo.","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"function_calls = 0\nmemoized_foo[1](1.0, 1.0)\nprintln(\"function_calls = \", function_calls)","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"As expected, this evaluated the function once. However, if we call the function again, we hit the cache instead of needing to re-compute foo and function_calls is still 1!","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"memoized_foo[1](1.0, 1.0)\nprintln(\"function_calls = \", function_calls)","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Now let's see how this works during a real solve:","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, x[1:2] >= 0, start = 0.1)\nregister(model, :foo_1, 2, memoized_foo[1]; autodiff = true)\nregister(model, :foo_2, 2, memoized_foo[2]; autodiff = true)\n@NLobjective(model, Max, foo_1(x[1], x[2]))\n@NLconstraint(model, foo_2(x[1], x[2]) <= 2)\nfunction_calls = 0\noptimize!(model)\nTest.@test objective_value(model) ≈ √3 atol = 1e-4\nTest.@test value.(x) ≈ [1.0, 1.0] atol = 1e-4\nprintln(\"Memoized approach: function_calls = $(function_calls)\")","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Compared to the naive approach, the memoized approach requires half as many function evaluations!","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/nonlinear/rocket_control.jl\"","category":"page"},{"location":"tutorials/nonlinear/rocket_control/#Rocket-Control","page":"Rocket Control","title":"Rocket Control","text":"","category":"section"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Originally Contributed by: Iain Dunning","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"This tutorial shows how to solve a nonlinear rocketry control problem. The problem was drawn from the COPS3 benchmark.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Our goal is to maximize the final altitude of a vertically launched rocket.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We can control the thrust of the rocket, and must take account of the rocket mass, fuel consumption rate, gravity, and aerodynamic drag.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Let us consider the basic description of the model (for the full description, including parameters for the rocket, see the COPS3 PDF)","category":"page"},{"location":"tutorials/nonlinear/rocket_control/#Overview","page":"Rocket Control","title":"Overview","text":"","category":"section"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We will use a discretized model of time, with a fixed number of time steps, n.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We will make the time step size Delta t, and thus the final time t_f = n cdot Delta t, a variable in the problem. To approximate the derivatives in the problem we will use the trapezoidal rule.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/#State-and-Control","page":"Rocket Control","title":"State and Control","text":"","category":"section"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We will have three state variables:","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Velocity, v\nAltitude, h\nMass of rocket and remaining fuel, m","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"and a single control variable, thrust T.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Our goal is thus to maximize h(t_f).","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Each of these corresponds to a JuMP variable indexed by the time step.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/#Dynamics","page":"Rocket Control","title":"Dynamics","text":"","category":"section"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We have three equations that control the dynamics of the rocket:","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Rate of ascent: h^prime = v Acceleration: v^prime = fracT - D(hv)m - g(h) Rate of mass loss: m^prime = -fracTc","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"where drag D(hv) is a function of altitude and velocity, and gravity g(h) is a function of altitude.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"These forces are defined as","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"D(hv) = D_c v^2 expleft( -h_c left( frach-h(0)h(0) right) right)","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"and g(h) = g_0 left( frach(0)h right)^2","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"The three rate equations correspond to JuMP constraints, and for convenience we will represent the forces with nonlinear expressions.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"using JuMP\nimport Ipopt\nimport Plots","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Create JuMP model, using Ipopt as the solver","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"rocket = Model(Ipopt.Optimizer)\nset_silent(rocket)","category":"page"},{"location":"tutorials/nonlinear/rocket_control/#Constants","page":"Rocket Control","title":"Constants","text":"","category":"section"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Note that all parameters in the model have been normalized to be dimensionless. See the COPS3 paper for more info.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"h_0 = 1    # Initial height\nv_0 = 0    # Initial velocity\nm_0 = 1    # Initial mass\ng_0 = 1    # Gravity at the surface\n\nT_c = 3.5  # Used for thrust\nh_c = 500  # Used for drag\nv_c = 620  # Used for drag\nm_c = 0.6  # Fraction of initial mass left at end\n\nc = 0.5 * sqrt(g_0 * h_0)  # Thrust-to-fuel mass\nm_f = m_c * m_0              # Final mass\nD_c = 0.5 * v_c * m_0 / g_0  # Drag scaling\nT_max = T_c * g_0 * m_0        # Maximum thrust\n\nn = 800    # Time steps","category":"page"},{"location":"tutorials/nonlinear/rocket_control/#Decision-variables","page":"Rocket Control","title":"Decision variables","text":"","category":"section"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"@variables(rocket, begin\n    Δt ≥ 0, (start = 1 / n) # Time step\n    # State variables\n    v[1:n] ≥ 0            # Velocity\n    h[1:n] ≥ h_0          # Height\n    m_f ≤ m[1:n] ≤ m_0    # Mass\n    # Control variables\n    0 ≤ T[1:n] ≤ T_max    # Thrust\nend)","category":"page"},{"location":"tutorials/nonlinear/rocket_control/#Objective","page":"Rocket Control","title":"Objective","text":"","category":"section"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"The objective is to maximize altitude at end of time of flight.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"@objective(rocket, Max, h[n])","category":"page"},{"location":"tutorials/nonlinear/rocket_control/#Initial-conditions","page":"Rocket Control","title":"Initial conditions","text":"","category":"section"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"fix(v[1], v_0; force = true)\nfix(h[1], h_0; force = true)\nfix(m[1], m_0; force = true)\nfix(m[n], m_f; force = true)","category":"page"},{"location":"tutorials/nonlinear/rocket_control/#Forces","page":"Rocket Control","title":"Forces","text":"","category":"section"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"@NLexpressions(\n    rocket,\n    begin\n        # Drag(h,v) = Dc v^2 exp( -hc * (h - h0) / h0 )\n        drag[j = 1:n], D_c * (v[j]^2) * exp(-h_c * (h[j] - h_0) / h_0)\n        # Grav(h)   = go * (h0 / h)^2\n        grav[j = 1:n], g_0 * (h_0 / h[j])^2\n        # Time of flight\n        t_f, Δt * n\n    end\n)","category":"page"},{"location":"tutorials/nonlinear/rocket_control/#Dynamics-2","page":"Rocket Control","title":"Dynamics","text":"","category":"section"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"for j in 2:n\n    # h' = v\n    # Rectangular integration\n    # @NLconstraint(rocket, h[j] == h[j - 1] + Δt * v[j - 1])\n    # Trapezoidal integration\n    @NLconstraint(rocket, h[j] == h[j-1] + 0.5 * Δt * (v[j] + v[j-1]))\n    # v' = (T-D(h,v))/m - g(h)\n    # Rectangular integration\n    # @NLconstraint(\n    #     rocket,\n    #     v[j] == v[j - 1] + Δt *((T[j - 1] - drag[j - 1]) / m[j - 1] - grav[j - 1])\n    # )\n    # Trapezoidal integration\n    @NLconstraint(\n        rocket,\n        v[j] ==\n        v[j-1] +\n        0.5 *\n        Δt *\n        (\n            (T[j] - drag[j] - m[j] * grav[j]) / m[j] +\n            (T[j-1] - drag[j-1] - m[j-1] * grav[j-1]) / m[j-1]\n        )\n    )\n    # m' = -T/c\n    # Rectangular integration\n    # @NLconstraint(rocket, m[j] == m[j - 1] - Δt * T[j - 1] / c)\n    # Trapezoidal integration\n    @NLconstraint(rocket, m[j] == m[j-1] - 0.5 * Δt * (T[j] + T[j-1]) / c)\nend","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Solve for the control and state","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"println(\"Solving...\")\noptimize!(rocket)\nsolution_summary(rocket)","category":"page"},{"location":"tutorials/nonlinear/rocket_control/#Display-results","page":"Rocket Control","title":"Display results","text":"","category":"section"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"println(\"Max height: \", objective_value(rocket))","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"function my_plot(y, ylabel)\n    return Plots.plot(\n        (1:n) * value.(Δt),\n        value.(y)[:];\n        xlabel = \"Time (s)\",\n        ylabel = ylabel,\n    )\nend\n\nPlots.plot(\n    my_plot(h, \"Altitude\"),\n    my_plot(m, \"Mass\"),\n    my_plot(v, \"Velocity\"),\n    my_plot(T, \"Thrust\");\n    layout = (2, 2),\n    legend = false,\n    margin = 1Plots.cm,\n)","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"DocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"manual/containers/#Containers","page":"Containers","title":"Containers","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"JuMP provides specialized containers similar to AxisArrays that enable multi-dimensional arrays with non-integer indices.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"These containers are created automatically by JuMP's macros. Each macro has the same basic syntax:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"@macroname(model, name[key1=index1, index2; optional_condition], other stuff)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"The containers are generated by the name[key1=index1, index2; optional_condition] syntax. Everything else is specific to the particular macro.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Containers can be named, for example, name[key=index], or unnamed, for example, [key=index]. We call unnamed containers anonymous.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"We call the bits inside the square brackets and before the ; the index sets. The index sets can be named, for example, [i = 1:4], or they can be unnamed, for example, [1:4].","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"We call the bit inside the square brackets and after the ; the condition. Conditions are optional.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"In addition to the standard JuMP macros like @variable and @constraint, which construct containers of variables and constraints respectively, you can use Containers.@container to construct containers with arbitrary elements.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"We will use this macro to explain the three types of containers that are natively supported by JuMP: Array, Containers.DenseAxisArray, and Containers.SparseAxisArray.","category":"page"},{"location":"manual/containers/#Array","page":"Containers","title":"Array","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"An Array is created when the index sets are rectangular and the index sets are of the form 1:n.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container(x[i = 1:2, j = 1:3], (i, j))\n2×3 Matrix{Tuple{Int64, Int64}}:\n (1, 1)  (1, 2)  (1, 3)\n (2, 1)  (2, 2)  (2, 3)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"The result is a normal Julia Array, so you can do all the usual things.","category":"page"},{"location":"manual/containers/#Slicing","page":"Containers","title":"Slicing","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Arrays can be sliced","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x[:, 1]\n2-element Vector{Tuple{Int64, Int64}}:\n (1, 1)\n (2, 1)\n\njulia> x[2, :]\n3-element Vector{Tuple{Int64, Int64}}:\n (2, 1)\n (2, 2)\n (2, 3)","category":"page"},{"location":"manual/containers/#Looping","page":"Containers","title":"Looping","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use eachindex to loop over the elements:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> for key in eachindex(x)\n           println(x[key])\n       end\n(1, 1)\n(2, 1)\n(1, 2)\n(2, 2)\n(1, 3)\n(2, 3)","category":"page"},{"location":"manual/containers/#Get-the-index-sets","page":"Containers","title":"Get the index sets","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use axes to obtain the index sets:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> axes(x)\n(Base.OneTo(2), Base.OneTo(3))","category":"page"},{"location":"manual/containers/#Broadcasting","page":"Containers","title":"Broadcasting","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Broadcasting over an Array returns an Array","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> swap(x::Tuple) = (last(x), first(x))\nswap (generic function with 1 method)\n\njulia> swap.(x)\n2×3 Matrix{Tuple{Int64, Int64}}:\n (1, 1)  (2, 1)  (3, 1)\n (1, 2)  (2, 2)  (3, 2)","category":"page"},{"location":"manual/containers/#DenseAxisArray","page":"Containers","title":"DenseAxisArray","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"A Containers.DenseAxisArray is created when the index sets are rectangular, but not of the form 1:n. The index sets can be of any type.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x = Containers.@container([i = 1:2, j = [:A, :B]], (i, j))\n2-dimensional DenseAxisArray{Tuple{Int64, Symbol},2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, [:A, :B]\nAnd data, a 2×2 Matrix{Tuple{Int64, Symbol}}:\n (1, :A)  (1, :B)\n (2, :A)  (2, :B)","category":"page"},{"location":"manual/containers/#Slicing-2","page":"Containers","title":"Slicing","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"DenseAxisArrays can be sliced","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x[:, :A]\n1-dimensional DenseAxisArray{Tuple{Int64, Symbol},1,...} with index sets:\n    Dimension 1, Base.OneTo(2)\nAnd data, a 2-element Vector{Tuple{Int64, Symbol}}:\n (1, :A)\n (2, :A)\n\njulia> x[1, :]\n1-dimensional DenseAxisArray{Tuple{Int64, Symbol},1,...} with index sets:\n    Dimension 1, [:A, :B]\nAnd data, a 2-element Vector{Tuple{Int64, Symbol}}:\n (1, :A)\n (1, :B)","category":"page"},{"location":"manual/containers/#Looping-2","page":"Containers","title":"Looping","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use eachindex to loop over the elements:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> for key in eachindex(x)\n           println(x[key])\n       end\n(1, :A)\n(2, :A)\n(1, :B)\n(2, :B)","category":"page"},{"location":"manual/containers/#Get-the-index-sets-2","page":"Containers","title":"Get the index sets","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use axes to obtain the index sets:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> axes(x)\n(Base.OneTo(2), [:A, :B])","category":"page"},{"location":"manual/containers/#Broadcasting-2","page":"Containers","title":"Broadcasting","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Broadcasting over a DenseAxisArray returns a DenseAxisArray","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> swap(x::Tuple) = (last(x), first(x))\nswap (generic function with 1 method)\n\njulia> swap.(x)\n2-dimensional DenseAxisArray{Tuple{Symbol, Int64},2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, [:A, :B]\nAnd data, a 2×2 Matrix{Tuple{Symbol, Int64}}:\n (:A, 1)  (:B, 1)\n (:A, 2)  (:B, 2)","category":"page"},{"location":"manual/containers/#Access-internal-data","page":"Containers","title":"Access internal data","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use Array(x) to copy the internal data array into a new Array:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Array(x)\n2×2 Matrix{Tuple{Int64, Symbol}}:\n (1, :A)  (1, :B)\n (2, :A)  (2, :B)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"To access the internal data without a copy, use x.data.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x.data\n2×2 Matrix{Tuple{Int64, Symbol}}:\n (1, :A)  (1, :B)\n (2, :A)  (2, :B)","category":"page"},{"location":"manual/containers/#SparseAxisArray","page":"Containers","title":"SparseAxisArray","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"A Containers.SparseAxisArray is created when the index sets are non-rectangular. This occurs in two circumstances:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"An index depends on a prior index:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i = 1:2, j = i:2], (i, j))\nJuMP.Containers.SparseAxisArray{Tuple{Int64, Int64}, 2, Tuple{Int64, Int64}} with 3 entries:\n  [1, 1]  =  (1, 1)\n  [1, 2]  =  (1, 2)\n  [2, 2]  =  (2, 2)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"The [indices; condition] syntax is used:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x = Containers.@container([i = 1:3, j = [:A, :B]; i > 1 && j == :B], (i, j))\nJuMP.Containers.SparseAxisArray{Tuple{Int64, Symbol}, 2, Tuple{Int64, Symbol}} with 2 entries:\n  [2, B]  =  (2, :B)\n  [3, B]  =  (3, :B)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Here we have the index sets i = 1:3, j = [:A, :B], followed by ;, and then a condition, which evaluates to true or false: i > 1 && j == :B.","category":"page"},{"location":"manual/containers/#Slicing-3","page":"Containers","title":"Slicing","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"# TODO: This is included so we know to update the documentation when this is fixed.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Slicing is not supported.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x[:, :B]\nERROR: ArgumentError: Indexing with `:` is not supported by Containers.SparseAxisArray\n[...]","category":"page"},{"location":"manual/containers/#Looping-3","page":"Containers","title":"Looping","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use eachindex to loop over the elements:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> for key in eachindex(x)\n           println(x[key])\n       end\n(2, :B)\n(3, :B)","category":"page"},{"location":"manual/containers/#Broadcasting-3","page":"Containers","title":"Broadcasting","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Broadcasting over a SparseAxisArray returns a SparseAxisArray","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> swap(x::Tuple) = (last(x), first(x))\nswap (generic function with 1 method)\n\njulia> swap.(x)\nJuMP.Containers.SparseAxisArray{Tuple{Symbol, Int64}, 2, Tuple{Int64, Symbol}} with 2 entries:\n  [2, B]  =  (:B, 2)\n  [3, B]  =  (:B, 3)","category":"page"},{"location":"manual/containers/#Forcing-the-container-type","page":"Containers","title":"Forcing the container type","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Pass container = T to use T as the container. For example:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i = 1:2, j = 1:2], i + j, container = Array)\n2×2 Matrix{Int64}:\n 2  3\n 3  4\n\njulia> Containers.@container([i = 1:2, j = 1:2], i + j, container = Dict)\nDict{Tuple{Int64, Int64}, Int64} with 4 entries:\n  (1, 2) => 3\n  (1, 1) => 2\n  (2, 2) => 4\n  (2, 1) => 3","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"You can also pass DenseAxisArray or SparseAxisArray.","category":"page"},{"location":"manual/containers/#How-different-container-types-are-chosen","page":"Containers","title":"How different container types are chosen","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"If the compiler can prove at compile time that the index sets are rectangular, and indexed by a compact set of integers that start at 1, Containers.@container will return an array. This is the case if your index sets are visible to the macro as 1:n:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i=1:3, j=1:5], i + j)\n3×5 Matrix{Int64}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"or an instance of Base.OneTo:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> set = Base.OneTo(3)\nBase.OneTo(3)\n\njulia> Containers.@container([i=set, j=1:5], i + j)\n3×5 Matrix{Int64}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"If the compiler can prove that the index set is rectangular, but not necessarily of the form 1:n at compile time, then a Containers.DenseAxisArray will be constructed instead:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> set = 1:3\n1:3\n\njulia> Containers.@container([i=set, j=1:5], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, Base.OneTo(5)\nAnd data, a 3×5 Matrix{Int64}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"info: Info\nWhat happened here? Although we know that set contains 1:3, at compile time the typeof(set) is a UnitRange{Int}. Therefore, Julia can't prove that the range starts at 1 (it only finds this out at runtime), and it defaults to a  DenseAxisArray. The case where we explicitly wrote i = 1:3 worked because the macro can \"see\" the 1 at compile time.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"However, if you know that the indices do form an Array, you can force the container type with container = Array:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> set = 1:3\n1:3\n\njulia> Containers.@container([i=set, j=1:5], i + j, container = Array)\n3×5 Matrix{Int64}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Here's another example with something similar:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> a = 1\n1\n\njulia> Containers.@container([i=a:3, j=1:5], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, Base.OneTo(5)\nAnd data, a 3×5 Matrix{Int64}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8\n\njulia> Containers.@container([i=1:a, j=1:5], i + j)\n1×5 Matrix{Int64}:\n 2  3  4  5  6","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Finally, if the compiler cannot prove that the index set is rectangular, a Containers.SparseAxisArray will be created.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"This occurs when some indices depend on a previous one:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i=1:3, j=1:i], i + j)\nJuMP.Containers.SparseAxisArray{Int64, 2, Tuple{Int64, Int64}} with 6 entries:\n  [1, 1]  =  2\n  [2, 1]  =  3\n  [2, 2]  =  4\n  [3, 1]  =  4\n  [3, 2]  =  5\n  [3, 3]  =  6","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"or if there is a condition on the index sets:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i = 1:5; isodd(i)], i^2)\nJuMP.Containers.SparseAxisArray{Int64, 1, Tuple{Int64}} with 3 entries:\n  [1]  =  1\n  [3]  =  9\n  [5]  =  25","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"The condition can depend on multiple indices, the only requirement is that it is an expression that returns true or false:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> condition(i, j) = isodd(i) && iseven(j)\ncondition (generic function with 1 method)\n\njulia> Containers.@container([i = 1:2, j = 1:4; condition(i, j)], i + j)\nJuMP.Containers.SparseAxisArray{Int64, 2, Tuple{Int64, Int64}} with 2 entries:\n  [1, 2]  =  3\n  [1, 4]  =  5","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP, GLPK\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/solutions/#jump_solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"This section of the manual describes how to access a solved solution to a problem. It uses the following model as an example:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"model = Model(GLPK.Optimizer)\n@variable(model, x >= 0)\n@variable(model, y[[:a, :b]] <= 1)\n@objective(model, Max, -12x - 20y[:a])\n@expression(model, my_expr, 6x + 8y[:a])\n@constraint(model, my_expr >= 100)\n@constraint(model, c1, 7x + 12y[:a] >= 120)\noptimize!(model)\nprint(model)\n\n# output\n\nMax -12 x - 20 y[a]\nSubject to\n 6 x + 8 y[a] ≥ 100.0\n c1 : 7 x + 12 y[a] ≥ 120.0\n x ≥ 0.0\n y[a] ≤ 1.0\n y[b] ≤ 1.0","category":"page"},{"location":"manual/solutions/#Solutions-summary","page":"Solutions","title":"Solutions summary","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"solution_summary can be used for checking the summary of the optimization solutions.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> solution_summary(model)\n* Solver : GLPK\n\n* Status\n  Termination status : OPTIMAL\n  Primal status      : FEASIBLE_POINT\n  Dual status        : FEASIBLE_POINT\n  Message from the solver:\n  \"Solution is optimal\"\n\n* Candidate solution\n  Objective value      : -205.14285714285714\n  Objective bound      : Inf\n  Dual objective value : -205.1428571428571\n\n* Work counters\n  Solve time (sec)   : 0.00008\n\njulia> solution_summary(model, verbose=true)\n* Solver : GLPK\n\n* Status\n  Termination status : OPTIMAL\n  Primal status      : FEASIBLE_POINT\n  Dual status        : FEASIBLE_POINT\n  Result count       : 1\n  Has duals          : true\n  Message from the solver:\n  \"Solution is optimal\"\n\n* Candidate solution\n  Objective value      : -205.14285714285714\n  Objective bound      : Inf\n  Dual objective value : -205.1428571428571\n  Primal solution :\n    x : 15.428571428571429\n    y[a] : 1.0\n    y[b] : 1.0\n  Dual solution :\n    c1 : 1.7142857142857142\n\n* Work counters\n  Solve time (sec)   : 0.00008","category":"page"},{"location":"manual/solutions/#Why-did-the-solver-stop?","page":"Solutions","title":"Why did the solver stop?","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Usetermination_status to understand why the solver stopped.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> termination_status(model)\nOPTIMAL::TerminationStatusCode = 1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The MOI.TerminationStatusCode enum describes the full list of statuses that could be returned.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Common return values include OPTIMAL, LOCALLY_SOLVED, INFEASIBLE, DUAL_INFEASIBLE, and TIME_LIMIT.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"info: Info\nA return status of OPTIMAL means the solver found (and proved) a globally optimal solution. A return status of LOCALLY_SOLVED means the solver found a locally optimal solution (which may also be globally optimal, but it could not prove so).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nA return status of DUAL_INFEASIBLE does not guarantee that the primal is unbounded. When the dual is infeasible, the primal is unbounded if there exists a feasible primal solution.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Use raw_status to get a solver-specific string explaining why the optimization stopped:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> raw_status(model)\n\"Solution is optimal\"","category":"page"},{"location":"manual/solutions/#Primal-solutions","page":"Solutions","title":"Primal solutions","text":"","category":"section"},{"location":"manual/solutions/#Primal-solution-status","page":"Solutions","title":"Primal solution status","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Use primal_status to return an MOI.ResultStatusCode enum describing the status of the primal solution.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> primal_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Other common returns are NO_SOLUTION, and INFEASIBILITY_CERTIFICATE. The first means that the solver doesn't have a solution to return, and the second means that the primal solution is a certificate of dual infeasibility (a primal unbounded ray).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"You can also use has_values, which returns true if there is a solution that can be queried, and false otherwise.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> has_values(model)\ntrue","category":"page"},{"location":"manual/solutions/#Objective-values","page":"Solutions","title":"Objective values","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The objective value of a solved problem can be obtained via objective_value. The best known bound on the optimal objective value can be obtained via objective_bound. If the solver supports it, the value of the dual objective can be obtained via dual_objective_value.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> objective_value(model)\n-205.14285714285714\n\njulia> objective_bound(model)  # GLPK only implements objective bound for MIPs\nInf\n\njulia> dual_objective_value(model)\n-205.1428571428571","category":"page"},{"location":"manual/solutions/#Primal-solution-values","page":"Solutions","title":"Primal solution values","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If the solver has a primal solution to return, use value to access it:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> value(x)\n15.428571428571429","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Broadcast value over containers:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> value.(y)\n1-dimensional DenseAxisArray{Float64,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{Float64,1}:\n 1.0\n 1.0","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"value also works on expressions:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> value(my_expr)\n100.57142857142857","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"and constraints:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> value(c1)\n120.0","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"info: Info\nCalling value on a constraint returns the constraint function evaluated at the solution.","category":"page"},{"location":"manual/solutions/#Dual-solutions","page":"Solutions","title":"Dual solutions","text":"","category":"section"},{"location":"manual/solutions/#Dual-solution-status","page":"Solutions","title":"Dual solution status","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Use dual_status to return an MOI.ResultStatusCode enum describing the status of the dual solution.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> dual_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Other common returns are NO_SOLUTION, and INFEASIBILITY_CERTIFICATE. The first means that the solver doesn't have a solution to return, and the second means that the dual solution is a certificate of primal infeasibility (a dual unbounded ray).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"You can also use has_duals, which returns true if there is a solution that can be queried, and false otherwise.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> has_duals(model)\ntrue","category":"page"},{"location":"manual/solutions/#Dual-solution-values","page":"Solutions","title":"Dual solution values","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If the solver has a dual solution to return, use dual to access it:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> dual(c1)\n1.7142857142857142","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Query the duals of variable bounds using LowerBoundRef, UpperBoundRef, and FixRef:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> dual(LowerBoundRef(x))\n0.0\n\njulia> dual.(UpperBoundRef.(y))\n1-dimensional DenseAxisArray{Float64,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{Float64,1}:\n -0.5714285714285694\n  0.0","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nJuMP's definition of duality is independent of the objective sense. That is, the sign of feasible duals associated with a constraint depends on the direction of the constraint and not whether the problem is maximization or minimization. This is a different convention from linear programming duality in some common textbooks. If you have a linear program, and you want the textbook definition, you probably want to use shadow_price and reduced_cost instead.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> shadow_price(c1)\n1.7142857142857142\n\njulia> reduced_cost(x)\n0.0\n\njulia> reduced_cost.(y)\n1-dimensional DenseAxisArray{Float64,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{Float64,1}:\n  0.5714285714285694\n -0.0","category":"page"},{"location":"manual/solutions/#Recommended-workflow","page":"Solutions","title":"Recommended workflow","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The recommended workflow for solving a model and querying the solution is something like the following:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"if termination_status(model) == OPTIMAL\n    println(\"Solution is optimal\")\nelseif termination_status(model) == TIME_LIMIT && has_values(model)\n    println(\"Solution is suboptimal due to a time limit, but a primal solution is available\")\nelse\n    error(\"The model was not solved correctly.\")\nend\nprintln(\"  objective value = \", objective_value(model))\nif primal_status(model) == FEASIBLE_POINT\n    println(\"  primal solution: x = \", value(x))\nend\nif dual_status(model) == FEASIBLE_POINT\n    println(\"  dual solution: c1 = \", dual(c1))\nend\n\n# output\n\nSolution is optimal\n  objective value = -205.14285714285714\n  primal solution: x = 15.428571428571429\n  dual solution: c1 = 1.7142857142857142","category":"page"},{"location":"manual/solutions/#OptimizeNotCalled-errors","page":"Solutions","title":"OptimizeNotCalled errors","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Modifying a model after calling optimize! will reset the model into the MOI.OPTIMIZE_NOT_CALLED state. If you attempt to query solution information, an OptimizeNotCalled error will be thrown.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If you are iteratively querying solution information and modifying a model, query all the results first, then modify the problem.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"For example, instead of:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"model = Model(GLPK.Optimizer)\n@variable(model, x >= 0)\noptimize!(model)\nset_lower_bound(x, 1)  # This will modify the model\nx_val = value(x)       # This will fail because the model has been modified\nset_start_value(x, x_val)","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"do","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"model = Model(GLPK.Optimizer)\n@variable(model, x >= 0)\noptimize!(model)\nx_val = value(x)\nset_lower_bound(x, 1)\nset_start_value(x, x_val)","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"# TODO: How to accurately measure the solve time.","category":"page"},{"location":"manual/solutions/#Accessing-attributes","page":"Solutions","title":"Accessing attributes","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"MathOptInterface defines many model attributes that can be queried. Some attributes can be directly accessed by getter functions. These include:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"solve_time\nrelative_gap\nsimplex_iterations\nbarrier_iterations\nnode_count","category":"page"},{"location":"manual/solutions/#Sensitivity-analysis-for-LP","page":"Solutions","title":"Sensitivity analysis for LP","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Given an LP problem and an optimal solution corresponding to a basis, we can question how much an objective coefficient or standard form right-hand side coefficient (c.f., normalized_rhs) can change without violating primal or dual feasibility of the basic solution.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Note that not all solvers compute the basis, and for sensitivity analysis, the solver interface must implement MOI.ConstraintBasisStatus.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To give a simple example, we could analyze the sensitivity of the optimal solution to the following (non-degenerate) LP problem:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"model = Model(GLPK.Optimizer)\n@variable(model, x[1:2])\nset_lower_bound(x[2], -0.5)\nset_upper_bound(x[2], 0.5)\n@constraint(model, c1, x[1] + x[2] <= 1)\n@constraint(model, c2, x[1] - x[2] <= 1)\n@objective(model, Max, x[1])\nprint(model)\n\n# output\n\nMax x[1]\nSubject to\n c1 : x[1] + x[2] ≤ 1.0\n c2 : x[1] - x[2] ≤ 1.0\n x[2] ≥ -0.5\n x[2] ≤ 0.5","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To analyze the sensitivity of the problem we could check the allowed perturbation ranges of, for example, the cost coefficients and the right-hand side coefficient of the constraint c1 as follows:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> optimize!(model)\n\njulia> value.(x)\n2-element Vector{Float64}:\n 1.0\n 0.0\n\njulia> report = lp_sensitivity_report(model);\n\njulia> x1_lo, x1_hi = report[x[1]]\n(-1.0, Inf)\n\njulia> println(\"The objective coefficient of x[1] could decrease by $(x1_lo) or increase by $(x1_hi).\")\nThe objective coefficient of x[1] could decrease by -1.0 or increase by Inf.\n\njulia> x2_lo, x2_hi = report[x[2]]\n(-1.0, 1.0)\n\njulia> println(\"The objective coefficient of x[2] could decrease by $(x2_lo) or increase by $(x2_hi).\")\nThe objective coefficient of x[2] could decrease by -1.0 or increase by 1.0.\n\njulia> c_lo, c_hi = report[c1]\n(-1.0, 1.0)\n\njulia> println(\"The RHS of c1 could decrease by $(c_lo) or increase by $(c_hi).\")\nThe RHS of c1 could decrease by -1.0 or increase by 1.0.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The range associated with a variable is the range of the allowed perturbation of the corresponding objective coefficient. Note that the current primal solution remains optimal within this range; however the corresponding dual solution might change since a cost coefficient is perturbed. Similarly, the range associated with a constraint is the range of the allowed perturbation of the corresponding right-hand side coefficient. In this range the current dual solution remains optimal, but the optimal primal solution might change.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If the problem is degenerate, there are multiple optimal bases and hence these ranges might not be as intuitive and seem too narrow, for example, a larger cost coefficient perturbation might not invalidate the optimality of the current primal solution. Moreover, if a problem is degenerate, due to finite precision, it can happen that, for example, a perturbation seems to invalidate a basis even though it doesn't (again providing too narrow ranges). To prevent this, increase the atol keyword argument to lp_sensitivity_report. Note that this might make the ranges too wide for numerically challenging instances. Thus, do not blindly trust these ranges, especially not for highly degenerate or numerically unstable instances.","category":"page"},{"location":"manual/solutions/#Conflicts","page":"Solutions","title":"Conflicts","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"When the model you input is infeasible, some solvers can help you find the cause of this infeasibility by offering a conflict, that is, a subset of the constraints that create this infeasibility. Depending on the solver, this can also be called an IIS (irreducible inconsistent subsystem).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The function compute_conflict! is used to trigger the computation of a conflict. Once this process is finished, the attribute MOI.ConflictStatus returns a MOI.ConflictStatusCode.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If there is a conflict, you can query from each constraint whether it participates in the conflict or not using the attribute MOI.ConstraintConflictStatus, which returns a MOI.ConflictParticipationStatusCode.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To create a new model containing only the constraints that participate in the conflict, use copy_conflict. It may be helpful to write this model to a file for easier debugging using write_to_file.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"For instance, this is how you can use this functionality:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"using JuMP\nmodel = Model() # You must use a solver that supports conflict refining/IIS\n# computation, like CPLEX or Gurobi\n# for example, using Gurobi; model = Model(Gurobi.Optimizer)\n@variable(model, x >= 0)\n@constraint(model, c1, x >= 2)\n@constraint(model, c2, x <= 1)\noptimize!(model)\n\n# termination_status(model) will likely be INFEASIBLE,\n# depending on the solver\n\ncompute_conflict!(model)\nif MOI.get(model, MOI.ConflictStatus()) != MOI.CONFLICT_FOUND\n    error(\"No conflict could be found for an infeasible model.\")\nend\n\n# Both constraints participate in the conflict.\nMOI.get(model, MOI.ConstraintConflictStatus(), c1)\nMOI.get(model, MOI.ConstraintConflictStatus(), c2)\n\n# Get a copy of the model with only the constraints in the conflict.\nnew_model, reference_map = copy_conflict(model)","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Conflicting constraints can be collected in a list and printed as follows:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"conflict_constraint_list = ConstraintRef[]\nfor (F, S) in list_of_constraint_types(model)\n    for con in all_constraints(model, F, S)\n        if MOI.get(model, MOI.ConstraintConflictStatus(), con) == MOI.IN_CONFLICT\n            push!(conflict_constraint_list, con)\n            println(con)\n        end\n    end\nend","category":"page"},{"location":"manual/solutions/#Multiple-solutions","page":"Solutions","title":"Multiple solutions","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Some solvers support returning multiple solutions. You can check how many solutions are available to query using result_count.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Functions for querying the solutions, for example, primal_status and value, all take an additional keyword argument result which can be used to specify which result to return.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nEven if termination_status is OPTIMAL, some of the returned solutions may be suboptimal! However, if the solver found at least one optimal solution, then result = 1 will always return an optimal solution. Use objective_value to assess the quality of the remaining solutions.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"using JuMP\nmodel = Model()\n@variable(model, x[1:10] >= 0)\n# ... other constraints ...\noptimize!(model)\n\nif termination_status(model) != OPTIMAL\n    error(\"The model was not solved correctly.\")\nend\n\nan_optimal_solution = value.(x; result = 1)\noptimal_objective = objective_value(model; result = 1)\nfor i in 2:result_count(model)\n    @assert has_values(model; result = i)\n    println(\"Solution $(i) = \", value.(x; result = i))\n    obj = objective_value(model; result = i)\n    println(\"Objective $(i) = \", obj)\n    if isapprox(obj, optimal_objective; atol = 1e-8)\n        print(\"Solution $(i) is also optimal!\")\n    end\nend","category":"page"},{"location":"manual/solutions/#Checking-feasibility-of-solutions","page":"Solutions","title":"Checking feasibility of solutions","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To check the feasibility of a primal solution, use primal_feasibility_report, which takes a model, a dictionary mapping each variable to a primal solution value (defaults to the last solved solution), and a tolerance atol (defaults to 0.0).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The function returns a dictionary which maps the infeasible constraint references to the distance between the primal value of the constraint and the nearest point in the corresponding set. A point is classed as infeasible if the distance is greater than the supplied tolerance atol.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"# Add a filter here because the output of the dictionary is not ordered, and\n# changes in printing order will cause the doctest to fail.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> model = Model(GLPK.Optimizer);\n\njulia> @variable(model, x >= 1, Int);\n\njulia> @variable(model, y);\n\njulia> @constraint(model, c1, x + y <= 1.95);\n\njulia> point = Dict(x => 1.9, y => 0.06);\n\njulia> primal_feasibility_report(model, point)\nDict{Any, Float64} with 2 entries:\n  x integer         => 0.1\n  c1 : x + y ≤ 1.95 => 0.01\n\njulia> primal_feasibility_report(model, point; atol = 0.02)\nDict{Any, Float64} with 1 entry:\n  x integer => 0.1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If the point is feasible, an empty dictionary is returned:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> primal_feasibility_report(model, Dict(x => 1.0, y => 0.0))\nDict{Any, Float64}()","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To use the primal solution from a solve, omit the point argument:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> optimize!(model)\n\njulia> primal_feasibility_report(model)\nDict{Any, Float64}()","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Pass skip_mising = true to skip constraints which contain variables that are not in point:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> primal_feasibility_report(model, Dict(x => 2.1); skip_missing = true)\nDict{Any, Float64} with 1 entry:\n  x integer => 0.1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"You can also use the functional form, where the first argument is a function that maps variables to their primal values:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> optimize!(model)\n\njulia> primal_feasibility_report(v -> value(v), model)\nDict{Any, Float64}()","category":"page"},{"location":"reference/expressions/#ExpressionAPI","page":"Expressions","title":"Expressions","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"More information can be found in the Expressions section of the manual.","category":"page"},{"location":"reference/expressions/#Macros","page":"Expressions","title":"Macros","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"@expression\n@expressions","category":"page"},{"location":"reference/expressions/#JuMP.@expression","page":"Expressions","title":"JuMP.@expression","text":"@expression(args...)\n\nEfficiently builds a linear or quadratic expression but does not add to model immediately. Instead, returns the expression which can then be inserted in other constraints. For example:\n\n@expression(m, shared, sum(i*x[i] for i=1:5))\n@constraint(m, shared + y >= 5)\n@constraint(m, shared + z <= 10)\n\nThe ref accepts index sets in the same way as @variable, and those indices can be used in the construction of the expressions:\n\n@expression(m, expr[i=1:3], i*sum(x[j] for j=1:3))\n\nAnonymous syntax is also supported:\n\nexpr = @expression(m, [i=1:3], i*sum(x[j] for j=1:3))\n\n\n\n\n\n","category":"macro"},{"location":"reference/expressions/#JuMP.@expressions","page":"Expressions","title":"JuMP.@expressions","text":"@expressions(model, args...)\n\nAdds multiple expressions to model at once, in the same fashion as the @expression macro.\n\nThe model must be the first argument, and multiple expressions can be added on multiple lines wrapped in a begin ... end block.\n\nThe macro returns a tuple containing the expressions that were defined.\n\nExamples\n\n@expressions(model, begin\n    my_expr, x^2 + y^2\n    my_expr_1[i = 1:2], a[i] - z[i]\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/expressions/#Affine-expressions","page":"Expressions","title":"Affine expressions","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"GenericAffExpr\nAffExpr\nlinear_terms","category":"page"},{"location":"reference/expressions/#JuMP.GenericAffExpr","page":"Expressions","title":"JuMP.GenericAffExpr","text":"mutable struct GenericAffExpr{CoefType,VarType} <: AbstractJuMPScalar\n    constant::CoefType\n    terms::OrderedDict{VarType,CoefType}\nend\n\nAn expression type representing an affine expression of the form: sum a_i x_i + c.\n\nFields\n\n.constant: the constant c in the expression.\n.terms: an OrderedDict, with keys of VarType and values of CoefType describing the sparse vector a.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.AffExpr","page":"Expressions","title":"JuMP.AffExpr","text":"AffExpr\n\nAlias for GenericAffExpr{Float64,VariableRef}, the specific GenericAffExpr used by JuMP.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.linear_terms","page":"Expressions","title":"JuMP.linear_terms","text":"linear_terms(aff::GenericAffExpr{C, V})\n\nProvides an iterator over coefficient-variable tuples (a_i::C, x_i::V) in the linear part of the affine expression.\n\n\n\n\n\nlinear_terms(quad::GenericQuadExpr{C, V})\n\nProvides an iterator over tuples (coefficient::C, variable::V) in the linear part of the quadratic expression.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#Quadratic-expressions","page":"Expressions","title":"Quadratic expressions","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"GenericQuadExpr\nQuadExpr\nUnorderedPair\nquad_terms","category":"page"},{"location":"reference/expressions/#JuMP.GenericQuadExpr","page":"Expressions","title":"JuMP.GenericQuadExpr","text":"mutable struct GenericQuadExpr{CoefType,VarType} <: AbstractJuMPScalar\n    aff::GenericAffExpr{CoefType,VarType}\n    terms::OrderedDict{UnorderedPair{VarType}, CoefType}\nend\n\nAn expression type representing an quadratic expression of the form: sum q_ij x_i x_j + sum a_i x_i + c.\n\nFields\n\n.aff: an GenericAffExpr representing the affine portion of the expression.\n.terms: an OrderedDict, with keys of UnorderedPair{VarType} and values of CoefType, describing the sparse list of terms q.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.QuadExpr","page":"Expressions","title":"JuMP.QuadExpr","text":"QuadExpr\n\nAn alias for GenericQuadExpr{Float64,VariableRef}, the specific     GenericQuadExpr used by JuMP.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.UnorderedPair","page":"Expressions","title":"JuMP.UnorderedPair","text":"UnorderedPair(a::T, b::T)\n\nA wrapper type used by GenericQuadExpr with fields .a and .b.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.quad_terms","page":"Expressions","title":"JuMP.quad_terms","text":"quad_terms(quad::GenericQuadExpr{C, V})\n\nProvides an iterator over tuples (coefficient::C, var_1::V, var_2::V) in the quadratic part of the quadratic expression.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#Utilities-and-modifications","page":"Expressions","title":"Utilities and modifications","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"constant\ncoefficient\nisequal_canonical\nadd_to_expression!\ndrop_zeros!\nmap_coefficients\nmap_coefficients_inplace!","category":"page"},{"location":"reference/expressions/#JuMP.constant","page":"Expressions","title":"JuMP.constant","text":"constant(aff::GenericAffExpr{C, V})::C\n\nReturn the constant of the affine expression.\n\n\n\n\n\nconstant(aff::GenericQuadExpr{C, V})::C\n\nReturn the constant of the quadratic expression.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.coefficient","page":"Expressions","title":"JuMP.coefficient","text":"coefficient(v1::VariableRef, v2::VariableRef)\n\nReturn 1.0 if v1 == v2, and 0.0 otherwise.\n\nThis is a fallback for other coefficient methods to simplify code in which the expression may be a single variable.\n\n\n\n\n\ncoefficient(a::GenericAffExpr{C,V}, v::V) where {C,V}\n\nReturn the coefficient associated with variable v in the affine expression a.\n\n\n\n\n\ncoefficient(a::GenericAffExpr{C,V}, v1::V, v2::V) where {C,V}\n\nReturn the coefficient associated with the term v1 * v2 in the quadratic expression a.\n\nNote that coefficient(a, v1, v2) is the same as coefficient(a, v2, v1).\n\n\n\n\n\ncoefficient(a::GenericQuadExpr{C,V}, v::V) where {C,V}\n\nReturn the coefficient associated with variable v in the affine component of a.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.isequal_canonical","page":"Expressions","title":"JuMP.isequal_canonical","text":"isequal_canonical(\n    aff::GenericAffExpr{C,V},\n    other::GenericAffExpr{C,V}\n) where {C,V}\n\nReturn true if aff is equal to other after dropping zeros and disregarding the order. Mainly useful for testing.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.add_to_expression!","page":"Expressions","title":"JuMP.add_to_expression!","text":"add_to_expression!(expression, terms...)\n\nUpdates expression in place to expression + (*)(terms...). This is typically much more efficient than expression += (*)(terms...). For example, add_to_expression!(expression, a, b) produces the same result as expression += a*b, and add_to_expression!(expression, a) produces the same result as expression += a.\n\nOnly a few methods are defined, mostly for internal use, and only for the cases when (1) they can be implemented efficiently and (2) expression is capable of storing the result. For example, add_to_expression!(::AffExpr, ::VariableRef, ::VariableRef) is not defined because a GenericAffExpr cannot store the product of two variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.drop_zeros!","page":"Expressions","title":"JuMP.drop_zeros!","text":"drop_zeros!(expr::GenericAffExpr)\n\nRemove terms in the affine expression with 0 coefficients.\n\n\n\n\n\ndrop_zeros!(expr::GenericQuadExpr)\n\nRemove terms in the quadratic expression with 0 coefficients.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.map_coefficients","page":"Expressions","title":"JuMP.map_coefficients","text":"map_coefficients(f::Function, a::GenericAffExpr)\n\nApply f to the coefficients and constant term of an GenericAffExpr a and return a new expression.\n\nSee also: map_coefficients_inplace!\n\nExample\n\njulia> a = GenericAffExpr(1.0, x => 1.0)\nx + 1\n\njulia> map_coefficients(c -> 2 * c, a)\n2 x + 2\n\njulia> a\nx + 1\n\n\n\n\n\nmap_coefficients(f::Function, a::GenericQuadExpr)\n\nApply f to the coefficients and constant term of an GenericQuadExpr a and return a new expression.\n\nSee also: map_coefficients_inplace!\n\nExample\n\njulia> a = @expression(model, x^2 + x + 1)\nx² + x + 1\n\njulia> map_coefficients(c -> 2 * c, a)\n2 x² + 2 x + 2\n\njulia> a\nx² + x + 1\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.map_coefficients_inplace!","page":"Expressions","title":"JuMP.map_coefficients_inplace!","text":"map_coefficients_inplace!(f::Function, a::GenericAffExpr)\n\nApply f to the coefficients and constant term of an GenericAffExpr a and update them in-place.\n\nSee also: map_coefficients\n\nExample\n\njulia> a = GenericAffExpr(1.0, x => 1.0)\nx + 1\n\njulia> map_coefficients_inplace!(c -> 2 * c, a)\n2 x + 2\n\njulia> a\n2 x + 2\n\n\n\n\n\nmap_coefficients_inplace!(f::Function, a::GenericQuadExpr)\n\nApply f to the coefficients and constant term of an GenericQuadExpr a and update them in-place.\n\nSee also: map_coefficients\n\nExample\n\njulia> a = @expression(model, x^2 + x + 1)\nx² + x + 1\n\njulia> map_coefficients_inplace!(c -> 2 * c, a)\n2 x² + 2 x + 2\n\njulia> a\n2 x² + 2 x + 2\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP-to-MOI-converters","page":"Expressions","title":"JuMP-to-MOI converters","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"variable_ref_type\njump_function\njump_function_type\nmoi_function\nmoi_function_type","category":"page"},{"location":"reference/expressions/#JuMP.variable_ref_type","page":"Expressions","title":"JuMP.variable_ref_type","text":"variable_ref_type(::GenericAffExpr{C, V}) where {C, V}\n\nA helper function used internally by JuMP and some JuMP extensions. Returns the variable type V from a GenericAffExpr\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.jump_function","page":"Expressions","title":"JuMP.jump_function","text":"jump_function(x)\n\nGiven an MathOptInterface object x, return the JuMP equivalent.\n\nSee also: moi_function.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.jump_function_type","page":"Expressions","title":"JuMP.jump_function_type","text":"jump_function_type(::Type{T}) where {T}\n\nGiven an MathOptInterface object type T, return the JuMP equivalent.\n\nSee also: moi_function_type.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.moi_function","page":"Expressions","title":"JuMP.moi_function","text":"moi_function(x)\n\nGiven a JuMP object x, return the MathOptInterface equivalent.\n\nSee also: jump_function.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.moi_function_type","page":"Expressions","title":"JuMP.moi_function_type","text":"moi_function_type(::Type{T}) where {T}\n\nGiven a JuMP object type T, return the MathOptInterface equivalent.\n\nSee also: jump_function_type.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/getting_started/getting_started_with_JuMP.jl\"","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Getting-started-with-JuMP","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"This tutorial is aimed at providing a quick introduction to writing and solving optimization models with JuMP.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"If you're new to Julia, start by reading Getting started with Julia.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#What-is-JuMP?","page":"Getting started with JuMP","title":"What is JuMP?","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP (\"Julia for Mathematical Programming\") is an open-source modeling language that is embedded in Julia. It allows users to formulate various classes of optimization problems (linear, mixed-integer, quadratic, conic quadratic, semidefinite, and nonlinear) with easy-to-read code. These problems can then be solved using state-of-the-art open-source and commercial solvers.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP also makes advanced optimization techniques easily accessible from a high-level language.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#What-is-a-solver?","page":"Getting started with JuMP","title":"What is a solver?","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"A solver is a software package that incorporates algorithms for finding solutions to one or more classes of problem.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"For example, GLPK is a solver for linear programming (LP) and mixed integer programming (MIP) problems. It incorporates algorithms such as the simplex method and the interior-point method.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"The Supported-solvers table lists the open-source and commercial solvers that JuMP currently supports.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#What-is-MathOptInterface?","page":"Getting started with JuMP","title":"What is MathOptInterface?","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Each solver has its own concepts and data structures for representing optimization models and obtaining results.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"MathOptInterface (MOI) is an abstraction layer that JuMP uses to convert from the problem written in JuMP to the solver-specific data structures for each solver.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"MOI can be used directly, or through a higher-level modeling interface like JuMP.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Because JuMP is built on top of MOI, you'll often see the MathOptInterface. prefix displayed when JuMP types are printed. However, you'll only need to understand and interact with MOI to accomplish advanced tasks such as creating solver-independent callbacks.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Installation","page":"Getting started with JuMP","title":"Installation","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP is a package for Julia. From Julia, JuMP is installed by using the built-in package manager.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"import Pkg\nPkg.add(\"JuMP\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"You also need to include a Julia package which provides an appropriate solver. One such solver is GLPK.Optimizer, which is provided by the GLPK.jl package.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"import Pkg\nPkg.add(\"GLPK\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"See Installation Guide for a list of other solvers you can use.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#An-example","page":"Getting started with JuMP","title":"An example","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Let's to solve the following linear programming problem using JuMP and GLPK. We will first look at the complete code to solve the problem and then go through it step by step.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Here's the problem:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"beginaligned\n min  12x + 20y \n textst  6x + 8y geq 100 \n  7x + 12y geq 120 \n  x geq 0 \n  y in 0 3 \nendaligned","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"And here's the code to solve this problem:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"using JuMP\nusing GLPK\nmodel = Model(GLPK.Optimizer)\n@variable(model, x >= 0)\n@variable(model, 0 <= y <= 3)\n@objective(model, Min, 12x + 20y)\n@constraint(model, c1, 6x + 8y >= 100)\n@constraint(model, c2, 7x + 12y >= 120)\nprint(model)\noptimize!(model)\n@show termination_status(model)\n@show primal_status(model)\n@show dual_status(model)\n@show objective_value(model)\n@show value(x)\n@show value(y)\n@show shadow_price(c1)\n@show shadow_price(c2)\nnothing #hide","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Step-by-step","page":"Getting started with JuMP","title":"Step-by-step","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Once JuMP is installed, to use JuMP in your programs write:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"using JuMP","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We also need to include a Julia package which provides an appropriate solver. We want to use GLPK.Optimizer here which is provided by the GLPK.jl package.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"using GLPK","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP builds problems incrementally in a Model object. Create a model by passing an optimizer to the Model function:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = Model(GLPK.Optimizer)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Variables are modeled using @variable:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, x >= 0)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"They can have lower and upper bounds.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, 0 <= y <= 30)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"The objective is set using @objective:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@objective(model, Min, 12x + 20y)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Constraints are modeled using @constraint. Here, c1 and c2 are the names of our constraint.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@constraint(model, c1, 6x + 8y >= 100)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@constraint(model, c2, 7x + 12y >= 120)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Call print to display the model:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"print(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"To solve the optimization problem, call the optimize! function.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"optimize!(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"info: Info\nThe ! after optimize is part of the name. It's nothing special. Julia has a convention that functions which mutate their arguments should end in !. A common example is push!.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Now let's see what information we can query about the solution.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"termination_status tells us why the solver stopped:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"termination_status(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"In this case, the solver found an optimal solution.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Check primal_status to see if the solver found a primal feasible point:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"primal_status(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"and dual_status to see if the solver found a dual feasible point:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"dual_status(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Now we know that our solver found an optimal solution, and that it has a primal and a dual solution to query.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Query the objective value using objective_value:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"objective_value(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"the primal solution using value:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"value(x)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"value(y)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"and the dual solution using shadow_price:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"shadow_price(c1)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"shadow_price(c2)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"That's it for our simple model. In the rest of this tutorial, we expand on some of the basic JuMP operations.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Model-basics","page":"Getting started with JuMP","title":"Model basics","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Create a model by passing an optimizer:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = Model(GLPK.Optimizer)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Alternatively, call set_optimizer at any point before calling optimize!:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = Model()\nset_optimizer(model, GLPK.Optimizer)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"For some solvers, you can also use direct_model, which offers a more efficient connection to the underlying solver:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = direct_model(GLPK.Optimizer())","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"warning: Warning\nSome solvers do not support direct_model!","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Solver-Options","page":"Getting started with JuMP","title":"Solver Options","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Pass options to solvers with optimizer_with_attributes:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = Model(optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 0))","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"note: Note\nThese options are solver-specific. To find out the various options available, see the GitHub README of the individual solver packages. The link to each solver's GitHub page is in the Supported solvers table.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"You can also pass options with set_optimizer_attribute","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = Model(GLPK.Optimizer)\nset_optimizer_attribute(model, \"msg_lev\", 0)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Solution-basics","page":"Getting started with JuMP","title":"Solution basics","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We saw above how to use termination_status and primal_status to understand the solution returned by the solver.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"However, only query solution attributes like value and objective_value if there is an available solution. Here's a recommended way to check:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"function solve_infeasible()\n    model = Model(GLPK.Optimizer)\n    @variable(model, 0 <= x <= 1)\n    @variable(model, 0 <= y <= 1)\n    @constraint(model, x + y >= 3)\n    @objective(model, Max, x + 2y)\n    optimize!(model)\n    if termination_status(model) != OPTIMAL\n        @warn(\"The model was not solved correctly.\")\n        return nothing\n    end\n    return value(x), value(y)\nend\n\nsolve_infeasible()","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Variable-basics","page":"Getting started with JuMP","title":"Variable basics","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Let's create a new empty model to explain some of the variable syntax:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = Model()","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Variable-bounds","page":"Getting started with JuMP","title":"Variable bounds","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"All of the variables we have created till now have had a bound. We can also create a free variable.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, free_x)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"While creating a variable, instead of using the <= and >= syntax, we can also use the lower_bound and upper_bound keyword arguments.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, keyword_x, lower_bound = 1, upper_bound = 2)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We can query whether a variable has a bound using the has_lower_bound and has_upper_bound functions. The values of the bound can be obtained using the lower_bound and upper_bound functions.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"has_upper_bound(keyword_x)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"upper_bound(keyword_x)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Note querying the value of a bound that does not exist will result in an error.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"try                         #hide\n    lower_bound(free_x)\ncatch err                   #hide\n    showerror(stderr, err)  #hide\nend                         #hide","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#tutorial_variable_container","page":"Getting started with JuMP","title":"Containers","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We have already seen how to add a single variable to a model using the @variable macro. Now let's look at ways to add multiple variables to a model.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP provides data structures for adding collections of variables to a model. These data structures are referred to as containers and are of three types: Arrays, DenseAxisArrays, and SparseAxisArrays.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Arrays","page":"Getting started with JuMP","title":"Arrays","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP arrays are created when you have integer indices that start at 1:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, a[1:2, 1:2])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Create an n-dimensional variable x in R^n with bounds l le x le u (l u in R^n) as follows:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"n = 10\nl = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nu = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n\n@variable(model, l[i] <= x[i = 1:n] <= u[i])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We can also create variable bounds that depend upon the indices:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, y[i = 1:2, j = 1:2] >= 2i + j)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#DenseAxisArrays","page":"Getting started with JuMP","title":"DenseAxisArrays","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"DenseAxisArrays are used when the indices are not one-based integer ranges. The syntax is similar except with an arbitrary vector as an index as opposed to a one-based range:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, z[i = 2:3, j = 1:2:3] >= 0)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Indices do not have to be integers. They can be any Julia type:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, w[1:5, [\"red\", \"blue\"]] <= 1)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#SparseAxisArrays","page":"Getting started with JuMP","title":"SparseAxisArrays","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"SparseAxisArrays are created when the indices do not form a rectangular set. For example, this applies when indices have a dependence upon previous indices (called triangular indexing):","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, u[i = 1:2, j = i:3])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We can also conditionally create variables by adding a comparison check that depends upon the named indices and is separated from the indices by a semi-colon ;:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, v[i = 1:9; mod(i, 3) == 0])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Integrality","page":"Getting started with JuMP","title":"Integrality","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP can create binary and integer variables. Binary variables are constrained to the set  0 1, and integer variables are constrained to the set mathbbZ.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Integer-variables","page":"Getting started with JuMP","title":"Integer variables","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Create an integer variable by passing  Int:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, integer_x, Int)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"or setting the integer keyword to true:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, integer_z, integer = true)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Binary-variables","page":"Getting started with JuMP","title":"Binary variables","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Create a binary variable by passing Bin:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, binary_x, Bin)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"or setting the binary keyword to true:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, binary_z, binary = true)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Constraint-basics","page":"Getting started with JuMP","title":"Constraint basics","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We'll need a need a new model to explain some of the constraint  basics:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\n@variable(model, z[1:10]);\nnothing #hide","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#tutorial_constraint_container","page":"Getting started with JuMP","title":"Containers","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Just as we had containers for variables, JuMP also provides Arrays, DenseAxisArrays, and SparseAxisArrays for storing collections of constraints. Examples for each container type are given below.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Arrays-2","page":"Getting started with JuMP","title":"Arrays","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@constraint(model, [i = 1:3], i * x <= i + 1)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#DenseAxisArrays-2","page":"Getting started with JuMP","title":"DenseAxisArrays","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@constraint(model, [i = 1:2, j = 2:3], i * x <= j + 1)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#SparseAxisArrays-2","page":"Getting started with JuMP","title":"SparseAxisArrays","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@constraint(model, [i = 1:2, j = 1:2; i != j], i * x <= j + 1)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Constraints-in-a-loop","page":"Getting started with JuMP","title":"Constraints in a loop","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We can add constraints using regular Julia loops:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"for i in 1:3\n    @constraint(model, 6x + 4y >= 5i)\nend","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"or use for each loops inside the @constraint macro:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@constraint(model, [i in 1:3], 6x + 4y >= 5i)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We can also create constraints such as sum _i = 1^10 z_i leq 1:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@constraint(model, sum(z[i] for i in 1:10) <= 1)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Objective-functions","page":"Getting started with JuMP","title":"Objective functions","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Set an objective function with @objective:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = Model(GLPK.Optimizer)\n@variable(model, x >= 0)\n@variable(model, y >= 0)\n@objective(model, Min, 2x + y)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Create a maximization objective using Max:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@objective(model, Max, 2x + y)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"tip: Tip\nCalling @objective multiple times will over-write the previous objective. This can be useful when you want to solve the same problem with different objectives.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Vectorized-syntax","page":"Getting started with JuMP","title":"Vectorized syntax","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We can also add constraints and an objective to JuMP using vectorized linear algebra. We'll illustrate this by solving an LP in standard form i.e.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"beginaligned\n min  c^T x \n textst  A x = b \n  x ge 0\nendaligned","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"vector_model = Model(GLPK.Optimizer)\n\nA = [\n    1 1 9 5\n    3 5 0 8\n    2 0 6 13\n]\n\nb = [7; 3; 5]\n\nc = [1; 3; 5; 2]\n\n@variable(vector_model, x[1:4] >= 0)\n@constraint(vector_model, A * x .== b)\n@objective(vector_model, Min, c' * x)\n\noptimize!(vector_model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"objective_value(vector_model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"},{"location":"tutorials/conic/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/conic/robust_uncertainty.jl\"","category":"page"},{"location":"tutorials/conic/robust_uncertainty/#Robust-uncertainty-sets","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"","category":"section"},{"location":"tutorials/conic/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"Computes the Value at Risk for a data-driven uncertainty set; see \"Data-Driven Robust Optimization\" (Bertsimas 2013), section 6.1 for details. Closed-form expressions for the optimal value are available.","category":"page"},{"location":"tutorials/conic/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"using JuMP\nimport SCS\nimport LinearAlgebra\nimport Test\n\nfunction example_robust_uncertainty()\n    R = 1\n    d = 3\n    𝛿 = 0.05\n    ɛ = 0.05\n    N = ceil((2 + 2 * log(2 / 𝛿))^2) + 1\n    c = randn(d)\n    μhat = rand(d)\n    M = rand(d, d)\n    Σhat = 1 / (d - 1) * (M - ones(d) * μhat')' * (M - ones(d) * μhat')\n    Γ1(𝛿, N) = R / sqrt(N) * (2 + sqrt(2 * log(1 / 𝛿)))\n    Γ2(𝛿, N) = 2 * R^2 / sqrt(N) * (2 + sqrt(2 * log(2 / 𝛿)))\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, Σ[1:d, 1:d], PSD)\n    @variable(model, u[1:d])\n    @variable(model, μ[1:d])\n    @constraint(model, [Γ1(𝛿 / 2, N); μ - μhat] in SecondOrderCone())\n    @constraint(model, [Γ2(𝛿 / 2, N); vec(Σ - Σhat)] in SecondOrderCone())\n    @constraint(model, [((1-ɛ)/ɛ) (u - μ)'; (u-μ) Σ] in PSDCone())\n    @objective(model, Max, LinearAlgebra.dot(c, u))\n    optimize!(model)\n    I = Matrix(1.0 * LinearAlgebra.I, d, d)\n    exact =\n        LinearAlgebra.dot(μhat, c) +\n        Γ1(𝛿 / 2, N) * LinearAlgebra.norm(c) +\n        sqrt((1 - ɛ) / ɛ) *\n        sqrt(LinearAlgebra.dot(c, (Σhat + Γ2(𝛿 / 2, N) * I) * c))\n    Test.@test objective_value(model) ≈ exact atol = 1e-3\n    return\nend\n\nexample_robust_uncertainty()","category":"page"},{"location":"tutorials/conic/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"","category":"page"},{"location":"tutorials/conic/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"tip: Tip\nThis tutorial was generated using Literate.jl. View the source .jl file on GitHub.","category":"page"}]
}
