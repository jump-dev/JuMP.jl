<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Nonlinear Modeling · JuMP</title><meta name="title" content="Nonlinear Modeling · JuMP"/><meta property="og:title" content="Nonlinear Modeling · JuMP"/><meta property="twitter:title" content="Nonlinear Modeling · JuMP"/><meta name="description" content="Documentation for JuMP."/><meta property="og:description" content="Documentation for JuMP."/><meta property="twitter:description" content="Documentation for JuMP."/><script async src="https://www.googletagmanager.com/gtag/js?id=G-0RZ8X3D3D0"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-0RZ8X3D3D0', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="JuMP logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="JuMP logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../should_i_use/">Should you use JuMP?</a></li><li><a class="tocitem" href="../../installation/">Installation Guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/getting_started/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/getting_started/getting_started_with_julia/">Getting started with Julia</a></li><li><a class="tocitem" href="../../tutorials/getting_started/getting_started_with_JuMP/">Getting started with JuMP</a></li><li><a class="tocitem" href="../../tutorials/getting_started/getting_started_with_sets_and_indexing/">Getting started with sets and indexing</a></li><li><a class="tocitem" href="../../tutorials/getting_started/getting_started_with_data_and_plotting/">Getting started with data and plotting</a></li><li><a class="tocitem" href="../../tutorials/getting_started/debugging/">Debugging</a></li><li><a class="tocitem" href="../../tutorials/getting_started/tolerances/">Tolerances and numerical issues</a></li><li><a class="tocitem" href="../../tutorials/getting_started/design_patterns_for_larger_models/">Design patterns for larger models</a></li><li><a class="tocitem" href="../../tutorials/getting_started/performance_tips/">Performance tips</a></li><li><a class="tocitem" href="../../tutorials/getting_started/sum_if/">Performance problems with sum-if formulations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Transitioning</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/transitioning/transitioning_from_matlab/">Transitioning from MATLAB</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Linear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/linear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/linear/knapsack/">The knapsack problem example</a></li><li><a class="tocitem" href="../../tutorials/linear/diet/">The diet problem</a></li><li><a class="tocitem" href="../../tutorials/linear/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../../tutorials/linear/typed_indices/">Strategies for dealing with many indices</a></li><li><a class="tocitem" href="../../tutorials/linear/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../../tutorials/linear/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../../tutorials/linear/multi_commodity_network/">The network multi-commodity flow problem</a></li><li><a class="tocitem" href="../../tutorials/linear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../tutorials/linear/piecewise_linear/">Approximating nonlinear functions</a></li><li><a class="tocitem" href="../../tutorials/linear/facility_location/">The facility location problem</a></li><li><a class="tocitem" href="../../tutorials/linear/finance/">Financial modeling problems</a></li><li><a class="tocitem" href="../../tutorials/linear/geographic_clustering/">Geographical clustering</a></li><li><a class="tocitem" href="../../tutorials/linear/network_flows/">Network flow problems</a></li><li><a class="tocitem" href="../../tutorials/linear/transp/">The transportation problem</a></li><li><a class="tocitem" href="../../tutorials/linear/multi_objective_knapsack/">Multi-objective knapsack</a></li><li><a class="tocitem" href="../../tutorials/linear/multi_objective_examples/">Simple multi-objective examples</a></li><li><a class="tocitem" href="../../tutorials/linear/sudoku/">Sudoku</a></li><li><a class="tocitem" href="../../tutorials/linear/n-queens/">N-Queens</a></li><li><a class="tocitem" href="../../tutorials/linear/constraint_programming/">Constraint programming</a></li><li><a class="tocitem" href="../../tutorials/linear/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../tutorials/linear/lp_sensitivity/">Sensitivity analysis of a linear program</a></li><li><a class="tocitem" href="../../tutorials/linear/basis/">Basis matrices</a></li><li><a class="tocitem" href="../../tutorials/linear/mip_duality/">Computing the duals of a mixed-integer program</a></li><li><a class="tocitem" href="../../tutorials/linear/multiple_solutions/">Finding multiple feasible solutions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Nonlinear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/nonlinear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/simple_examples/">Simple examples</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/tips_and_tricks/">User-defined operators with vector outputs</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/operator_ad/">Automatic differentiation of user-defined operators</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/user_defined_hessians/">User-defined Hessians</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/nested_problems/">Nested optimization problems</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/querying_hessians/">Computing Hessians</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/complementarity/">Example: mixed complementarity problems</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/classifiers/">Example: classification problems</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/portfolio/">Example: portfolio optimization</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/rocket_control/">Example: nonlinear optimal control of a rocket</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/space_shuttle_reentry_trajectory/">Example: optimal control for a Space Shuttle reentry trajectory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Conic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/conic/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/conic/tips_and_tricks/">Modeling with cones</a></li><li><a class="tocitem" href="../../tutorials/conic/dualization/">Dualization</a></li><li><a class="tocitem" href="../../tutorials/conic/arbitrary_precision/">Arbitrary precision arithmetic</a></li><li><a class="tocitem" href="../../tutorials/conic/start_values/">Primal and dual warm-starts</a></li><li><a class="tocitem" href="../../tutorials/conic/simple_examples/">Simple semidefinite programming examples</a></li><li><a class="tocitem" href="../../tutorials/conic/chordal_decomposition/">Chordal decomposition</a></li><li><a class="tocitem" href="../../tutorials/conic/logistic_regression/">Example: logistic regression</a></li><li><a class="tocitem" href="../../tutorials/conic/experiment_design/">Example: experiment design</a></li><li><a class="tocitem" href="../../tutorials/conic/min_ellipse/">Example: minimal ellipses</a></li><li><a class="tocitem" href="../../tutorials/conic/ellipse_approx/">Example: ellipsoid approximation</a></li><li><a class="tocitem" href="../../tutorials/conic/ellipse_fitting/">Example: fitting of circles and ellipses</a></li><li><a class="tocitem" href="../../tutorials/conic/quantum_discrimination/">Example: quantum state discrimination</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/algorithms/benders_decomposition/">Benders decomposition</a></li><li><a class="tocitem" href="../../tutorials/algorithms/cutting_stock_column_generation/">Column generation</a></li><li><a class="tocitem" href="../../tutorials/algorithms/tsp_lazy_constraints/">Traveling Salesperson Problem</a></li><li><a class="tocitem" href="../../tutorials/algorithms/rolling_horizon/">Rolling horizon problems</a></li><li><a class="tocitem" href="../../tutorials/algorithms/parallelism/">Parallelism</a></li><li><a class="tocitem" href="../../tutorials/algorithms/pdhg/">Writing a solver interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-7" type="checkbox"/><label class="tocitem" for="menuitem-2-7"><span class="docs-label">Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/applications/power_systems/">Power Systems</a></li><li><a class="tocitem" href="../../tutorials/applications/optimal_power_flow/">Optimal power flow</a></li><li><a class="tocitem" href="../../tutorials/applications/web_app/">Serving web apps</a></li><li><a class="tocitem" href="../../tutorials/applications/two_stage_stochastic/">Two-stage stochastic programs</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../variables/">Variables</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../expressions/">Expressions</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../containers/">Containers</a></li><li><a class="tocitem" href="../solutions/">Solutions</a></li><li><a class="tocitem" href="../callbacks/">Solver-independent Callbacks</a></li><li><a class="tocitem" href="../complex/">Complex number support</a></li><li class="is-active"><a class="tocitem" href>Nonlinear Modeling</a><ul class="internal"><li><a class="tocitem" href="#Set-a-nonlinear-objective"><span>Set a nonlinear objective</span></a></li><li><a class="tocitem" href="#Add-a-nonlinear-constraint"><span>Add a nonlinear constraint</span></a></li><li><a class="tocitem" href="#Add-a-parameter"><span>Add a parameter</span></a></li><li><a class="tocitem" href="#Create-a-nonlinear-expression"><span>Create a nonlinear expression</span></a></li><li><a class="tocitem" href="#Common-subexpressions"><span>Common subexpressions</span></a></li><li><a class="tocitem" href="#Automatic-differentiation"><span>Automatic differentiation</span></a></li><li><a class="tocitem" href="#Nonlinear-expressions-in-detail"><span>Nonlinear expressions in detail</span></a></li><li><a class="tocitem" href="#Function-tracing"><span>Function tracing</span></a></li><li><a class="tocitem" href="#jump_user_defined_operators"><span>User-defined operators</span></a></li></ul></li><li><a class="tocitem" href="../nlp/">Nonlinear Modeling (Legacy)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/JuMP/">JuMP</a></li><li><a class="tocitem" href="../../api/JuMP.Containers/">JuMP.Containers</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Background Information</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/algebraic_modeling_languages/">Algebraic modeling languages</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../developers/contributing/">Contributing</a></li><li><a class="tocitem" href="../../developers/extensions/">Extensions</a></li><li><a class="tocitem" href="../../developers/custom_solver_binaries/">Custom binaries</a></li><li><a class="tocitem" href="../../developers/style/">Style Guide</a></li><li><a class="tocitem" href="../../developers/conventions/">Conventions</a></li><li><a class="tocitem" href="../../developers/roadmap/">Roadmap</a></li><li><a class="tocitem" href="../../developers/checklists/">Checklists</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../packages/solvers/">Introduction</a></li><li><a class="tocitem" href="../../packages/AmplNLWriter/">jump-dev/AmplNLWriter.jl</a></li><li><a class="tocitem" href="../../packages/BARON/">jump-dev/BARON.jl</a></li><li><a class="tocitem" href="../../packages/CPLEX/">jump-dev/CPLEX.jl</a></li><li><a class="tocitem" href="../../packages/CSDP/">jump-dev/CSDP.jl</a></li><li><a class="tocitem" href="../../packages/Cbc/">jump-dev/Cbc.jl</a></li><li><a class="tocitem" href="../../packages/Clp/">jump-dev/Clp.jl</a></li><li><a class="tocitem" href="../../packages/DSDP/">jump-dev/DSDP.jl</a></li><li><a class="tocitem" href="../../packages/Dualization/">jump-dev/Dualization.jl</a></li><li><a class="tocitem" href="../../packages/ECOS/">jump-dev/ECOS.jl</a></li><li><a class="tocitem" href="../../packages/GLPK/">jump-dev/GLPK.jl</a></li><li><a class="tocitem" href="../../packages/Gurobi/">jump-dev/Gurobi.jl</a></li><li><a class="tocitem" href="../../packages/HiGHS/">jump-dev/HiGHS.jl</a></li><li><a class="tocitem" href="../../packages/Hypatia/">jump-dev/Hypatia.jl</a></li><li><a class="tocitem" href="../../packages/Ipopt/">jump-dev/Ipopt.jl</a></li><li><a class="tocitem" href="../../packages/KNITRO/">jump-dev/KNITRO.jl</a></li><li><a class="tocitem" href="../../packages/MiniZinc/">jump-dev/MiniZinc.jl</a></li><li><a class="tocitem" href="../../packages/MosekTools/">jump-dev/MosekTools.jl</a></li><li><a class="tocitem" href="../../packages/MultiObjectiveAlgorithms/">jump-dev/MultiObjectiveAlgorithms.jl</a></li><li><a class="tocitem" href="../../packages/NEOSServer/">jump-dev/NEOSServer.jl</a></li><li><a class="tocitem" href="../../packages/NLopt/">jump-dev/NLopt.jl</a></li><li><a class="tocitem" href="../../packages/Pajarito/">jump-dev/Pajarito.jl</a></li><li><a class="tocitem" href="../../packages/Pavito/">jump-dev/Pavito.jl</a></li><li><a class="tocitem" href="../../packages/SCS/">jump-dev/SCS.jl</a></li><li><a class="tocitem" href="../../packages/SDPA/">jump-dev/SDPA.jl</a></li><li><a class="tocitem" href="../../packages/SDPLR/">jump-dev/SDPLR.jl</a></li><li><a class="tocitem" href="../../packages/SDPNAL/">jump-dev/SDPNAL.jl</a></li><li><a class="tocitem" href="../../packages/SDPT3/">jump-dev/SDPT3.jl</a></li><li><a class="tocitem" href="../../packages/SeDuMi/">jump-dev/SeDuMi.jl</a></li><li><a class="tocitem" href="../../packages/Xpress/">jump-dev/Xpress.jl</a></li><li><a class="tocitem" href="../../packages/COPT/">COPT-Public/COPT.jl</a></li><li><a class="tocitem" href="../../packages/GAMS/">GAMS-dev/GAMS.jl</a></li><li><a class="tocitem" href="../../packages/Manopt/">JuliaManifolds/Manopt.jl</a></li><li><a class="tocitem" href="../../packages/Optim/">JuliaNLSolvers/Optim.jl</a></li><li><a class="tocitem" href="../../packages/CDDLib/">JuliaPolyhedra/CDDLib.jl</a></li><li><a class="tocitem" href="../../packages/Percival/">JuliaSmoothOptimizers/Percival.jl</a></li><li><a class="tocitem" href="../../packages/MAiNGO/">MAiNGO-github/MAiNGO.jl</a></li><li><a class="tocitem" href="../../packages/MadNLP/">MadNLP/MadNLP.jl</a></li><li><a class="tocitem" href="../../packages/EAGO/">PSORLab/EAGO.jl</a></li><li><a class="tocitem" href="../../packages/PATHSolver/">chkwon/PATHSolver.jl</a></li><li><a class="tocitem" href="../../packages/DAQP/">darnstrom/DAQP.jl</a></li><li><a class="tocitem" href="../../packages/Tulip/">ds4dm/Tulip.jl</a></li><li><a class="tocitem" href="../../packages/CATrustRegionMethod/">fadihamad94/CATrustRegionMethod.jl</a></li><li><a class="tocitem" href="../../packages/Loraine/">kocvara/Loraine.jl</a></li><li><a class="tocitem" href="../../packages/Alpine/">lanl-ansi/Alpine.jl</a></li><li><a class="tocitem" href="../../packages/Juniper/">lanl-ansi/Juniper.jl</a></li><li><a class="tocitem" href="../../packages/ProxSDP/">mariohsouto/ProxSDP.jl</a></li><li><a class="tocitem" href="../../packages/OSQP/">osqp/OSQP.jl</a></li><li><a class="tocitem" href="../../packages/CDCS/">oxfordcontrol/CDCS.jl</a></li><li><a class="tocitem" href="../../packages/COSMO/">oxfordcontrol/COSMO.jl</a></li><li><a class="tocitem" href="../../packages/Clarabel/">oxfordcontrol/Clarabel.jl</a></li><li><a class="tocitem" href="../../packages/MathOptChordalDecomposition/">samuelsonric/MathOptChordalDecomposition.jl</a></li><li><a class="tocitem" href="../../packages/SCIP/">scipopt/SCIP.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Extensions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../extensions/introduction/">Introduction</a></li><li><a class="tocitem" href="../../packages/DiffOpt/">jump-dev/DiffOpt.jl</a></li><li><a class="tocitem" href="../../packages/ParametricOptInterface/">jump-dev/ParametricOptInterface.jl</a></li><li><a class="tocitem" href="../../packages/PiecewiseLinearOpt/">jump-dev/PiecewiseLinearOpt.jl</a></li><li><a class="tocitem" href="../../packages/PolyJuMP/">jump-dev/PolyJuMP.jl</a></li><li><a class="tocitem" href="../../packages/SumOfSquares/">jump-dev/SumOfSquares.jl</a></li><li><a class="tocitem" href="../../packages/DisjunctiveProgramming/">hdavid16/DisjunctiveProgramming.jl</a></li><li><a class="tocitem" href="../../packages/InfiniteOpt/">infiniteopt/InfiniteOpt.jl</a></li><li><a class="tocitem" href="../../packages/BilevelJuMP/">joaquimg/BilevelJuMP.jl</a></li><li><a class="tocitem" href="../../packages/MathOptAI/">lanl-ansi/MathOptAI.jl</a></li><li><a class="tocitem" href="../../packages/MathOptSymbolicAD/">lanl-ansi/MathOptSymbolicAD.jl</a></li><li><a class="tocitem" href="../../packages/SDDP/">odow/SDDP.jl</a></li><li><a class="tocitem" href="../../packages/Plasmo/">plasmo-dev/Plasmo.jl</a></li><li><a class="tocitem" href="../../extensions/DimensionalData/">rafaqz/DimensionalData.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">MathOptInterface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-1" type="checkbox"/><label class="tocitem" for="menuitem-9-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/">Introduction</a></li><li><a class="tocitem" href="../../moi/background/motivation/">Motivation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-2" type="checkbox"/><label class="tocitem" for="menuitem-9-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/tutorials/example/">Solving a problem using MathOptInterface</a></li><li><a class="tocitem" href="../../moi/tutorials/implementing/">Implementing a solver interface</a></li><li><a class="tocitem" href="../../moi/tutorials/mathprogbase/">Transitioning from MathProgBase</a></li><li><a class="tocitem" href="../../moi/tutorials/bridging_constraint/">Implementing a constraint bridge</a></li><li><a class="tocitem" href="../../moi/tutorials/manipulating_expressions/">Manipulating expressions</a></li><li><a class="tocitem" href="../../moi/tutorials/latency/">Latency</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-3" type="checkbox"/><label class="tocitem" for="menuitem-9-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/manual/standard_form/">Standard form problem</a></li><li><a class="tocitem" href="../../moi/manual/models/">Models</a></li><li><a class="tocitem" href="../../moi/manual/variables/">Variables</a></li><li><a class="tocitem" href="../../moi/manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../moi/manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../moi/manual/modification/">Problem modification</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-4" type="checkbox"/><label class="tocitem" for="menuitem-9-4"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/background/duality/">Duality</a></li><li><a class="tocitem" href="../../moi/background/infeasibility_certificates/">Infeasibility certificates</a></li><li><a class="tocitem" href="../../moi/background/naming_conventions/">Naming conventions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-5" type="checkbox"/><label class="tocitem" for="menuitem-9-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/reference/standard_form/">Standard form</a></li><li><a class="tocitem" href="../../moi/reference/models/">Models</a></li><li><a class="tocitem" href="../../moi/reference/variables/">Variables</a></li><li><a class="tocitem" href="../../moi/reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../moi/reference/modification/">Modifications</a></li><li><a class="tocitem" href="../../moi/reference/nonlinear/">Nonlinear programming</a></li><li><a class="tocitem" href="../../moi/reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../moi/reference/errors/">Errors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-6-1" type="checkbox"/><label class="tocitem" for="menuitem-9-6-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-2" type="checkbox"/><label class="tocitem" for="menuitem-9-6-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Bridges/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Bridges/implementation/">Implementation</a></li><li><a class="tocitem" href="../../moi/submodules/Bridges/list_of_bridges/">List of bridges</a></li><li><a class="tocitem" href="../../moi/submodules/Bridges/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-3" type="checkbox"/><label class="tocitem" for="menuitem-9-6-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/FileFormats/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-4" type="checkbox"/><label class="tocitem" for="menuitem-9-6-4"><span class="docs-label">Nonlinear</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Nonlinear/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Nonlinear/SymbolicAD/">SymbolicAD</a></li><li><a class="tocitem" href="../../moi/submodules/Nonlinear/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-5" type="checkbox"/><label class="tocitem" for="menuitem-9-6-5"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Utilities/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Utilities/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6-6"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Test/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Test/reference/">API Reference</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/developer/checklists/">Checklists</a></li></ul></li><li><a class="tocitem" href="../../moi/release_notes/">Release notes</a></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Nonlinear Modeling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Nonlinear Modeling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/manual/nonlinear.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Nonlinear-Modeling"><a class="docs-heading-anchor" href="#Nonlinear-Modeling">Nonlinear Modeling</a><a id="Nonlinear-Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Modeling" title="Permalink"></a></h1><p>JuMP has support for nonlinear (convex and nonconvex) optimization problems. JuMP is able to automatically provide exact, sparse second-order derivatives to solvers. This information can improve solver accuracy and performance.</p><h2 id="Set-a-nonlinear-objective"><a class="docs-heading-anchor" href="#Set-a-nonlinear-objective">Set a nonlinear objective</a><a id="Set-a-nonlinear-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Set-a-nonlinear-objective" title="Permalink"></a></h2><p>Use <a href="../../api/JuMP/#@objective"><code>@objective</code></a> to set a nonlinear objective.</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; @objective(model, Min, exp(x[1]) - sqrt(x[2]))
exp(x[1]) - sqrt(x[2])</code></pre><p>To modify a nonlinear objective, call <a href="../../api/JuMP/#@objective"><code>@objective</code></a> again.</p><h2 id="Add-a-nonlinear-constraint"><a class="docs-heading-anchor" href="#Add-a-nonlinear-constraint">Add a nonlinear constraint</a><a id="Add-a-nonlinear-constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Add-a-nonlinear-constraint" title="Permalink"></a></h2><p>Use <a href="../../api/JuMP/#@constraint"><code>@constraint</code></a> to add a nonlinear constraint.</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; @constraint(model, exp(x[1]) &lt;= 1)
exp(x[1]) - 1.0 ≤ 0

julia&gt; @constraint(model, con[i = 1:2], 2^x[i] &gt;= i)
2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarNonlinearFunction, MathOptInterface.GreaterThan{Float64}}, ScalarShape}}:
 con[1] : (2.0 ^ x[1]) - 1.0 ≥ 0
 con[2] : (2.0 ^ x[2]) - 2.0 ≥ 0</code></pre><p>Delete a nonlinear constraint using <a href="../../api/JuMP/#delete"><code>delete</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; delete(model, con[1])</code></pre><h2 id="Add-a-parameter"><a class="docs-heading-anchor" href="#Add-a-parameter">Add a parameter</a><a id="Add-a-parameter-1"></a><a class="docs-heading-anchor-permalink" href="#Add-a-parameter" title="Permalink"></a></h2><p>Some solvers have explicit support for parameters, which are constants in the model that can be efficiently updated between solves.</p><p>JuMP implements parameters by a decision variable constrained on creation to the <a href="../../api/JuMP/#Parameter"><code>Parameter</code></a> set.</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; @variable(model, p[i = 1:2] in Parameter(i))
2-element Vector{VariableRef}:
 p[1]
 p[2]

julia&gt; parameter_value(p[1])
1.0

julia&gt; set_parameter_value(p[1], 3.5)

julia&gt; @objective(model, Max, log(p[1] * x + p[2]))
log(p[1]*x + p[2])</code></pre><p>See <a href="../variables/#variables_parameters">Parameters</a> for more information on how to create and manage parameters.</p><p>Parameters are most useful when solving nonlinear models in a sequence:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JuMP, Ipopt</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model = Model(Ipopt.Optimizer);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; set_silent(model)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variable(model, x)</code><code class="nohighlight hljs ansi" style="display:block;">x</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variable(model, p in Parameter(1.0))</code><code class="nohighlight hljs ansi" style="display:block;">p</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @objective(model, Min, (x - p)^2)</code><code class="nohighlight hljs ansi" style="display:block;">x² - 2 p*x + p²</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; optimize!(model)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; value(x)</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; set_parameter_value(p, 5.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; optimize!(model)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; value(x)</code><code class="nohighlight hljs ansi" style="display:block;">5.0</code></pre><p>Using parameters can be faster than creating a new model from scratch with updated data because JuMP is able to avoid repeating a number of steps in processing the model before handing it off to the solver.</p><h2 id="Create-a-nonlinear-expression"><a class="docs-heading-anchor" href="#Create-a-nonlinear-expression">Create a nonlinear expression</a><a id="Create-a-nonlinear-expression-1"></a><a class="docs-heading-anchor-permalink" href="#Create-a-nonlinear-expression" title="Permalink"></a></h2><p>Use <a href="../../api/JuMP/#@expression"><code>@expression</code></a> to create nonlinear expression objects:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; expr = @expression(model, exp(x[1]) + sqrt(x[2]))
exp(x[1]) + sqrt(x[2])

julia&gt; my_anon_expr = @expression(model, [i = 1:2], sin(x[i]))
2-element Vector{NonlinearExpr}:
 sin(x[1])
 sin(x[2])

julia&gt; @expression(model, my_expr[i = 1:2], sin(x[i]))
2-element Vector{NonlinearExpr}:
 sin(x[1])
 sin(x[2])</code></pre><p>A <a href="../../api/JuMP/#NonlinearExpr"><code>NonlinearExpr</code></a> can be used in <a href="../../api/JuMP/#@objective"><code>@objective</code></a>, <a href="../../api/JuMP/#@constraint"><code>@constraint</code></a>, and even nested in other <a href="../../api/JuMP/#@expression"><code>@expression</code></a>s.</p><pre><code class="language-julia-repl hljs">julia&gt; @objective(model, Min, expr^2 + 1)
((exp(x[1]) + sqrt(x[2])) ^ 2.0) + 1.0

julia&gt; @constraint(model, [i = 1:2], my_expr[i] &lt;= i)
2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarNonlinearFunction, MathOptInterface.LessThan{Float64}}, ScalarShape}}:
 sin(x[1]) - 1.0 ≤ 0
 sin(x[2]) - 2.0 ≤ 0

julia&gt; @expression(model, nested[i = 1:2], sin(my_expr[i]))
2-element Vector{NonlinearExpr}:
 sin(sin(x[1]))
 sin(sin(x[2]))</code></pre><p>Use <a href="../../api/JuMP/#value"><code>value</code></a> to query the value of a nonlinear expression:</p><pre><code class="language-julia-repl hljs">julia&gt; set_start_value(x[1], 1.0)

julia&gt; value(start_value, nested[1])
0.7456241416655579

julia&gt; sin(sin(1.0))
0.7456241416655579</code></pre><h2 id="Common-subexpressions"><a class="docs-heading-anchor" href="#Common-subexpressions">Common subexpressions</a><a id="Common-subexpressions-1"></a><a class="docs-heading-anchor-permalink" href="#Common-subexpressions" title="Permalink"></a></h2><p>JuMP does not perform <a href="https://en.wikipedia.org/wiki/Common_subexpression_elimination">common subexpression elimination</a>. Instead, if you re-use an expression in multiple places, JuMP will insert a copy of the expression.</p><p>JuMP&#39;s lack of common subexpression elimination is a common cause of performance problems, particularly in nonlinear models with a pattern like <code>sum(t / common_term for t in terms)</code>. One example is the logistic loss:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; @expression(model, expr, sum(exp.(x)))
0.0 + exp(x[2]) + exp(x[1])

julia&gt; @objective(model, Min, sum(exp(x[i]) / expr for i in 1:2))
(exp(x[1]) / (0.0 + exp(x[2]) + exp(x[1]))) + (exp(x[2]) / (0.0 + exp(x[2]) + exp(x[1])))</code></pre><p>In this model, JuMP will compute the value (and derivatives) of the denominator twice, without realizing that it is the same expression.</p><p>As a work-around, create a new <a href="../../api/JuMP/#@variable"><code>@variable</code></a> and use an <code>==</code> <a href="../../api/JuMP/#@constraint"><code>@constraint</code></a> to constrain the value of the variable to the subexpression.</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; @variable(model, expr);

julia&gt; @constraint(model, expr == sum(exp.(x)))
expr - (0.0 + exp(x[2]) + exp(x[1])) = 0

julia&gt; @objective(model, Min, sum(exp(x[i]) / expr for i in 1:2))
(exp(x[1]) / expr) + (exp(x[2]) / expr)</code></pre><p>The reason JuMP does not perform common subexpression elimination automatically is for simplicity, and because there is a trade-off: for simple expressions, the extra complexity of detecting and merging common subexpressions may outweigh the cost of computing them independently. Instead, we leave it to the user to decide which expressions to extract as common subexpressions.</p><h2 id="Automatic-differentiation"><a class="docs-heading-anchor" href="#Automatic-differentiation">Automatic differentiation</a><a id="Automatic-differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-differentiation" title="Permalink"></a></h2><p>JuMP computes first- and second-order derivatives using sparse reverse-mode automatic differentiation. For details, see <a href="../../moi/submodules/Nonlinear/overview/#ReverseAD">ReverseAD</a>.</p><p>For a tutorial on how to construct and query the derivatives, see <a href="../../tutorials/nonlinear/querying_hessians/#Computing-Hessians">Computing Hessians</a></p><h2 id="Nonlinear-expressions-in-detail"><a class="docs-heading-anchor" href="#Nonlinear-expressions-in-detail">Nonlinear expressions in detail</a><a id="Nonlinear-expressions-in-detail-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-expressions-in-detail" title="Permalink"></a></h2><p>Nonlinear expressions in JuMP are represented by a <a href="../../api/JuMP/#NonlinearExpr"><code>NonlinearExpr</code></a> object.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><p>Nonlinear expressions can be created using the <a href="../../api/JuMP/#NonlinearExpr"><code>NonlinearExpr</code></a> constructors:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; expr = NonlinearExpr(:sin, Any[x])
sin(x)</code></pre><p>or via operator overloading:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; expr = sin(x)
sin(x)</code></pre><h3 id="Supported-arguments"><a class="docs-heading-anchor" href="#Supported-arguments">Supported arguments</a><a id="Supported-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Supported-arguments" title="Permalink"></a></h3><p>Nonlinear expressions can contain a mix of numbers, <a href="../../api/JuMP/#AffExpr"><code>AffExpr</code></a>, <a href="../../api/JuMP/#QuadExpr"><code>QuadExpr</code></a>, and other <a href="../../api/JuMP/#NonlinearExpr"><code>NonlinearExpr</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; aff = x + 1;

julia&gt; quad = x^2 + x;

julia&gt; expr = cos(x) * sin(quad) + aff
(cos(x) * sin(x² + x)) + (x + 1)</code></pre><h3 id="Supported-operators"><a class="docs-heading-anchor" href="#Supported-operators">Supported operators</a><a id="Supported-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Supported-operators" title="Permalink"></a></h3><p>The list of supported operators may vary between solvers. Given an optimizer, query the list of supported operators using <a href="../../moi/reference/models/#MathOptInterface.ListOfSupportedNonlinearOperators"><code>MOI.ListOfSupportedNonlinearOperators</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; import Ipopt

julia&gt; import MathOptInterface as MOI

julia&gt; MOI.get(Ipopt.Optimizer(), MOI.ListOfSupportedNonlinearOperators())
85-element Vector{Symbol}:
 :+
 :-
 :abs
 :sqrt
 :cbrt
 :abs2
 :inv
 :log
 :log10
 :log2
 ⋮
 :min
 :max
 :&amp;&amp;
 :||
 :&lt;=
 :(==)
 :&gt;=
 :&lt;
 :&gt;</code></pre><p>In some univariate cases, the operator is defined in <a href="https://github.com/JuliaMath/SpecialFunctions.jl"><code>SpecialFunctions.jl</code></a>. To use these functions, you must explicitly import <code>SpecialFunctions.jl</code></p><pre><code class="language-julia-repl hljs">julia&gt; import Ipopt

julia&gt; op = MOI.get(Ipopt.Optimizer(), MOI.ListOfSupportedNonlinearOperators());

julia&gt; :erfcx in op
true

julia&gt; :dawson in op
true

julia&gt; import SpecialFunctions

julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @expression(model, SpecialFunctions.erfcx(x))
erfcx(x)

julia&gt; @expression(model, SpecialFunctions.dawson(x))
dawson(x)</code></pre><h3 id="Limitations"><a class="docs-heading-anchor" href="#Limitations">Limitations</a><a id="Limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Limitations" title="Permalink"></a></h3><p>Some nonlinear expressions cannot be created via operator overloading. For example, to minimize the likelihood of bugs in user-code, we have not overloaded comparisons such as <code>&lt;</code> and <code>&gt;=</code> between JuMP objects:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; x &lt; 1
ERROR: Cannot evaluate `&lt;` between a variable and a number.
[...]</code></pre><p>Instead, wrap the expression in the <a href="../../api/JuMP/#@expression"><code>@expression</code></a> macro:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; expr = @expression(model, x &lt; 1)
x &lt; 1</code></pre><p>For technical reasons, other operators that are not overloaded include <code>||</code>, <code>&amp;&amp;</code>, and <code>ifelse</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; expr = @expression(model, ifelse(x &lt; -1 || x &gt;= 1, x^2, 0.0))
ifelse((x &lt; -1) || (x &gt;= 1), x², 0.0)</code></pre><p>As an alternative, use the <code>JuMP.op_</code> functions, which fallback to the various comparison and logical operators:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; expr = op_ifelse(
           op_or(op_strictly_less_than(x, -1), op_greater_than_or_equal_to(x, 1)),
           x^2,
           0.0,
       )
ifelse((x &lt; -1) || (x &gt;= 1), x², 0.0)</code></pre><p>The available functions are:</p><table><tr><th style="text-align: left">JuMP function</th><th style="text-align: left">Julia function</th></tr><tr><td style="text-align: left"><a href="../../api/JuMP/#op_ifelse"><code>op_ifelse</code></a></td><td style="text-align: left"><code>ifelse</code></td></tr><tr><td style="text-align: left"><a href="../../api/JuMP/#op_and"><code>op_and</code></a></td><td style="text-align: left"><code>&amp;&amp;</code></td></tr><tr><td style="text-align: left"><a href="../../api/JuMP/#op_or"><code>op_or</code></a></td><td style="text-align: left"><code>||</code></td></tr><tr><td style="text-align: left"><a href="../../api/JuMP/#op_greater_than_or_equal_to"><code>op_greater_than_or_equal_to</code></a></td><td style="text-align: left"><code>&gt;=</code></td></tr><tr><td style="text-align: left"><a href="../../api/JuMP/#op_less_than_or_equal_to"><code>op_less_than_or_equal_to</code></a></td><td style="text-align: left"><code>&lt;=</code></td></tr><tr><td style="text-align: left"><a href="../../api/JuMP/#op_equal_to"><code>op_equal_to</code></a></td><td style="text-align: left"><code>==</code></td></tr><tr><td style="text-align: left"><a href="../../api/JuMP/#op_strictly_greater_than"><code>op_strictly_greater_than</code></a></td><td style="text-align: left"><code>&gt;</code></td></tr><tr><td style="text-align: left"><a href="../../api/JuMP/#op_strictly_less_than"><code>op_strictly_less_than</code></a></td><td style="text-align: left"><code>&lt;</code></td></tr></table><h3 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h3><p>Each <a href="../../api/JuMP/#NonlinearExpr"><code>NonlinearExpr</code></a> has two fields.</p><p>The <code>.head</code> field is a <code>Symbol</code> that represents the operator being called:</p><pre><code class="language-julia-repl hljs">julia&gt; expr.head
:sin</code></pre><p>The <code>.args</code> field is a <code>Vector{Any}</code> containing the arguments to the operator:</p><pre><code class="language-julia-repl hljs">julia&gt; expr.args
1-element Vector{Any}:
 x</code></pre><h3 id="Forcing-nonlinear-expressions"><a class="docs-heading-anchor" href="#Forcing-nonlinear-expressions">Forcing nonlinear expressions</a><a id="Forcing-nonlinear-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Forcing-nonlinear-expressions" title="Permalink"></a></h3><p>The JuMP macros and operator overloading will preferentially build affine (<a href="../../api/JuMP/#GenericAffExpr"><code>GenericAffExpr</code></a>) and quadratic (<a href="../../api/JuMP/#GenericQuadExpr"><code>GenericQuadExpr</code></a>) expressions instead of <a href="../../api/JuMP/#GenericNonlinearExpr"><code>GenericNonlinearExpr</code></a>. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; f = (x - 0.1)^2
x² - 0.2 x + 0.010000000000000002

julia&gt; typeof(f)
QuadExpr (alias for GenericQuadExpr{Float64, GenericVariableRef{Float64}})</code></pre><p>To override this behavior, use the <a href="../../api/JuMP/#@force_nonlinear"><code>@force_nonlinear</code></a> macro:</p><pre><code class="language-julia-repl hljs">julia&gt; g = @force_nonlinear((x - 0.1)^2)
(x - 0.1) ^ 2

julia&gt; typeof(g)
NonlinearExpr (alias for GenericNonlinearExpr{GenericVariableRef{Float64}})</code></pre><div class="admonition is-warning" id="Warning-c2494169895a8916"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-c2494169895a8916" title="Permalink"></a></header><div class="admonition-body"><p>Use this macro only if necessary. See the docstring of <a href="../../api/JuMP/#@force_nonlinear"><code>@force_nonlinear</code></a> for more details on when you should use it.</p></div></div><h2 id="Function-tracing"><a class="docs-heading-anchor" href="#Function-tracing">Function tracing</a><a id="Function-tracing-1"></a><a class="docs-heading-anchor-permalink" href="#Function-tracing" title="Permalink"></a></h2><p>Nonlinear expressions can be constructed using <em>function tracing</em>. Function tracing is when you call a regular Julia function with JuMP variables as arguments and the function builds a nonlinear expression via operator overloading. For example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JuMP</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model = Model();</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variable(model, x[1:2]);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x::Vector{VariableRef}) = 2 * sin(x[1]^2) + sqrt(x[2])</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = f(x)</code><code class="nohighlight hljs ansi" style="display:block;">(2.0 * sin(x[1]²)) + sqrt(x[2])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(y)</code><code class="nohighlight hljs ansi" style="display:block;">NonlinearExpr<span class="sgr90"> (alias for GenericNonlinearExpr{GenericVariableRef{Float64}})</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @objective(model, Max, f(x))</code><code class="nohighlight hljs ansi" style="display:block;">(2.0 * sin(x[1]²)) + sqrt(x[2])</code></pre><p>Function tracing supports functions which return vectors or arrays of <a href="../../api/JuMP/#NonlinearExpr"><code>NonlinearExpr</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JuMP</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model = Model();</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variable(model, x[1:2]);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x::Vector{VariableRef}) = sqrt.(x)</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = f(x)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{NonlinearExpr}:
 sqrt(x[1])
 sqrt(x[2])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(y)</code><code class="nohighlight hljs ansi" style="display:block;">Vector{NonlinearExpr}<span class="sgr90"> (alias for Array{GenericNonlinearExpr{GenericVariableRef{Float64}}, 1})</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @constraint(model, f(x) .&lt;= 2)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarNonlinearFunction, MathOptInterface.LessThan{Float64}}, ScalarShape}}:
 sqrt(x[1]) - 2.0 ≤ 0
 sqrt(x[2]) - 2.0 ≤ 0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @objective(model, Max, sum(f(x)))</code><code class="nohighlight hljs ansi" style="display:block;">0.0 + sqrt(x[2]) + sqrt(x[1])</code></pre><p>Because function tracing uses operator overloading, there are many functions for which it will not work. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP

julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; f(x::Vector{VariableRef}) = x[1] &gt; 1 ? 0 : x[2]
f (generic function with 1 method)

julia&gt; f(x)
ERROR: Cannot evaluate `&gt;` between a variable and a number.
[...]</code></pre><p>In these cases, you should define a <a href="#jump_user_defined_operators">User-defined operator</a> using the <a href="../../api/JuMP/#@operator"><code>@operator</code></a> macro.</p><h2 id="jump_user_defined_operators"><a class="docs-heading-anchor" href="#jump_user_defined_operators">User-defined operators</a><a id="jump_user_defined_operators-1"></a><a class="docs-heading-anchor-permalink" href="#jump_user_defined_operators" title="Permalink"></a></h2><p>In addition to a standard list of univariate and multivariate operators recognized by the <code>MOI.Nonlinear</code> submodule, JuMP supports user-defined operators, which let you represent nonlinear functions that cannot (or should not) be traced, for example, because they rely on non-Julia subroutines.</p><div class="admonition is-warning" id="Warning-b0394a771d50793e"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-b0394a771d50793e" title="Permalink"></a></header><div class="admonition-body"><p>User-defined operators must return a scalar output. For a work-around, see <a href="../../tutorials/nonlinear/tips_and_tricks/#User-defined-operators-with-vector-outputs">User-defined operators with vector outputs</a>.</p></div></div><h3 id="Add-an-operator"><a class="docs-heading-anchor" href="#Add-an-operator">Add an operator</a><a id="Add-an-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Add-an-operator" title="Permalink"></a></h3><p>Add a user-defined operator using the <a href="../../api/JuMP/#@operator"><code>@operator</code></a> macro:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JuMP</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; square(x) = x^2</code><code class="nohighlight hljs ansi" style="display:block;">square (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x, y) = (x - 1)^2 + (y - 2)^2</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model = Model();</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @operator(model, op_square, 1, square)</code><code class="nohighlight hljs ansi" style="display:block;">NonlinearOperator(square, :op_square)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @operator(model, op_f, 2, f)</code><code class="nohighlight hljs ansi" style="display:block;">NonlinearOperator(f, :op_f)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variable(model, x[1:2]);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @objective(model, Min, op_f(x[1], op_square(x[2])))</code><code class="nohighlight hljs ansi" style="display:block;">op_f(x[1], op_square(x[2]))</code></pre><p>The arguments to <a href="../../api/JuMP/#@operator"><code>@operator</code></a> are:</p><ol><li>The model to which the operator is added.</li><li>A Julia symbol object which serves as the name of the user-defined operator in JuMP expressions. This name must not be the same as that of the function.</li><li>The number of scalar input arguments that the function takes.</li><li>A Julia method which computes the function.</li></ol><div class="admonition is-warning" id="Warning-4919f47f99d4e6fa"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-4919f47f99d4e6fa" title="Permalink"></a></header><div class="admonition-body"><p>User-defined operators cannot be deleted.</p></div></div><p>You can obtain a reference to the operator using the <code>model[:key]</code> syntax:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JuMP</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; square(x) = x^2</code><code class="nohighlight hljs ansi" style="display:block;">square (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model = Model();</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @operator(model, op_square, 1, square)</code><code class="nohighlight hljs ansi" style="display:block;">NonlinearOperator(square, :op_square)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; op_square_2 = model[:op_square]</code><code class="nohighlight hljs ansi" style="display:block;">NonlinearOperator(square, :op_square)</code></pre><h3 id="Automatic-differentiation-2"><a class="docs-heading-anchor" href="#Automatic-differentiation-2">Automatic differentiation</a><a class="docs-heading-anchor-permalink" href="#Automatic-differentiation-2" title="Permalink"></a></h3><p>JuMP computes first- and second-order derivatives of expressions using <a href="../../moi/submodules/Nonlinear/overview/#ReverseAD">ReverseAD</a>, which implements sparse reverse-mode automatic differentiation. However, because <a href="../../moi/submodules/Nonlinear/overview/#ReverseAD">ReverseAD</a> requires the algebraic expression as input, JuMP cannot use <a href="../../moi/submodules/Nonlinear/overview/#ReverseAD">ReverseAD</a> to differentiate user-defined operators.</p><p>Instead, unless <a href="#Gradients-and-Hessians">Gradients and Hessians</a> are explicitly provided, user-defined operators must support automatic differentiation by <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a>.</p><p>The use of FowardDiff.jl has two important implications:</p><ol><li>ForwardDiff.jl supports only a limited subset of Julia. If you encounter an error adding the operator, see <a href="#Common-mistakes-when-writing-a-user-defined-operator">Common mistakes when writing a user-defined operator</a>.</li><li>Differentiating operators with many arguments is slow. In general, you should try to keep the number of arguments to less than 100, and ideally, to less than 10.</li></ol><p>Because of the use of ForwardDiff, in most cases, you should prefer to use function tracing instead of defining a user-defined operator.</p><h3 id="Add-an-operator-without-macros"><a class="docs-heading-anchor" href="#Add-an-operator-without-macros">Add an operator without macros</a><a id="Add-an-operator-without-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Add-an-operator-without-macros" title="Permalink"></a></h3><p>The <a href="../../api/JuMP/#@operator"><code>@operator</code></a> macro is syntactic sugar for <a href="../../api/JuMP/#add_nonlinear_operator"><code>add_nonlinear_operator</code></a>. Thus, the non-macro version of the preceding example is:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JuMP</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; square(x) = x^2</code><code class="nohighlight hljs ansi" style="display:block;">square (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x, y) = (x - 1)^2 + (y - 2)^2</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model = Model();</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; op_square = add_nonlinear_operator(model, 1, square; name = :op_square)</code><code class="nohighlight hljs ansi" style="display:block;">NonlinearOperator(square, :op_square)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model[:op_square] = op_square</code><code class="nohighlight hljs ansi" style="display:block;">NonlinearOperator(square, :op_square)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; op_f = add_nonlinear_operator(model, 2, f; name = :op_f)</code><code class="nohighlight hljs ansi" style="display:block;">NonlinearOperator(f, :op_f)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model[:op_f] = op_f</code><code class="nohighlight hljs ansi" style="display:block;">NonlinearOperator(f, :op_f)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variable(model, x[1:2]);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @objective(model, Min, op_f(x[1], op_square(x[2])))</code><code class="nohighlight hljs ansi" style="display:block;">op_f(x[1], op_square(x[2]))</code></pre><h3 id="Operators-with-the-same-name-as-an-existing-function"><a class="docs-heading-anchor" href="#Operators-with-the-same-name-as-an-existing-function">Operators with the same name as an existing function</a><a id="Operators-with-the-same-name-as-an-existing-function-1"></a><a class="docs-heading-anchor-permalink" href="#Operators-with-the-same-name-as-an-existing-function" title="Permalink"></a></h3><p>A common error encountered is the following:</p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP

julia&gt; model = Model();

julia&gt; f(x) = x^2
f (generic function with 1 method)

julia&gt; @operator(model, f, 1, f)
ERROR: Unable to add the nonlinear operator `:f` with the same name as
an existing function.
[...]</code></pre><p>This error occurs because <code>@operator(model, f, 1, f)</code> is equivalent to:</p><pre><code class="language-julia hljs">julia&gt; f = add_nonlinear_operator(model, 1, f; name = :f)</code></pre><p>but <code>f</code> already exists as a Julia function.</p><p>If you evaluate the function without adding it as an operator, JuMP will trace the function using operator overloading:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x);

julia&gt; f(x)
x²</code></pre><p>To force JuMP to treat <code>f</code> as a user-defined operator and not trace it, add the operator using <a href="../../api/JuMP/#add_nonlinear_operator"><code>add_nonlinear_operator</code></a> and define a new method which manually creates a <a href="../../api/JuMP/#NonlinearExpr"><code>NonlinearExpr</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; _ = add_nonlinear_operator(model, 1, f; name = :f)
NonlinearOperator(f, :f)

julia&gt; f(x::AbstractJuMPScalar) = NonlinearExpr(:f, Any[x])
f (generic function with 2 methods)

julia&gt; @expression(model, log(f(x)))
log(f(x))</code></pre><h3 id="Gradients-and-Hessians"><a class="docs-heading-anchor" href="#Gradients-and-Hessians">Gradients and Hessians</a><a id="Gradients-and-Hessians-1"></a><a class="docs-heading-anchor-permalink" href="#Gradients-and-Hessians" title="Permalink"></a></h3><p>By default, JuMP will use automatic differentiation to compute the gradient and Hessian of user-defined operators. If your function is not amenable to the default automatic differentiation, or you can compute analytic derivatives, you may pass additional arguments to <a href="../../api/JuMP/#@operator"><code>@operator</code></a> to compute the first- and second-derivatives.</p><div class="admonition is-success" id="Tip-47a4fdc3a8b4519e"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-47a4fdc3a8b4519e" title="Permalink"></a></header><div class="admonition-body"><p>The tutorial <a href="../../tutorials/nonlinear/operator_ad/#Automatic-differentiation-of-user-defined-operators">Automatic differentiation of user-defined operators</a> has examples of how to use third-party Julia packages to compute automatic derivatives.</p></div></div><h4 id="Univariate-functions"><a class="docs-heading-anchor" href="#Univariate-functions">Univariate functions</a><a id="Univariate-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-functions" title="Permalink"></a></h4><p>For univariate functions, a gradient function <code>∇f</code> returns a number that represents the first-order derivative. You may, in addition, pass a third function which returns a number representing the second-order derivative:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JuMP</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x) = x^2</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ∇f(x) = 2x</code><code class="nohighlight hljs ansi" style="display:block;">∇f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ∇²f(x) = 2</code><code class="nohighlight hljs ansi" style="display:block;">∇²f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model = Model();</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @operator(model, op_f, 1, f, ∇f, ∇²f)  # Providing ∇²f is optional</code><code class="nohighlight hljs ansi" style="display:block;">NonlinearOperator(f, :op_f)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variable(model, x)</code><code class="nohighlight hljs ansi" style="display:block;">x</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @objective(model, Min, op_f(x))</code><code class="nohighlight hljs ansi" style="display:block;">op_f(x)</code></pre><h4 id="Multivariate-functions"><a class="docs-heading-anchor" href="#Multivariate-functions">Multivariate functions</a><a id="Multivariate-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-functions" title="Permalink"></a></h4><p>For multivariate functions, the gradient function <code>∇f</code> must take an <code>AbstractVector</code> as the first argument that is filled in-place. The Hessian function, <code>∇²f</code>, must take an <code>AbstractMatrix</code> as the first argument, the lower-triangular of which is filled in-place:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JuMP</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x...) = (1 - x[1])^2 + 100 * (x[2] - x[1]^2)^2</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function ∇f(g::AbstractVector{T}, x::T...) where {T}
           g[1] = 400 * x[1]^3 - 400 * x[1] * x[2] + 2 * x[1] - 2
           g[2] = 200 * (x[2] - x[1]^2)
           return
       end</code><code class="nohighlight hljs ansi" style="display:block;">∇f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function ∇²f(H::AbstractMatrix{T}, x::T...) where {T}
           H[1, 1] = 1200 * x[1]^2 - 400 * x[2] + 2
           # H[1, 2] = -400 * x[1]  &lt;-- Not needed. Fill the lower-triangular only.
           H[2, 1] = -400 * x[1]
           H[2, 2] = 200.0
           return
       end</code><code class="nohighlight hljs ansi" style="display:block;">∇²f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model = Model();</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @operator(model, rosenbrock, 2, f, ∇f, ∇²f)  # Providing ∇²f is optional</code><code class="nohighlight hljs ansi" style="display:block;">NonlinearOperator(f, :rosenbrock)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variable(model, x[1:2])</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{VariableRef}:
 x[1]
 x[2]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @objective(model, Min, rosenbrock(x[1], x[2]))</code><code class="nohighlight hljs ansi" style="display:block;">rosenbrock(x[1], x[2])</code></pre><p>You may assume the Hessian matrix <code>H</code> is initialized with zeros, and because <code>H</code> is symmetric, you need only to fill in the non-zero lower-triangular terms. The matrix type passed in as <code>H</code> depends on the automatic differentiation system, so make sure the first argument to the Hessian function supports an <code>AbstractMatrix</code> (it may be something other than <code>Matrix{Float64}</code>). Moreover, you may assume only that <code>H</code> supports <code>size(H)</code> and <code>setindex!</code>. Finally, the matrix is treated as dense, so the performance will be poor on functions with high-dimensional input.</p><h3 id="User-defined-operators-with-vector-inputs"><a class="docs-heading-anchor" href="#User-defined-operators-with-vector-inputs">User-defined operators with vector inputs</a><a id="User-defined-operators-with-vector-inputs-1"></a><a class="docs-heading-anchor-permalink" href="#User-defined-operators-with-vector-inputs" title="Permalink"></a></h3><p>User-defined operators which take vectors as input arguments (for example, <code>f(x::Vector)</code>) are <em>not</em> supported. Instead, use Julia&#39;s splatting syntax to create a function with scalar arguments. For example, instead of:</p><pre><code class="language-julia hljs">f(x::Vector) = sum(x[i]^i for i in 1:length(x))</code></pre><p>define:</p><pre><code class="language-julia hljs">f(x...) = sum(x[i]^i for i in 1:length(x))</code></pre><p>Another approach is to define the splatted function as an anonymous function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JuMP</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model = Model();</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variable(model, x[1:5])</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{VariableRef}:
 x[1]
 x[2]
 x[3]
 x[4]
 x[5]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x::Vector) = sum(x[i]^i for i in 1:length(x))</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @operator(model, op_f, 5, (x...) -&gt; f(collect(x)))</code><code class="nohighlight hljs ansi" style="display:block;">NonlinearOperator(#6, :op_f)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @objective(model, Min, op_f(x...))</code><code class="nohighlight hljs ansi" style="display:block;">op_f(x[1], x[2], x[3], x[4], x[5])</code></pre><p>If the operator takes several vector inputs, write a function that takes the splatted arguments and reconstructs the required vector inputs:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JuMP</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model = Model();</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variable(model, x[1:2]);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variable(model, y[1:2]);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variable(model, z);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x::Vector, y::Vector, z) = sum((x[i] * y[i])^z for i in 1:2)</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x, y, z)</code><code class="nohighlight hljs ansi" style="display:block;">((x[1]*y[1]) ^ z) + ((x[2]*y[2]) ^ z)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f_splat(args...) = f(collect(args[1:2]), collect(args[3:4]), args[5])</code><code class="nohighlight hljs ansi" style="display:block;">f_splat (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f_splat(x..., y..., z)</code><code class="nohighlight hljs ansi" style="display:block;">((x[1]*y[1]) ^ z) + ((x[2]*y[2]) ^ z)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @operator(model, op_f, 5, f_splat)</code><code class="nohighlight hljs ansi" style="display:block;">NonlinearOperator(f_splat, :op_f)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @objective(model, Min, op_f(x..., y..., z))</code><code class="nohighlight hljs ansi" style="display:block;">op_f(x[1], x[2], y[1], y[2], z)</code></pre><h3 id="Common-mistakes-when-writing-a-user-defined-operator"><a class="docs-heading-anchor" href="#Common-mistakes-when-writing-a-user-defined-operator">Common mistakes when writing a user-defined operator</a><a id="Common-mistakes-when-writing-a-user-defined-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Common-mistakes-when-writing-a-user-defined-operator" title="Permalink"></a></h3><p>JuMP uses <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> to compute the first-order derivatives of user-defined operators. ForwardDiff has a number of limitations that you should be aware of when writing user-defined operators.</p><p>The rest of this section provides debugging advice and explains some common mistakes.</p><div class="admonition is-warning" id="Warning-20f3e65443d16b72"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-20f3e65443d16b72" title="Permalink"></a></header><div class="admonition-body"><p>Get an error like <code>No method matching Float64(::ForwardDiff.Dual)</code>? Read this section.</p></div></div><h4 id="Debugging"><a class="docs-heading-anchor" href="#Debugging">Debugging</a><a id="Debugging-1"></a><a class="docs-heading-anchor-permalink" href="#Debugging" title="Permalink"></a></h4><p>If you add an operator that does not support ForwardDiff, a long error message will be printed. You can review the stacktrace for more information, but it can often be hard to understand why and where your function is failing.</p><p>It may be helpful to debug the operator outside of JuMP as follows.</p><p>If the operator is univariate, do:</p><pre><code class="language-julia-repl hljs">julia&gt; import ForwardDiff

julia&gt; my_operator(a) = a^2
my_operator (generic function with 1 method)

julia&gt; ForwardDiff.derivative(my_operator, 1.0)
2.0</code></pre><p>If the operator is multivariate, do:</p><pre><code class="language-julia-repl hljs">julia&gt; import ForwardDiff

julia&gt; my_operator(a, b) = a^2 + b^2
my_operator (generic function with 1 method)

julia&gt; ForwardDiff.gradient(x -&gt; my_operator(x...), [1.0, 2.0])
2-element Vector{Float64}:
 2.0
 4.0</code></pre><p>Note that even though the operator takes the splatted arguments, <code>ForwardDiff.gradient</code> requires a vector as input.</p><h4 id="Operator-calls-something-unsupported-by-ForwardDiff"><a class="docs-heading-anchor" href="#Operator-calls-something-unsupported-by-ForwardDiff">Operator calls something unsupported by ForwardDiff</a><a id="Operator-calls-something-unsupported-by-ForwardDiff-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-calls-something-unsupported-by-ForwardDiff" title="Permalink"></a></h4><p>ForwardDiff works by overloading many Julia functions for a special type <code>ForwardDiff.Dual &lt;: Real</code>. If your operator attempts to call a function for which an overload has not been defined, a <code>MethodError</code> will be thrown.</p><p>For example, your operator cannot call external C functions, or be the optimal objective value of a JuMP model.</p><pre><code class="language-julia-repl hljs">julia&gt; import ForwardDiff

julia&gt; my_operator_bad(x) = @ccall sqrt(x::Cdouble)::Cdouble
my_operator_bad (generic function with 1 method)

julia&gt; ForwardDiff.derivative(my_operator_bad, 1.0)
ERROR: MethodError: no method matching Float64(::ForwardDiff.Dual{ForwardDiff.Tag{typeof(my_operator_bad), Float64}, Float64, 1})
[...]</code></pre><p>Unfortunately, the list of calls supported by ForwardDiff is too large to enumerate what is an isn&#39;t allowed, so the best advice is to try and see if it works.</p><h4 id="Operator-does-not-accept-splatted-input"><a class="docs-heading-anchor" href="#Operator-does-not-accept-splatted-input">Operator does not accept splatted input</a><a id="Operator-does-not-accept-splatted-input-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-does-not-accept-splatted-input" title="Permalink"></a></h4><p>The operator takes <code>f(x::Vector)</code> as input, instead of the splatted <code>f(x...)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; import ForwardDiff

julia&gt; my_operator_bad(x::Vector) = sum(x[i]^2 for i in eachindex(x))
my_operator_bad (generic function with 1 method)

julia&gt; my_operator_good(x...) = sum(x[i]^2 for i in eachindex(x))
my_operator_good (generic function with 1 method)

julia&gt; ForwardDiff.gradient(x -&gt; my_operator_bad(x...), [1.0, 2.0])
ERROR: MethodError: no method matching my_operator_bad(::ForwardDiff.Dual{ForwardDiff.Tag{var&quot;#5#6&quot;, Float64}, Float64, 2}, ::ForwardDiff.Dual{ForwardDiff.Tag{var&quot;#5#6&quot;, Float64}, Float64, 2})
[...]

julia&gt; ForwardDiff.gradient(x -&gt; my_operator_good(x...), [1.0, 2.0])
2-element Vector{Float64}:
 2.0
 4.0</code></pre><h4 id="Operator-assumes-Float64-as-input"><a class="docs-heading-anchor" href="#Operator-assumes-Float64-as-input">Operator assumes <code>Float64</code> as input</a><a id="Operator-assumes-Float64-as-input-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-assumes-Float64-as-input" title="Permalink"></a></h4><p>The operator assumes <code>Float64</code> will be passed as input, but it must work for any generic <code>Real</code> type.</p><pre><code class="language-julia-repl hljs">julia&gt; import ForwardDiff

julia&gt; my_operator_bad(x::Float64...) = sum(x[i]^2 for i in eachindex(x))
my_operator_bad (generic function with 1 method)

julia&gt; my_operator_good(x::Real...) = sum(x[i]^2 for i in eachindex(x))
my_operator_good (generic function with 1 method)

julia&gt; ForwardDiff.gradient(x -&gt; my_operator_bad(x...), [1.0, 2.0])
ERROR: MethodError: no method matching my_operator_bad(::ForwardDiff.Dual{ForwardDiff.Tag{var&quot;#5#6&quot;, Float64}, Float64, 2}, ::ForwardDiff.Dual{ForwardDiff.Tag{var&quot;#5#6&quot;, Float64}, Float64, 2})
[...]

julia&gt; ForwardDiff.gradient(x -&gt; my_operator_good(x...), [1.0, 2.0])
2-element Vector{Float64}:
 2.0
 4.0</code></pre><h4 id="Operator-allocates-Float64-storage"><a class="docs-heading-anchor" href="#Operator-allocates-Float64-storage">Operator allocates <code>Float64</code> storage</a><a id="Operator-allocates-Float64-storage-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-allocates-Float64-storage" title="Permalink"></a></h4><p>The operator allocates temporary storage using <code>zeros(3)</code> or similar. This defaults to <code>Float64</code>, so use <code>zeros(T, 3)</code> instead.</p><pre><code class="language-julia hljs">julia&gt; import ForwardDiff

julia&gt; function my_operator_bad(x::Real...)
           # This line is problematic. zeros(n) is short for zeros(Float64, n)
           y = zeros(length(x))
           for i in eachindex(x)
               y[i] = x[i]^2
           end
           return sum(y)
       end
my_operator_bad (generic function with 1 method)

julia&gt; function my_operator_good(x::T...) where {T&lt;:Real}
           y = zeros(T, length(x))
           for i in eachindex(x)
               y[i] = x[i]^2
           end
           return sum(y)
       end
my_operator_good (generic function with 1 method)

julia&gt; ForwardDiff.gradient(x -&gt; my_operator_bad(x...), [1.0, 2.0])
ERROR: MethodError: no method matching Float64(::ForwardDiff.Dual{ForwardDiff.Tag{var&quot;#1#2&quot;, Float64}, Float64, 2})
[...]

julia&gt; ForwardDiff.gradient(x -&gt; my_operator_good(x...), [1.0, 2.0])
2-element Vector{Float64}:
 2.0
 4.0</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../complex/">« Complex number support</a><a class="docs-footer-nextpage" href="../nlp/">Nonlinear Modeling (Legacy) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 18 July 2025 22:57">Friday 18 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
