<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Constraints · JuMP</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><a href="../index.html"><img alt="JuMP logo" class="logo" src="../assets/logo.png"/></a><h1>JuMP</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search/" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../installation/">Installation Guide</a></li><li><a class="toctext" href="../quickstart/">Quick Start Guide</a></li><li><a class="toctext" href="../concepts/">Concepts</a></li><li><a class="toctext" href="../variables/">Variables</a></li><li><a class="toctext" href="../expressions/">Expressions</a></li><li><a class="toctext" href="../objective/">Objective</a></li><li class="current"><a class="toctext" href="">Constraints</a><ul class="internal"><li><a class="toctext" href="#The-@constraint-macro-1">The <code>@constraint</code> macro</a></li><li><a class="toctext" href="#constraint_duality-1">Duality</a></li><li><a class="toctext" href="#Constraint-containers-1">Constraint containers</a></li><li><a class="toctext" href="#Vectorized-constraints-1">Vectorized constraints</a></li><li><a class="toctext" href="#Constraints-on-a-single-variable-1">Constraints on a single variable</a></li><li><a class="toctext" href="#Constraints-on-a-collection-of-variables-1">Constraints on a collection of variables</a></li><li><a class="toctext" href="#Quadratic-constraints-1">Quadratic constraints</a></li><li><a class="toctext" href="#Semidefinite-constraints-1">Semidefinite constraints</a></li><li><a class="toctext" href="#Constraint-modifications-1">Constraint modifications</a></li><li><a class="toctext" href="#Constraint-deletion-1">Constraint deletion</a></li><li><a class="toctext" href="#Function-Set-pairs-1">Function-Set pairs</a></li><li><a class="toctext" href="#Reference-1">Reference</a></li><li><a class="toctext" href="#Constructing-constraints-without-adding-them-to-the-model-1">Constructing constraints without adding them to the model</a></li></ul></li><li><a class="toctext" href="../containers/">Containers</a></li><li><a class="toctext" href="../names/">Names</a></li><li><a class="toctext" href="../solvers/">Solvers</a></li><li><a class="toctext" href="../nlp/">Nonlinear Modeling</a></li><li><a class="toctext" href="../style/">Style Guide</a></li><li><a class="toctext" href="../extensions/">Extensions</a></li><li><a class="toctext" href="../updating/">Updating Guide</a></li><li><a class="toctext" href="../howdoi/">How do I ...? (FAQ)</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="">Constraints</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/JuMP.jl/blob/master/docs/src/constraints.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Constraints</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Constraints-1" id="Constraints-1">Constraints</a></h1><p>This page explains how to write various types of constraints in JuMP. Before reading further, please make sure you are familiar with JuMP models, and JuMP <a href="../variables/#Variables-1">Variables</a>. If you want to add nonlinear constraints, read <a href="../nlp/#Nonlinear-Modeling-1">Nonlinear Modeling</a> instead.</p><p>JuMP is based on the MathOptInterface API. Because of this, JuMP thinks of a constraint as the restriction that the output of a <em>function</em> belongs to a <em>set</em>. For example, instead of representing a constraint <span>$a^\top x \le b$</span> as a <em>less-than-or-equal-to</em> constraint, JuMP models this as the <em>scalar affine</em> function <span>$a^\top x$</span> belonging to the <em>less-than</em> set <span>$(-\infty, b]$</span>. Thus, instead of a <em>less-than-or-equal-to</em> constraint, we consider this constraint to be a <em>scalar affine -in- less than</em> constraint. More generally, we use the shorthand <em>function-in-set</em> to refer to constraints composed of different types of functions and sets. In the rest of this page, we will introduce the different types of functions and sets that JuMP knows about as needed. You can read more details about this <em>function-in-set</em> concept in the MathOptInterface documentation.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Throughout this page (and these docs), we use <code>MOI</code> as a shorthand for the <code>MathOptInterface</code> module. This can be created by including the following lines after <code>using JuMP</code> in your code.</p><pre><code class="language-julia">using MathOptInterface
const MOI = MathOptInterface</code></pre></div></div><h2><a class="nav-anchor" href="#The-@constraint-macro-1" id="The-@constraint-macro-1">The <code>@constraint</code> macro</a></h2><p>Constraints are added to a JuMP model using the <a href="#JuMP.@constraint"><code>@constraint</code></a> macro. It is similar to the <a href="../variables/#JuMP.@variable"><code>@variable</code></a> macro. Here is an example of how to add the constraint <span>$2x \le 1$</span> to a JuMP model:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, con, 2x &lt;= 1)
con : 2 x &lt;= 1.0</code></pre><p>Wasn't that easy! Let's unpack what happened, because just like <a href="../variables/#JuMP.@variable"><code>@variable</code></a> there are a few subtle things going on.</p><ol><li>The mathematical constraint <span>$2x \le 1$</span> was added to the model.</li><li>A Julia variable called <code>con</code> was created that is a reference to the constraint.</li><li>This Julia variable was stored in <code>model</code> and can be accessed by <code>model[:con]</code>.</li><li>JuMP set the name (the one that is shown when printing) of the constraint to <code>"con"</code>.</li></ol><p>Just like the Julia variables created in <a href="../variables/#JuMP.@variable"><code>@variable</code></a>, <code>con</code> can be bound to a different value. For example:</p><pre><code class="language-julia-repl">julia&gt; con
con : 2 x &lt;= 1.0

julia&gt; con = 1
1

julia&gt; con
1</code></pre><p>However, the reference can be retrieved by querying the model using the symbolic name:</p><pre><code class="language-julia-repl">julia&gt; con = model[:con]
con : 2 x &lt;= 1.0

julia&gt; con
con : 2 x &lt;= 1.0</code></pre><p>Because the named variables and constraints are stored in the same namespace, creating a constraint with the same name as a variable or an existing constraint will result in an error. To overcome this limitation, it is possible to create anonymous constraints, just like it is possible to create <a href="../variables/#Anonymous-JuMP-variables-1">Anonymous JuMP variables</a>. This is done by dropping the second argument to <a href="#JuMP.@constraint"><code>@constraint</code></a>:</p><pre><code class="language-julia-repl">julia&gt; con = @constraint(model, 2x &lt;= 1)
2 x &lt;= 1.0</code></pre><p>It is also possible use different comparison operators (e.g., <code>&gt;=</code> and <code>==</code>) to create the following types of constraints:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, 2x &gt;= 1)
2 x &gt;= 1.0

julia&gt; @constraint(model, 2x == 1)
2 x = 1.0

julia&gt; @constraint(model, 1 &lt;= 2x &lt;= 3)
2 x ∈ [1.0, 3.0]</code></pre><p>Note that JuMP normalizes the constraints given by the user by moving all of the terms containing variables to the left-hand side, and all of the constant terms to the right-hand side. Thus, we get:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, 2x + 1 &lt;= 4x + 4)
-2 x &lt;= 3.0</code></pre><h2><a class="nav-anchor" href="#constraint_duality-1" id="constraint_duality-1">Duality</a></h2><p>JuMP adopts the notion of <a href="http://www.juliaopt.org/MathOptInterface.jl/v0.6.2/apimanual.html#Duals-1">conic duality from MathOptInterface</a>. For linear programs, a feasible dual on a <code>&gt;=</code> constraint is nonnegative and a feasible dual on a <code>&lt;=</code> constraint is nonpositive. If the constraint is an equality constraint, it depends on which direction is binding.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>JuMP's definition of duality is independent of the objective sense. That is, the sign of feasible duals associated with a constraint depends on the direction of the constraint and not whether the problem is maximization or minimization. <strong>This is different to linear programming duality in some common textbooks.</strong></p></div></div><p>The dual value associated with a constraint in the most recent solution can be accessed using the <a href="#JuMP.dual"><code>JuMP.dual</code></a> function. You can use the <a href="#JuMP.has_duals"><code>JuMP.has_duals</code></a> function to check whether the model has a dual solution available to query. For example:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @constraint(model, con, x &lt;= 1)
con : x &lt;= 1.0

julia&gt; JuMP.has_duals(model)
false</code></pre><pre><code class="language-julia-repl">julia&gt; @objective(model, Min, -2x)
-2 x

julia&gt; JuMP.optimize!(model)

julia&gt; JuMP.has_duals(model)
true

julia&gt; JuMP.dual(con)
-2.0

julia&gt; @objective(model, Max, 2x)
2 x

julia&gt; JuMP.optimize!(model)

julia&gt; JuMP.dual(con)
-2.0</code></pre><p>To help users who may be less familiar with conic duality, JuMP provides the <a href="#JuMP.shadow_price"><code>JuMP.shadow_price</code></a> function which returns a value that can be interpreted as the improvement in the objective in response to an infinitesimal relaxation (on the scale of one unit) in the right-hand side of the constraint. <a href="#JuMP.shadow_price"><code>JuMP.shadow_price</code></a> can only be used on linear constraints with a <code>&lt;=</code>, <code>&gt;=</code>, or <code>==</code> comparison operator.</p><p>In the example above, <code>JuMP.dual(con)</code> returned <code>-2.0</code> regardless of the optimization sense. However, in the second case when the optimization sense is <code>Max</code>, <a href="#JuMP.shadow_price"><code>JuMP.shadow_price</code></a> returns:</p><pre><code class="language-julia-repl">julia&gt; JuMP.shadow_price(con)
2.0</code></pre><p>To query the dual variables associated a variable bound, first obtain a constraint reference using one of <a href="#JuMP.UpperBoundRef"><code>JuMP.UpperBoundRef</code></a>, <a href="#JuMP.LowerBoundRef"><code>JuMP.LowerBoundRef</code></a>, or <a href="#JuMP.FixRef"><code>JuMP.FixRef</code></a>, and then call <a href="#JuMP.dual"><code>JuMP.dual</code></a> on the returned constraint reference. Note that in linear programming, the duals on variable bounds are also called the reduced costs (although the sign might differ from the one you expect).</p><h2><a class="nav-anchor" href="#Constraint-containers-1" id="Constraint-containers-1">Constraint containers</a></h2><p>So far, we've added constraints one-by-one. However, just like <a href="../variables/#Variable-containers-1">Variable containers</a>, JuMP provides a mechanism for building groups of constraints compactly. References to these groups of constraints are returned in <em>containers</em>. Three types of constraint containers are supported: <code>Array</code>s, <code>DenseAxisArray</code>s, and <code>SparseAxisArray</code>s. We explain each of these in the following.</p><h3><a class="nav-anchor" href="#constraint_arrays-1" id="constraint_arrays-1">Arrays</a></h3><p>One way of adding a group of constraints compactly is the following:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, con[i = 1:3], i * x &lt;= i + 1)
3-element Array{ConstraintRef{Model,C,Shape} where Shape&lt;:JuMP.AbstractShape where C,1}:
 con[1] : x &lt;= 2.0
 con[2] : 2 x &lt;= 3.0
 con[3] : 3 x &lt;= 4.0</code></pre><p>JuMP returns references to the three constraints in an <code>Array</code> that is bound to the Julia variable <code>con</code>. This array can be accessed and sliced just like a normal Julia array:</p><pre><code class="language-julia-repl">julia&gt; con[1]
con[1] : x &lt;= 2.0

julia&gt; con[2:3]
2-element Array{ConstraintRef{Model,C,Shape} where Shape&lt;:JuMP.AbstractShape where C,1}:
 con[2] : 2 x &lt;= 3.0
 con[3] : 3 x &lt;= 4.0</code></pre><p>Anonymous containers can also be constructed by dropping the name (e.g. <code>con</code>) before the square brackets:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, [i = 1:2], i * x &lt;= i + 1)
2-element Array{ConstraintRef{Model,C,Shape} where Shape&lt;:JuMP.AbstractShape where C,1}:
 x &lt;= 2.0
 2 x &lt;= 3.0</code></pre><p>Just like <a href="../variables/#JuMP.@variable"><code>@variable</code></a>, JuMP will form an <code>Array</code> of constraints when it can determine at parse time that the indices are one-based integer ranges. Therefore <code>con[1:b]</code> will create an <code>Array</code>, but <code>con[a:b]</code> will not. A special case is <code>con[Base.OneTo(n)]</code> which will produce an <code>Array</code>. If JuMP cannot determine that the indices are one-based integer ranges (e.g., in the case of <code>con[a:b]</code>), JuMP will create a <code>DenseAxisArray</code> instead.</p><h3><a class="nav-anchor" href="#DenseAxisArrays-1" id="DenseAxisArrays-1">DenseAxisArrays</a></h3><p>The syntax for constructing a <code>DenseAxisArray</code> of constraints is very similar to the <a href="../variables/#variable_jump_arrays-1">syntax for constructing</a> a DenseAxisArray of variables.</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, con[i = 1:2, j = 2:3], i * x &lt;= j + 1)
2-dimensional DenseAxisArray{ConstraintRef{Model,C,Shape} where Shape&lt;:JuMP.AbstractShape where C,2,...} with index sets:
    Dimension 1, 1:2
    Dimension 2, 2:3
And data, a 2×2 Array{ConstraintRef{Model,C,Shape} where Shape&lt;:JuMP.AbstractShape where C,2}:
 con[1,2] : x &lt;= 3.0    con[1,3] : x &lt;= 4.0
 con[2,2] : 2 x &lt;= 3.0  con[2,3] : 2 x &lt;= 4.0</code></pre><h3><a class="nav-anchor" href="#Dictionaries-1" id="Dictionaries-1">Dictionaries</a></h3><p>The syntax for constructing a dictionary of constraints is very similar to the <a href="../variables/#variable_sparseaxisarrays-1">syntax for constructing</a> a dictionary of variables.</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, con[i = 1:2, j = 1:2; i != j], i * x &lt;= j + 1)
JuMP.Containers.SparseAxisArray{ConstraintRef{Model,C,Shape} where Shape&lt;:JuMP.AbstractShape where C,2,Tuple{Any,Any}} with 2 entries:
  [1, 2]  =  con[1,2] : x &lt;= 3.0
  [2, 1]  =  con[2,1] : 2 x &lt;= 2.0</code></pre><h3><a class="nav-anchor" href="#Forcing-the-container-type-1" id="Forcing-the-container-type-1">Forcing the container type</a></h3><p>When creating a container of constraints, JuMP will attempt to choose the tightest container type that can store the constraints. However, because this happens at parse time, it does not always make the best choice. Just like in <a href="../variables/#JuMP.@variable"><code>@variable</code></a>, we can force the type of container using the <code>container</code> keyword. For syntax and the reason behind this, take a look at the <a href="../variables/#variable_forcing-1">variable docs</a>.</p><h2><a class="nav-anchor" href="#Vectorized-constraints-1" id="Vectorized-constraints-1">Vectorized constraints</a></h2><p>We can also add constraints to JuMP using vectorized linear algebra. For example:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x[i=1:2])
2-element Array{VariableRef,1}:
 x[1]
 x[2]

julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; b = [5, 6]
2-element Array{Int64,1}:
 5
 6

julia&gt; @constraint(model, con, A * x .== b)
2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}},JuMP.ScalarShape},1}:
 x[1] + 2 x[2] == 5.0
 3 x[1] + 4 x[2] == 6.0</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Make sure to use <a href="https://docs.julialang.org/en/v1/manual/functions/index.html#man-vectorized-1">Julia's dot syntax</a> in front of the comparison operators (e.g. <code>.==</code>, <code>.&gt;=</code>, and <code>.&lt;=</code>). If you use a comparison without the dot, an error will be thrown.</p></div></div><p>Instead of adding an array of <code>ScalarAffineFunction-in-EqualTo</code> constraints, we can instead construct a <code>VectorAffineFunction-in-Nonnegatives</code> constraint as follows:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, A * x - b in MOI.Nonnegatives(2))
[x[1] + 2 x[2] - 5, 3 x[1] + 4 x[2] - 6] in MathOptInterface.Nonnegatives(2)</code></pre><p>In addition to the <code>Nonnegatives</code> set, MathOptInterface defines a number of other vector-valued sets such as <code>Nonpositives</code>. See the <a href="http://www.juliaopt.org/MathOptInterface.jl/v0.6.2/apireference/#Sets-1">MathOptInterface documentation</a> for more information.</p><p>Note also that for the first time we have used an explicit <em>function-in-set</em> description of the constraint. Read more about this below in the <a href="#Function-Set-pairs-1">Function-Set pairs</a> section of this documentation.</p><h2><a class="nav-anchor" href="#Constraints-on-a-single-variable-1" id="Constraints-on-a-single-variable-1">Constraints on a single variable</a></h2><p>In <a href="../variables/#Variables-1">Variables</a>, we saw how to modify the variable bounds, as well as add binary and integer restrictions to the domain of each variable. This can also be achieved using the <a href="#JuMP.@constraint"><code>@constraint</code></a> macro. For example, <code>MOI.ZeroOne()</code> restricts the domain to ``{0, 1}:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, x in MOI.ZeroOne())
x binary</code></pre><p>and <code>MOI.Integer()</code> restricts to the domain to the integers <span>$\mathbb{Z}$</span>:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, x in MOI.Integer())
x integer</code></pre><p>JuMP also supports modeling semi-continuous variables, whose domain is <span>$\{0\} ∪ [l, u]$</span>, using the <code>MOI.Semicontinuous</code> set:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, x in MOI.Semicontinuous(1.5, 3.5))
x in MathOptInterface.Semicontinuous{Float64}(1.5, 3.5)</code></pre><p>as well as semi-integer variables, whose domain is <span>${0} ∪ {l, l+1, \dots, u}$</span>, using the <code>MOI.Semiinteger</code> set:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, x in MOI.Semiinteger(1.0, 3.0))
x in MathOptInterface.Semiinteger{Float64}(1.0, 3.0)</code></pre><h2><a class="nav-anchor" href="#Constraints-on-a-collection-of-variables-1" id="Constraints-on-a-collection-of-variables-1">Constraints on a collection of variables</a></h2><p>In addition to constraining the domain of a single variable, JuMP supports placing constraints of a subset of the variables. We already saw an example of this in the <a href="#Quadratic-constraints-1">Quadratic constraints</a> section when we constrained a vector of variables to belong to the second order cone.</p><p>In a special ordered set of type I (often denoted SOS-I), at most one variable can take a non-zero value. We can construct SOS-I constraints using the <code>MOI.SOS1</code> set:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x[1:3])
3-element Array{VariableRef,1}:
 x[1]
 x[2]
 x[3]

julia&gt; @constraint(model, x in MOI.SOS1([1.0, 2.0, 3.0]))
[x[1], x[2], x[3]] in MathOptInterface.SOS1{Float64}([1.0, 2.0, 3.0])</code></pre><p>Note that we have to pass <code>MOI.SOS1</code> a <em>weight</em> vector. This vector implies an ordering on the variables. If the decision variables are related and have a physical ordering (e.g., they correspond to the size of a factory to be built, and the SOS-I constraint enforces that only one factory can be built), then the weight vector, although not used directly in the constraint, can help the solver make better decision in the solution process.</p><p>This ordering is more important in a special ordered set of type II (SOS-II), in which at most two values can be non-zero, and if there are two non-zeros, they must be consecutive according to the ordering. For example, in the following constraint, the possible non-zero pairs are (<code>x[1]</code> and <code>x[3]</code>) and (<code>x[2]</code> and <code>x[3]</code>):</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, x in MOI.SOS2([3.0, 1.0, 2.0]))
[x[1], x[2], x[3]] in MathOptInterface.SOS2{Float64}([3.0, 1.0, 2.0])</code></pre><h2><a class="nav-anchor" href="#Quadratic-constraints-1" id="Quadratic-constraints-1">Quadratic constraints</a></h2><p>In addition to affine functions, JuMP also supports constraints with quadratic terms. (For more general nonlinear functions, see <a href="../nlp/#Nonlinear-Modeling-1">Nonlinear Modeling</a>.) For example:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x[i=1:2])
2-element Array{VariableRef,1}:
 x[1]
 x[2]

julia&gt; @variable(model, t &gt;= 0)
t

julia&gt; @constraint(model, x[1]^2 + x[2]^2 &lt;= t^2)
x[1]² + x[2]² - t² &lt;= 0.0</code></pre><p>Note that this quadratic constraint (including the lower bound on <code>t</code>) is equivalent to a second order cone constraint where <code>||x[1]^2 + x[2]^2||\_2 ≤ t</code> and <code>t ≥ 0</code>. Instead of writing out the quadratic expansion, we can pass JuMP the constraint in <em>function</em>-in-<em>set</em> form. To do so, we need to define the function and the set.</p><p>The function is a vector of variables:</p><pre><code class="language-julia-repl">julia&gt; [t, x[1], x[2]]
3-element Array{VariableRef,1}:
 t
 x[1]
 x[2]</code></pre><p>Note that the variable <code>t</code> comes first, followed by the <code>x</code> arguments. The set is an instance of <a href="#JuMP.SecondOrderCone"><code>JuMP.SecondOrderCone</code></a>: <code>JuMP.SecondOrderCone()</code>. Thus, we can add the second order cone constraint as follows:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, [t, x[1], x[2]] in JuMP.SecondOrderCone())
[t, x[1], x[2]] in MathOptInterface.SecondOrderCone(3)</code></pre><p>JuMP also supports the <a href="#JuMP.RotatedSecondOrderCone"><code>RotatedSecondOrderCone</code></a> which requires the addition of a perspective variable <code>u</code>. The rotated second order cone constraints the variables <code>t</code>, <code>u</code>, and <code>x</code> such that: <code>||x[1]^2 + x[2]^2||\_2 ≤ t × u</code> and <code>t, u ≥ 0</code>. It can be added as follows:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, u)
u

julia&gt; @constraint(model, [t, u, x[1], x[2]] in JuMP.RotatedSecondOrderCone())
[t, u, x[1], x[2]] in MathOptInterface.RotatedSecondOrderCone(4)</code></pre><p>In addition to the second order cone and rotated second order cone, MathOptInterface defines a number of other conic sets such as the exponential and power cones. See the <a href="http://www.juliaopt.org/MathOptInterface.jl/v0.6.2/apireference/#Sets-1">MathOptInterface documentation</a> for more information.</p><h2><a class="nav-anchor" href="#Semidefinite-constraints-1" id="Semidefinite-constraints-1">Semidefinite constraints</a></h2><p>TODO: discuss [<code>@SDconstraint</code>] and [<code>PSDCone</code>].</p><h2><a class="nav-anchor" href="#Constraint-modifications-1" id="Constraint-modifications-1">Constraint modifications</a></h2><p>A common paradigm, especially in linear programming, is to repeatedly solve a model with different coefficients.</p><h3><a class="nav-anchor" href="#Modifying-a-constant-term-1" id="Modifying-a-constant-term-1">Modifying a constant term</a></h3><p>Most often, modifications involve changing the "right-hand side" of a linear constraint. This presents a challenge for JuMP because it leads to ambiguities. For example, what is the right-hand side term of <code>@constraint(model, 2x + 1 &lt;= x - 3)</code>? This applies more generally to any constant term in a function appearing in the objective or a constraint.</p><p>To avoid these ambiguities, JuMP includes the ability to <em>fix</em> variables to a value using the <a href="#JuMP.fix"><code>JuMP.fix</code></a> function. Fixing a variable sets its lower and upper bound to the same value. Thus, changes in a constant term can be simulated by adding a dummy variable and fixing it to different values. Here is an example:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, const_term)
const_term

julia&gt; @constraint(model, con, 2x &lt;= const_term)
con : 2 x - const_term &lt;= 0.0

julia&gt; JuMP.fix(const_term, 1.0)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Even though <code>const_term</code> is fixed, it is still a decision variable. Thus, <code>const_term * x</code> is bilinear.</p></div></div><h3><a class="nav-anchor" href="#Modifying-a-variable-coefficient-1" id="Modifying-a-variable-coefficient-1">Modifying a variable coefficient</a></h3><p>It is also possible to modify the scalar coefficients (but notably <em>not</em> the quadratic coefficients) using the <a href="#JuMP.set_coefficient"><code>JuMP.set_coefficient</code></a> function. Here is an example:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, con, 2x &lt;= 1)
con : 2 x &lt;= 1.0

julia&gt; JuMP.set_coefficient(con, x, 3)

julia&gt; con
con : 3 x &lt;= 1.0</code></pre><h2><a class="nav-anchor" href="#Constraint-deletion-1" id="Constraint-deletion-1">Constraint deletion</a></h2><p>Constraints can be deleted from a model using <a href="#JuMP.delete"><code>JuMP.delete</code></a>. Just like variable references, it is possible to check if a constraint reference is valid using <a href="#JuMP.is_valid"><code>JuMP.is_valid</code></a>. Here is an example of deleting a constraint:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, con, 2x &lt;= 1)
con : 2 x &lt;= 1.0

julia&gt; JuMP.is_valid(model, con)
true

julia&gt; JuMP.delete(model, con)

julia&gt; JuMP.is_valid(model, con)
false</code></pre><h2><a class="nav-anchor" href="#Function-Set-pairs-1" id="Function-Set-pairs-1">Function-Set pairs</a></h2><p>DRAFT: Describe how constraints are represented (link to MOI docs). Constraints are very similar to variables in (1) how names work (2) how attributes work, and (3) the macro syntax for constructing them. They're a bit different because they're parameterized by function-set type. Describe constraints vs. <code>ConstraintRefs</code>. Describe <code>JuMP.constraint_object</code>. How to delete constraints. How to modify constraints by setting attributes and <code>MOI.modifyconstraint!</code>. Describe semidefinite constraints and symmetry handling. Refer to NLP docs for nonlinear constraints.</p><h2><a class="nav-anchor" href="#Reference-1" id="Reference-1">Reference</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.@constraint" id="JuMP.@constraint"><code>JuMP.@constraint</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@constraint(m::Model, expr)</code></pre><p>Add a constraint described by the expression <code>expr</code>.</p><pre><code class="language-none">@constraint(m::Model, ref[i=..., j=..., ...], expr)</code></pre><p>Add a group of constraints described by the expression <code>expr</code> parametrized by <code>i</code>, <code>j</code>, ...</p><p>The expression <code>expr</code> can either be</p><ul><li>of the form <code>func in set</code> constraining the function <code>func</code> to belong to the set <code>set</code> which is either a <a href="http://www.juliaopt.org/MathOptInterface.jl/v0.6.2/apireference.html#Sets-1"><code>MathOptInterface.AbstractSet</code></a> or one of the JuMP shortcuts <a href="#JuMP.SecondOrderCone"><code>SecondOrderCone</code></a>, <a href="#JuMP.RotatedSecondOrderCone"><code>RotatedSecondOrderCone</code></a> and <a href="#JuMP.PSDCone"><code>PSDCone</code></a>, e.g. <code>@constraint(model, [1, x-1, y-2] in SecondOrderCone())</code> constrains the norm of <code>[x-1, y-2]</code> be less than 1;</li><li>of the form <code>a sign b</code>, where <code>sign</code> is one of <code>==</code>, <code>≥</code>, <code>&gt;=</code>, <code>≤</code> and <code>&lt;=</code> building the single constraint enforcing the comparison to hold for the expression <code>a</code> and <code>b</code>, e.g. <code>@constraint(m, x^2 + y^2 == 1)</code> constrains <code>x</code> and <code>y</code> to lie on the unit circle;</li><li>of the form <code>a ≤ b ≤ c</code> or <code>a ≥ b ≥ c</code> (where <code>≤</code> and <code>&lt;=</code> (resp. <code>≥</code> and <code>&gt;=</code>) can be used interchangeably) constraining the paired the expression <code>b</code> to lie between <code>a</code> and <code>c</code>;</li><li>of the forms <code>@constraint(m, a .sign b)</code> or <code>@constraint(m, a .sign b .sign c)</code> which broadcast the constraint creation to each element of the vectors.</li></ul><p><strong>Note for extending the constraint macro</strong></p><p>Each constraint will be created using <code>add_constraint(m, build_constraint(_error, func, set))</code> where</p><ul><li><code>_error</code> is an error function showing the constraint call in addition to the error message given as argument,</li><li><code>func</code> is the expression that is constrained</li><li>and <code>set</code> is the set in which it is constrained to belong.</li></ul><p>For <code>expr</code> of the first type (i.e. <code>@constraint(m, func in set)</code>), <code>func</code> and <code>set</code> are passed unchanged to <code>build_constraint</code> but for the other types, they are determined from the expressions and signs. For instance, <code>@constraint(m, x^2 + y^2 == 1)</code> is transformed into <code>add_constraint(m, build_constraint(_error, x^2 + y^2, MOI.EqualTo(1.0)))</code>.</p><p>To extend JuMP to accept new constraints of this form, it is necessary to add the corresponding methods to <code>build_constraint</code>. Note that this will likely mean that either <code>func</code> or <code>set</code> will be some custom type, rather than e.g. a <code>Symbol</code>, since we will likely want to dispatch on the type of the function or set appearing in the constraint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.@SDconstraint" id="JuMP.@SDconstraint"><code>JuMP.@SDconstraint</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@SDconstraint(model::Model, expr)</code></pre><p>Add a semidefinite constraint described by the expression <code>expr</code>.</p><pre><code class="language-none">@SDconstraint(model::Model, ref[i=..., j=..., ...], expr)</code></pre><p>Add a group of semidefinite constraints described by the expression <code>expr</code> parametrized by <code>i</code>, <code>j</code>, ...</p><p>The expression <code>expr</code> needs to be of the form <code>a sign b</code> where <code>sign</code> is <code>⪰</code>, <code>≥</code>, <code>&gt;=</code>, <code>⪯</code>, <code>≤</code> or <code>&lt;=</code> and <code>a</code> and <code>b</code> are <code>square</code> matrices. It constrains the matrix <code>x = a - b</code> (or <code>x = b - a</code> if the sign is <code>⪯</code>, <code>≤</code> or <code>&lt;=</code>) to be symmetric and positive semidefinite.</p><p>By default, we check numerical symmetry of the matrix <code>x</code>, and if symmetry is violated by some arbitrary amount, we add explicit equality constraints. You can use <code>Symmetric(x) in PSDCone()</code> with the <a href="#JuMP.@constraint"><code>@constraint</code></a> macro to skip these checks if you know the matrix must be symmetric; see <a href="#JuMP.PSDCone"><code>PSDCone</code></a> for more information.</p><p><strong>Examples</strong></p><p>The following constrains the matrix <code>[x-1 2x-2; -3 x-4]</code> to be symmetric and positive semidefinite, that is, it constrains <code>2x-2</code> to be equal to <code>-3</code> and constrains all eigenvalues of the matrix to be nonnegative.</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; a = [x 2x
            0  x];

julia&gt; b = [1 2
            3 4];

julia&gt; @SDconstraint(model, a ⪰ b)
[x - 1, -3, 2 x - 2, x - 4] ∈ MathOptInterface.PositiveSemidefiniteConeSquare(2)</code></pre><p>In the set <code>PositiveSemidefiniteConeSquare(2)</code> in the last output, <code>Square</code> means that the matrix is passed as a square matrix as the corresponding off-diagonal entries need to be constrained to be equal. A similar set <code>PositiveSemidefiniteConeTriangle</code> exists which only uses the upper triangular part of the matrix assuming that it is symmetric, see <a href="#JuMP.PSDCone"><code>PSDCone</code></a> to see how to use it.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.SecondOrderCone" id="JuMP.SecondOrderCone"><code>JuMP.SecondOrderCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SecondOrderCone</code></pre><p>Second order cone object that can be used to constrain the euclidean norm of a vector <code>x</code> to be less than or equal to a nonnegative scalar <code>t</code>. This is a shortcut for the <code>MathOptInterface.SecondOrderCone</code>.</p><p><strong>Examples</strong></p><p>The following constrains <span>$\|(x-1, x-2)\|_2 \le t$</span> and <span>$t \ge 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @variable(model, t)
t

julia&gt; @constraint(model, [t, x-1, x-2] in SecondOrderCone())
[t, x - 1, x - 2] ∈ MathOptInterface.SecondOrderCone(3)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.RotatedSecondOrderCone" id="JuMP.RotatedSecondOrderCone"><code>JuMP.RotatedSecondOrderCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RotatedSecondOrderCone</code></pre><p>Rotated second order cone object that can be used to constrain the square of the euclidean norm of a vector <code>x</code> to be less than or equal to <span>$2tu$</span> where <code>t</code> and <code>u</code> are nonnegative scalars. This is a shortcut for the <code>MathOptInterface.RotatedSecondOrderCone</code>.</p><p><strong>Examples</strong></p><p>The following constrains <span>$\|(x-1, x-2)\|_2 \le 2tx$</span> and <span>$t, x \ge 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @variable(model, t)
t

julia&gt; @constraint(model, [t, x, x-1, x-2] in RotatedSecondOrderCone())
[t, x, x - 1, x - 2] ∈ MathOptInterface.RotatedSecondOrderCone(4)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.PSDCone" id="JuMP.PSDCone"><code>JuMP.PSDCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PSDCone</code></pre><p>Positive semidefinite cone object that can be used to constrain a square matrix to be positive semidefinite in the <a href="#JuMP.@constraint"><code>@constraint</code></a> macro. If the matrix has type <code>Symmetric</code> then the columns vectorization (the vector obtained by concatenating the columns) of its upper triangular part is constrained to belong to the <code>MOI.PositiveSemidefiniteConeTriangle</code> set, otherwise its column vectorization is constrained to belong to the <code>MOI.PositiveSemidefiniteConeSquare</code> set.</p><p><strong>Examples</strong></p><p>Consider the following example:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; a = [ x 2x
            2x  x];

julia&gt; b = [1 2
            2 4];

julia&gt; @SDconstraint(model, a ⪰ b)
[x - 1, 2 x - 2, 2 x - 2, x - 4] ∈ MathOptInterface.PositiveSemidefiniteConeSquare(2)</code></pre><p>We see in the output of the last command that the matrix the vectorization of the matrix is constrained to belong to the <code>PositiveSemidefiniteConeSquare</code>.</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra # For Symmetric

julia&gt; @constraint(model, Symmetric(a - b) in PSDCone())
[x - 1, 2 x - 2, x - 4] ∈ MathOptInterface.PositiveSemidefiniteConeTriangle(2)</code></pre><p>As we see in the output of the last command, the vectorization of only the upper triangular part of the matrix is constrained to belong to the <code>PositiveSemidefiniteConeSquare</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.has_duals" id="JuMP.has_duals"><code>JuMP.has_duals</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_duals(model::Model)</code></pre><p>Return true if the solver has a dual solution available to query, otherwise return false.</p><p>See also <a href="#JuMP.dual"><code>dual</code></a> and <a href="#JuMP.shadow_price"><code>shadow_price</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.dual" id="JuMP.dual"><code>JuMP.dual</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dual(cr::ConstraintRef)</code></pre><p>Get the dual value of this constraint in the result returned by a solver. Use <code>has_dual</code> to check if a result exists before asking for values. See also <a href="#JuMP.shadow_price"><code>shadow_price</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.shadow_price" id="JuMP.shadow_price"><code>JuMP.shadow_price</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">shadow_price(constraint::ConstraintRef)</code></pre><p>The change in the objective from an infinitesimal relaxation of the constraint. This value is computed from <a href="#JuMP.dual"><code>dual</code></a> and can be queried only when <code>has_duals</code> is <code>true</code> and the objective sense is <code>MIN_SENSE</code> or <code>MAX_SENSE</code> (not <code>FEASIBILITY_SENSE</code>). For linear constraints, the shadow prices differ at most in sign from the <code>dual</code> value depending on the objective sense.</p><p><strong>Notes</strong></p><ul><li>The function simply translates signs from <code>dual</code> and does not validate the conditions needed to guarantee the sensitivity interpretation of the shadow price. The caller is responsible, e.g., for checking whether the solver converged to an optimal primal-dual pair or a proof of infeasibility.</li><li>The computation is based on the current objective sense of the model. If this has changed since the last solve, the results will be incorrect.</li><li>Relaxation of equality constraints (and hence the shadow price) is defined based on which sense of the equality constraint is active.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.fix" id="JuMP.fix"><code>JuMP.fix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fix(v::VariableRef, value::Number; force::Bool = false)</code></pre><p>Fix a variable to a value. Update the fixing constraint if one exists, otherwise create a new one.</p><p>If the variable already has variable bounds and <code>force=false</code>, calling <code>fix</code> will throw an error. If <code>force=true</code>, existing variable bounds will be deleted, and the fixing constraint will be added. Note a variable will have no bounds after a call to <code>JuMP.unfix</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.set_coefficient" id="JuMP.set_coefficient"><code>JuMP.set_coefficient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_coefficient(constraint::ConstraintRef, variable::VariableRef, value)</code></pre><p>Set the coefficient of <code>variable</code> in the constraint <code>constraint</code> to <code>value</code>.</p><p>Note that prior to this step, JuMP will aggregate multiple terms containing the same variable. For example, given a constraint <code>2x + 3x &lt;= 2</code>, <code>JuMP.set_coefficient(c, x, 4)</code> will create the constraint <code>4x &lt;= 2</code>.</p><pre><code class="language-julia">model = Model()
@variable(model, x)
@constraint(model, con, 2x + 3x &lt;= 2)
JuMP.set_coefficient(con, x, 4)
con

# output

con : 4 x &lt;= 2.0</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.is_valid" id="JuMP.is_valid"><code>JuMP.is_valid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_valid(model::Model, constraint_ref::ConstraintRef{Model})</code></pre><p>Return <code>true</code> if <code>constraint_ref</code> refers to a valid constraint in <code>model</code>.</p></div></div><div><div><pre><code class="language-none">is_valid(model::Model, variable_ref::VariableRef)</code></pre><p>Return <code>true</code> if <code>variable</code> refers to a valid variable in <code>model</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.delete" id="JuMP.delete"><code>JuMP.delete</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">delete(model::Model, constraint_ref::ConstraintRef)</code></pre><p>Delete the constraint associated with <code>constraint_ref</code> from the model <code>model</code>.</p></div></div><div><div><pre><code class="language-none">delete(model::Model, variable_ref::VariableRef)</code></pre><p>Delete the variable associated with <code>variable_ref</code> from the model <code>model</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.LowerBoundRef" id="JuMP.LowerBoundRef"><code>JuMP.LowerBoundRef</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">LowerBoundRef(v::VariableRef)</code></pre><p>Return a constraint reference to the lower bound constraint of <code>v</code>. Errors if one does not exist.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.UpperBoundRef" id="JuMP.UpperBoundRef"><code>JuMP.UpperBoundRef</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">UpperBoundRef(v::VariableRef)</code></pre><p>Return a constraint reference to the upper bound constraint of <code>v</code>. Errors if one does not exist.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.FixRef" id="JuMP.FixRef"><code>JuMP.FixRef</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">LowerBoundRef(v::VariableRef)</code></pre><p>Return a constraint reference to the constraint fixing the value of <code>v</code>. Errors if one does not exist.</p></div></div></section><h2><a class="nav-anchor" href="#Constructing-constraints-without-adding-them-to-the-model-1" id="Constructing-constraints-without-adding-them-to-the-model-1">Constructing constraints without adding them to the model</a></h2><p>For advanced use cases.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.@build_constraint" id="JuMP.@build_constraint"><code>JuMP.@build_constraint</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@build_constraint(constraint_expr)</code></pre><p>Constructs a <code>JuMP.ScalarConstraint</code> or <code>JuMP.VectorConstraint</code> using the same machinery as <a href="#JuMP.@constraint"><code>@constraint</code></a> but without adding the constraint to a model.</p><p>Constraints using broadcast operators like <code>x .&lt;= 1</code> are also supported and will create arrays of <code>JuMP.ScalarConstraint</code> or <code>JuMP.VectorConstraint</code>.</p><p><strong>Examples</strong></p><p>```jldoctest; setup = :(using JuMP) model = Model(); @variable(model, x); JuMP.@build_constraint(2x &gt;= 1)</p><p><strong>output</strong></p><p>JuMP.ScalarConstraint{JuMP.GenericAffExpr{Float64,VariableRef},MathOptInterface.GreaterThan{Float64}}(2 x, MathOptInterface.GreaterThan{Float64}(1.0))</p></div></div></section><footer><hr/><a class="previous" href="../objective/"><span class="direction">Previous</span><span class="title">Objective</span></a><a class="next" href="../containers/"><span class="direction">Next</span><span class="title">Containers</span></a></footer></article></body></HTML>