<!DOCTYPE html><HTML class="no-js" lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Models — JuMP -- Julia for Mathematical Optimization 0.17 documentation</title><link href="_static/css/theme.css" rel="stylesheet" type="text/css"/><link href="genindex.html" rel="index" title="Index"/><link href="search.html" rel="search" title="Search"/><link href="index.html" rel="top" title="JuMP -- Julia for Mathematical Optimization 0.17 documentation"/><link href="refvariable.html" rel="next" title="Variables"/><link href="quickstart.html" rel="prev" title="Quick Start Guide"/><script src="_static/js/modernizr.min.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body class="wy-body-for-nav" role="document"><div class="wy-grid-for-nav"><nav class="wy-nav-side" data-toggle="wy-nav-shift"><div class="wy-side-scroll"><div class="wy-side-nav-search"><a class="icon icon-home" href="index.html"> JuMP -- Julia for Mathematical Optimization
          

          
          </a><div class="version">
                0.17
              </div><div role="search"><form action="search.html" class="wy-form" id="rtd-search-form" method="get"><input name="q" placeholder="Search docs" type="text"/><input name="check_keywords" type="hidden" value="yes"/><input name="area" type="hidden" value="default"/></form></div></div><div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation"><ul class="current"><li class="toctree-l1"><a class="reference internal" href="installation.html">Installation Guide</a></li><li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quick Start Guide</a></li><li class="toctree-l1 current"><a class="current reference internal" href="#">Models</a><ul><li class="toctree-l2"><a class="reference internal" href="#constructor">Constructor</a></li><li class="toctree-l2"><a class="reference internal" href="#methods">Methods</a></li><li class="toctree-l2"><a class="reference internal" href="#solve-status">Solve status</a></li><li class="toctree-l2"><a class="reference internal" href="#quadratic-objectives">Quadratic Objectives</a></li><li class="toctree-l2"><a class="reference internal" href="#second-order-cone-constraints">Second-order cone constraints</a></li><li class="toctree-l2"><a class="reference internal" href="#accessing-the-low-level-model">Accessing the low-level model</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="refvariable.html">Variables</a></li><li class="toctree-l1"><a class="reference internal" href="refexpr.html">Expressions and Constraints</a></li><li class="toctree-l1"><a class="reference internal" href="probmod.html">Problem Modification</a></li><li class="toctree-l1"><a class="reference internal" href="callbacks.html">Solver Callbacks</a></li><li class="toctree-l1"><a class="reference internal" href="nlp.html">Nonlinear Modeling</a></li></ul></div></div></nav><section class="wy-nav-content-wrap" data-toggle="wy-nav-shift"><nav aria-label="top navigation" class="wy-nav-top" role="navigation"><i class="fa fa-bars" data-toggle="wy-nav-top"></i><a href="index.html">JuMP -- Julia for Mathematical Optimization</a></nav><div class="wy-nav-content"><div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation"><ul class="wy-breadcrumbs"><li><a href="index.html">Docs</a> »</li><li>Models</li><li class="wy-breadcrumbs-aside"><a href="_sources/refmodel.rst.txt" rel="nofollow"> View page source</a></li></ul><hr/></div><div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main"><div itemprop="articleBody"><div class="admonition warning" id="officialwarn"><p class="first admonition-title">Warning</p><p class="last">This documentation tracks the development branch of JuMP. For the documentation of the latest JuMP release, see <a href="http://www.juliaopt.org/JuMP.jl/0.17/">here</a>.</p></div><script type="text/javascript">
if(!(location.hostname.match('readthedocs') || location.hostname.match('rtfd'))){
    document.getElementById("officialwarn").style.display = 'none';
}
</script><div class="section" id="models"><span id="ref-model"></span><h1>Models<a class="headerlink" href="#models" title="Permalink to this headline">¶</a></h1><div class="section" id="constructor"><h2>Constructor<a class="headerlink" href="#constructor" title="Permalink to this headline">¶</a></h2><p><code class="docutils literal"><span class="pre">Model</span></code> is a type defined by JuMP. All variables and constraints are
associated with a <code class="docutils literal"><span class="pre">Model</span></code> object. It has a constructor that has no
required arguments:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">=</span><span class="n">Model</span><span class="p">()</span></pre></div></div><p>The constructor also accepts an optional keyword argument, <code class="docutils literal"><span class="pre">solver</span></code>. You may specify a solver either here or later on by calling <code class="docutils literal"><span class="pre">setsolver</span></code>. JuMP will throw an error if you try to solve a problem without specifying a solver.</p><p><code class="docutils literal"><span class="pre">solver</span></code> must be an <code class="docutils literal"><span class="pre">AbstractMathProgSolver</span></code> object, which is constructed as follows:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">solver</span><span class="o">=</span><span class="n">solvername</span><span class="p">(</span><span class="n">Option1</span><span class="o">=</span><span class="n">Value1</span><span class="p">,</span><span class="n">Option2</span><span class="o">=</span><span class="n">Value2</span><span class="p">,</span><span class="o">...</span><span class="p">)</span></pre></div></div><p>where <code class="docutils literal"><span class="pre">solvername</span></code> is one of the supported solvers. See the <a class="reference internal" href="installation.html#jump-solvertable"><span class="std std-ref">solver table</span></a> for the list of available solvers and corresponding parameter names.  All options are solver-dependent; see corresponding solver packages for more information.</p><div class="admonition note"><p class="first admonition-title">Note</p><p class="last">Be sure that the solver provided supports the problem class of the model. For example <code class="docutils literal"><span class="pre">ClpSolver</span></code> and <code class="docutils literal"><span class="pre">GLPKSolverLP</span></code> support only linear programming problems. <code class="docutils literal"><span class="pre">CbcSolver</span></code> and <code class="docutils literal"><span class="pre">GLPKSolverMIP</span></code> support only mixed-integer programming problems.</p></div><p>As an example, we can create a <code class="docutils literal"><span class="pre">Model</span></code> object that will use GLPK’s
exact solver for LPs as follows:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">=</span><span class="n">Model</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="n">GLPKSolverLP</span><span class="p">(</span><span class="n">method</span><span class="o">=:</span><span class="n">Exact</span><span class="p">))</span></pre></div></div></div><div class="section" id="methods"><h2>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h2><p><strong>General</strong></p><ul class="simple"><li><code class="docutils literal"><span class="pre">MathProgBase.numvar(m::Model)</span></code> - returns the number of variables associated with the <code class="docutils literal"><span class="pre">Model</span><span class="pre">m</span></code>.</li><li><code class="docutils literal"><span class="pre">MathProgBase.numlinconstr(m::Model)</span></code> - returns the number of linear constraints associated with the <code class="docutils literal"><span class="pre">Model</span><span class="pre">m</span></code>.</li><li><code class="docutils literal"><span class="pre">MathProgBase.numquadconstr(m::Model)</span></code> - returns the number of quadratic constraints associated with the <code class="docutils literal"><span class="pre">Model</span><span class="pre">m</span></code>.</li><li><code class="docutils literal"><span class="pre">JuMP.numsocconstr(m::Model)</span></code> - returns the number of second order cone constraints associated with the <code class="docutils literal"><span class="pre">Model</span><span class="pre">m</span></code>.</li><li><code class="docutils literal"><span class="pre">JuMP.numsosconstr(m::Model)</span></code> - returns the number of sos constraints associated with the <code class="docutils literal"><span class="pre">Model</span><span class="pre">m</span></code>.</li><li><code class="docutils literal"><span class="pre">JuMP.numsdconstr(m::Model)</span></code> - returns the number of semi-definite constraints associated with the <code class="docutils literal"><span class="pre">Model</span><span class="pre">m</span></code>.</li><li><code class="docutils literal"><span class="pre">JuMP.numnlconstr(m::Model)</span></code> - returns the number of nonlinear constraints associated with the <code class="docutils literal"><span class="pre">Model</span><span class="pre">m</span></code>.</li><li><code class="docutils literal"><span class="pre">MathProgBase.numconstr(m::Model)</span></code> - returns the total number of constraints associated with the <code class="docutils literal"><span class="pre">Model</span><span class="pre">m</span></code>.</li><li><code class="docutils literal"><span class="pre">getsolvetime(m::Model)</span></code> - returns the solve time reported by the solver if it is implemented.</li><li><code class="docutils literal"><span class="pre">getnodecount(m::Model)</span></code> - returns the number of explored branch-and-bound nodes, if it is implemented.</li><li><code class="docutils literal"><span class="pre">getobjbound(m::Model)</span></code> - returns the best known bound on the optimal objective value. This is used, for example, when a branch-and-bound method is stopped before finishing.</li><li><code class="docutils literal"><span class="pre">getobjgap(m::Model)</span></code> - returns the final relative optimality gap as optimization terminated. That is, it returns <span class="math">\(\frac{|b-f|}{|f|}\)</span>, where <span class="math">\(b\)</span> is the best bound and <span class="math">\(f\)</span> is the best feasible objective value.</li><li><code class="docutils literal"><span class="pre">getrawsolver(m::Model)</span></code> - returns an object that may be used to access a solver-specific API.</li><li><code class="docutils literal"><span class="pre">getsimplexiter(m::Model)</span></code> - returns the cumulative number of simplex iterations during the optimization process. In particular, for a MIP it returns the total simplex iterations for all nodes.</li><li><code class="docutils literal"><span class="pre">getbarrieriter(m::Model)</span></code> - returns the cumulative number of barrier iterations during the optimization process.</li><li><code class="docutils literal"><span class="pre">internalmodel(m::Model)</span></code> - returns the internal low-level <code class="docutils literal"><span class="pre">AbstractMathProgModel</span></code> object which can be used to access any functionality that is not exposed by JuMP. See the MathProgBase <a class="reference external" href="https://mathprogbasejl.readthedocs.org/en/latest/lowlevel.html">documentation</a>.</li><li><code class="docutils literal"><span class="pre">solve(m::Model;</span><span class="pre">suppress_warnings=false,</span><span class="pre">relaxation=false)</span></code> - solves the model using the selected solver (or a default for the problem class), and takes two optional arguments that are disabled by default. Setting <code class="docutils literal"><span class="pre">suppress_warnings</span></code> to <code class="docutils literal"><span class="pre">true</span></code> will suppress all JuMP-specific output (e.g. warnings about infeasibility and lack of dual information) but will not suppress solver output (which should be done by passing options to the solver). Setting <code class="docutils literal"><span class="pre">relaxation=true</span></code> solves the standard continuous relaxation for the model: that is, integrality is dropped, special ordered set constraints are not enforced, and semi-continuous and semi-integer variables with bounds <code class="docutils literal"><span class="pre">[l,u]</span></code> are replaced with bounds <code class="docutils literal"><span class="pre">[min(l,0),max(u,0)]</span></code>.</li><li><code class="docutils literal"><span class="pre">JuMP.build(m::Model)</span></code> - builds the model in memory at the MathProgBase level without optimizing.</li><li><code class="docutils literal"><span class="pre">setsolver(m::Model,s::AbstractMathProgSolver)</span></code> - changes the solver which will be used for the next call to <code class="docutils literal"><span class="pre">solve()</span></code>, discarding the current internal model if present.</li><li><code class="docutils literal"><span class="pre">getindex(m::Model,name::Symbol)</span></code> - returns the variable, or group of variables, or constraint, or group of constraints, of the given name which were added to the model. This errors if multiple variables or constraints share the same name.</li><li><code class="docutils literal"><span class="pre">setindex!(m::Model,</span><span class="pre">value,</span><span class="pre">name::Symbol)</span></code> - stores the object <code class="docutils literal"><span class="pre">value</span></code> in the model <code class="docutils literal"><span class="pre">m</span></code> so that it can be accessed via <code class="docutils literal"><span class="pre">getindex</span></code>.</li></ul><p><strong>Objective</strong></p><ul class="simple"><li><code class="docutils literal"><span class="pre">getobjective(m::Model)</span></code> - returns the objective function as a <code class="docutils literal"><span class="pre">QuadExpr</span></code>.</li><li><code class="docutils literal"><span class="pre">getobjectivesense(m::Model)</span></code> - returns objective sense, either <code class="docutils literal"><span class="pre">:Min</span></code> or <code class="docutils literal"><span class="pre">:Max</span></code>.</li><li><code class="docutils literal"><span class="pre">setobjectivesense(m::Model,</span><span class="pre">newSense::Symbol)</span></code> - sets the objective sense (<code class="docutils literal"><span class="pre">newSense</span></code> is either <code class="docutils literal"><span class="pre">:Min</span></code> or <code class="docutils literal"><span class="pre">:Max</span></code>).</li><li><code class="docutils literal"><span class="pre">getobjectivevalue(m::Model)</span></code> - returns objective value after a call to <code class="docutils literal"><span class="pre">solve</span></code>.</li><li><code class="docutils literal"><span class="pre">getobjectivebound(m::Model)</span></code> - returns the best known bound on the optimal objective value after a call to <code class="docutils literal"><span class="pre">solve</span></code>.</li></ul><p><strong>Output</strong></p><ul class="simple"><li><code class="docutils literal"><span class="pre">writeLP(m::Model,</span><span class="pre">filename::AbstractString;</span><span class="pre">genericnames=true)</span></code> - write the model to <code class="docutils literal"><span class="pre">filename</span></code> in the LP file format. Set <code class="docutils literal"><span class="pre">genericnames=false</span></code> for user-defined variable names.</li><li><code class="docutils literal"><span class="pre">writeMPS(m::Model,</span><span class="pre">filename::AbstractString)</span></code> - write the model to <code class="docutils literal"><span class="pre">filename</span></code> in the MPS file format.</li></ul></div><div class="section" id="solve-status"><span id="solvestatus"></span><h2>Solve status<a class="headerlink" href="#solve-status" title="Permalink to this headline">¶</a></h2><p>The call <code class="docutils literal"><span class="pre">status</span><span class="pre">=</span><span class="pre">solve(m)</span></code> returns a symbol recording the status of the optimization process, as reported by the solver. Typical values are listed in the table below, although the code can take solver-dependent values. For instance, certain solvers prove infeasibility or unboundedness during presolve, but do not report which of the two cases holds. See your solver interface documentation (as linked to in the <a class="reference internal" href="installation.html#jump-solvertable"><span class="std std-ref">solver table</span></a>) for more information.</p><table border="1" class="docutils" id="jump-statustable"><colgroup><col width="29%"/><col width="71%"/></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">Status</th><th class="head">Meaning</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">:Optimal</span></code></td><td>Problem solved to optimality</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">:Unbounded</span></code></td><td>Problem is unbounded</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">:Infeasible</span></code></td><td>Problem is infeasible</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">:UserLimit</span></code></td><td>Iteration limit or timeout</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">:Error</span></code></td><td>Solver exited with an error</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">:NotSolved</span></code></td><td>Model built in memory but not optimized</td></tr></tbody></table></div><div class="section" id="quadratic-objectives"><h2>Quadratic Objectives<a class="headerlink" href="#quadratic-objectives" title="Permalink to this headline">¶</a></h2><p>Quadratic objectives are supported by JuMP using a solver which implements the
corresponding extensions of the MathProgBase interface. Add them in the same way
you would a linear objective:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">using</span><span class="n">Ipopt</span><span class="n">m</span><span class="o">=</span><span class="n">Model</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="n">IpoptSolver</span><span class="p">())</span><span class="nd">@variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">)</span><span class="nd">@variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span><span class="o">&lt;=</span><span class="mi">30</span><span class="p">)</span><span class="nd">@objective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">Min</span><span class="p">,</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="nd">@constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">)</span><span class="n">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="n">status</span><span class="o">=</span><span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="p">)</span></pre></div></div></div><div class="section" id="second-order-cone-constraints"><h2>Second-order cone constraints<a class="headerlink" href="#second-order-cone-constraints" title="Permalink to this headline">¶</a></h2><p>Second-order cone constraints of the form <span class="math">\(||Ax-b||_2 + a^Tx + c \le 0\)</span> can be added directly using the <code class="docutils literal"><span class="pre">norm</span></code> function:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="nd">@constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">2</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></pre></div></div><p>You may use generator expressions within <code class="docutils literal"><span class="pre">norm()</span></code> to build up normed expressions with complex indexing operations in much the same way as with <code class="docutils literal"><span class="pre">sum(...)</span></code>:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="nd">@constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">norm</span><span class="p">(</span><span class="mi">2</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">i</span><span class="k">for</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="k">if</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">)</span></pre></div></div></div><div class="section" id="accessing-the-low-level-model"><h2>Accessing the low-level model<a class="headerlink" href="#accessing-the-low-level-model" title="Permalink to this headline">¶</a></h2><p>It is possible to construct the internal low-level model before optimizing. To do this,
call the <code class="docutils literal"><span class="pre">JuMP.build</span></code> function. It is then possible
to obtain this model by using the <code class="docutils literal"><span class="pre">internalmodel</span></code> function. This may be useful when
it is necessary to access some functionality that is not exposed by JuMP. When you are ready to optimize,
simply call <code class="docutils literal"><span class="pre">solve</span></code> in the normal fashion.</p></div></div></div><div class="articleComments"></div></div><footer><div aria-label="footer navigation" class="rst-footer-buttons" role="navigation"><a accesskey="n" class="btn btn-neutral float-right" href="refvariable.html" rel="next" title="Variables">Next <span class="fa fa-arrow-circle-right"></span></a><a accesskey="p" class="btn btn-neutral" href="quickstart.html" rel="prev" title="Quick Start Guide"><span class="fa fa-arrow-circle-left"></span> Previous</a></div><hr/><div role="contentinfo"><p>
        © Copyright 2017, Miles Lubin, Iain Dunning, and Joey Huchette.

    </p></div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer></div></div></section></div><script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.17',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script><script src="_static/jquery.js" type="text/javascript"></script><script src="_static/underscore.js" type="text/javascript"></script><script src="_static/doctools.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script src="_static/js/theme.js" type="text/javascript"></script><script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script><script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview');
</script><script async="" src="https://www.google-analytics.com/analytics.js"></script></body></HTML>