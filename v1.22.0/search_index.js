var documenterSearchIndex = {"docs":
[{"location":"moi/reference/nonlinear/","page":"Nonlinear programming","title":"Nonlinear programming","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/reference/nonlinear.md\"","category":"page"},{"location":"moi/reference/nonlinear/","page":"Nonlinear programming","title":"Nonlinear programming","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/nonlinear/#Nonlinear-programming","page":"Nonlinear programming","title":"Nonlinear programming","text":"","category":"section"},{"location":"moi/reference/nonlinear/#Types","page":"Nonlinear programming","title":"Types","text":"","category":"section"},{"location":"moi/reference/nonlinear/","page":"Nonlinear programming","title":"Nonlinear programming","text":"AbstractNLPEvaluator\nNLPBoundsPair\nNLPBlockData","category":"page"},{"location":"moi/reference/nonlinear/#MathOptInterface.AbstractNLPEvaluator","page":"Nonlinear programming","title":"MathOptInterface.AbstractNLPEvaluator","text":"AbstractNLPEvaluator\n\nAbstract supertype for the callback object that is used to query function values, derivatives, and expression graphs.\n\nIt is used in NLPBlockData.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#MathOptInterface.NLPBoundsPair","page":"Nonlinear programming","title":"MathOptInterface.NLPBoundsPair","text":"NLPBoundsPair(lower::Float64, upper::Float64)\n\nA struct holding a pair of lower and upper bounds.\n\n-Inf and Inf can be used to indicate no lower or upper bound, respectively.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#MathOptInterface.NLPBlockData","page":"Nonlinear programming","title":"MathOptInterface.NLPBlockData","text":"struct NLPBlockData\n    constraint_bounds::Vector{NLPBoundsPair}\n    evaluator::AbstractNLPEvaluator\n    has_objective::Bool\nend\n\nA struct encoding a set of nonlinear constraints of the form lb le g(x) le ub and, if has_objective == true, a nonlinear objective function f(x).\n\nNonlinear objectives override any objective set by using the ObjectiveFunction attribute.\n\nThe evaluator is a callback object that is used to query function values, derivatives, and expression graphs. If has_objective == false, then it is an error to query properties of the objective function, and in Hessian-of-the-Lagrangian queries, σ must be set to zero.\n\nnote: Note\nThroughout the evaluator, all variables are ordered according to ListOfVariableIndices. Hence, MOI copies of nonlinear problems must not re-order variables.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#Attributes","page":"Nonlinear programming","title":"Attributes","text":"","category":"section"},{"location":"moi/reference/nonlinear/","page":"Nonlinear programming","title":"Nonlinear programming","text":"NLPBlock\nNLPBlockDual\nNLPBlockDualStart","category":"page"},{"location":"moi/reference/nonlinear/#MathOptInterface.NLPBlock","page":"Nonlinear programming","title":"MathOptInterface.NLPBlock","text":"NLPBlock()\n\nAn AbstractModelAttribute that stores an NLPBlockData, representing a set of nonlinear constraints, and optionally a nonlinear objective.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#MathOptInterface.NLPBlockDual","page":"Nonlinear programming","title":"MathOptInterface.NLPBlockDual","text":"NLPBlockDual(result_index::Int = 1)\n\nAn AbstractModelAttribute for the Lagrange multipliers on the constraints from the NLPBlock in result result_index.\n\nIf result_index is omitted, it is 1 by default.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#MathOptInterface.NLPBlockDualStart","page":"Nonlinear programming","title":"MathOptInterface.NLPBlockDualStart","text":"NLPBlockDualStart()\n\nAn AbstractModelAttribute for the initial assignment of the Lagrange multipliers on the constraints from the NLPBlock that the solver may use to warm-start the solve.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/nonlinear/#Functions","page":"Nonlinear programming","title":"Functions","text":"","category":"section"},{"location":"moi/reference/nonlinear/","page":"Nonlinear programming","title":"Nonlinear programming","text":"initialize\nfeatures_available\neval_objective\neval_constraint\neval_objective_gradient\njacobian_structure\neval_constraint_gradient\nconstraint_gradient_structure\neval_constraint_jacobian\neval_constraint_jacobian_product\neval_constraint_jacobian_transpose_product\nhessian_lagrangian_structure\nhessian_objective_structure\nhessian_constraint_structure\neval_hessian_objective\neval_hessian_constraint\neval_hessian_lagrangian\neval_hessian_lagrangian_product\nobjective_expr\nconstraint_expr","category":"page"},{"location":"moi/reference/nonlinear/#MathOptInterface.initialize","page":"Nonlinear programming","title":"MathOptInterface.initialize","text":"initialize(\n    d::AbstractNLPEvaluator,\n    requested_features::Vector{Symbol},\n)::Nothing\n\nInitialize d with the set of features in requested_features. Check features_available before calling initialize to see what features are supported by d.\n\nwarning: Warning\nThis method must be called before any other methods.\n\nFeatures\n\nThe following features are defined:\n\n:Grad: enables eval_objective_gradient\n:Jac: enables eval_constraint_jacobian\n:JacVec: enables eval_constraint_jacobian_product and eval_constraint_jacobian_transpose_product\n:Hess: enables eval_hessian_lagrangian\n:HessVec: enables eval_hessian_lagrangian_product\n:ExprGraph: enables objective_expr and constraint_expr.\n\nIn all cases, including when requested_features is empty, eval_objective and eval_constraint are supported.\n\nExamples\n\nMOI.initialize(d, Symbol[])\nMOI.initialize(d, [:ExprGraph])\nMOI.initialize(d, MOI.features_available(d))\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.features_available","page":"Nonlinear programming","title":"MathOptInterface.features_available","text":"features_available(d::AbstractNLPEvaluator)::Vector{Symbol}\n\nReturns the subset of features available for this problem instance.\n\nSee initialize for the list of defined features.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_objective","page":"Nonlinear programming","title":"MathOptInterface.eval_objective","text":"eval_objective(d::AbstractNLPEvaluator, x::AbstractVector{T})::T where {T}\n\nEvaluate the objective f(x), returning a scalar value.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_constraint","page":"Nonlinear programming","title":"MathOptInterface.eval_constraint","text":"eval_constraint(d::AbstractNLPEvaluator,\n    g::AbstractVector{T},\n    x::AbstractVector{T},\n)::Nothing where {T}\n\nGiven a set of vector-valued constraints l le g(x) le u, evaluate the constraint function g(x), storing the result in the vector g.\n\nImplementation notes\n\nWhen implementing this method, you must not assume that g is Vector{Float64}, but you may assume that it supports setindex! and length. For example, it may be the view of a vector.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_objective_gradient","page":"Nonlinear programming","title":"MathOptInterface.eval_objective_gradient","text":"eval_objective_gradient(\n    d::AbstractNLPEvaluator,\n    grad::AbstractVector{T},\n    x::AbstractVector{T},\n)::Nothing where {T}\n\nEvaluate the gradient of the objective function grad = nabla f(x) as a dense vector, storing the result in the vector grad.\n\nImplementation notes\n\nWhen implementing this method, you must not assume that grad is Vector{Float64}, but you may assume that it supports setindex! and length. For example, it may be the view of a vector.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.jacobian_structure","page":"Nonlinear programming","title":"MathOptInterface.jacobian_structure","text":"jacobian_structure(d::AbstractNLPEvaluator)::Vector{Tuple{Int64,Int64}}\n\nReturns a vector of tuples, (row, column), where each indicates the position of a structurally nonzero element in the Jacobian matrix: J_g(x) = left beginarrayc nabla g_1(x)  nabla g_2(x)  vdots  nabla g_m(x) endarrayright where g_i is the itextth component of the nonlinear constraints g(x).\n\nThe indices are not required to be sorted and can contain duplicates, in which case the solver should combine the corresponding elements by adding them together.\n\nThe sparsity structure is assumed to be independent of the point x.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_constraint_gradient","page":"Nonlinear programming","title":"MathOptInterface.eval_constraint_gradient","text":"eval_constraint_gradient(\n    d::AbstractNLPEvaluator,\n    ∇g::AbstractVector{T},\n    x::AbstractVector{T},\n    i::Int,\n)::Nothing where {T}\n\nEvaluate the gradient of constraint i, nabla g_i(x), and store the non-zero values in ∇g, corresponding to the structure returned by constraint_gradient_structure.\n\nImplementation notes\n\nWhen implementing this method, you must not assume that ∇g is Vector{Float64}, but you may assume that it supports setindex! and length. For example, it may be the view of a vector.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.constraint_gradient_structure","page":"Nonlinear programming","title":"MathOptInterface.constraint_gradient_structure","text":"constraint_gradient_structure(d::AbstractNLPEvaluator, i::Int)::Vector{Int64}\n\nReturns a vector of indices, where each element indicates the position of a structurally nonzero element in the gradient of constraint nabla g_i(x).\n\nThe indices are not required to be sorted and can contain duplicates, in which case the solver should combine the corresponding elements by adding them together.\n\nThe sparsity structure is assumed to be independent of the point x.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_constraint_jacobian","page":"Nonlinear programming","title":"MathOptInterface.eval_constraint_jacobian","text":"eval_constraint_jacobian(d::AbstractNLPEvaluator,\n    J::AbstractVector{T},\n    x::AbstractVector{T},\n)::Nothing where {T}\n\nEvaluates the sparse Jacobian matrix J_g(x) = left beginarrayc nabla g_1(x)  nabla g_2(x)  vdots  nabla g_m(x) endarrayright.\n\nThe result is stored in the vector J in the same order as the indices returned by jacobian_structure.\n\nImplementation notes\n\nWhen implementing this method, you must not assume that J is Vector{Float64}, but you may assume that it supports setindex! and length. For example, it may be the view of a vector.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_constraint_jacobian_product","page":"Nonlinear programming","title":"MathOptInterface.eval_constraint_jacobian_product","text":"eval_constraint_jacobian_product(\n    d::AbstractNLPEvaluator,\n    y::AbstractVector{T},\n    x::AbstractVector{T},\n    w::AbstractVector{T},\n)::Nothing where {T}\n\nComputes the Jacobian-vector product y = J_g(x)w, storing the result in the vector y.\n\nThe vectors have dimensions such that length(w) == length(x), and length(y) is the number of nonlinear constraints.\n\nImplementation notes\n\nWhen implementing this method, you must not assume that y is Vector{Float64}, but you may assume that it supports setindex! and length. For example, it may be the view of a vector.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_constraint_jacobian_transpose_product","page":"Nonlinear programming","title":"MathOptInterface.eval_constraint_jacobian_transpose_product","text":"eval_constraint_jacobian_transpose_product(\n    d::AbstractNLPEvaluator,\n    y::AbstractVector{T},\n    x::AbstractVector{T},\n    w::AbstractVector{T},\n)::Nothing where {T}\n\nComputes the Jacobian-transpose-vector product y = J_g(x)^Tw, storing the result in the vector y.\n\nThe vectors have dimensions such that length(y) == length(x), and length(w) is the number of nonlinear constraints.\n\nImplementation notes\n\nWhen implementing this method, you must not assume that y is Vector{Float64}, but you may assume that it supports setindex! and length. For example, it may be the view of a vector.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.hessian_lagrangian_structure","page":"Nonlinear programming","title":"MathOptInterface.hessian_lagrangian_structure","text":"hessian_lagrangian_structure(\n    d::AbstractNLPEvaluator,\n)::Vector{Tuple{Int64,Int64}}\n\nReturns a vector of tuples, (row, column), where each indicates the position of a structurally nonzero element in the Hessian-of-the-Lagrangian matrix: nabla^2 f(x) + sum_i=1^m nabla^2 g_i(x).\n\nThe indices are not required to be sorted and can contain duplicates, in which case the solver should combine the corresponding elements by adding them together.\n\nAny mix of lower and upper-triangular indices is valid. Elements (i,j) and (j,i), if both present, should be treated as duplicates.\n\nThe sparsity structure is assumed to be independent of the point x.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.hessian_objective_structure","page":"Nonlinear programming","title":"MathOptInterface.hessian_objective_structure","text":"hessian_objective_structure(\n    d::AbstractNLPEvaluator,\n)::Vector{Tuple{Int64,Int64}}\n\nReturns a vector of tuples, (row, column), where each indicates the position of a structurally nonzero element in the Hessian matrix: nabla^2 f(x).\n\nThe indices are not required to be sorted and can contain duplicates, in which case the solver should combine the corresponding elements by adding them together.\n\nAny mix of lower and upper-triangular indices is valid. Elements (i,j) and (j,i), if both present, should be treated as duplicates.\n\nThe sparsity structure is assumed to be independent of the point x.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.hessian_constraint_structure","page":"Nonlinear programming","title":"MathOptInterface.hessian_constraint_structure","text":"hessian_constraint_structure(\n    d::AbstractNLPEvaluator,\n    i::Int64,\n)::Vector{Tuple{Int64,Int64}}\n\nReturns a vector of tuples, (row, column), where each indicates the position of a structurally nonzero element in the Hessian matrix: nabla^2 g_i(x).\n\nThe indices are not required to be sorted and can contain duplicates, in which case the solver should combine the corresponding elements by adding them together.\n\nAny mix of lower and upper-triangular indices is valid. Elements (i,j) and (j,i), if both present, should be treated as duplicates.\n\nThe sparsity structure is assumed to be independent of the point x.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_hessian_objective","page":"Nonlinear programming","title":"MathOptInterface.eval_hessian_objective","text":"eval_hessian_objective(\n    d::AbstractNLPEvaluator,\n    H::AbstractVector{T},\n    x::AbstractVector{T},\n)::Nothing where {T}\n\nThis function computes the sparse Hessian matrix: nabla^2 f(x), storing the result in the vector H in the same order as the indices returned by hessian_objective_structure.\n\nImplementation notes\n\nWhen implementing this method, you must not assume that H is Vector{Float64}, but you may assume that it supports setindex! and length. For example, it may be the view of a vector.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_hessian_constraint","page":"Nonlinear programming","title":"MathOptInterface.eval_hessian_constraint","text":"eval_hessian_constraint(\n    d::AbstractNLPEvaluator,\n    H::AbstractVector{T},\n    x::AbstractVector{T},\n    i::Int64,\n)::Nothing where {T}\n\nThis function computes the sparse Hessian matrix: nabla^2 g_i(x), storing the result in the vector H in the same order as the indices returned by hessian_constraint_structure.\n\nImplementation notes\n\nWhen implementing this method, you must not assume that H is Vector{Float64}, but you may assume that it supports setindex! and length. For example, it may be the view of a vector.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_hessian_lagrangian","page":"Nonlinear programming","title":"MathOptInterface.eval_hessian_lagrangian","text":"eval_hessian_lagrangian(\n    d::AbstractNLPEvaluator,\n    H::AbstractVector{T},\n    x::AbstractVector{T},\n    σ::T,\n    μ::AbstractVector{T},\n)::Nothing where {T}\n\nGiven scalar weight σ and vector of constraint weights μ, this function computes the sparse Hessian-of-the-Lagrangian matrix: sigmanabla^2 f(x) + sum_i=1^m mu_i nabla^2 g_i(x), storing the result in the vector H in the same order as the indices returned by hessian_lagrangian_structure.\n\nImplementation notes\n\nWhen implementing this method, you must not assume that H is Vector{Float64}, but you may assume that it supports setindex! and length. For example, it may be the view of a vector.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.eval_hessian_lagrangian_product","page":"Nonlinear programming","title":"MathOptInterface.eval_hessian_lagrangian_product","text":"eval_hessian_lagrangian_product(\n    d::AbstractNLPEvaluator,\n    h::AbstractVector{T},\n    x::AbstractVector{T},\n    v::AbstractVector{T},\n    σ::T,\n    μ::AbstractVector{T},\n)::Nothing where {T}\n\nGiven scalar weight σ and vector of constraint weights μ, computes the Hessian-of-the-Lagrangian-vector product h = left(sigmanabla^2 f(x) + sum_i=1^m mu_i nabla^2 g_i(x)right)v, storing the result in the vector h.\n\nThe vectors have dimensions such that length(h) == length(x) == length(v).\n\nImplementation notes\n\nWhen implementing this method, you must not assume that h is Vector{Float64}, but you may assume that it supports setindex! and length. For example, it may be the view of a vector.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.objective_expr","page":"Nonlinear programming","title":"MathOptInterface.objective_expr","text":"objective_expr(d::AbstractNLPEvaluator)::Expr\n\nReturns a Julia Expr object representing the expression graph of the objective function.\n\nFormat\n\nThe expression has a number of limitations, compared with arbitrary Julia expressions:\n\nAll sums and products are flattened out as simple Expr(:+, ...) and Expr(:*, ...) objects.\nAll decision variables must be of the form Expr(:ref, :x, MOI.VariableIndex(i)), where i is the ith variable in ListOfVariableIndices.\nThere are currently no restrictions on recognized functions; typically these will be built-in Julia functions like ^, exp, log, cos, tan, sqrt, etc., but modeling interfaces may choose to extend these basic functions, or error if they encounter unsupported functions.\n\nExamples\n\nThe expression x_1+sin(x_2exp(x_3)) is represented as\n\n:(x[MOI.VariableIndex(1)] + sin(x[MOI.VariableIndex(2)] / exp(x[MOI.VariableIndex[3]])))\n\nor equivalently\n\nExpr(\n    :call,\n    :+,\n    Expr(:ref, :x, MOI.VariableIndex(1)),\n    Expr(\n        :call,\n        :/,\n        Expr(:call, :sin, Expr(:ref, :x, MOI.VariableIndex(2))),\n        Expr(:call, :exp, Expr(:ref, :x, MOI.VariableIndex(3))),\n    ),\n)\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/nonlinear/#MathOptInterface.constraint_expr","page":"Nonlinear programming","title":"MathOptInterface.constraint_expr","text":"constraint_expr(d::AbstractNLPEvaluator, i::Integer)::Expr\n\nReturns a Julia Expr object representing the expression graph for the itextth nonlinear constraint.\n\nFormat\n\nThe format is the same as objective_expr, with an additional comparison operator indicating the sense of and bounds on the constraint.\n\nFor single-sided comparisons, the body of the constraint must be on the left-hand side, and the right-hand side must be a constant.\n\nFor double-sided comparisons (that is, l le f(x) le u), the body of the constraint must be in the middle, and the left- and right-hand sides must be constants.\n\nThe bounds on the constraints must match the NLPBoundsPairs passed to NLPBlockData.\n\nExamples\n\n:(x[MOI.VariableIndex(1)]^2 <= 1.0)\n:(x[MOI.VariableIndex(1)]^2 >= 2.0)\n:(x[MOI.VariableIndex(1)]^2 == 3.0)\n:(4.0 <= x[MOI.VariableIndex(1)]^2 <= 5.0)\n\n\n\n\n\n","category":"function"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"EditURL = \"https://github.com/jump-dev/Cbc.jl/blob/v1.2.0/README.md\"","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"(Image: )","category":"page"},{"location":"packages/Cbc/#Cbc.jl","page":"jump-dev/Cbc.jl","title":"Cbc.jl","text":"","category":"section"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"Cbc.jl is a wrapper for the COIN-OR Branch and Cut (Cbc) solver.","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"The wrapper has two components:","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"a thin wrapper around the complete C API\nan interface to MathOptInterface","category":"page"},{"location":"packages/Cbc/#Affiliation","page":"jump-dev/Cbc.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"This wrapper is maintained by the JuMP community and is not a COIN-OR project.","category":"page"},{"location":"packages/Cbc/#License","page":"jump-dev/Cbc.jl","title":"License","text":"","category":"section"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"Cbc.jl is licensed under the MIT License.","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"The underlying solver, coin-or/Cbc, is licensed under the Eclipse public license.","category":"page"},{"location":"packages/Cbc/#Installation","page":"jump-dev/Cbc.jl","title":"Installation","text":"","category":"section"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"Install Cbc using Pkg.add:","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"import Pkg\nPkg.add(\"Cbc\")","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"In addition to installing the Cbc.jl package, this will also download and install the Cbc binaries. You do not need to install Cbc separately.","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"To use a custom binary, read the Custom solver binaries section of the JuMP documentation.","category":"page"},{"location":"packages/Cbc/#Use-with-JuMP","page":"jump-dev/Cbc.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"To use Cbc with JuMP, use Cbc.Optimizer:","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"using JuMP, Cbc\nmodel = Model(Cbc.Optimizer)\nset_attribute(model, \"logLevel\", 1)","category":"page"},{"location":"packages/Cbc/#MathOptInterface-API","page":"jump-dev/Cbc.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"The COIN Branch-and-Cut (Cbc) optimizer supports the following constraints and attributes.","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"List of supported objective functions:","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"MOI.Reals","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"MOI.ScalarAffineFunction{Float64} in MOI.EqualTo{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.Interval{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.EqualTo{Float64}\nMOI.VariableIndex in MOI.GreaterThan{Float64}\nMOI.VariableIndex in MOI.Integer\nMOI.VariableIndex in MOI.Interval{Float64}\nMOI.VariableIndex in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.ZeroOne\nMOI.VectorOfVariables in MOI.SOS1{Float64}\nMOI.VectorOfVariables in MOI.SOS2{Float64}","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"Cbc.Status\nCbc.SecondaryStatus\nMOI.DualStatus\nMOI.NodeCount\nMOI.NumberOfVariables\nMOI.ObjectiveBound\nMOI.ObjectiveSense\nMOI.ObjectiveValue\nMOI.PrimalStatus\nMOI.RelativeGap\nMOI.ResultCount\nMOI.SolveTimeSec\nMOI.TerminationStatus","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"List of supported optimizer attributes:","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"Cbc.SetVariableNames\nMOI.AbsoluteGapTolerance\nMOI.NumberOfThreads\nMOI.RawOptimizerAttribute\nMOI.RelativeGapTolerance\nMOI.Silent\nMOI.SolverName\nMOI.SolverVersion\nMOI.TimeLimitSec","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"List of supported variable attributes:","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"MOI.VariablePrimal\nMOI.VariablePrimalStart\nMOI.VariableName","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"List of supported constraint attributes:","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"MOI.ConstraintPrimal","category":"page"},{"location":"packages/Cbc/#Options","page":"jump-dev/Cbc.jl","title":"Options","text":"","category":"section"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"Options are, unfortunately, not well documented.","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"The following options are likely to be the most useful:","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"Parameter Example Explanation\nseconds 60.0 Solution timeout limit\nlogLevel 2 Set to 0 to disable solution output\nmaxSolutions 1 Terminate after this many feasible solutions have been found\nmaxNodes 1 Terminate after this many branch-and-bound nodes have been evaluated\nallowableGap 0.05 Terminate after optimality gap is less than this value (on an absolute scale)\nratioGap 0.05 Terminate after optimality gap is smaller than this relative fraction\nthreads 1 Set the number of threads to use for parallel branch & bound","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"The complete list of parameters can be found by running the cbc executable and typing ? at the prompt.","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"Start the cbc executable from Julia as follows:","category":"page"},{"location":"packages/Cbc/","page":"jump-dev/Cbc.jl","title":"jump-dev/Cbc.jl","text":"using Cbc_jll\nCbc_jll.cbc() do exe\n    run(`$(exe)`)\nend","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"EditURL = \"geographic_clustering.jl\"","category":"page"},{"location":"tutorials/linear/geographic_clustering/#Geographical-clustering","page":"Geographical clustering","title":"Geographical clustering","text":"","category":"section"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"This tutorial was originally contributed by Matthew Helm and Mathieu Tanneau.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"The goal of this exercise is to cluster n cities into k groups, minimizing the total pairwise distance between cities and ensuring that the variance in the total populations of each group is relatively small.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"using JuMP\nimport DataFrames\nimport HiGHS\nimport LinearAlgebra","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"For this example, we'll use the 20 most populous cities in the United States.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"cities = DataFrames.DataFrame(\n    Union{String,Float64}[\n        \"New York, NY\" 8.405 40.7127 -74.0059\n        \"Los Angeles, CA\" 3.884 34.0522 -118.2436\n        \"Chicago, IL\" 2.718 41.8781 -87.6297\n        \"Houston, TX\" 2.195 29.7604 -95.3698\n        \"Philadelphia, PA\" 1.553 39.9525 -75.1652\n        \"Phoenix, AZ\" 1.513 33.4483 -112.0740\n        \"San Antonio, TX\" 1.409 29.4241 -98.4936\n        \"San Diego, CA\" 1.355 32.7157 -117.1610\n        \"Dallas, TX\" 1.257 32.7766 -96.7969\n        \"San Jose, CA\" 0.998 37.3382 -121.8863\n        \"Austin, TX\" 0.885 30.2671 -97.7430\n        \"Indianapolis, IN\" 0.843 39.7684 -86.1580\n        \"Jacksonville, FL\" 0.842 30.3321 -81.6556\n        \"San Francisco, CA\" 0.837 37.7749 -122.4194\n        \"Columbus, OH\" 0.822 39.9611 -82.9987\n        \"Charlotte, NC\" 0.792 35.2270 -80.8431\n        \"Fort Worth, TX\" 0.792 32.7554 -97.3307\n        \"Detroit, MI\" 0.688 42.3314 -83.0457\n        \"El Paso, TX\" 0.674 31.7775 -106.4424\n        \"Memphis, TN\" 0.653 35.1495 -90.0489\n    ],\n    [\"city\", \"population\", \"lat\", \"lon\"],\n)","category":"page"},{"location":"tutorials/linear/geographic_clustering/#Model-Specifics","page":"Geographical clustering","title":"Model Specifics","text":"","category":"section"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"We will cluster these 20 cities into 3 different groups and we will assume that the ideal or target population P for a group is simply the total population of the 20 cities divided by 3:","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"n = size(cities, 1)\nk = 3\nP = sum(cities.population) / k","category":"page"},{"location":"tutorials/linear/geographic_clustering/#Obtaining-the-distances-between-each-city","page":"Geographical clustering","title":"Obtaining the distances between each city","text":"","category":"section"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"Let's compute the pairwise Haversine distance between each of the cities in our data set and store the result in a variable we'll call dm:","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"\"\"\"\n    haversine(lat1, long1, lat2, long2, r = 6372.8)\n\nCompute the haversine distance between two points on a sphere of radius `r`,\nwhere the points are given by the latitude/longitude pairs `lat1/long1` and\n`lat2/long2` (in degrees).\n\"\"\"\nfunction haversine(lat1, long1, lat2, long2, r = 6372.8)\n    lat1, long1 = deg2rad(lat1), deg2rad(long1)\n    lat2, long2 = deg2rad(lat2), deg2rad(long2)\n    hav(a, b) = sin((b - a) / 2)^2\n    inner_term = hav(lat1, lat2) + cos(lat1) * cos(lat2) * hav(long1, long2)\n    d = 2 * r * asin(sqrt(inner_term))\n    # Round distance to nearest kilometer.\n    return round(Int, d)\nend","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"Our distance matrix is symmetric so we'll convert it to a LowerTriangular matrix so that we can better interpret the objective value of our model:","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"dm = LinearAlgebra.LowerTriangular([\n    haversine(cities.lat[i], cities.lon[i], cities.lat[j], cities.lon[j])\n    for i in 1:n, j in 1:n\n])","category":"page"},{"location":"tutorials/linear/geographic_clustering/#Build-the-model","page":"Geographical clustering","title":"Build the model","text":"","category":"section"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"Now that we have the basics taken  care of, we can set up our model, create decision variables, add constraints, and then solve.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"First, we'll set up a model that leverages the Cbc solver. Next, we'll set up a binary variable x_ik that takes the value 1 if city i is in group k and 0 otherwise. Each city must be in a group, so we'll add the constraint sum_k x_ik = 1 for every i.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, x[1:n, 1:k], Bin)\n@constraint(model, [i = 1:n], sum(x[i, :]) == 1);\n# To reduce symmetry, we fix the first city to belong to the first group.\nfix(x[1, 1], 1; force = true)","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"The total population of a group k is Q_k = sum_ix_ikq_i where q_i is simply the i-th value from the population column in our cities DataFrame. Let's add constraints so that alpha leq (Q_k - P) leq beta. We'll set alpha equal to -3 million and beta equal to 3. By adjusting these thresholds you'll find that there is a tradeoff between having relatively even populations between groups and having geographically close cities within each group. In other words, the larger the absolute values of alpha and beta, the closer together the cities in a group will be but the variance between the group populations will be higher.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"@variable(model, -3 <= population_diff[1:k] <= 3)\n@constraint(model, population_diff .== x' * cities.population .- P)","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"Now we need to add one last binary variable z_ij to our model that we'll use to compute the total distance between the cities in our groups, defined as sum_ijd_ijz_ij. Variable z_ij will equal 1 if cities i and j are in the same group, and 0 if they are not in the same group.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"To ensure that z_ij = 1 if and only if cities i and j are in the same group, we add the constraints z_ij geq x_ik + x_jk - 1 for every pair ij and every k:","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"@variable(model, z[i = 1:n, j = 1:i], Bin)\nfor k in 1:k, i in 1:n, j in 1:i\n    @constraint(model, z[i, j] >= x[i, k] + x[j, k] - 1)\nend","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"We can now add an objective to our model which will simply be to minimize the dot product of z and our distance matrix, dm.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"@objective(model, Min, sum(dm[i, j] * z[i, j] for i in 1:n, j in 1:i));\nnothing #hide","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"We can then call optimize! and review the results.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"optimize!(model)\n@assert is_solved_and_feasible(model)","category":"page"},{"location":"tutorials/linear/geographic_clustering/#Reviewing-the-Results","page":"Geographical clustering","title":"Reviewing the Results","text":"","category":"section"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"Now that we have results, we can add a column to our cities DataFrame for the group and then loop through our x variable to assign each city to its group. Once we have that, we can look at the total population for each group and also look at the cities in each group to verify that they are grouped by geographic proximity.","category":"page"},{"location":"tutorials/linear/geographic_clustering/","page":"Geographical clustering","title":"Geographical clustering","text":"cities.group = zeros(n)\n\nfor i in 1:n, j in 1:k\n    if round(Int, value(x[i, j])) == 1\n        cities.group[i] = j\n    end\nend\n\nfor group in DataFrames.groupby(cities, :group)\n    @show group\n    println(\"\")\n    @show sum(group.population)\n    println(\"\")\nend","category":"page"},{"location":"packages/DisjunctiveProgramming/","page":"hdavid16/DisjunctiveProgramming.jl","title":"hdavid16/DisjunctiveProgramming.jl","text":"EditURL = \"https://github.com/hdavid16/DisjunctiveProgramming.jl/blob/6a4d0ac4a7484e52b1dbff9cee310a73d2d23e81/docs/jump/README.md\"","category":"page"},{"location":"packages/DisjunctiveProgramming/","page":"hdavid16/DisjunctiveProgramming.jl","title":"hdavid16/DisjunctiveProgramming.jl","text":"(Image: Logo)","category":"page"},{"location":"packages/DisjunctiveProgramming/","page":"hdavid16/DisjunctiveProgramming.jl","title":"hdavid16/DisjunctiveProgramming.jl","text":"DisjunctiveProgramming.jl is a  JuMP extension for expressing and solving Generalized Disjunctive Programs.  Generalized Disjunctive Programming  (GDP) is a modeling paradigm for easily modeling logical conditions which can be reformulated into a variety of mixed-integer programs. ","category":"page"},{"location":"packages/DisjunctiveProgramming/","page":"hdavid16/DisjunctiveProgramming.jl","title":"hdavid16/DisjunctiveProgramming.jl","text":"Current Version Documentation Build Status Citation\n(Image: ) (Image: ) (Image: Build Status) (Image: codecov.io) (Image: arXiv)","category":"page"},{"location":"packages/DisjunctiveProgramming/","page":"hdavid16/DisjunctiveProgramming.jl","title":"hdavid16/DisjunctiveProgramming.jl","text":"DisjunctiveProgramming builds upon JuMP to add support GDP modeling objects which include:","category":"page"},{"location":"packages/DisjunctiveProgramming/","page":"hdavid16/DisjunctiveProgramming.jl","title":"hdavid16/DisjunctiveProgramming.jl","text":"Logical variables (Y in textFalse textTrue)\nDisjunctions\nLogical constraints (also known as propositions)\nCardinality constraints","category":"page"},{"location":"packages/DisjunctiveProgramming/","page":"hdavid16/DisjunctiveProgramming.jl","title":"hdavid16/DisjunctiveProgramming.jl","text":"It also supports automatic conversion of the GDP model into a regular mixed-integer JuMP model  via a variety of reformulations which include:","category":"page"},{"location":"packages/DisjunctiveProgramming/","page":"hdavid16/DisjunctiveProgramming.jl","title":"hdavid16/DisjunctiveProgramming.jl","text":"Big-M\nHull\nIndicator constraints","category":"page"},{"location":"packages/DisjunctiveProgramming/","page":"hdavid16/DisjunctiveProgramming.jl","title":"hdavid16/DisjunctiveProgramming.jl","text":"Moreover, DisjunctiveProgramming provides an extension API to easily add new reformulation methods.","category":"page"},{"location":"packages/DisjunctiveProgramming/#License","page":"hdavid16/DisjunctiveProgramming.jl","title":"License","text":"","category":"section"},{"location":"packages/DisjunctiveProgramming/","page":"hdavid16/DisjunctiveProgramming.jl","title":"hdavid16/DisjunctiveProgramming.jl","text":"InfiniteOpt is licensed under the MIT \"Expat\" license.","category":"page"},{"location":"packages/DisjunctiveProgramming/#Installation","page":"hdavid16/DisjunctiveProgramming.jl","title":"Installation","text":"","category":"section"},{"location":"packages/DisjunctiveProgramming/","page":"hdavid16/DisjunctiveProgramming.jl","title":"hdavid16/DisjunctiveProgramming.jl","text":"DisjunctiveProgramming.jl is a registered Julia package and  can be installed by entering the following in the REPL.","category":"page"},{"location":"packages/DisjunctiveProgramming/","page":"hdavid16/DisjunctiveProgramming.jl","title":"hdavid16/DisjunctiveProgramming.jl","text":"julia> import Pkg; Pkg.add(\"DisjunctiveProgramming\")","category":"page"},{"location":"packages/DisjunctiveProgramming/#Documentation","page":"hdavid16/DisjunctiveProgramming.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/DisjunctiveProgramming/","page":"hdavid16/DisjunctiveProgramming.jl","title":"hdavid16/DisjunctiveProgramming.jl","text":"Please visit our documentation pages  to learn more.","category":"page"},{"location":"packages/DisjunctiveProgramming/#Citing","page":"hdavid16/DisjunctiveProgramming.jl","title":"Citing","text":"","category":"section"},{"location":"packages/DisjunctiveProgramming/","page":"hdavid16/DisjunctiveProgramming.jl","title":"hdavid16/DisjunctiveProgramming.jl","text":"(Image: arXiv)","category":"page"},{"location":"packages/DisjunctiveProgramming/","page":"hdavid16/DisjunctiveProgramming.jl","title":"hdavid16/DisjunctiveProgramming.jl","text":"If you use DisjunctiveProgramming.jl in your research, we would greatly appreciate your  citing it.","category":"page"},{"location":"packages/DisjunctiveProgramming/","page":"hdavid16/DisjunctiveProgramming.jl","title":"hdavid16/DisjunctiveProgramming.jl","text":"@article{perez2023disjunctiveprogramming,\n  title={DisjunctiveProgramming. jl: Generalized Disjunctive Programming Models and Algorithms for JuMP},\n  author={Perez, Hector D and Joshi, Shivank and Grossmann, Ignacio E},\n  journal={arXiv preprint arXiv:2304.10492},\n  year={2023}\n}","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/objective/#Objectives","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"This page describes macros and functions related to linear and quadratic objective functions only, unless otherwise indicated. For nonlinear objective functions, see Nonlinear Modeling.","category":"page"},{"location":"manual/objective/#Set-a-linear-objective","page":"Objectives","title":"Set a linear objective","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use the @objective macro to set a linear objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use Min to create a minimization objective:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @objective(model, Min, 2x + 1)\n2 x + 1","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use Max to create a maximization objective:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @objective(model, Max, 2x + 1)\n2 x + 1","category":"page"},{"location":"manual/objective/#Set-a-quadratic-objective","page":"Objectives","title":"Set a quadratic objective","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use the @objective macro to set a quadratic objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use ^2 to have a variable squared:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @objective(model, Min, x^2 + 2x + 1)\nx² + 2 x + 1","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"You can also have bilinear terms between variables:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @objective(model, Max, x * y + x + y)\nx*y + x + y","category":"page"},{"location":"manual/objective/#Set-a-nonlinear-objective","page":"Objectives","title":"Set a nonlinear objective","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use the @objective macro to set a nonlinear objective function:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> model = Model();\n\njulia> @variable(model, x <= 1);\n\njulia> @objective(model, Max, log(x))\nlog(x)","category":"page"},{"location":"manual/objective/#Query-the-objective-function","page":"Objectives","title":"Query the objective function","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use objective_function to return the current objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @objective(model, Min, 2x + 1)\n2 x + 1\n\njulia> objective_function(model)\n2 x + 1","category":"page"},{"location":"manual/objective/#Evaluate-the-objective-function-at-a-point","page":"Objectives","title":"Evaluate the objective function at a point","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use value to evaluate an objective function at a point specifying values for variables.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @objective(model, Min, 2x[1]^2 + x[1] + 0.5*x[2])\n2 x[1]² + x[1] + 0.5 x[2]\n\njulia> f = objective_function(model)\n2 x[1]² + x[1] + 0.5 x[2]\n\njulia> point = Dict(x[1] => 2.0, x[2] => 1.0);\n\njulia> value(z -> point[z], f)\n10.5","category":"page"},{"location":"manual/objective/#Query-the-objective-sense","page":"Objectives","title":"Query the objective sense","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use objective_sense to return the current objective sense.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @objective(model, Min, 2x + 1)\n2 x + 1\n\njulia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0","category":"page"},{"location":"manual/objective/#Modify-an-objective","page":"Objectives","title":"Modify an objective","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"To modify an objective, call @objective with the new objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @objective(model, Min, 2x)\n2 x\n\njulia> @objective(model, Max, -2x)\n-2 x","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Alternatively, use set_objective_function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @objective(model, Min, 2x)\n2 x\n\njulia> new_objective = @expression(model, -2 * x)\n-2 x\n\njulia> set_objective_function(model, new_objective)","category":"page"},{"location":"manual/objective/#Modify-an-objective-coefficient","page":"Objectives","title":"Modify an objective coefficient","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use set_objective_coefficient to modify an objective coefficient.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @objective(model, Min, 2x)\n2 x\n\njulia> set_objective_coefficient(model, x, 3)\n\njulia> objective_function(model)\n3 x","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use set_objective_coefficient with two variables to modify a quadratic objective coefficient:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @variable(model, y);\n\njulia> @objective(model, Min, x^2 + x * y)\nx² + x*y\n\njulia> set_objective_coefficient(model, x, x, 2)\n\njulia> set_objective_coefficient(model, x, y, 3)\n\njulia> objective_function(model)\n2 x² + 3 x*y","category":"page"},{"location":"manual/objective/#Modify-the-objective-sense","page":"Objectives","title":"Modify the objective sense","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use set_objective_sense to modify the objective sense.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @objective(model, Min, 2x)\n2 x\n\njulia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0\n\njulia> set_objective_sense(model, MAX_SENSE);\n\njulia> objective_sense(model)\nMAX_SENSE::OptimizationSense = 1","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Alternatively, call @objective and pass the existing objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @objective(model, Min, 2x)\n2 x\n\njulia> @objective(model, Max, objective_function(model))\n2 x","category":"page"},{"location":"manual/objective/#Set-a-vector-valued-objective","page":"Objectives","title":"Set a vector-valued objective","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Define a multi-objective optimization problem by passing a vector of objectives:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @objective(model, Min, [1 + x[1], 2 * x[2]])\n2-element Vector{AffExpr}:\n x[1] + 1\n 2 x[2]\n\njulia> f = objective_function(model)\n2-element Vector{AffExpr}:\n x[1] + 1\n 2 x[2]","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"tip: Tip\nThe Multi-objective knapsack tutorial provides an example of solving a multi-objective integer program.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"In most cases, multi-objective optimization solvers will return multiple solutions, corresponding to points on the Pareto frontier. See Multiple solutions for information on how to query and work with multiple solutions.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Note that you must set a single objective sense, that is, you cannot have both minimization and maximization objectives. Work around this limitation by choosing Min and negating any objectives you want to maximize:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @expression(model, obj1, 1 + x[1])\nx[1] + 1\n\njulia> @expression(model, obj2, 2 * x[1])\n2 x[1]\n\njulia> @objective(model, Min, [obj1, -obj2])\n2-element Vector{AffExpr}:\n x[1] + 1\n -2 x[1]","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Defining your objectives as expressions allows flexibility in how you can solve variations of the same problem, with some objectives removed and constrained to be no worse that a fixed value.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @expression(model, obj1, 1 + x[1])\nx[1] + 1\n\njulia> @expression(model, obj2, 2 * x[1])\n2 x[1]\n\njulia> @expression(model, obj3, x[1] + x[2])\nx[1] + x[2]\n\njulia> @objective(model, Min, [obj1, obj2, obj3])  # Three-objective problem\n3-element Vector{AffExpr}:\n x[1] + 1\n 2 x[1]\n x[1] + x[2]\n\njulia> # optimize!(model), look at the solution, talk to stakeholders, then\n       # decide you want to solve a new problem where the third objective is\n       # removed and constrained to be better than 2.0.\n       nothing\n\njulia> @objective(model, Min, [obj1, obj2])   # Two-objective problem\n2-element Vector{AffExpr}:\n x[1] + 1\n 2 x[1]\n\njulia> @constraint(model, obj3 <= 2.0)\nx[1] + x[2] ≤ 2","category":"page"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/reference/callbacks.md\"","category":"page"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"AbstractCallback\nAbstractSubmittable\nsubmit","category":"page"},{"location":"moi/reference/callbacks/#MathOptInterface.AbstractCallback","page":"Callbacks","title":"MathOptInterface.AbstractCallback","text":"abstract type AbstractCallback <: AbstractModelAttribute end\n\nAbstract type for a model attribute representing a callback function. The value set to subtypes of AbstractCallback is a function that may be called during optimize!. As optimize! is in progress, the result attributes (that is, the attributes attr such that is_set_by_optimize(attr)) may not be accessible from the callback, hence trying to get result attributes might throw a OptimizeInProgress error.\n\nAt most one callback of each type can be registered. If an optimizer already has a function for a callback type, and the user registers a new function, then the old one is replaced.\n\nThe value of the attribute should be a function taking only one argument, commonly called callback_data, that can be used for instance in LazyConstraintCallback, HeuristicCallback and UserCutCallback.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.AbstractSubmittable","page":"Callbacks","title":"MathOptInterface.AbstractSubmittable","text":"AbstractSubmittable\n\nAbstract supertype for objects that can be submitted to the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.submit","page":"Callbacks","title":"MathOptInterface.submit","text":"submit(\n    optimizer::AbstractOptimizer,\n    sub::AbstractSubmittable,\n    values...,\n)::Nothing\n\nSubmit values to the submittable sub of the optimizer optimizer.\n\nAn UnsupportedSubmittable error is thrown if model does not support the attribute attr (see supports) and a SubmitNotAllowed error is thrown if it supports the submittable sub but it cannot be submitted.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/callbacks/#Attributes","page":"Callbacks","title":"Attributes","text":"","category":"section"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"CallbackNodeStatus\nCallbackVariablePrimal\nCallbackNodeStatusCode\nCALLBACK_NODE_STATUS_INTEGER\nCALLBACK_NODE_STATUS_FRACTIONAL\nCALLBACK_NODE_STATUS_UNKNOWN","category":"page"},{"location":"moi/reference/callbacks/#MathOptInterface.CallbackNodeStatus","page":"Callbacks","title":"MathOptInterface.CallbackNodeStatus","text":"CallbackNodeStatus(callback_data)\n\nAn optimizer attribute describing the (in)feasibility of the primal solution available from CallbackVariablePrimal during a callback identified by callback_data.\n\nReturns a CallbackNodeStatusCode Enum.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.CallbackVariablePrimal","page":"Callbacks","title":"MathOptInterface.CallbackVariablePrimal","text":"CallbackVariablePrimal(callback_data)\n\nA variable attribute for the assignment to some primal variable's value during the callback identified by callback_data.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.CallbackNodeStatusCode","page":"Callbacks","title":"MathOptInterface.CallbackNodeStatusCode","text":"CallbackNodeStatusCode\n\nAn Enum of possible return values from calling get with CallbackNodeStatus.\n\nValues\n\nPossible values are:\n\nCALLBACK_NODE_STATUS_INTEGER: the primal solution available from CallbackVariablePrimal is integer feasible.\nCALLBACK_NODE_STATUS_FRACTIONAL: the primal solution available from CallbackVariablePrimal is integer infeasible.\nCALLBACK_NODE_STATUS_UNKNOWN: the primal solution available from CallbackVariablePrimal might be integer feasible or infeasible.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.CALLBACK_NODE_STATUS_INTEGER","page":"Callbacks","title":"MathOptInterface.CALLBACK_NODE_STATUS_INTEGER","text":"CALLBACK_NODE_STATUS_INTEGER::CallbackNodeStatusCode\n\nAn instance of the CallbackNodeStatusCode enum.\n\nCALLBACK_NODE_STATUS_INTEGER: the primal solution available from CallbackVariablePrimal is integer feasible.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/callbacks/#MathOptInterface.CALLBACK_NODE_STATUS_FRACTIONAL","page":"Callbacks","title":"MathOptInterface.CALLBACK_NODE_STATUS_FRACTIONAL","text":"CALLBACK_NODE_STATUS_FRACTIONAL::CallbackNodeStatusCode\n\nAn instance of the CallbackNodeStatusCode enum.\n\nCALLBACK_NODE_STATUS_FRACTIONAL: the primal solution available from CallbackVariablePrimal is integer infeasible.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/callbacks/#MathOptInterface.CALLBACK_NODE_STATUS_UNKNOWN","page":"Callbacks","title":"MathOptInterface.CALLBACK_NODE_STATUS_UNKNOWN","text":"CALLBACK_NODE_STATUS_UNKNOWN::CallbackNodeStatusCode\n\nAn instance of the CallbackNodeStatusCode enum.\n\nCALLBACK_NODE_STATUS_UNKNOWN: the primal solution available from CallbackVariablePrimal might be integer feasible or infeasible.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/callbacks/#Lazy-constraints","page":"Callbacks","title":"Lazy constraints","text":"","category":"section"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"LazyConstraintCallback\nLazyConstraint","category":"page"},{"location":"moi/reference/callbacks/#MathOptInterface.LazyConstraintCallback","page":"Callbacks","title":"MathOptInterface.LazyConstraintCallback","text":"LazyConstraintCallback() <: AbstractCallback\n\nThe callback can be used to reduce the feasible set given the current primal solution by submitting a LazyConstraint. For instance, it may be called at an incumbent of a mixed-integer problem. Note that there is no guarantee that the callback is called at every feasible primal solution.\n\nThe current primal solution is accessed through CallbackVariablePrimal. Trying to access other result attributes will throw OptimizeInProgress as discussed in AbstractCallback.\n\nExamples\n\nx = MOI.add_variables(optimizer, 8)\nMOI.set(optimizer, MOI.LazyConstraintCallback(), callback_data -> begin\n    sol = MOI.get(optimizer, MOI.CallbackVariablePrimal(callback_data), x)\n    if # should add a lazy constraint\n        func = # computes function\n        set = # computes set\n        MOI.submit(optimizer, MOI.LazyConstraint(callback_data), func, set)\n    end\nend)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.LazyConstraint","page":"Callbacks","title":"MathOptInterface.LazyConstraint","text":"LazyConstraint(callback_data)\n\nLazy constraint func-in-set submitted as func, set. The optimal solution returned by VariablePrimal will satisfy all lazy constraints that have been submitted.\n\nThis can be submitted only from the LazyConstraintCallback. The field callback_data is a solver-specific callback type that is passed as the argument to the feasible solution callback.\n\nExamples\n\nSuppose x and y are VariableIndexs of optimizer. To add a LazyConstraint for 2x + 3y <= 1, write\n\nfunc = 2.0x + 3.0y\nset = MOI.LessThan(1.0)\nMOI.submit(optimizer, MOI.LazyConstraint(callback_data), func, set)\n\ninside a LazyConstraintCallback of data callback_data.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#User-cuts","page":"Callbacks","title":"User cuts","text":"","category":"section"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"UserCutCallback\nUserCut","category":"page"},{"location":"moi/reference/callbacks/#MathOptInterface.UserCutCallback","page":"Callbacks","title":"MathOptInterface.UserCutCallback","text":"UserCutCallback() <: AbstractCallback\n\nThe callback can be used to submit UserCut given the current primal solution. For instance, it may be called at fractional (that is, non-integer) nodes in the branch and bound tree of a mixed-integer problem. Note that there is not guarantee that the callback is called everytime the solver has an infeasible solution.\n\nThe infeasible solution is accessed through CallbackVariablePrimal. Trying to access other result attributes will throw OptimizeInProgress as discussed in AbstractCallback.\n\nExamples\n\nx = MOI.add_variables(optimizer, 8)\nMOI.set(optimizer, MOI.UserCutCallback(), callback_data -> begin\n    sol = MOI.get(optimizer, MOI.CallbackVariablePrimal(callback_data), x)\n    if # can find a user cut\n        func = # computes function\n        set = # computes set\n        MOI.submit(optimizer, MOI.UserCut(callback_data), func, set)\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.UserCut","page":"Callbacks","title":"MathOptInterface.UserCut","text":"UserCut(callback_data)\n\nConstraint func-to-set suggested to help the solver detect the solution given by CallbackVariablePrimal as infeasible. The cut is submitted as func, set. Typically CallbackVariablePrimal will violate integrality constraints, and a cut would be of the form ScalarAffineFunction-in-LessThan or ScalarAffineFunction-in-GreaterThan. Note that, as opposed to LazyConstraint, the provided constraint cannot modify the feasible set, the constraint should be redundant, for example, it may be a consequence of affine and integrality constraints.\n\nThis can be submitted only from the UserCutCallback. The field callback_data is a solver-specific callback type that is passed as the argument to the infeasible solution callback.\n\nNote that the solver may silently ignore the provided constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#Heuristic-solutions","page":"Callbacks","title":"Heuristic solutions","text":"","category":"section"},{"location":"moi/reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"HeuristicCallback\nHeuristicSolution\nHeuristicSolutionStatus\nHEURISTIC_SOLUTION_ACCEPTED\nHEURISTIC_SOLUTION_REJECTED\nHEURISTIC_SOLUTION_UNKNOWN","category":"page"},{"location":"moi/reference/callbacks/#MathOptInterface.HeuristicCallback","page":"Callbacks","title":"MathOptInterface.HeuristicCallback","text":"HeuristicCallback() <: AbstractCallback\n\nThe callback can be used to submit HeuristicSolution given the current primal solution. For example, it may be called at fractional (that is, non-integer) nodes in the branch and bound tree of a mixed-integer problem. Note that there is no guarantee that the callback is called every time the solver has an infeasible solution.\n\nThe current primal solution is accessed through CallbackVariablePrimal. Trying to access other result attributes will throw OptimizeInProgress as discussed in AbstractCallback.\n\nExamples\n\nx = MOI.add_variables(optimizer, 8)\nMOI.set(optimizer, MOI.HeuristicCallback(), callback_data -> begin\n    sol = MOI.get(optimizer, MOI.CallbackVariablePrimal(callback_data), x)\n    if # can find a heuristic solution\n        values = # computes heuristic solution\n        MOI.submit(optimizer, MOI.HeuristicSolution(callback_data), x,\n                   values)\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.HeuristicSolution","page":"Callbacks","title":"MathOptInterface.HeuristicSolution","text":"HeuristicSolution(callback_data)\n\nHeuristically obtained feasible solution. The solution is submitted as variables, values where values[i] gives the value of variables[i], similarly to set. The submit call returns a HeuristicSolutionStatus indicating whether the provided solution was accepted or rejected.\n\nThis can be submitted only from the HeuristicCallback. The field callback_data is a solver-specific callback type that is passed as the argument to the heuristic callback.\n\nSome solvers require a complete solution, others only partial solutions.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.HeuristicSolutionStatus","page":"Callbacks","title":"MathOptInterface.HeuristicSolutionStatus","text":"HeuristicSolutionStatus\n\nAn Enum of possible return values for submit with HeuristicSolution. This informs whether the heuristic solution was accepted or rejected.\n\nValues\n\nPossible values are:\n\nHEURISTIC_SOLUTION_ACCEPTED: The heuristic solution was accepted\nHEURISTIC_SOLUTION_REJECTED: The heuristic solution was rejected\nHEURISTIC_SOLUTION_UNKNOWN: No information available on the acceptance\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/callbacks/#MathOptInterface.HEURISTIC_SOLUTION_ACCEPTED","page":"Callbacks","title":"MathOptInterface.HEURISTIC_SOLUTION_ACCEPTED","text":"HEURISTIC_SOLUTION_ACCEPTED::HeuristicSolutionStatus\n\nAn instance of the HeuristicSolutionStatus enum.\n\nHEURISTIC_SOLUTION_ACCEPTED: The heuristic solution was accepted\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/callbacks/#MathOptInterface.HEURISTIC_SOLUTION_REJECTED","page":"Callbacks","title":"MathOptInterface.HEURISTIC_SOLUTION_REJECTED","text":"HEURISTIC_SOLUTION_REJECTED::HeuristicSolutionStatus\n\nAn instance of the HeuristicSolutionStatus enum.\n\nHEURISTIC_SOLUTION_REJECTED: The heuristic solution was rejected\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/callbacks/#MathOptInterface.HEURISTIC_SOLUTION_UNKNOWN","page":"Callbacks","title":"MathOptInterface.HEURISTIC_SOLUTION_UNKNOWN","text":"HEURISTIC_SOLUTION_UNKNOWN::HeuristicSolutionStatus\n\nAn instance of the HeuristicSolutionStatus enum.\n\nHEURISTIC_SOLUTION_UNKNOWN: No information available on the acceptance\n\n\n\n\n\n","category":"constant"},{"location":"packages/SDDP/","page":"odow/SDDP.jl","title":"odow/SDDP.jl","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/v1.6.7/README.md\"","category":"page"},{"location":"packages/SDDP/","page":"odow/SDDP.jl","title":"odow/SDDP.jl","text":"<img src=\"https://raw.githubusercontent.com/odow/SDDP.jl/e9de84e0a4b57374bd9e0c95148da1501816e4c5/docs/src/assets/logo.png?raw=true\" alt=\"logo\" width=\"100px\"/>","category":"page"},{"location":"packages/SDDP/#SDDP.jl","page":"odow/SDDP.jl","title":"SDDP.jl","text":"","category":"section"},{"location":"packages/SDDP/","page":"odow/SDDP.jl","title":"odow/SDDP.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/SDDP/","page":"odow/SDDP.jl","title":"odow/SDDP.jl","text":"SDDP.jl is a JuMP extension for solving large convex multistage stochastic programming problems using stochastic dual dynamic programming.","category":"page"},{"location":"packages/SDDP/#License","page":"odow/SDDP.jl","title":"License","text":"","category":"section"},{"location":"packages/SDDP/","page":"odow/SDDP.jl","title":"odow/SDDP.jl","text":"SDDP.jl is licensed under the MPL 2.0 license.","category":"page"},{"location":"packages/SDDP/#Documentation","page":"odow/SDDP.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/SDDP/","page":"odow/SDDP.jl","title":"odow/SDDP.jl","text":"You can find the documentation at sddp.dev.","category":"page"},{"location":"packages/SDDP/#Help","page":"odow/SDDP.jl","title":"Help","text":"","category":"section"},{"location":"packages/SDDP/","page":"odow/SDDP.jl","title":"odow/SDDP.jl","text":"If you need help, please open a GitHub issue.","category":"page"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"EditURL = \"https://github.com/plasmo-dev/Plasmo.jl/blob/v0.5.4/README.md\"","category":"page"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"<img src=\"https://github.com/plasmo-dev/Plasmo.jl/blob/main/docs/plasmo_logo.svg?raw=true\"/>","category":"page"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"(Image: CI) (Image: codecov) (Image: ) (Image: DOI)","category":"page"},{"location":"packages/Plasmo/#Plasmo.jl","page":"plasmo-dev/Plasmo.jl","title":"Plasmo.jl","text":"","category":"section"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"Plasmo.jl (Platform for Scalable Modeling and Optimization) is a graph-based algebraic modeling framework that adopts a modular style to create mathematical optimization problems and manage distributed and hierarchical structures. The package has been developed as a JuMP extension and consequently supports  most JuMP syntax and functions. ","category":"page"},{"location":"packages/Plasmo/#Overview","page":"plasmo-dev/Plasmo.jl","title":"Overview","text":"","category":"section"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"The core data structure in Plasmo.jl is the OptiGraph. The optigraph contains a set of optinodes which represent self-contained optimization problems and optiedges that represent coupling between optinodes (which produces an underlying hypergraph structure of optinodes and optiedges). Optigraphs can further be embedded within other optigraphs to create nested hierarchical graph structures. The graph structures obtained using Plasmo.jl can be used for simple model and data management, but they can also be used to perform graph partitioning or develop interfaces to structured optimization solvers.","category":"page"},{"location":"packages/Plasmo/#License","page":"plasmo-dev/Plasmo.jl","title":"License","text":"","category":"section"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"Plasmo is licensed under the MPL 2.0 license.","category":"page"},{"location":"packages/Plasmo/#Installation","page":"plasmo-dev/Plasmo.jl","title":"Installation","text":"","category":"section"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"Install Plasmo using Pkg.add:","category":"page"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"import Pkg\nPkg.add(\"Plasmo\")","category":"page"},{"location":"packages/Plasmo/#Documentation","page":"plasmo-dev/Plasmo.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"The latest documentation is available through GitHub Pages. Additional examples can be found in the examples folder.","category":"page"},{"location":"packages/Plasmo/#Simple-Example","page":"plasmo-dev/Plasmo.jl","title":"Simple Example","text":"","category":"section"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"using Plasmo\nusing Ipopt\n\n#create an optigraph\ngraph = OptiGraph()\n\n#add nodes to an optigraph\n@optinode(graph, n1)\n@optinode(graph, n2)\n\n#add variables, constraints, and objective functions to nodes\n@variable(n1, 0 <= x <= 2)\n@variable(n1, 0 <= y <= 3)\n@constraint(n1, x+y <= 4)\n@objective(n1, Min, x)\n\n@variable(n2,x)\n@NLconstraint(n2, exp(x) >= 2)\n\n#add a linkconstraint to couple nodes\n@linkconstraint(graph, n1[:x] == n2[:x])\n\n#optimize with Ipopt\nset_optimizer(graph, Ipopt.Optimizer)\noptimize!(graph)\n\n#Print solution values\nprintln(\"n1[:x] = \", value(n1[:x]))\nprintln(\"n2[:x] = \", value(n2[:x]))","category":"page"},{"location":"packages/Plasmo/#Acknowledgments","page":"plasmo-dev/Plasmo.jl","title":"Acknowledgments","text":"","category":"section"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"This code is based on work supported by the following funding agencies:","category":"page"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"U.S. Department of Energy (DOE), Office of Science, under Contract No. DE-AC02-06CH11357\nDOE Office of Electricity Delivery and Energy Reliability’s Advanced Grid Research and Development program at Argonne National Laboratory\nNational Science Foundation under award NSF-EECS-1609183 and under award CBET-1748516","category":"page"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"The primary developer is Jordan Jalving (@jalving) with support from the following contributors.  ","category":"page"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"Victor Zavala (University of Wisconsin-Madison)\nYankai Cao (University of British Columbia)\nKibaek Kim (Argonne National Laboratory)\nSungho Shin (University of Wisconsin-Madison)","category":"page"},{"location":"packages/Plasmo/#Citing-Plasmo.jl","page":"plasmo-dev/Plasmo.jl","title":"Citing Plasmo.jl","text":"","category":"section"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"If you find Plasmo.jl useful for your work, you may cite the manuscript as:","category":"page"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"@article{JalvingShinZavala2022,\n  title={A Graph-Based Modeling Abstraction for Optimization: Concepts and Implementation in Plasmo.jl},\n  author={Jordan Jalving and Sungho Shin and Victor M. Zavala},\n  journal={Mathematical Programming Computation},\n  year={2022},\n  volume={14},\n  pages={699 - 747}\n}","category":"page"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"There is also a freely available pre-print:","category":"page"},{"location":"packages/Plasmo/","page":"plasmo-dev/Plasmo.jl","title":"plasmo-dev/Plasmo.jl","text":"@misc{JalvingShinZavala2020,\ntitle = {A Graph-Based Modeling Abstraction for Optimization: Concepts and Implementation in Plasmo.jl},\nauthor = {Jordan Jalving and Sungho Shin and Victor M. Zavala},\nyear = {2020},\neprint = {2006.05378},\narchivePrefix = {arXiv},\nprimaryClass = {math.OC}\n}","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"EditURL = \"https://github.com/jump-dev/MiniZinc.jl/blob/v0.3.8/README.md\"","category":"page"},{"location":"packages/MiniZinc/#MiniZinc.jl","page":"jump-dev/MiniZinc.jl","title":"MiniZinc.jl","text":"","category":"section"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"MiniZinc.jl is a wrapper for the MiniZinc constraint modeling language.","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"It provides a way to write MathOptInterface models to .mzn files, and a way to interact with libminizinc.","category":"page"},{"location":"packages/MiniZinc/#Affiliation","page":"jump-dev/MiniZinc.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"This wrapper is maintained by the JuMP community and is not part of the MiniZinc project.","category":"page"},{"location":"packages/MiniZinc/#License","page":"jump-dev/MiniZinc.jl","title":"License","text":"","category":"section"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"MiniZinc.jl is licensed under the MIT License.","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"The underlying project, MiniZinc/libminizinc, is licensed under the MPL 2.0 license.","category":"page"},{"location":"packages/MiniZinc/#Install","page":"jump-dev/MiniZinc.jl","title":"Install","text":"","category":"section"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"Install MiniZinc.jl using the Julia package manager:","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"import Pkg\nPkg.add(\"MiniZinc\")","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"Windows","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"On Linux and macOS, this package automatically installs libminizinc. However, we're still working out problems with the install on Windows. To use MiniZinc.jl, you'll need to manually install a copy of libminizinc from minizinc.org or compile one yourself from MiniZinc/libminizinc.","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"To teach MiniZinc.jl where to look for libminizinc, set the JULIA_LIBMINIZINC_DIR environment variable. For example:","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"ENV[\"JULIA_LIBMINIZINC_DIR\"] = \"C:\\\\Program Files\\\\MiniZinc\"","category":"page"},{"location":"packages/MiniZinc/#Use-with-MathOptInterface","page":"jump-dev/MiniZinc.jl","title":"Use with MathOptInterface","text":"","category":"section"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"MiniZinc.jl supports the constraint programming sets defined in MathOptInterface, as well as (in)equality constraints.","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"The following example solves the following constraint program:","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"xᵢ ∈ {1, 2, 3} ∀i=1,2,3\nzⱼ ∈ {0, 1}    ∀j=1,2\nz₁ <-> x₁ != x₂\nz₂ <-> x₂ != x₃\nz₁ + z₂ = 1","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"julia> import MiniZinc\n\njulia> import MathOptInterface as MOI\n\njulia> function main()\n           model = MOI.Utilities.CachingOptimizer(\n               MiniZinc.Model{Int}(),\n               MiniZinc.Optimizer{Int}(\"chuffed\"),\n           )\n           # xᵢ ∈ {1, 2, 3} ∀i=1,2,3\n           x = MOI.add_variables(model, 3)\n           MOI.add_constraint.(model, x, MOI.Interval(1, 3))\n           MOI.add_constraint.(model, x, MOI.Integer())\n           # zⱼ ∈ {0, 1}    ∀j=1,2\n           z = MOI.add_variables(model, 2)\n           MOI.add_constraint.(model, z, MOI.ZeroOne())\n           # z₁ <-> x₁ != x₂\n           MOI.add_constraint(\n               model,\n               MOI.VectorOfVariables([z[1], x[1], x[2]]),\n               MOI.Reified(MOI.AllDifferent(2)),\n           )\n           # z₂ <-> x₂ != x₃\n           MOI.add_constraint(\n               model,\n               MOI.VectorOfVariables([z[2], x[2], x[3]]),\n               MOI.Reified(MOI.AllDifferent(2)),\n           )\n           # z₁ + z₂ = 1\n           MOI.add_constraint(model, 1 * z[1] + x[2], MOI.EqualTo(1))\n           MOI.optimize!(model)\n           x_star = MOI.get(model, MOI.VariablePrimal(), x)\n           z_star = MOI.get(model, MOI.VariablePrimal(), z)\n           return x_star, z_star\n       end\nmain (generic function with 1 method)\n\njulia> main()\n([1, 1, 3], [0, 1])","category":"page"},{"location":"packages/MiniZinc/#Use-with-JuMP","page":"jump-dev/MiniZinc.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"You can also call MiniZinc from JuMP, using any solver that libminizinc supports. By default, MiniZinc.jl is compiled with the HiGHS MILP solver, which can be selected by passing the \"highs\" parameter to MiniZinc.Optimizer:","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"using JuMP\nimport MiniZinc\nmodel = Model(() -> MiniZinc.Optimizer{Float64}(\"highs\"))\n@variable(model, 1 <= x[1:3] <= 3, Int)\n@constraint(model, x in MOI.AllDifferent(3))\n@objective(model, Max, sum(i * x[i] for i in 1:3))\noptimize!(model)\n@show value.(x)","category":"page"},{"location":"packages/MiniZinc/#MathOptInterface-API","page":"jump-dev/MiniZinc.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"The MiniZinc Optimizer{T} supports the following constraints and attributes.","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"List of supported objective functions:","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"MOI.ObjectiveFunction{MOI.ScalarAffineFunction{T}}\nMOI.ObjectiveFunction{MOI.ScalarQuadraticFunction{T}}\nMOI.ObjectiveFunction{MOI.VariableIndex}","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"MOI.Reals","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"MOI.ScalarAffineFunction{T} in MOI.EqualTo{T}\nMOI.ScalarAffineFunction{T} in MOI.GreaterThan{T}\nMOI.ScalarAffineFunction{T} in MOI.Integer\nMOI.ScalarAffineFunction{T} in MOI.Interval{T}\nMOI.ScalarAffineFunction{T} in MOI.LessThan{T}\nMOI.ScalarAffineFunction{T} in MOI.ZeroOne\nMOI.VariableIndex in MOI.EqualTo{T}\nMOI.VariableIndex in MOI.GreaterThan{T}\nMOI.VariableIndex in MOI.Integer\nMOI.VariableIndex in MOI.Interval{T}\nMOI.VariableIndex in MOI.LessThan{T}\nMOI.VariableIndex in MOI.Parameter{T}\nMOI.VariableIndex in MOI.Semicontinuous{T}\nMOI.VariableIndex in MOI.Semiinteger{T}\nMOI.VariableIndex in MOI.ZeroOne\nMOI.VectorOfVariables in MOI.AllDifferent\nMOI.VectorOfVariables in MOI.BinPacking{T}\nMOI.VectorOfVariables in MOI.Circuit\nMOI.VectorOfVariables in MOI.CountAtLeast\nMOI.VectorOfVariables in MOI.CountBelongs\nMOI.VectorOfVariables in MOI.CountDistinct\nMOI.VectorOfVariables in MOI.CountGreaterThan\nMOI.VectorOfVariables in MOI.Cumulative\nMOI.VectorOfVariables in MOI.Path\nMOI.VectorOfVariables in MOI.Table{T}","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"MOI.NLPBlock()\nMOI.Name()\nMOI.ObjectiveSense()","category":"page"},{"location":"packages/MiniZinc/#Options","page":"jump-dev/MiniZinc.jl","title":"Options","text":"","category":"section"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"Set options using MOI.RawOptimizerAttribute in MOI or set_attribute in JuMP.","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"MiniZinc.jl supports the following options:","category":"page"},{"location":"packages/MiniZinc/","page":"jump-dev/MiniZinc.jl","title":"jump-dev/MiniZinc.jl","text":"model_filename::String = \"\": the location at which to write out the .mzn file during optimization. This option can be helpful during debugging. If left empty, a temporary file will be used instead.","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"EditURL = \"transp.jl\"","category":"page"},{"location":"tutorials/linear/transp/#The-transportation-problem","page":"The transportation problem","title":"The transportation problem","text":"","category":"section"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"This tutorial was originally contributed by Louis Luangkesorn.","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"This tutorial is an adaptation of the transportation problem described in AMPL: A Modeling Language for Mathematical Programming, by R. Fourer, D.M. Gay and B.W. Kernighan.","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"The purpose of this tutorial is to demonstrate how to create a JuMP model from an ad-hoc structured text file.","category":"page"},{"location":"tutorials/linear/transp/#Required-packages","page":"The transportation problem","title":"Required packages","text":"","category":"section"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"using JuMP\nimport DelimitedFiles\nimport HiGHS","category":"page"},{"location":"tutorials/linear/transp/#Formulation","page":"The transportation problem","title":"Formulation","text":"","category":"section"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"Suppose that we have a set of factories that produce pogo sticks, and a set of retail stores in which to sell them. Each factory has a maximum number of pogo sticks that it can produce, and each retail store has a demand of pogo sticks that it can sell.","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"In the transportation problem, we want to choose the number of pogo sticks to make and ship from each factory to each retail store that minimizes the total shipping cost.","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"Mathematically, we represent our set of factories by a set of origins i in O and our retail stores by a set of destinations j in D. The maximum supply at each factory is s_i and the demand from each retail store is d_j. The cost of shipping one pogo stick from i to j is c_ij.","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"With a little effort, we can model the transportation problem as the following linear program:","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"beginaligned\nmin   sum_i in O j in D c_ij x_ij \nst   sum_j in D x_i j le s_i  forall i in O \n       sum_i in O x_i j = d_j  forall j in D \n       x_i j ge 0  forall i in O j in D\nendaligned","category":"page"},{"location":"tutorials/linear/transp/#Data","page":"The transportation problem","title":"Data","text":"","category":"section"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"We assume our data is in the form of a text file that has the following form. In practice, we would obtain this text file from the user as input, but for the purpose of this tutorial we're going to create it from Julia.","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"open(joinpath(@__DIR__, \"transp.txt\"), \"w\") do io\n    print(\n        io,\n        \"\"\"\n             . FRA  DET LAN WIN  STL  FRE  LAF SUPPLY\n          GARY  39   14  11  14   16   82    8   1400\n          CLEV  27    .  12   .   26   95   17   2600\n          PITT  24   14  17  13   28   99   20   2900\n        DEMAND 900 1200 600 400 1700 1100 1000      0\n        \"\"\",\n    )\n    return\nend","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"Here the rows are the origins, the columns are the destinations, and the values are the cost of shipping one pogo stick from the origin to the destination. If pogo stick cannot be transported from a source to a destination, then the value is .. The final row and final column are the demand and supply of each location respectively.","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"We didn't account for arcs which do not exist in our formulation, but we can make a small change and fix x_ij = 0 if c_ij = .","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"Our first step is to convert this text format into an appropriate Julia datastructure that we can work with. Since our data is tabular with named rows and columns, one option is JuMP's Containers.DenseAxisArray object:","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"function read_data(filename::String)\n    data = DelimitedFiles.readdlm(filename)\n    rows, columns = data[2:end, 1], data[1, 2:end]\n    return Containers.DenseAxisArray(data[2:end, 2:end], rows, columns)\nend\n\ndata = read_data(joinpath(@__DIR__, \"transp.txt\"))","category":"page"},{"location":"tutorials/linear/transp/#JuMP-formulation","page":"The transportation problem","title":"JuMP formulation","text":"","category":"section"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"Following Design patterns for larger models, we code our JuMP model as a function which takes in an input. In this example, we print the output to stdout:","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"function solve_transportation_problem(data::Containers.DenseAxisArray)\n    # Get the set of supplies and demands\n    O, D = axes(data)\n    # Drop the SUPPLY and DEMAND nodes from our sets\n    O, D = setdiff(O, [\"DEMAND\"]), setdiff(D, [\"SUPPLY\"])\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    @variable(model, x[o in O, d in D] >= 0)\n    # Remove arcs with \".\" cost by fixing them to 0.0.\n    for o in O, d in D\n        if data[o, d] == \".\"\n            fix(x[o, d], 0.0; force = true)\n        end\n    end\n    @objective(\n        model,\n        Min,\n        sum(data[o, d] * x[o, d] for o in O, d in D if data[o, d] != \".\"),\n    )\n    @constraint(model, [o in O], sum(x[o, :]) <= data[o, \"SUPPLY\"])\n    @constraint(model, [d in D], sum(x[:, d]) == data[\"DEMAND\", d])\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    # Pretty print the solution in the format of the input\n    print(\"    \", join(lpad.(D, 7, ' ')))\n    for o in O\n        print(\"\\n\", o)\n        for d in D\n            if isapprox(value(x[o, d]), 0.0; atol = 1e-6)\n                print(\"      .\")\n            else\n                print(\" \", lpad(value(x[o, d]), 6, ' '))\n            end\n        end\n    end\n    return\nend","category":"page"},{"location":"tutorials/linear/transp/#Solution","page":"The transportation problem","title":"Solution","text":"","category":"section"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"Let's solve and view the solution:","category":"page"},{"location":"tutorials/linear/transp/","page":"The transportation problem","title":"The transportation problem","text":"solve_transportation_problem(data)","category":"page"},{"location":"moi/developer/checklists/","page":"Checklists","title":"Checklists","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/developer/checklists.md\"","category":"page"},{"location":"moi/developer/checklists/#Checklists","page":"Checklists","title":"Checklists","text":"","category":"section"},{"location":"moi/developer/checklists/","page":"Checklists","title":"Checklists","text":"The purpose of this page is to collate a series of checklists for commonly performed changes to the source code of MathOptInterface.","category":"page"},{"location":"moi/developer/checklists/","page":"Checklists","title":"Checklists","text":"In each case, copy the checklist into the description of the pull request.","category":"page"},{"location":"moi/developer/checklists/#Making-a-release","page":"Checklists","title":"Making a release","text":"","category":"section"},{"location":"moi/developer/checklists/","page":"Checklists","title":"Checklists","text":"Use this checklist when making a release of the MathOptInterface repository.","category":"page"},{"location":"moi/developer/checklists/","page":"Checklists","title":"Checklists","text":"## Basic\n\n - [ ] `version` field of `Project.toml` has been updated\n       - If a breaking change, increment the MAJOR field and reset others to 0\n       - If adding new features, increment the MINOR field and reset PATCH to 0\n       - If adding bug fixes or documentation changes, increment the PATCH field\n\n## Documentation\n\n - [ ] Add a new entry to `docs/src/changelog.md`, following existing style\n\n## Tests\n\n - [ ] The `solver-tests.yml` GitHub action does not have unexpected failures.\n       To run the action, go to:\n       https://github.com/jump-dev/MathOptInterface.jl/actions/workflows/solver-tests.yml\n       and click \"Run workflow\"","category":"page"},{"location":"moi/developer/checklists/#Adding-a-new-set","page":"Checklists","title":"Adding a new set","text":"","category":"section"},{"location":"moi/developer/checklists/","page":"Checklists","title":"Checklists","text":"Use this checklist when adding a new set to the MathOptInterface repository.","category":"page"},{"location":"moi/developer/checklists/","page":"Checklists","title":"Checklists","text":"## Basic\n\n - [ ] Add a new `AbstractScalarSet` or `AbstractVectorSet` to `src/sets.jl`\n - [ ] If `isbitstype(S) == false`, implement `Base.copy(set::S)`\n - [ ] If `isbitstype(S) == false`, implement `Base.:(==)(x::S, y::S)`\n - [ ] If an `AbstractVectorSet`, implement `dimension(set::S)`, unless the\n       dimension is given by `set.dimension`.\n\n## Utilities\n\n - [ ] If an `AbstractVectorSet`, implement `Utilities.set_dot`,\n       unless the dot product between two vectors in the set is equivalent to\n       `LinearAlgebra.dot`\n - [ ] If an `AbstractVectorSet`, implement `Utilities.set_with_dimension` in\n       `src/Utilities/matrix_of_constraints.jl`\n - [ ] Add the set to the `@model` macro at the bottom of `src/Utilities.model.jl`\n\n## Documentation\n\n - [ ] Add a docstring, which gives the mathematical definition of the set,\n       along with an `## Example` block containing a `jldoctest`\n - [ ] Add the docstring to `docs/src/reference/standard_form.md`\n - [ ] Add the set to the relevant table in `docs/src/manual/standard_form.md`\n\n## Tests\n\n - [ ] Define a new `_set(::Type{S})` method in `src/Test/test_basic_constraint.jl`\n       and add the name of the set to the list at the bottom of that files\n - [ ] If the set has any checks in its constructor, add tests to `test/sets.jl`\n\n## MathOptFormat\n\n - [ ] Open an issue at `https://github.com/jump-dev/MathOptFormat` to add\n       support for the new set {{ replace with link to the issue }}\n\n## Optional\n\n - [ ] Implement `dual_set(::S)` and `dual_set_type(::Type{S})`\n - [ ] Add new tests to the `Test` submodule exercising your new set\n - [ ] Add new bridges to convert your set into more commonly used sets","category":"page"},{"location":"moi/developer/checklists/#Adding-a-new-bridge","page":"Checklists","title":"Adding a new bridge","text":"","category":"section"},{"location":"moi/developer/checklists/","page":"Checklists","title":"Checklists","text":"Use this checklist when adding a new bridge to the MathOptInterface repository.","category":"page"},{"location":"moi/developer/checklists/","page":"Checklists","title":"Checklists","text":"The steps are mostly the same, but locations depend on whether the bridge is a Constraint, Objective, or Variable bridge. In each case below, replace XXX with the appropriate type of bridge.","category":"page"},{"location":"moi/developer/checklists/","page":"Checklists","title":"Checklists","text":"## Basic\n\n - [ ] Create a new file in `src/Bridges/XXX/bridges`\n - [ ] Define the bridge, following existing examples. The name of the bridge\n       struct must end in `Bridge`\n - [ ] Check if your bridge can be a subtype of [`MOI.Bridges.Constraint.SetMapBridge`](@ref)\n - [ ] Define a new `const` that is a `SingleBridgeOptimizer` wrapping the\n       new bridge. The name of the const must be the name of the bridge, less\n       the `Bridge` suffix\n - [ ] `include` the file in `src/Bridges/XXX/bridges/XXX.jl`\n - [ ] If the bridge should be enabled by default, add the bridge to\n       `add_all_bridges` at the bottom of `src/Bridges/XXX/XXX.jl`\n\n## Tests\n\n - [ ] Create a new file in the appropriate subdirectory of `tests/Bridges/XXX`\n - [ ] Use `MOI.Bridges.runtests` to test various inputs and outputs of the\n       bridge\n - [ ] If, after opening the pull request to add the bridge, some lines are not\n       covered by the tests, add additional bridge-specific tests to cover the\n       untested lines.\n\n## Documentation\n\n - [ ] Add a docstring which uses the same template as existing bridges.\n\n## Final touch\n\nIf the bridge depends on run-time values of other variables and constraints in\nthe model:\n\n - [ ] Implement `MOI.Utilities.needs_final_touch(::Bridge)`\n - [ ] Implement `MOI.Utilities.final_touch(::Bridge, ::MOI.ModelLike)`\n - [ ] Ensure that `final_touch` can be called multiple times in a row","category":"page"},{"location":"moi/developer/checklists/#Updating-MathOptFormat","page":"Checklists","title":"Updating MathOptFormat","text":"","category":"section"},{"location":"moi/developer/checklists/","page":"Checklists","title":"Checklists","text":"Use this checklist when updating the version of MathOptFormat.","category":"page"},{"location":"moi/developer/checklists/","page":"Checklists","title":"Checklists","text":"## Basic\n\n - [ ] The file at `src/FileFormats/MOF/mof.schema.json` is updated\n - [ ] The constant `_SUPPORTED_VERSIONS` is updated in\n       `src/FileFormats/MOF/MOF.jl`\n\n## New sets\n\n - [ ] New sets are added to the `@model` in `src/FileFormats/MOF/MOF.jl`\n - [ ] New sets are added to the `@enum` in `src/FileFormats/MOF/read.jl`\n - [ ] `set_to_moi` is defined for each set in `src/FileFormats/MOF/read.jl`\n - [ ] `head_name` is defined for each set in `src/FileFormats/MOF/write.jl`\n - [ ] A new unit test calling `_test_model_equality` is aded to\n       `test/FileFormats/MOF/MOF.jl`\n\n## Tests\n\n - [ ] The version field in `test/FileFormats/MOF/nlp.mof.json` is updated\n\n## Documentation\n\n - [ ] The version fields are updated in `docs/src/submodules/FileFormats/overview.md`","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"EditURL = \"https://github.com/jump-dev/SDPLR.jl/blob/v0.1.0/README.md\"","category":"page"},{"location":"packages/SDPLR/#SDPLR","page":"jump-dev/SDPLR.jl","title":"SDPLR","text":"","category":"section"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"SDPLR.jl is a wrapper for the SDPLR semidefinite programming solver.","category":"page"},{"location":"packages/SDPLR/#License","page":"jump-dev/SDPLR.jl","title":"License","text":"","category":"section"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"SDPLR.jl is licensed under the MIT License.","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"The underlying solver, SDPLR, is licensed under the GPL v2 license.","category":"page"},{"location":"packages/SDPLR/#Installation","page":"jump-dev/SDPLR.jl","title":"Installation","text":"","category":"section"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"Install SDPLR.jl using Pkg.add:","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"import Pkg\nPkg.add(\"SDPLR\")","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"In addition to installing the SDPLR.jl package, this will also download and install the SDPLR binaries. You do not need to install SDPLR separately.","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"To use a custom binary, read the Custom solver binaries section of the JuMP documentation.","category":"page"},{"location":"packages/SDPLR/#Use-with-JuMP","page":"jump-dev/SDPLR.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"To use SDPLR with JuMP, use SDPLR.Optimizer:","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"using JuMP, SDPLR\nmodel = Model(SDPLR.Optimizer)","category":"page"},{"location":"packages/SDPLR/#MathOptInterface-API","page":"jump-dev/SDPLR.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"The SDPLR optimizer supports the following constraints and attributes.","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"List of supported objective functions:","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"MOI.Nonnegatives\nMOI.PositiveSemidefiniteConeTriangle","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"MOI.ScalarAffineFunction{Float64} in MOI.EqualTo{Float64}","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"MOI.ObjectiveSense()","category":"page"},{"location":"packages/SDPLR/#Attributes","page":"jump-dev/SDPLR.jl","title":"Attributes","text":"","category":"section"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"The algorithm is parametrized by the attributes that can be used both with JuMP.set_attributes and JuMP.get_attributes and have the following types and default values:","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"rho_f::Cdouble = 1.0e-5\nrho_c::Cdouble = 1.0e-1\nsigmafac::Cdouble = 2.0\nrankreduce::Csize_t = 0\ntimelim::Csize_t = 3600\nprintlevel::Csize_t = 1\ndthresh_dim::Csize_t = 10\ndthresh_dens::Cdouble = 0.75\nnumbfgsvecs::Csize_t = 4\nrankredtol::Cdouble = 2.2204460492503131e-16\ngaptol::Cdouble = 1.0e-3\ncheckbd::Cptrdiff_t = -1\ntypebd::Cptrdiff_t = 1\nmaxrank::Function = default_maxrank","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"The following attributes can be also be used both with JuMP.set_attributes and JuMP.get_attributes, but they are also modified by optimize!:","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"majiter\niter\nlambdaupdate\ntotaltime\nsigma","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"When they are set, it provides the initial value of the algorithm. With get, they provide the value at the end of the algorithm. totaltime is the total time in second. For the other attributes, their meaning is best described by the following pseudo-code.","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"Given values of R, lambda and sigma, let vio = [dot(A[i], R * R') - b[i]) for i in 1:m] (vio[0] is dot(C, R * R') in the C implementation, but we ignore this entry here), val = dot(C, R * R') - dot(vio, lambda) + sigma/2 * norm(vio)^2, y = -lambda - sigma * vio, S = C + sum(A[i] * y[i] for i in 1:m) and the gradient is G = 2S * R. Note that norm(G) used in SDPLR when comparing with rho_c which has a 2-scaling difference from norm(S * R) used in the paper.","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"The SDPLR solvers implements the following algorithm.","category":"page"},{"location":"packages/SDPLR/","page":"jump-dev/SDPLR.jl","title":"jump-dev/SDPLR.jl","text":"sigma = inv(sum(size(A[i], 1) for i in 1:m))\norigval = val\nwhile majiter++ < 100_000\n    lambdaupdate = 0\n    localiter = 100\n    while localiter > 10\n        lambdaupdate += 1\n        localiter = 0\n        if norm(G) / (norm(C) + 1) <= rho_c / sigma\n            break\n        end\n        while norm(G) / (norm(C) + 1) - rho_c / sigma > eps()\n            localiter += 1\n            iter += 1\n            D = lbfgs(G)\n            R += linesearch(D) * D\n            if norm(vio) / (norm(b) + 1) <= rho_f || totaltime >= timelim || iter >= 10_000_000\n                return\n            end\n        end\n        lambda -= sigma * vio\n    end\n    if val - 1e10 * abs(origval) > eps()\n        return\n    end\n    if norm(vio) / (norm(b) + 1) <= rho_f || totaltime >= timelim || iter >= 10_000_000\n        return\n    end\n    while norm(G) / (norm(C) + 1) > rho_c / sigma\n        sigma *= 2\n    end\n    lambdaupdate = 0\nend","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"DocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"manual/expressions/#Expressions","page":"Expressions","title":"Expressions","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"JuMP has three types of expressions: affine, quadratic, and nonlinear. These expressions can be inserted into constraints or into the objective. This is particularly useful if an expression is used in multiple places in the model.","category":"page"},{"location":"manual/expressions/#Affine-expressions","page":"Expressions","title":"Affine expressions","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"There are four ways of constructing an affine expression in JuMP: with the @expression macro, with operator overloading, with the AffExpr constructor, and with add_to_expression!.","category":"page"},{"location":"manual/expressions/#Macros","page":"Expressions","title":"Macros","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"The recommended way to create an affine expression is via the @expression macro.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> ex = @expression(model, 2x + y - 1)\n2 x + y - 1","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"This expression can be used in the objective or added to a constraint. For example:","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> @objective(model, Min, 2 * ex - 1)\n4 x + 2 y - 3\n\njulia> objective_function(model)\n4 x + 2 y - 3","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Just like variables and constraints, named expressions can also be created. For example","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x[i = 1:3]);\n\njulia> @expression(model, expr[i = 1:3], i * sum(x[j] for j in i:3));\n\njulia> expr\n3-element Vector{AffExpr}:\n x[1] + x[2] + x[3]\n 2 x[2] + 2 x[3]\n 3 x[3]","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"tip: Tip\nYou can read more about containers in the Containers section.","category":"page"},{"location":"manual/expressions/#Operator-overloading","page":"Expressions","title":"Operator overloading","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Expressions can also be created without macros. However, note that in some cases, this can be much slower that constructing an expression using macros.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> ex = 2x + y - 1\n2 x + y - 1","category":"page"},{"location":"manual/expressions/#Constructors","page":"Expressions","title":"Constructors","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"A third way to create an affine expression is by the AffExpr constructor. The first argument is the constant term, and the remaining arguments are variable-coefficient pairs.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> ex = AffExpr(-1.0, x => 2.0, y => 1.0)\n2 x + y - 1","category":"page"},{"location":"manual/expressions/#add_to_expression!","page":"Expressions","title":"add_to_expression!","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"The fourth way to create an affine expression is by using add_to_expression!. Compared to the operator overloading method, this approach is faster because it avoids constructing temporary objects. The @expression macro uses add_to_expression! behind-the-scenes.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> ex = AffExpr(-1.0)\n-1\n\njulia> add_to_expression!(ex, 2.0, x)\n2 x - 1\n\njulia> add_to_expression!(ex, 1.0, y)\n2 x + y - 1","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"warning: Warning\nRead the section Initializing arrays for some cases to be careful about when using add_to_expression!.","category":"page"},{"location":"manual/expressions/#Removing-zero-terms","page":"Expressions","title":"Removing zero terms","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Use drop_zeros! to remove terms from an affine expression with a 0 coefficient.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @expression(model, ex, x + 1 - x)\n0 x + 1\n\njulia> drop_zeros!(ex)\n\njulia> ex\n1","category":"page"},{"location":"manual/expressions/#Coefficients","page":"Expressions","title":"Coefficients","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Use coefficient to return the coefficient associated with a variable in an affine expression.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @expression(model, ex, 2x + 1)\n2 x + 1\n\njulia> coefficient(ex, x)\n2.0\n\njulia> coefficient(ex, y)\n0.0","category":"page"},{"location":"manual/expressions/#Quadratic-expressions","page":"Expressions","title":"Quadratic expressions","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Like affine expressions, there are four ways of constructing a quadratic expression in JuMP: macros, operator overloading, constructors, and add_to_expression!.","category":"page"},{"location":"manual/expressions/#Macros-2","page":"Expressions","title":"Macros","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"The @expression macro can be used to create quadratic expressions by including quadratic terms.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> ex = @expression(model, x^2 + 2 * x * y + y^2 + x + y - 1)\nx² + 2 x*y + y² + x + y - 1","category":"page"},{"location":"manual/expressions/#Operator-overloading-2","page":"Expressions","title":"Operator overloading","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Operator overloading can also be used to create quadratic expressions. The same performance warning (discussed in the affine expression section) applies.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> ex = x^2 + 2 * x * y + y^2 + x + y - 1\nx² + 2 x*y + y² + x + y - 1","category":"page"},{"location":"manual/expressions/#Constructors-2","page":"Expressions","title":"Constructors","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Quadratic expressions can also be created using the QuadExpr constructor. The first argument is an affine expression, and the remaining arguments are pairs, where the first term is a JuMP.UnorderedPair and the second term is the coefficient.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> aff_expr = AffExpr(-1.0, x => 1.0, y => 1.0)\nx + y - 1\n\njulia> quad_expr = QuadExpr(\n           aff_expr,\n           UnorderedPair(x, x) => 1.0,\n           UnorderedPair(x, y) => 2.0,\n           UnorderedPair(y, y) => 1.0,\n       )\nx² + 2 x*y + y² + x + y - 1","category":"page"},{"location":"manual/expressions/#add_to_expression!-2","page":"Expressions","title":"add_to_expression!","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Finally, add_to_expression! can also be used to add quadratic terms.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> ex = QuadExpr(x + y - 1.0)\nx + y - 1\n\njulia> add_to_expression!(ex, 1.0, x, x)\nx² + x + y - 1\n\njulia> add_to_expression!(ex, 2.0, x, y)\nx² + 2 x*y + x + y - 1\n\njulia> add_to_expression!(ex, 1.0, y, y)\nx² + 2 x*y + y² + x + y - 1","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"warning: Warning\nRead the section Initializing arrays for some cases to be careful about when using add_to_expression!.","category":"page"},{"location":"manual/expressions/#Removing-zero-terms-2","page":"Expressions","title":"Removing zero terms","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Use drop_zeros! to remove terms from a quadratic expression with a 0 coefficient.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @expression(model, ex, x^2 + x + 1 - x^2)\n0 x² + x + 1\n\njulia> drop_zeros!(ex)\n\njulia> ex\nx + 1","category":"page"},{"location":"manual/expressions/#Coefficients-2","page":"Expressions","title":"Coefficients","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Use coefficient to return the coefficient associated with a pair of variables in a quadratic expression.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @expression(model, ex, 2*x*y + 3*x)\n2 x*y + 3 x\n\njulia> coefficient(ex, x, y)\n2.0\n\njulia> coefficient(ex, x, x)\n0.0\n\njulia> coefficient(ex, y, x)\n2.0\n\njulia> coefficient(ex, x)\n3.0","category":"page"},{"location":"manual/expressions/#Nonlinear-expressions","page":"Expressions","title":"Nonlinear expressions","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Nonlinear expressions in JuMP are represented by a NonlinearExpr object. See Nonlinear expressions in detail for more details.","category":"page"},{"location":"manual/expressions/#Initializing-arrays","page":"Expressions","title":"Initializing arrays","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"JuMP implements zero(AffExpr) and one(AffExpr) to support various functions in LinearAlgebra (for example, accessing the off-diagonal of a Diagonal matrix).","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> zero(AffExpr)\n0\n\njulia> one(AffExpr)\n1","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"However, this can result in a subtle bug if you call add_to_expression! or the MutableArithmetics API on an element created by zeros or ones:","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> x = zeros(AffExpr, 2)\n2-element Vector{AffExpr}:\n 0\n 0\n\njulia> add_to_expression!(x[1], 1.1)\n1.1\n\njulia> x\n2-element Vector{AffExpr}:\n 1.1\n 1.1","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Notice how we modified x[1], but we also changed x[2]!","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"This happened because zeros(AffExpr, 2) calls zero(AffExpr) once to obtain a zero element, and then creates an appropriately sized array filled with the same element.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"This also happens with broadcasting calls containing a conversion of 0 or 1:","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> x = Vector{AffExpr}(undef, 2)\n2-element Vector{AffExpr}:\n #undef\n #undef\n\njulia> x .= 0\n2-element Vector{AffExpr}:\n 0\n 0\n\njulia> add_to_expression!(x[1], 1.1)\n1.1\n\njulia> x\n2-element Vector{AffExpr}:\n 1.1\n 1.1","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"The recommended way to create an array of empty expressions is as follows:","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> x = Vector{AffExpr}(undef, 2)\n2-element Vector{AffExpr}:\n #undef\n #undef\n\njulia> for i in eachindex(x)\n           x[i] = AffExpr(0.0)\n       end\n\njulia> add_to_expression!(x[1], 1.1)\n1.1\n\njulia> x\n2-element Vector{AffExpr}:\n 1.1\n 0","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Alternatively, use non-mutating operation to avoid updating x[1] in-place:","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> x = zeros(AffExpr, 2)\n2-element Vector{AffExpr}:\n 0\n 0\n\njulia> x[1] += 1.1\n1.1\n\njulia> x\n2-element Vector{AffExpr}:\n 1.1\n 0","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Note that for large expressions this will be slower due to the allocation of additional temporary objects.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"EditURL = \"factory_schedule.jl\"","category":"page"},{"location":"tutorials/linear/factory_schedule/#The-factory-schedule-example","page":"The factory schedule example","title":"The factory schedule example","text":"","category":"section"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"This tutorial was originally contributed by @Crghilardi.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"This tutorial is a Julia translation of Part 5 from Introduction to Linear Programming with Python.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"The purpose of this tutorial is to demonstrate how to use DataFrames and delimited files, and to structure your code that is robust to infeasibilities and permits running with different datasets.","category":"page"},{"location":"tutorials/linear/factory_schedule/#Required-packages","page":"The factory schedule example","title":"Required packages","text":"","category":"section"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"This tutorial requires the following packages:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"using JuMP\nimport CSV\nimport DataFrames\nimport HiGHS\nimport StatsPlots","category":"page"},{"location":"tutorials/linear/factory_schedule/#Formulation","page":"The factory schedule example","title":"Formulation","text":"","category":"section"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"The Factory Scheduling Problem assumes we are optimizing the production of a good from factories f in F over the course of 12 months m in M.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"If a factory f runs during a month m, a fixed cost of a_f is incurred, the factory must produce x_mf units that is within some minimum and maximum production levels l_f and u_f respectively, and each unit of production incurs a variable cost c_f. Otherwise, the factory can be shut for the month with zero production and no fixed-cost is incurred. We denote the run/not-run decision by z_mf in 0 1, where z_mf is 1 if factory f runs in month m. The factory must produce enough units to satisfy demand d_m.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"With a little effort, we can formulate our problem as the following linear program:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"beginaligned\nmin  sumlimits_f in F m in M a_f z_mf + c_f x_mf \ntextst  x_mf le u_f z_mf  forall f in F m in M \n             x_mf ge l_f z_mf  forall f in F m in M \n             sumlimits_fin F x_mf = d_m  forall f in F m in M \n             z_mf in 0 1  forall f in F m in M\nendaligned","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"However, this formulation has a problem: if demand is too high, we may be unable to satisfy the demand constraint, and the problem will be infeasible.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"tip: Tip\nWhen modeling, consider ways to formulate your model such that it always has a feasible solution. This greatly simplifies debugging data errors that would otherwise result in an infeasible solution. In practice, most practical decisions have a feasible solution. In our case, we could satisfy demand (at a high cost) by buying replacement items for the buyer, or running the factories in overtime to make up the difference.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"We can improve our model by adding a new variable, delta_m, which represents the quantity of unmet demand in each month m. We penalize delta_m by an arbitrarily large value of $10,000/unit in the objective.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"beginaligned\nmin  sumlimits_f in F m in M a_f z_mf + c_f x_mf + sumlimits_m in M10000 delta_m \ntextst  x_mf le u_f z_mf  forall f in F m in M \n             x_mf ge l_f z_mf  forall f in F m in M \n             sumlimits_fin F x_mf - delta_m = d_m  forall f in F m in M \n             z_mf in 0 1  forall f in F m in M \n             delta_m ge 0  forall m in M\nendaligned","category":"page"},{"location":"tutorials/linear/factory_schedule/#Data","page":"The factory schedule example","title":"Data","text":"","category":"section"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"The JuMP GitHub repository contains two text files with the data we need for this tutorial.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"The first file contains a dataset of our factories, A and B, with their production and cost levels for each month. For the documentation, the file is located at:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"factories_filename = joinpath(@__DIR__, \"factory_schedule_factories.txt\");\nnothing #hide","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"To run locally, download factory_schedule_factories.txt and update factories_filename appropriately.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"The file has the following contents:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"print(read(factories_filename, String))","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"We use the CSV and DataFrames packages to read it into Julia:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"factory_df = CSV.read(\n    factories_filename,\n    DataFrames.DataFrame;\n    delim = ' ',\n    ignorerepeated = true,\n)","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"The second file contains the demand data by month:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"demand_filename = joinpath(@__DIR__, \"factory_schedule_demand.txt\");\nnothing #hide","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"To run locally, download factory_schedule_demand.txt and update demand_filename appropriately.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"demand_df = CSV.read(\n    demand_filename,\n    DataFrames.DataFrame;\n    delim = ' ',\n    ignorerepeated = true,\n)","category":"page"},{"location":"tutorials/linear/factory_schedule/#Data-validation","page":"The factory schedule example","title":"Data validation","text":"","category":"section"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"Before moving on, it's always good practice to validate the data you read from external sources. The more effort you spend here, the fewer issues you will have later. The following function contains a few simple checks, but we could add more. For example, you might want to check that none of the values are too large (or too small), which might indicate a typo or a unit conversion issue (perhaps the variable costs are in $/1000 units instead of $/unit).","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"function valiate_data(\n    demand_df::DataFrames.DataFrame,\n    factory_df::DataFrames.DataFrame,\n)\n    # Minimum production must not exceed maximum production.\n    @assert all(factory_df.min_production .<= factory_df.max_production)\n    # Demand, minimum production, fixed costs, and variable costs must all be\n    # non-negative.\n    @assert all(demand_df.demand .>= 0)\n    @assert all(factory_df.min_production .>= 0)\n    @assert all(factory_df.fixed_cost .>= 0)\n    @assert all(factory_df.variable_cost .>= 0)\n    return\nend\n\nvaliate_data(demand_df, factory_df)","category":"page"},{"location":"tutorials/linear/factory_schedule/#JuMP-formulation","page":"The factory schedule example","title":"JuMP formulation","text":"","category":"section"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"Next, we need to code our JuMP formulation. As shown in Design patterns for larger models, it's always good practice to code your model in a function that accepts well-defined input and returns well-defined output.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"function solve_factory_scheduling(\n    demand_df::DataFrames.DataFrame,\n    factory_df::DataFrames.DataFrame,\n)\n    # Even though we validated the data above, it's good practice to do it here\n    # too.\n    valiate_data(demand_df, factory_df)\n    months, factories = unique(factory_df.month), unique(factory_df.factory)\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    @variable(model, status[months, factories], Bin)\n    @variable(model, production[months, factories], Int)\n    @variable(model, unmet_demand[months] >= 0)\n    # We use `eachrow` to loop through the rows of the dataframe and add the\n    # relevant constraints.\n    for r in eachrow(factory_df)\n        m, f = r.month, r.factory\n        @constraint(model, production[m, f] <= r.max_production * status[m, f])\n        @constraint(model, production[m, f] >= r.min_production * status[m, f])\n    end\n    @constraint(\n        model,\n        [r in eachrow(demand_df)],\n        sum(production[r.month, :]) + unmet_demand[r.month] == r.demand,\n    )\n    @objective(\n        model,\n        Min,\n        10_000 * sum(unmet_demand) + sum(\n            r.fixed_cost * status[r.month, r.factory] +\n            r.variable_cost * production[r.month, r.factory] for\n            r in eachrow(factory_df)\n        )\n    )\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    schedules = Dict{Symbol,Vector{Float64}}(\n        Symbol(f) => value.(production[:, f]) for f in factories\n    )\n    schedules[:unmet_demand] = value.(unmet_demand)\n    return (\n        termination_status = termination_status(model),\n        cost = objective_value(model),\n        # This `select` statement re-orders the columns in the DataFrame.\n        schedules = DataFrames.select(\n            DataFrames.DataFrame(schedules),\n            [:unmet_demand, :A, :B],\n        ),\n    )\nend","category":"page"},{"location":"tutorials/linear/factory_schedule/#Solution","page":"The factory schedule example","title":"Solution","text":"","category":"section"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"Now we can call our solve_factory_scheduling function using the data we read in above.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"solution = solve_factory_scheduling(demand_df, factory_df);\nnothing #hide","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"Let's see what solution contains:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"solution.termination_status","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"solution.cost","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"solution.schedules","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"These schedules will be easier to visualize as a graph:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"StatsPlots.groupedbar(\n    Matrix(solution.schedules);\n    bar_position = :stack,\n    labels = [\"unmet demand\" \"A\" \"B\"],\n    xlabel = \"Month\",\n    ylabel = \"Production\",\n    legend = :topleft,\n    color = [\"#20326c\" \"#4063d8\" \"#a0b1ec\"],\n)","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"Note that we don't have any unmet demand.","category":"page"},{"location":"tutorials/linear/factory_schedule/#What-happens-if-demand-increases?","page":"The factory schedule example","title":"What happens if demand increases?","text":"","category":"section"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"Let's run an experiment by increasing the demand by 50% in all time periods:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"demand_df.demand .*= 1.5","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"Now we resolve the problem:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"high_demand_solution = solve_factory_scheduling(demand_df, factory_df);\nnothing #hide","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"and visualize the solution:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"StatsPlots.groupedbar(\n    Matrix(high_demand_solution.schedules);\n    bar_position = :stack,\n    labels = [\"unmet demand\" \"A\" \"B\"],\n    xlabel = \"Month\",\n    ylabel = \"Production\",\n    legend = :topleft,\n    color = [\"#20326c\" \"#4063d8\" \"#a0b1ec\"],\n)","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"Uh oh, we can't satisfy all of the demand.","category":"page"},{"location":"tutorials/linear/factory_schedule/#How-sensitive-is-the-solution-to-changes-in-variable-cost?","page":"The factory schedule example","title":"How sensitive is the solution to changes in variable cost?","text":"","category":"section"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"Let's run another experiment, this time seeing how the optimal objective value changes as we vary the variable costs of each factory.","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"First though, let's reset the demand to it's original level:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"demand_df.demand ./= 1.5;\nnothing #hide","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"For our experiment, we're going to scale the variable costs of both factories by a set of values from 0.0 to 1.5:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"scale_factors = 0:0.1:1.5","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"At a high level, we're going to loop over the scale factors for A, then the scale factors for B, rescale the input data, call our solve_factory_scheduling example, and then store the optimal objective value in the following cost matrix:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"cost = zeros(length(scale_factors), length(scale_factors));\nnothing #hide","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"Because we're modifying factory_df in-place, we need to store the original variable costs in a new column:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"factory_df[!, :old_variable_cost] = copy(factory_df.variable_cost);\nnothing #hide","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"Then, we need a function to scale the :variable_cost column for a particular factory by a value scale:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"function scale_variable_cost(df, factory, scale)\n    rows = df.factory .== factory\n    df[rows, :variable_cost] .=\n        round.(Int, df[rows, :old_variable_cost] .* scale)\n    return\nend","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"Our experiment is just a nested for-loop, modifying A and B and storing the cost:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"for (j, a) in enumerate(scale_factors)\n    scale_variable_cost(factory_df, \"A\", a)\n    for (i, b) in enumerate(scale_factors)\n        scale_variable_cost(factory_df, \"B\", b)\n        cost[i, j] = solve_factory_scheduling(demand_df, factory_df).cost\n    end\nend","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"Let's visualize the cost matrix:","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"StatsPlots.contour(\n    scale_factors,\n    scale_factors,\n    cost;\n    xlabel = \"Scale of factory A\",\n    ylabel = \"Scale of factory B\",\n)","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"What can you infer from the solution?","category":"page"},{"location":"tutorials/linear/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"info: Info\nThe Power Systems tutorial explains a number of other ways you can structure a problem to perform a parametric analysis of the solution. In particular, you can use in-place modification to reduce the time it takes to build and solve the resulting models.","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"EditURL = \"changelog.md\"","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"CurrentModule = JuMP","category":"page"},{"location":"release_notes/#Release-notes","page":"Release notes","title":"Release notes","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"release_notes/#[Version-1.22.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.22.0)-(May-12,-2024)","page":"Release notes","title":"Version 1.22.0 (May 12, 2024)","text":"","category":"section"},{"location":"release_notes/#Added","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added Base.complex(r, i) where r and i may be real-valued variables or affine or quadratic expressions (#3734)\nAdded @force_nonlinear for controlling when affine and quadratic expressions are instead parsed as nonlinear expressions. This can be useful for advanced users in a limited set of circumstances. (#3732)\nAdded support for returning the variable coefficients of a vector-valued constraint via normalized_coefficient. In addition, set_normalized_coefficients has been softly deprecated (no warning is thrown and old code will still work for all future 1.X releases of JuMP) in favor of set_normalized_coefficient. This change was made to unify how we get and set variable coefficients. (#3743)","category":"page"},{"location":"release_notes/#Fixed","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed missing promote_operation method that resulted in slow code (#3730)\nImproved performance of getindex for Containers.DenseAxisArray (#3731)\nFixed the error message when the legacy nonlinear API is mixed with the new nonlinear API. In particular, we now uniformly throw an error message when unexpected objects occur in nonlinear expressions. (#3741)","category":"page"},{"location":"release_notes/#Other","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Updated documentation (#3727), (#3728), (#3739)\nUpdated versions in GitHub actions (#3735)","category":"page"},{"location":"release_notes/#[Version-1.21.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.21.1)-(April-11,-2024)","page":"Release notes","title":"Version 1.21.1 (April 11, 2024)","text":"","category":"section"},{"location":"release_notes/#Fixed-2","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed behavior of complex-value related functions like real, imag, conj and abs2 when called on GenericNonlinearExpr. This fixes a method error when calling x' where x is an array of nonlinear expressions. As a related consequence, we now always error when creating nonlinear expressions with complex components. Previously, only some constructors were checked for complex expressionns. (#3724)","category":"page"},{"location":"release_notes/#Other-2","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Documentation improvements (#3719) (#3720) (#3721) (#3722)","category":"page"},{"location":"release_notes/#[Version-1.21.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.21.0)-(March-31,-2024)","page":"Release notes","title":"Version 1.21.0 (March 31, 2024)","text":"","category":"section"},{"location":"release_notes/#Added-2","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added support for matrix inequality constraints with the HermitianPSDCone (#3705)\nAdded batched modification methods for set_normalized_rhs, set_objective_coefficient and set_normalized_coefficient. Using these methods can be more efficient for some solvers (#3716)\nAdded the private constant _CONSTRAINT_LIMIT_FOR_PRINTING, which controls how many constraints are printed to the screen during print(model). The main purpose of this is to prevent large quantities of text being printed when print(model) is accidentally called on a large model. (#3686)","category":"page"},{"location":"release_notes/#Fixed-3","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Changed Containers.SparseAxisArray to use an OrderedDict as the backing data structure. Iterating over the elements in a SparseAxisArray now iterates in the order that the elements were created. Previously, the order was undefined behavior. (#3681)\nFixed complex variables for non-Float64 coefficient types (#3691)\nFixed LinearAlgebra.hermitan(::AbstractJuMPScalar) (#3693)\nFixed multiplying real scalar by Hermitian matrix (#3695)","category":"page"},{"location":"release_notes/#Other-3","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Documentation improvements (#3679) (#3683) (#3702) (#3703) (#3706) (#3696) (#3708) (#3709) (#3711)\nAdded new tutorials:\nBasis matrices (#3675)\nTransitioning from MATLAB (#3698)\nAutomatic differentiation of user-defined operators (#3713)\nUpdated versions and compat bounds (#3687) (#3707) (#3717)","category":"page"},{"location":"release_notes/#[Version-1.20.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.20.0)-(February-15,-2024)","page":"Release notes","title":"Version 1.20.0 (February 15, 2024)","text":"","category":"section"},{"location":"release_notes/#Added-3","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added is_solved_and_feasible (#3668)\nAdded support for MOI.ModelLike as the optimizer (#3667)","category":"page"},{"location":"release_notes/#Fixed-4","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed compat of DimensionalData (#3666)\nFixed convert(::Type{NonlinearExpr}, ::Number)(#3672)","category":"page"},{"location":"release_notes/#Other-4","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added Optim to list of solvers (#3624)\nImproved linking within documentation (#3669)","category":"page"},{"location":"release_notes/#[Version-1.19.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.19.0)-(February-1,-2024)","page":"Release notes","title":"Version 1.19.0 (February 1, 2024)","text":"","category":"section"},{"location":"release_notes/#Added-4","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added support for modifying quadratic coefficients (#3658)","category":"page"},{"location":"release_notes/#Fixed-5","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed short circuiting of && and || in macros (#3655)","category":"page"},{"location":"release_notes/#Other-5","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added SDPLR to list of solvers (#3644)\nAdded new roadmap items (#3645)\nFixed vale.sh version (#3650)\nImprove error messages in macros (#3653)\nRefactoring of set_normalized_coefficient (#3660) (#3661)\nUpdate docs/packages.toml (#3662)","category":"page"},{"location":"release_notes/#[Version-1.18.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.18.1)-(January-6,-2024)","page":"Release notes","title":"Version 1.18.1 (January 6, 2024)","text":"","category":"section"},{"location":"release_notes/#Fixed-6","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed escaping of the set keyword in @variable (#3647)","category":"page"},{"location":"release_notes/#[Version-1.18.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.18.0)-(January-2,-2024)","page":"Release notes","title":"Version 1.18.0 (January 2, 2024)","text":"","category":"section"},{"location":"release_notes/#Added-5","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"This release includes a large refactoring of the macro code that closes a roadmap item (#3629) Contributing pull requests include (#3600), (#3603), (#3606), (#3607), (#3610), (#3611), (#3612), (#3613), (#3614), (#3615), (#3617), (#3618), (#3619), (#3620), (#3621), (#3631), (#3632), (#3633)","category":"page"},{"location":"release_notes/#Fixed-7","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed error for unsupported objective sense (#3601)\nFixed text/latex printing of GenericNonlinearExpr (#3609)\nFixed compat bounds of stdlib packages (#3626)\nFixed a bug that can accidentally modify the user's expressions in a macro (#3639)\nFixed a bug converting AffExpr to GenericNonlinearExpr (#3642)","category":"page"},{"location":"release_notes/#Other-6","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added DisjunctiveProgrammingto extension-tests (#3597)\nAdded DisjunctiveProgrammingto docs (#3598)\nAdded DocumenterCitations to the docs (#3596), (#3630)\nMigrate from SnoopPrecompile to PrecompileTools (#3608)\nMinor documentation updates (#3623), (#3628), (#3635), (#3640), (#3643)","category":"page"},{"location":"release_notes/#[Version-1.17.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.17.0)-(December-4,-2023)","page":"Release notes","title":"Version 1.17.0 (December 4, 2023)","text":"","category":"section"},{"location":"release_notes/#Added-6","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added start_value, lower_bound, and upper_bound support for GenericAffExpr that are equivalent to a single GenericVariableRef (#3551)\nAdded SkipModelConvertScalarSetWrapper which is useful for extensions looking to avoid model_convert (#3552) (#3592)\nAdded lp_matrix_data (#3573) (#3591)","category":"page"},{"location":"release_notes/#Fixed-8","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed variable_ref_type for unsupported types (#3556)\nFixed convert type of constraint starting values (#3571)\nFixed various methods to support AbstractJuMPScalar with Distances.jl (#3583)\nFixed eachindex for multiple arguments of Containers.DenseAxisArray and Containers.SparseAxisArray (#3587)\nExpressions with more than 60 terms now print in truncated form. This prevents large expressions from being accidentally printed to terminal or IJulia output (#3575)\nFixed a type instability in set_objective_coefficient (#3590)\nVarious fixes to the documentation (#3593) (#3595)","category":"page"},{"location":"release_notes/#Other-7","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Improved error messages for:\nAddition and subtraction between a matrix and a scalar (#3557) (#3558)\nVariables with non-constant bounds (#3583)\nInvalid indicator constraints (#3584)\nAdded new solvers to the documentation:\nEAGO.jl (#3560) (#3561)\nManopt.jl (#3568)\nPercival.jl (#3567)\nAdded new tutorials:\nApproximating nonlinear functions (#3563)\nClassifiers (#3569)\nImproved documentation for:\nSemicontinuous and Semiinteger variables (#3562)\nSOS1 and SOS2 (#3565)\nstart_value of HermitianPSDCone (#3564)\nFunction tracing (#3570)\nNonlinear operators with vector arguments (#3577)\nIndicator constraints (#3582)\nUpdated package compat bounds (#3578)","category":"page"},{"location":"release_notes/#[Version-1.16.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.16.0)-(October-24,-2023)","page":"Release notes","title":"Version 1.16.0 (October 24, 2023)","text":"","category":"section"},{"location":"release_notes/#Added-7","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added := operator for Boolean satisfiability problems (#3530)","category":"page"},{"location":"release_notes/#Fixed-9","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed text/latex printing of MOI.Interval sets (#3537)\nFixed tests with duplicate function names (#3539)","category":"page"},{"location":"release_notes/#Other-8","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Updated documentation list of supported solvers (#3527) (#3529) (#3538) (#3542) (#3545) (#3546)\nUpdated to Documenter@1.1 (#3528)\nFixed various tutorials (#3534) (#3532)\nFixed Project.toml compat bounds for standard libraries (#3544)","category":"page"},{"location":"release_notes/#[Version-1.15.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.15.1)-(September-24,-2023)","page":"Release notes","title":"Version 1.15.1 (September 24, 2023)","text":"","category":"section"},{"location":"release_notes/#Fixed-10","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed support for single argument min and max operators (#3522)\nFixed error message for add_to_expression! when called with a GenericNonlinearExpr (#3506)\nFixed constraint tags with broadcasted constraints (#3515)\nFixed MethodError in MA.scaling (#3518)\nFixed support for arrays of Parameter variables (#3524)","category":"page"},{"location":"release_notes/#Other-9","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Updated to Documenter@1 (#3501)\nFixed links to data in tutorials (#3512)\nFixed typo in TSP tutorial (#3516)\nImproved error message for VariableNotOwned errors (#3520)\nFixed various JET errors (#3519)","category":"page"},{"location":"release_notes/#[Version-1.15.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.15.0)-(September-15,-2023)","page":"Release notes","title":"Version 1.15.0 (September 15, 2023)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"This is a large minor release because it adds an entirely new data structure and API path for working with nonlinear programs. The previous nonlinear interface remains unchanged and is documented at Nonlinear Modeling (Legacy). The new interface is a treated as a non-breaking feature addition and is documented at Nonlinear Modeling.","category":"page"},{"location":"release_notes/#Breaking","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Although the new nonlinear interface is a feature addition, there are two changes which might be breaking for a very small number of users.","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The syntax inside JuMP macros is parsed using a different code path, even for linear and quadratic expressions. We made this change to unify how we parse linear, quadratic, and nonlinear expressions. In all cases, the new code returns equivalent expressions, but because of the different order of operations, there are three changes to be aware of when updating:\nThe printed form of the expression may change, for example from x * y to y * x. This can cause tests which test the String representation of a model to fail.\nSome coefficients may change slightly due to floating point round-off error.\nParticularly when working with a JuMP extension, you may encounter a MethodError due to a missing or ambiguous method. These errors are due to previously existing bugs that were not triggered by the previous parsing code. If you encounter such an error, please open a GitHub issue.\nThe methods for Base.:^(x::VariableRef, n::Integer) and Base.:^(x::AffExpr, n::Integer) have changed. Previously, these methods supported only n = 0, 1, 2 and they always returned a QuadExpr, even for the case when n = 0 or n = 1. Now:\nx^0 returns one(T), where T is the value_type of the model (defaults to Float64)\nx^1 returns x\nx^2 returns a QuadExpr\nx^n where !(0 <= n <= 2) returns a NonlinearExpr.\nWe made this change to support nonlinear expressions and to align the mathematical definition of the operation with their return type. (Previously, users were surprised that x^1 returned a QuadExpr.) As a consequence of this change, the methods are now not type-stable. This means that the compiler cannot prove that x^2 returns a QuadExpr. If benchmarking shows that this is a performance problem, you can use the type-stable x * x instead of x^2.","category":"page"},{"location":"release_notes/#Added-8","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added triangle_vec which simplifies adding MOI.LogDetConeTriangle and MOI.RootDetConeTriangle constraints (#3456)\nAdded the new nonlinear interface. This is a very large change. See the documentation at Nonlinear Modeling and the (long) discussion in JuMP.jl#3106. Related PRs are (#3468) (#3472) (#3475) (#3483) (#3487) (#3488) (#3489) (#3504) (#3509)","category":"page"},{"location":"release_notes/#Fixed-11","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed uses of @nospecialize which cause precompilation failures in Julia v1.6.0 and v1.6.1. (#3464)\nFixed adding a container of Parameter (#3473)\nFixed return type of x^0 and x^1 to no longer return QuadExpr (see note in Breaking section above) (#3474)\nFixed error messages in LowerBoundRef, UpperBoundRef, FixRef, IntegerRef, BinaryRef, ParameterRef and related functions (#3494)\nFixed type inference of empty containers in JuMP macros (#3500)","category":"page"},{"location":"release_notes/#Other-10","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added GAMS to solver documentation (#3357)\nUpdated various tutorials (#3459) (#3460) (#3462) (#3463) (#3465) (#3490) (#3492) (#3503)\nAdded The network multi-commodity flow problem tutorial (#3491)\nAdded Two-stage stochastic programs tutorial (#3466)\nAdded better error messages for unsupported operations in LinearAlgebra (#3476)\nUpdated to the latest version of Documenter (#3484) (#3495) (#3497)\nUpdated GitHub action versions (#3507)","category":"page"},{"location":"release_notes/#[Version-1.14.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.14.1)-(September-2,-2023)","page":"Release notes","title":"Version 1.14.1 (September 2, 2023)","text":"","category":"section"},{"location":"release_notes/#Fixed-12","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix links in Documentation (#3478)","category":"page"},{"location":"release_notes/#[Version-1.14.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.14.0)-(August-27,-2023)","page":"Release notes","title":"Version 1.14.0 (August 27, 2023)","text":"","category":"section"},{"location":"release_notes/#Added-9","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added DimensionalData.jl extension (#3413)\nAdded syntactic sugar for the MOI.Parameter set (#3443)\nParameter\nParameterRef\nis_parameter\nparameter_value\nset_parameter_value","category":"page"},{"location":"release_notes/#Fixed-13","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed model_convert for BridgeableConstraint (#3437)\nFixed printing models with integer coefficients larger than typemax(Int) (#3447)\nFixed support for constant left-hand side functions in a complementarity constraint (#3452)","category":"page"},{"location":"release_notes/#Other-11","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Updated packages used in documentation (#3444) (#3455)\nFixed docstring tests (#3445)\nFixed printing change for MathOptInterface (#3446)\nFixed typos in documentation (#3448) (#3457)\nAdded SCIP to callback documentation (#3449)","category":"page"},{"location":"release_notes/#[Version-1.13.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.13.0)-(July-27,-2023)","page":"Release notes","title":"Version 1.13.0 (July 27, 2023)","text":"","category":"section"},{"location":"release_notes/#Added-10","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added support for generic number types (#3377) (#3385)\nAdded fallback for MOI.AbstractSymmetricMatrixSetTriangle and MOI.AbstractSymmetricMatrixSetSquare (#3424)","category":"page"},{"location":"release_notes/#Fixed-14","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed set_start_values with MOI.Bridges.Objective.SlackBridge (#3422)\nFixed flakey doctest in variables.md (#3425)\nFixed names on CITATION.bib (#3423)","category":"page"},{"location":"release_notes/#Other-12","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added Loraine.jl to the installation table (#3426)\nRemoved Penopt.jl from packages.toml (#3428)\nImproved problem statement in cannery example of tutorial (#3430)\nMinor cleanups in Containers.DenseAxisArray implementation (#3429)\nChanged nested_problems.jl: outer/inner to upper/lower (#3433)\nRemoved second SDP relaxation in OPF tutorial (#3432)","category":"page"},{"location":"release_notes/#[Version-1.12.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.12.0)-(June-19,-2023)","page":"Release notes","title":"Version 1.12.0 (June 19, 2023)","text":"","category":"section"},{"location":"release_notes/#Added-11","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added coefficient_type keyword argument to add_bridge and remove_bridge (#3394)","category":"page"},{"location":"release_notes/#Fixed-15","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed error message for matrix in HermitianPSDCone (#3369)\nFixed EditURL for custom documentation pages (#3373)\nFixed return type annotations for MOI.ConstraintPrimal and MOI.ConstraintDual (#3381)\nFixed printing change in Julia nightly (#3391)\nFixed printing of Complex coefficients (#3397)\nFixed printing of constraints in text/latex mode (#3405)\nFixed performance issue in Containers.rowtable (#3410)\nFixed bug when variables added to set of wrong dimension (#3411)","category":"page"},{"location":"release_notes/#Other-13","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added more solver READMEs to the documentation (#3358) (#3360) (#3364) (#3365) (#3366) (#3368) (#3372) (#3374) (#3376) (#3379) (#3387) (#3389)\nAdded StatusSwitchingQP.jl to the installation table (#3354)\nUpdated checklist for adding a new solver (#3370)\nUpdated extension-tests.yml action (#3371) (#3375)\nColor logs in GitHub actions (#3392)\nAdded new tutorials\nOptimal power flow (#3395) (#3412)\nLovász numbers (#3399)\nDualization (#3402)\nUpdated JuMP paper citation (#3400)\nChanged GitHub action to upload LaTeX logs when building documentation (#3403)\nFixed printing of SCS log in documentation (#3406)\nUpdated solver versions (#3407)\nUpdated documentation to use Julia v1.9 (#3398)\nReplaced _value_type with MOI.Utilities.value_type (#3414)\nFixed a typo in docstring (#3415)\nRefactored API documentation (#3386)\nUpdated SCIP license (#3420)","category":"page"},{"location":"release_notes/#[Version-1.11.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.11.1)-(May-19,-2023)","page":"Release notes","title":"Version 1.11.1 (May 19, 2023)","text":"","category":"section"},{"location":"release_notes/#Fixed-16","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a poor error message when sum(::DenseAxisArray; dims) was called (#3338)\nFixed support for dependent sets in the @variable macro (#3344)\nFixed a performance bug in constraints with sparse symmetric matrices (#3349)","category":"page"},{"location":"release_notes/#Other-14","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Improved the printing of complex numbers (#3332)\nWhen printing, sets which contain constants ending in .0 now print as integers. This follows the behavior of constants in functions (#3341)\nAdded InfiniteOpt to the extensions documentation (#3343)\nAdded more documentation for the exponential cone (#3345) (#3347)\nAdded checklists for developers (#3346) (#3355)\nFixed test support upcoming Julia nightly (#3351)\nFixed extension-tests.yml action (#3353)\nAdd more solvers to the documentation (#3359) (#3361) (#3362)","category":"page"},{"location":"release_notes/#[Version-1.11.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.11.0)-(May-3,-2023)","page":"Release notes","title":"Version 1.11.0 (May 3, 2023)","text":"","category":"section"},{"location":"release_notes/#Added-12","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added new methods to print_active_bridges for printing a particular objective, constraint, or variable (#3316)","category":"page"},{"location":"release_notes/#Fixed-17","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed tests for MOI v1.14.0 release (#3312)\nFixed indexing containers when an axis is Vector{Any} that contains a Vector{Any} element (#3280)\nFixed getindex(::AbstractJuMPScalar) which is called for an expression like x[] (#3314)\nFixed bug in set_string_names_on_creation with a vector of variables (#3322)\nFixed bug in memoize function in nonlinear documentation (#3337)","category":"page"},{"location":"release_notes/#Other-15","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed typos in the documentation (#3317) (#3318) (#3328)\nAdded a test for the order of setting start values (#3315)\nAdded READMEs of solvers and extensions to the docs (#3309) (#3320) (#3327) (#3329) (#3333)\nStyle improvements to src/variables.jl (#3324)\nClarify that column generation does not find global optimum (#3325)\nAdd a GitHub actions workflow for testing extensions prior to release (#3331)\nDocument the release process for JuMP (#3334)\nFix links to discourse and chatroom (#3335)","category":"page"},{"location":"release_notes/#[Version-1.10.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.10.0)-(April-3,-2023)","page":"Release notes","title":"Version 1.10.0 (April 3, 2023)","text":"","category":"section"},{"location":"release_notes/#Added-13","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added Nonnegatives, Nonpositives and Zeros, and support vector-valued inequality syntax in the JuMP macros (#3273)\nAdded special support for LinearAlgebra.Symmetric and LinearAlgebra.Hermitian matrices in Zeros constraints (#3281) (#3296)\nAdded HermitianMatrixSpace and the Hermitian tag for generating a matrix of variables that is Hermitian (#3292) (#3293)\nAdded Semicontinuous and Semiinteger (#3302)\nAdded support for keyword indexing of containers (#3237)","category":"page"},{"location":"release_notes/#Fixed-18","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed [compat] bound for MathOptInterface in Project.toml (#3272)","category":"page"},{"location":"release_notes/#Other-16","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Split out the Nested optimization problems tutorial (#3274)\nUpdated doctests to ensure none have hidden state (#3275) (#3276)\nClarified how lazy constraints may revisit points (#3278)\nAdded P-Norm example (#3282)\nClarified docs that macros create new bindings (#3284)\nFixed threading example (#3283)\nAdded plot to The minimum distortion problem (#3288)\nAdded Google style rules for Vale and fixed warnings (#3285)\nAdded citation for the JuMP 1.0 paper (#3294)\nUpdated package versions in the documentation (#3298)\nAdded comment for the order in which start values must be set (#3303)\nImproved error message for unrecognized constraint operators (#3311)","category":"page"},{"location":"release_notes/#[Version-1.9.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.9.0)-(March-7,-2023)","page":"Release notes","title":"Version 1.9.0 (March 7, 2023)","text":"","category":"section"},{"location":"release_notes/#Added-14","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added get_attribute and set_attribute. These replace get_optimizer_attribute and set_optimizer_attribute, although the _optimizer_ functions remain for backward compatibility. (#3219)\nAdded set_start_values for setting all supported start values in a model (#3238)\nAdd remove_bridge and print_active_bridges (#3259)","category":"page"},{"location":"release_notes/#Fixed-19","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The matrix returned by a variable in HermitianPSDCone is now a LinearAlgebra.Hermitian matrix. This is potentially breaking if you have written code to assume the return is a Matrix. (#3245) (#3246)\nFixed missing support for Base.isreal of expressions (#3252)","category":"page"},{"location":"release_notes/#Other-17","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a thread safety issue in the Parallelism tutorial (#3240) (#3243)\nImproved the error message when unsupported operators are used in @NL macros (#3236)\nClarified the documentation to say that matrices in HermitianPSDCone must be LinearAlgebra.Hermitian (#3241)\nMinor style fixes to internal macro code (#3247)\nAdd Quantum state discrimination tutorial (#3250)\nImprove error message when begin...end not passed to plural macros (#3255)\nDocument how to register function with varying number of input arguments (#3258)\nTidy tests by removing unneeded JuMP. prefixes (#3260)\nClarified the introduction to the Complex number support tutorial (#3262)\nFixed typos in the Documentation (#3263) (#3266) (#3268) (#3269)","category":"page"},{"location":"release_notes/#[Version-1.8.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.8.2)-(February-27,-2023)","page":"Release notes","title":"Version 1.8.2 (February 27, 2023)","text":"","category":"section"},{"location":"release_notes/#Fixed-20","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed dot product between complex JuMP expression and number (#3244)","category":"page"},{"location":"release_notes/#Other-18","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Polish simple SDP examples (#3232)","category":"page"},{"location":"release_notes/#[Version-1.8.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.8.1)-(February-23,-2023)","page":"Release notes","title":"Version 1.8.1 (February 23, 2023)","text":"","category":"section"},{"location":"release_notes/#Fixed-21","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed support for init in nonlinear generator expressions (#3226)","category":"page"},{"location":"release_notes/#Other-19","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Use and document import MathOptInterface as MOI (#3222)\nRemoved references in documentation to multiobjective optimization being unsupported (#3223)\nAdded tutorial on multi-objective portfolio optimization (#3227)\nRefactored some of the conic tutorials (#3229)\nFixed typos in the documentation (#3230)\nAdded tutorial on parallelism (#3231)","category":"page"},{"location":"release_notes/#[Version-1.8.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.8.0)-(February-16,-2023)","page":"Release notes","title":"Version 1.8.0 (February 16, 2023)","text":"","category":"section"},{"location":"release_notes/#Added-15","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added --> syntax support for indicator constraints. The old syntax of => remains supported (#3207)\nAdded <--> syntax for reified constraints. For now, few solvers support reified constraints (#3206)\nAdded fix_discrete_variables. This is most useful for computing the dual of a mixed-integer program (#3208)\nAdded support for vector-valued objectives. For details, see the Multi-objective knapsack tutorial (#3176)","category":"page"},{"location":"release_notes/#Fixed-22","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug in lp_sensitivity_report by switching to an explicit LU factorization of the basis matrix (#3182)\nFixed a bug that prevented [; kwarg] arguments in macros (#3220)","category":"page"},{"location":"release_notes/#Other-20","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Minor fixes to the documentation (#3200) (#3201) (#3203) (#3210)\nAdded tutorial Constraint programming (#3202)\nAdded more examples to Tips and Tricks\nRemove _distance_to_set in favor of MOI.Utilities.distance_to_set (#3209)\nImprove The diet problem tutorial by adding the variable as a column in the dataframe (#3213)\nImprove The knapsack problem example tutorial (#3216) (#3217)\nAdded the Ellipsoid approximation tutorial (#3218)","category":"page"},{"location":"release_notes/#[Version-1.7.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.7.0)-(January-25,-2023)","page":"Release notes","title":"Version 1.7.0 (January 25, 2023)","text":"","category":"section"},{"location":"release_notes/#Added-16","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added support for view of a Containers.DenseAxisArray (#3152) (#3180)\nAdded support for containers of variables in ComplexPlane (#3184)\nAdded support for minimum and maximum generators in nonlinear expressions (#3189)\nAdded SnoopPrecompile statements that reduce the time-to-first-solve in Julia 1.9 (#3193) (#3195) (#3196) (#3197)","category":"page"},{"location":"release_notes/#Other-21","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Large refactoring of the tests (#3166) (#3167) (#3168) (#3169) (#3170) (#3171)\nRemove unreachable code due to VERSION checks (#3172)\nDocument how to test JuMP extensions (#3174)\nFix method ambiguities in Containers (#3173)\nImprove error message that is thrown when = is used instead of == in the @constraint macro (#3178)\nImprove the error message when Bool is used instead of Bin in the @variable macro (#3180)\nUpdate versions of the documentation (#3185)\nTidy the import of packages and remove unnecessary prefixes (#3186) (#3187)\nRefactor src/JuMP.jl by moving methods into more relevant files (#3188)\nFix docstring of Model not appearing in the documentation (#3198)","category":"page"},{"location":"release_notes/#[Version-1.6.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.6.0)-(January-1,-2023)","page":"Release notes","title":"Version 1.6.0 (January 1, 2023)","text":"","category":"section"},{"location":"release_notes/#Added-17","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added a result keyword argument to solution_summary to allow summarizing models with multiple solutions (#3138)\nAdded relax_with_penalty!, which is a useful tool when debugging infeasible models (#3140)\nAdded has_start_value (#3157)\nAdded support for HermitianPSDCone in constraints (#3154)","category":"page"},{"location":"release_notes/#Fixed-23","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed promotion of complex expressions (#3150) (#3164)","category":"page"},{"location":"release_notes/#Other-22","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added Benders tutorial with in-place resolves (#3145)\nAdded more Tips and tricks for linear programs (#3144) (#3163)\nClarified documentation that start can depend on the indices of a variable container (#3148)\nReplace instances of length and size by the recommended eachindex and axes (#3149)\nAdded a warning explaining why the model is dirty when accessing solution results from a modified model (#3156)\nClarify documentation that PSD ensures a symmetric matrix (#3159)\nMaintenance of the JuMP test suite (#3146) (#3158) (#3162)","category":"page"},{"location":"release_notes/#[Version-1.5.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.5.0)-(December-8,-2022)","page":"Release notes","title":"Version 1.5.0 (December 8, 2022)","text":"","category":"section"},{"location":"release_notes/#Added-18","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Add support for complex-valued variables:\nHermitianPSDCone (#3109)\nComplexPlane and ComplexVariable (#3134)\nAdd support for MOI.OptimizerWithAttributes in set_optimizer_attribute and get_optimizer_attribute (#3129)","category":"page"},{"location":"release_notes/#Fixed-24","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed error message for vectorized interval constraints (#3123)\nFixed passing AbstractString to set_optimizer_attribute (#3127)","category":"page"},{"location":"release_notes/#Other-23","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Update package versions used in docs (#3119) (#3133) (#3139)\nFixed output of diet tutorial (#3120)\nExplain how to use Dates.period in set_time_limit_sec (#3121)\nUpdate to JuliaFormatter v1.0.15 (#3130)\nFixed HTTP server example in web_app.jl (#3131)\nUpdate docs to build with Documenter#master (#3094)\nAdd tests for LinearAlgebra operations (#3132)\nTidy these release notes (#3135)\nAdded documentation for Complex number support (#3141)\nRemoved the \"workforce scheduling\" and \"steelT3\" tutorials (#3143)","category":"page"},{"location":"release_notes/#[Version-1.4.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.4.0)-(October-29,-2022)","page":"Release notes","title":"Version 1.4.0 (October 29, 2022)","text":"","category":"section"},{"location":"release_notes/#Added-19","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added Containers.rowtable which converts a container into a vector of NamedTuples to support the Tables.jl interface. This simplifies converting Containers.DenseAxisArray and Containers.SparseAxisArray objects into tabular forms such as a DataFrame (#3104)\nAdded a new method to Containers.container so that index names are passed to the container (#3088)","category":"page"},{"location":"release_notes/#Fixed-25","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug in copy_to(dest::Model, src::MOI.ModelLike) when src has nonlinear components (#3101)\nFixed the printing of (-1.0 + 0.0im) coefficients in complex expressions (#3112)\nFixed a parsing bug in nonlinear expressions with generator statements that contain multiple for statements (#3116)","category":"page"},{"location":"release_notes/#Other-24","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Converted the multi-commodity flow tutorial to use an SQLite database (#3098)\nFixed a number of typos in the documentation (#3103) (#3107) (#3018)\nImproved various style aspects of the PDF documentation (#3095) (#3098) (#3102)","category":"page"},{"location":"release_notes/#[Version-1.3.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.3.1)-(September-28,-2022)","page":"Release notes","title":"Version 1.3.1 (September 28, 2022)","text":"","category":"section"},{"location":"release_notes/#Fixed-26","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a performance issue in relax_integrality (#3087)\nFixed the type stability of operators with Complex arguments (#3072)\nFixed a bug which added additional +() terms to some nonlinear expressions (#3091)\nFixed potential method ambiguities with AffExpr and QuadExpr objects (#3092)","category":"page"},{"location":"release_notes/#Other-25","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added vale as a linter for the documentation (#3080)\nAdded a tutorial on debugging JuMP models (#3043)\nFixed a number of typos in the documentation (#3079) (#3083)\nMany other small tweaks to the documentation (#3068) (#3073) (#3074) (#3075) (#3076) (#3077) (#3078) (#3081) (#3082) (#3084) (#3085) (#3089)","category":"page"},{"location":"release_notes/#[Version-1.3.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.3.0)-(September-5,-2022)","page":"Release notes","title":"Version 1.3.0 (September 5, 2022)","text":"","category":"section"},{"location":"release_notes/#Added-20","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Support slicing in SparseAxisArray (#3031)","category":"page"},{"location":"release_notes/#Fixed-27","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug introduced in v1.2.0 that prevented DenseAxisArrays with Vector keys (#3064)","category":"page"},{"location":"release_notes/#Other-26","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Released the JuMP logos under the CC BY 4.0 license (#3063)\nMinor tweaks to the documentation (#3054) (#3056) (#3057) (#3060) (#3061) (#3065)\nImproved code coverage of a number of files (#3048) (#3049) (#3050) (#3051) (#3052) (#3053) (#3058) (#3059)","category":"page"},{"location":"release_notes/#[Version-1.2.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.2.1)-(August-22,-2022)","page":"Release notes","title":"Version 1.2.1 (August 22, 2022)","text":"","category":"section"},{"location":"release_notes/#Fixed-28","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug when parsing two-sided nonlinear constraints (#3045)","category":"page"},{"location":"release_notes/#[Version-1.2.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.2.0)-(August-16,-2022)","page":"Release notes","title":"Version 1.2.0 (August 16, 2022)","text":"","category":"section"},{"location":"release_notes/#Breaking-2","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"This is a large minor release because it significantly refactors the internal code for handling nonlinear programs to use the MathOptInterface.Nonlinear submodule that was introduced in MathOptInterface v1.3.0. As a consequence, the internal datastructure in model.nlp_data has been removed, as has the JuMP._Derivatives submodule. Despite the changes, the public API for nonlinear programming has not changed, and any code that uses only the public API and that worked with v1.1.1 will continue to work with v1.2.0.","category":"page"},{"location":"release_notes/#Added-21","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added all_constraints(model; include_variable_in_set_constraints) which simplifies returning a list of all constraint indices in the model.\nAdded the ability to delete nonlinear constraints via delete(::Model, ::NonlinearConstraintRef).\nAdded the ability to provide an explicit Hessian for a multivariate user-defined function.\nAdded support for querying the primal value of a nonlinear constraint via value(::NonlinearConstraintRef)","category":"page"},{"location":"release_notes/#Fixed-29","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug in Containers.DenseAxisArray so that it now supports indexing with keys that hash to the same value, even if they are different types, for example, Int32 and Int64.\nFixed a bug printing the model when the solver does not support MOI.Name.","category":"page"},{"location":"release_notes/#Other-27","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added a constraint programming formulation to the Sudoku tutorial.\nAdded newly supported solvers Pajarito, Clarabel, and COPT to the installation table.\nFixed a variety of other miscellaneous issues in the documentation.","category":"page"},{"location":"release_notes/#[Version-1.1.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.1.1)-(June-14,-2022)","page":"Release notes","title":"Version 1.1.1 (June 14, 2022)","text":"","category":"section"},{"location":"release_notes/#Other-28","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed problem displaying LaTeX in the documentation\nMinor updates to the style guide\nUpdated to MOI v1.4.0 in the documentation","category":"page"},{"location":"release_notes/#[Version-1.1.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.1.0)-(May-25,-2022)","page":"Release notes","title":"Version 1.1.0 (May 25, 2022)","text":"","category":"section"},{"location":"release_notes/#Added-22","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added num_constraints(::Model; count_variable_in_set_constraints) to simplify the process of counting the number of constraints in a model\nAdded VariableRef(::ConstraintRef) for querying the variable associated with a bound or integrality constraint.\nAdded set_normalized_coefficients for modifying the variable coefficients of a vector-valued constraint.\nAdded set_string_names_on_creation to disable creating String names for variables and constraints. This can improve performance.","category":"page"},{"location":"release_notes/#Fixed-30","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug passing nothing to the start keyword of @variable","category":"page"},{"location":"release_notes/#Other-29","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"New tutorials:\nSensitivity analysis of a linear program\nServing web apps\nMinimal ellipse SDP tutorial refactored and improved\nDocs updated to the latest version of each package\nLots of minor fixes and improvements to the documentation","category":"page"},{"location":"release_notes/#[Version-1.0.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v1.0.0)-(March-24,-2022)","page":"Release notes","title":"Version 1.0.0 (March 24, 2022)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Read more about this release, along with an acknowledgement of all the contributors in our JuMP 1.0.0 is released blog post.","category":"page"},{"location":"release_notes/#Breaking-3","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The previously deprecated functions (v0.23.0, v0.23.1) have been removed. Deprecation was to improve consistency of function names:\nnum_nl_constraints (see num_nonlinear_constraints)\nall_nl_constraints (see all_nonlinear_constraints)\nadd_NL_expression (see add_nonlinear_expression)\nset_NL_objective  (see set_nonlinear_objective)\nadd_NL_constraint (see add_nonlinear_constraint)\nnl_expr_string (see nonlinear_expr_string)\nnl_constraint_string (see nonlinear_constraint_string)\nSymMatrixSpace (see SymmetricMatrixSpace)\nThe unintentionally exported variable JuMP.op_hint has been renamed to the unexported JuMP._OP_HINT","category":"page"},{"location":"release_notes/#Fixed-31","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug writing .nl files\nFixed a bug broadcasting SparseAxisArrays","category":"page"},{"location":"release_notes/#[Version-0.23.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.23.2)-(March-14,-2022)","page":"Release notes","title":"Version 0.23.2 (March 14, 2022)","text":"","category":"section"},{"location":"release_notes/#Added-23","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added relative_gap to solution_summary\nregister now throws an informative error if the function is not differentiable using ForwardDiff. In some cases, the check in register will encounter a false negative, and the informative error will be thrown at run-time. This usually happens when the function is non-differentiable in a subset of the domain.","category":"page"},{"location":"release_notes/#Fixed-32","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a scoping issue when extending the container keyword of containers","category":"page"},{"location":"release_notes/#Other-30","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Docs updated to the latest version of each package","category":"page"},{"location":"release_notes/#[Version-0.23.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.23.1)-(March-2,-2022)","page":"Release notes","title":"Version 0.23.1 (March 2, 2022)","text":"","category":"section"},{"location":"release_notes/#Deprecated","page":"Release notes","title":"Deprecated","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"nl_expr_string and nl_constraint_string have been renamed to nonlinear_expr_string and nonlinear_constraint_string. The old methods still exist with deprecation warnings. This change should impact very few users because to call them you must rely on private internals of the nonlinear API. Users are encouraged to use sprint(show, x) instead, where x is the nonlinear expression or constraint of interest.","category":"page"},{"location":"release_notes/#Added-24","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added support for Base.abs2(x) where x is a variable or affine expression. This is mainly useful for complex-valued constraints.","category":"page"},{"location":"release_notes/#Fixed-33","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed addition of complex and real affine expressions\nFixed arithmetic for Complex-valued quadratic expressions\nFixed variable bounds passed as Rational{Int}(Inf)\nFixed printing of the coefficient (0 + 1im)\nFixed a bug when solution_summary is called prior to optimize!","category":"page"},{"location":"release_notes/#[Version-0.23.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.23.0)-(February-25,-2022)","page":"Release notes","title":"Version 0.23.0 (February 25, 2022)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"JuMP v0.23.0 is a breaking release. It is also a release-candidate for JuMP v1.0.0. That is, if no issues are found with the v0.23.0 release, then it will be re-tagged as v1.0.0.","category":"page"},{"location":"release_notes/#Breaking-4","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Julia 1.6 is now the minimum supported version\nMathOptInterface has been updated to v1.0.0\nAll previously deprecated functionality has been removed\nPrintMode, REPLMode and IJuliaMode have been removed in favor of the MIME types MIME\"text/plain\" and MIME\"text/latex\". Replace instances of ::Type{REPLMode} with ::MIME\"text/plain\", REPLMode with MIME(\"text/plain\"), ::Type{IJuliaMode} with ::MIME\"text/latex\", and IJuliaMode with MIME(\"text/latex\").\nFunctions containing the nl_ acronym have been renamed to the more explicit nonlinear_. For example, num_nl_constraints is now num_nonlinear_constraints and set_NL_objective is now set_nonlinear_objective. Calls to the old functions throw an error explaining the new name.\nSymMatrixSpace has been renamed to SymmetricMatrixSpace","category":"page"},{"location":"release_notes/#Added-25","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added nonlinear_dual_start_value and set_nonlinear_dual_start_value\nAdded preliminary support for Complex coefficient types","category":"page"},{"location":"release_notes/#Fixed-34","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug in solution_summary","category":"page"},{"location":"release_notes/#Other-31","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"MILP examples have been migrated from GLPK to HiGHS\nFixed various typos\nImproved section on setting constraint start values","category":"page"},{"location":"release_notes/#Troubleshooting-problems-when-updating","page":"Release notes","title":"Troubleshooting problems when updating","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"If you experience problems when updating, you are likely using previously deprecated functionality. (By default, Julia does not warn when you use deprecated features.)","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"To find the deprecated features you are using, start Julia with --depwarn=yes:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"$ julia --depwarn=yes","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Then install JuMP v0.22.3:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"julia> using Pkg\njulia> pkg\"add JuMP@0.22.3\"","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"And then run your code. Apply any suggestions, or search the release notes below for advice on updating a specific deprecated feature.","category":"page"},{"location":"release_notes/#[Version-0.22.3](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.22.3)-(February-10,-2022)","page":"Release notes","title":"Version 0.22.3 (February 10, 2022)","text":"","category":"section"},{"location":"release_notes/#Fixed-35","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a reproducibility issue in the TSP tutorial\nFixed a reproducibility issue in the max_cut_sdp tutorial\nFixed a bug broadcasting an empty SparseAxisArray","category":"page"},{"location":"release_notes/#Other-32","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added a warning and improved documentation for the modify-then-query case\nFixed a typo in the docstring of RotatedSecondOrderCone\nAdded Aqua.jl as a check for code health\nAdded introductions to each section of the tutorials\nImproved the column generation and Benders decomposition tutorials\nUpdated documentation to MOI v0.10.8\nUpdated JuliaFormatter to v0.22.2","category":"page"},{"location":"release_notes/#[Version-0.22.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.22.2)-(January-10,-2022)","page":"Release notes","title":"Version 0.22.2 (January 10, 2022)","text":"","category":"section"},{"location":"release_notes/#Added-26","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The function all_nl_constraints now returns all nonlinear constraints in a model\nstart_value and set_start_value can now be used to get and set the primal start for constraint references\nPlural macros now return a tuple containing the elements that were defined instead of nothing\nAnonymous variables are now printed as _[i] where i is the index of the variable instead of noname. Calling name(x) still returns \"\" so this is non-breaking.","category":"page"},{"location":"release_notes/#Fixed-36","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed handling of min and max in nonlinear expressions\nCartesianIndex is no longer allowed as a key for DenseAxisArrays.","category":"page"},{"location":"release_notes/#Other-33","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Improved the performance of GenericAffExpr\nAdded a tutorial on the Travelling Salesperson Problem\nAdded a tutorial on querying the Hessian of a nonlinear program\nAdded documentation on using custom solver binaries.","category":"page"},{"location":"release_notes/#[Version-0.22.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.22.1)-(November-29,-2021)","page":"Release notes","title":"Version 0.22.1 (November 29, 2021)","text":"","category":"section"},{"location":"release_notes/#Added-27","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Export OptimizationSense enum, with instances: MIN_SENSE, MAX_SENSE, and FEASIBILITY_SENSE\nAdd Base.isempty(::Model) to match Base.empty(::Model)","category":"page"},{"location":"release_notes/#Fixed-37","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix bug in container with tuples as indices\nFix bug in set_time_limit_sec","category":"page"},{"location":"release_notes/#Other-34","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Add tutorial \"Design patterns for larger models\"\nRemove release notes section from PDF\nGeneral edits of the documentation and error messages","category":"page"},{"location":"release_notes/#[Version-0.22.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.22.0)-(November-10,-2021)","page":"Release notes","title":"Version 0.22.0 (November 10, 2021)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"JuMP v0.22 is a breaking release","category":"page"},{"location":"release_notes/#Breaking-5","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"JuMP 0.22 contains a number of breaking changes. However, these should be invisible for the majority of users. You will mostly encounter these breaking changes if you: wrote a JuMP extension, accessed backend(model), or called @SDconstraint.","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The breaking changes are as follows:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"MathOptInterface has been updated to v0.10.4. For users who have interacted with the MOI backend, this contains a large number of breaking changes. Read the MathOptInterface release notes for more details.\nThe bridge_constraints keyword argument to Model and set_optimizer has been renamed add_bridges to reflect that more thing were bridged than just constraints.\nThe backend(model) field now contains a concrete instance of a MOI.Utilities.CachingOptimizer instead of one with an abstractly typed optimizer field. In most cases, this will lead to improved performance. However, calling set_optimizer after backend invalidates the old backend. For example:\nmodel = Model()\nb = backend(model)\nset_optimizer(model, GLPK.Optimizer)\n@variable(model, x)\n# b is not updated with `x`! Get a new b by calling `backend` again.\nnew_b = backend(model)\nAll usages of @SDconstraint are deprecated. The new syntax is @constraint(model, X >= Y, PSDCone()).\nCreating a DenseAxisArray with a Number as an axis will now display a warning. This catches a common error in which users write @variable(model, x[length(S)]) instead of @variable(model, x[1:length(S)]).\nThe caching_mode argument to Model, for example, Model(caching_mode = MOIU.MANUAL) mode has been removed. For more control over the optimizer, use direct_model instead.\nThe previously deprecated lp_objective_perturbation_range and lp_rhs_perturbation_range functions have been removed. Use lp_sensitivity_report instead.\nThe .m fields of NonlinearExpression and NonlinearParameter have been renamed to .model.\nInfinite variable bounds are now ignored. Thus, @variable(model, x <= Inf) will show has_upper_bound(x) == false. Previously, these bounds were passed through to the solvers which caused numerical issues for solvers expecting finite bounds.\nThe variable_type and constraint_type functions were removed. This should only affect users who previously wrote JuMP extensions. The functions can be deleted without consequence.\nThe internal functions moi_mode, moi_bridge_constraints, moi_add_constraint, and moi_add_to_function_constant are no longer exported.\nThe un-used method Containers.generate_container has been deleted.\nThe Containers API has been refactored, and _build_ref_sets is now public as Containers.build_ref_sets.\nThe parse_constraint_ methods for extending @constraint at parse time have been refactored in a breaking way. Consult the Extensions documentation for more details and examples.","category":"page"},{"location":"release_notes/#Added-28","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The TerminationStatusCode and ResultStatusCode enums are now exported by JuMP. Prefer termination_status(model) == OPTIMAL instead of == MOI.OPTIMAL, although the MOI. prefix way still works.\nCopy a x::DenseAxisArray to an Array by calling Array(x).\nNonlinearExpression is now a subtype of AbstractJuMPScalar\nConstraints such as @constraint(model, x + 1 in MOI.Integer()) are now supported.\nprimal_feasibility_report now accepts a function as the first argument.\nScalar variables @variable(model, x[1:2] in MOI.Integer()) creates two variables, both of which are constrained to be in the set MOI.Integer.\nConic constraints can now be specified as inequalities under a different partial ordering. So @constraint(model, x - y in MOI.Nonnegatives()) can now be written as @constraint(model, x >= y, MOI.Nonnegatives()).\nNames are now set for vectorized constraints.","category":"page"},{"location":"release_notes/#Fixed-38","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a performance issue when show was called on a SparseAxisArray with a large number of elements.\nFixed a bug displaying barrier and simplex iterations in solution_summary.\nFixed a bug by implementing hash for DenseAxisArray and SparseAxisArray.\nNames are now only set if the solver supports them. Previously, this prevented solvers such as Ipopt from being used with direct_model.\nMutableArithmetics.Zero is converted into a 0.0 before being returned to the user. Previously, some calls to @expression would return the undocumented MutableArithmetics.Zero() object. One example is summing over an empty set @expression(model, sum(x[i] for i in 1:0)). You will now get 0.0 instead.\nAffExpr and QuadExpr can now be used with == 0 instead of iszero. This fixes a number of issues relating to Julia standard libraries such as LinearAlgebra and SparseArrays.\nFixed a bug when registering a user-defined function with splatting.","category":"page"},{"location":"release_notes/#Other-35","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The documentation is now available as a PDF.\nThe documentation now includes a full copy of the MathOptInterface documentation to make it easy to link concepts between the docs. (The MathOptInterface documentation has also been significantly improved.)\nThe documentation contains a large number of improvements and clarifications on a range of topics. Thanks to @sshin23, @DilumAluthge, and @jlwether.\nThe documentation is now built with Julia 1.6 instead of 1.0.\nVarious error messages have been improved to be more readable.","category":"page"},{"location":"release_notes/#[Version-0.21.10](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.21.10)-(September-4,-2021)","page":"Release notes","title":"Version 0.21.10 (September 4, 2021)","text":"","category":"section"},{"location":"release_notes/#Added-29","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added add_NL_expression\nadd_NL_xxx functions now support AffExpr and QuadExpr as terms","category":"page"},{"location":"release_notes/#Fixed-39","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug in solution_summary\nFixed a bug in relax_integrality","category":"page"},{"location":"release_notes/#Other-36","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Improved error message in lp_sensitivity_report","category":"page"},{"location":"release_notes/#[Version-0.21.9](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.21.9)-(August-1,-2021)","page":"Release notes","title":"Version 0.21.9 (August 1, 2021)","text":"","category":"section"},{"location":"release_notes/#Added-30","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Containers now support arbitrary container types by passing the type to the container keyword and overloading Containers.container.\nis_valid now supports nonlinear constraints\nAdded unsafe_backend for querying the inner-most optimizer of a JuMP model.\nNonlinear parameters now support the plural @NLparameters macro.\nContainers (for example, DenseAxisArray) can now be used in vector-valued constraints.","category":"page"},{"location":"release_notes/#Other-37","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Various improvements to the documentation.","category":"page"},{"location":"release_notes/#[Version-0.21.8](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.21.8)-(May-8,-2021)","page":"Release notes","title":"Version 0.21.8 (May 8, 2021)","text":"","category":"section"},{"location":"release_notes/#Added-31","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The @constraint macro is now extendable in the same way as @variable.\nAffExpr and QuadExpr can now be used in nonlinear macros.","category":"page"},{"location":"release_notes/#Fixed-40","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug in lp_sensitivity_report.\nFixed an inference issue when creating empty SparseAxisArrays.","category":"page"},{"location":"release_notes/#[Version-0.21.7](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.21.7)-(April-12,-2021)","page":"Release notes","title":"Version 0.21.7 (April 12, 2021)","text":"","category":"section"},{"location":"release_notes/#Added-32","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added primal_feasibility_report, which can be used to check whether a primal point satisfies primal feasibility.\nAdded coefficient, which returns the coefficient associated with a variable in affine and quadratic expressions.\nAdded copy_conflict, which returns the IIS of an infeasible model.\nAdded solution_summary, which returns (and prints) a struct containing a summary of the solution.\nAllow AbstractVector in vector constraints instead of just Vector.\nAdded latex_formulation(model) which returns an object representing the latex formulation of a model. Use print(latex_formulation(model)) to print the formulation as a string.\nUser-defined functions in nonlinear expressions are now automatically registered to aid quick model prototyping. However, a warning is printed to encourage the manual registration.\nDenseAxisArray's now support broadcasting over multiple arrays.\nContainer indices can now be iterators of Base.SizeUnknown.","category":"page"},{"location":"release_notes/#Fixed-41","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed bug in rad2deg and deg2rad in nonlinear expressions.\nFixed a MethodError bug in Containers when forcing container type.\nAllow partial slicing of a DenseAxisArray, resolving an issue from 2014.\nFixed a bug printing variable names in IJulia.\nEnding an IJulia cell with model now prints a summary of the model (like in the REPL) not the latex formulation. Use print(model) to print the latex formulation.\nFixed a bug when copying models containing nested arrays.","category":"page"},{"location":"release_notes/#Other-38","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Tutorials are now part of the documentation, and more refactoring has taken place.\nAdded JuliaFormatter added as a code formatter.\nAdded some precompilation statements to reduce initial latency.\nVarious improvements to error messages to make them more helpful.\nImproved performance of value(::NonlinearExpression).\nImproved performance of fix(::VariableRef).","category":"page"},{"location":"release_notes/#[Version-0.21.6](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.21.6)-(January-29,-2021)","page":"Release notes","title":"Version 0.21.6 (January 29, 2021)","text":"","category":"section"},{"location":"release_notes/#Added-33","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added support for skew symmetric variables via @variable(model, X[1:2, 1:2] in SkewSymmetricMatrixSpace()).\nlp_sensitivity_report has been added which significantly improves the performance of querying the sensitivity summary of an LP. lp_objective_perturbation_range and lp_rhs_perturbation_range are deprecated.\nDual warm-starts are now supported with set_dual_start_value and dual_start_value.\n∈ (\\in<tab>) can now be used in macros instead of = or in.\nUse haskey(model::Model, key::Symbol) to check if a name key is registered in a model.\nAdded unregister(model::Model, key::Symbol) to unregister a name key from model.\nAdded callback_node_status for use in callbacks.\nAdded print_bridge_graph to visualize the bridging graph generated by MathOptInterface.\nImproved error message for containers with duplicate indices.","category":"page"},{"location":"release_notes/#Fixed-42","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Various fixes to pass tests on Julia 1.6.\nFixed a bug in the printing of nonlinear expressions in IJulia.\nFixed a bug when nonlinear expressions are passed to user-defined functions.\nSome internal functions that were previously exported are now no longer exported.\nFixed a bug when relaxing a fixed binary variable.\nFixed a StackOverflowError that occurred when SparseAxisArrays had a large number of elements.\nRemoved an unnecessary type assertion in list_of_constraint_types.\nFixed a bug when copying models with registered expressions.","category":"page"},{"location":"release_notes/#Other-39","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The documentation has been significantly overhauled. It now has distinct sections for the manual, API reference, and examples. The existing examples in /examples have now been moved to /docs/src/examples and rewritten using Literate.jl, and they are now included in the documentation.\nJuliaFormatter has been applied to most of the codebase. This will continue to roll out over time, as we fix upstream issues in the formatter, and will eventually become compulsory.\nThe root cause of a large number of method invalidations has been resolved.\nWe switched continuous integration from Travis and Appveyor to GitHub Actions.","category":"page"},{"location":"release_notes/#[Version-0.21.5](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.21.5)-(September-18,-2020)","page":"Release notes","title":"Version 0.21.5 (September 18, 2020)","text":"","category":"section"},{"location":"release_notes/#Fixed-43","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed deprecation warnings\nThrow DimensionMismatch for incompatibly sized functions and sets\nUnify treatment of keys(x) on JuMP containers","category":"page"},{"location":"release_notes/#[Version-0.21.4](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.21.4)-(September-14,-2020)","page":"Release notes","title":"Version 0.21.4 (September 14, 2020)","text":"","category":"section"},{"location":"release_notes/#Added-34","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Add debug info when adding unsupported constraints\nAdd relax_integrality for solving continuous relaxation\nAllow querying constraint conflicts","category":"page"},{"location":"release_notes/#Fixed-44","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Dispatch on Real for MOI.submit\nImplement copy for CustomSet in tests\nDon't export private macros\nFix invalid assertion in nonlinear\nError if constraint has NaN right-hand side\nImprove speed of tests\nLots of work modularizing files in /test\nImprove line numbers in macro error messages\nPrint nonlinear subexpressions\nVarious documentation updates\nDependency updates:\nDatastructures 0.18\nMathOptFormat v0.5\nPrep for MathOptInterface 0.9.15","category":"page"},{"location":"release_notes/#[Version-0.21.3](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.21.3)-(June-18,-2020)","page":"Release notes","title":"Version 0.21.3 (June 18, 2020)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added Special Order Sets (SOS1 and SOS2) to JuMP with default weights to ease the creation of such constraints (#2212).\nAdded functions simplex_iterations, barrier_iterations and node_count (#2201).\nAdded function reduced_cost (#2205).\nImplemented callback_value for affine and quadratic expressions (#2231).\nSupport MutableArithmetics.Zero in objective and constraints (#2219).\nDocumentation improvements:\nMention tutorials in the docs (#2223).\nUpdate COIN-OR links (#2242).\nExplicit link to the documentation of MOI.FileFormats (#2253).\nTypo fixes (#2261).\nContainers improvements:\nFix Base.map for DenseAxisArray (#2235).\nThrow BoundsError if number of indices is incorrect for DenseAxisArray and SparseAxisArray (#2240).\nExtensibility improvements:\nImplement a set_objective method fallback that redirects to set_objective_sense and set_objective_function (#2247).\nAdd parse_constraint method with arbitrary number of arguments (#2051).\nAdd parse_constraint_expr and parse_constraint_head (#2228).","category":"page"},{"location":"release_notes/#[Version-0.21.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.21.2)-(April-2,-2020)","page":"Release notes","title":"Version 0.21.2 (April 2, 2020)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added relative_gap() to access MOI.RelativeGap() attribute (#2199).\nDocumentation fixes:\nAdded link to source for docstrings in the documentation (#2207).\nAdded docstring for @variables macro (#2216).\nTypo fixes (#2177, #2184, #2182).\nImplementation of methods for Base functions:\nImplemented Base.empty! for JuMP.Model (#2198).\nImplemented Base.conj for JuMP scalar types (#2209).","category":"page"},{"location":"release_notes/#Fixed-45","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed sum of expression with scalar product in macro (#2178).\nFixed writing of nonlinear models to MathOptFormat (#2181).\nFixed construction of empty SparseAxisArray (#2179).\nFixed constraint with zero function (#2188).","category":"page"},{"location":"release_notes/#[Version-0.21.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.21.1)-(Feb-18,-2020)","page":"Release notes","title":"Version 0.21.1 (Feb 18, 2020)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Improved the clarity of the with_optimizer deprecation warning.","category":"page"},{"location":"release_notes/#[Version-0.21.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.21.0)-(Feb-16,-2020)","page":"Release notes","title":"Version 0.21.0 (Feb 16, 2020)","text":"","category":"section"},{"location":"release_notes/#Breaking-6","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Deprecated with_optimizer (#2090, #2084, #2141). You can replace with_optimizer by either nothing, optimizer_with_attributes or a closure:\nreplace with_optimizer(Ipopt.Optimizer) by Ipopt.Optimizer.\nreplace with_optimizer(Ipopt.Optimizer, max_cpu_time=60.0) by optimizer_with_attributes(Ipopt.Optimizer, \"max_cpu_time\" => 60.0).\nreplace with_optimizer(Gurobi.Optimizer, env) by () -> Gurobi.Optimizer(env).\nreplace with_optimizer(Gurobi.Optimizer, env, Presolve=0) by optimizer_with_attributes(() -> Gurobi.Optimizer(env), \"Presolve\" => 0).\nalternatively to optimizer_with_attributes, you can also set the attributes separately with set_optimizer_attribute.\nRenamed set_parameter and set_parameters to set_optimizer_attribute and set_optimizer_attributes (#2150).\nBroadcast should now be explicit inside macros. @SDconstraint(model, x >= 1) and @constraint(model, x + 1 in SecondOrderCone()) now throw an error instead of broadcasting 1 along the dimension of x (#2107).\n@SDconstraint(model, x >= 0) is now equivalent to @constraint(model, x in PSDCone()) instead of @constraint(model, (x .- 0) in PSDCone()) (#2107).\nThe macros now create the containers with map instead of for loops, as a consequence, containers created by @expression can now have any element type and containers of constraint references now have concrete element types when possible. This fixes a long-standing issue where @expression could only be used to generate a collection of linear expressions. Now it works for quadratic expressions as well (#2070).\nCalling deepcopy(::AbstractModel) now throws an error.\nThe constraint name is now printed in the model string (#2108).","category":"page"},{"location":"release_notes/#Added-35","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added support for solver-independent and solver-specific callbacks (#2101).\nAdded write_to_file and read_from_file, supported formats are CBF, LP, MathOptFormat, MPS and SDPA (#2114).\nAdded support for complementarity constraints (#2132).\nAdded support for indicator constraints (#2092).\nAdded support for querying multiple solutions with the result keyword (#2100).\nAdded support for constraining variables on creation (#2128).\nAdded method delete that deletes a vector of variables at once if it is supported by the underlying solver (#2135).\nThe arithmetic between JuMP expression has be refactored into the MutableArithmetics package (#2107).\nImproved error on complex values in NLP (#1978).\nAdded an example of column generation (#2010).","category":"page"},{"location":"release_notes/#Fixed-46","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Incorrect coefficients generated when using Symmetric variables (#2102)","category":"page"},{"location":"release_notes/#[Version-0.20.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.20.1)-(Oct-18,-2019)","page":"Release notes","title":"Version 0.20.1 (Oct 18, 2019)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Add sections on @variables and @constraints in the documentation (#2062).\nFixed product of sparse matrices for Julia v1.3 (#2063).\nAdded set_objective_coefficient to modify the coefficient of a linear term of the objective function (#2008).\nAdded set_time_limit_sec, unset_time_limit_sec and time_limit_sec to set and query the time limit for the solver in seconds (#2053).","category":"page"},{"location":"release_notes/#[Version-0.20.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.20.0)-(Aug-24,-2019)","page":"Release notes","title":"Version 0.20.0 (Aug 24, 2019)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Documentation updates.\nNumerous bug fixes.\nBetter error messages (#1977, #1978, #1997, #2017).\nPerformance improvements (#1947, #2032).\nAdded LP sensitivity summary functions lp_objective_perturbation_range and lp_rhs_perturbation_range (#1917).\nAdded functions dual_objective_value, raw_status and set_parameter.\nAdded function set_objective_coefficient to modify the coefficient of a linear term of the objective (#2008).\nAdded functions set_normalized_rhs, normalized_rhs, and add_to_function_constant to modify and get the constant part of a constraint (#1935, #1960).\nAdded functions set_normalized_coefficient and normalized_coefficient to modify and get the coefficient of a linear term of a constraint (#1935, #1960).\nNumerous other improvements in MOI 0.9, see the NEWS.md file of MOI for more details.","category":"page"},{"location":"release_notes/#[Version-0.19.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.19.2)-(June-8,-2019)","page":"Release notes","title":"Version 0.19.2 (June 8, 2019)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug in derivatives that could arise in models with nested nonlinear subexpressions.","category":"page"},{"location":"release_notes/#[Version-0.19.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.19.1)-(May-12,-2019)","page":"Release notes","title":"Version 0.19.1 (May 12, 2019)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Usability and performance improvements.\nBug fixes.","category":"page"},{"location":"release_notes/#[Version-0.19.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.19.0)-(February-15,-2019)","page":"Release notes","title":"Version 0.19.0 (February 15, 2019)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"JuMP 0.19 contains significant breaking changes.","category":"page"},{"location":"release_notes/#Breaking-7","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"JuMP's abstraction layer for communicating with solvers changed from MathProgBase (MPB) to MathOptInterface (MOI). MOI addresses many longstanding design issues. (See @mlubin's slides from JuMP-dev 2018.) JuMP 0.19 is compatible only with solvers that have been updated for MOI. See the installation guide for a list of solvers that have and have not yet been updated.\nMost solvers have been renamed to PackageName.Optimizer. For example, GurobiSolver() is now Gurobi.Optimizer.\nSolvers are no longer added to a model via Model(solver = XXX(kwargs...)). Instead use Model(with_optimizer(XXX, kwargs...)). For example, Model(with_optimizer(Gurobi.Optimizer, OutputFlag=0)).\nJuMP containers (for example, the objects returned by @variable) have been redesigned. Containers.SparseAxisArray replaces JuMPDict, JuMPArray was rewritten (inspired by AxisArrays) and renamed Containers.DenseAxisArray, and you can now request a container type with the container= keyword to the macros. See the corresponding documentation for more details.\nThe statuses returned by solvers have changed. See the possible status values here. The MOI statuses are much richer than the MPB statuses and can be used to distinguish between previously indistinguishable cases (for example, did the solver have a feasible solution when it stopped because of the time limit?).\nStarting values are separate from result values. Use value to query the value of a variable in a solution. Use start_value and set_start_value to get and set an initial starting point provided to the solver. The solutions from previous solves are no longer automatically set as the starting points for the next solve.\nThe data structures for affine and quadratic expressions AffExpr and QuadExpr have changed. Internally, terms are stored in dictionaries instead of lists. Duplicate coefficients can no longer exist. Accessors and iteration methods have changed.\nJuMPNLPEvaluator no longer includes the linear and quadratic parts of the model in the evaluation calls. These are now handled separately to allow NLP solvers that support various types of constraints.\nJuMP solver-independent callbacks have been replaced by solver-specific callbacks. See your favorite solver for more details. (See the note below: No solver-specific callbacks are implemented yet.)\nThe norm() syntax is no longer recognized inside macros. Use the SecondOrderCone() set instead.\nJuMP no longer performs automatic transformation between special quadratic forms and second-order cone constraints. Support for these constraint classes depends on the solver.\nThe symbols :Min and :Max are no longer used as optimization senses. Instead, JuMP uses the OptimizationSense enum from MathOptInterface. @objective(model, Max, ...), @objective(model, Min, ...), @NLobjective(model, Max, ...), and @objective(model, Min, ...) remain valid, but @objective(m, :Max, ...) is no longer accepted.\nThe sign conventions for duals has changed in some cases for consistency with conic duality (see the documentation). The shadow_price helper method returns duals with signs that match conventional LP interpretations of dual values as sensitivities of the objective value to relaxations of constraints.\n@constraintref is no longer defined. Instead, create the appropriate container to hold constraint references manually. For example,\nconstraints = Dict() # Optionally, specify types for improved performance.\nfor i in 1:N\n  constraints[i] = @constraint(model, ...)\nend\nThe lowerbound, upperbound, and basename keyword arguments to the @variable macro have been renamed to lower_bound, upper_bound, and base_name, for consistency with JuMP's new style recommendations.\nWe rely on broadcasting syntax to apply accessors to collections of variables, for example, value.(x) instead of getvalue(x) for collections. (Use value(x) when x is a scalar object.)","category":"page"},{"location":"release_notes/#Added-36","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Splatting (like f(x...)) is recognized in restricted settings in nonlinear expressions.\nSupport for deleting constraints and variables.\nThe documentation has been completely rewritten using docstrings and Documenter.\nSupport for modeling mixed conic and quadratic models (for example, conic models with quadratic objectives and bi-linear matrix inequalities).\nSignificantly improved support for modeling new types of constraints and for extending JuMP's macros.\nSupport for providing dual warm starts.\nImproved support for accessing solver-specific attributes (for example, the irreducible inconsistent subsystem).\nExplicit control of whether symmetry-enforcing constraints are added to PSD constraints.\nSupport for modeling exponential cones.\nSignificant improvements in internal code quality and testing.\nStyle and naming guidelines.\nDirect mode and manual mode provide explicit control over when copies of a model are stored or regenerated. See the corresponding documentation.","category":"page"},{"location":"release_notes/#Regressions","page":"Release notes","title":"Regressions","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"There are known regressions from JuMP 0.18 that will be addressed in a future release (0.19.x or later):","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Performance regressions in model generation (issue). Please file an issue anyway if you notice a significant performance regression. We have plans to address a number of performance issues, but we might not be aware of all of them.\nFast incremental NLP solves are not yet reimplemented (issue).\nWe do not yet have an implementation of solver-specific callbacks.\nThe column generation syntax in @variable has been removed (that is, the objective, coefficients, and inconstraints keyword arguments). Support for column generation will be re-introduced in a future release.\nThe ability to solve the continuous relaxation (that is, via solve(model; relaxation = true)) is not yet reimplemented (issue).","category":"page"},{"location":"release_notes/#[Version-0.18.5](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.18.5)-(December-1,-2018)","page":"Release notes","title":"Version 0.18.5 (December 1, 2018)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Support views in some derivative evaluation functions.\nImproved compatibility with PackageCompiler.","category":"page"},{"location":"release_notes/#[Version-0.18.4](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.18.4)-(October-8,-2018)","page":"Release notes","title":"Version 0.18.4 (October 8, 2018)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug in model printing on Julia 0.7 and 1.0.","category":"page"},{"location":"release_notes/#[Version-0.18.3](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.18.3)-(October-1,-2018)","page":"Release notes","title":"Version 0.18.3 (October 1, 2018)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Add support for Julia v1.0 (Thanks @ExpandingMan)\nFix matrix expressions with quadratic functions (#1508)","category":"page"},{"location":"release_notes/#[Version-0.18.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.18.2)-(June-10,-2018)","page":"Release notes","title":"Version 0.18.2 (June 10, 2018)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug in second-order derivatives when expressions are present (#1319)\nFix a bug in @constraintref (#1330)","category":"page"},{"location":"release_notes/#[Version-0.18.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.18.1)-(April-9,-2018)","page":"Release notes","title":"Version 0.18.1 (April 9, 2018)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix for nested tuple destructuring (#1193)\nPreserve internal model when relaxation=true (#1209)\nMinor bug fixes and updates for example","category":"page"},{"location":"release_notes/#[Version-0.18.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.18.0)-(July-27,-2017)","page":"Release notes","title":"Version 0.18.0 (July 27, 2017)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Drop support for Julia 0.5.\nUpdate for ForwardDiff 0.5.\nMinor bug fixes.","category":"page"},{"location":"release_notes/#[Version-0.17.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.17.1)-(June-9,-2017)","page":"Release notes","title":"Version 0.17.1 (June 9, 2017)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Use of constructconstraint! in @SDconstraint.\nMinor bug fixes.","category":"page"},{"location":"release_notes/#[Version-0.17.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.17.0)-(May-27,-2017)","page":"Release notes","title":"Version 0.17.0 (May 27, 2017)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Breaking change: Mixing quadratic and conic constraints is no longer supported.\nBreaking change: The getvariable and getconstraint functions are replaced by indexing on the corresponding symbol. For instance, to access the variable with name x, one should now write m[:x] instead of getvariable(m, :x). As a consequence, creating a variable and constraint with the same name now triggers a warning, and accessing one of them afterwards throws an error. This change is breaking only in the latter case.\nAddition of the getobjectivebound function that mirrors the functionality of the MathProgBase getobjbound function except that it takes into account transformations performed by JuMP.\nMinor bug fixes.","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The following changes are primarily of interest to developers of JuMP extensions:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The new syntax @constraint(model, expr in Cone) creates the constraint ensuring that expr is inside Cone. The Cone argument is passed to constructconstraint! which enables the call to the dispatched to an extension.\nThe @variable macro now calls constructvariable! instead of directly calling the Variable constructor. Extra arguments and keyword arguments passed to @variable are passed to constructvariable! which enables the call to be dispatched to an extension.\nRefactor the internal function conicdata (used build the MathProgBase conic model) into smaller sub-functions to make these parts reusable by extensions.","category":"page"},{"location":"release_notes/#[Version-0.16.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.16.2)-(March-28,-2017)","page":"Release notes","title":"Version 0.16.2 (March 28, 2017)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Minor bug fixes and printing tweaks\nAddress deprecation warnings for Julia 0.6","category":"page"},{"location":"release_notes/#[Version-0.16.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.16.1)-(March-7,-2017)","page":"Release notes","title":"Version 0.16.1 (March 7, 2017)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Better support for AbstractArray in JuMP (Thanks @tkoolen)\nMinor bug fixes","category":"page"},{"location":"release_notes/#[Version-0.16.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.16.0)-(February-23,-2017)","page":"Release notes","title":"Version 0.16.0 (February 23, 2017)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Breaking change: JuMP no longer has a mechanism for selecting solvers by default (the previous mechanism was flawed and incompatible with Julia 0.6). Not specifying a solver before calling solve() will result in an error.\nBreaking change: User-defined functions are no longer global. The first argument to JuMP.register is now a JuMP Model object within whose scope the function will be registered. Calling JuMP.register without a Model now produces an error.\nBreaking change: Use the new JuMP.fix method to fix a variable to a value or to update the value to which a variable is fixed. Calling setvalue on a fixed variable now results in an error in order to avoid silent behavior changes. (Thanks @joaquimg)\nNonlinear expressions now print out similarly to linear/quadratic expressions (useful for debugging!)\nNew category keyword to @variable. Used for specifying categories of anonymous variables.\nCompatibility with Julia 0.6-dev.\nMinor fixes and improvements (Thanks @cossio, @ccoffrin, @blegat)","category":"page"},{"location":"release_notes/#[Version-0.15.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.15.1)-(January-31,-2017)","page":"Release notes","title":"Version 0.15.1 (January 31, 2017)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Bugfix for @LinearConstraints and friends","category":"page"},{"location":"release_notes/#[Version-0.15.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.15.0)-(December-22,-2016)","page":"Release notes","title":"Version 0.15.0 (December 22, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Julia 0.5.0 is the minimum required version for this release.\nDocument support for BARON solver\nEnable info callbacks in more states than before, for example, for recording solutions. New when argument to addinfocallback (#814, thanks @yeesian)\nImproved support for anonymous variables. This includes new warnings for potentially confusing use of the traditional non-anonymous syntax:\nWhen multiple variables in a model are given the same name\nWhen non-symbols are used as names, for example, @variable(m, x[1][1:N])\nImprovements in iterating over JuMP containers (#836, thanks @IssamT)\nSupport for writing variable names in .lp file output (Thanks @leethargo)\nSupport for querying duals to SDP problems (Thanks @blegat)\nThe comprehension syntax with curly braces sum{}, prod{}, and norm2{} has been deprecated in favor of Julia's native comprehension syntax sum(), prod() and norm() as previously announced. (For early adopters of the new syntax, norm2() was renamed to norm() without deprecation.)\nUnit tests rewritten to use Base.Test instead of FactCheck\nImproved support for operations with matrices of JuMP types (Thanks @ExpandingMan)\nThe syntax to halt a solver from inside a callback has changed from throw(CallbackAbort()) to return JuMP.StopTheSolver\nMinor bug fixes","category":"page"},{"location":"release_notes/#[Version-0.14.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.14.2)-(December-12,-2016)","page":"Release notes","title":"Version 0.14.2 (December 12, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Allow singleton anonymous variables (includes bugfix)","category":"page"},{"location":"release_notes/#[Version-0.14.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.14.1)-(September-12,-2016)","page":"Release notes","title":"Version 0.14.1 (September 12, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"More consistent handling of states in informational callbacks, includes a new when parameter to addinfocallback for specifying in which state an informational callback should be called.","category":"page"},{"location":"release_notes/#[Version-0.14.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.14.0)-(August-7,-2016)","page":"Release notes","title":"Version 0.14.0 (August 7, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Compatibility with Julia 0.5 and ForwardDiff 0.2\nSupport for \"anonymous\" variables, constraints, expressions, and parameters, for example, x = @variable(m, [1:N]) instead of @variable(m, x[1:N])\nSupport for retrieving constraints from a model by name via getconstraint\n@NLconstraint now returns constraint references (as expected).\nSupport for vectorized expressions within lazy constraints\nOn Julia 0.5, parse new comprehension syntax sum(x[i] for i in 1:N if isodd(i)) instead of sum{ x[i], i in 1:N; isodd(i) }. The old syntax with curly braces will be deprecated in JuMP 0.15.\nNow possible to provide nonlinear expressions as \"raw\" Julia Expr objects instead of using JuMP's nonlinear macros. This input format is useful for programmatically generated expressions.\ns/Mathematical Programming/Mathematical Optimization/\nSupport for local cuts (Thanks to @madanim, Mehdi Madani)\nDocument Xpress interface developed by @joaquimg, Joaquim Dias Garcia\nMinor bug and deprecation fixes (Thanks @odow, @jrevels)","category":"page"},{"location":"release_notes/#[Version-0.13.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.13.2)-(May-16,-2016)","page":"Release notes","title":"Version 0.13.2 (May 16, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Compatibility update for MathProgBase","category":"page"},{"location":"release_notes/#[Version-0.13.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.13.1)-(May-3,-2016)","page":"Release notes","title":"Version 0.13.1 (May 3, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix broken deprecation for registerNLfunction.","category":"page"},{"location":"release_notes/#[Version-0.13.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.13.0)-(April-29,-2016)","page":"Release notes","title":"Version 0.13.0 (April 29, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Most exported methods and macros have been renamed to avoid camelCase. See the list of changes here. There is a 1-1 mapping from the old names to the new, and it is safe to simply replace the names to update existing models.\nSpecify variable lower/upper bounds in @variable using the lowerbound and upperbound keyword arguments.\nChange name printed for variable using the basename keyword argument to @variable.\nNew @variables macro allows multi-line declaration of groups of variables.\nA number of solver methods previously available only through MathProgBase are now exposed directly in JuMP. The fix was recorded live.\nCompatibility fixes with Julia 0.5.\nThe \"end\" indexing syntax is no longer supported within JuMPArrays which do not use 1-based indexing until upstream issues are resolved, see here.","category":"page"},{"location":"release_notes/#[Version-0.12.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.12.2)-(March-9,-2016)","page":"Release notes","title":"Version 0.12.2 (March 9, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Small fixes for nonlinear optimization","category":"page"},{"location":"release_notes/#[Version-0.12.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.12.1)-(March-1,-2016)","page":"Release notes","title":"Version 0.12.1 (March 1, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a regression in slicing for JuMPArrays (when not using 1-based indexing)","category":"page"},{"location":"release_notes/#[Version-0.12.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.12.0)-(February-27,-2016)","page":"Release notes","title":"Version 0.12.0 (February 27, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The automatic differentiation functionality has been completely rewritten with a number of user-facing changes:\n@defExpr and @defNLExpr now take the model as the first argument. The previous one-argument version of @defExpr is deprecated; all expressions should be named. For example, replace @defExpr(2x+y) with @defExpr(jump_model, my_expr, 2x+y).\nJuMP no longer uses Julia's variable binding rules for efficiently re-solving a sequence of nonlinear models. Instead, we have introduced nonlinear parameters. This is a breaking change, so we have added a warning message when we detect models that may depend on the old behavior.\nSupport for user-defined functions integrated within nonlinear JuMP expressions.\nReplaced iteration over AffExpr with Number-like scalar iteration; previous iteration behavior is now available via linearterms(::AffExpr).\nStopping the solver via throw(CallbackAbort()) from a callback no longer triggers an exception. Instead, solve() returns UserLimit status.\ngetDual() now works for conic problems (Thanks @emreyamangil.)","category":"page"},{"location":"release_notes/#[Version-0.11.3](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.11.3)-(February-4,-2016)","page":"Release notes","title":"Version 0.11.3 (February 4, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Bug-fix for problems with quadratic objectives and semidefinite constraints","category":"page"},{"location":"release_notes/#[Version-0.11.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.11.2)-(January-14,-2016)","page":"Release notes","title":"Version 0.11.2 (January 14, 2016)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Compatibility update for Mosek","category":"page"},{"location":"release_notes/#[Version-0.11.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.11.1)-(December-1,-2015)","page":"Release notes","title":"Version 0.11.1 (December 1, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Remove usage of @compat in tests.\nFix updating quadratic objectives for nonlinear models.","category":"page"},{"location":"release_notes/#[Version-0.11.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.11.0)-(November-30,-2015)","page":"Release notes","title":"Version 0.11.0 (November 30, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Julia 0.4.0 is the minimum required version for this release.\nFix for scoping semantics of index variables in sum{}. Index variables no longer leak into the surrounding scope.\nAddition of the solve(m::Model, relaxation=true) keyword argument to solve the standard continuous relaxation of model m\nThe getConstraintBounds() method allows access to the lower and upper bounds of all constraints in a (nonlinear) model.\nUpdate for breaking changes in MathProgBase","category":"page"},{"location":"release_notes/#[Version-0.10.3](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.10.3)-(November-20,-2015)","page":"Release notes","title":"Version 0.10.3 (November 20, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a rare error when parsing quadratic expressions\nFix Variable() constructor with default arguments\nDetect unrecognized keywords in solve()","category":"page"},{"location":"release_notes/#[Version-0.10.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.10.2)-(September-28,-2015)","page":"Release notes","title":"Version 0.10.2 (September 28, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix for deprecation warnings","category":"page"},{"location":"release_notes/#[Version-0.10.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.10.1)-(September-3,-2015)","page":"Release notes","title":"Version 0.10.1 (September 3, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixes for ambiguity warnings.\nFix for breaking change in precompilation syntax in Julia 0.4-pre","category":"page"},{"location":"release_notes/#[Version-0.10.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.10.0)-(August-31,-2015)","page":"Release notes","title":"Version 0.10.0 (August 31, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Support (on Julia 0.4 and later) for conditions in indexing @defVar and @addConstraint constructs, for example, @defVar(m, x[i=1:5,j=1:5; i+j >= 3])\nSupport for vectorized operations on Variables and expressions. See the documentation for details.\nNew getVar() method to access variables in a model by name\nSupport for semidefinite programming.\nDual solutions are now available for general nonlinear problems. You may call getDual on a reference object for a nonlinear constraint, and getDual on a variable object for Lagrange multipliers from active bounds.\nIntroduce warnings for two common performance traps: too many calls to getValue() on a collection of variables and use of the + operator in a loop to sum expressions.\nSecond-order cone constraints can be written directly with the norm() and norm2{} syntax.\nImplement MathProgBase interface for querying Hessian-vector products.\nIteration over JuMPContainers is deprecated; instead, use the keys and values functions, and zip(keys(d),values(d)) for the old behavior.\n@defVar returns Array{Variable,N} when each of N index sets are of the form 1:nᵢ.\nModule precompilation: on Julia 0.4 and later, using JuMP is now much faster.","category":"page"},{"location":"release_notes/#[Version-0.9.3](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.9.3)-(August-11,-2015)","page":"Release notes","title":"Version 0.9.3 (August 11, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixes for FactCheck testing on julia v0.4.","category":"page"},{"location":"release_notes/#[Version-0.9.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.9.2)-(June-27,-2015)","page":"Release notes","title":"Version 0.9.2 (June 27, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix bug in @addConstraints.","category":"page"},{"location":"release_notes/#[Version-0.9.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.9.1)-(April-25,-2015)","page":"Release notes","title":"Version 0.9.1 (April 25, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix for Julia 0.4-dev.\nSmall infrastructure improvements for extensions.","category":"page"},{"location":"release_notes/#[Version-0.9.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.9.0)-(April-18,-2015)","page":"Release notes","title":"Version 0.9.0 (April 18, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Comparison operators for constructing constraints (for example, 2x >= 1) have been deprecated. Instead, construct the constraints explicitly in the @addConstraint macro to add them to the model, or in the @LinearConstraint macro to create a stand-alone linear constraint instance.\ngetValue() method implemented to compute the value of a nonlinear subexpression\nJuMP is now released under the Mozilla Public License version 2.0 (was previously LGPL). MPL is a copyleft license which is less restrictive than LGPL, especially for embedding JuMP within other applications.\nA number of performance improvements in ReverseDiffSparse for computing derivatives.\nMathProgBase.getsolvetime(m) now returns the solution time reported by the solver, if available. (Thanks @odow, Oscar Dowson)\nFormatting fix for LP format output. (Thanks @sbebo, Leonardo Taccari).","category":"page"},{"location":"release_notes/#[Version-0.8.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.8.0)-(February-17,-2015)","page":"Release notes","title":"Version 0.8.0 (February 17, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Nonlinear subexpressions now supported with the @defNLExpr macro.\nSCS supported for solving second-order conic problems.\nsetXXXCallback family deprecated in favor of addXXXCallback.\nMultiple callbacks of the same type can be registered.\nAdded support for informational callbacks via addInfoCallback.\nA CallbackAbort exception can be thrown from callback to safely exit optimization.","category":"page"},{"location":"release_notes/#[Version-0.7.4](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.7.4)-(February-4,-2015)","page":"Release notes","title":"Version 0.7.4 (February 4, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Reduced costs and linear constraint duals are now accessible when quadratic constraints are present.\nTwo-sided nonlinear constraints are supported.\nMethods for accessing the number of variables and constraints in a model are renamed.\nNew default procedure for setting initial values in nonlinear optimization: project zero onto the variable bounds.\nSmall bug fixes.","category":"page"},{"location":"release_notes/#[Version-0.7.3](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.7.3)-(January-14,-2015)","page":"Release notes","title":"Version 0.7.3 (January 14, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a method ambiguity conflict with Compose.jl (cosmetic fix)","category":"page"},{"location":"release_notes/#[Version-0.7.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.7.2)-(January-9,-2015)","page":"Release notes","title":"Version 0.7.2 (January 9, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug in sum(::JuMPDict)\nAdded the setCategory function to change a variables category (for example, continuous or binary)","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"after construction, and getCategory to retrieve the variable category.","category":"page"},{"location":"release_notes/#[Version-0.7.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.7.1)-(January-2,-2015)","page":"Release notes","title":"Version 0.7.1 (January 2, 2015)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug in parsing linear expressions in macros. Affects only Julia 0.4 and later.","category":"page"},{"location":"release_notes/#[Version-0.7.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.7.0)-(December-29,-2014)","page":"Release notes","title":"Version 0.7.0 (December 29, 2014)","text":"","category":"section"},{"location":"release_notes/#Linear/quadratic/conic-programming","page":"Release notes","title":"Linear/quadratic/conic programming","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Breaking change: The syntax for column-wise model generation has been changed to use keyword arguments in @defVar.\nOn Julia 0.4 and later, variables and coefficients may be multiplied in any order within macros. That is, variable*coefficient is now valid syntax.\nECOS supported for solving second-order conic problems.","category":"page"},{"location":"release_notes/#_nonlinear_programming_release_notes","page":"Release notes","title":"Nonlinear programming","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Support for skipping model generation when solving a sequence of nonlinear models with changing data.\nFix a memory leak when solving a sequence of nonlinear models.\nThe @addNLConstraint macro now supports the three-argument version to define sets of nonlinear constraints.\nKNITRO supported as a nonlinear solver.\nSpeed improvements for model generation.\nThe @addNLConstraints macro supports adding multiple (groups of) constraints at once. Syntax is similar to @addConstraints.\nDiscrete variables allowed in nonlinear problems for solvers which support them (currently only KNITRO).","category":"page"},{"location":"release_notes/#General","page":"Release notes","title":"General","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Starting values for variables may now be specified with @defVar(m, x, start=value).\nThe setSolver function allows users to change the solver subsequent to model creation.\nSupport for \"fixed\" variables via the @defVar(m, x == 1) syntax.\nUnit tests rewritten to use FactCheck.jl, improved testing across solvers.","category":"page"},{"location":"release_notes/#[Version-0.6.3](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.6.3)-(October-19,-2014)","page":"Release notes","title":"Version 0.6.3 (October 19, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug in multiplying two AffExpr objects.","category":"page"},{"location":"release_notes/#[Version-0.6.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.6.2)-(October-11,-2014)","page":"Release notes","title":"Version 0.6.2 (October 11, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Further improvements and bug fixes for printing.\nFixed a bug in @defExpr.\nSupport for accessing expression graphs through the MathProgBase NLP interface.","category":"page"},{"location":"release_notes/#[Version-0.6.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.6.1)-(September-19,-2014)","page":"Release notes","title":"Version 0.6.1 (September 19, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Improvements and bug fixes for printing.","category":"page"},{"location":"release_notes/#[Version-0.6.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.6.0)-(September-9,-2014)","page":"Release notes","title":"Version 0.6.0 (September 9, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Julia 0.3.0 is the minimum required version for this release.\nbuildInternalModel(m::Model) added to build solver-level model in memory without optimizing.\nDeprecate load_model_only keyword argument to solve.\nAdd groups of constraints with @addConstraints macro.\nUnicode operators now supported, including ∑ for sum, ∏ for prod, and ≤/≥\nQuadratic constraints supported in @addConstraint macro.\nQuadratic objectives supported in @setObjective macro.\nMathProgBase solver-independent interface replaces Ipopt-specific interface for nonlinear problems\nBreaking change: IpoptOptions no longer supported to specify solver options, use m = Model(solver=IpoptSolver(options...)) instead.\nNew solver interfaces: ECOS, NLopt, and nonlinear support for MOSEK\nNew option to control whether the lazy constraint callback is executed at each node in the B&B tree or just when feasible solutions are found\nAdd support for semicontinuous and semi-integer variables for those solvers that support them.\nAdd support for index dependencies (for example, triangular indexing) in @defVar, @addConstraint, and @defExpr (for example, @defVar(m, x[i=1:10,j=i:10])).\nThis required some changes to the internal structure of JuMP containers, which may break code that explicitly stored JuMPDict objects.","category":"page"},{"location":"release_notes/#[Version-0.5.8](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.5.8)-(September-24,-2014)","page":"Release notes","title":"Version 0.5.8 (September 24, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug with specifying solvers (affects Julia 0.2 only)","category":"page"},{"location":"release_notes/#[Version-0.5.7](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.5.7)-(September-5,-2014)","page":"Release notes","title":"Version 0.5.7 (September 5, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug in printing models","category":"page"},{"location":"release_notes/#[Version-0.5.6](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.5.6)-(September-2,-2014)","page":"Release notes","title":"Version 0.5.6 (September 2, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Add support for semicontinuous and semi-integer variables for those solvers that support them.\nBreaking change: Syntax for Variable() constructor has changed (use of this interface remains discouraged)\nUpdate for breaking changes in MathProgBase","category":"page"},{"location":"release_notes/#[Version-0.5.5](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.5.5)-(July-6,-2014)","page":"Release notes","title":"Version 0.5.5 (July 6, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix bug with problem modification: adding variables that did not appear in existing constraints or objective.","category":"page"},{"location":"release_notes/#[Version-0.5.4](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.5.4)-(June-19,-2014)","page":"Release notes","title":"Version 0.5.4 (June 19, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Update for breaking change in MathProgBase which reduces loading times for using JuMP\nFix error when MIPs not solved to optimality","category":"page"},{"location":"release_notes/#[Version-0.5.3](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.5.3)-(May-21,-2014)","page":"Release notes","title":"Version 0.5.3 (May 21, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Update for breaking change in ReverseDiffSparse","category":"page"},{"location":"release_notes/#[Version-0.5.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.5.2)-(May-9,-2014)","page":"Release notes","title":"Version 0.5.2 (May 9, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix compatibility with Julia 0.3 prerelease","category":"page"},{"location":"release_notes/#[Version-0.5.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.5.1)-(May-5,-2014)","page":"Release notes","title":"Version 0.5.1 (May 5, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix a bug in coefficient handling inside lazy constraints and user cuts","category":"page"},{"location":"release_notes/#[Version-0.5.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.5.0)-(May-2,-2014)","page":"Release notes","title":"Version 0.5.0 (May 2, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Support for nonlinear optimization with exact, sparse second-order derivatives automatically computed. Ipopt is currently the only solver supported.\ngetValue for AffExpr and QuadExpr\nBreaking change: getSolverModel replaced by getInternalModel, which returns the internal MathProgBase-level model\nGroups of constraints can be specified with @addConstraint (see documentation for details). This is not a breaking change.\ndot(::JuMPDict{Variable},::JuMPDict{Variable}) now returns the corresponding quadratic expression.","category":"page"},{"location":"release_notes/#[Version-0.4.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.4.1)-(March-24,-2014)","page":"Release notes","title":"Version 0.4.1 (March 24, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fix bug where change in objective sense was ignored when re-solving a model.\nFix issue with handling zero coefficients in AffExpr.","category":"page"},{"location":"release_notes/#[Version-0.4.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.4.0)-(March-10,-2014)","page":"Release notes","title":"Version 0.4.0 (March 10, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Support for SOS1 and SOS2 constraints.\nSolver-independent callback for user heuristics.\ndot and sum implemented for JuMPDict objects. Now you can say @addConstraint(m, dot(a,x) <= b).\nDevelopers: support for extensions to JuMP. See definition of Model in src/JuMP.jl for more details.\nOption to construct the low-level model before optimizing.","category":"page"},{"location":"release_notes/#[Version-0.3.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.3.2)-(February-17,-2014)","page":"Release notes","title":"Version 0.3.2 (February 17, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Improved model printing\nPreliminary support for IJulia output","category":"page"},{"location":"release_notes/#[Version-0.3.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.3.1)-(January-30,-2014)","page":"Release notes","title":"Version 0.3.1 (January 30, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Documentation updates\nSupport for MOSEK\nCPLEXLink renamed to CPLEX","category":"page"},{"location":"release_notes/#[Version-0.3.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.3.0)-(January-21,-2014)","page":"Release notes","title":"Version 0.3.0 (January 21, 2014)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Unbounded/infeasibility rays: getValue() will return the corresponding components of an unbounded ray when a model is unbounded, if supported by the selected solver. getDual() will return an infeasibility ray (Farkas proof) if a model is infeasible and the selected solver supports this feature.\nSolver-independent callbacks for user generated cuts.\nUse new interface for solver-independent QCQP.\nsetlazycallback renamed to setLazyCallback for consistency.","category":"page"},{"location":"release_notes/#[Version-0.2.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.2.0)-(December-15,-2013)","page":"Release notes","title":"Version 0.2.0 (December 15, 2013)","text":"","category":"section"},{"location":"release_notes/#Breaking-8","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Objective sense is specified in setObjective instead of in the Model constructor.\nlpsolver and mipsolver merged into single solver option.","category":"page"},{"location":"release_notes/#Added-37","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Problem modification with efficient LP restarts and MIP warm-starts.\nRelatedly, column-wise modeling now supported.\nSolver-independent callbacks supported. Currently we support only a \"lazy constraint\" callback, which works with Gurobi, CPLEX, and GLPK. More callbacks coming soon.","category":"page"},{"location":"release_notes/#[Version-0.1.2](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.1.2)-(November-16,-2013)","page":"Release notes","title":"Version 0.1.2 (November 16, 2013)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Bug fixes for printing, improved error messages.\nAllow AffExpr to be used in macros; for example, ex = y + z; @addConstraint(m, x + 2*ex <= 3)","category":"page"},{"location":"release_notes/#[Version-0.1.1](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.1.1)-(October-23,-2013)","page":"Release notes","title":"Version 0.1.1 (October 23, 2013)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Update for solver specification API changes in MathProgBase.","category":"page"},{"location":"release_notes/#[Version-0.1.0](https://github.com/jump-dev/JuMP.jl/releases/tag/v0.1.0)-(October-3,-2013)","page":"Release notes","title":"Version 0.1.0 (October 3, 2013)","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Initial public release.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\n    import HiGHS\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/constraints/#jump_constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP is based on the MathOptInterface (MOI) API. Because of this, JuMP uses the following standard form to represent problems:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"beginalign\n     min_x in mathbbR^n  f_0(x)\n    \n     textst  f_i(x)  in mathcalS_i  i = 1 ldots m\nendalign","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Each constraint, f_i(x) in mathcalS_i, is composed of a function and a set. For example, instead of calling a^top x le b a less-than-or-equal-to constraint, we say that it is a scalar-affine-in-less-than constraint, where the function a^top x belongs to the less-than set (-infty b. We use the shorthand function-in-set to refer to constraints composed of different types of functions and sets.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"This page explains how to write various types of constraints in JuMP. For nonlinear constraints, see Nonlinear Modeling instead.","category":"page"},{"location":"manual/constraints/#Add-a-constraint","page":"Constraints","title":"Add a constraint","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Add a constraint to a JuMP model using the @constraint macro. The syntax to use depends on the type of constraint you wish to add.","category":"page"},{"location":"manual/constraints/#Add-a-linear-constraint","page":"Constraints","title":"Add a linear constraint","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Create linear constraints using the @constraint macro:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[1:3]);\n\njulia> @constraint(model, c1, sum(x) <= 1)\nc1 : x[1] + x[2] + x[3] ≤ 1\n\njulia> @constraint(model, c2, x[1] + 2 * x[3] >= 2)\nc2 : x[1] + 2 x[3] ≥ 2\n\njulia> @constraint(model, c3, sum(i * x[i] for i in 1:3) == 3)\nc3 : x[1] + 2 x[2] + 3 x[3] = 3\n\njulia> @constraint(model, c4, 4 <= 2 * x[2] <= 5)\nc4 : 2 x[2] ∈ [4, 5]","category":"page"},{"location":"manual/constraints/#Normalization","page":"Constraints","title":"Normalization","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP normalizes constraints by moving all of the terms containing variables to the left-hand side and all of the constant terms to the right-hand side. Thus, we get:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @constraint(model, c, 2x + 1 <= 4x + 4)\nc : -2 x ≤ 3","category":"page"},{"location":"manual/constraints/#quad_constraints","page":"Constraints","title":"Add a quadratic constraint","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In addition to affine functions, JuMP also supports constraints with quadratic terms. For example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[i=1:2])\n2-element Vector{VariableRef}:\n x[1]\n x[2]\n\njulia> @variable(model, t >= 0)\nt\n\njulia> @constraint(model, my_q, x[1]^2 + x[2]^2 <= t^2)\nmy_q : x[1]² + x[2]² - t² ≤ 0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"tip: Tip\nBecause solvers can take advantage of the knowledge that a constraint is quadratic, prefer adding quadratic constraints using @constraint, rather than @NLconstraint.","category":"page"},{"location":"manual/constraints/#Vectorized-constraints","page":"Constraints","title":"Vectorized constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"You can also add constraints to JuMP using vectorized linear algebra. For example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[i=1:2])\n2-element Vector{VariableRef}:\n x[1]\n x[2]\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> b = [5, 6]\n2-element Vector{Int64}:\n 5\n 6\n\njulia> @constraint(model, con_vector, A * x == b)\ncon_vector : [x[1] + 2 x[2] - 5, 3 x[1] + 4 x[2] - 6] ∈ MathOptInterface.Zeros(2)\n\njulia> @constraint(model, con_scalar, A * x .== b)\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}, ScalarShape}}:\n con_scalar : x[1] + 2 x[2] = 5\n con_scalar : 3 x[1] + 4 x[2] = 6","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The two constraints, == and .== are similar, but subtly different. The first creates a single constraint that is a MOI.VectorAffineFunction in MOI.Zeros constraint. The second creates a vector of MOI.ScalarAffineFunction in MOI.EqualTo constraints.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Which formulation to choose depends on the solver, and what you want to do with the constraint object con_vector or con_scalar.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If you are using a conic solver, expect the dual of con_vector to be a Vector{Float64}, and do not intend to delete a row in the constraint, choose the == formulation.\nIf you are using a solver that expects a list of scalar constraints, for example HiGHS, or you wish to delete part of the constraint or access a single row of the constraint, for example, dual(con_scalar[2]), then use the broadcast .==.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP reformulates both constraints into the other form if needed by the solver, but choosing the right format for a particular solver is more efficient.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"You can also use <=, .<= , >=, and .>= as comparison operators in the constraint.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, A * x <= b)\n[x[1] + 2 x[2] - 5, 3 x[1] + 4 x[2] - 6] ∈ MathOptInterface.Nonpositives(2)\n\njulia> @constraint(model, A * x .<= b)\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n x[1] + 2 x[2] ≤ 5\n 3 x[1] + 4 x[2] ≤ 6\n\njulia> @constraint(model, A * x >= b)\n[x[1] + 2 x[2] - 5, 3 x[1] + 4 x[2] - 6] ∈ MathOptInterface.Nonnegatives(2)\n\njulia> @constraint(model, A * x .>= b)\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}, ScalarShape}}:\n x[1] + 2 x[2] ≥ 5\n 3 x[1] + 4 x[2] ≥ 6","category":"page"},{"location":"manual/constraints/#Vectorized-matrix-constraints","page":"Constraints","title":"Vectorized matrix constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In most cases, you cannot use the non-broadcasting syntax for general matrices. For example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, X[1:2, 1:2])\n2×2 Matrix{VariableRef}:\n X[1,1]  X[1,2]\n X[2,1]  X[2,2]\n\njulia> @constraint(model, X >= 0)\nERROR: At none:1: `@constraint(model, X >= 0)`: Unsupported matrix in vector-valued set. Did you mean to use the broadcasting syntax `.>=` instead? Alternatively, perhaps you are missing a set argument like `@constraint(model, X >= 0, PSDCone())` or `@constraint(model, X >= 0, HermmitianPSDCone())`.\nStacktrace:\n[...]","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Instead, to represent matrix inequalities you must always use the element-wise broadcasting .==, .>=, or .<=, or use the Set inequality syntax.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"There are two exceptions: if the result of the left-hand side minus the right-hand side is a LinearAlgebra.Symmetric matrix or a LinearAlgebra.Hermitian matrix, you may use the non-broadcasting equality syntax:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> using LinearAlgebra\n\njulia> model = Model();\n\njulia> @variable(model, X[1:2, 1:2], Symmetric)\n2×2 Symmetric{VariableRef, Matrix{VariableRef}}:\n X[1,1]  X[1,2]\n X[1,2]  X[2,2]\n\njulia> @constraint(model, X == LinearAlgebra.I)\n[X[1,1] - 1  X[1,2];\n X[1,2]      X[2,2] - 1] ∈ Zeros()","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Despite the model showing the matrix in Zeros, this will add only three rows to the constraint matrix because the symmetric constraints are redundant. In contrast, the broadcasting syntax adds four linear constraints:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, X .== LinearAlgebra.I)\n2×2 Matrix{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}, ScalarShape}}:\n X[1,1] = 1  X[1,2] = 0\n X[1,2] = 0  X[2,2] = 1","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The same holds for LinearAlgebra.Hermitian matrices:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> using LinearAlgebra\n\njulia> model = Model();\n\njulia> @variable(model, X[1:2, 1:2] in HermitianPSDCone())\n2×2 Hermitian{GenericAffExpr{ComplexF64, VariableRef}, Matrix{GenericAffExpr{ComplexF64, VariableRef}}}:\n real(X[1,1])                    real(X[1,2]) + imag(X[1,2]) im\n real(X[1,2]) - imag(X[1,2]) im  real(X[2,2])\n\njulia> @constraint(model, X == LinearAlgebra.I)\n[real(X[1,1]) - 1                real(X[1,2]) + imag(X[1,2]) im;\n real(X[1,2]) - imag(X[1,2]) im  real(X[2,2]) - 1] ∈ Zeros()\n\njulia> @constraint(model, X .== LinearAlgebra.I)\n2×2 Matrix{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{ComplexF64}, MathOptInterface.EqualTo{ComplexF64}}, ScalarShape}}:\n real(X[1,1]) = 1                    real(X[1,2]) + imag(X[1,2]) im = 0\n real(X[1,2]) - imag(X[1,2]) im = 0  real(X[2,2]) = 1","category":"page"},{"location":"manual/constraints/#Containers-of-constraints","page":"Constraints","title":"Containers of constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The @constraint macro supports creating collections of constraints. We'll cover some brief syntax here; read the Constraint containers section for more details:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Create arrays of constraints:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[1:3]);\n\njulia> @constraint(model, c[i=1:3], x[i] <= i^2)\n3-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n c[1] : x[1] ≤ 1\n c[2] : x[2] ≤ 4\n c[3] : x[3] ≤ 9\n\njulia> c[2]\nc[2] : x[2] ≤ 4","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Sets can be any Julia type that supports iteration:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[1:3]);\n\njulia> @constraint(model, c[i=2:3, [\"red\", \"blue\"]], x[i] <= i^2)\n2-dimensional DenseAxisArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape},2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, [\"red\", \"blue\"]\nAnd data, a 2×2 Matrix{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n c[2,red] : x[2] ≤ 4  c[2,blue] : x[2] ≤ 4\n c[3,red] : x[3] ≤ 9  c[3,blue] : x[3] ≤ 9\n\njulia> c[2, \"red\"]\nc[2,red] : x[2] ≤ 4","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Sets can depend upon previous indices:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[1:3]);\n\njulia> @constraint(model, c[i=1:3, j=i:3], x[i] <= j)\nJuMP.Containers.SparseAxisArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}, 2, Tuple{Int64, Int64}} with 6 entries:\n  [1, 1]  =  c[1,1] : x[1] ≤ 1\n  [1, 2]  =  c[1,2] : x[1] ≤ 2\n  [1, 3]  =  c[1,3] : x[1] ≤ 3\n  [2, 2]  =  c[2,2] : x[2] ≤ 2\n  [2, 3]  =  c[2,3] : x[2] ≤ 3\n  [3, 3]  =  c[3,3] : x[3] ≤ 3","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"and you can filter elements in the sets using the ; syntax:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[1:9]);\n\njulia> @constraint(model, c[i=1:9; mod(i, 3) == 0], x[i] <= i)\nJuMP.Containers.SparseAxisArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}, 1, Tuple{Int64}} with 3 entries:\n  [3]  =  c[3] : x[3] ≤ 3\n  [6]  =  c[6] : x[6] ≤ 6\n  [9]  =  c[9] : x[9] ≤ 9","category":"page"},{"location":"manual/constraints/#Registered-constraints","page":"Constraints","title":"Registered constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"When you create constraints, JuMP registers them inside the model using their corresponding symbol. Get a registered name using model[:key]:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, my_c, 2x <= 1)\nmy_c : 2 x ≤ 1\n\njulia> model\nA JuMP Model\nFeasibility problem with:\nVariable: 1\n`AffExpr`-in-`MathOptInterface.LessThan{Float64}`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: my_c, x\n\njulia> model[:my_c] === my_c\ntrue","category":"page"},{"location":"manual/constraints/#Anonymous-constraints","page":"Constraints","title":"Anonymous constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To reduce the likelihood of accidental bugs, and because JuMP registers constraints inside a model, creating two constraints with the same name is an error:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, c, 2x <= 1)\nc : 2 x ≤ 1\n\njulia> @constraint(model, c, 2x <= 1)\nERROR: An object of name c is already attached to this model. If this\n    is intended, consider using the anonymous construction syntax, for example,\n    `x = @variable(model, [1:N], ...)` where the name of the object does\n    not appear inside the macro.\n\n    Alternatively, use `unregister(model, :c)` to first unregister\n    the existing name from the model. Note that this will not delete the\n    object; it will just remove the reference at `model[:c]`.\n[...]","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A common reason for encountering this error is adding constraints in a loop.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"As a work-around, JuMP provides anonymous constraints. Create an anonymous constraint by omitting the name argument:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> c = @constraint(model, 2x <= 1)\n2 x ≤ 1","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Create a container of anonymous constraints by dropping the name in front of the [:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[1:3]);\n\njulia> c = @constraint(model, [i = 1:3], x[i] <= i)\n3-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n x[1] ≤ 1\n x[2] ≤ 2\n x[3] ≤ 3","category":"page"},{"location":"manual/constraints/#Constraint-names","page":"Constraints","title":"Constraint names","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In addition to the symbol that constraints are registered with, constraints have a String name that is used for printing and writing to file formats.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Get and set the name of a constraint using name(::JuMP.ConstraintRef) and set_name(::JuMP.ConstraintRef, ::String):","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model(); @variable(model, x);\n\njulia> @constraint(model, con, x <= 1)\ncon : x ≤ 1\n\njulia> name(con)\n\"con\"\n\njulia> set_name(con, \"my_con_name\")\n\njulia> con\nmy_con_name : x ≤ 1","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Override the default choice of name using the base_name keyword:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model(); @variable(model, x);\n\njulia> con = @constraint(model, [i=1:2], x <= i, base_name = \"my_con\")\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n my_con[1] : x ≤ 1\n my_con[2] : x ≤ 2","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note that names apply to each element of the container, not to the container of constraints:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> name(con[1])\n\"my_con[1]\"\n\njulia> set_name(con[1], \"c\")\n\njulia> con\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n c : x ≤ 1\n my_con[2] : x ≤ 2","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"tip: Tip\nFor some models, setting the string name of each constraint can take a non-trivial portion of the total time required to build the model. Turn off String names by passing set_string_name = false to @constraint:julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @constraint(model, con, x <= 2, set_string_name = false)\nx ≤ 2See Disable string names for more information.","category":"page"},{"location":"manual/constraints/#Retrieve-a-constraint-by-name","page":"Constraints","title":"Retrieve a constraint by name","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Retrieve a constraint from a model using constraint_by_name:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> constraint_by_name(model, \"c\")\nc : x ≤ 1","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If the name is not present, nothing will be returned:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> constraint_by_name(model, \"bad_name\")","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"You can only look up individual constraints using constraint_by_name. Something like this will not work:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model(); @variable(model, x);\n\njulia> con = @constraint(model, [i=1:2], x <= i, base_name = \"my_con\")\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n my_con[1] : x ≤ 1\n my_con[2] : x ≤ 2\n\njulia> constraint_by_name(model, \"my_con\")","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To look up a collection of constraints, do not use constraint_by_name. Instead, register them using the model[:key] = value syntax:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model(); @variable(model, x);\n\njulia> model[:con] = @constraint(model, [i=1:2], x <= i, base_name = \"my_con\")\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n my_con[1] : x ≤ 1\n my_con[2] : x ≤ 2\n\njulia> model[:con]\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n my_con[1] : x ≤ 1\n my_con[2] : x ≤ 2","category":"page"},{"location":"manual/constraints/#String-names,-symbolic-names,-and-bindings","page":"Constraints","title":"String names, symbolic names, and bindings","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"It's common for new users to experience confusion relating to constraints. Part of the problem is the difference between the name that a constraint is registered under and the String name used for printing.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Here's a summary of the differences:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Constraints are created using @constraint.\nConstraints can be named or anonymous.\nNamed constraints have the form @constraint(model, c, expr). For named constraints:\nThe String name of the constraint is set to \"c\".\nA Julia variable c is created that binds c to  the JuMP constraint.\nThe name :c is registered as a key in the model with the value c.\nAnonymous constraints have the form c = @constraint(model, expr). For anonymous constraints:\nThe String name of the constraint is set to \"\".\nYou control the name of the Julia variable used as the binding.\nNo name is registered as a key in the model.\nThe base_name keyword can override the String name of the constraint.\nYou can manually register names in the model via model[:key] = value.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Here's an example of the differences:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> c_binding = @constraint(model, 2x <= 1, base_name = \"c\")\nc : 2 x ≤ 1\n\njulia> model\nA JuMP Model\nFeasibility problem with:\nVariable: 1\n`AffExpr`-in-`MathOptInterface.LessThan{Float64}`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: x\n\njulia> c\nERROR: UndefVarError: `c` not defined\n\njulia> c_binding\nc : 2 x ≤ 1\n\njulia> name(c_binding)\n\"c\"\n\njulia> model[:c_register] = c_binding\nc : 2 x ≤ 1\n\njulia> model\nA JuMP Model\nFeasibility problem with:\nVariable: 1\n`AffExpr`-in-`MathOptInterface.LessThan{Float64}`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: c_register, x\n\njulia> model[:c_register]\nc : 2 x ≤ 1\n\njulia> model[:c_register] === c_binding\ntrue\n\njulia> c\nERROR: UndefVarError: `c` not defined","category":"page"},{"location":"manual/constraints/#The-@constraints-macro","page":"Constraints","title":"The @constraints macro","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If you have many @constraint calls, use the @constraints macro to improve readability:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @constraints(model, begin\n           2x <= 1\n           c, x >= -1\n       end)\n(2 x ≤ 1, c : x ≥ -1)\n\njulia> print(model)\nFeasibility\nSubject to\n c : x ≥ -1\n 2 x ≤ 1","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The @constraints macro returns a tuple of the constraints that were defined.","category":"page"},{"location":"manual/constraints/#constraint_duality","page":"Constraints","title":"Duality","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP adopts the notion of conic duality from MathOptInterface. For linear programs, a feasible dual on a >= constraint is nonnegative and a feasible dual on a <= constraint is nonpositive. If the constraint is an equality constraint, it depends on which direction is binding.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"warning: Warning\nJuMP's definition of duality is independent of the objective sense. That is, the sign of feasible duals associated with a constraint depends on the direction of the constraint and not whether the problem is maximization or minimization. This is a different convention from linear programming duality in some common textbooks. If you have a linear program, and you want the textbook definition, you probably want to use shadow_price and reduced_cost instead.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The dual value associated with a constraint in the most recent solution can be accessed using the dual function. Use has_duals to check if the model has a dual solution available to query. For example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model(HiGHS.Optimizer);\n\njulia> set_silent(model)\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x <= 1)\ncon : x ≤ 1\n\njulia> @objective(model, Min, -2x)\n-2 x\n\njulia> has_duals(model)\nfalse\n\njulia> optimize!(model)\n\njulia> has_duals(model)\ntrue\n\njulia> dual(con)\n-2.0\n\njulia> @objective(model, Max, 2x)\n2 x\n\njulia> optimize!(model)\n\njulia> dual(con)\n-2.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To help users who may be less familiar with conic duality, JuMP provides shadow_price, which returns a value that can be interpreted as the improvement in the objective in response to an infinitesimal relaxation (on the scale of one unit) in the right-hand side of the constraint. shadow_price can be used only on linear constraints with a <=, >=, or == comparison operator.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In the example above, dual(con) returned -2.0 regardless of the optimization sense. However, in the second case when the optimization sense is Max, shadow_price returns:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> shadow_price(con)\n2.0","category":"page"},{"location":"manual/constraints/#Duals-of-variable-bounds","page":"Constraints","title":"Duals of variable bounds","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To query the dual variables associated with a variable bound, first obtain a constraint reference using one of UpperBoundRef, LowerBoundRef, or FixRef, and then call dual on the returned constraint reference. The reduced_cost function may simplify this process as it returns the shadow price of an active bound of a variable (or zero, if no active bound exists).","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model(HiGHS.Optimizer);\n\njulia> set_silent(model)\n\njulia> @variable(model, x <= 1)\nx\n\njulia> @objective(model, Min, -2x)\n-2 x\n\njulia> optimize!(model)\n\njulia> dual(UpperBoundRef(x))\n-2.0\n\njulia> reduced_cost(x)\n-2.0","category":"page"},{"location":"manual/constraints/#Modify-a-constant-term","page":"Constraints","title":"Modify a constant term","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"This section explains how to modify the constant term in a constraint. There are multiple ways to achieve this goal; we explain three options.","category":"page"},{"location":"manual/constraints/#Option-1:-change-the-right-hand-side","page":"Constraints","title":"Option 1: change the right-hand side","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Use set_normalized_rhs to modify the right-hand side (constant) term of a linear or quadratic  constraint. Use normalized_rhs to query the right-hand side term.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @constraint(model, con, 2x <= 1)\ncon : 2 x ≤ 1\n\njulia> set_normalized_rhs(con, 3)\n\njulia> con\ncon : 2 x ≤ 3\n\njulia> normalized_rhs(con)\n3.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"warning: Warning\nset_normalized_rhs sets the right-hand side term of the normalized constraint. See Normalization for more details.","category":"page"},{"location":"manual/constraints/#Option-2:-use-fixed-variables","page":"Constraints","title":"Option 2: use fixed variables","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If constraints are complicated, for example, they are composed of a number of components, each of which has a constant term, then it may be difficult to calculate what the right-hand side term is in the standard form.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For this situation, JuMP includes the ability to fix variables to a value using the fix function. Fixing a variable sets its lower and upper bound to the same value. Thus, changes in a constant term can be simulated by adding a new variable and fixing it to different values. Here is an example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @variable(model, const_term)\nconst_term\n\njulia> @constraint(model, con, 2x <= const_term + 1)\ncon : 2 x - const_term ≤ 1\n\njulia> fix(const_term, 1.0)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The constraint con is now equivalent to 2x <= 2.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"warning: Warning\nFixed variables are not replaced with constants when communicating the problem to a solver. Therefore, even though const_term is fixed, it is still a decision variable, and so const_term * x is bilinear.","category":"page"},{"location":"manual/constraints/#Option-3:-modify-the-function's-constant-term","page":"Constraints","title":"Option 3: modify the function's constant term","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The third option is to use add_to_function_constant. The constant given is added to the function of a func-in-set constraint. In the following example, adding 2 to the function has the effect of removing 2 to the right-hand side:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @constraint(model, con, 2x <= 1)\ncon : 2 x ≤ 1\n\njulia> add_to_function_constant(con, 2)\n\njulia> con\ncon : 2 x ≤ -1\n\njulia> normalized_rhs(con)\n-1.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In the case of interval constraints, the constant is removed from each bound:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @constraint(model, con, 0 <= 2x + 1 <= 2)\ncon : 2 x ∈ [-1, 1]\n\njulia> add_to_function_constant(con, 3)\n\njulia> con\ncon : 2 x ∈ [-4, -2]","category":"page"},{"location":"manual/constraints/#Modify-a-variable-coefficient","page":"Constraints","title":"Modify a variable coefficient","text":"","category":"section"},{"location":"manual/constraints/#Scalar-constraints","page":"Constraints","title":"Scalar constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To modify the coefficients for a linear term in a constraint, use set_normalized_coefficient. To query the current coefficient, use normalized_coefficient.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @constraint(model, con, 2x[1] + x[2] <= 1)\ncon : 2 x[1] + x[2] ≤ 1\n\njulia> set_normalized_coefficient(con, x[2], 0)\n\njulia> con\ncon : 2 x[1] ≤ 1\n\njulia> normalized_coefficient(con, x[2])\n0.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To modify quadratic terms, pass two variables:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @constraint(model, con, x[1]^2 + x[1] * x[2] <= 1)\ncon : x[1]² + x[1]*x[2] ≤ 1\n\njulia> set_normalized_coefficient(con, x[1], x[1], 2)\n\njulia> set_normalized_coefficient(con, x[1], x[2], 3)\n\njulia> con\ncon : 2 x[1]² + 3 x[1]*x[2] ≤ 1\n\njulia> normalized_coefficient(con, x[1], x[1])\n2.0\n\njulia> normalized_coefficient(con, x[1], x[2])\n3.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"warning: Warning\nset_normalized_coefficient sets the coefficient of the normalized constraint. See Normalization for more details.","category":"page"},{"location":"manual/constraints/#Vector-constraints","page":"Constraints","title":"Vector constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To modify the coefficients of a vector-valued constraint, use set_normalized_coefficient.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, [2x + 3x, 4x] in MOI.Nonnegatives(2))\ncon : [5 x, 4 x] ∈ MathOptInterface.Nonnegatives(2)\n\njulia> set_normalized_coefficient(con, x, [(1, 3.0)])\n\njulia> con\ncon : [3 x, 4 x] ∈ MathOptInterface.Nonnegatives(2)\n\njulia> set_normalized_coefficient(con, x, [(1, 2.0), (2, 5.0)])\n\njulia> con\ncon : [2 x, 5 x] ∈ MathOptInterface.Nonnegatives(2)","category":"page"},{"location":"manual/constraints/#Delete-a-constraint","page":"Constraints","title":"Delete a constraint","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Use delete to delete a constraint from a model. Use is_valid to check if a constraint belongs to a model and has not been deleted.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @constraint(model, con, 2x <= 1)\ncon : 2 x ≤ 1\n\njulia> is_valid(model, con)\ntrue\n\njulia> delete(model, con)\n\njulia> is_valid(model, con)\nfalse","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Deleting a constraint does not unregister the symbolic reference from the model. Therefore, creating a new constraint of the same name will throw an error:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\nERROR: An object of name con is already attached to this model. If this\n    is intended, consider using the anonymous construction syntax, for example,\n    `x = @variable(model, [1:N], ...)` where the name of the object does\n    not appear inside the macro.\n\n    Alternatively, use `unregister(model, :con)` to first unregister\n    the existing name from the model. Note that this will not delete the\n    object; it will just remove the reference at `model[:con]`.\n[...]","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"After calling delete, call unregister to remove the symbolic reference:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> unregister(model, :con)\n\njulia> @constraint(model, con, 2x <= 1)\ncon : 2 x ≤ 1","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"info: Info\ndelete does not automatically unregister because we do not distinguish between names that are automatically registered by JuMP macros, and names that are manually registered by the user by setting values in object_dictionary. In addition, deleting a constraint and then adding a new constraint of the same name is an easy way to introduce bugs into your code.","category":"page"},{"location":"manual/constraints/#Start-values","page":"Constraints","title":"Start values","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Provide a starting value (also called warmstart) for a constraint's primal and dual solutions using set_start_value and set_dual_start_value.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Query the starting value for a constraint's primal and dual solution using start_value and dual_start_value. If no start value has been set, the methods will return nothing.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x >= 10)\ncon : x ≥ 10\n\njulia> start_value(con)\n\njulia> set_start_value(con, 10.0)\n\njulia> start_value(con)\n10.0\n\njulia> dual_start_value(con)\n\njulia> set_dual_start_value(con, 2)\n\njulia> dual_start_value(con)\n2.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Vector-valued constraints require a vector:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[1:3])\n3-element Vector{VariableRef}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, con, x in SecondOrderCone())\ncon : [x[1], x[2], x[3]] in MathOptInterface.SecondOrderCone(3)\n\njulia> dual_start_value(con)\n\njulia> set_dual_start_value(con, [1.0, 2.0, 3.0])\n\njulia> dual_start_value(con)\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"tip: Tip\nTo simplify setting start values for all variables and constraints in a model, see set_start_values. The Primal and dual warm-starts tutorial also gives a detailed description of how to iterate over constraints in the model to set custom start values.","category":"page"},{"location":"manual/constraints/#Constraint-containers","page":"Constraints","title":"Constraint containers","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Like Variable containers, JuMP provides a mechanism for building groups of constraints compactly. References to these groups of constraints are returned in containers. Three types of constraint containers are supported: Arrays, DenseAxisArrays, and SparseAxisArrays. We explain each of these in the following.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"tip: Tip\nYou can read more about containers in the Containers section.","category":"page"},{"location":"manual/constraints/#constraint_arrays","page":"Constraints","title":"Arrays","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"One way of adding a group of constraints compactly is the following:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @constraint(model, con[i = 1:3], i * x <= i + 1)\n3-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n con[1] : x ≤ 2\n con[2] : 2 x ≤ 3\n con[3] : 3 x ≤ 4","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP returns references to the three constraints in an Array that is bound to the Julia variable con. This array can be accessed and sliced as you would with any Julia array:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> con[1]\ncon[1] : x ≤ 2\n\njulia> con[2:3]\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n con[2] : 2 x ≤ 3\n con[3] : 3 x ≤ 4","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Anonymous containers can also be constructed by dropping the name (for example, con) before the square brackets:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> con = @constraint(model, [i = 1:2], i * x <= i + 1)\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n x ≤ 2\n 2 x ≤ 3","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Just like @variable, JuMP will form an Array of constraints when it can determine at parse time that the indices are one-based integer ranges. Therefore con[1:b] will create an Array, but con[a:b] will not. A special case is con[Base.OneTo(n)] which will produce an Array. If JuMP cannot determine that the indices are one-based integer ranges (for example, in the case of con[a:b]), JuMP will create a DenseAxisArray instead.","category":"page"},{"location":"manual/constraints/#DenseAxisArrays","page":"Constraints","title":"DenseAxisArrays","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The syntax for constructing a DenseAxisArray of constraints is very similar to the syntax for constructing a DenseAxisArray of variables.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @constraint(model, con[i = 1:2, j = 2:3], i * x <= j + 1)\n2-dimensional DenseAxisArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape},2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, 2:3\nAnd data, a 2×2 Matrix{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n con[1,2] : x ≤ 3    con[1,3] : x ≤ 4\n con[2,2] : 2 x ≤ 3  con[2,3] : 2 x ≤ 4","category":"page"},{"location":"manual/constraints/#SparseAxisArrays","page":"Constraints","title":"SparseAxisArrays","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The syntax for constructing a SparseAxisArray of constraints is very similar to the syntax for constructing a SparseAxisArray of variables.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @constraint(model, con[i = 1:2, j = 1:2; i != j], i * x <= j + 1)\nJuMP.Containers.SparseAxisArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}, 2, Tuple{Int64, Int64}} with 2 entries:\n  [1, 2]  =  con[1,2] : x ≤ 3\n  [2, 1]  =  con[2,1] : 2 x ≤ 2","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"warning: Warning\nIf you have many index dimensions and a large amount of sparsity, read Performance considerations.","category":"page"},{"location":"manual/constraints/#Forcing-the-container-type","page":"Constraints","title":"Forcing the container type","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"When creating a container of constraints, JuMP will attempt to choose the tightest container type that can store the constraints. However, because this happens at parse time, it does not always make the best choice. Just like in @variable, you can force the type of container using the container keyword. For syntax and the reason behind this, take a look at the variable docs.","category":"page"},{"location":"manual/constraints/#Constraints-with-similar-indices","page":"Constraints","title":"Constraints with similar indices","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Containers are often used to create constraints over a set of indices. However, you'll often have cases in which you are repeating the indices:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @variable(model, y[1:2]);\n\njulia> @constraints(model, begin\n           [i=1:2, j=1:2, k=1:2], i * x[j] <= k\n           [i=1:2, j=1:2, k=1:2], i * y[j] <= k\n       end);","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"This is hard to read and leads to a lot of copy-paste. A more readable way is to use a for-loop:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> for i=1:2, j=1:2, k=1:2\n           @constraints(model, begin\n               i * x[j] <= k\n               i * y[j] <= k\n           end)\n       end","category":"page"},{"location":"manual/constraints/#Accessing-constraints-from-a-model","page":"Constraints","title":"Accessing constraints from a model","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Query the types of function-in-set constraints in a model using list_of_constraint_types:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[i=1:2] >= i, Int);\n\njulia> @constraint(model, x[1] + x[2] <= 1);\n\njulia> list_of_constraint_types(model)\n3-element Vector{Tuple{Type, Type}}:\n (AffExpr, MathOptInterface.LessThan{Float64})\n (VariableRef, MathOptInterface.GreaterThan{Float64})\n (VariableRef, MathOptInterface.Integer)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For a given combination of function and set type, use num_constraints to access the number of constraints and all_constraints to access a list of their references:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> num_constraints(model, VariableRef, MOI.Integer)\n2\n\njulia> cons = all_constraints(model, VariableRef, MOI.Integer)\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}, ScalarShape}}:\n x[1] integer\n x[2] integer","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"You can also count the total number of constraints in the model, but you must explicitly choose whether to count VariableRef constraints such as bound and integrality constraints:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> num_constraints(model; count_variable_in_set_constraints = true)\n5\n\njulia> num_constraints(model; count_variable_in_set_constraints = false)\n1","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The same also applies for all_constraints:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> all_constraints(model; include_variable_in_set_constraints = true)\n5-element Vector{ConstraintRef}:\n x[1] + x[2] ≤ 1\n x[1] ≥ 1\n x[2] ≥ 2\n x[1] integer\n x[2] integer\n\njulia> all_constraints(model; include_variable_in_set_constraints = false)\n1-element Vector{ConstraintRef}:\n x[1] + x[2] ≤ 1","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If you need finer-grained control on which constraints to include, use a variant of:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> sum(\n           num_constraints(model, F, S) for\n           (F, S) in list_of_constraint_types(model) if F != VariableRef\n       )\n1","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Use constraint_object to get an instance of an AbstractConstraint object that stores the constraint data:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> con = constraint_object(cons[1])\nScalarConstraint{VariableRef, MathOptInterface.Integer}(x[1], MathOptInterface.Integer())\n\njulia> con.func\nx[1]\n\njulia> con.set\nMathOptInterface.Integer()","category":"page"},{"location":"manual/constraints/#MathOptInterface-constraints","page":"Constraints","title":"MathOptInterface constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Because JuMP is based on MathOptInterface, you can add any constraints supported by MathOptInterface using the function-in-set syntax. For a list of supported functions and sets, read Standard form problem.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nWe use MOI as an alias for the MathOptInterface module. This alias is defined by using JuMP. You may also define it in your code as follows:import MathOptInterface as MOI","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For example, the following two constraints are equivalent:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[1:3]);\n\njulia> @constraint(model, 2 * x[1] <= 1)\n2 x[1] ≤ 1\n\njulia> @constraint(model, 2 * x[1] in MOI.LessThan(1.0))\n2 x[1] ≤ 1","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"You can also use any set defined by MathOptInterface:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x - [1; 2; 3] in MOI.Nonnegatives(3))\n[x[1] - 1, x[2] - 2, x[3] - 3] ∈ MathOptInterface.Nonnegatives(3)\n\njulia> @constraint(model, x in MOI.ExponentialCone())\n[x[1], x[2], x[3]] ∈ MathOptInterface.ExponentialCone()","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"info: Info\nSimilar to how JuMP defines the <= and >= syntax as a convenience way to specify MOI.LessThan and MOI.GreaterThan constraints, the remaining sections in this page describe functions and syntax that have been added for the convenience of common modeling situations.","category":"page"},{"location":"manual/constraints/#Set-inequality-syntax","page":"Constraints","title":"Set inequality syntax","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For modeling convenience, the syntax @constraint(model, x >= y, Set()) is short-hand for @constraint(model, x - y in Set()). Therefore, the following calls are equivalent:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> y = [0.5, 0.75];\n\njulia> @constraint(model, x >= y, MOI.Nonnegatives(2))\n[x[1] - 0.5, x[2] - 0.75] ∈ MathOptInterface.Nonnegatives(2)\n\njulia> @constraint(model, y <= x, MOI.Nonnegatives(2))\n[x[1] - 0.5, x[2] - 0.75] ∈ MathOptInterface.Nonnegatives(2)\n\njulia> @constraint(model, x - y in MOI.Nonnegatives(2))\n[x[1] - 0.5, x[2] - 0.75] ∈ MathOptInterface.Nonnegatives(2)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Non-zero constants are not supported in this syntax:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x >= 1, MOI.Nonnegatives(2))\nERROR: Operation `sub_mul` between `Vector{VariableRef}` and `Int64` is not allowed. This most often happens when you write a constraint like `x >= y` where `x` is an array and `y` is a constant. Use the broadcast syntax `x .- y >= 0` instead.\nStacktrace:\n[...]","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Use instead:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x .- 1 >= 0, MOI.Nonnegatives(2))\n[x[1] - 1, x[2] - 1] ∈ MathOptInterface.Nonnegatives(2)","category":"page"},{"location":"manual/constraints/#Second-order-cone-constraints","page":"Constraints","title":"Second-order cone constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A SecondOrderCone constrains the variables t and x to the set:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"x_2 le t","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"and t ge 0. It can be added as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, t)\nt\n\njulia> @variable(model, x[1:2])\n2-element Vector{VariableRef}:\n x[1]\n x[2]\n\njulia> @constraint(model, [t; x] in SecondOrderCone())\n[t, x[1], x[2]] ∈ MathOptInterface.SecondOrderCone(3)","category":"page"},{"location":"manual/constraints/#Rotated-second-order-cone-constraints","page":"Constraints","title":"Rotated second-order cone constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A RotatedSecondOrderCone constrains the variables t, u, and x to the set:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"x_2^2 le 2 t cdot u","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"and t u ge 0. It can be added as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, t)\nt\n\njulia> @variable(model, u)\nu\n\njulia> @variable(model, x[1:2])\n2-element Vector{VariableRef}:\n x[1]\n x[2]\n\njulia> @constraint(model, [t; u; x] in RotatedSecondOrderCone())\n[t, u, x[1], x[2]] ∈ MathOptInterface.RotatedSecondOrderCone(4)","category":"page"},{"location":"manual/constraints/#Special-Ordered-Sets-of-Type-1","page":"Constraints","title":"Special Ordered Sets of Type 1","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In a Special Ordered Set of Type 1 (often denoted SOS-I or SOS1), at most one element can take a non-zero value.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Construct SOS-I constraints using the SOS1 set:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[1:3])\n3-element Vector{VariableRef}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in SOS1())\n[x[1], x[2], x[3]] in MathOptInterface.SOS1{Float64}([1.0, 2.0, 3.0])","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Although not required for feasibility, solvers can benefit from an ordering of the variables (for example, the variables represent different factories to build, at most one factory can be built, and the factories can be ordered according to cost). To induce an ordering, a vector of weights can be provided, and the variables are ordered according to their corresponding weight.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For example, in the constraint:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in SOS1([3.1, 1.2, 2.3]))\n[x[1], x[2], x[3]] in MathOptInterface.SOS1{Float64}([3.1, 1.2, 2.3])","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"the variables x have precedence x[2], x[3], x[1].","category":"page"},{"location":"manual/constraints/#Special-Ordered-Sets-of-Type-2","page":"Constraints","title":"Special Ordered Sets of Type 2","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In a Special Ordered Set of Type 2 (SOS-II), at most two elements can be non-zero, and if there are two non-zeros, they must be consecutive according to the ordering induced by a weight vector.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Construct SOS-II constraints using the SOS2 set:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in SOS2([3.0, 1.0, 2.0]))\n[x[1], x[2], x[3]] in MathOptInterface.SOS2{Float64}([3.0, 1.0, 2.0])","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The possible non-zero pairs are (x[1], x[3]) and (x[2], x[3]):","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If the weight vector is omitted, JuMP induces an ordering from 1:length(x):","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in SOS2())\n[x[1], x[2], x[3]] in MathOptInterface.SOS2{Float64}([1.0, 2.0, 3.0])","category":"page"},{"location":"manual/constraints/#Indicator-constraints","page":"Constraints","title":"Indicator constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Indicator constraints consist of a binary variable and a linear constraint. The constraint holds when the binary variable takes the value 1. The constraint may or may not hold when the binary variable takes the value 0.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To enforce the constraint x + y <= 1 when the binary variable a is 1, use:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @variable(model, a, Bin)\na\n\njulia> @constraint(model, a --> {x + y <= 1})\na --> {x + y ≤ 1}","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If the constraint must hold when a is zero, add ! or ¬ before the binary variable;","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, !a --> {x + y <= 1})\n!a --> {x + y ≤ 1}","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"warning: Warning\nYou cannot use an expression for the left-hand side of an indicator constraint.","category":"page"},{"location":"manual/constraints/#Semidefinite-constraints","page":"Constraints","title":"Semidefinite constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To constrain a matrix to be positive semidefinite (PSD), use PSDCone:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, X[1:2, 1:2])\n2×2 Matrix{VariableRef}:\n X[1,1]  X[1,2]\n X[2,1]  X[2,2]\n\njulia> @constraint(model, X >= 0, PSDCone())\n[X[1,1]  X[1,2];\n X[2,1]  X[2,2]] ∈ PSDCone()","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"tip: Tip\nWhere possible, prefer constructing a matrix of Semidefinite variables using the @variable macro, rather than adding a constraint like @constraint(model, X >= 0, PSDCone()). In some solvers, adding the constraint via @constraint is less efficient, and can result in additional intermediate variables and constraints being added to the model.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The inequality X >= Y between two square matrices X and Y is understood as constraining X - Y to be positive semidefinite.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> Y = [1 2; 2 1]\n2×2 Matrix{Int64}:\n 1  2\n 2  1\n\njulia> @constraint(model, X >= Y, PSDCone())\n[X[1,1] - 1  X[1,2] - 2;\n X[2,1] - 2  X[2,2] - 1] ∈ PSDCone()","category":"page"},{"location":"manual/constraints/#Symmetry","page":"Constraints","title":"Symmetry","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Solvers supporting PSD constraints usually expect to be given a matrix that is symbolically symmetric, that is, for which the expression in corresponding off-diagonal entries are the same. In our example, the expressions of entries (1, 2) and (2, 1) are respectively X[1,2] - 2 and X[2,1] - 2 which are different.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To bridge the gap between the constraint modeled and what the solver expects, solvers may add an equality constraint X[1,2] - 2 == X[2,1] - 2 to force symmetry. Use LinearAlgebra.Symmetric to explicitly tell the solver that the matrix is symmetric:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> import LinearAlgebra\n\njulia> Z = [X[1, 1] X[1, 2]; X[1, 2] X[2, 2]]\n2×2 Matrix{VariableRef}:\n X[1,1]  X[1,2]\n X[1,2]  X[2,2]\n\njulia> @constraint(model, LinearAlgebra.Symmetric(Z) >= 0, PSDCone())\n[X[1,1]  X[1,2];\n X[1,2]  X[2,2]] ∈ PSDCone()","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note that the lower triangular entries are ignored even if they are different so use it with caution:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, LinearAlgebra.Symmetric(X) >= 0, PSDCone())\n[X[1,1]  X[1,2];\n X[1,2]  X[2,2]] ∈ PSDCone()","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"(Note the (2, 1) element of the constraint is X[1,2], not X[2,1].)","category":"page"},{"location":"manual/constraints/#Complementarity-constraints","page":"Constraints","title":"Complementarity constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A mixed complementarity constraint F(x) ⟂ x consists of finding x in the interval [lb, ub], such that the following holds:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"F(x) == 0 if lb < x < ub\nF(x) >= 0 if lb == x\nF(x) <= 0 if x == ub","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP supports mixed complementarity constraints via complements(F(x), x) or F(x) ⟂ x in the @constraint macro. The interval set [lb, ub] is obtained from the variable bounds on x.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For example, to define the problem 2x - 1 ⟂ x with x ∈ [0, ∞), do:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x >= 0)\nx\n\njulia> @constraint(model, 2x - 1 ⟂ x)\n[2 x - 1, x] ∈ MathOptInterface.Complements(2)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"This problem has a unique solution at x = 0.5.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The perp operator ⟂ can be entered in most editors (and the Julia REPL) by typing \\perp<tab>.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"An alternative approach that does not require the ⟂ symbol uses the complements function as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, complements(2x - 1, x))\n[2 x - 1, x] ∈ MathOptInterface.Complements(2)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In both cases, the mapping F(x) is supplied as the first argument, and the matching variable x is supplied as the second.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Vector-valued complementarity constraints are also supported:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, -2 <= y[1:2] <= 2)\n2-element Vector{VariableRef}:\n y[1]\n y[2]\n\njulia> M = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> q = [5, 6]\n2-element Vector{Int64}:\n 5\n 6\n\njulia> @constraint(model, M * y + q ⟂ y)\n[y[1] + 2 y[2] + 5, 3 y[1] + 4 y[2] + 6, y[1], y[2]] ∈ MathOptInterface.Complements(4)","category":"page"},{"location":"manual/constraints/#Boolean-constraints","page":"Constraints","title":"Boolean constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Add a Boolean constraint (a MOI.EqualTo{Bool} set) using the := operator with a Bool right-hand side term:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = GenericModel{Bool}();\n\njulia> @variable(model, x[1:2]);\n\njulia> @constraint(model, x[1] || x[2] := true)\nx[1] || x[2] = true\n\njulia> @constraint(model, x[1] && x[2] := false)\nx[1] && x[2] = false\n\njulia> model\nA JuMP Model\nFeasibility problem with:\nVariables: 2\n`GenericNonlinearExpr{GenericVariableRef{Bool}}`-in-`MathOptInterface.EqualTo{Bool}`: 2 constraints\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: x","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Boolean constraints should not be added using the == operator because JuMP will rewrite the constraint as lhs - rhs = 0, and because constraints like a == b == c require parentheses to disambiguate between (a == b) == c and a == (b == c). In contrast, a == b := c is equivalent to (a == b) := c:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> rhs = false\nfalse\n\njulia> @constraint(model, (x[1] == x[2]) == rhs)\n(x[1] == x[2]) - 0.0 = 0\n\njulia> @constraint(model, x[1] == x[2] := rhs)\nx[1] == x[2] = false","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"EditURL = \"power_systems.jl\"","category":"page"},{"location":"tutorials/applications/power_systems/#Power-Systems","page":"Power Systems","title":"Power Systems","text":"","category":"section"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"This tutorial was originally contributed by Yury Dvorkin and Miles Lubin.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"This tutorial demonstrates how to formulate basic power systems engineering models in JuMP.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"We will consider basic \"economic dispatch\" and \"unit commitment\" models without taking into account transmission constraints.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"For this tutorial, we use the following packages:","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"using JuMP\nimport DataFrames\nimport HiGHS\nimport Plots\nimport StatsPlots","category":"page"},{"location":"tutorials/applications/power_systems/#Economic-dispatch","page":"Power Systems","title":"Economic dispatch","text":"","category":"section"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Economic dispatch (ED) is an optimization problem that minimizes the cost of supplying energy demand subject to operational constraints on power system assets. In its simplest modification, ED is an LP problem solved for an aggregated load and wind forecast and for a single infinitesimal moment.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Mathematically, the ED problem can be written as follows:","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"min sum_i in I c^g_i cdot g_i + c^w cdot w","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"where c_i and g_i are the incremental cost ($/MWh) and power output (MW) of the i^th generator, respectively, and c^w and w are the incremental cost ($/MWh) and wind power injection (MW), respectively.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Subject to the constraints:","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Minimum (g^min) and maximum (g^max) limits on power outputs of generators: g^min_i leq g_i leq g^max_i\nConstraint on the wind power injection: 0 leq w leq w^f where w and w^f are the wind power injection and wind power forecast, respectively.\nPower balance constraint: sum_i in I g_i + w = d^f where d^f is the demand forecast.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Further reading on ED models can be found in A. J. Wood, B. F. Wollenberg, and G. B. Sheblé, \"Power Generation, Operation and Control,\" Wiley, 2013.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Define some input data about the test system.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"We define some thermal generators:","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"function ThermalGenerator(\n    min::Float64,\n    max::Float64,\n    fixed_cost::Float64,\n    variable_cost::Float64,\n)\n    return (\n        min = min,\n        max = max,\n        fixed_cost = fixed_cost,\n        variable_cost = variable_cost,\n    )\nend\n\ngenerators = [\n    ThermalGenerator(0.0, 1000.0, 1000.0, 50.0),\n    ThermalGenerator(300.0, 1000.0, 0.0, 100.0),\n]","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"A wind generator","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"WindGenerator(variable_cost::Float64) = (variable_cost = variable_cost,)\n\nwind_generator = WindGenerator(50.0)","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"And a scenario","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"function Scenario(demand::Float64, wind::Float64)\n    return (demand = demand, wind = wind)\nend\n\nscenario = Scenario(1500.0, 200.0)","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Create a function solve_economic_dispatch, which solves the economic dispatch problem for a given set of input parameters.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"function solve_economic_dispatch(generators::Vector, wind, scenario)\n    # Define the economic dispatch (ED) model\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    # Define decision variables\n    # power output of generators\n    N = length(generators)\n    @variable(model, generators[i].min <= g[i = 1:N] <= generators[i].max)\n    # wind power injection\n    @variable(model, 0 <= w <= scenario.wind)\n    # Define the objective function\n    @objective(\n        model,\n        Min,\n        sum(generators[i].variable_cost * g[i] for i in 1:N) +\n        wind.variable_cost * w,\n    )\n    # Define the power balance constraint\n    @constraint(model, sum(g[i] for i in 1:N) + w == scenario.demand)\n    # Solve statement\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    # return the optimal value of the objective function and its minimizers\n    return (\n        g = value.(g),\n        w = value(w),\n        wind_spill = scenario.wind - value(w),\n        total_cost = objective_value(model),\n    )\nend","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Solve the economic dispatch problem","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"solution = solve_economic_dispatch(generators, wind_generator, scenario);\n\nprintln(\"Dispatch of Generators: \", solution.g, \" MW\")\nprintln(\"Dispatch of Wind: \", solution.w, \" MW\")\nprintln(\"Wind spillage: \", solution.wind_spill, \" MW\")\nprintln(\"Total cost: \\$\", solution.total_cost)","category":"page"},{"location":"tutorials/applications/power_systems/#Economic-dispatch-with-adjustable-incremental-costs","page":"Power Systems","title":"Economic dispatch with adjustable incremental costs","text":"","category":"section"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"In the following exercise we adjust the incremental cost of generator G1 and observe its impact on the total cost.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"function scale_generator_cost(g, scale)\n    return ThermalGenerator(g.min, g.max, g.fixed_cost, scale * g.variable_cost)\nend\n\nstart = time()\nc_g_scale_df = DataFrames.DataFrame(;\n    # Scale factor\n    scale = Float64[],\n    # Dispatch of Generator 1 [MW]\n    dispatch_G1 = Float64[],\n    # Dispatch of Generator 2 [MW]\n    dispatch_G2 = Float64[],\n    # Dispatch of Wind [MW]\n    dispatch_wind = Float64[],\n    # Spillage of Wind [MW]\n    spillage_wind = Float64[],\n    # Total cost [$]\n    total_cost = Float64[],\n)\nfor c_g1_scale in 0.5:0.1:3.0\n    # Update the incremental cost of the first generator at every iteration.\n    new_generators = scale_generator_cost.(generators, [c_g1_scale, 1.0])\n    # Solve the economic-dispatch problem with the updated incremental cost\n    sol = solve_economic_dispatch(new_generators, wind_generator, scenario)\n    push!(\n        c_g_scale_df,\n        (c_g1_scale, sol.g[1], sol.g[2], sol.w, sol.wind_spill, sol.total_cost),\n    )\nend\nprint(string(\"elapsed time: \", time() - start, \" seconds\"))","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"c_g_scale_df","category":"page"},{"location":"tutorials/applications/power_systems/#Modifying-the-JuMP-model-in-place","page":"Power Systems","title":"Modifying the JuMP model in-place","text":"","category":"section"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Note that in the previous exercise we entirely rebuilt the optimization model at every iteration of the internal loop, which incurs an additional computational burden. This burden can be alleviated if instead of re-building the entire model, we modify the constraints or objective function, as it shown in the example below.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Compare the computing time in case of the above and below models.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"function solve_economic_dispatch_inplace(\n    generators::Vector,\n    wind,\n    scenario,\n    scale::AbstractVector{Float64},\n)\n    obj_out = Float64[]\n    w_out = Float64[]\n    g1_out = Float64[]\n    g2_out = Float64[]\n    # This function only works for two generators\n    @assert length(generators) == 2\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    N = length(generators)\n    @variable(model, generators[i].min <= g[i = 1:N] <= generators[i].max)\n    @variable(model, 0 <= w <= scenario.wind)\n    @objective(\n        model,\n        Min,\n        sum(generators[i].variable_cost * g[i] for i in 1:N) +\n        wind.variable_cost * w,\n    )\n    @constraint(model, sum(g[i] for i in 1:N) + w == scenario.demand)\n    for c_g1_scale in scale\n        @objective(\n            model,\n            Min,\n            c_g1_scale * generators[1].variable_cost * g[1] +\n            generators[2].variable_cost * g[2] +\n            wind.variable_cost * w,\n        )\n        optimize!(model)\n        @assert is_solved_and_feasible(model)\n        push!(obj_out, objective_value(model))\n        push!(w_out, value(w))\n        push!(g1_out, value(g[1]))\n        push!(g2_out, value(g[2]))\n    end\n    df = DataFrames.DataFrame(;\n        scale = scale,\n        dispatch_G1 = g1_out,\n        dispatch_G2 = g2_out,\n        dispatch_wind = w_out,\n        spillage_wind = scenario.wind .- w_out,\n        total_cost = obj_out,\n    )\n    return df\nend\n\nstart = time()\ninplace_df = solve_economic_dispatch_inplace(\n    generators,\n    wind_generator,\n    scenario,\n    0.5:0.1:3.0,\n)\nprint(string(\"elapsed time: \", time() - start, \" seconds\"))","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"For small models, adjusting specific constraints or the objective function is sometimes faster and sometimes slower than re-building the entire model. However, as the problem size increases, updating the model in-place is usually faster.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"inplace_df","category":"page"},{"location":"tutorials/applications/power_systems/#Inefficient-usage-of-wind-generators","page":"Power Systems","title":"Inefficient usage of wind generators","text":"","category":"section"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"The economic dispatch problem does not perform commitment decisions and, thus, assumes that all generators must be dispatched at least at their minimum power output limit. This approach is not cost efficient and may lead to absurd decisions. For example, if d = sum_i in I g^min_i, the wind power injection must be zero, that is, all available wind generation is spilled, to meet the minimum power output constraints on generators.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"In the following example, we adjust the total demand and observed how it affects wind spillage.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"demand_scale_df = DataFrames.DataFrame(;\n    demand = Float64[],\n    dispatch_G1 = Float64[],\n    dispatch_G2 = Float64[],\n    dispatch_wind = Float64[],\n    spillage_wind = Float64[],\n    total_cost = Float64[],\n)\n\nfunction scale_demand(scenario, scale)\n    return Scenario(scale * scenario.demand, scenario.wind)\nend\n\nfor demand_scale in 0.2:0.1:1.4\n    new_scenario = scale_demand(scenario, demand_scale)\n    sol = solve_economic_dispatch(generators, wind_generator, new_scenario)\n    push!(\n        demand_scale_df,\n        (\n            new_scenario.demand,\n            sol.g[1],\n            sol.g[2],\n            sol.w,\n            sol.wind_spill,\n            sol.total_cost,\n        ),\n    )\nend\n\ndemand_scale_df","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"dispatch_plot = StatsPlots.@df(\n    demand_scale_df,\n    Plots.plot(\n        :demand,\n        [:dispatch_G1, :dispatch_G2],\n        labels = [\"G1\" \"G2\"],\n        title = \"Thermal Dispatch\",\n        legend = :bottomright,\n        linewidth = 3,\n        xlabel = \"Demand\",\n        ylabel = \"Dispatch [MW]\",\n    ),\n)\n\nwind_plot = StatsPlots.@df(\n    demand_scale_df,\n    Plots.plot(\n        :demand,\n        [:dispatch_wind, :spillage_wind],\n        labels = [\"Dispatch\" \"Spillage\"],\n        title = \"Wind\",\n        legend = :bottomright,\n        linewidth = 3,\n        xlabel = \"Demand [MW]\",\n        ylabel = \"Energy [MW]\",\n    ),\n)\n\nPlots.plot(dispatch_plot, wind_plot)","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"This particular drawback can be overcome by introducing binary decisions on the \"on/off\" status of generators. This model is called unit commitment and considered later in these notes.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"For further reading on the interplay between wind generation and the minimum power output constraints of generators, we refer interested readers to R. Baldick, \"Wind and energy markets: a case study of Texas,\" IEEE Systems Journal, vol. 6, pp. 27-34, 2012.","category":"page"},{"location":"tutorials/applications/power_systems/#Unit-commitment","page":"Power Systems","title":"Unit commitment","text":"","category":"section"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"The Unit Commitment (UC) model can be obtained from ED model by introducing binary variable associated with each generator. This binary variable can attain two values: if it is \"1,\" the generator is synchronized and, thus, can be dispatched, otherwise, that is, if the binary variable is \"0,\" that generator is not synchronized and its power output is set to 0.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"To obtain the mathematical formulation of the UC model, we will modify the constraints of the ED model as follows:","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"g^min_i cdot u_ti leq g_i leq g^max_i cdot u_ti","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"where u_i in 01 In this constraint, if u_i = 0, then g_i  = 0. On the other hand, if u_i = 1, then g^min_i leq g_i leq g^max_i.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"For further reading on the UC problem we refer interested readers to G. Morales-Espana, J. M. Latorre, and A. Ramos, \"Tight and Compact MILP Formulation for the Thermal Unit Commitment Problem,\" IEEE Transactions on Power Systems, vol. 28, pp. 4897-4908, 2013.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"In the following example we convert the ED model explained above to the UC model.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"function solve_unit_commitment(generators::Vector, wind, scenario)\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    N = length(generators)\n    @variable(model, 0 <= g[i = 1:N] <= generators[i].max)\n    @variable(model, 0 <= w <= scenario.wind)\n    @constraint(model, sum(g[i] for i in 1:N) + w == scenario.demand)\n    # !!! New: add binary on-off variables for each generator\n    @variable(model, u[i = 1:N], Bin)\n    @constraint(model, [i = 1:N], g[i] <= generators[i].max * u[i])\n    @constraint(model, [i = 1:N], g[i] >= generators[i].min * u[i])\n    @objective(\n        model,\n        Min,\n        sum(generators[i].variable_cost * g[i] for i in 1:N) +\n        wind.variable_cost * w +\n        # !!! new\n        sum(generators[i].fixed_cost * u[i] for i in 1:N)\n    )\n    optimize!(model)\n    status = termination_status(model)\n    if status != OPTIMAL\n        return (status = status,)\n    end\n    @assert primal_status(model) == FEASIBLE_POINT\n    return (\n        status = status,\n        g = value.(g),\n        w = value(w),\n        wind_spill = scenario.wind - value(w),\n        u = value.(u),\n        total_cost = objective_value(model),\n    )\nend","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Solve the unit commitment problem","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"solution = solve_unit_commitment(generators, wind_generator, scenario)\n\nprintln(\"Dispatch of Generators: \", solution.g, \" MW\")\nprintln(\"Commitments of Generators: \", solution.u)\nprintln(\"Dispatch of Wind: \", solution.w, \" MW\")\nprintln(\"Wind spillage: \", solution.wind_spill, \" MW\")\nprintln(\"Total cost: \\$\", solution.total_cost)","category":"page"},{"location":"tutorials/applications/power_systems/#Unit-commitment-as-a-function-of-demand","page":"Power Systems","title":"Unit commitment as a function of demand","text":"","category":"section"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"After implementing the unit commitment model, we can now assess the interplay between the minimum power output constraints on generators and wind generation.","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"uc_df = DataFrames.DataFrame(;\n    demand = Float64[],\n    commitment_G1 = Float64[],\n    commitment_G2 = Float64[],\n    dispatch_G1 = Float64[],\n    dispatch_G2 = Float64[],\n    dispatch_wind = Float64[],\n    spillage_wind = Float64[],\n    total_cost = Float64[],\n)\n\nfor demand_scale in 0.2:0.1:1.4\n    new_scenario = scale_demand(scenario, demand_scale)\n    sol = solve_unit_commitment(generators, wind_generator, new_scenario)\n    if sol.status == OPTIMAL\n        push!(\n            uc_df,\n            (\n                new_scenario.demand,\n                sol.u[1],\n                sol.u[2],\n                sol.g[1],\n                sol.g[2],\n                sol.w,\n                sol.wind_spill,\n                sol.total_cost,\n            ),\n        )\n    end\n    println(\"Status: $(sol.status) for demand_scale = $(demand_scale)\")\nend","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"uc_df","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"commitment_plot = StatsPlots.@df(\n    uc_df,\n    Plots.plot(\n        :demand,\n        [:commitment_G1, :commitment_G2],\n        labels = [\"G1\" \"G2\"],\n        title = \"Commitment\",\n        legend = :bottomright,\n        linewidth = 3,\n        xlabel = \"Demand [MW]\",\n        ylabel = \"Commitment decision {0, 1}\",\n    ),\n)\n\ndispatch_plot = StatsPlots.@df(\n    uc_df,\n    Plots.plot(\n        :demand,\n        [:dispatch_G1, :dispatch_G2, :dispatch_wind],\n        labels = [\"G1\" \"G2\" \"Wind\"],\n        title = \"Dispatch [MW]\",\n        legend = :bottomright,\n        linewidth = 3,\n        xlabel = \"Demand\",\n        ylabel = \"Dispatch [MW]\",\n    ),\n)\n\nPlots.plot(commitment_plot, dispatch_plot)","category":"page"},{"location":"tutorials/applications/power_systems/#Nonlinear-economic-dispatch","page":"Power Systems","title":"Nonlinear economic dispatch","text":"","category":"section"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"As a final example, we modify our economic dispatch problem in two ways:","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"The thermal cost function is user-defined\nThe output of the wind is only the square-root of the dispatch","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"import Ipopt\n\n\"\"\"\n    thermal_cost_function(g)\n\nA user-defined thermal cost function in pure-Julia! You can include\nnonlinearities, and even things like control flow.\n\n!!! warning\n    It's still up to you to make sure that the function has a meaningful\n    derivative.\n\"\"\"\nfunction thermal_cost_function(g)\n    if g <= 500\n        return g\n    else\n        return g + 1e-2 * (g - 500)^2\n    end\nend\n\nfunction solve_nonlinear_economic_dispatch(\n    generators::Vector,\n    wind,\n    scenario;\n    silent::Bool = false,\n)\n    model = Model(Ipopt.Optimizer)\n    if silent\n        set_silent(model)\n    end\n    @operator(model, op_tcf, 1, thermal_cost_function)\n    N = length(generators)\n    @variable(model, generators[i].min <= g[i = 1:N] <= generators[i].max)\n    @variable(model, 0 <= w <= scenario.wind)\n    @objective(\n        model,\n        Min,\n        sum(generators[i].variable_cost * op_tcf(g[i]) for i in 1:N) +\n        wind.variable_cost * w,\n    )\n    @constraint(model, sum(g[i] for i in 1:N) + sqrt(w) == scenario.demand)\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    return (\n        g = value.(g),\n        w = value(w),\n        wind_spill = scenario.wind - value(w),\n        total_cost = objective_value(model),\n    )\nend\n\nsolution =\n    solve_nonlinear_economic_dispatch(generators, wind_generator, scenario)","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"Now let's see how the wind is dispatched as a function of the cost:","category":"page"},{"location":"tutorials/applications/power_systems/","page":"Power Systems","title":"Power Systems","text":"wind_cost = 0.0:1:100\nwind_dispatch = Float64[]\nfor c in wind_cost\n    sol = solve_nonlinear_economic_dispatch(\n        generators,\n        WindGenerator(c),\n        scenario;\n        silent = true,\n    )\n    push!(wind_dispatch, sol.w)\nend\n\nPlots.plot(\n    wind_cost,\n    wind_dispatch;\n    xlabel = \"Cost\",\n    ylabel = \"Dispatch [MW]\",\n    label = false,\n)","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"EditURL = \"logistic_regression.jl\"","category":"page"},{"location":"tutorials/conic/logistic_regression/#Logistic-regression","page":"Logistic regression","title":"Logistic regression","text":"","category":"section"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"This tutorial was originally contributed by François Pacaud.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"This tutorial shows how to solve a logistic regression problem with JuMP. Logistic regression is a well known method in machine learning, useful when we want to classify binary variables with the help of a given set of features. To this goal, we find the optimal combination of features maximizing the (log)-likelihood onto a training set. From a modern optimization glance, the resulting problem is convex and differentiable. On a modern optimization glance, it is even conic representable.","category":"page"},{"location":"tutorials/conic/logistic_regression/#Formulating-the-logistic-regression-problem","page":"Logistic regression","title":"Formulating the logistic regression problem","text":"","category":"section"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"Suppose we have a set of training data-point i = 1 cdots n, where for each i we have a vector of features x_i in mathbbR^p and a categorical observation y_i in -1 1.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"The log-likelihood is given by","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"l(theta) = sum_i=1^n log(dfrac11 + exp(-y_i theta^top x_i))","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"and the optimal theta minimizes the logistic loss function:","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"min_theta sum_i=1^n log(1 + exp(-y_i theta^top x_i))","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"Most of the time, instead of solving directly the previous optimization problem, we prefer to add a regularization term:","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"min_theta sum_i=1^n log(1 + exp(-y_i theta^top x_i)) + lambda  theta ","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"with lambda in mathbbR_+ a penalty and  a norm function. By adding such a regularization term, we avoid overfitting on the training set and usually achieve a greater score in cross-validation.","category":"page"},{"location":"tutorials/conic/logistic_regression/#Reformulation-as-a-conic-optimization-problem","page":"Logistic regression","title":"Reformulation as a conic optimization problem","text":"","category":"section"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"By introducing auxiliary variables t_1 cdots t_n and r, the optimization problem is equivalent to","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"beginaligned\nmin_t r theta  sum_i=1^n t_i + lambda r \ntextsubject to   quad t_i geq log(1 + exp(- y_i theta^top x_i)) \n                    quad r geq theta\nendaligned","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"Now, the trick is to reformulate the constraints t_i geq log(1 + exp(- y_i theta^top x_i)) with the help of the exponential cone","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"K_exp =  (x y z) in mathbbR^3   y exp(x  y) leq z  ","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"Indeed, by passing to the exponential, we see that for all i=1 cdots n, the constraint t_i geq log(1 + exp(- y_i theta^top x_i)) is equivalent to","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"exp(-t_i) + exp(u_i - t_i) leq 1","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"with u_i = -y_i theta^top x_i. Then, by adding two auxiliary variables z_i1 and z_i2 such that z_i1 geq exp(u_i-t_i) and z_i2 geq exp(-t_i), we get the equivalent formulation","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"left\nbeginaligned\n(u_i -t_i  1 z_i1)  in  K_exp  \n(-t_i  1 z_i2)  in  K_exp  \nz_i1 + z_i2  leq  1\nendaligned\nright","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"In this setting, the conic version of the logistic regression problems writes out","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"beginaligned\nmin_t z r theta   sum_i=1^n t_i + lambda r \ntextsubject to   quad  (u_i -t_i  1 z_i1)  in  K_exp  \n                    quad  (-t_i  1 z_i2)  in  K_exp  \n                    quad  z_i1 + z_i2  leq  1 \n                    quad u_i = -y_i x_i^top theta \n                    quad r geq theta\nendaligned","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"and thus encompasses 3n + p + 1 variables and 3n + 1 constraints (u_i = -y_i theta^top x_i is only a virtual constraint used to clarify the notation). Thus, if n gg 1, we get a large number of variables and constraints.","category":"page"},{"location":"tutorials/conic/logistic_regression/#Fitting-logistic-regression-with-a-conic-solver","page":"Logistic regression","title":"Fitting logistic regression with a conic solver","text":"","category":"section"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"It is now time to pass to the implementation. We choose SCS as a conic solver.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"using JuMP\nimport Random\nimport SCS","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"info: Info\nThis tutorial uses sets from MathOptInterface. By default, JuMP exports the MOI symbol as an alias for the MathOptInterface.jl package. We recommend making this more explicit in your code by adding the following lines:import MathOptInterface as MOI","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"Random.seed!(2713);\nnothing #hide","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"We start by implementing a function to generate a fake dataset, and where we could tune the correlation between the feature variables. The function is a direct transcription of the one used in this blog post.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"function generate_dataset(n_samples = 100, n_features = 10; shift = 0.0)\n    X = randn(n_samples, n_features)\n    w = randn(n_features)\n    y = sign.(X * w)\n    X .+= 0.8 * randn(n_samples, n_features) # add noise\n    X .+= shift # shift the points in the feature space\n    X = hcat(X, ones(n_samples, 1))\n    return X, y\nend","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"We write a softplus function to formulate each constraint t geq log(1 + exp(u)) with two exponential cones.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"function softplus(model, t, u)\n    z = @variable(model, [1:2], lower_bound = 0.0)\n    @constraint(model, sum(z) <= 1.0)\n    @constraint(model, [u - t, 1, z[1]] in MOI.ExponentialCone())\n    @constraint(model, [-t, 1, z[2]] in MOI.ExponentialCone())\nend","category":"page"},{"location":"tutorials/conic/logistic_regression/#\\ell_2-regularized-logistic-regression","page":"Logistic regression","title":"ell_2 regularized logistic regression","text":"","category":"section"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"Then, with the help of the softplus function, we could write our optimization model. In the ell_2 regularization case, the constraint r geq theta_2 rewrites as a second order cone constraint.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"function build_logit_model(X, y, λ)\n    n, p = size(X)\n    model = Model()\n    @variable(model, θ[1:p])\n    @variable(model, t[1:n])\n    for i in 1:n\n        u = -(X[i, :]' * θ) * y[i]\n        softplus(model, t[i], u)\n    end\n    # Add ℓ2 regularization\n    @variable(model, 0.0 <= reg)\n    @constraint(model, [reg; θ] in SecondOrderCone())\n    # Define objective\n    @objective(model, Min, sum(t) + λ * reg)\n    return model\nend","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"We generate the dataset.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"warning: Warning\nBe careful here, for large n and p SCS could fail to converge.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"n, p = 200, 10\nX, y = generate_dataset(n, p; shift = 10.0);\n\n# We could now solve the logistic regression problem\nλ = 10.0\nmodel = build_logit_model(X, y, λ)\nset_optimizer(model, SCS.Optimizer)\nset_silent(model)\noptimize!(model)\n@assert is_solved_and_feasible(model)","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"θ♯ = value.(model[:θ])","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"It appears that the speed of convergence is not that impacted by the correlation of the dataset, nor by the penalty lambda.","category":"page"},{"location":"tutorials/conic/logistic_regression/#\\ell_1-regularized-logistic-regression","page":"Logistic regression","title":"ell_1 regularized logistic regression","text":"","category":"section"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"We now formulate the logistic problem with a ell_1 regularization term. The ell_1 regularization ensures sparsity in the optimal solution of the resulting optimization problem. Luckily, the ell_1 norm is implemented as a set in MathOptInterface. Thus, we could formulate the sparse logistic regression problem with the help of a MOI.NormOneCone set.","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"function build_sparse_logit_model(X, y, λ)\n    n, p = size(X)\n    model = Model()\n    @variable(model, θ[1:p])\n    @variable(model, t[1:n])\n    for i in 1:n\n        u = -(X[i, :]' * θ) * y[i]\n        softplus(model, t[i], u)\n    end\n    # Add ℓ1 regularization\n    @variable(model, 0.0 <= reg)\n    @constraint(model, [reg; θ] in MOI.NormOneCone(p + 1))\n    # Define objective\n    @objective(model, Min, sum(t) + λ * reg)\n    return model\nend\n\n# Auxiliary function to count non-null components:\ncount_nonzero(v::Vector; tol = 1e-6) = sum(abs.(v) .>= tol)\n\n# We solve the sparse logistic regression problem on the same dataset as before.\nλ = 10.0\nsparse_model = build_sparse_logit_model(X, y, λ)\nset_optimizer(sparse_model, SCS.Optimizer)\nset_silent(sparse_model)\noptimize!(sparse_model)\n@assert is_solved_and_feasible(sparse_model)","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"θ♯ = value.(sparse_model[:θ])\nprintln(\n    \"Number of non-zero components: \",\n    count_nonzero(θ♯),\n    \" (out of \",\n    p,\n    \" features)\",\n)","category":"page"},{"location":"tutorials/conic/logistic_regression/#Extensions","page":"Logistic regression","title":"Extensions","text":"","category":"section"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"A direct extension would be to consider the sparse logistic regression with hard thresholding, which, on contrary to the soft version using a ell_1 regularization, adds an explicit cardinality constraint in its formulation:","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"beginaligned\nmin_theta   sum_i=1^n log(1 + exp(-y_i theta^top x_i)) + lambda  theta _2^2 \ntextsubject to   quad  theta _0 = k\nendaligned","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"where k is the maximum number of non-zero components in the vector theta, and _0 is the ell_0 pseudo-norm:","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":" x_0 = i   x_i neq 0","category":"page"},{"location":"tutorials/conic/logistic_regression/","page":"Logistic regression","title":"Logistic regression","text":"The cardinality constraint theta_0 leq k could be reformulated with binary variables. Thus the hard sparse regression problem could be solved by any solver supporting mixed integer conic problems.","category":"page"},{"location":"moi/background/motivation/","page":"Motivation","title":"Motivation","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/background/motivation.md\"","category":"page"},{"location":"moi/background/motivation/#Motivation","page":"Motivation","title":"Motivation","text":"","category":"section"},{"location":"moi/background/motivation/","page":"Motivation","title":"Motivation","text":"MathOptInterface (MOI) is a replacement for MathProgBase, the first-generation abstraction layer for mathematical optimization previously used by JuMP and Convex.jl.","category":"page"},{"location":"moi/background/motivation/","page":"Motivation","title":"Motivation","text":"To address a number of limitations of MathProgBase, MOI is designed to:","category":"page"},{"location":"moi/background/motivation/","page":"Motivation","title":"Motivation","text":"Be simple and extensible\nunifying linear, quadratic, and conic optimization,\nseamlessly facilitating extensions to essentially arbitrary constraints and functions (for example, indicator constraints, complementarity constraints, and piecewise-linear functions)\nBe fast\nby allowing access to a solver's in-memory representation of a problem without writing intermediate files (when possible)\nby using multiple dispatch and avoiding requiring containers of non-concrete types\nAllow a solver to return multiple results (for example, a pool of solutions)\nAllow a solver to return extra arbitrary information via attributes (for example, variable- and constraint-wise membership in an irreducible inconsistent subset for infeasibility analysis)\nProvide a greatly expanded set of status codes explaining what happened during the optimization procedure\nEnable a solver to more precisely specify which problem classes it supports\nEnable both primal and dual warm starts\nEnable adding and removing both variables and constraints by indices that are not required to be consecutive\nEnable any modification that the solver supports to an existing model\nAvoid requiring the solver wrapper to store an additional copy of the problem data","category":"page"},{"location":"tutorials/conic/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"tutorials/conic/introduction/","page":"Introduction","title":"Introduction","text":"Conic programs are a class of convex nonlinear optimization problems which use cones to represent the nonlinearities. They have the form:","category":"page"},{"location":"tutorials/conic/introduction/","page":"Introduction","title":"Introduction","text":"beginalign\n     min_x in mathbbR^n  f_0(x) \n     textst  f_j(x) in mathcalS_j   j = 1 ldots m\nendalign","category":"page"},{"location":"tutorials/conic/introduction/","page":"Introduction","title":"Introduction","text":"Mixed-integer conic programs (MICPs) are extensions of conic programs in which some (or all) of the decision variables take discrete values.","category":"page"},{"location":"tutorials/conic/introduction/#How-to-choose-a-solver","page":"Introduction","title":"How to choose a solver","text":"","category":"section"},{"location":"tutorials/conic/introduction/","page":"Introduction","title":"Introduction","text":"JuMP supports a range of conic solvers, although support differs on what types of cones each solver supports. In the list of Supported solvers, \"SOCP\" denotes solvers supporting second-order cones and \"SDP\" denotes solvers supporting semidefinite cones. In addition, solvers such as SCS and Mosek have support for the exponential cone. Moreover, due to the bridging system in MathOptInterface, many of these solvers support a much wider range of exotic cones than they natively support. Solvers supporting discrete variables start with \"(MI)\" in the list of Supported solvers.","category":"page"},{"location":"tutorials/conic/introduction/","page":"Introduction","title":"Introduction","text":"tip: Tip\nDuality plays a large role in solving conic optimization models. Depending on the solver, it can be more efficient to solve the dual instead of the primal. If performance is an issue, see the Dualization tutorial for more details.","category":"page"},{"location":"tutorials/conic/introduction/#How-these-tutorials-are-structured","page":"Introduction","title":"How these tutorials are structured","text":"","category":"section"},{"location":"tutorials/conic/introduction/","page":"Introduction","title":"Introduction","text":"Having a high-level overview of how this part of the documentation is structured will help you know where to look for certain things.","category":"page"},{"location":"tutorials/conic/introduction/","page":"Introduction","title":"Introduction","text":"The following tutorials are worked examples that present a problem in words, then formulate it in mathematics, and then solve it in JuMP. This usually involves some sort of visualization of the solution. Start here if you are new to JuMP.\nExperiment design\nLogistic regression\nThe Tips and tricks tutorial contains a number of helpful reformulations and tricks you can use when modeling conic programs. Look here if you are stuck trying to formulate a problem as a conic program.\nThe remaining tutorials are less verbose and styled in the form of short code examples. These tutorials have less explanation, but may contain useful code snippets, particularly if they are similar to a problem you are trying to solve.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/tutorials/manipulating_expressions.md\"","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/tutorials/manipulating_expressions/#Manipulating-expressions","page":"Manipulating expressions","title":"Manipulating expressions","text":"","category":"section"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"This guide highlights a syntactically appealing way to build expressions at the MOI level, but also to look at their contents. It may be especially useful when writing models or bridge code.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/#Creating-functions","page":"Manipulating expressions","title":"Creating functions","text":"","category":"section"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"This section details the ways to create functions with MathOptInterface.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/#Creating-scalar-affine-functions","page":"Manipulating expressions","title":"Creating scalar affine functions","text":"","category":"section"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"The simplest scalar function is simply a variable:","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> x = MOI.add_variable(model) # Create the variable x\nMOI.VariableIndex(1)","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"This type of function is extremely simple; to express more complex functions, other types must be used. For instance, a ScalarAffineFunction is a sum of linear terms (a factor times a variable) and a constant. Such an object can be built using the standard constructor:","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> f = MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1, x)], 2) # x + 2\n(2) + (1) MOI.VariableIndex(1)","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"However, you can also use operators to build the same scalar function:","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> f = x + 2\n(2) + (1) MOI.VariableIndex(1)","category":"page"},{"location":"moi/tutorials/manipulating_expressions/#Creating-scalar-quadratic-functions","page":"Manipulating expressions","title":"Creating scalar quadratic functions","text":"","category":"section"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"Scalar quadratic functions are stored in ScalarQuadraticFunction objects, in a way that is highly similar to scalar affine functions. You can obtain a quadratic function as a product of affine functions:","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> 1 * x * x\n(0) + 1.0 MOI.VariableIndex(1)²\n\njulia> f * f  # (x + 2)²\n(4) + (2) MOI.VariableIndex(1) + (2) MOI.VariableIndex(1) + 1.0 MOI.VariableIndex(1)²\n\njulia> f^2  # (x + 2)² too\n(4) + (2) MOI.VariableIndex(1) + (2) MOI.VariableIndex(1) + 1.0 MOI.VariableIndex(1)²","category":"page"},{"location":"moi/tutorials/manipulating_expressions/#Creating-vector-functions","page":"Manipulating expressions","title":"Creating vector functions","text":"","category":"section"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"A vector function is a function with several values, irrespective of the number of input variables. Similarly to scalar functions, there are three main types of vector functions: VectorOfVariables, VectorAffineFunction, and VectorQuadraticFunction.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"The easiest way to create a vector function is to stack several scalar functions using Utilities.vectorize. It takes a vector as input, and the generated vector function (of the most appropriate type) has each dimension corresponding to a dimension of the vector.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> g = MOI.Utilities.vectorize([f, 2 * f])\n┌                              ┐\n│(2) + (1) MOI.VariableIndex(1)│\n│(4) + (2) MOI.VariableIndex(1)│\n└                              ┘","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"warning: Warning\nUtilities.vectorize only takes a vector of similar scalar functions: you cannot mix VariableIndex and ScalarAffineFunction, for instance. In practice, it means that Utilities.vectorize([x, f]) does not work; you should rather use Utilities.vectorize([1 * x, f]) instead to only have ScalarAffineFunction objects.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/#Canonicalizing-functions","page":"Manipulating expressions","title":"Canonicalizing functions","text":"","category":"section"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"In more advanced use cases, you might need to ensure that a function is \"canonical.\" Functions are stored as an array of terms, but there is no check that these terms are redundant: a ScalarAffineFunction object might have two terms with the same variable, like x + x + 1. These terms could be merged without changing the semantics of the function: 2x + 1.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"Working with these objects might be cumbersome. Canonicalization helps maintain redundancy to zero.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"Utilities.is_canonical checks whether a function is already in its canonical form:","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> MOI.Utilities.is_canonical(f + f) # (x + 2) + (x + 2) is stored as x + x + 4\nfalse","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"Utilities.canonical returns the equivalent canonical version of the function:","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> MOI.Utilities.canonical(f + f) # Returns 2x + 4\n(4) + (2) MOI.VariableIndex(1)","category":"page"},{"location":"moi/tutorials/manipulating_expressions/#Exploring-functions","page":"Manipulating expressions","title":"Exploring functions","text":"","category":"section"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"At some point, you might need to dig into a function, for instance to map it into solver constructs.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/#Vector-functions","page":"Manipulating expressions","title":"Vector functions","text":"","category":"section"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"Utilities.scalarize returns a vector of scalar functions from a vector function:","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> MOI.Utilities.scalarize(g) # Returns a vector [f, 2 * f].\n2-element Vector{MathOptInterface.ScalarAffineFunction{Int64}}:\n (2) + (1) MOI.VariableIndex(1)\n (4) + (2) MOI.VariableIndex(1)","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"note: Note\nUtilities.eachscalar returns an iterator on the dimensions, which serves the same purpose as Utilities.scalarize.","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"output_dimension returns the number of dimensions of the output of a function:","category":"page"},{"location":"moi/tutorials/manipulating_expressions/","page":"Manipulating expressions","title":"Manipulating expressions","text":"julia> MOI.output_dimension(g)\n2","category":"page"},{"location":"packages/MosekTools/","page":"jump-dev/MosekTools.jl","title":"jump-dev/MosekTools.jl","text":"EditURL = \"https://github.com/jump-dev/MosekTools.jl/blob/v0.15.1/README.md\"","category":"page"},{"location":"packages/MosekTools/#MosekTools.jl","page":"jump-dev/MosekTools.jl","title":"MosekTools.jl","text":"","category":"section"},{"location":"packages/MosekTools/","page":"jump-dev/MosekTools.jl","title":"jump-dev/MosekTools.jl","text":"MosekTools.jl is the MathOptInterface.jl implementation for the MOSEK solver.","category":"page"},{"location":"packages/MosekTools/","page":"jump-dev/MosekTools.jl","title":"jump-dev/MosekTools.jl","text":"The low-level solver API for MOSEK is found in the package Mosek.jl.","category":"page"},{"location":"packages/MosekTools/#Affiliation","page":"jump-dev/MosekTools.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/MosekTools/","page":"jump-dev/MosekTools.jl","title":"jump-dev/MosekTools.jl","text":"MosekTools.jl is maintained by the JuMP community and is not officially supported by MOSEK. However, Mosek.jl is an officially supported product of MOSEK.","category":"page"},{"location":"packages/MosekTools/#License","page":"jump-dev/MosekTools.jl","title":"License","text":"","category":"section"},{"location":"packages/MosekTools/","page":"jump-dev/MosekTools.jl","title":"jump-dev/MosekTools.jl","text":"MosekTools.jl is licensed under the MIT License.","category":"page"},{"location":"packages/MosekTools/","page":"jump-dev/MosekTools.jl","title":"jump-dev/MosekTools.jl","text":"The underlying solver is a closed-source commercial product for which you must obtain a license.","category":"page"},{"location":"packages/MosekTools/#Installation","page":"jump-dev/MosekTools.jl","title":"Installation","text":"","category":"section"},{"location":"packages/MosekTools/","page":"jump-dev/MosekTools.jl","title":"jump-dev/MosekTools.jl","text":"The latest release of this package and the master branch are to be used with the latest release of Mosek.jl (which uses MOSEK v10).","category":"page"},{"location":"packages/MosekTools/","page":"jump-dev/MosekTools.jl","title":"jump-dev/MosekTools.jl","text":"To use MOSEK v9 (resp. v8), use the v0.12.x (resp. v0.7.x) releases of this package, and the mosekv9 (resp. mosekv8) branch and v1.2.x (resp. v0.9.x) releases of Mosek.jl.","category":"page"},{"location":"packages/MosekTools/","page":"jump-dev/MosekTools.jl","title":"jump-dev/MosekTools.jl","text":"See the following table for a summary:","category":"page"},{"location":"packages/MosekTools/","page":"jump-dev/MosekTools.jl","title":"jump-dev/MosekTools.jl","text":"MOSEK Mosek.jl MosekTools.jl release MosekTools.jl branch\nv10 v10 v0.13 master\nv9 v0.12 v0.12 mosekv9\nv8 v0.9 v0.7 mosekv8","category":"page"},{"location":"packages/MosekTools/#Use-with-JuMP","page":"jump-dev/MosekTools.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/MosekTools/","page":"jump-dev/MosekTools.jl","title":"jump-dev/MosekTools.jl","text":"using JuMP\nusing MosekTools\nmodel = Model(Mosek.Optimizer)\nset_attribute(model, \"QUIET\", true)\nset_attribute(model, \"INTPNT_CO_TOL_DFEAS\", 1e-7)","category":"page"},{"location":"packages/MosekTools/#Options","page":"jump-dev/MosekTools.jl","title":"Options","text":"","category":"section"},{"location":"packages/MosekTools/","page":"jump-dev/MosekTools.jl","title":"jump-dev/MosekTools.jl","text":"The parameter QUIET is a special parameter that when set to true disables all Mosek printing output.","category":"page"},{"location":"packages/MosekTools/","page":"jump-dev/MosekTools.jl","title":"jump-dev/MosekTools.jl","text":"All other parameters can be found in the Mosek documentation.","category":"page"},{"location":"packages/MosekTools/","page":"jump-dev/MosekTools.jl","title":"jump-dev/MosekTools.jl","text":"Note that the prefix MSK_IPAR_ (for integer parameters), MSK_DPAR_ (for floating point parameters) or MSK_SPAR_ (for string parameters) are optional. If they are not given, they are inferred from the type of the value. For example, in the example above, as 1e-7 is a floating point number, the parameters name used is MSK_DPAR_INTPNT_CO_TOL_DFEAS.","category":"page"},{"location":"developers/style/#Style-guide-and-design-principles","page":"Style Guide","title":"Style guide and design principles","text":"","category":"section"},{"location":"developers/style/#Style-guide","page":"Style Guide","title":"Style guide","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"This section describes the coding style rules that apply to JuMP code and that we recommend for JuMP models and surrounding Julia code. The motivations for a style guide include:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"conveying best practices for writing readable and maintainable code\nreducing the amount of time spent on bike-shedding by establishing basic naming and formatting conventions\nlowering the barrier for new contributors by codifying the existing practices (for example, you can be more confident your code will pass review if you follow the style guide)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"In some cases, the JuMP style guide diverges from the Julia style guide. All such cases will be explicitly noted and justified.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"The JuMP style guide adopts many recommendations from the Google style guides.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"info: Info\nThe style guide is always a work in progress, and not all JuMP code follows the rules. When modifying JuMP, please fix the style violations of the surrounding code (that is, leave the code tidier than when you started). If large changes are needed, consider separating them into another PR.","category":"page"},{"location":"developers/style/#JuliaFormatter","page":"Style Guide","title":"JuliaFormatter","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"JuMP uses JuliaFormatter.jl as an auto-formatting tool.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"We use the options contained in .JuliaFormatter.toml.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"To format code, cd to the JuMP directory, then run:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"] add JuliaFormatter@1\nusing JuliaFormatter\nformat(\"docs\")\nformat(\"src\")\nformat(\"test\")","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"info: Info\nA continuous integration check verifies that all PRs made to JuMP have passed the formatter.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"The following sections outline extra style guide points that are not fixed automatically by JuliaFormatter.","category":"page"},{"location":"developers/style/#Abstract-types-and-composition","page":"Style Guide","title":"Abstract types and composition","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Specifying types for method arguments is mostly optional in Julia. The benefit of abstract method arguments is that it enables functions and types from one package to be used with functions and types from another package via multiple dispatch.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"However, abstractly typed methods have two main drawbacks:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"It's possible to find out that you are working with unexpected types deep in the call chain, potentially leading to hard-to-diagnose MethodErrors.\nUntyped function arguments can lead to correctness problems if the user's choice of input type does not satisfy the assumptions made by the author of the function.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"As a motivating example, consider the following function:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"julia> function my_sum(x)\n           y = 0.0\n           for i in 1:length(x)\n               y += x[i]\n           end\n           return y\n       end\nmy_sum (generic function with 1 method)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"This function contains a number of implicit assumptions about the type of x:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"x supports 1-based getindex and implements length\nThe element type of x supports addition with 0.0, and then with the result of x + 0.0.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"info: Info\nAs a motivating example for the second point, VariableRef plus Float64 produces an AffExpr. Do not assume that +(::A, ::B) produces an instance of the type A or B.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"my_sum works as expected if the user passes in Vector{Float64}:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"julia> my_sum([1.0, 2.0, 3.0])\n6.0","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"but it doesn't respect input types, for example returning a Float64 if the user passes Vector{Int}:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"julia> my_sum([1, 2, 3])\n6.0","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"but it throws a MethodError if the user passes String:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"julia> my_sum(\"abc\")\nERROR: MethodError: no method matching +(::Float64, ::Char)\n[...]","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"This particular MethodError is hard to debug, particularly for new users, because it mentions +, Float64, and Char, none of which were called or passed by the user.","category":"page"},{"location":"developers/style/#Dealing-with-MethodErrors","page":"Style Guide","title":"Dealing with MethodErrors","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"This section diverges from the Julia style guide, as well as other common guides like SciML. The following suggestions are intended to provide a friendlier experience for novice Julia programmers, at the cost of limiting the power and flexibility of advanced Julia programmers.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Code should follow the MethodError principle:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"info: The MethodError principle\nA user should see a MethodError only for methods that they called directly.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"_internal_function(x::Integer) = x + 1\n# The user sees a MethodError for _internal_function when calling\n# public_function(\"a string\"). This is not very helpful.\npublic_function(x) = _internal_function(x)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"_internal_function(x::Integer) = x + 1\n# The user sees a MethodError for public_function when calling\n# public_function(\"a string\"). This is easy to understand.\npublic_function(x::Integer) = _internal_function(x)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"If it is hard to provide an error message at the top of the call chain, then the following pattern is also ok:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"_internal_function(x::Integer) = x + 1\nfunction _internal_function(x)\n    error(\n        \"Internal error. This probably means that you called \" *\n        \"`public_function()`s with the wrong type.\",\n    )\nend\npublic_function(x) = _internal_function(x)","category":"page"},{"location":"developers/style/#Dealing-with-correctness","page":"Style Guide","title":"Dealing with correctness","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Dealing with correctness is harder, because Julia has no way of formally specifying interfaces that abstract types must implement. Instead, here are two options that you can use when writing and interacting with generic code:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Option 1: use concrete types and let users extend new methods.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"In this option, explicitly restrict input arguments to concrete types that are tested and have been validated for correctness. For example:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"julia> function my_sum_option_1(x::Vector{Float64})\n           y = 0.0\n           for i in 1:length(x)\n               y += x[i]\n           end\n           return y\n       end\nmy_sum_option_1 (generic function with 1 method)\n\njulia> my_sum_option_1([1.0, 2.0, 3.0])\n6.0","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Using concrete types satisfies the MethodError principle:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"julia> my_sum_option_1(\"abc\")\nERROR: MethodError: no method matching my_sum_option_1(::String)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"and it allows other types to be supported in future by defining new methods:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"julia> function my_sum_option_1(x::Array{T,N}) where {T<:Number,N}\n           y = zero(T)\n           for i in eachindex(x)\n               y += x[i]\n           end\n           return y\n       end\nmy_sum_option_1 (generic function with 2 methods)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Importantly, these methods do not have to be defined in the original package.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"info: Info\nSome usage of abstract types is okay. For example, in my_sum_option_1, we allowed the element type, T, to be a subtype of Number. This is fairly safe, but it still has an implicit assumption that T supports zero(T) and +(::T, ::T).","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Option 2: program defensively, and validate all assumptions.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"An alternative is to program defensively, and to rigorously document and validate all assumptions that the code makes. In particular:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"All assumptions on abstract types that aren't guaranteed by the definition of the abstract type (for example, optional methods without a fallback) should be documented.\nIf practical, the assumptions should be checked in code, and informative error messages should be provided to the user if the assumptions are not met. In general, these checks may be expensive, so you should prefer to do this once, at the highest level of the call-chain.\nTests should cover for a range of corner cases and argument types.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For example:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"\"\"\"\n    test_my_sum_defensive_assumptions(x::AbstractArray{T}) where {T}\n\nTest the assumptions made by `my_sum_defensive`.\n\"\"\"\nfunction test_my_sum_defensive_assumptions(x::AbstractArray{T}) where {T}\n    try\n        # Some types may not define zero.\n        @assert zero(T) isa T\n        # Check iteration supported\n        @assert iterate(x) isa Union{Nothing,Tuple{T,Int}}\n        # Check that + is defined\n        @assert +(zero(T), zero(T)) isa Any\n    catch err\n        error(\n            \"Unable to call my_sum_defensive(::$(typeof(x))) because \" *\n            \"it failed an internal assumption\",\n        )\n    end\n    return\nend\n\n\"\"\"\n    my_sum_defensive(x::AbstractArray{T}) where {T}\n\nReturn the sum of the elements in the abstract array `x`.\n\n## Assumptions\n\nThis function makes the following assumptions:\n\n * That `zero(T)` is defined\n * That `x` supports the iteration interface\n * That  `+(::T, ::T)` is defined\n\"\"\"\nfunction my_sum_defensive(x::AbstractArray{T}) where {T}\n    test_my_sum_defensive_assumptions(x)\n    y = zero(T)\n    for xi in x\n        y += xi\n    end\n    return y\nend\n\n# output\n\nmy_sum_defensive","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"This function works on Vector{Float64}:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"julia> my_sum_defensive([1.0, 2.0, 3.0])\n6.0","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"as well as Matrix{Rational{Int}}:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"julia> my_sum_defensive([(1//2) + (4//3)im; (6//5) + (7//11)im])\n17//10 + 65//33*im","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"and it throws an error when the assumptions aren't met:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"julia> my_sum_defensive(['a', 'b', 'c'])\nERROR: Unable to call my_sum_defensive(::Vector{Char}) because it failed an internal assumption\n[...]","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"As an alternative, you may choose not to call test_my_sum_defensive_assumptions within my_sum_defensive, and instead ask users of my_sum_defensive to call it in their tests.","category":"page"},{"location":"developers/style/#Juxtaposed-multiplication","page":"Style Guide","title":"Juxtaposed multiplication","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Only use juxtaposed multiplication when the right-hand side is a symbol.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"2x  # Acceptable if there are space constraints.\n2 * x  # This is preferred if space is not an issue.\n2 * (x + 1)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"2(x + 1)","category":"page"},{"location":"developers/style/#Empty-vectors","page":"Style Guide","title":"Empty vectors","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For a type T, T[] and Vector{T}() are equivalent ways to create an empty vector with element type T. Prefer T[] because it is more concise.","category":"page"},{"location":"developers/style/#Comments","page":"Style Guide","title":"Comments","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For non-native speakers and for general clarity, comments in code must be proper English sentences with appropriate punctuation.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"# This is a comment demonstrating a good comment.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"# a bad comment","category":"page"},{"location":"developers/style/#JuMP-macro-syntax","page":"Style Guide","title":"JuMP macro syntax","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For consistency, always use parentheses.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable model x >= 0","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For consistency, always use constant * variable as opposed to variable * constant. This makes it easier to read models in ambiguous cases like a * x.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"a = 4\n@constraint(model, 3 * x <= 1)\n@constraint(model, a * x <= 1)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"a = 4\n@constraint(model, x * 3 <= 1)\n@constraint(model, x * a <= 1)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"In order to reduce boilerplate code, prefer the plural form of macros over lots of repeated calls to singular forms.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variables(model, begin\n    x >= 0\n    y >= 1\n    z <= 2\nend)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0)\n@variable(model, y >= 1)\n@variable(model, z <= 2)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"An exception is made for calls with many keyword arguments, since these need to be enclosed in parentheses in order to parse properly.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Acceptable:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0, start = 0.0, base_name = \"my_x\")\n@variable(model, y >= 1, start = 2.0)\n@variable(model, z <= 2, start = -1.0)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Also acceptable:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variables(model, begin\n    x >= 0, (start = 0.0, base_name = \"my_x\")\n    y >= 1, (start = 2.0)\n    z <= 2, (start = -1.0)\nend)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"While we always use in for for-loops, it is acceptable to use = in the container declarations of JuMP macros.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Okay:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x[i=1:3])","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Also okay:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x[i in 1:3])","category":"page"},{"location":"developers/style/#Naming","page":"Style Guide","title":"Naming","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"module SomeModule end\nfunction some_function end\nconst SOME_CONSTANT = ...\nstruct SomeStruct\n  some_field::SomeType\nend\n@enum SomeEnum ENUM_VALUE_A ENUM_VALUE_B\nsome_local_variable = ...\nsome_file.jl # Except for ModuleName.jl.","category":"page"},{"location":"developers/style/#Exported-and-non-exported-names","page":"Style Guide","title":"Exported and non-exported names","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Begin private module level functions and constants with an underscore. All other objects in the scope of a module should be exported. (See JuMP.jl for an example of how to do this.)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Names beginning with an underscore should only be used for distinguishing between exported (public) and non-exported (private) objects. Therefore, never begin the name of a local variable with an underscore.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"module MyModule\n\nexport public_function, PUBLIC_CONSTANT\n\nfunction _private_function()\n    local_variable = 1\n    return\nend\n\nfunction public_function end\n\nconst _PRIVATE_CONSTANT = 3.14159\nconst PUBLIC_CONSTANT = 1.41421\n\nend","category":"page"},{"location":"developers/style/#Use-of-underscores-within-names","page":"Style Guide","title":"Use of underscores within names","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"The Julia style guide recommends avoiding underscores \"when readable,\" for example, haskey, isequal, remotecall, and remotecall_fetch. This convention creates the potential for unnecessary bikeshedding and also forces the user to recall the presence/absence of an underscore, for example, \"was that argument named basename or base_name?\". For consistency, always use underscores in variable names and function names to separate words.","category":"page"},{"location":"developers/style/#Use-of-!","page":"Style Guide","title":"Use of !","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Julia has a convention of appending ! to a function name if the function modifies its arguments. We recommend to:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Omit ! when the name itself makes it clear that modification is taking place, for example, add_constraint and set_name. We depart from the Julia style guide because ! does not provide a reader with any additional information in this case, and adherence to this convention is not uniform even in base Julia itself (consider Base.println and Base.finalize).\nUse ! in all other cases. In particular it can be used to distinguish between modifying and non-modifying variants of the same function like scale and scale!.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Note that ! is not a self-documenting feature because it is still ambiguous which arguments are modified when multiple arguments are present. Be sure to document which arguments are modified in the method's docstring.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"See also the Julia style guide recommendations for ordering of function arguments.","category":"page"},{"location":"developers/style/#Abbreviations","page":"Style Guide","title":"Abbreviations","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Abbreviate names to make the code more readable, not to save typing. Don't arbitrarily delete letters from a word to abbreviate it (for example, indx). Use abbreviations consistently within a body of code (for example, do not mix con and constr, idx and indx).","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Common abbreviations:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"num for number\ncon for constraint","category":"page"},{"location":"developers/style/#No-one-letter-variable-names","page":"Style Guide","title":"No one-letter variable names","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Where possible, avoid one-letter variable names.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Use model = Model() instead of m = Model()","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Exceptions are made for indices in loops.","category":"page"},{"location":"developers/style/#@enum-vs.-Symbol","page":"Style Guide","title":"@enum vs. Symbol","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"The @enum macro lets you define types with a finite number of values that are explicitly enumerated (like enum in C/C++). Symbols are lightweight strings that are used to represent identifiers in Julia (for example, :x).","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@enum provides type safety and can have docstrings attached to explain the possible values. Use @enums when applicable, for example, for reporting statuses. Use strings to provide long-form additional information like error messages.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Use of Symbol should typically be reserved for identifiers, for example, for lookup in the JuMP model (model[:my_variable]).","category":"page"},{"location":"developers/style/#using-vs.-import","page":"Style Guide","title":"using vs. import","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"using ModuleName brings all symbols exported by the module ModuleName into scope, while import ModuleName brings only the module itself into scope. (See the Julia manual) for examples and more details.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For the same reason that from <module> import * is not recommended in python (PEP 8), avoid using ModuleName except in throw-away scripts or at the REPL. The using statement makes it harder to track where symbols come from and exposes the code to ambiguities when two modules export the same symbol.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Prefer using ModuleName: x, p to import ModuleName.x, ModuleName.p and import MyModule: x, p because the import versions allow method extension without qualifying with the module name.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Similarly, using ModuleName: ModuleName is an acceptable substitute for import ModuleName, because it does not bring all symbols exported by ModuleName into scope. However, we prefer import ModuleName for consistency.","category":"page"},{"location":"developers/style/#Documentation","page":"Style Guide","title":"Documentation","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"This section describes the writing style that should be used when writing documentation for JuMP (and supporting packages).","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"We can recommend the documentation style guides by Divio, Google, and Write the Docs as general reading for those writing documentation. This guide delegates a thorough handling of the topic to those guides and instead elaborates on the points more specific to Julia and documentation that use Documenter.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Be concise\nUse lists instead of long sentences\nUse numbered lists when describing a sequence, for example, (1) do X, (2) then Y\nUse bullet points when the items are not ordered\nExample code should be covered by doctests\nWhen a word is a Julia symbol and not an English word, enclose it with backticks. In addition, if it has a docstring in this doc add a link using @ref. If it is a plural, add the \"s\" after the closing backtick. For example,\n[`VariableRef`](@ref)s\nUse @meta blocks for TODOs and other comments that shouldn't be visible to readers. For example,\n```@meta\n# TODO: Mention also X, Y, and Z.\n```","category":"page"},{"location":"developers/style/#Docstrings","page":"Style Guide","title":"Docstrings","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Every exported object needs a docstring\nAll examples in docstrings should be jldoctests\nAlways use complete English sentences with proper punctuation\nDo not terminate lists with punctuation (for example, as in this doc)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Here is an example:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"\"\"\"\n    signature(args; kwargs...)\n\nShort sentence describing the function.\n\nOptional: add a slightly longer paragraph describing the function.\n\n## Notes\n\n - List any notes that the user should be aware of\n\n## Example\n\n```jldoctest\njulia> 1 + 1\n2\n```\n\"\"\"","category":"page"},{"location":"developers/style/#Testing","page":"Style Guide","title":"Testing","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Use a module to encapsulate tests, and structure all tests as functions. This avoids leaking local variables between tests.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Here is a basic skeleton:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"module TestPkg\n\nusing Test\n\nfunction runtests()\n    for name in names(@__MODULE__; all = true)\n        if startswith(\"$(name)\", \"test_\")\n            @testset \"$(name)\" begin\n                getfield(@__MODULE__, name)()\n            end\n        end\n    end\n    return\nend\n\n_helper_function() = 2\n\nfunction test_addition()\n    @test 1 + 1 == _helper_function()\n    return\nend\n\nend # module TestPkg\n\nTestPkg.runtests()","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Break the tests into multiple files, with one module per file, so that subsets of the codebase can be tested by calling include with the relevant file.","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/submodules/Bridges/implementation.md\"","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Bridges/implementation/#Implementing-a-bridge","page":"Implementation","title":"Implementing a bridge","text":"","category":"section"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"The easiest way to implement a bridge is to follow an existing example. There are three locations of bridges in the source code:","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"Constraint bridges are stored in src/Bridges/Constraint/bridges\nObjective bridges are stored in src/Bridges/Objective/bridges\nVariable bridges are stored in src/Bridges/Variable/bridges","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"The Implementing a constraint bridge tutorial has a more detailed guide on what is required to implement a bridge.","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"When opening a pull request that adds a new bridge, use the checklist Adding a new bridge.","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"If you need help or advice, please contact the Developer Chatroom.","category":"page"},{"location":"moi/submodules/Bridges/implementation/#SetMap-bridges","page":"Implementation","title":"SetMap bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"For constraint and variable bridges, a common reformulation is that f(x) in F is reformulated to g(x) in G. In this case, no additional variables and constraints are added, and the bridge needs only a way to map between the functions f and g and the sets F and G.","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"To implementation a bridge of this form, subtype the abstract type Bridges.Constraint.SetMapBridge or Bridges.Variable.SetMapBridge and implement the API described in the docstring of each type.","category":"page"},{"location":"moi/submodules/Bridges/implementation/#final_touch","page":"Implementation","title":"final_touch","text":"","category":"section"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"Some bridges require information from other parts of the model. One set of examples are the various combinatorial ToMILP bridges, such as Bridges.Constraint.SOS1ToMILPBridge, which require knowledge of the variable bounds.","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"Bridges requiring information from other parts of the model should implement Bridges.final_touch and Bridges.needs_final_touch.","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"During the bridge's construction, store the function and set and make no changes to the underlying model. Then, in Bridges.final_touch, query the additional information and add the reformulated problem to the model.","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"When implementing, you must consider that:","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"Bridges.final_touch may be called multiple times, so that your reformulation should be applied only if necessary. Sometimes the additional data will be the same, and sometimes it may be different.\nWe do not currently support final_touch bridges that introduce constraints which also require a final_touch bridge. Therefore, you should implement final_touch only if necessary, and we recommend that you contact the Developer Chatroom for advice before doing so.","category":"page"},{"location":"moi/submodules/Bridges/implementation/#Testing","page":"Implementation","title":"Testing","text":"","category":"section"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"Use the Bridges.runtests function to test a bridge. It takes three arguments: the type of the bridge, the input model as a string, and the output model as a string.","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"Here is an example:","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"julia> MOI.Bridges.runtests(\n           MOI.Bridges.Constraint.GreaterToLessBridge,\n           \"\"\"\n           variables: x\n           x >= 1.0\n           \"\"\",\n           \"\"\"\n           variables: x\n           -1.0 * x <= -1.0\n           \"\"\",\n       )","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"There are a number of other useful keyword arguments.","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"eltype can be used to specify the element type of the model (and bridge). It defaults to Float64.\nvariable_start and constraint_start are used as the values to set the VariablePrimalStart and ConstraintPrimalStart attributes to. They default to 1.2. If you use a different eltype, you must set appropriate starting values of the same type. The default 1.2 was chosen to minimize the risk that the starting point is undefined, which could happen for common situations like 0.0 and 1.0. The tests associated with the starting values do not necessarily check for correctness, only that they can be set and get to produce the same result.\nprint_inner_model can be used to print the reformulated output model from the bridge. This is especially helpful during debugging to see what the bridge is doing, and to spot mistakes. It defaults to false.","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"Here is an example:","category":"page"},{"location":"moi/submodules/Bridges/implementation/","page":"Implementation","title":"Implementation","text":"julia> MOI.Bridges.runtests(\n           MOI.Bridges.Constraint.GreaterToLessBridge,\n           \"\"\"\n           variables: x\n           x >= 1\n           \"\"\",\n           \"\"\"\n           variables: x\n           ::Int: -1 * x <= -1\n           \"\"\";\n           eltype = Int,\n           print_inner_model = true,\n           variable_start = 2,\n           constraint_start = 2,\n       )\nFeasibility\n\nSubject to:\n\nScalarAffineFunction{Int64}-in-LessThan{Int64}\n (0) - (1) x <= (-1)","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/submodules/Test/overview.md\"","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Test/overview/#test_module","page":"Overview","title":"The Test submodule","text":"","category":"section"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"The Test submodule provides tools to help solvers implement unit tests in order to ensure they implement the MathOptInterface API correctly, and to check for solver-correctness.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"We use a centralized repository of tests, so that if we find a bug in one solver, instead of adding a test to that particular repository, we add it here so that all solvers can benefit.","category":"page"},{"location":"moi/submodules/Test/overview/#How-to-test-a-solver","page":"Overview","title":"How to test a solver","text":"","category":"section"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"The skeleton below can be used for the wrapper test file of a solver named FooBar.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"# ============================ /test/MOI_wrapper.jl ============================\nmodule TestFooBar\n\nimport FooBar\nusing Test\n\nimport MathOptInterface as MOI\n\nconst OPTIMIZER = MOI.instantiate(\n    MOI.OptimizerWithAttributes(FooBar.Optimizer, MOI.Silent() => true),\n)\n\nconst BRIDGED = MOI.instantiate(\n    MOI.OptimizerWithAttributes(FooBar.Optimizer, MOI.Silent() => true),\n    with_bridge_type = Float64,\n)\n\n# See the docstring of MOI.Test.Config for other arguments.\nconst CONFIG = MOI.Test.Config(\n    # Modify tolerances as necessary.\n    atol = 1e-6,\n    rtol = 1e-6,\n    # Use MOI.LOCALLY_SOLVED for local solvers.\n    optimal_status = MOI.OPTIMAL,\n    # Pass attributes or MOI functions to `exclude` to skip tests that\n    # rely on this functionality.\n    exclude = Any[MOI.VariableName, MOI.delete],\n)\n\n\"\"\"\n    runtests()\n\nThis function runs all functions in the this Module starting with `test_`.\n\"\"\"\nfunction runtests()\n    for name in names(@__MODULE__; all = true)\n        if startswith(\"$(name)\", \"test_\")\n            @testset \"$(name)\" begin\n                getfield(@__MODULE__, name)()\n            end\n        end\n    end\nend\n\n\"\"\"\n    test_runtests()\n\nThis function runs all the tests in MathOptInterface.Test.\n\nPass arguments to `exclude` to skip tests for functionality that is not\nimplemented or that your solver doesn't support.\n\"\"\"\nfunction test_runtests()\n    MOI.Test.runtests(\n        BRIDGED,\n        CONFIG,\n        exclude = [\n            \"test_attribute_NumberOfThreads\",\n            \"test_quadratic_\",\n        ],\n        # This argument is useful to prevent tests from failing on future\n        # releases of MOI that add new tests. Don't let this number get too far\n        # behind the current MOI release though. You should periodically check\n        # for new tests to fix bugs and implement new features.\n        exclude_tests_after = v\"0.10.5\",\n    )\n    return\nend\n\n\"\"\"\n    test_SolverName()\n\nYou can also write new tests for solver-specific functionality. Write each new\ntest as a function with a name beginning with `test_`.\n\"\"\"\nfunction test_SolverName()\n    @test MOI.get(FooBar.Optimizer(), MOI.SolverName()) == \"FooBar\"\n    return\nend\n\nend # module TestFooBar\n\n# This line at tne end of the file runs all the tests!\nTestFooBar.runtests()","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Then modify your runtests.jl file to include the MOI_wrapper.jl file:","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"# ============================ /test/runtests.jl ============================\n\nusing Test\n\n@testset \"MOI\" begin\n    include(\"test/MOI_wrapper.jl\")\nend","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"info: Info\nThe optimizer BRIDGED constructed with instantiate automatically bridges constraints that are not supported by OPTIMIZER using the bridges listed in Bridges. It is recommended for an implementation of MOI to only support constraints that are natively supported by the solver and let bridges transform the constraint to the appropriate form. For this reason it is expected that tests may not pass if OPTIMIZER is used instead of BRIDGED.","category":"page"},{"location":"moi/submodules/Test/overview/#How-to-debug-a-failing-test","page":"Overview","title":"How to debug a failing test","text":"","category":"section"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"When writing a solver, it's likely that you will initially fail many tests. Some failures will be bugs, but other failures you may choose to exclude.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"There are two ways to exclude tests:","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Exclude tests whose names contain a string using:\nMOI.Test.runtests(\n    model,\n    config;\n    exclude = String[\"test_to_exclude\", \"test_conic_\"],\n)\nThis will exclude tests whose name contains either of the two strings provided.\nExclude tests which rely on specific functionality using:\nMOI.Test.Config(exclude = Any[MOI.VariableName, MOI.optimize!])\nThis will exclude tests which use the MOI.VariableName attribute, or which call MOI.optimize!.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Each test that fails can be independently called as:","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"model = FooBar.Optimizer()\nconfig = MOI.Test.Config()\nMOI.empty!(model)\nMOI.Test.test_category_name_that_failed(model, config)","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"You can look-up the source code of the test that failed by searching for it in the src/Test/test_category.jl file.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"tip: Tip\nEach test function also has a docstring that explains what the test is for. Use ? MOI.Test.test_category_name_that_failed from the REPL to read it.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Periodically, you should re-run excluded tests to see if they now pass. The easiest way to do this is to swap the exclude keyword argument of runtests to include. For example:","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"MOI.Test.runtests(\n    model,\n    config;\n    exclude = String[\"test_to_exclude\", \"test_conic_\"],\n)","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"becomes","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"MOI.Test.runtests(\n    model,\n    config;\n    include = String[\"test_to_exclude\", \"test_conic_\"],\n)","category":"page"},{"location":"moi/submodules/Test/overview/#How-to-add-a-test","page":"Overview","title":"How to add a test","text":"","category":"section"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"To detect bugs in solvers, we add new tests to MOI.Test.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"As an example, ECOS errored calling optimize! twice in a row. (See ECOS.jl PR #72.) We could add a test to ECOS.jl, but that would only stop us from re-introducing the bug to ECOS.jl in the future, but it would not catch other solvers in the ecosystem with the same bug. Instead, if we add a test to MOI.Test, then all solvers will also check that they handle a double optimize call.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"For this test, we care about correctness, rather than performance. therefore, we don't expect solvers to efficiently decide that they have already solved the problem, only that calling optimize! twice doesn't throw an error or give the wrong answer.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Step 1","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Install the MathOptInterface julia package in dev mode:","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"julia> ]\n(@v1.6) pkg> dev MathOptInterface","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Step 2","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"From here on, proceed with making the following changes in the ~/.julia/dev/MathOptInterface folder (or equivalent dev path on your machine).","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Step 3","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Since the double-optimize error involves solving an optimization problem, add a new test to src/Test/test_solve.jl:","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"\"\"\"\n    test_unit_optimize!_twice(model::MOI.ModelLike, config::Config)\n\nTest that calling `MOI.optimize!` twice does not error.\n\nThis problem was first detected in ECOS.jl PR#72:\nhttps://github.com/jump-dev/ECOS.jl/pull/72\n\"\"\"\nfunction test_unit_optimize!_twice(\n    model::MOI.ModelLike,\n    config::Config{T},\n) where {T}\n    # Use the `@requires` macro to check conditions that the test function\n    # requires to run. Models failing this `@requires` check will silently skip\n    # the test.\n    @requires MOI.supports_constraint(\n        model,\n        MOI.VariableIndex,\n        MOI.GreaterThan{Float64},\n    )\n    @requires _supports(config, MOI.optimize!)\n    # If needed, you can test that the model is empty at the start of the test.\n    # You can assume that this will be the case for tests run via `runtests`.\n    # User's calling tests individually need to call `MOI.empty!` themselves.\n    @test MOI.is_empty(model)\n    # Create a simple model. Try to make this as simple as possible so that the\n    # majority of solvers can run the test.\n    x = MOI.add_variable(model)\n    MOI.add_constraint(model, x, MOI.GreaterThan(one(T)))\n    MOI.set(model, MOI.ObjectiveSense(), MOI.MIN_SENSE)\n    MOI.set(\n        model,\n        MOI.ObjectiveFunction{MOI.VariableIndex}(),\n        x,\n    )\n    # The main component of the test: does calling `optimize!` twice error?\n    MOI.optimize!(model)\n    MOI.optimize!(model)\n    # Check we have a solution.\n    @test MOI.get(model, MOI.TerminationStatus()) == MOI.OPTIMAL\n    # There is a three-argument version of `Base.isapprox` for checking\n    # approximate equality based on the tolerances defined in `config`:\n    @test isapprox(MOI.get(model, MOI.VariablePrimal(), x), one(T), config)\n    # For code-style, these tests should always `return` `nothing`.\n    return\nend","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"info: Info\nMake sure the function is agnostic to the number type T; don't assume it is a Float64 capable solver.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"We also need to write a test for the test. Place this function immediately below the test you just wrote in the same file:","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"function setup_test(\n    ::typeof(test_unit_optimize!_twice),\n    model::MOI.Utilities.MockOptimizer,\n    ::Config,\n)\n    MOI.Utilities.set_mock_optimize!(\n        model,\n        (mock::MOI.Utilities.MockOptimizer) -> MOIU.mock_optimize!(\n            mock,\n            MOI.OPTIMAL,\n            (MOI.FEASIBLE_POINT, [1.0]),\n        ),\n    )\n    return\nend","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Finally, you also need to implement Test.version_added. If we added this test when the latest released version of MOI was v0.10.5, define:","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"version_added(::typeof(test_unit_optimize!_twice)) = v\"0.10.6\"","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Step 6","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"Commit the changes to git from ~/.julia/dev/MathOptInterface and submit the PR for review.","category":"page"},{"location":"moi/submodules/Test/overview/","page":"Overview","title":"Overview","text":"tip: Tip\nIf you need help writing a test, open an issue on GitHub, or ask the Developer Chatroom.","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/submodules/Utilities/reference.md\"","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Utilities/reference/#Utilities.Model","page":"API Reference","title":"Utilities.Model","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.Model","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.Model","page":"API Reference","title":"MathOptInterface.Utilities.Model","text":"MOI.Utilities.Model{T}() where {T}\n\nAn implementation of ModelLike that supports all functions and sets defined in MOI. It is parameterized by the coefficient type.\n\nExamples\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#Utilities.UniversalFallback","page":"API Reference","title":"Utilities.UniversalFallback","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.UniversalFallback","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.UniversalFallback","page":"API Reference","title":"MathOptInterface.Utilities.UniversalFallback","text":"UniversalFallback\n\nThe UniversalFallback can be applied on a MOI.ModelLike model to create the model UniversalFallback(model) supporting any constraint and attribute. This allows to have a specialized implementation in model for performance critical constraints and attributes while still supporting other attributes with a small performance penalty. Note that model is unaware of constraints and attributes stored by UniversalFallback so this is not appropriate if model is an optimizer (for this reason, MOI.optimize! has not been implemented). In that case, optimizer bridges should be used instead.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#Utilities.@model","page":"API Reference","title":"Utilities.@model","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.@model\nUtilities.GenericModel\nUtilities.GenericOptimizer","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.@model","page":"API Reference","title":"MathOptInterface.Utilities.@model","text":"macro model(\n    model_name,\n    scalar_sets,\n    typed_scalar_sets,\n    vector_sets,\n    typed_vector_sets,\n    scalar_functions,\n    typed_scalar_functions,\n    vector_functions,\n    typed_vector_functions,\n    is_optimizer = false\n)\n\nCreates a type model_name implementing the MOI model interface and supporting all combinations of the provided functions and sets.\n\nEach typed_ scalar/vector sets/functions argument is a tuple of types. A type is \"typed\" if it has a coefficient {T} as the first type parameter.\n\nTuple syntax\n\nTo give no set/function, write (). To give one set or function X, write (X,).\n\nis_optimizer\n\nIf is_optimizer = true, the resulting struct is a of GenericOptimizer, which is a subtype of MOI.AbstractOptimizer, otherwise, it is a GenericModel, which is a subtype of MOI.ModelLike.\n\nVariableIndex\n\nThe function MOI.VariableIndex must not be given in scalar_functions.\nThe model supports MOI.VariableIndex-in-S constraints where S is MOI.EqualTo, MOI.GreaterThan, MOI.LessThan, MOI.Interval, MOI.Integer, MOI.ZeroOne, MOI.Semicontinuous or MOI.Semiinteger.\nThe sets supported with MOI.VariableIndex cannot be controlled from the macro; use UniversalFallback to support more sets.\n\nExamples\n\nThe model describing a linear program would be:\n\n@model(\n    LPModel,                                          # model_name\n    (),                                               # untyped scalar sets\n    (MOI.EqualTo, MOI.GreaterThan, MOI.LessThan, MOI.Interval), #   typed scalar sets\n    (MOI.Zeros, MOI.Nonnegatives, MOI.Nonpositives),  # untyped vector sets\n    (),                                               #   typed vector sets\n    (),                                               # untyped scalar functions\n    (MOI.ScalarAffineFunction,),                      #   typed scalar functions\n    (MOI.VectorOfVariables,),                         # untyped vector functions\n    (MOI.VectorAffineFunction,),                      #   typed vector functions\n    false,                                            # is_optimizer\n)\n\n\n\n\n\n","category":"macro"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.GenericModel","page":"API Reference","title":"MathOptInterface.Utilities.GenericModel","text":"mutable struct GenericModel{T,O,V,C} <: AbstractModelLike{T}\n\nImplements a model supporting coefficients of type T and:\n\nAn objective function stored in .objective::O\nVariables and VariableIndex constraints stored in .variable_bounds::V\nF-in-S constraints (excluding VariableIndex constraints) stored in .constraints::C\n\nAll interactions take place via the MOI interface, so the types O, V, and C must implement the API as needed for their functionality.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.GenericOptimizer","page":"API Reference","title":"MathOptInterface.Utilities.GenericOptimizer","text":"mutable struct GenericOptimizer{T,O,V,C} <: AbstractOptimizer{T}\n\nImplements a model supporting coefficients of type T and:\n\nAn objective function stored in .objective::O\nVariables and VariableIndex constraints stored in .variable_bounds::V\nF-in-S constraints (excluding VariableIndex constraints) stored in .constraints::C\n\nAll interactions take place via the MOI interface, so the types O, V, and C must implement the API as needed for their functionality.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#.objective","page":"API Reference","title":".objective","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.ObjectiveContainer","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.ObjectiveContainer","page":"API Reference","title":"MathOptInterface.Utilities.ObjectiveContainer","text":"ObjectiveContainer{T}\n\nA helper struct to simplify the handling of objective functions in Utilities.Model.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#.variables","page":"API Reference","title":".variables","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.VariablesContainer\nUtilities.FreeVariables","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.VariablesContainer","page":"API Reference","title":"MathOptInterface.Utilities.VariablesContainer","text":"struct VariablesContainer{T} <: AbstractVectorBounds\n    set_mask::Vector{UInt16}\n    lower::Vector{T}\n    upper::Vector{T}\nend\n\nA struct for storing variables and VariableIndex-related constraints. Used in MOI.Utilities.Model by default.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.FreeVariables","page":"API Reference","title":"MathOptInterface.Utilities.FreeVariables","text":"mutable struct FreeVariables <: MOI.ModelLike\n    n::Int64\n    FreeVariables() = new(0)\nend\n\nA struct for storing free variables that can be used as the variables field of GenericModel or GenericModel. It represents a model that does not support any constraint nor objective function.\n\nExample\n\nThe following model type represents a conic model in geometric form. As opposed to VariablesContainer, FreeVariables does not support constraint bounds so they are bridged into an affine constraint in the MOI.Nonnegatives cone as expected for the geometric conic form.\n\njulia> MOI.Utilities.@product_of_sets(\n    Cones,\n    MOI.Zeros,\n    MOI.Nonnegatives,\n    MOI.SecondOrderCone,\n    MOI.PositiveSemidefiniteConeTriangle,\n);\n\njulia> const ConicModel{T} = MOI.Utilities.GenericOptimizer{\n    T,\n    MOI.Utilities.ObjectiveContainer{T},\n    MOI.Utilities.FreeVariables,\n    MOI.Utilities.MatrixOfConstraints{\n        T,\n        MOI.Utilities.MutableSparseMatrixCSC{\n            T,\n            Int,\n            MOI.Utilities.OneBasedIndexing,\n        },\n        Vector{T},\n        Cones{T},\n    },\n};\n\njulia> model = MOI.instantiate(ConicModel{Float64}, with_bridge_type=Float64);\n\njulia> x = MOI.add_variable(model)\nMathOptInterface.VariableIndex(1)\n\njulia> c = MOI.add_constraint(model, x, MOI.GreaterThan(1.0))\nMathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64}}(1)\n\njulia> MOI.Bridges.is_bridged(model, c)\ntrue\n\njulia> bridge = MOI.Bridges.bridge(model, c)\nMathOptInterface.Bridges.Constraint.VectorizeBridge{Float64, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives, MathOptInterface.VariableIndex}(MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}(1), 1.0)\n\njulia> bridge.vector_constraint\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}(1)\n\njulia> MOI.Bridges.is_bridged(model, bridge.vector_constraint)\nfalse\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#.constraints","page":"API Reference","title":".constraints","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.VectorOfConstraints\nUtilities.StructOfConstraints\nUtilities.@struct_of_constraints_by_function_types\nUtilities.@struct_of_constraints_by_set_types\nUtilities.struct_of_constraint_code","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.VectorOfConstraints","page":"API Reference","title":"MathOptInterface.Utilities.VectorOfConstraints","text":"mutable struct VectorOfConstraints{\n    F<:MOI.AbstractFunction,\n    S<:MOI.AbstractSet,\n} <: MOI.ModelLike\n    constraints::CleverDicts.CleverDict{\n        MOI.ConstraintIndex{F,S},\n        Tuple{F,S},\n        typeof(CleverDicts.key_to_index),\n        typeof(CleverDicts.index_to_key),\n    }\nend\n\nA struct storing F-in-S constraints as a mapping between the constraint indices to the corresponding tuple of function and set.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.StructOfConstraints","page":"API Reference","title":"MathOptInterface.Utilities.StructOfConstraints","text":"abstract type StructOfConstraints <: MOI.ModelLike end\n\nA struct storing a subfields other structs storing constraints of different types.\n\nSee Utilities.@struct_of_constraints_by_function_types and Utilities.@struct_of_constraints_by_set_types.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.@struct_of_constraints_by_function_types","page":"API Reference","title":"MathOptInterface.Utilities.@struct_of_constraints_by_function_types","text":"Utilities.@struct_of_constraints_by_function_types(name, func_types...)\n\nGiven a vector of n function types (F1, F2,..., Fn) in func_types, defines a subtype of StructOfConstraints of name name and which type parameters {T, C1, C2, ..., Cn}. It contains n field where the ith field has type Ci and stores the constraints of function type Fi.\n\nThe expression Fi can also be a union in which case any constraint for which the function type is in the union is stored in the field with type Ci.\n\n\n\n\n\n","category":"macro"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.@struct_of_constraints_by_set_types","page":"API Reference","title":"MathOptInterface.Utilities.@struct_of_constraints_by_set_types","text":"Utilities.@struct_of_constraints_by_set_types(name, func_types...)\n\nGiven a vector of n set types (S1, S2,..., Sn) in func_types, defines a subtype of StructOfConstraints of name name and which type parameters {T, C1, C2, ..., Cn}. It contains n field where the ith field has type Ci and stores the constraints of set type Si. The expression Si can also be a union in which case any constraint for which the set type is in the union is stored in the field with type Ci. This can be useful if Ci is a MatrixOfConstraints in order to concatenate the coefficients of constraints of several different set types in the same matrix.\n\n\n\n\n\n","category":"macro"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.struct_of_constraint_code","page":"API Reference","title":"MathOptInterface.Utilities.struct_of_constraint_code","text":"struct_of_constraint_code(struct_name, types, field_types = nothing)\n\nGiven a vector of n Union{SymbolFun,_UnionSymbolFS{SymbolFun}} or Union{SymbolSet,_UnionSymbolFS{SymbolSet}} in types, defines a subtype of StructOfConstraints of name name and which type parameters {T, F1, F2, ..., Fn} if field_types is nothing and a {T} otherwise. It contains n field where the ith field has type Ci if field_types is nothing and type field_types[i] otherwise. If types is vector of Union{SymbolFun,_UnionSymbolFS{SymbolFun}} (resp. Union{SymbolSet,_UnionSymbolFS{SymbolSet}}) then the constraints of that function (resp. set) type are stored in the corresponding field.\n\nThis function is used by the macros @model, @struct_of_constraints_by_function_types and @struct_of_constraints_by_set_types.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#Caching-optimizer","page":"API Reference","title":"Caching optimizer","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.CachingOptimizer\nUtilities.attach_optimizer\nUtilities.reset_optimizer\nUtilities.drop_optimizer\nUtilities.state\nUtilities.mode","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.CachingOptimizer","page":"API Reference","title":"MathOptInterface.Utilities.CachingOptimizer","text":"CachingOptimizer\n\nCachingOptimizer is an intermediate layer that stores a cache of the model and links it with an optimizer. It supports incremental model construction and modification even when the optimizer doesn't.\n\nConstructors\n\n    CachingOptimizer(cache::MOI.ModelLike, optimizer::AbstractOptimizer)\n\nCreates a CachingOptimizer in AUTOMATIC mode, with the optimizer optimizer.\n\nThe type of the optimizer returned is CachingOptimizer{typeof(optimizer), typeof(cache)} so it does not support the function reset_optimizer(::CachingOptimizer, new_optimizer) if the type of new_optimizer is different from the type of optimizer.\n\n    CachingOptimizer(cache::MOI.ModelLike, mode::CachingOptimizerMode)\n\nCreates a CachingOptimizer in the NO_OPTIMIZER state and mode mode.\n\nThe type of the optimizer returned is CachingOptimizer{MOI.AbstractOptimizer,typeof(cache)} so it does support the function reset_optimizer(::CachingOptimizer, new_optimizer) if the type of new_optimizer is different from the type of optimizer.\n\nAbout the type\n\nStates\n\nA CachingOptimizer may be in one of three possible states (CachingOptimizerState):\n\nNO_OPTIMIZER: The CachingOptimizer does not have any optimizer.\nEMPTY_OPTIMIZER: The CachingOptimizer has an empty optimizer. The optimizer is not synchronized with the cached model.\nATTACHED_OPTIMIZER: The CachingOptimizer has an optimizer, and it is synchronized with the cached model.\n\nModes\n\nA CachingOptimizer has two modes of operation (CachingOptimizerMode):\n\nMANUAL: The only methods that change the state of the CachingOptimizer are Utilities.reset_optimizer, Utilities.drop_optimizer, and Utilities.attach_optimizer. Attempting to perform an operation in the incorrect state results in an error.\nAUTOMATIC: The CachingOptimizer changes its state when necessary. For example, optimize! will automatically call attach_optimizer (an optimizer must have been previously set). Attempting to add a constraint or perform a modification not supported by the optimizer results in a drop to EMPTY_OPTIMIZER mode.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.attach_optimizer","page":"API Reference","title":"MathOptInterface.Utilities.attach_optimizer","text":"attach_optimizer(model::CachingOptimizer)\n\nAttaches the optimizer to model, copying all model data into it. Can be called only from the EMPTY_OPTIMIZER state. If the copy succeeds, the CachingOptimizer will be in state ATTACHED_OPTIMIZER after the call, otherwise an error is thrown; see MOI.copy_to for more details on which errors can be thrown.\n\n\n\n\n\nMOIU.attach_optimizer(model::GenericModel)\n\nCall MOIU.attach_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.reset_optimizer","page":"API Reference","title":"MathOptInterface.Utilities.reset_optimizer","text":"reset_optimizer(m::CachingOptimizer, optimizer::MOI.AbstractOptimizer)\n\nSets or resets m to have the given empty optimizer optimizer.\n\nCan be called from any state. An assertion error will be thrown if optimizer is not empty.\n\nThe CachingOptimizer m will be in state EMPTY_OPTIMIZER after the call.\n\n\n\n\n\nreset_optimizer(m::CachingOptimizer)\n\nDetaches and empties the current optimizer. Can be called from ATTACHED_OPTIMIZER or EMPTY_OPTIMIZER state. The CachingOptimizer will be in state EMPTY_OPTIMIZER after the call.\n\n\n\n\n\nMOIU.reset_optimizer(model::GenericModel, optimizer::MOI.AbstractOptimizer)\n\nCall MOIU.reset_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\nMOIU.reset_optimizer(model::GenericModel)\n\nCall MOIU.reset_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.drop_optimizer","page":"API Reference","title":"MathOptInterface.Utilities.drop_optimizer","text":"drop_optimizer(m::CachingOptimizer)\n\nDrops the optimizer, if one is present. Can be called from any state. The CachingOptimizer will be in state NO_OPTIMIZER after the call.\n\n\n\n\n\nMOIU.drop_optimizer(model::GenericModel)\n\nCall MOIU.drop_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.state","page":"API Reference","title":"MathOptInterface.Utilities.state","text":"state(m::CachingOptimizer)::CachingOptimizerState\n\nReturns the state of the CachingOptimizer m. See Utilities.CachingOptimizer.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.mode","page":"API Reference","title":"MathOptInterface.Utilities.mode","text":"mode(m::CachingOptimizer)::CachingOptimizerMode\n\nReturns the operating mode of the CachingOptimizer m. See Utilities.CachingOptimizer.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#Mock-optimizer","page":"API Reference","title":"Mock optimizer","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.MockOptimizer","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.MockOptimizer","page":"API Reference","title":"MathOptInterface.Utilities.MockOptimizer","text":"MockOptimizer\n\nMockOptimizer is a fake optimizer especially useful for testing. Its main feature is that it can store the values that should be returned for each attribute.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#Printing","page":"API Reference","title":"Printing","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.latex_formulation","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.latex_formulation","page":"API Reference","title":"MathOptInterface.Utilities.latex_formulation","text":"latex_formulation(model::MOI.ModelLike; kwargs...)\n\nWrap model in a type so that it can be pretty-printed as text/latex in a notebook like IJulia, or in Documenter.\n\nTo render the model, end the cell with latex_formulation(model), or call display(latex_formulation(model)) in to force the display of the model from inside a function.\n\nPossible keyword arguments are:\n\nsimplify_coefficients : Simplify coefficients if possible by omitting them or removing trailing zeros.\ndefault_name : The name given to variables with an empty name.\nprint_types : Print the MOI type of each function and set for clarity.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#Copy-utilities","page":"API Reference","title":"Copy utilities","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.default_copy_to\nUtilities.IndexMap\nUtilities.identity_index_map\nUtilities.ModelFilter\nUtilities.loadfromstring!","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.default_copy_to","page":"API Reference","title":"MathOptInterface.Utilities.default_copy_to","text":"default_copy_to(dest::MOI.ModelLike, src::MOI.ModelLike)\n\nA default implementation of MOI.copy_to(dest, src) for models that implement the incremental interface, that is, MOI.supports_incremental_interface returns true.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.IndexMap","page":"API Reference","title":"MathOptInterface.Utilities.IndexMap","text":"IndexMap()\n\nThe dictionary-like object returned by MOI.copy_to.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.identity_index_map","page":"API Reference","title":"MathOptInterface.Utilities.identity_index_map","text":"identity_index_map(model::MOI.ModelLike)\n\nReturn an IndexMap that maps all variable and constraint indices of model to themselves.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.ModelFilter","page":"API Reference","title":"MathOptInterface.Utilities.ModelFilter","text":"ModelFilter(filter::Function, model::MOI.ModelLike)\n\nA layer to filter out various components of model.\n\nThe filter function takes a single argument, which is each element from the list returned by the attributes below. It returns true if the element should be visible in the filtered model and false otherwise.\n\nThe components that are filtered are:\n\nEntire constraint types via:\nMOI.ListOfConstraintTypesPresent\nIndividual constraints via:\nMOI.ListOfConstraintIndices{F,S}\nSpecific attributes via:\nMOI.ListOfModelAttributesSet\nMOI.ListOfConstraintAttributesSet\nMOI.ListOfVariableAttributesSet\n\nwarning: Warning\nThe list of attributes filtered may change in a future release. You should write functions that are generic and not limited to the five types listed above. Thus, you should probably define a fallback filter(::Any) = true.\n\nSee below for examples of how this works.\n\nnote: Note\nThis layer has a limited scope. It is intended by be used in conjunction with MOI.copy_to.\n\nExample: copy model excluding integer constraints\n\nUse the do syntax to provide a single function.\n\nfiltered_src = MOI.Utilities.ModelFilter(src) do item\n    return item != (MOI.VariableIndex, MOI.Integer)\nend\nMOI.copy_to(dest, filtered_src)\n\nExample: copy model excluding names\n\nUse type dispatch to simplify the implementation:\n\nmy_filter(::Any) = true  # Note the generic fallback\nmy_filter(::MOI.VariableName) = false\nmy_filter(::MOI.ConstraintName) = false\nfiltered_src = MOI.Utilities.ModelFilter(my_filter, src)\nMOI.copy_to(dest, filtered_src)\n\nExample: copy irreducible infeasible subsystem\n\nmy_filter(::Any) = true  # Note the generic fallback\nfunction my_filter(ci::MOI.ConstraintIndex)\n    status = MOI.get(dest, MOI.ConstraintConflictStatus(), ci)\n    return status != MOI.NOT_IN_CONFLICT\nend\nfiltered_src = MOI.Utilities.ModelFilter(my_filter, src)\nMOI.copy_to(dest, filtered_src)\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.loadfromstring!","page":"API Reference","title":"MathOptInterface.Utilities.loadfromstring!","text":"loadfromstring!(model, s)\n\nA utility function to aid writing tests.\n\nwarning: Warning\nThis function is not intended for widespread use. It is mainly used as a tool to simplify writing tests in MathOptInterface. Do not use it as an exchange format for storing or transmitting problem instances. Use the FileFormats submodule instead.\n\nExample\n\njulia> model = MOI.Utilities.Model{Float64}();\n\njulia> MOI.Utilities.loadfromstring!(model, \"\"\"\n       variables: x, y, z\n       constrainedvariable: [a, b, c] in Nonnegatives(3)\n       minobjective::Float64: 2x + 3y\n       con1: x + y <= 1.0\n       con2: [x, y] in Nonnegatives(2)\n       x >= 0.0\n       \"\"\")\n\nNotes\n\nSpecial labels are:\n\nvariables\nminobjective\nmaxobjectives\n\nEverything else denotes a constraint with a name.\n\nAppend ::T to use an element type of T when parsing the function.\n\nDo not name VariableIndex constraints.\n\nExceptions\n\nx - y does NOT currently parse. Instead, write x + -1.0 * y.\nx^2 does NOT currently parse. Instead, write x * x.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#Penalty-relaxation","page":"API Reference","title":"Penalty relaxation","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.PenaltyRelaxation\nUtilities.ScalarPenaltyRelaxation","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.PenaltyRelaxation","page":"API Reference","title":"MathOptInterface.Utilities.PenaltyRelaxation","text":"PenaltyRelaxation(\n    penalties = Dict{MOI.ConstraintIndex,Float64}();\n    default::Union{Nothing,T} = 1.0,\n)\n\nA problem modifier that, when passed to MOI.modify, destructively modifies the model in-place to create a penalized relaxation of the constraints.\n\nwarning: Warning\nThis is a destructive routine that modifies the model in-place. If you don't want to modify the original model, use JuMP.copy_model to create a copy before calling MOI.modify.\n\nReformulation\n\nSee Utilities.ScalarPenaltyRelaxation for details of the reformulation.\n\nFor each constraint ci, the penalty passed to Utilities.ScalarPenaltyRelaxation is get(penalties, ci, default). If the value is nothing, because ci does not exist in penalties and default = nothing, then the constraint is skipped.\n\nReturn value\n\nMOI.modify(model, PenaltyRelaxation()) returns a Dict{MOI.ConstraintIndex,MOI.ScalarAffineFunction} that maps each constraint index to the corresponding y + z as a MOI.ScalarAffineFunction. In an optimal solution, query the value of these functions to compute the violation of each constraint.\n\nRelax a subset of constraints\n\nTo relax a subset of constraints, pass a penalties dictionary and set default = nothing.\n\nSupported constraint types\n\nThe penalty relaxation is currently limited to modifying MOI.ScalarAffineFunction and MOI.ScalarQuadraticFunction constraints in the linear sets MOI.LessThan, MOI.GreaterThan, MOI.EqualTo and MOI.Interval.\n\nIt does not include variable bound or integrality constraints, because these cannot be modified in-place.\n\nTo modify variable bounds, rewrite them as linear constraints.\n\nExamples\n\njulia> model = MOI.Utilities.Model{Float64}();\n\njulia> x = MOI.add_variable(model);\n\njulia> c = MOI.add_constraint(model, 1.0 * x, MOI.LessThan(2.0));\n\njulia> map = MOI.modify(model, MOI.Utilities.PenaltyRelaxation(default = 2.0));\n\njulia> print(model)\nMinimize ScalarAffineFunction{Float64}:\n 0.0 + 2.0 v[2]\n\nSubject to:\n\nScalarAffineFunction{Float64}-in-LessThan{Float64}\n 0.0 + 1.0 v[1] - 1.0 v[2] <= 2.0\n\nVariableIndex-in-GreaterThan{Float64}\n v[2] >= 0.0\n\njulia> map[c] isa MOI.ScalarAffineFunction{Float64}\ntrue\n\njulia> model = MOI.Utilities.Model{Float64}();\n\njulia> x = MOI.add_variable(model);\n\njulia> c = MOI.add_constraint(model, 1.0 * x, MOI.LessThan(2.0));\n\njulia> map = MOI.modify(model, MOI.Utilities.PenaltyRelaxation(Dict(c => 3.0)));\n\njulia> print(model)\nMinimize ScalarAffineFunction{Float64}:\n 0.0 + 3.0 v[2]\n\nSubject to:\n\nScalarAffineFunction{Float64}-in-LessThan{Float64}\n 0.0 + 1.0 v[1] - 1.0 v[2] <= 2.0\n\nVariableIndex-in-GreaterThan{Float64}\n v[2] >= 0.0\n\njulia> map[c] isa MOI.ScalarAffineFunction{Float64}\ntrue\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.ScalarPenaltyRelaxation","page":"API Reference","title":"MathOptInterface.Utilities.ScalarPenaltyRelaxation","text":"ScalarPenaltyRelaxation(penalty::T) where {T}\n\nA problem modifier that, when passed to MOI.modify, destructively modifies the constraint in-place to create a penalized relaxation of the constraint.\n\nwarning: Warning\nThis is a destructive routine that modifies the constraint in-place. If you don't want to modify the original model, use JuMP.copy_model to create a copy before calling MOI.modify.\n\nReformulation\n\nThe penalty relaxation modifies constraints of the form f(x) in S into f(x) + y - z in S, where y z ge 0, and then it introduces a penalty term into the objective of a times (y + z) (if minimizing, else -a), where a is penalty\n\nWhen S is MOI.LessThan or MOI.GreaterThan, we omit y or z respectively as a performance optimization.\n\nReturn value\n\nMOI.modify(model, ci, ScalarPenaltyRelaxation(penalty)) returns y + z as a MOI.ScalarAffineFunction. In an optimal solution, query the value of this function to compute the violation of the constraint.\n\nExamples\n\njulia> model = MOI.Utilities.Model{Float64}();\n\njulia> x = MOI.add_variable(model);\n\njulia> c = MOI.add_constraint(model, 1.0 * x, MOI.LessThan(2.0));\n\njulia> f = MOI.modify(model, c, MOI.Utilities.ScalarPenaltyRelaxation(2.0));\n\njulia> print(model)\nMinimize ScalarAffineFunction{Float64}:\n 0.0 + 2.0 v[2]\n\nSubject to:\n\nScalarAffineFunction{Float64}-in-LessThan{Float64}\n 0.0 + 1.0 v[1] - 1.0 v[2] <= 2.0\n\nVariableIndex-in-GreaterThan{Float64}\n v[2] >= 0.0\n\njulia> f isa MOI.ScalarAffineFunction{Float64}\ntrue\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MatrixOfConstraints","page":"API Reference","title":"MatrixOfConstraints","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.MatrixOfConstraints","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.MatrixOfConstraints","page":"API Reference","title":"MathOptInterface.Utilities.MatrixOfConstraints","text":"mutable struct MatrixOfConstraints{T,AT,BT,ST} <: MOI.ModelLike\n    coefficients::AT\n    constants::BT\n    sets::ST\n    caches::Vector{Any}\n    are_indices_mapped::Vector{BitSet}\n    final_touch::Bool\nend\n\nRepresent ScalarAffineFunction and VectorAffinefunction constraints in a matrix form where the linear coefficients of the functions are stored in the coefficients field, the constants of the functions or sets are stored in the constants field. Additional information about the sets are stored in the sets field.\n\nThis model can only be used as the constraints field of a MOI.Utilities.AbstractModel.\n\nWhen the constraints are added, they are stored in the caches field. They are only loaded in the coefficients and constants fields once MOI.Utilities.final_touch is called. For this reason, MatrixOfConstraints should not be used by an incremental interface. Use MOI.copy_to instead.\n\nThe constraints can be added in two different ways:\n\nWith add_constraint, in which case a canonicalized copy of the function is stored in caches.\nWith pass_nonvariable_constraints, in which case the functions and sets are stored themselves in caches without mapping the variable indices. The corresponding index in caches is added in are_indices_mapped. This avoids doing a copy of the function in case the getter of CanonicalConstraintFunction does not make a copy for the source model, for example, this is the case of VectorOfConstraints.\n\nWe illustrate this with an example. Suppose a model is copied from a src::MOI.Utilities.Model to a bridged model with a MatrixOfConstraints. For all the types that are not bridged, the constraints will be copied with pass_nonvariable_constraints. Hence the functions stored in caches are exactly the same as the ones stored in src. This is ok since this is only during the copy_to operation during which src cannot be modified. On the other hand, for the types that are bridged, the functions added may contain duplicates even if the functions did not contain duplicates in src so duplicates are removed with MOI.Utilities.canonical.\n\nInterface\n\nThe .coefficients::AT type must implement:\n\nAT()\nMOI.empty(::AT)!\nMOI.Utilities.add_column\nMOI.Utilities.set_number_of_rows\nMOI.Utilities.allocate_terms\nMOI.Utilities.load_terms\nMOI.Utilities.final_touch\n\nThe .constants::BT type must implement:\n\nBT()\nBase.empty!(::BT)\nBase.resize(::BT)\nMOI.Utilities.load_constants\nMOI.Utilities.function_constants\nMOI.Utilities.set_from_constants\n\nThe .sets::ST type must implement:\n\nST()\nMOI.is_empty(::ST)\nMOI.empty(::ST)\nMOI.dimension(::ST)\nMOI.is_valid(::ST, ::MOI.ConstraintIndex)\nMOI.get(::ST, ::MOI.ListOfConstraintTypesPresent)\nMOI.get(::ST, ::MOI.NumberOfConstraints)\nMOI.get(::ST, ::MOI.ListOfConstraintIndices)\nMOI.Utilities.set_types\nMOI.Utilities.set_index\nMOI.Utilities.add_set\nMOI.Utilities.rows\nMOI.Utilities.final_touch\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#.coefficients","page":"API Reference","title":".coefficients","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.add_column\nUtilities.allocate_terms\nUtilities.set_number_of_rows\nUtilities.load_terms\nUtilities.final_touch\nUtilities.extract_function","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.add_column","page":"API Reference","title":"MathOptInterface.Utilities.add_column","text":"add_column(coefficients)::Nothing\n\nTell coefficients to pre-allocate datastructures as needed to store one column.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.allocate_terms","page":"API Reference","title":"MathOptInterface.Utilities.allocate_terms","text":"allocate_terms(coefficients, index_map, func)::Nothing\n\nTell coefficients that the terms of the function func where the variable indices are mapped with index_map will be loaded with load_terms.\n\nThe function func must be canonicalized before calling allocate_terms. See is_canonical.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.set_number_of_rows","page":"API Reference","title":"MathOptInterface.Utilities.set_number_of_rows","text":"set_number_of_rows(coefficients, n)::Nothing\n\nTell coefficients to pre-allocate datastructures as needed to store n rows.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.load_terms","page":"API Reference","title":"MathOptInterface.Utilities.load_terms","text":"load_terms(coefficients, index_map, func, offset)::Nothing\n\nLoads the terms of func to coefficients, mapping the variable indices with index_map.\n\nThe ith dimension of func is loaded at the (offset + i)th row of coefficients.\n\nThe function must be allocated first with allocate_terms.\n\nThe function func must be canonicalized, see is_canonical.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.final_touch","page":"API Reference","title":"MathOptInterface.Utilities.final_touch","text":"final_touch(coefficients)::Nothing\n\nInforms the coefficients that all functions have been added with load_terms. No more modification is allowed unless MOI.empty! is called.\n\nfinal_touch(sets)::Nothing\n\nInforms the sets that all functions have been added with add_set. No more modification is allowed unless MOI.empty! is called.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.extract_function","page":"API Reference","title":"MathOptInterface.Utilities.extract_function","text":"extract_function(coefficients, row::Integer, constant::T) where {T}\n\nReturn the MOI.ScalarAffineFunction{T} function corresponding to row row in coefficients.\n\nextract_function(\n    coefficients,\n    rows::UnitRange,\n    constants::Vector{T},\n) where{T}\n\nReturn the MOI.VectorAffineFunction{T} function corresponding to rows rows in coefficients.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.MutableSparseMatrixCSC\nUtilities.AbstractIndexing\nUtilities.ZeroBasedIndexing\nUtilities.OneBasedIndexing","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.MutableSparseMatrixCSC","page":"API Reference","title":"MathOptInterface.Utilities.MutableSparseMatrixCSC","text":"mutable struct MutableSparseMatrixCSC{Tv,Ti<:Integer,I<:AbstractIndexing}\n    indexing::I\n    m::Int\n    n::Int\n    colptr::Vector{Ti}\n    rowval::Vector{Ti}\n    nzval::Vector{Tv}\n    nz_added::Vector{Ti}\nend\n\nMatrix type loading sparse matrices in the Compressed Sparse Column format. The indexing used is indexing, see AbstractIndexing. The other fields have the same meaning than for SparseArrays.SparseMatrixCSC except that the indexing is different unless indexing is OneBasedIndexing. In addition, nz_added is used to cache the number of non-zero terms that have been added to each column due to the incremental nature of load_terms.\n\nThe matrix is loaded in 5 steps:\n\nMOI.empty! is called.\nMOI.Utilities.add_column and MOI.Utilities.allocate_terms are called in any order.\nMOI.Utilities.set_number_of_rows is called.\nMOI.Utilities.load_terms is called for each affine function.\nMOI.Utilities.final_touch is called.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.AbstractIndexing","page":"API Reference","title":"MathOptInterface.Utilities.AbstractIndexing","text":"abstract type AbstractIndexing end\n\nIndexing to be used for storing the row and column indices of MutableSparseMatrixCSC. See ZeroBasedIndexing and OneBasedIndexing.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.ZeroBasedIndexing","page":"API Reference","title":"MathOptInterface.Utilities.ZeroBasedIndexing","text":"struct ZeroBasedIndexing <: AbstractIndexing end\n\nZero-based indexing: the ith row or column has index i - 1. This is useful when the vectors of row and column indices need to be communicated to a library using zero-based indexing such as C libraries.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.OneBasedIndexing","page":"API Reference","title":"MathOptInterface.Utilities.OneBasedIndexing","text":"struct ZeroBasedIndexing <: AbstractIndexing end\n\nOne-based indexing: the ith row or column has index i. This enables an allocation-free conversion of MutableSparseMatrixCSC to SparseArrays.SparseMatrixCSC.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#.constants","page":"API Reference","title":".constants","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.load_constants\nUtilities.function_constants\nUtilities.set_from_constants\nUtilities.modify_constants","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.load_constants","page":"API Reference","title":"MathOptInterface.Utilities.load_constants","text":"load_constants(constants, offset, func_or_set)::Nothing\n\nThis function loads the constants of func_or_set in constants at an offset of offset. Where offset is the sum of the dimensions of the constraints already loaded. The storage should be preallocated with resize! before calling this function.\n\nThis function should be implemented to be usable as storage of constants for MatrixOfConstraints.\n\nThe constants are loaded in three steps:\n\nBase.empty! is called.\nBase.resize! is called with the sum of the dimensions of all constraints.\nMOI.Utilities.load_constants is called for each function for vector constraint or set for scalar constraint.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.function_constants","page":"API Reference","title":"MathOptInterface.Utilities.function_constants","text":"function_constants(constants, rows)\n\nThis function returns the function constants that were loaded with load_constants at the rows rows.\n\nThis function should be implemented to be usable as storage of constants for MatrixOfConstraints.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.set_from_constants","page":"API Reference","title":"MathOptInterface.Utilities.set_from_constants","text":"set_from_constants(constants, S::Type, rows)::S\n\nThis function returns an instance of the set S for which the constants where loaded with load_constants at the rows rows.\n\nThis function should be implemented to be usable as storage of constants for MatrixOfConstraints.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.modify_constants","page":"API Reference","title":"MathOptInterface.Utilities.modify_constants","text":"modify_constants(constants, row::Integer, new_constant::T) where {T}\nmodify_constants(\n    constants,\n    rows::AbstractVector{<:Integer},\n    new_constants::AbstractVector{T},\n) where {T}\n\nModify constants in-place to store new_constant in the row row, or rows rows.\n\nThis function must be implemented to enable MOI.ScalarConstantChange and MOI.VectorConstantChange for MatrixOfConstraints.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.Hyperrectangle","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.Hyperrectangle","page":"API Reference","title":"MathOptInterface.Utilities.Hyperrectangle","text":"struct Hyperrectangle{T} <: AbstractVectorBounds\n    lower::Vector{T}\n    upper::Vector{T}\nend\n\nA struct for the .constants field in MatrixOfConstraints.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#.sets","page":"API Reference","title":".sets","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.set_index\nUtilities.set_types\nUtilities.add_set\nUtilities.rows\nUtilities.num_rows\nUtilities.set_with_dimension","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.set_index","page":"API Reference","title":"MathOptInterface.Utilities.set_index","text":"set_index(sets, ::Type{S})::Union{Int,Nothing} where {S<:MOI.AbstractSet}\n\nReturn an integer corresponding to the index of the set type in the list given by set_types.\n\nIf S is not part of the list, return nothing.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.set_types","page":"API Reference","title":"MathOptInterface.Utilities.set_types","text":"set_types(sets)::Vector{Type}\n\nReturn the list of the types of the sets allowed in sets.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.add_set","page":"API Reference","title":"MathOptInterface.Utilities.add_set","text":"add_set(sets, i)::Int64\n\nAdd a scalar set of type index i.\n\nadd_set(sets, i, dim)::Int64\n\nAdd a vector set of type index i and dimension dim.\n\nBoth methods return a unique Int64 of the set that can be used to reference this set.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.rows","page":"API Reference","title":"MathOptInterface.Utilities.rows","text":"rows(sets, ci::MOI.ConstraintIndex)::Union{Int,UnitRange{Int}}\n\nReturn the rows in 1:MOI.dimension(sets) corresponding to the set of id ci.value.\n\nFor scalar sets, this returns an Int. For vector sets, this returns an UnitRange{Int}.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.num_rows","page":"API Reference","title":"MathOptInterface.Utilities.num_rows","text":"num_rows(sets::OrderedProductOfSets, ::Type{S}) where {S}\n\nReturn the number of rows corresponding to a set of type S. That is, it is the sum of the dimensions of the sets of type S.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.set_with_dimension","page":"API Reference","title":"MathOptInterface.Utilities.set_with_dimension","text":"set_with_dimension(::Type{S}, dim) where {S<:MOI.AbstractVectorSet}\n\nReturns the instance of S of MOI.dimension dim. This needs to be implemented for sets of type S to be useable with MatrixOfConstraints.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.ProductOfSets\nUtilities.MixOfScalarSets\nUtilities.@mix_of_scalar_sets\nUtilities.OrderedProductOfSets\nUtilities.@product_of_sets","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.ProductOfSets","page":"API Reference","title":"MathOptInterface.Utilities.ProductOfSets","text":"abstract type ProductOfSets{T} end\n\nRepresents a cartesian product of sets of given types.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.MixOfScalarSets","page":"API Reference","title":"MathOptInterface.Utilities.MixOfScalarSets","text":"abstract type MixOfScalarSets{T} <: ProductOfSets{T} end\n\nProduct of scalar sets in the order the constraints are added, mixing the constraints of different types.\n\nUse @mix_of_scalar_sets to generate a new subtype.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.@mix_of_scalar_sets","page":"API Reference","title":"MathOptInterface.Utilities.@mix_of_scalar_sets","text":"@mix_of_scalar_sets(name, set_types...)\n\nGenerate a new MixOfScalarSets subtype.\n\nExample\n\n@mix_of_scalar_sets(\n    MixedIntegerLinearProgramSets,\n    MOI.GreaterThan{T},\n    MOI.LessThan{T},\n    MOI.EqualTo{T},\n    MOI.Integer,\n)\n\n\n\n\n\n","category":"macro"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.OrderedProductOfSets","page":"API Reference","title":"MathOptInterface.Utilities.OrderedProductOfSets","text":"abstract type OrderedProductOfSets{T} <: ProductOfSets{T} end\n\nProduct of sets in the order the constraints are added, grouping the constraints of the same types contiguously.\n\nUse @product_of_sets to generate new subtypes.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.@product_of_sets","page":"API Reference","title":"MathOptInterface.Utilities.@product_of_sets","text":"@product_of_sets(name, set_types...)\n\nGenerate a new OrderedProductOfSets subtype.\n\nExample\n\n@product_of_sets(\n    LinearOrthants,\n    MOI.Zeros,\n    MOI.Nonnegatives,\n    MOI.Nonpositives,\n    MOI.ZeroOne,\n)\n\n\n\n\n\n","category":"macro"},{"location":"moi/submodules/Utilities/reference/#Fallbacks","page":"API Reference","title":"Fallbacks","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.get_fallback","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.get_fallback","page":"API Reference","title":"MathOptInterface.Utilities.get_fallback","text":"get_fallback(model::MOI.ModelLike, ::MOI.ObjectiveValue)\n\nCompute the objective function value using the VariablePrimal results and the ObjectiveFunction value.\n\n\n\n\n\nget_fallback(\n    model::MOI.ModelLike,\n    ::MOI.DualObjectiveValue,\n    ::Type{T},\n)::T where {T}\n\nCompute the dual objective value of type T using the ConstraintDual results and the ConstraintFunction and ConstraintSet values.\n\nNote that the nonlinear part of the model is ignored.\n\n\n\n\n\nget_fallback(\n    model::MOI.ModelLike,\n    ::MOI.ConstraintPrimal,\n    constraint_index::MOI.ConstraintIndex,\n)\n\nCompute the value of the function of the constraint of index constraint_index using the VariablePrimal results and the ConstraintFunction values.\n\n\n\n\n\nget_fallback(\n    model::MOI.ModelLike,\n    attr::MOI.ConstraintDual,\n    ci::MOI.ConstraintIndex{Union{MOI.VariableIndex,MOI.VectorOfVariables}},\n    ::Type{T} = Float64,\n) where {T}\n\nCompute the dual of the constraint of index ci using the ConstraintDual of other constraints and the ConstraintFunction values.\n\nThrows an error if some constraints are quadratic or if there is one another MOI.VariableIndex-in-S or MOI.VectorOfVariables-in-S constraint with one of the variables in the function of the constraint ci.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#Function-utilities","page":"API Reference","title":"Function utilities","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following utilities are available for functions:","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.eval_variables\nUtilities.map_indices\nUtilities.substitute_variables\nUtilities.filter_variables\nUtilities.remove_variable\nUtilities.all_coefficients\nUtilities.unsafe_add\nUtilities.isapprox_zero\nUtilities.modify_function\nUtilities.zero_with_output_dimension","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.eval_variables","page":"API Reference","title":"MathOptInterface.Utilities.eval_variables","text":"eval_variables(value_fn::Function, f::MOI.AbstractFunction)\n\nReturns the value of function f if each variable index vi is evaluated as value_fn(vi).\n\nNote that value_fn must return a Number. See substitute_variables for a similar function where value_fn returns an MOI.AbstractScalarFunction.\n\nwarning: Warning\nThe two-argument version of eval_variables is deprecated and may be removed in MOI v2.0.0. Use the three-argument method eval_variables(::Function, ::MOI.ModelLike, ::MOI.AbstractFunction) instead.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.map_indices","page":"API Reference","title":"MathOptInterface.Utilities.map_indices","text":"map_indices(index_map::Function, attr::MOI.AnyAttribute, x::X)::X where {X}\n\nSubstitute any MOI.VariableIndex (resp. MOI.ConstraintIndex) in x by the MOI.VariableIndex (resp. MOI.ConstraintIndex) of the same type given by index_map(x).\n\nWhen to implement this method for new types X\n\nThis function is used by implementations of MOI.copy_to on constraint functions, attribute values and submittable values. If you define a new attribute whose values x::X contain variable or constraint indices, you must also implement this function.\n\n\n\n\n\nmap_indices(\n    variable_map::AbstractDict{T,T},\n    x::X,\n)::X where {T<:MOI.Index,X}\n\nShortcut for map_indices(vi -> variable_map[vi], x).\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.substitute_variables","page":"API Reference","title":"MathOptInterface.Utilities.substitute_variables","text":"substitute_variables(variable_map::Function, x)\n\nSubstitute any MOI.VariableIndex in x by variable_map(x). The variable_map function returns either MOI.VariableIndex or MOI.ScalarAffineFunction, see eval_variables for a similar function where variable_map returns a number.\n\nThis function is used by bridge optimizers on constraint functions, attribute values and submittable values when at least one variable bridge is used hence it needs to be implemented for custom types that are meant to be used as attribute or submittable value.\n\nnote: Note\nWhen implementing a new method, don't use substitute_variables(::Function, because Julia will not specialize on it. Use instead substitute_variables(::F, ...) where {F<:Function}.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.filter_variables","page":"API Reference","title":"MathOptInterface.Utilities.filter_variables","text":"filter_variables(keep::Function, f::AbstractFunction)\n\nReturn a new function f with the variable vi such that !keep(vi) removed.\n\nWARNING: Don't define filter_variables(::Function, ...) because Julia will not specialize on this. Define instead filter_variables(::F, ...) where {F<:Function}.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.remove_variable","page":"API Reference","title":"MathOptInterface.Utilities.remove_variable","text":"remove_variable(f::AbstractFunction, vi::VariableIndex)\n\nReturn a new function f with the variable vi removed.\n\n\n\n\n\nremove_variable(\n    f::MOI.AbstractFunction,\n    s::MOI.AbstractSet,\n    vi::MOI.VariableIndex,\n)\n\nReturn a tuple (g, t) representing the constraint f-in-s with the variable vi removed. That is, the terms containing the variable vi in the function f are removed and the dimension of the set s is updated if needed (for example, when f is a VectorOfVariables with vi being one of the variables).\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.all_coefficients","page":"API Reference","title":"MathOptInterface.Utilities.all_coefficients","text":"all_coefficients(p::Function, f::MOI.AbstractFunction)\n\nDetermine whether predicate p returns true for all coefficients of f, returning false as soon as the first coefficient of f for which p returns false is encountered (short-circuiting). Similar to all.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.unsafe_add","page":"API Reference","title":"MathOptInterface.Utilities.unsafe_add","text":"unsafe_add(t1::MOI.ScalarAffineTerm, t2::MOI.ScalarAffineTerm)\n\nSums the coefficients of t1 and t2 and returns an output MOI.ScalarAffineTerm. It is unsafe because it uses the variable of t1 as the variable of the output without checking that it is equal to that of t2.\n\n\n\n\n\nunsafe_add(t1::MOI.ScalarQuadraticTerm, t2::MOI.ScalarQuadraticTerm)\n\nSums the coefficients of t1 and t2 and returns an output MOI.ScalarQuadraticTerm. It is unsafe because it uses the variable's of t1 as the variable's of the output without checking that they are the same (up to permutation) to those of t2.\n\n\n\n\n\nunsafe_add(t1::MOI.VectorAffineTerm, t2::MOI.VectorAffineTerm)\n\nSums the coefficients of t1 and t2 and returns an output MOI.VectorAffineTerm. It is unsafe because it uses the output_index and variable of t1 as the output_index and variable of the output term without checking that they are equal to those of t2.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.isapprox_zero","page":"API Reference","title":"MathOptInterface.Utilities.isapprox_zero","text":"isapprox_zero(f::MOI.AbstractFunction, tol)\n\nReturn a Bool indicating whether the function f is approximately zero using tol as a tolerance.\n\nImportant note\n\nThis function assumes that f does not contain any duplicate terms, you might want to first call canonical if that is not guaranteed. For instance, given\n\nf = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([1, -1], [x, x]), 0)\n\nthen isapprox_zero(f) is false but isapprox_zero(MOIU.canonical(f)) is true.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.modify_function","page":"API Reference","title":"MathOptInterface.Utilities.modify_function","text":"modify_function(f::AbstractFunction, change::AbstractFunctionModification)\n\nReturn a copy of the function f, modified according to change.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.zero_with_output_dimension","page":"API Reference","title":"MathOptInterface.Utilities.zero_with_output_dimension","text":"zero_with_output_dimension(::Type{T}, output_dimension::Integer) where {T}\n\nCreate an instance of type T with the output dimension output_dimension.\n\nThis is mostly useful in Bridges, when code needs to be agnostic to the type of vector-valued function that is passed in.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following functions can be used to canonicalize a function:","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.is_canonical\nUtilities.canonical\nUtilities.canonicalize!","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.is_canonical","page":"API Reference","title":"MathOptInterface.Utilities.is_canonical","text":"is_canonical(f::Union{ScalarAffineFunction, VectorAffineFunction})\n\nReturns a Bool indicating whether the function is in canonical form. See canonical.\n\n\n\n\n\nis_canonical(f::Union{ScalarQuadraticFunction, VectorQuadraticFunction})\n\nReturns a Bool indicating whether the function is in canonical form. See canonical.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.canonical","page":"API Reference","title":"MathOptInterface.Utilities.canonical","text":"canonical(f::MOI.AbstractFunction)\n\nReturns the function in a canonical form, that is,\n\nA term appear only once.\nThe coefficients are nonzero.\nThe terms appear in increasing order of variable where there the order of the variables is the order of their value.\nFor a AbstractVectorFunction, the terms are sorted in ascending order of output index.\n\nThe output of canonical can be assumed to be a copy of f, even for VectorOfVariables.\n\nExamples\n\nIf x (resp. y, z) is VariableIndex(1) (resp. 2, 3). The canonical representation of ScalarAffineFunction([y, x, z, x, z], [2, 1, 3, -2, -3], 5) is ScalarAffineFunction([x, y], [-1, 2], 5).\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.canonicalize!","page":"API Reference","title":"MathOptInterface.Utilities.canonicalize!","text":"canonicalize!(f::Union{ScalarAffineFunction, VectorAffineFunction})\n\nConvert a function to canonical form in-place, without allocating a copy to hold the result. See canonical.\n\n\n\n\n\ncanonicalize!(f::Union{ScalarQuadraticFunction, VectorQuadraticFunction})\n\nConvert a function to canonical form in-place, without allocating a copy to hold the result. See canonical.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following functions can be used to manipulate functions with basic algebra:","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.scalar_type\nUtilities.scalarize\nUtilities.eachscalar\nUtilities.promote_operation\nUtilities.operate\nUtilities.operate!\nUtilities.operate_output_index!\nUtilities.vectorize","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.scalar_type","page":"API Reference","title":"MathOptInterface.Utilities.scalar_type","text":"scalar_type(F::Type{<:MOI.AbstractVectorFunction})\n\nType of functions obtained by indexing objects obtained by calling eachscalar on functions of type F.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.scalarize","page":"API Reference","title":"MathOptInterface.Utilities.scalarize","text":"scalarize(func::MOI.VectorOfVariables, ignore_constants::Bool = false)\n\nReturns a vector of scalar functions making up the vector function in the form of a Vector{MOI.SingleVariable}.\n\nSee also eachscalar.\n\n\n\n\n\nscalarize(func::MOI.VectorAffineFunction{T}, ignore_constants::Bool = false)\n\nReturns a vector of scalar functions making up the vector function in the form of a Vector{MOI.ScalarAffineFunction{T}}.\n\nSee also eachscalar.\n\n\n\n\n\nscalarize(func::MOI.VectorQuadraticFunction{T}, ignore_constants::Bool = false)\n\nReturns a vector of scalar functions making up the vector function in the form of a Vector{MOI.ScalarQuadraticFunction{T}}.\n\nSee also eachscalar.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.eachscalar","page":"API Reference","title":"MathOptInterface.Utilities.eachscalar","text":"eachscalar(f::MOI.AbstractVectorFunction)\n\nReturns an iterator for the scalar components of the vector function.\n\nSee also scalarize.\n\n\n\n\n\neachscalar(f::MOI.AbstractVector)\n\nReturns an iterator for the scalar components of the vector.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.promote_operation","page":"API Reference","title":"MathOptInterface.Utilities.promote_operation","text":"promote_operation(\n    op::Function,\n    ::Type{T},\n    ArgsTypes::Type{<:Union{T,AbstractVector{T},MOI.AbstractFunction}}...,\n) where {T<:Number}\n\nCompute the return type of the call operate(op, T, args...), where the types of the arguments args are ArgsTypes.\n\nOne assumption is that the element type T is invariant under each operation. That is, op(::T, ::T)::T where op is a +, -, *, and /.\n\nThere are six methods for which we implement Utilities.promote_operation:\n\n+ a. promote_operation(::typeof(+), ::Type{T}, ::Type{F1}, ::Type{F2})\n- a. promote_operation(::typeof(-), ::Type{T}, ::Type{F}) b. promote_operation(::typeof(-), ::Type{T}, ::Type{F1}, ::Type{F2})\n* a. promote_operation(::typeof(*), ::Type{T}, ::Type{T}, ::Type{F}) b. promote_operation(::typeof(*), ::Type{T}, ::Type{F}, ::Type{T}) c. promote_operation(::typeof(*), ::Type{T}, ::Type{F1}, ::Type{F2})    where F1 and F2 are VariableIndex or ScalarAffineFunction d. promote_operation(::typeof(*), ::Type{T}, ::Type{<:Diagonal{T}}, ::Type{F}\n/ a. promote_operation(::typeof(/), ::Type{T}, ::Type{F}, ::Type{T})\nvcat a. promote_operation(::typeof(vcat), ::Type{T}, ::Type{F}...)\nimag a. promote_operation(::typeof(imag), ::Type{T}, ::Type{F})    where F is VariableIndex or VectorOfVariables\n\nIn each case, F (or F1 and F2) is one of the ten supported types, with a restriction that the mathematical operation makes sense, for example, we don't define promote_operation(-, T, F1, F2) where F1 is a scalar-valued function and  F2 is a vector-valued function. The ten supported types are:\n\n::T\n::VariableIndex\n::ScalarAffineFunction{T}\n::ScalarQuadraticFunction{T}\n::ScalarNonlinearFunction\n::AbstractVector{T}\n::VectorOfVariables\n::VectorAffineFunction{T}\n::VectorQuadraticFunction{T}\n::VectorNonlinearFunction\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.operate","page":"API Reference","title":"MathOptInterface.Utilities.operate","text":"operate(\n    op::Function,\n    ::Type{T},\n    args::Union{T,MOI.AbstractFunction}...,\n)::MOI.AbstractFunction where {T<:Number}\n\nReturns an MOI.AbstractFunction representing the function resulting from the operation op(args...) on functions of coefficient type T.\n\nNo argument can be modified.\n\nMethods\n\n+ a. operate(::typeof(+), ::Type{T}, ::F1) b. operate(::typeof(+), ::Type{T}, ::F1, ::F2) c. operate(::typeof(+), ::Type{T}, ::F1...)\n- a. operate(::typeof(-), ::Type{T}, ::F) b. operate(::typeof(-), ::Type{T}, ::F1, ::F2)\n* a. operate(::typeof(*), ::Type{T}, ::T, ::F) b. operate(::typeof(*), ::Type{T}, ::F, ::T) c. operate(::typeof(*), ::Type{T}, ::F1, ::F2)    where F1 and F2 are VariableIndex or ScalarAffineFunction d. operate(::typeof(*), ::Type{T}, ::Diagonal{T}, ::F)\n/ a. operate(::typeof(/), ::Type{T}, ::F, ::T)\nvcat a. operate(::typeof(vcat), ::Type{T}, ::F...)\nimag a. operate(::typeof(imag), ::Type{T}, ::F)    where F is VariableIndex or VectorOfVariables\n\nOne assumption is that the element type T is invariant under each operation. That is, op(::T, ::T)::T where op is a +, -, *, and /.\n\nIn each case, F (or F1 and F2) is one of the ten supported types, with a restriction that the mathematical operation makes sense, for example, we don't define promote_operation(-, T, F1, F2) where F1 is a scalar-valued function and  F2 is a vector-valued function. The ten supported types are:\n\n::T\n::VariableIndex\n::ScalarAffineFunction{T}\n::ScalarQuadraticFunction{T}\n::ScalarNonlinearFunction\n::AbstractVector{T}\n::VectorOfVariables\n::VectorAffineFunction{T}\n::VectorQuadraticFunction{T}\n::VectorNonlinearFunction\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.operate!","page":"API Reference","title":"MathOptInterface.Utilities.operate!","text":"operate!(\n    op::Function,\n    ::Type{T},\n    args::Union{T,MOI.AbstractFunction}...,\n)::MOI.AbstractFunction where {T<:Number}\n\nReturns an MOI.AbstractFunction representing the function resulting from the operation op(args...) on functions of coefficient type T.\n\nThe first argument may be modified, in which case the return value is identical to the first argument. For operations which cannot be implemented in-place, this function returns a new object.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.operate_output_index!","page":"API Reference","title":"MathOptInterface.Utilities.operate_output_index!","text":"operate_output_index!(\n    op::Union{typeof(+),typeof(-)},\n    ::Type{T},\n    output_index::Integer,\n    f::Union{AbstractVector{T},MOI.AbstractVectorFunction}\n    g::Union{T,MOI.AbstractScalarFunction}...\n) where {T<:Number}\n\nReturn an MOI.AbstractVectorFunction in which the scalar function in row output_index is the result of op(f[output_index], g).\n\nThe functions at output index different to output_index are the same as the functions at the same output index in func. The first argument may be modified.\n\nMethods\n\n+ a. operate_output_index!(+, ::Type{T}, ::Int, ::VectorF, ::ScalarF)\n- a. operate_output_index!(-, ::Type{T}, ::Int, ::VectorF, ::ScalarF)\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.vectorize","page":"API Reference","title":"MathOptInterface.Utilities.vectorize","text":"vectorize(x::AbstractVector{<:Number})\n\nReturns x.\n\n\n\n\n\nvectorize(x::AbstractVector{MOI.VariableIndex})\n\nReturns the vector of scalar affine functions in the form of a MOI.VectorAffineFunction{T}.\n\n\n\n\n\nvectorize(funcs::AbstractVector{MOI.ScalarAffineFunction{T}}) where T\n\nReturns the vector of scalar affine functions in the form of a MOI.VectorAffineFunction{T}.\n\n\n\n\n\nvectorize(funcs::AbstractVector{MOI.ScalarQuadraticFunction{T}}) where T\n\nReturns the vector of scalar quadratic functions in the form of a MOI.VectorQuadraticFunction{T}.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#Constraint-utilities","page":"API Reference","title":"Constraint utilities","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following utilities are available for moving the function constant to the set for scalar constraints:","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.shift_constant\nUtilities.supports_shift_constant\nUtilities.normalize_and_add_constraint\nUtilities.normalize_constant","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.shift_constant","page":"API Reference","title":"MathOptInterface.Utilities.shift_constant","text":"shift_constant(set::MOI.AbstractScalarSet, offset)\n\nReturns a new scalar set new_set such that func-in-set is equivalent to func + offset-in-new_set.\n\nUse supports_shift_constant to check if the set supports shifting:\n\nif MOI.Utilities.supports_shift_constant(typeof(set))\n    new_set = MOI.Utilities.shift_constant(set, -func.constant)\n    func.constant = 0\n    MOI.add_constraint(model, func, new_set)\nelse\n    MOI.add_constraint(model, func, set)\nend\n\nNote for developers\n\nOnly define this function if it makes sense and you have implemented supports_shift_constant to return true.\n\nExamples\n\njulia> import MathOptInterface as MOI\n\njulia> set = MOI.Interval(-2.0, 3.0)\nMathOptInterface.Interval{Float64}(-2.0, 3.0)\n\njulia> MOI.Utilities.supports_shift_constant(typeof(set))\ntrue\n\njulia> MOI.Utilities.shift_constant(set, 1.0)\nMathOptInterface.Interval{Float64}(-1.0, 4.0)\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.supports_shift_constant","page":"API Reference","title":"MathOptInterface.Utilities.supports_shift_constant","text":"supports_shift_constant(::Type{S}) where {S<:MOI.AbstractSet}\n\nReturn true if shift_constant is defined for set S.\n\nSee also shift_constant.\n\nExamples\n\njulia> import MathOptInterface as MOI\n\njulia> MOI.Utilities.supports_shift_constant(MOI.Interval{Float64})\ntrue\n\njulia> MOI.Utilities.supports_shift_constant(MOI.ZeroOne)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.normalize_and_add_constraint","page":"API Reference","title":"MathOptInterface.Utilities.normalize_and_add_constraint","text":"normalize_and_add_constraint(\n    model::MOI.ModelLike,\n    func::MOI.AbstractScalarFunction,\n    set::MOI.AbstractScalarSet;\n    allow_modify_function::Bool = false,\n)\n\nAdds the scalar constraint obtained by moving the constant term in func to the set in model. If allow_modify_function is true then the function func can be modified.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.normalize_constant","page":"API Reference","title":"MathOptInterface.Utilities.normalize_constant","text":"normalize_constant(\n    func::MOI.AbstractScalarFunction,\n    set::MOI.AbstractScalarSet;\n    allow_modify_function::Bool = false,\n)\n\nReturn the func-in-set constraint in normalized form. That is, if func is MOI.ScalarQuadraticFunction or MOI.ScalarAffineFunction, the constant is moved to the set. If allow_modify_function is true then the function func can be modified.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following utility identifies those constraints imposing bounds on a given variable, and returns those bound values:","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.get_bounds","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.get_bounds","page":"API Reference","title":"MathOptInterface.Utilities.get_bounds","text":"get_bounds(model::MOI.ModelLike, ::Type{T}, x::MOI.VariableIndex)\n\nReturn a tuple (lb, ub) of type Tuple{T, T}, where lb and ub are lower  and upper bounds, respectively, imposed on x in model.\n\n\n\n\n\nget_bounds(\n    model::MOI.ModelLike,\n    bounds_cache::Dict{MOI.VariableIndex,NTuple{2,T}},\n    f::MOI.ScalarAffineFunction{T},\n) where {T} --> Union{Nothing,NTuple{2,T}}\n\nReturn the lower and upper bound of f as a tuple. If the domain is not bounded, return nothing.\n\n\n\n\n\nget_bounds(\n    model::MOI.ModelLike,\n    bounds_cache::Dict{MOI.VariableIndex,NTuple{2,T}},\n    x::MOI.VariableIndex,\n) where {T} --> Union{Nothing,NTuple{2,T}}\n\nReturn the lower and upper bound of x as a tuple. If the domain is not bounded, return nothing.\n\nSimilar to get_bounds(::MOI.ModelLike, ::Type{T}, ::MOI.VariableIndex), except that the second argument is a cache which maps variables to their bounds and avoids repeated lookups.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following utilities are useful when working with symmetric matrix cones.","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.is_diagonal_vectorized_index\nUtilities.side_dimension_for_vectorized_dimension","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.is_diagonal_vectorized_index","page":"API Reference","title":"MathOptInterface.Utilities.is_diagonal_vectorized_index","text":"is_diagonal_vectorized_index(index::Base.Integer)\n\nReturn whether index is the index of a diagonal element in a MOI.AbstractSymmetricMatrixSetTriangle set.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.side_dimension_for_vectorized_dimension","page":"API Reference","title":"MathOptInterface.Utilities.side_dimension_for_vectorized_dimension","text":"side_dimension_for_vectorized_dimension(n::Integer)\n\nReturn the dimension d such that MOI.dimension(MOI.PositiveSemidefiniteConeTriangle(d)) is n.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#Set-utilities","page":"API Reference","title":"Set utilities","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"The following utilities are available for sets:","category":"page"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.AbstractDistance\nUtilities.ProjectionUpperBoundDistance\nUtilities.distance_to_set\nUtilities.set_dot","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.AbstractDistance","page":"API Reference","title":"MathOptInterface.Utilities.AbstractDistance","text":"abstract type AbstractDistance end\n\nAn abstract type used to enable dispatch of Utilities.distance_to_set.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.ProjectionUpperBoundDistance","page":"API Reference","title":"MathOptInterface.Utilities.ProjectionUpperBoundDistance","text":"ProjectionUpperBoundDistance() <: AbstractDistance\n\nAn upper bound on the minimum distance between point and the closest feasible point in set.\n\nDefinition of distance\n\nThe minimum distance is computed as:\n\nd(x mathcalK) = min_y in mathcalK  x - y \n\nwhere x is point and mathcalK is set. The norm is computed as:\n\nx = sqrtf(x x mathcalK)\n\nwhere f is Utilities.set_dot.\n\nIn the default case, where the set does not have a specialized method for Utilities.set_dot, the norm is equivalent to the Euclidean norm x = sqrtsum x_i^2.\n\nWhy an upper bound?\n\nIn most cases, distance_to_set should return the smallest upper bound, but it may return a larger value if the smallest upper bound is expensive to compute.\n\nFor example, given an epigraph from of a conic set, (t x)  f(x) le t, it may be simpler to return delta such that f(x) le t + delta, rather than computing the nearest projection onto the set.\n\nIf the distance is not the smallest upper bound, the docstring of the appropriate distance_to_set method must describe the way that the distance is computed.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.distance_to_set","page":"API Reference","title":"MathOptInterface.Utilities.distance_to_set","text":"distance_to_set(\n    [d::AbstractDistance = ProjectionUpperBoundDistance()],]\n    point::T,\n    set::MOI.AbstractScalarSet,\n) where {T}\n\ndistance_to_set(\n    [d::AbstractDistance = ProjectionUpperBoundDistance(),]\n    point::AbstractVector{T},\n    set::MOI.AbstractVectorSet,\n) where {T}\n\nCompute the distance between point and set using the distance metric d. If point is in the set set, this function must return zero(T).\n\nIf d is omitted, the default distance is Utilities.ProjectionUpperBoundDistance.\n\n\n\n\n\ndistance_to_set(::ProjectionUpperBoundDistance, x, ::MOI.RotatedSecondOrderCone)\n\nLet (t, u, y...) = x. Return the 2-norm of the vector d such that in x + d, u is projected to 1 if u <= 0, and t is increased such that x + d belongs to the set.\n\n\n\n\n\ndistance_to_set(::ProjectionUpperBoundDistance, x, ::MOI.ExponentialCone)\n\nLet (u, v, w) = x. If v > 0, return the epigraph distance d such that (u, v, w + d) belongs to the set.\n\nIf v <= 0 return the 2-norm of the vector d such that x + d = (u, 1, z) where z satisfies the constraints.\n\n\n\n\n\ndistance_to_set(::ProjectionUpperBoundDistance, x, ::MOI.DualExponentialCone)\n\nLet (u, v, w) = x. If u < 0, return the epigraph distance d such that (u, v, w + d) belongs to the set.\n\nIf u >= 0 return the 2-norm of the vector d such that x + d = (u, -1, z) where z satisfies the constraints.\n\n\n\n\n\ndistance_to_set(::ProjectionUpperBoundDistance, x, ::MOI.GeometricMeanCone)\n\nLet (t, y...) = x. If all y are non-negative, return the epigraph distance d such that (t + d, y...) belongs to the set.\n\nIf any y are strictly negative, return the 2-norm of the vector d that projects negative y elements to 0 and t to ℝ₋.\n\n\n\n\n\ndistance_to_set(::ProjectionUpperBoundDistance, x, ::MOI.PowerCone)\n\nLet (a, b, c) = x. If a and b are non-negative, return the epigraph distance required to increase c such that the constraint is satisfied.\n\nIf a or b is strictly negative, return the 2-norm of the vector d such that in the vector x + d: c, and any negative a and b are projected to 0.\n\n\n\n\n\ndistance_to_set(::ProjectionUpperBoundDistance, x, ::MOI.DualPowerCone)\n\nLet (a, b, c) = x. If a and b are non-negative, return the epigraph distance required to increase c such that the constraint is satisfied.\n\nIf a or b is strictly negative, return the 2-norm of the vector d such that in the vector x + d: c, and any negative a and b are projected to 0.\n\n\n\n\n\ndistance_to_set(::ProjectionUpperBoundDistance, x, ::MOI.NormOneCone)\n\nLet (t, y...) = x. Return the epigraph distance d such that (t + d, y...) belongs to the set.\n\n\n\n\n\ndistance_to_set(::ProjectionUpperBoundDistance, x, ::MOI.NormInfinityCone)\n\nLet (t, y...) = x. Return the epigraph distance d such that (t + d, y...) belongs to the set.\n\n\n\n\n\ndistance_to_set(::ProjectionUpperBoundDistance, x, ::MOI.RelativeEntropyCone)\n\nLet (u, v..., w...) = x. If v and w are strictly positive, return the epigraph distance required to increase u such that the constraint is satisfied.\n\nIf any elements in v or w are non-positive, return the 2-norm of the vector d such that in the vector x + d: any non-positive elements in v and w are projected to 1, and u is projected such that the epigraph constraint holds.\n\n\n\n\n\ndistance_to_set(::ProjectionUpperBoundDistance, x, set::MOI.NormCone)\n\nLet (t, y...) = x. Return the epigraph distance d such that (t + d, y...) belongs to the set.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.set_dot","page":"API Reference","title":"MathOptInterface.Utilities.set_dot","text":"set_dot(x::AbstractVector, y::AbstractVector, set::AbstractVectorSet)\n\nReturn the scalar product between a vector x of the set set and a vector y of the dual of the set s.\n\n\n\n\n\nset_dot(x, y, set::AbstractScalarSet)\n\nReturn the scalar product between a number x of the set set and a number y of the dual of the set s.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#DoubleDicts","page":"API Reference","title":"DoubleDicts","text":"","category":"section"},{"location":"moi/submodules/Utilities/reference/","page":"API Reference","title":"API Reference","text":"Utilities.DoubleDicts.DoubleDict\nUtilities.DoubleDicts.DoubleDictInner\nUtilities.DoubleDicts.IndexDoubleDict\nUtilities.DoubleDicts.IndexDoubleDictInner\nUtilities.DoubleDicts.outer_keys\nUtilities.DoubleDicts.nonempty_outer_keys","category":"page"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.DoubleDicts.DoubleDict","page":"API Reference","title":"MathOptInterface.Utilities.DoubleDicts.DoubleDict","text":"DoubleDict{V}\n\nAn optimized dictionary to map MOI.ConstraintIndex to values of type V.\n\nWorks as a AbstractDict{MOI.ConstraintIndex,V} with minimal differences.\n\nIf V is also a MOI.ConstraintIndex, use IndexDoubleDict.\n\nNote that MOI.ConstraintIndex is not a concrete type, opposed to MOI.ConstraintIndex{MOI.VariableIndex, MOI.Integers}, which is a concrete type.\n\nWhen looping through multiple keys of the same Function-in-Set type, use\n\ninner = dict[F, S]\n\nto return a type-stable DoubleDictInner.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.DoubleDicts.DoubleDictInner","page":"API Reference","title":"MathOptInterface.Utilities.DoubleDicts.DoubleDictInner","text":"DoubleDictInner{F,S,V}\n\nA type stable inner dictionary of DoubleDict.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.DoubleDicts.IndexDoubleDict","page":"API Reference","title":"MathOptInterface.Utilities.DoubleDicts.IndexDoubleDict","text":"IndexDoubleDict\n\nA specialized version of [DoubleDict] in which the values are of type MOI.ConstraintIndex\n\nWhen looping through multiple keys of the same Function-in-Set type, use\n\ninner = dict[F, S]\n\nto return a type-stable IndexDoubleDictInner.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.DoubleDicts.IndexDoubleDictInner","page":"API Reference","title":"MathOptInterface.Utilities.DoubleDicts.IndexDoubleDictInner","text":"IndexDoubleDictInner{F,S}\n\nA type stable inner dictionary of IndexDoubleDict.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.DoubleDicts.outer_keys","page":"API Reference","title":"MathOptInterface.Utilities.DoubleDicts.outer_keys","text":"outer_keys(d::AbstractDoubleDict)\n\nReturn an iterator over the outer keys of the AbstractDoubleDict d. Each outer key is a Tuple{Type,Type} so that a double loop can be easily used:\n\nfor (F, S) in DoubleDicts.outer_keys(dict)\n    for (k, v) in dict[F, S]\n        # ...\n    end\nend\n\nFor performance, it is recommended that the inner loop lies in a separate function to guarantee type-stability. Some outer keys (F, S) might lead to an empty dict[F, S]. If you want only nonempty dict[F, S], use nonempty_outer_keys.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Utilities/reference/#MathOptInterface.Utilities.DoubleDicts.nonempty_outer_keys","page":"API Reference","title":"MathOptInterface.Utilities.DoubleDicts.nonempty_outer_keys","text":"nonempty_outer_keys(d::AbstractDoubleDict)\n\nReturn a vector of outer keys of the AbstractDoubleDict d.\n\nOnly outer keys that have a nonempty set of inner keys will be returned.\n\nEach outer key is a Tuple{Type,Type} so that a double loop can be easily used\n\nfor (F, S) in DoubleDicts.nonempty_outer_keys(dict)\n    for (k, v) in dict[F, S]\n        # ...\n    end\nend\nFor performance, it is recommended that the inner loop lies in a separate\nfunction to guarantee type-stability.\n\nIf you want an iterator of all current outer keys, use [`outer_keys`](@ref).\n\n\n\n\n\n","category":"function"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"EditURL = \"https://github.com/jump-dev/Clp.jl/blob/v1.0.3/README.md\"","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"(Image: )","category":"page"},{"location":"packages/Clp/#Clp.jl","page":"jump-dev/Clp.jl","title":"Clp.jl","text":"","category":"section"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"Clp.jl is a wrapper for the COIN-OR Linear Programming solver.","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"The wrapper has two components:","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"a thin wrapper around the complete C API\nan interface to MathOptInterface","category":"page"},{"location":"packages/Clp/#Affiliation","page":"jump-dev/Clp.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"This wrapper is maintained by the JuMP community and is not a COIN-OR project.","category":"page"},{"location":"packages/Clp/#License","page":"jump-dev/Clp.jl","title":"License","text":"","category":"section"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"Clp.jl is licensed under the MIT License.","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"The underlying solver, coin-or/Clp, is licensed under the Eclipse public license.","category":"page"},{"location":"packages/Clp/#Installation","page":"jump-dev/Clp.jl","title":"Installation","text":"","category":"section"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"Install Clp using Pkg.add:","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"import Pkg\nPkg.add(\"Clp\")","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"In addition to installing the Clp.jl package, this will also download and install the Clp binaries. You do not need to install Clp separately.","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"To use a custom binary, read the Custom solver binaries section of the JuMP documentation.","category":"page"},{"location":"packages/Clp/#Use-with-JuMP","page":"jump-dev/Clp.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"To use Clp with JuMP, use Clp.Optimizer:","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"using JuMP, Clp\nmodel = Model(Clp.Optimizer)\nset_attribute(model, \"LogLevel\", 1)\nset_attribute(model, \"Algorithm\", 4)","category":"page"},{"location":"packages/Clp/#MathOptInterface-API","page":"jump-dev/Clp.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"The Clp optimizer supports the following constraints and attributes.","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"List of supported objective functions:","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"MOI.Reals","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"MOI.ScalarAffineFunction{Float64} in MOI.EqualTo{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.Interval{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.EqualTo{Float64}\nMOI.VariableIndex in MOI.GreaterThan{Float64}\nMOI.VariableIndex in MOI.Interval{Float64}\nMOI.VariableIndex in MOI.LessThan{Float64}","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"MOI.ObjectiveSense()","category":"page"},{"location":"packages/Clp/#Options","page":"jump-dev/Clp.jl","title":"Options","text":"","category":"section"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"Options are, unfortunately, not well documented.","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"The following options are likely to be the most useful:","category":"page"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"Parameter Example Explanation\nPrimalTolerance 1e-7 Primal feasibility tolerance\nDualTolerance 1e-7 Dual feasibility tolerance\nDualObjectiveLimit 1e308 When using dual simplex (where the objective is monotonically changing), terminate when the objective exceeds this limit\nMaximumIterations 2147483647 Terminate after performing this number of simplex iterations\nMaximumSeconds -1.0 Terminate after this many seconds have passed. A negative value means no time limit\nLogLevel 1 Set to 1, 2, 3, or 4 for increasing output. Set to 0 to disable output\nPresolveType 0 Set to 1 to disable presolve\nSolveType 5 Solution method: dual simplex (0), primal simplex (1), sprint (2), barrier with crossover (3), barrier without crossover (4), automatic (5)\nInfeasibleReturn 0 Set to 1 to return as soon as the problem is found to be infeasible (by default, an infeasibility proof is computed as well)\nScaling 3 0 -off, 1 equilibrium, 2 geometric, 3 auto, 4 dynamic(later)\nPerturbation 100 switch on perturbation (50), automatic (100), don't try perturbing (102)","category":"page"},{"location":"packages/Clp/#C-API","page":"jump-dev/Clp.jl","title":"C API","text":"","category":"section"},{"location":"packages/Clp/","page":"jump-dev/Clp.jl","title":"jump-dev/Clp.jl","text":"The C API can be accessed via Clp.Clp_XXX functions, where the names and arguments are identical to the C API.","category":"page"},{"location":"background/bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"background/bibliography/","page":"Bibliography","title":"Bibliography","text":"Barvinok, A. (2002). A course in convexity. Vol. 54 of Graduate studies in mathematics (American Mathematical Society).\n\n\n\nBen-Tal, A. and Nemirovski, A. (2001). Lectures on Modern Convex Optimization (Society for Industrial and Applied Mathematics).\n\n\n\nBertsimas, D.; Gupta, V. and Kallus, N. (2018). Data-driven robust optimization. Mathematical Programming 167, 235–292.\n\n\n\nBetts, J. T. (2010). Practical Methods for Optimal Control and Estimation Using Nonlinear Programming. Second Edition (Society for Industrial and Applied Mathematics).\n\n\n\nBoyd, S. and Vandenberghe, L. (2004). Convex Optimization (Cambridge University Press, Cambridge).\n\n\n\nBukhsh, W. A.; Grothey, A.; McKinnon, K. I. and Trodden, P. A. (2013). Local Solutions of the Optimal Power Flow Problem. IEEE Transactions on Power Systems 28, 4780–4788.\n\n\n\nCornuéjols, G.; Peña, J. and Tütüncü, R. (2018). Optimization Methods in Finance. 2 Edition (Cambridge University Press).\n\n\n\nD’Aertrycke, G.; Ehrenmann, A.; Ralph, D. and Smeers, Y. (2017). Risk trading in capacity equilibrium models (Cambridge Working Papers in Economics (CWPE)).\n\n\n\nFerris, M. C.; Mangasarian, O. L. and Wright, S. J. (2007). Linear Programming with MATLAB (Society for Industrial and Applied Mathematics).\n\n\n\nGoemans, M. X. and Williamson, D. P. (1995). Improved Approximation Algorithms for Maximum Cut and Satisfiability Problems Using Semidefinite Programming. J. ACM 42, 1115–1145.\n\n\n\nJabr, R. A. (2012). Exploiting Sparsity in SDP Relaxations of the OPF Problem. IEEE Transactions on Power Systems 27, 1138–1139.\n\n\n\nKnuth, D. E. (1994). The sandwich theorem. The Electronic Journal of Combinatorics 1.\n\n\n\nKrasko, V. and Rebennack, S. (2017). Global Optimization: Optimal Power Flow Problem. In: Advances and Trends in Optimization with Engineering Applications, edited by Terlaky, T.; Anjos, M. F. and Ahmed, S. (Society for Industrial and Applied Mathematics, Philadelphia, PA); Chapter 15, pp. 187–205.\n\n\n\nLinial, N. (2002). Finite Metric Spaces: Combinatorics, Geometry and Algorithms. In: Proceedings of the Eighteenth Annual Symposium on Computational Geometry, SCG '02 (Association for Computing Machinery, New York, NY, USA); p. 63.\n\n\n\nMatoušek, J. (2013). Lectures on discrete geometry. Vol. 212 no. 1 of Graduate Texts in Mathematics (Springer Science & Business Media).\n\n\n\nPeng, J. and Wei, Y. (2007). Approximating K‐means‐type Clustering via Semidefinite Programming. SIAM Journal on Optimization 18, 186–205.\n\n\n\nZimmerman, R. D.; Murillo-Sánchez, C. E. and Thomas, R. J. (2011). MATPOWER: Steady-State Operations, Planning, and Analysis Tools for Power Systems Research and Education. IEEE Transactions on Power Systems 26, 12–19.\n\n\n\n","category":"page"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/index.md\"","category":"page"},{"location":"moi/#moi_documentation","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"warning: Warning\nThis documentation in this section is a copy of the official MathOptInterface documentation available at https://jump.dev/MathOptInterface.jl/v1.29.0. It is included here to make it easier to link concepts between JuMP and MathOptInterface.","category":"page"},{"location":"moi/#What-is-MathOptInterface?","page":"Introduction","title":"What is MathOptInterface?","text":"","category":"section"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"MathOptInterface.jl (MOI) is an abstraction layer designed to provide a unified interface to mathematical optimization solvers so that users do not need to understand multiple solver-specific APIs.","category":"page"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"tip: Tip\nThis documentation is aimed at developers writing software interfaces to solvers and modeling languages using the MathOptInterface API. If you are a user interested in solving optimization problems, we encourage you instead to use MOI through a higher-level modeling interface like JuMP or Convex.jl.","category":"page"},{"location":"moi/#How-the-documentation-is-structured","page":"Introduction","title":"How the documentation is structured","text":"","category":"section"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"Having a high-level overview of how this documentation is structured will help you know where to look for certain things.","category":"page"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"The Tutorials section contains articles on how to use and implement the MathOptInteraface API. Look here if you want to write a model in MOI, or write an interface to a new solver.\nThe Manual contains short code-snippets that explain how to use the MOI API. Look here for more details on particular areas of MOI.\nThe Background section contains articles on the theory behind MathOptInterface. Look here if you want to understand why, rather than how.\nThe API Reference contains a complete list of functions and types that comprise the MOI API. Look here is you want to know how to use (or implement) a particular function.\nThe Submodules section contains stand-alone documentation for each of the submodules within MOI. These submodules are not required to interface a solver with MOI, but they make the job much easier.","category":"page"},{"location":"moi/#Citing-MathOptInterface","page":"Introduction","title":"Citing MathOptInterface","text":"","category":"section"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"If you find MathOptInterface useful in your work, we kindly request that you cite the following paper:","category":"page"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"@article{legat2021mathoptinterface,\n    title={{MathOptInterface}: a data structure for mathematical optimization problems},\n    author={Legat, Beno{\\^\\i}t and Dowson, Oscar and Garcia, Joaquim Dias and Lubin, Miles},\n    journal={INFORMS Journal on Computing},\n    year={2021},\n    doi={10.1287/ijoc.2021.1067},\n    publisher={INFORMS}\n}","category":"page"},{"location":"moi/","page":"Introduction","title":"Introduction","text":"A preprint of this paper is freely available.","category":"page"},{"location":"packages/OSQP/","page":"osqp/OSQP.jl","title":"osqp/OSQP.jl","text":"EditURL = \"https://github.com/osqp/OSQP.jl/blob/443706e34c2619acbe65281c60bbe850ca4a8fac/README.md\"","category":"page"},{"location":"packages/OSQP/#OSQP.jl","page":"osqp/OSQP.jl","title":"OSQP.jl","text":"","category":"section"},{"location":"packages/OSQP/","page":"osqp/OSQP.jl","title":"osqp/OSQP.jl","text":"(Image: Build Status)  (Image: codecov.io)","category":"page"},{"location":"packages/OSQP/","page":"osqp/OSQP.jl","title":"osqp/OSQP.jl","text":"OSQP.jl is a Julia wrapper for OSQP: the Operator Splitting QP Solver.","category":"page"},{"location":"packages/OSQP/#License","page":"osqp/OSQP.jl","title":"License","text":"","category":"section"},{"location":"packages/OSQP/","page":"osqp/OSQP.jl","title":"osqp/OSQP.jl","text":"OSQP.jl is licensed under the Apache-2.0 license.","category":"page"},{"location":"packages/OSQP/","page":"osqp/OSQP.jl","title":"osqp/OSQP.jl","text":"The upstream solver, osqp/osqp is also licensed under the Apache-2.0 license.","category":"page"},{"location":"packages/OSQP/#Installation","page":"osqp/OSQP.jl","title":"Installation","text":"","category":"section"},{"location":"packages/OSQP/","page":"osqp/OSQP.jl","title":"osqp/OSQP.jl","text":"Install OSQP.jl using the Julia package manager","category":"page"},{"location":"packages/OSQP/","page":"osqp/OSQP.jl","title":"osqp/OSQP.jl","text":"import Pkg\nPkg.add(\"OSQP\")","category":"page"},{"location":"packages/OSQP/#Problem-class","page":"osqp/OSQP.jl","title":"Problem class","text":"","category":"section"},{"location":"packages/OSQP/","page":"osqp/OSQP.jl","title":"osqp/OSQP.jl","text":"The OSQP (Operator Splitting Quadratic Program) solver is a numerical optimization package for solving problems in the form","category":"page"},{"location":"packages/OSQP/","page":"osqp/OSQP.jl","title":"osqp/OSQP.jl","text":"minimize        0.5 x' P x + q' x\n\nsubject to      l <= A x <= u","category":"page"},{"location":"packages/OSQP/","page":"osqp/OSQP.jl","title":"osqp/OSQP.jl","text":"where x in R^n is the optimization variable. The objective function is defined by a positive semidefinite matrix P in S^n_+ and vector q in R^n. The linear constraints are defined by matrix A in R^{m x n} and vectors l in R^m U {-inf}^m, u in R^m U {+inf}^m.","category":"page"},{"location":"packages/OSQP/#Documentation","page":"osqp/OSQP.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/OSQP/","page":"osqp/OSQP.jl","title":"osqp/OSQP.jl","text":"Detailed documentation is available at https://osqp.org/.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"EditURL = \"classifiers.jl\"","category":"page"},{"location":"tutorials/nonlinear/classifiers/#Classifiers","page":"Classifiers","title":"Classifiers","text":"","category":"section"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"The purpose of this tutorial is to show how JuMP can be used to formulate classification problems.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"Classification problems deal with constructing functions, called classifiers, that can efficiently classify data into two or more distinct sets. A common application is classifying previously unseen data points after training a classifier on known data.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"The theory and models in this tutorial come from Section 9.4 of (Ferris et al., 2007).","category":"page"},{"location":"tutorials/nonlinear/classifiers/#Required-packages","page":"Classifiers","title":"Required packages","text":"","category":"section"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"This tutorial uses the following packages","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"using JuMP\nimport DelimitedFiles\nimport Ipopt\nimport LinearAlgebra\nimport Plots\nimport Random\nimport Test","category":"page"},{"location":"tutorials/nonlinear/classifiers/#Data-and-visualisation","page":"Classifiers","title":"Data and visualisation","text":"","category":"section"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"To start, let's generate some points to test with. The argument m is the number of 2-dimensional points:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"function generate_test_points(m; random_seed = 1)\n    rng = Random.MersenneTwister(random_seed)\n    return 2.0 .* rand(rng, Float64, m, 2)\nend","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"For the sake of the example, let's take m = 100:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"P = generate_test_points(100);\nnothing #hide","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"The points are represented row-wise in the matrix P. Let's visualise the points using the Plots package:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"plot = Plots.scatter(\n    P[:, 1],\n    P[:, 2];\n    xlim = (0, 2.02),\n    ylim = (0, 2.02),\n    color = :white,\n    size = (600, 600),\n    legend = false,\n)","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"We want to split the points into two distinct sets on either side of a dividing line. We'll then label each point depending on which side of the line it happens to fall. Based on the labels of the point, we'll show how to create a classifier using a JuMP model. We can then test how well our classifier reproduces the original labels and the boundary between them.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"Let's make a line to divide the points into two sets by defining a gradient and a constant:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"w_0, g_0 = [5, 3], 8\nline(v::AbstractArray; w = w_0, g = g_0) = w' * v - g\nline(x::Real; w = w_0, g = g_0) = -(w[1] * x - g) / w[2];\nnothing #hide","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"Julia's multiple dispatch feature allows us to define the vector and single-variable form of the line function under the same name.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"Let's add this to the plot:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"Plots.plot!(plot, line; linewidth = 5)","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"Now we label the points relative to which side of the line they are. It is numerically useful to have the labels +1 and -1 for the upcoming JuMP formulation.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"labels = ifelse.(line.(eachrow(P)) .>= 0, 1, -1)\nPlots.scatter!(\n    plot,\n    P[:, 1],\n    P[:, 2];\n    shape = ifelse.(labels .== 1, :cross, :xcross),\n    markercolor = ifelse.(labels .== 1, :blue, :crimson),\n    markersize = 8,\n)","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"Our goal is to show we can reconstruct the line from just the points and the labels.","category":"page"},{"location":"tutorials/nonlinear/classifiers/#Formulation:-linear-support-vector-machine","page":"Classifiers","title":"Formulation: linear support vector machine","text":"","category":"section"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"A classifier known as the linear support vector machine (SVM) looks for the affine function L(p) = w^top p - g that satisfies L(p)  0 for all points p with a label -1 and L(p) ge 0 for all points p with a label +1.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"The linearly constrained quadratic program that implements this is:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"beginaligned\nmin_w in mathbbR^n  g in mathbbR  y in mathbbR^m quad  frac12 w^top w + C  sum_i=1^m y_i \ntextsubject to  quad  D cdot (P w - g) + y geq mathbf1 \n                   y ge 0\nendaligned","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"where D is a diagonal matrix of the labels.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"We need a default value for the positive penalty parameter C:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"C_0 = 100.0;\nnothing #hide","category":"page"},{"location":"tutorials/nonlinear/classifiers/#JuMP-formulation","page":"Classifiers","title":"JuMP formulation","text":"","category":"section"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"Here is the JuMP model:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"function solve_SVM_classifier(P::Matrix, labels::Vector; C::Float64 = C_0)\n    m, n = size(P)\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, w[1:n])\n    @variable(model, g)\n    @variable(model, y[1:m] >= 0)\n    @objective(model, Min, 1 / 2 * w' * w + C * sum(y))\n    D = LinearAlgebra.Diagonal(labels)\n    @constraint(model, D * (P * w .- g) .+ y .>= 1)\n    optimize!(model)\n    Test.@test is_solved_and_feasible(model)\n    slack = extrema(value.(y))\n    println(\"Minimum slack: \", slack[1], \"\\nMaximum slack: \", slack[2])\n    classifier(x) = line(x; w = value.(w), g = value(g))\n    return model, classifier\nend","category":"page"},{"location":"tutorials/nonlinear/classifiers/#Results","page":"Classifiers","title":"Results","text":"","category":"section"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"Let's recover the values that define the classifier by solving the model:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"_, classifier = solve_SVM_classifier(P, labels)","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"With the solution, we can ask: was the value of the penalty constant \"sufficiently large\" for this data set? This can be judged in part by the range of the slack variables. If the slack is too large, then we need to increase the penalty constant.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"Let's plot the solution and check how we did:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"Plots.plot!(plot, classifier; linewidth = 5, linestyle = :dashdotdot)","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"We find that we have recovered the dividing line from just the information of the points and their labels.","category":"page"},{"location":"tutorials/nonlinear/classifiers/#Nonseparable-classes-of-points","page":"Classifiers","title":"Nonseparable classes of points","text":"","category":"section"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"Now, what if the point sets are not cleanly separable by a line (or a hyperplane in higher dimensions)? Does this still work?  Let's repeat the process, but this time we will simulate nonseparable classes of points by intermingling a few nearby points across the previously used line.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"nearby_indices = abs.(line.(eachrow(P))) .< 1.1\nlabels_new = ifelse.(nearby_indices, -labels, labels)\nmodel, classifier = solve_SVM_classifier(P, labels_new)\nplot = Plots.scatter(\n    P[:, 1],\n    P[:, 2];\n    xlim = (0, 2.02),\n    ylim = (0, 2.02),\n    color = :white,\n    size = (600, 600),\n    legend = false,\n)\nPlots.scatter!(\n    plot,\n    P[:, 1],\n    P[:, 2];\n    shape = ifelse.(labels_new .== 1, :cross, :xcross),\n    markercolor = ifelse.(labels_new .== 1, :blue, :crimson),\n    markersize = 8,\n)\nPlots.plot!(plot, classifier; linewidth = 5, linestyle = :dashdotdot)","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"So our JuMP formulation still produces a classifier, but it mis-classifies some of the nonseparable points.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"We can find out which points are contributing to the shape of the line by looking at the dual values of the affine constraints and comparing them to the penalty constant C:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"affine_cons = all_constraints(model, AffExpr, MOI.GreaterThan{Float64})\nactive_cons = findall(isapprox.(dual.(affine_cons), C_0; atol = 0.001))\nfindall(nearby_indices) ⊆ active_cons","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"The last statement tells us that our nonseparable points are actively contributing to how the classifier is defined. The remaining points are of interest and are highlighted:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"P_active = P[setdiff(active_cons, findall(nearby_indices)), :]\nPlots.scatter!(\n    plot,\n    P_active[:, 1],\n    P_active[:, 2];\n    shape = :hexagon,\n    markersize = 8,\n    markeropacity = 0.5,\n)","category":"page"},{"location":"tutorials/nonlinear/classifiers/#Advanced:-duality-and-the-kernel-method","page":"Classifiers","title":"Advanced: duality and the kernel method","text":"","category":"section"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"We now consider an alternative formulation for a linear SVM by solving the dual problem.","category":"page"},{"location":"tutorials/nonlinear/classifiers/#The-dual-program","page":"Classifiers","title":"The dual program","text":"","category":"section"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"The dual of the linear SVM program is also a linearly constrained quadratic program:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"beginaligned\nmin_u in mathbbR^m quad  frac12 u^top D P  P^top D u -  mathbf1^top u \ntextsubject to  quad  mathbf1^top D u = 0  \n                   0 leq u leq Cmathbf1\nendaligned","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"This is the JuMP model:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"function solve_dual_SVM_classifier(P::Matrix, labels::Vector; C::Float64 = C_0)\n    m, n = size(P)\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, 0 <= u[1:m] <= C)\n    D = LinearAlgebra.Diagonal(labels)\n    @objective(model, Min, 1 / 2 * u' * D * P * P' * D * u - sum(u))\n    @constraint(model, con, sum(D * u) == 0)\n    optimize!(model)\n    Test.@test is_solved_and_feasible(model)\n    w = P' * D * value.(u)\n    g = dual(con)\n    classifier(x) = line(x; w = w, g = g)\n    return classifier\nend","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"We recover the line gradient vector w through setting w = P^top D u, and the line constant g as the dual value of the single affine constraint.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"The dual problem has fewer variables and fewer constraints, so in many cases it may be simpler to solve the dual form.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"We can check that the dual form has recovered a classifier:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"classifier = solve_dual_SVM_classifier(P, labels)\nPlots.plot!(plot, classifier; linewidth = 5, linestyle = :dash)","category":"page"},{"location":"tutorials/nonlinear/classifiers/#The-kernel-method","page":"Classifiers","title":"The kernel method","text":"","category":"section"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"Linear SVM techniques are not limited to finding separating hyperplanes in the original space of the dataset. One could first transform the  training data under a nonlinear mapping, apply our method, then map the hyperplane back into original space.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"The actual data describing the point set is held in a matrix P, but looking at the dual program we see that what actually matters is the Gram matrix P P^top, expressing a pairwise comparison (an inner-product) between each point vector. It follows that any mapping of the point set only needs to be defined at the level of pairwise maps between points. Such maps are known as kernel functions:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"k    mathbbR^n times mathbbR^n  rightarrow mathbbR qquad\n(s t) mapsto left Phi(s) Phi(t) right","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"where the right-hand side applies some transformation Phi  mathbbR^n rightarrow mathbbR^n followed by an inner-product in that image space.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"In practice, we can avoid having Phi explicitly given but instead define a kernel function directly between pairs of vectors. This change to using a kernel function without knowing the map is called the kernel method (or sometimes, the kernel trick).","category":"page"},{"location":"tutorials/nonlinear/classifiers/#Classifier-using-a-Gaussian-kernel","page":"Classifiers","title":"Classifier using a Gaussian kernel","text":"","category":"section"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"We will demonstrate the application of a Gaussian or radial basis function kernel:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"k(s t)  = expleft( -mu lVert s - t rVert^2_2 right)","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"for some positive parameter mu.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"k_gauss(s::Vector, t::Vector; μ = 0.5) = exp(-μ * LinearAlgebra.norm(s - t)^2)","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"Given a matrix of points expressed row-wise and a kernel, the next function returns the transformed matrix K that replaces P P^top:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"function pairwise_transform(kernel::Function, P::Matrix{T}) where {T}\n    m, n = size(P)\n    K = zeros(T, m, m)\n    for j in 1:m, i in 1:j\n        K[i, j] = K[j, i] = kernel(P[i, :], P[j, :])\n    end\n    return LinearAlgebra.Symmetric(K)\nend","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"Now we're ready to define our optimization problem. We need to provide the kernel function to be used in the problem. Note that any extra keyword arguments here (like parameter values) are passed through to the kernel.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"function solve_kernel_SVM_classifier(\n    kernel::Function,\n    P::Matrix,\n    labels::Vector;\n    C::Float64 = C_0,\n    kwargs...,\n)\n    m, n = size(P)\n    K = pairwise_transform(kernel, P)\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, 0 <= u[1:m] <= C)\n    D = LinearAlgebra.Diagonal(labels)\n    con = @constraint(model, sum(D * u) == 0)\n    @objective(model, Min, 1 / 2 * u' * D * K * D * u - sum(u))\n    optimize!(model)\n    Test.@test is_solved_and_feasible(model)\n    u_sol, g_sol = value.(u), dual(con)\n    function classifier(v::Vector)\n        return sum(\n            D[i, i] * u_sol[i] * kernel(P[i, :], v; kwargs...) for i in 1:m\n        ) - g_sol\n    end\n    return classifier\nend","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"This time, we don't recover the line gradient vector w directly. Instead, we compute the classifier f using the function:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":" f(v) = sum_i=1^m D_ii u_i  k(p_i v ) - g","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"where p_i is row vector i of P.","category":"page"},{"location":"tutorials/nonlinear/classifiers/#Checkerboard-dataset","page":"Classifiers","title":"Checkerboard dataset","text":"","category":"section"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"To demonstrate this nonlinear technique, we'll use the checkerboard dataset.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"filename = joinpath(@__DIR__, \"data\", \"checker\", \"checker.txt\")\ncheckerboard = DelimitedFiles.readdlm(filename, ' ', Int)\nlabels = ifelse.(iszero.(checkerboard[:, 1]), -1, 1)\nB = checkerboard[:, 2:3] ./ 100.0  # rescale to [0,2] x [0,2] square.\nplot = Plots.scatter(\n    B[:, 1],\n    B[:, 2];\n    color = ifelse.(labels .== 1, :white, :black),\n    markersize = ifelse.(labels .== 1, 4, 2),\n    size = (600, 600),\n    legend = false,\n)","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"Is the technique capable of generating a distinctly nonlinear surface? Let's solve the Gaussian kernel based quadratic problem with these parameters:","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"classifier = solve_kernel_SVM_classifier(k_gauss, B, labels; C = 1e5, μ = 10.0)\ngrid = [[x, y] for x in 0:0.01:2, y in 0:0.01:2]\ngrid_pos = [Tuple(g) for g in grid if classifier(g) >= 0]\nPlots.scatter!(plot, grid_pos; markersize = 0.2)","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"We find that the kernel method can perform well as a nonlinear classifier.","category":"page"},{"location":"tutorials/nonlinear/classifiers/","page":"Classifiers","title":"Classifiers","text":"The result has a fairly strong dependence on the choice of parameters, with larger values of mu allowing for a more complex boundary while smaller values lead to a smoother boundary for the classifier. Determining a better performing kernel function and choice of parameters is covered by the process of cross-validation with respect to the dataset, where different testing, training and tuning sets are used to validate the best choice of parameters against a statistical measure of error.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP, HiGHS, SCS\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/models/#jump_models","page":"Models","title":"Models","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"JuMP models are the fundamental building block that we use to construct optimization problems. They hold things like the variables and constraints, as well as which solver to use and even solution information.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"info: Info\nJuMP uses \"optimizer\" as a synonym for \"solver.\" Our convention is to use \"solver\" to refer to the underlying software, and use \"optimizer\" to refer to the Julia object that wraps the solver. For example, HiGHS is a solver, and HiGHS.Optimizer is an optimizer.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"tip: Tip\nSee Supported solvers for a list of available solvers.","category":"page"},{"location":"manual/models/#Create-a-model","page":"Models","title":"Create a model","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Create a model by passing an optimizer to Model:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(HiGHS.Optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: HiGHS","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"If you don't know which optimizer you will be using at creation time, create a model without an optimizer, and then call set_optimizer at any time prior to optimize!:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> set_optimizer(model, HiGHS.Optimizer)","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"tip: Tip\nDon't know what the fields Model mode and CachingOptimizer state mean? Read the Backends section.","category":"page"},{"location":"manual/models/#What-is-the-difference?","page":"Models","title":"What is the difference?","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"For most models, there is no difference between passing the optimizer to Model, and calling set_optimizer.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"However, if an optimizer does not support a constraint in the model, the timing of when an error will be thrown can differ:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"If you pass an optimizer, an error will be thrown when you try to add the constraint.\nIf you call set_optimizer, an error will be thrown when you try to solve the model via optimize!.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Therefore, most users should pass an optimizer to Model because it provides the earliest warning that your solver is not suitable for the model you are trying to build. However, if you are modifying a problem by adding and deleting different constraint types, you may need to use set_optimizer. See Switching optimizer for the relaxed problem for an example of when this is useful.","category":"page"},{"location":"manual/models/#Reducing-time-to-first-solve-latency","page":"Models","title":"Reducing time-to-first-solve latency","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"By default, JuMP uses bridges to reformulate the model you are building into an equivalent model supported by the solver.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"However, if your model is already supported by the solver, bridges add latency (read The \"time-to-first-solve\" issue). This is particularly noticeable for small models.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"To reduce the \"time-to-first-solve,s\" try passing add_bridges = false.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(HiGHS.Optimizer; add_bridges = false);","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"or","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model();\n\njulia> set_optimizer(model, HiGHS.Optimizer; add_bridges = false)","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"However, be wary. If your model and solver combination needs bridges, an error will be thrown:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(SCS.Optimizer; add_bridges = false);\n\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, 2x <= 1)\nERROR: Constraints of type MathOptInterface.ScalarAffineFunction{Float64}-in-MathOptInterface.LessThan{Float64} are not supported by the solver.\n\nIf you expected the solver to support your problem, you may have an error in your formulation. Otherwise, consider using a different solver.\n\nThe list of available solvers, along with the problem types they support, is available at https://jump.dev/JuMP.jl/stable/installation/#Supported-solvers.\n[...]","category":"page"},{"location":"manual/models/#Solvers-which-expect-environments","page":"Models","title":"Solvers which expect environments","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Some solvers accept (or require) positional arguments such as a license environment or a path to a binary executable. For these solvers, you can pass a function to Model which takes zero arguments and returns an instance of the optimizer.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A common use-case for this is passing an environment or sub-solver to the optimizer:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> import HiGHS\n\njulia> import MultiObjectiveAlgorithms as MOA\n\njulia> model = Model(() -> MOA.Optimizer(HiGHS.Optimizer))\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: MOA[algorithm=MultiObjectiveAlgorithms.Lexicographic, optimizer=HiGHS]","category":"page"},{"location":"manual/models/#solver_options","page":"Models","title":"Solver options","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"JuMP uses \"attribute\" as a synonym for \"option.\" Use optimizer_with_attributes to create an optimizer with some attributes initialized:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(\n           optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => false),\n       )\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: HiGHS","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Alternatively, use set_attribute to set an attribute after the model has been created:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(HiGHS.Optimizer);\n\njulia> set_attribute(model, \"output_flag\", false)\n\njulia> get_attribute(model, \"output_flag\")\nfalse","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"You can also modify attributes within an optimizer_with_attributes object:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> solver = optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => true);\n\njulia> get_attribute(solver, \"output_flag\")\ntrue\n\njulia> set_attribute(solver, \"output_flag\", false)\n\njulia> get_attribute(solver, \"output_flag\")\nfalse\n\njulia> model = Model(solver);","category":"page"},{"location":"manual/models/#Changing-the-number-types","page":"Models","title":"Changing the number types","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"By default, the coefficients of affine and quadratic expressions are numbers of type either Float64 or Complex{Float64} (see Complex number support).","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"The type Float64 can be changed using the GenericModel constructor:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = GenericModel{Rational{BigInt}}();\n\njulia> @variable(model, x)\nx\n\njulia> @expression(model, expr, 1 // 3 * x)\n1//3 x\n\njulia> typeof(expr)\nGenericAffExpr{Rational{BigInt}, GenericVariableRef{Rational{BigInt}}}","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Using a value_type other than Float64 is an advanced operation and should be used only if the underlying solver actually solves the problem using the provided value type.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"warning: Warning\nNonlinear Modeling is currently restricted to the Float64 number type.","category":"page"},{"location":"manual/models/#Print-the-model","page":"Models","title":"Print the model","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"By default, show(model) will print a summary of the problem:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(); @variable(model, x >= 0); @objective(model, Max, x);\n\njulia> model\nA JuMP Model\nMaximization problem with:\nVariable: 1\nObjective function type: VariableRef\n`VariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: x","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use print to print the formulation of the model (in IJulia, this will render as LaTeX.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> print(model)\nMax x\nSubject to\n x ≥ 0","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"warning: Warning\nThis format is specific to JuMP and may change in any future release. It is not intended to be an instance format. To write the model to a file, use write_to_file instead.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use latex_formulation to display the model in LaTeX form.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> latex_formulation(model)\n$$ \\begin{aligned}\n\\max\\quad & x\\\\\n\\text{Subject to} \\quad & x \\geq 0\\\\\n\\end{aligned} $$","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"In IJulia (and Documenter), ending a cell in with latex_formulation will render the model in LaTeX:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"using JuMP                # hide\nmodel = Model()           # hide\n@variable(model, x >= 0)  # hide\n@objective(model, Max, x) # hide\nlatex_formulation(model)","category":"page"},{"location":"manual/models/#Turn-off-output","page":"Models","title":"Turn off output","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use set_silent and unset_silent to disable or enable printing output from the solver.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(HiGHS.Optimizer);\n\njulia> set_silent(model)\n\njulia> unset_silent(model)","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"tip: Tip\nMost solvers will also have a solver-specific option to provide finer-grained control over the output. Consult their README's for details.","category":"page"},{"location":"manual/models/#Set-a-time-limit","page":"Models","title":"Set a time limit","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use set_time_limit_sec, unset_time_limit_sec, and time_limit_sec to manage time limits.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(HiGHS.Optimizer);\n\njulia> set_time_limit_sec(model, 60.0)\n\n\njulia> time_limit_sec(model)\n60.0\n\njulia> unset_time_limit_sec(model)\n\njulia> limit = time_limit_sec(model)\n\njulia> limit === nothing\ntrue","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"If your time limit is encoded as a Dates.Period object, use the following code to convert it to Float64 for set_time_limit_sec:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> import Dates\n\njulia> seconds(x::Dates.Period) = 1e-3 * Dates.value(round(x, Dates.Millisecond))\nseconds (generic function with 1 method)\n\njulia> set_time_limit_sec(model, seconds(Dates.Hour(1)))\n\njulia> time_limit_sec(model)\n3600.0","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"info: Info\nSome solvers do not support time limits. In these cases, an error will be thrown.","category":"page"},{"location":"manual/models/#Write-a-model-to-file","page":"Models","title":"Write a model to file","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"JuMP can write models to a variety of file-formats using write_to_file and Base.write.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"For most common file formats, the file type will be detected from the extension.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"For example, here is how to write an MPS file:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model();\n\njulia> write_to_file(model, \"model.mps\")","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Other supported file formats include:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":".cbf for the Conic Benchmark Format\n.lp for the LP file format\n.mof.json for the MathOptFormat\n.nl for AMPL's NL file format\n.rew for the REW file format\n.sdpa and \".dat-s\" for the SDPA file format","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"To write to a specific io::IO, use Base.write. Specify the file type by passing a MOI.FileFormats.FileFormat enum.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model();\n\njulia> io = IOBuffer();\n\njulia> write(io, model; format = MOI.FileFormats.FORMAT_MPS)","category":"page"},{"location":"manual/models/#Read-a-model-from-file","page":"Models","title":"Read a model from file","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"JuMP models can be created from file formats using read_from_file and Base.read.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = read_from_file(\"model.mps\")\nA JuMP Model\nMinimization problem with:\nVariables: 0\nObjective function type: AffExpr\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> seekstart(io);\n\njulia> model2 = read(io, Model; format = MOI.FileFormats.FORMAT_MPS)\nA JuMP Model\nMinimization problem with:\nVariables: 0\nObjective function type: AffExpr\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"note: Note\nBecause file formats do not serialize the containers of JuMP variables and constraints, the names in the model will not be registered. Therefore, you cannot access named variables and constraints via model[:x]. Instead, use variable_by_name or constraint_by_name to access specific variables or constraints.","category":"page"},{"location":"manual/models/#Relax-integrality","page":"Models","title":"Relax integrality","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use relax_integrality to remove any integrality constraints from the model, such as integer and binary restrictions on variables. relax_integrality returns a function that can be later called with zero arguments to re-add the removed constraints:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model();\n\njulia> @variable(model, x, Int)\nx\n\njulia> num_constraints(model, VariableRef, MOI.Integer)\n1\n\njulia> undo = relax_integrality(model);\n\njulia> num_constraints(model, VariableRef, MOI.Integer)\n0\n\njulia> undo()\n\njulia> num_constraints(model, VariableRef, MOI.Integer)\n1","category":"page"},{"location":"manual/models/#Switching-optimizer-for-the-relaxed-problem","page":"Models","title":"Switching optimizer for the relaxed problem","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"A common reason for relaxing integrality is to compute dual variables of the relaxed problem. However, some mixed-integer linear solvers (for example, Cbc) do not return dual solutions, even if the problem does not have integrality restrictions.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Therefore, after relax_integrality you should call set_optimizer with a solver that does support dual solutions, such as Clp.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"For example, instead of:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"using JuMP, Cbc\nmodel = Model(Cbc.Optimizer)\n@variable(model, x, Int)\nundo = relax_integrality(model)\noptimize!(model)\nreduced_cost(x)  # Errors","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"do:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"using JuMP, Cbc, Clp\nmodel = Model(Cbc.Optimizer)\n@variable(model, x, Int)\nundo = relax_integrality(model)\nset_optimizer(model, Clp.Optimizer)\noptimize!(model)\nreduced_cost(x)  # Works","category":"page"},{"location":"manual/models/#Get-the-matrix-representation","page":"Models","title":"Get the matrix representation","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use lp_matrix_data to return a data structure that represents the matrix form of a linear program.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> begin\n           model = Model()\n           @variable(model, x >= 1, Bin)\n           @variable(model, 2 <= y)\n           @variable(model, 3 <= z <= 4, Int)\n           @constraint(model, x == 5)\n           @constraint(model, 2x + 3y <= 6)\n           @constraint(model, -4y >= 5z + 7)\n           @constraint(model, -1 <= x + y <= 2)\n           @objective(model, Max, 1 + 2x)\n       end;\n\njulia> data = lp_matrix_data(model);\n\njulia> data.A\n4×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 7 stored entries:\n 1.0    ⋅     ⋅\n  ⋅   -4.0  -5.0\n 2.0   3.0    ⋅\n 1.0   1.0    ⋅\n\njulia> data.b_lower\n4-element Vector{Float64}:\n   5.0\n   7.0\n -Inf\n  -1.0\n\njulia> data.b_upper\n4-element Vector{Float64}:\n  5.0\n Inf\n  6.0\n  2.0\n\njulia> data.x_lower\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n\njulia> data.x_upper\n3-element Vector{Float64}:\n Inf\n Inf\n  4.0\n\njulia> data.c\n3-element Vector{Float64}:\n 2.0\n 0.0\n 0.0\n\njulia> data.c_offset\n1.0\n\njulia> data.sense\nMAX_SENSE::OptimizationSense = 1\n\njulia> data.integers\n1-element Vector{Int64}:\n 3\n\njulia> data.binaries\n1-element Vector{Int64}:\n 1","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"warning: Warning\nlp_matrix_data is intentionally limited in the types of problems that it supports and the structure of the matrices it outputs. It is mainly intended as a pedagogical and debugging tool. It should not be used to interface solvers, see Implementing a solver interface instead.","category":"page"},{"location":"manual/models/#Backends","page":"Models","title":"Backends","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"info: Info\nThis section discusses advanced features of JuMP. For new users, you may want to skip this section. You don't need to know how JuMP manages problems behind the scenes to create and solve JuMP models.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A JuMP Model is a thin layer around a backend of type MOI.ModelLike that stores the optimization problem and acts as the optimization solver.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"However, if you construct a model like Model(HiGHS.Optimizer), the backend is not a HiGHS.Optimizer, but a more complicated object.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"From JuMP, the MOI backend can be accessed using the backend function. Let's see what the backend of a JuMP Model is:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(HiGHS.Optimizer);\n\njulia> b = backend(model)\nMOIU.CachingOptimizer{MOIB.LazyBridgeOptimizer{HiGHS.Optimizer}, MOIU.UniversalFallback{MOIU.Model{Float64}}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.UniversalFallback{MOIU.Model{Float64}}\n  fallback for MOIU.Model{Float64}\nwith optimizer MOIB.LazyBridgeOptimizer{HiGHS.Optimizer}\n  with 0 variable bridges\n  with 0 constraint bridges\n  with 0 objective bridges\n  with inner model A HiGHS model with 0 columns and 0 rows.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Uh oh. Even though we passed a HiGHS.Optimizer, the backend is a much more complicated object.","category":"page"},{"location":"manual/models/#CachingOptimizer","page":"Models","title":"CachingOptimizer","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"A MOIU.CachingOptimizer is a layer that abstracts the difference between solvers that support incremental modification (for example, they support adding variables one-by-one), and solvers that require the entire problem in a single API call (for example, they only accept the A, b and c matrices of a linear program).","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"It has two parts:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A cache, where the model can be built and modified incrementally\njulia> b.model_cache\nMOIU.UniversalFallback{MOIU.Model{Float64}}\nfallback for MOIU.Model{Float64}\nAn optimizer, which is used to solve the problem\njulia> b.optimizer\nMOIB.LazyBridgeOptimizer{HiGHS.Optimizer}\nwith 0 variable bridges\nwith 0 constraint bridges\nwith 0 objective bridges\nwith inner model A HiGHS model with 0 columns and 0 rows.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"info: Info\nThe LazyBridgeOptimizer section explains what a LazyBridgeOptimizer is.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"The CachingOptimizer has logic to decide when to copy the problem from the cache to the optimizer, and when it can efficiently update the optimizer in-place.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A CachingOptimizer may be in one of three possible states:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"NO_OPTIMIZER: The CachingOptimizer does not have any optimizer.\nEMPTY_OPTIMIZER: The CachingOptimizer has an empty optimizer, and it is not synchronized with the cached model.\nATTACHED_OPTIMIZER: The CachingOptimizer has an optimizer, and it is synchronized with the cached model.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A CachingOptimizer has two modes of operation:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"AUTOMATIC: The CachingOptimizer changes its state when necessary. For example, optimize! will automatically call attach_optimizer (an optimizer must have been previously set). Attempting to add a constraint or perform a modification not supported by the optimizer results in a drop to EMPTY_OPTIMIZER mode.\nMANUAL: The user must change the state of the CachingOptimizer using MOIU.reset_optimizer(::JuMP.Model), MOIU.drop_optimizer(::JuMP.Model), and MOIU.attach_optimizer(::JuMP.Model). Attempting to perform an operation in the incorrect state results in an error.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"By default Model will create a CachingOptimizer in AUTOMATIC mode.","category":"page"},{"location":"manual/models/#LazyBridgeOptimizer","page":"Models","title":"LazyBridgeOptimizer","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"The second layer that JuMP applies automatically is a MOI.Bridges.LazyBridgeOptimizer. A MOI.Bridges.LazyBridgeOptimizer is an MOI layer that attempts to transform the problem from the formulation provided by the user into an equivalent problem supported by the solver. This may involve adding new variables and constraints to the optimizer. The transformations are selected from a set of known recipes called bridges.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A common example of a bridge is one that splits an interval constraint like @constraint(model, 1 <= x + y <= 2) into two constraints, @constraint(model, x + y >= 1) and @constraint(model, x + y <= 2).","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use the add_bridges = false keyword to remove the bridging layer:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(HiGHS.Optimizer; add_bridges = false)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: HiGHS\n\njulia> backend(model)\nMOIU.CachingOptimizer{HiGHS.Optimizer, MOIU.UniversalFallback{MOIU.Model{Float64}}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.UniversalFallback{MOIU.Model{Float64}}\n  fallback for MOIU.Model{Float64}\nwith optimizer A HiGHS model with 0 columns and 0 rows.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Bridges can be added and removed from a MOI.Bridges.LazyBridgeOptimizer using add_bridge and remove_bridge. Use print_active_bridges to see which bridges are used to reformulate the model. Read the Ellipsoid approximation tutorial for more details.","category":"page"},{"location":"manual/models/#Unsafe-backend","page":"Models","title":"Unsafe backend","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"In some advanced use-cases, it is necessary to work with the inner optimization model directly. To access this model, use unsafe_backend:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> backend(model)\nMOIU.CachingOptimizer{MOIB.LazyBridgeOptimizer{HiGHS.Optimizer}, MOIU.UniversalFallback{MOIU.Model{Float64}}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.UniversalFallback{MOIU.Model{Float64}}\n  fallback for MOIU.Model{Float64}\nwith optimizer MOIB.LazyBridgeOptimizer{HiGHS.Optimizer}\n  with 0 variable bridges\n  with 0 constraint bridges\n  with 0 objective bridges\n  with inner model A HiGHS model with 0 columns and 0 rows.\n\njulia> unsafe_backend(model)\nA HiGHS model with 0 columns and 0 rows.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"warning: Warning\nbackend and unsafe_backend are advanced routines. Read their docstrings to understand the caveats of their usage, and only call them if you wish to access low-level solver-specific functions.","category":"page"},{"location":"manual/models/#Direct-mode","page":"Models","title":"Direct mode","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Using a CachingOptimizer results in an additional copy of the model being stored by JuMP in the .model_cache field. To avoid this overhead, create a JuMP model using direct_model:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = direct_model(HiGHS.Optimizer())\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: DIRECT\nSolver name: HiGHS","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"warning: Warning\nSolvers that do not support incremental modification do not support direct_model. An error will be thrown, telling you to use a CachingOptimizer instead.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"The benefit of using direct_model is that there are no extra layers (for example, Cachingoptimizer or LazyBridgeOptimizer) between model and the provided optimizer:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> backend(model)\nA HiGHS model with 0 columns and 0 rows.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A downside of direct mode is that there is no bridging layer. Therefore, only constraints which are natively supported by the solver are supported. For example, HiGHS.jl does not implement quadratic constraints:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = direct_model(HiGHS.Optimizer());\n\njulia> set_silent(model)\n\njulia> @variable(model, x[1:2]);\n\njulia> @constraint(model, x[1]^2 + x[2]^2 <= 2)\nERROR: Constraints of type MathOptInterface.ScalarQuadraticFunction{Float64}-in-MathOptInterface.LessThan{Float64} are not supported by the solver.\n\nIf you expected the solver to support your problem, you may have an error in your formulation. Otherwise, consider using a different solver.\n\nThe list of available solvers, along with the problem types they support, is available at https://jump.dev/JuMP.jl/stable/installation/#Supported-solvers.\nStacktrace:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"warning: Warning\nAnother downside of direct mode is that the behavior of querying solution information after modifying the problem is solver-specific. This can lead to errors, or the solver silently returning an incorrect value. See OptimizeNotCalled errors for more information.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/background/duality.md\"","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/background/duality/#Duality","page":"Duality","title":"Duality","text":"","category":"section"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"Conic duality is the starting point for MOI's duality conventions. When all functions are affine (or coordinate projections), and all constraint sets are closed convex cones, the model may be called a conic optimization problem.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"For a minimization problem in geometric conic form, the primal is:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n min_x in mathbbR^n  a_0^T x + b_0\n\n textst  A_i x + b_i  in mathcalC_i  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"and the dual is a maximization problem in standard conic form:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n max_y_1 ldots y_m  -sum_i=1^m b_i^T y_i + b_0\n\n textst  a_0 - sum_i=1^m A_i^T y_i  = 0\n\n  y_i  in mathcalC_i^*  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"where each mathcalC_i is a closed convex cone and mathcalC_i^* is its dual cone.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"For a maximization problem in geometric conic form, the primal is:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n max_x in mathbbR^n  a_0^T x + b_0\n\n textst  A_i x + b_i  in mathcalC_i  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"and the dual is a minimization problem in standard conic form:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n min_y_1 ldots y_m  sum_i=1^m b_i^T y_i + b_0\n\n textst  a_0 + sum_i=1^m A_i^T y_i  = 0\n\n  y_i  in mathcalC_i^*  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"A linear inequality constraint a^T x + b ge c is equivalent to a^T x + b - c in mathbbR_+, and a^T x + b le c is equivalent to a^T x + b - c in mathbbR_-. Variable-wise constraints are affine constraints with the appropriate identity mapping in place of A_i.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"For the special case of minimization LPs, the MOI primal form can be stated as:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n min_x in mathbbR^n  a_0^T x + b_0\n\n textst\nA_1 x  ge b_1\n A_2 x  le b_2\n A_3 x  = b_3\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"By applying the stated transformations to conic form, taking the dual, and transforming back into linear inequality form, one obtains the following dual:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n max_y_1y_2y_3  b_1^Ty_1 + b_2^Ty_2 + b_3^Ty_3 + b_0\n\n textst\nA_1^Ty_1 + A_2^Ty_2 + A_3^Ty_3  = a_0\n y_1 ge 0\n y_2 le 0\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"For maximization LPs, the MOI primal form can be stated as:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n max_x in mathbbR^n  a_0^T x + b_0\n\n textst\nA_1 x  ge b_1\n A_2 x  le b_2\n A_3 x  = b_3\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"and similarly, the dual is:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n min_y_1y_2y_3  -b_1^Ty_1 - b_2^Ty_2 - b_3^Ty_3 + b_0\n\n textst\nA_1^Ty_1 + A_2^Ty_2 + A_3^Ty_3  = -a_0\n y_1 ge 0\n y_2 le 0\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"warning: Warning\nFor the LP case, the signs of the feasible dual variables depend only on the sense of the corresponding primal inequality and not on the objective sense.","category":"page"},{"location":"moi/background/duality/#Duality-and-scalar-product","page":"Duality","title":"Duality and scalar product","text":"","category":"section"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"The scalar product is different from the canonical one for the sets PositiveSemidefiniteConeTriangle, LogDetConeTriangle, RootDetConeTriangle.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"If the set C_i of the section Duality is one of these three cones, then the rows of the matrix A_i corresponding to off-diagonal entries are twice the value of the coefficients field in the VectorAffineFunction for the corresponding rows. See PositiveSemidefiniteConeTriangle for details.","category":"page"},{"location":"moi/background/duality/#Dual-for-problems-with-quadratic-functions","page":"Duality","title":"Dual for problems with quadratic functions","text":"","category":"section"},{"location":"moi/background/duality/#Quadratic-Programs-(QPs)","page":"Duality","title":"Quadratic Programs (QPs)","text":"","category":"section"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"For quadratic programs with only affine conic constraints,","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign*\n min_x in mathbbR^n  frac12x^TQ_0x + a_0^T x + b_0\n\n textst  A_i x + b_i  in mathcalC_i  i = 1 ldots m\nendalign*","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"with cones mathcalC_i subseteq mathbbR^m_i for i = 1 ldots m, consider the Lagrangian function","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"L(x y) = frac12x^TQ_0x + a_0^T x + b_0 - sum_i = 1^m y_i^T (A_i x + b_i)","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"Let z(y) denote sum_i = 1^m A_i^T y_i - a_0, the Lagrangian can be rewritten as","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"L(x y) = frac12x^TQ_0x - z(y)^T x + b_0 - sum_i = 1^m y_i^T b_i","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"The condition nabla_x L(x y) = 0 gives","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"0 = nabla_x L(x y) = Q_0x + a_0 - sum_i = 1^m y_i^T b_i","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"which gives Q_0x = z(y). This allows to obtain that","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"min_x in mathbbR^n L(x y) = -frac12x^TQ_0x + b_0 - sum_i = 1^m y_i^T b_i","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"so the dual problem is","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"max_y_i in mathcalC_i^* min_x in mathbbR^n -frac12x^TQ_0x + b_0 - sum_i = 1^m y_i^T b_i","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"If Q_0 is invertible, we have x = Q_0^-1z(y) hence","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"min_x in mathbbR^n L(x y) = -frac12z(y)^TQ_0^-1z(y) + b_0 - sum_i = 1^m y_i^T b_i","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"so the dual problem is","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"max_y_i in mathcalC_i^* -frac12z(y)^TQ_0^-1z(y) + b_0 - sum_i = 1^m y_i^T b_i","category":"page"},{"location":"moi/background/duality/#Quadratically-Constrained-Quadratic-Programs-(QCQPs)","page":"Duality","title":"Quadratically Constrained Quadratic Programs (QCQPs)","text":"","category":"section"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"Given a problem with both quadratic function and quadratic objectives:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign*\n min_x in mathbbR^n  frac12x^TQ_0x + a_0^T x + b_0\n\n textst  frac12x^TQ_ix + a_i^T x + b_i  in mathcalC_i  i = 1 ldots m\nendalign*","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"with cones mathcalC_i subseteq mathbbR for i = 1 ldots m, consider the Lagrangian function","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"L(x y) = frac12x^TQ_0x + a_0^T x + b_0 - sum_i = 1^m y_i (frac12x^TQ_ix + a_i^T x + b_i)","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"A pair of primal-dual variables (x^star y^star) is optimal if","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"x^star is a minimizer of\nmin_x in mathbbR^n L(x y^star)\nThat is,\n0 = nabla_x L(x y^star) = Q_0x + a_0 - sum_i = 1^m y_i^star (Q_ix + a_i)\nand y^star is a maximizer of\nmax_y_i in mathcalC_i^* L(x^star y)\nThat is, for all i = 1 ldots m, frac12x^TQ_ix + a_i^T x + b_i is either zero or in the normal cone of mathcalC_i^* at y^star. For instance, if mathcalC_i is  z in mathbbR  z le 0 , this means that if frac12x^TQ_ix + a_i^T x + b_i is nonzero at x^star then y_i^star = 0. This is the classical complementary slackness condition.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"If mathcalC_i is a vector set, the discussion remains valid with y_i(frac12x^TQ_ix + a_i^T x + b_i) replaced with the scalar product between y_i and the vector of scalar-valued quadratic functions.","category":"page"},{"location":"moi/background/duality/#Dual-for-square-semidefinite-matrices","page":"Duality","title":"Dual for square semidefinite matrices","text":"","category":"section"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"The set PositiveSemidefiniteConeTriangle is a self-dual. That is, querying ConstraintDual of a PositiveSemidefiniteConeTriangle constraint returns a vector that is itself a member of PositiveSemidefiniteConeTriangle.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"However, the dual of PositiveSemidefiniteConeSquare is not so straight forward. This section explains the duality convention we use, and how it is derived.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"info: Info\nIf you have a PositiveSemidefiniteConeSquare constraint, the result matrix A from ConstraintDual is not positive semidefinite. However, A + A^top is positive semidefinite.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"Let mathcalS_+ be the cone of symmetric semidefinite matrices in the fracn(n+1)2 dimensional space of symmetric mathbbR^n times n matrices. That is, mathcalS_+ is the set PositiveSemidefiniteConeTriangle. It is well known that mathcalS_+ is a self-dual proper cone.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"Let mathcalP_+ be the cone of symmetric semidefinite matrices in the n^2 dimensional space of mathbbR^n times n matrices. That is mathcalP_+ is the set PositiveSemidefiniteConeSquare.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"In addition, let mathcalD_+ be the cone of matrices A such that A+A^top in mathcalP_+.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"mathcalP_+ is not proper because it is not solid (it is not n^2 dimensional), so it is not necessarily true that mathcalP_+^** = mathcalP_+.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"However, this is the case, because we will show that mathcalP_+^* = mathcalD_+ and mathcalD_+^* = mathcalP_+.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"First, let us see why mathcalP_+^* = mathcalD_+.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"If B is symmetric, then","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"langle AB rangle = langle A^top B^top rangle = langle A^top Brangle","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"so","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"2langle A B rangle = langle A B rangle + langle A^top B rangle = langle A + A^top  B rangle","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"Therefore, langle ABrangle ge 0 for all B in mathcalP_+ if and only if langle A+A^topBrangle ge 0 for all B in mathcalP_+. Since A+A^top is symmetric, and we know that mathcalS_+ is self-dual, we have shown that mathcalP_+^* is the set of matrices A such that A+A^top in mathcalP_+.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"Second, let us see why mathcalD_+^* = mathcalP_+.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"Since A in mathcalD_+ implies that A^top in mathcalD_+, B in mathcalD_+^* means that langle A+A^topBrangle ge 0 for all A in mathcalD_+, and hence B in mathcalP_+.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"To see why it should be symmetric, simply notice that if B_ij  B_ji, then langle ABrangle can be made arbitrarily small by setting A_ij = A_ij + s and A_ji = A_ji - s, with s arbitrarily large, and A stays in mathcalD_+ because A+A^top does not change.","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"Typically, the primal/dual pair for semidefinite programs is presented as:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n       min  langle C X rangle \ntextst   langle A_k Xrangle = b_k forall k \n             X                     in mathcalS_+\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"with the dual","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n       max  sum_k b_k y_k \ntextst   C - sum A_k y_k in mathcalS_+\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"If we allow A_k to be non-symmetric, we should instead use:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n       min  langle C X rangle \ntextst   langle A_k Xrangle = b_k forall k \n             X                     in mathcalD_+\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"with the dual","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n       max  sum b_k y_k \ntextst   C - sum A_k y_k in mathcalP_+\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"This is implemented as:","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n       min  langle C   Z rangle + langle C - C^top S rangle \ntextst   langle A_k Z rangle + langle A_k - A_k^top S rangle = b_k forall k \n             Z in mathcalS_+\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"with the dual","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"beginalign\n       max  sum b_k y_k \ntextst   C+C^top - sum (A_k+A_k^top) y_k in mathcalS_+ \n             C-C^top - sum(A_k-A_k^top) y_k = 0\nendalign","category":"page"},{"location":"moi/background/duality/","page":"Duality","title":"Duality","text":"and we recover Z = X + X^top.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"EditURL = \"tips_and_tricks.jl\"","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#conic_tips_and_tricks","page":"Tips and Tricks","title":"Tips and Tricks","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"This tutorial was originally contributed by Arpit Bhatia.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"This tutorial is aimed at providing a simplistic introduction to conic programming using JuMP.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"It uses the following packages:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"using JuMP\nimport SCS\nimport LinearAlgebra","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"info: Info\nThis tutorial uses sets from MathOptInterface. By default, JuMP exports the MOI symbol as an alias for the MathOptInterface.jl package. We recommend making this more explicit in your code by adding the following lines:import MathOptInterface as MOI","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"import Random      # hide\nRandom.seed!(1234) # hide\nnothing            # hide","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"tip: Tip\nA good resource for learning more about functions which can be modeled using cones is the MOSEK Modeling Cookbook.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Background-theory","page":"Tips and Tricks","title":"Background theory","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A subset C of a vector space V is a cone if forall x in C and positive scalars lambda  0, the product lambda x in C.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A cone C is a convex cone if lambda x + (1 - lambda) y in C, for any lambda in 0 1, and any x y in C.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Conic programming problems are convex optimization problems in which a convex function is minimized over the intersection of an affine subspace and a convex cone. An example of a conic-form minimization problems, in the primal form is:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\n min_x in mathbbR^n  a_0^T x + b_0 \n textst  A_i x + b_i  in mathcalC_i  i = 1 ldots m\nendaligned","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The corresponding dual problem is:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\n max_y_1 ldots y_m  -sum_i=1^m b_i^T y_i + b_0 \n textst  a_0 - sum_i=1^m A_i^T y_i  = 0 \n  y_i  in mathcalC_i^*  i = 1 ldots m\nendaligned","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"where each mathcalC_i is a closed convex cone and mathcalC_i^* is its dual cone.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Second-Order-Cone","page":"Tips and Tricks","title":"Second-Order Cone","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The SecondOrderCone (or Lorentz Cone) of dimension n is a cone of the form:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"K_soc =  (t x) in mathbbR^n  t ge x_2 ","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"It is most commonly used to represent the L2-norm of the vector x:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"model = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, x[1:3])\n@variable(model, t)\n@constraint(model, sum(x) == 1)\n@constraint(model, [t; x] in SecondOrderCone())\n@objective(model, Min, t)\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue(t), value.(x)","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Rotated-Second-Order-Cone","page":"Tips and Tricks","title":"Rotated Second-Order Cone","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A Second-Order Cone rotated by pi4 in the (x_1x_2) plane is called a RotatedSecondOrderCone. It is a cone of the form:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"K_rsoc =  (tux) in mathbbR^n  2tu ge x_2^2 tu ge 0 ","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"When u = 0.5, it represents the sum of squares of a vector x:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"data = [1.0, 2.0, 3.0, 4.0]\ntarget = [0.45, 1.04, 1.51, 1.97]\nmodel = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, θ)\n@variable(model, t)\n@expression(model, residuals, θ * data .- target)\n@constraint(model, [t; 0.5; residuals] in RotatedSecondOrderCone())\n@objective(model, Min, t)\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue(θ), value(t)","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Exponential-Cone","page":"Tips and Tricks","title":"Exponential Cone","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The MOI.ExponentialCone is a set of the form:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"K_exp =  (xyz) in mathbbR^3  y exp (xy) le z y  0 ","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"It can be used to model problems involving log and exp.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Exponential","page":"Tips and Tricks","title":"Exponential","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"To model exp(x) le z, use (x, 1, z):","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"model = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, x == 1.5)\n@variable(model, z)\n@objective(model, Min, z)\n@constraint(model, [x, 1, z] in MOI.ExponentialCone())\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue(z), exp(1.5)","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Logarithm","page":"Tips and Tricks","title":"Logarithm","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"To model x le log(z), use (x, 1, z):","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"model = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, x)\n@variable(model, z == 1.5)\n@objective(model, Max, x)\n@constraint(model, [x, 1, z] in MOI.ExponentialCone())\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue(x), log(1.5)","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Log-sum-exp","page":"Tips and Tricks","title":"Log-sum-exp","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"To model t ge logleft(sum e^x_iright), use:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"N = 3\nx0 = rand(N)\nmodel = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, x[i = 1:N] == x0[i])\n@variable(model, t)\n@objective(model, Min, t)\n@variable(model, u[1:N])\n@constraint(model, sum(u) <= 1)\n@constraint(model, [i = 1:N], [x[i] - t, 1, u[i]] in MOI.ExponentialCone())\noptimize!(model)\nvalue(t), log(sum(exp.(x0)))","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Entropy","page":"Tips and Tricks","title":"Entropy","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The entropy maximization problem consists of maximizing the entropy function, H(x) = -xlogx subject to linear inequality constraints.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\n max  - sum_i=1^n x_i log x_i \n textst  mathbf1^top x = 1 \n  Ax leq b\nendaligned","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"We can model this problem using an exponential cone by using the following transformation:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"tleq -xlogx iff tleq xlog(1x)  iff (t x 1) in K_exp","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Thus, our problem becomes,","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\n max  1^Tt \n textst  Ax leq b \n  1^T x = 1 \n  (t_i x_i 1) in K_exp  forall i = 1 ldots n \nendaligned","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"m, n = 10, 15\nA, b = randn(m, n), rand(m, 1)\nmodel = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, t[1:n])\n@variable(model, x[1:n])\n@objective(model, Max, sum(t))\n@constraint(model, sum(x) == 1)\n@constraint(model, A * x .<= b)\n@constraint(model, [i = 1:n], [t[i], x[i], 1] in MOI.ExponentialCone())\noptimize!(model)\n@assert is_solved_and_feasible(model)\nobjective_value(model)","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The MOI.ExponentialCone has a dual, the MOI.DualExponentialCone, that offers an alternative formulation that can be more efficient for some formulations.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"There is also the MOI.RelativeEntropyCone for explicitly encoding the relative entropy function","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"model = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, t)\n@variable(model, x[1:n])\n@objective(model, Max, -t)\n@constraint(model, sum(x) == 1)\n@constraint(model, A * x .<= b)\n@constraint(model, [t; ones(n); x] in MOI.RelativeEntropyCone(2n + 1))\noptimize!(model)\n@assert is_solved_and_feasible(model)\nobjective_value(model)","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#PowerCone","page":"Tips and Tricks","title":"PowerCone","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The MOI.PowerCone is a three-dimensional set parameterized by a scalar value α. It has the form:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"K_p =  (xyz) in mathbbR^3  x^alpha y^1-alpha ge z x ge 0 y ge 0 ","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The power cone permits a number of reformulations. For example, when p  1, we can model t ge x^p using the power cone (t 1 x) with alpha = 1  p. Thus, to model t ge x^3 with x ge 0","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"model = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, t)\n@variable(model, x >= 1.5)\n@constraint(model, [t, 1, x] in MOI.PowerCone(1 / 3))\n@objective(model, Min, t)\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue(t), value(x)","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The MOI.PowerCone has a dual, the MOI.DualPowerCone, that offers an alternative formulation that can be more efficient for some formulations.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#P-Norm","page":"Tips and Tricks","title":"P-Norm","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The p-norm x_p = left(sumlimits_i x_i^pright)^frac1p can be modeled using MOI.PowerCones. See the Mosek Modeling Cookbook for the derivation.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"function p_norm(x::Vector, p)\n    N = length(x)\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, r[1:N])\n    @variable(model, t)\n    @constraint(model, [i = 1:N], [r[i], t, x[i]] in MOI.PowerCone(1 / p))\n    @constraint(model, sum(r) == t)\n    @objective(model, Min, t)\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    return value(t)\nend\n\nx = rand(5);\nLinearAlgebra.norm(x, 4), p_norm(x, 4)","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Positive-Semidefinite-Cone","page":"Tips and Tricks","title":"Positive Semidefinite Cone","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The set of positive semidefinite matrices (PSD) of dimension n form a cone in mathbbR^n. We write this set mathematically as:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"mathcalS_+^n =  X in mathcalS^n mid z^T X z geq 0  forall zin mathbbR^n ","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A PSD cone is represented in JuMP using the MOI sets PositiveSemidefiniteConeTriangle (for upper triangle of a PSD matrix) and PositiveSemidefiniteConeSquare (for a complete PSD matrix). However, it is preferable to use the PSDCone shortcut as illustrated below.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Example:-largest-eigenvalue-of-a-symmetric-matrix","page":"Tips and Tricks","title":"Example: largest eigenvalue of a symmetric matrix","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Suppose A has eigenvalues lambda_1 geq lambda_2 ldots geq lambda_n. Then the matrix t I-A has eigenvalues t-lambda_1 t-lambda_2 ldots t-lambda_n. Note that t I-A is PSD exactly when all these eigenvalues are non-negative, and this happens for values t geq lambda_1. Thus, we can model the problem of finding the largest eigenvalue of a symmetric matrix as:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\nlambda_1 = min t \ntext  st  t I-A succeq 0\nendaligned","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A = [3 2 4; 2 0 2; 4 2 3]\nI = Matrix{Float64}(LinearAlgebra.I, 3, 3)\nmodel = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, t)\n@objective(model, Min, t)\n@constraint(model, t .* I - A in PSDCone())\noptimize!(model)\n@assert is_solved_and_feasible(model)\nobjective_value(model)","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#GeometricMeanCone","page":"Tips and Tricks","title":"GeometricMeanCone","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The MOI.GeometricMeanCone is a cone of the form:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"K_geo =  (t x) in mathbbR^n  x ge 0 t le sqrtn-1x_1 x_2 cdots x_n-1 ","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"model = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, x[1:4])\n@variable(model, t)\n@constraint(model, sum(x) == 1)\n@constraint(model, [t; x] in MOI.GeometricMeanCone(5))\noptimize!(model)\nvalue(t), value.(x)","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#RootDetCone","page":"Tips and Tricks","title":"RootDetCone","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The MOI.RootDetConeSquare is a cone of the form:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"K =  (t X) in mathbbR^1+d^2  t le det(X)^frac1d ","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"model = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, t)\n@variable(model, X[1:2, 1:2])\n@objective(model, Max, t)\n@constraint(model, [t; vec(X)] in MOI.RootDetConeSquare(2))\n@constraint(model, X .== [2 1; 1 3])\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue(t), sqrt(LinearAlgebra.det(value.(X)))","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"If X is symmetric, then you can use MOI.RootDetConeTriangle instead. This can be more efficient because the solver does not need to add additional constraints to ensure X is symmetric.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"When forming the function, use triangle_vec to obtain the column-wise upper triangle of the matrix as a vector in the order that JuMP requires.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"model = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, t)\n@variable(model, X[1:2, 1:2], Symmetric)\n@objective(model, Max, t)\n@constraint(model, [t; triangle_vec(X)] in MOI.RootDetConeTriangle(2))\n@constraint(model, X .== [2 1; 1 3])\noptimize!(model)\nvalue(t), sqrt(LinearAlgebra.det(value.(X)))","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#LogDetCone","page":"Tips and Tricks","title":"LogDetCone","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The MOI.LogDetConeSquare is a cone of the form:","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"K =  (t u X) in mathbbR^2+d^2  t le u log(det(X  u)) ","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"model = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, t)\n@variable(model, u)\n@variable(model, X[1:2, 1:2])\n@objective(model, Max, t)\n@constraint(model, [t; u; vec(X)] in MOI.LogDetConeSquare(2))\n@constraint(model, X .== [2 1; 1 3])\n@constraint(model, u == 0.5)\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue(t), 0.5 * log(LinearAlgebra.det(value.(X) ./ 0.5))","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"If X is symmetric, then you can use MOI.LogDetConeTriangle instead. This can be more efficient because the solver does not need to add additional constraints to ensure X is symmetric.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"When forming the function, use triangle_vec to obtain the column-wise upper triangle of the matrix as a vector in the order that JuMP requires.","category":"page"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"model = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, t)\n@variable(model, u)\n@variable(model, X[1:2, 1:2], Symmetric)\n@objective(model, Max, t)\n@constraint(model, [t; u; triangle_vec(X)] in MOI.LogDetConeTriangle(2))\n@constraint(model, X .== [2 1; 1 3])\n@constraint(model, u == 0.5)\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue(t), 0.5 * log(LinearAlgebra.det(value.(X) ./ 0.5))","category":"page"},{"location":"tutorials/conic/tips_and_tricks/#Other-Cones-and-Functions","page":"Tips and Tricks","title":"Other Cones and Functions","text":"","category":"section"},{"location":"tutorials/conic/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"For other cones supported by JuMP, check out the MathOptInterface Manual.","category":"page"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"EditURL = \"https://github.com/jump-dev/BARON.jl/blob/v0.8.3/README.md\"","category":"page"},{"location":"packages/BARON/#BARON.jl","page":"jump-dev/BARON.jl","title":"BARON.jl","text":"","category":"section"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"BARON.jl is a wrapper for BARON by The Optimization Firm.","category":"page"},{"location":"packages/BARON/#Affiliation","page":"jump-dev/BARON.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"This wrapper is maintained by the JuMP community and is not officially supported by The Optimization Firm.","category":"page"},{"location":"packages/BARON/#License","page":"jump-dev/BARON.jl","title":"License","text":"","category":"section"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"BARON.jl is licensed under the MIT License.","category":"page"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"The underlying solver is a closed-source commercial product for which you must obtain a license from The Optimization Firm, although a small trial version is available for free.","category":"page"},{"location":"packages/BARON/#Installation","page":"jump-dev/BARON.jl","title":"Installation","text":"","category":"section"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"First, download a copy of the BARON solver and unpack the executable in a location of your choosing.","category":"page"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"Once installed, set the BARON_EXEC environment variable pointing to the BARON executable (full path, including file name as it differs across platforms), and run Pkg.add(\"BARON\"). For example:","category":"page"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"ENV[\"BARON_EXEC\"] = \"/path/to/baron.exe\"\nusing Pkg\nPkg.add(\"BARON\")","category":"page"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"The baronlice.txt license file should be placed in the same directory as the BARON executable, or in your current working directory.","category":"page"},{"location":"packages/BARON/#Use-with-JuMP","page":"jump-dev/BARON.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"using JuMP, BARON\nmodel = Model(BARON.Optimizer)","category":"page"},{"location":"packages/BARON/#MathOptInterface-API","page":"jump-dev/BARON.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"The BARON optimizer supports the following constraints and attributes.","category":"page"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"List of supported objective functions:","category":"page"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}\nMOI.ObjectiveFunction{MOI.ScalarQuadraticFunction{Float64}}\nMOI.ObjectiveFunction{MOI.ScalarNonlinearFunction}","category":"page"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"MOI.Reals","category":"page"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"MOI.ScalarAffineFunction{Float64} in MOI.EqualTo{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.Interval{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.LessThan{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.EqualTo{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.Interval{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.LessThan{Float64}\nMOI.ScalarNonlinearFunction in MOI.EqualTo{Float64}\nMOI.ScalarNonlinearFunction in MOI.GreaterThan{Float64}\nMOI.ScalarNonlinearFunction in MOI.Interval{Float64}\nMOI.ScalarNonlinearFunction in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.EqualTo{Float64}\nMOI.VariableIndex in MOI.GreaterThan{Float64}\nMOI.VariableIndex in MOI.Integer\nMOI.VariableIndex in MOI.Interval{Float64}\nMOI.VariableIndex in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.ZeroOne","category":"page"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/BARON/","page":"jump-dev/BARON.jl","title":"jump-dev/BARON.jl","text":"MOI.NLPBlock()\nMOI.ObjectiveSense()","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"EditURL = \"getting_started_with_julia.jl\"","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Getting-started-with-Julia","page":"Getting started with Julia","title":"Getting started with Julia","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Because JuMP is embedded in Julia, knowing some basic Julia is important before you start learning JuMP.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nThis tutorial is designed to provide a minimalist crash course in the basics of Julia. You can find resources that provide a more comprehensive introduction to Julia here.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Installing-Julia","page":"Getting started with Julia","title":"Installing Julia","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"To install Julia, download the latest stable release, then follow the platform specific install instructions.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nUnless you know otherwise, you probably want the 64-bit version.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Next, you need an IDE to develop in. VS Code is a popular choice, so follow these install instructions.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Julia can also be used with Jupyter notebooks or the reactive notebooks of Pluto.jl.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#The-Julia-REPL","page":"Getting started with Julia","title":"The Julia REPL","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The main way of interacting with Julia is via its REPL (Read Evaluate Print Loop). To access the REPL, start the Julia executable to arrive at the julia> prompt, and then start coding:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"1 + 1","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"As your programs become larger, write a script as a text file, and then run that file using:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"julia> include(\"path/to/file.jl\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"warning: Warning\nBecause of Julia's startup latency, running scripts from the command line like the following is slow:$ julia path/to/file.jlUse the REPL or a notebook instead, and read The \"time-to-first-solve\" issue for more information.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Code-blocks-in-this-documentation","page":"Getting started with Julia","title":"Code blocks in this documentation","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"In this documentation you'll see a mix of code examples with and without the julia>.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The Julia prompt is mostly used to demonstrate short code snippets, and the output is exactly what you will see if run from the REPL.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Blocks without the julia> can be copy-pasted into the REPL, but they are used because they enable richer output like plots or LaTeX to be displayed in the online and PDF versions of the documentation. If you run them from the REPL you may see different output.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Where-to-get-help","page":"Getting started with Julia","title":"Where to get help","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Read the documentation\nJuMP https://jump.dev/JuMP.jl/stable/\nJulia https://docs.julialang.org/en/v1/\nAsk (or browse) the Julia community forum: https://discourse.julialang.org\nIf the question is JuMP-related, ask in the Optimization (Mathematical) section, or tag your question with \"jump\"","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"To access the built-in help at the REPL, type ? to enter help-mode, followed by the name of the function to lookup:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"help?> print\nsearch: print println printstyled sprint isprint prevind parentindices precision escape_string\n\n  print([io::IO], xs...)\n\n  Write to io (or to the default output stream stdout if io is not given) a canonical\n  (un-decorated) text representation. The representation used by print includes minimal formatting\n  and tries to avoid Julia-specific details.\n\n  print falls back to calling show, so most types should just define show. Define print if your\n  type has a separate \"plain\" representation. For example, show displays strings with quotes, and\n  print displays strings without quotes.\n\n  string returns the output of print as a string.\n\n  Examples\n  ≡≡≡≡≡≡≡≡≡≡\n\n  julia> print(\"Hello World!\")\n  Hello World!\n  julia> io = IOBuffer();\n\n  julia> print(io, \"Hello\", ' ', :World!)\n\n  julia> String(take!(io))\n  \"Hello World!\"","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Numbers-and-arithmetic","page":"Getting started with Julia","title":"Numbers and arithmetic","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Since we want to solve optimization problems, we're going to be using a lot of math. Luckily, Julia is great for math, with all the usual operators:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"1 + 1\n1 - 2\n2 * 2\n4 / 5\n3^2","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Did you notice how Julia didn't print .0 after some of the numbers? Julia is a dynamic language, which means you never have to explicitly declare the type of a variable. However, in the background, Julia is giving each variable a type. Check the type of something using the typeof function:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(1)\ntypeof(1.0)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Here 1 is an Int64, which is an integer with 64 bits of precision, and 1.0 is a Float64, which is a floating point number with 64-bits of precision.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nIf you aren't familiar with floating point numbers, make sure to read the Floating point numbers section.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"We create complex numbers using im:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"x = 2 + 1im\nreal(x)\nimag(x)\ntypeof(x)\nx * (1 - 2im)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nThe curly brackets surround what we call the parameters of a type. You can read Complex{Int64}  as \"a complex number, where the real and imaginary parts are represented by Int64.\" If we call typeof(1.0 + 2.0im) it will be Complex{Float64}, which a complex number with the parts represented by Float64.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"There are also some cool things like an irrational representation of π.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"π","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nTo make π (and most other Greek letters), type \\pi and then press [TAB].","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(π)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"However, if we do math with irrational numbers, they get converted to Float64:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(2π / 3)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Floating-point-numbers","page":"Getting started with Julia","title":"Floating point numbers","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"warning: Warning\nIf you aren't familiar with floating point numbers, make sure to read this section carefully.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A Float64 is a floating point approximation of a real number using 64-bits of information.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Because it is an approximation, things we know hold true in mathematics don't hold true in a computer. For example:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"0.1 * 3 == 0.3","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A more complicated example is:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"sin(2π / 3) == √3 / 2","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nGet √ by typing \\sqrt then press [TAB].","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Let's see what the differences are:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"0.1 * 3 - 0.3\nsin(2π / 3) - √3 / 2","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"They are small, but not zero.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"One way of explaining this difference is to consider how we would write 1 / 3 and 2 / 3 using only four digits after the decimal point. We would write 1 / 3 as 0.3333, and 2 / 3 as 0.6667. So, despite the fact that 2 * (1 / 3) == 2 / 3, 2 * 0.3333 == 0.6666 != 0.6667.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Let's try that again using ≈ (\\approx + [TAB]) instead of ==:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"0.1 * 3 ≈ 0.3\nsin(2π / 3) ≈ √3 / 2","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"≈ is a clever way of calling the isapprox function:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"isapprox(sin(2π / 3), √3 / 2; atol = 1e-8)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"warning: Warning\nFloating point is the reason solvers use tolerances when they solve optimization models. A common mistake you're likely to make is checking whether a binary variable is 0 using value(z) == 0. Always remember to use something like isapprox when comparing floating point numbers.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Note that isapprox will always return false if one of the number being compared is 0 and atol is zero (its default value).","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"1e-300 ≈ 0.0","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"so always set a nonzero value of atol if one of the arguments can be zero.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"isapprox(1e-9, 0.0; atol = 1e-8)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nGurobi has a good series of articles on the implications of floating point in optimization if you want to read more.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"If you aren't careful, floating point arithmetic can throw up all manner of issues. For example:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"1 + 1e-16 == 1","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"It even turns out that floating point numbers aren't associative:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"(1 + 1e-16) - 1e-16 == 1 + (1e-16 - 1e-16)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"It's important to note that this issue isn't Julia-specific. It happens in every programming language (try it out in Python).","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Vectors,-matrices,-and-arrays","page":"Getting started with Julia","title":"Vectors, matrices, and arrays","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Similar to MATLAB, Julia has native support for vectors, matrices and tensors; all of which are represented by arrays of different dimensions. Vectors are constructed by comma-separated elements surrounded by square brackets:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"b = [5, 6]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Matrices can be constructed with spaces separating the columns, and semicolons separating the rows:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A = [1.0 2.0; 3.0 4.0]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"We can do linear algebra:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"x = A \\ b","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nHere is floating point at work again; x is approximately [-4, 4.5].","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A * x\nA * x ≈ b","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Note that when multiplying vectors and matrices, dimensions matter. For example, you can't multiply a vector by a vector:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"try                         #hide\n    b * b\ncatch err                   #hide\n    showerror(stderr, err)  #hide\nend                         #hide","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"But multiplying transposes works:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"b' * b\nb * b'","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Other-common-types","page":"Getting started with Julia","title":"Other common types","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/#Comments","page":"Getting started with Julia","title":"Comments","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Although not technically a type, code comments begin with the # character:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"1 + 1  # This is a comment","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Multiline comments begin with #= and end with =#:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"#=\nHere is a\nmultiline comment\n=#","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Comments can even be nested inside expressions. This is sometimes helpful when documenting inputs to functions:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"isapprox(\n    sin(π),\n    0.0;\n    #= We need an explicit atol here because we are comparing with 0 =#\n    atol = 0.001,\n)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Strings","page":"Getting started with Julia","title":"Strings","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Double quotes are used for strings:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(\"This is Julia\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Unicode is fine in strings:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(\"π is about 3.1415\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Use println to print a string:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"println(\"Hello, World!\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Use $() to interpolate values into a string:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"x = 123\nprintln(\"The value of x is: $(x)\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Use triple-quotes for multiline strings:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"s = \"\"\"\nHere is\na\nmultiline string\n\"\"\"\n\nprintln(s)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Symbols","page":"Getting started with Julia","title":"Symbols","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Julia Symbols are a data structure from the compiler that represent Julia identifiers (that is, variable names).","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"println(\"The value of x is: $(eval(:x))\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"warning: Warning\nWe used eval here to demonstrate how Julia links Symbols to variables. However, avoid calling eval in your code. It is usually a sign that your code is doing something that could be more easily achieved a different way. The Community Forum is a good place to ask for advice on alternative approaches.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(:x)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"You can think of a Symbol as a String that takes up less memory, and that can't be modified.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Convert between String and Symbol using their constructors:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"String(:abc)\nSymbol(\"abc\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nSymbols are often (ab)used to stand in for a String or an Enum, when one of the latter is likely a better choice. The JuMP Style guide recommends reserving Symbols for identifiers. See @enum vs. Symbol for more.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Tuples","page":"Getting started with Julia","title":"Tuples","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Julia makes extensive use of a simple data structure called Tuples. Tuples are immutable collections of values. For example:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"t = (\"hello\", 1.2, :foo)\ntypeof(t)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Tuples can be accessed by index, similar to arrays:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"t[2]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"And they can be \"unpacked\" like so:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"a, b, c = t\nb","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The values can also be given names, which is a convenient way of making light-weight data structures.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"t = (word = \"hello\", num = 1.2, sym = :foo)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Values can be accessed using dot syntax:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"t.word","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Dictionaries","page":"Getting started with Julia","title":"Dictionaries","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Similar to Python, Julia has native support for dictionaries. Dictionaries provide a very generic way of mapping keys to values.  For example, a map of integers to strings:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d1 = Dict(1 => \"A\", 2 => \"B\", 4 => \"D\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nType-stuff again: Dict{Int64,String} is a dictionary with Int64 keys and String values.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Looking up a value uses the bracket syntax:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d1[2]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dictionaries support non-integer keys and can mix data types:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dict(\"A\" => 1, \"B\" => 2.5, \"D\" => 2 - 3im)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nJulia types form a hierarchy. Here the value type of the dictionary is Number, which is a generalization of Int64, Float64, and Complex{Int}. Leaf nodes in this hierarchy are called \"concrete\" types, and all others are called \"Abstract.\" In general, having variables with abstract types like Number can lead to slower code, so you should try to make sure every element in a dictionary or vector is the same type. For example, in this case we could represent every element as a Complex{Float64}:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dict(\"A\" => 1.0 + 0.0im, \"B\" => 2.5 + 0.0im, \"D\" => 2.0 - 3.0im)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dictionaries can be nested:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d2 = Dict(\"A\" => 1, \"B\" => 2, \"D\" => Dict(:foo => 3, :bar => 4))\nd2[\"B\"]\nd2[\"D\"][:foo]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Structs","page":"Getting started with Julia","title":"Structs","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"You can define custom datastructures with struct:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"struct MyStruct\n    x::Int\n    y::String\n    z::Dict{Int,Int}\nend\n\na = MyStruct(1, \"a\", Dict(2 => 3))\na.x","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"By default, these are not mutable","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"try                         #hide\n    a.x = 2\ncatch err                   #hide\n    showerror(stderr, err)  #hide\nend                         #hide","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"However, you can declare a mutable struct which is mutable:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"mutable struct MyStructMutable\n    x::Int\n    y::String\n    z::Dict{Int,Int}\nend\n\na = MyStructMutable(1, \"a\", Dict(2 => 3))\na.x\na.x = 2\na","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Loops","page":"Getting started with Julia","title":"Loops","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Julia has native support for for-each style loops with the syntax for <value> in <collection> end:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"for i in 1:5\n    println(i)\nend","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nRanges are constructed as start:stop, or start:step:stop.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"for i in 1.2:1.1:5.6\n    println(i)\nend","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"This for-each loop also works with dictionaries:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"for (key, value) in Dict(\"A\" => 1, \"B\" => 2.5, \"D\" => 2 - 3im)\n    println(\"$(key): $(value)\")\nend","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Note that in contrast to vector languages like MATLAB and R, loops do not result in a significant performance degradation in Julia.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Control-flow","page":"Getting started with Julia","title":"Control flow","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Julia control flow is similar to MATLAB, using the keywords if-elseif-else-end, and the logical operators || and && for or and and respectively:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"for i in 0:5:15\n    if i < 5\n        println(\"$(i) is less than 5\")\n    elseif i < 10\n        println(\"$(i) is less than 10\")\n    else\n        if i == 10\n            println(\"the value is 10\")\n        else\n            println(\"$(i) is bigger than 10\")\n        end\n    end\nend","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Comprehensions","page":"Getting started with Julia","title":"Comprehensions","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Similar to languages like Haskell and Python, Julia supports the use of simple loops in the construction of arrays and dictionaries, called comprehensions.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A list of increasing integers:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"[i for i in 1:5]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Matrices can be built by including multiple indices:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"[i * j for i in 1:5, j in 5:10]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Conditional statements can be used to filter out some values:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"[i for i in 1:10 if i % 2 == 1]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A similar syntax can be used for building dictionaries:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dict(\"$(i)\" => i for i in 1:10 if i % 2 == 1)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Functions","page":"Getting started with Julia","title":"Functions","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A simple function is defined as follows:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function print_hello()\n    return println(\"hello\")\nend\nprint_hello()","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Arguments can be added to a function:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function print_it(x)\n    return println(x)\nend\nprint_it(\"hello\")\nprint_it(1.234)\nprint_it(:my_id)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Optional keyword arguments are also possible:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function print_it(x; prefix = \"value:\")\n    return println(\"$(prefix) $(x)\")\nend\nprint_it(1.234)\nprint_it(1.234; prefix = \"val:\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The keyword return is used to specify the return values of a function:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function mult(x; y = 2.0)\n    return x * y\nend\n\nmult(4.0)\nmult(4.0; y = 5.0)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Anonymous-functions","page":"Getting started with Julia","title":"Anonymous functions","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The syntax input -> output creates an anonymous function. These are most useful when passed to other functions. For example:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"f = x -> x^2\nf(2)\nmap(x -> x^2, 1:4)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Type-parameters","page":"Getting started with Julia","title":"Type parameters","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"We can constrain the inputs to a function using type parameters, which are :: followed by the type of the input we want. For example:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function foo(x::Int)\n    return x^2\nend\n\nfunction foo(x::Float64)\n    return exp(x)\nend\n\nfunction foo(x::Number)\n    return x + 1\nend\n\nfoo(2)\nfoo(2.0)\nfoo(1 + 1im)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"But what happens if we call foo with something we haven't defined it for?","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"try                         #hide\n    foo([1, 2, 3])\ncatch err                   #hide\n    showerror(stderr, err)  #hide\nend                         #hide","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A MethodError means that you passed a function something that didn't match the type that it was expecting. In this case, the error message says that it doesn't know how to handle an Vector{Int64}, but it does know how to handle Float64, Int64, and Number.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nRead the \"Closest candidates\" part of the error message carefully to get a hint as to what was expected.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Broadcasting","page":"Getting started with Julia","title":"Broadcasting","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"In the example above, we didn't define what to do if f was passed a Vector. Luckily, Julia provides a convenient syntax for mapping f element-wise over arrays. Just add a . between the name of the function and the opening (. This works for any function, including functions with multiple arguments. For example:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"foo.([1, 2, 3])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nGet a MethodError when calling a function that takes a Vector, Matrix, or Array? Try broadcasting.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Mutable-vs-immutable-objects","page":"Getting started with Julia","title":"Mutable vs immutable objects","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Some types in Julia are mutable, which means you can change the values inside them. A good example is an array. You can modify the contents of an array without having to make a new array.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"In contrast, types like Float64 are immutable. You cannot modify the contents of a Float64.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"This is something to be aware of when passing types into functions. For example:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function mutability_example(mutable_type::Vector{Int}, immutable_type::Int)\n    mutable_type[1] += 1\n    immutable_type += 1\n    return\nend\n\nmutable_type = [1, 2, 3]\nimmutable_type = 1\n\nmutability_example(mutable_type, immutable_type)\n\nprintln(\"mutable_type: $(mutable_type)\")\nprintln(\"immutable_type: $(immutable_type)\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Because Vector{Int} is a mutable type, modifying the variable inside the function changed the value outside of the function. In contrast, the change to immutable_type didn't modify the value outside the function.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"You can check mutability with the isimmutable function:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"isimmutable([1, 2, 3])\nisimmutable(1)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#The-package-manager","page":"Getting started with Julia","title":"The package manager","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/#Installing-packages","page":"Getting started with Julia","title":"Installing packages","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"No matter how wonderful Julia's base language is, at some point you will want to use an extension package.  Some of these are built-in, for example random number generation is available in the Random package in the standard library. These packages are loaded with the commands using and import.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"using Random  # The equivalent of Python's `from Random import *`\nimport Random  # The equivalent of Python's `import Random`\n\nRandom.seed!(33)\n\n[rand() for i in 1:10]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The Package Manager is used to install packages that are not part of Julia's standard library.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"For example the following can be used to install JuMP,","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"using Pkg\nPkg.add(\"JuMP\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"For a complete list of registered Julia packages see the package listing at JuliaHub.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"From time to you may wish to use a Julia package that is not registered.  In this case a git repository URL can be used to install the package.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"using Pkg\nPkg.add(\"https://github.com/user-name/MyPackage.jl.git\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/#Package-environments","page":"Getting started with Julia","title":"Package environments","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"By default, Pkg.add will add packages to Julia's global environment. However, Julia also has built-in support for virtual environments.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Activate a virtual environment with:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"import Pkg; Pkg.activate(\"/path/to/environment\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"You can see what packages are installed in the current environment with Pkg.status().","category":"page"},{"location":"tutorials/getting_started/getting_started_with_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nWe strongly recommend you create a Pkg environment for each project that you create in Julia, and add only the packages that you need, instead of adding lots of packages to the global environment. The Pkg manager documentation has more information on this topic.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"EditURL = \"tips_and_tricks.jl\"","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#linear_tips_and_tricks","page":"Tips and tricks","title":"Tips and tricks","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This tutorial was originally contributed by Arpit Bhatia.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"tip: Tip\nA good source of tips is the Mosek Modeling Cookbook.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This tutorial collates some tips and tricks you can use when formulating mixed-integer programs. It uses the following packages:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"using JuMP","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Absolute-value","page":"Tips and tricks","title":"Absolute value","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"To model the absolute value function t ge x, there are a few options. In all cases, these reformulations only work if you are minimizing t \"down\" into x. They do not work if you are trying to maximize x.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Option-1","page":"Tips and tricks","title":"Option 1","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This option adds two linear inequality constraints:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x)\n@variable(model, t)\n@constraint(model, t >= x)\n@constraint(model, t >= -x)","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Option-2","page":"Tips and tricks","title":"Option 2","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This option uses two non-negative variables and forms expressions for x and t:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, z[1:2] >= 0)\n@expression(model, t, z[1] + z[2])\n@expression(model, x, z[1] - z[2])","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Option-3","page":"Tips and tricks","title":"Option 3","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This option uses MOI.NormOneCone and lets JuMP choose the reformulation:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x)\n@variable(model, t)\n@constraint(model, [t; x] in MOI.NormOneCone(2))","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#L1-norm","page":"Tips and tricks","title":"L1-norm","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"To model min x_1, that is, min sumlimits_i x_i, use the MOI.NormOneCone:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x[1:3])\n@variable(model, t)\n@constraint(model, [t; x] in MOI.NormOneCone(1 + length(x)))\n@objective(model, Min, t)","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Infinity-norm","page":"Tips and tricks","title":"Infinity-norm","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"To model min x_infty, that is, min maxlimits_i x_i, use the MOI.NormInfinityCone:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x[1:3])\n@variable(model, t)\n@constraint(model, [t; x] in MOI.NormInfinityCone(1 + length(x)))\n@objective(model, Min, t)","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Max","page":"Tips and tricks","title":"Max","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"To model t ge maxx y, do:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, t)\n@variable(model, x)\n@variable(model, y)\n@constraint(model, t >= x)\n@constraint(model, t >= y)","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This reformulation does not work for t ge minx y.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Min","page":"Tips and tricks","title":"Min","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"To model t le minx y, do:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, t)\n@variable(model, x)\n@variable(model, y)\n@constraint(model, t <= x)\n@constraint(model, t <= y)","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This reformulation does not work for t le maxx y.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Modulo","page":"Tips and tricks","title":"Modulo","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"To model y = x text mod  n, where n is a constant modulus, we use the relationship x = n cdot z + y, where z in mathbbZ_+ is the number of times that n can be divided by x and y is the remainder.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"n = 4\nmodel = Model();\n@variable(model, x >= 0, Int)\n@variable(model, 0 <= y <= n - 1, Int)\n@variable(model, z >= 0, Int)\n@constraint(model, x == n * z + y)","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"The modulo reformulation is often useful for subdividing a time increment into units of time like hours and days:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, t >= 0, Int)\n@variable(model, 0 <= hours <= 23, Int)\n@variable(model, days >= 0, Int)\n@constraint(model, t == 24 * days + hours)","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Boolean-operators","page":"Tips and tricks","title":"Boolean operators","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Binary variables can be used to construct logical operators. Here are some example.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Or","page":"Tips and tricks","title":"Or","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x_3 = x_1 lor x_2","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x[1:3], Bin)\n@constraints(model, begin\n    x[1] <= x[3]\n    x[2] <= x[3]\n    x[3] <= x[1] + x[2]\nend)","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#And","page":"Tips and tricks","title":"And","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x_3 = x_1 land x_2","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x[1:3], Bin)\n@constraints(model, begin\n    x[3] <= x[1]\n    x[3] <= x[2]\n    x[3] >= x[1] + x[2] - 1\nend)","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Not","page":"Tips and tricks","title":"Not","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x_1 neg x_2","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x[1:2], Bin)\n@constraint(model, x[1] == 1 - x[2])","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Implies","page":"Tips and tricks","title":"Implies","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x_1 implies x_2","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x[1:2], Bin)\n@constraint(model, x[1] <= x[2])","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Disjunctions","page":"Tips and tricks","title":"Disjunctions","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/#Problem","page":"Tips and tricks","title":"Problem","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Suppose that we have two constraints a^top x leq b and c^top x leq d, and we want at least one to hold.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Trick-1","page":"Tips and tricks","title":"Trick 1","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Use an indicator constraint.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example Either x_1 leq 1 or x_2 leq 2.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x[1:2])\n@variable(model, y[1:2], Bin)\n@constraint(model, y[1] --> {x[1] <= 1})\n@constraint(model, y[2] --> {x[2] <= 2})\n@constraint(model, sum(y) == 1)  # Exactly one branch must be true","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Trick-2","page":"Tips and tricks","title":"Trick 2","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Introduce a \"big-M\" multiplied by a binary variable to relax one of the constraints.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example Either x_1 leq 1 or x_2 leq 2.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x[1:2] <= 10)\n@variable(model, y[1:2], Bin)\nM = 100\n@constraint(model, x[1] <= 1 + M * y[1])\n@constraint(model, x[2] <= 2 + M * y[2])\n@constraint(model, sum(y) == 1)","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"warning: Warning\nIf M is too small, the solution may be suboptimal. If M is too big, the solver may encounter numerical issues. Try to use domain knowledge to choose an M that is just right. Gurobi has a good documentation section on this topic.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#tips_indicator_constraint","page":"Tips and tricks","title":"Indicator constraints","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/#Problem-2","page":"Tips and tricks","title":"Problem","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Suppose we want to model that a certain linear inequality must be satisfied when some other event occurs, that is, for a binary variable z, we want to model the implication:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"z = 1 implies a^top x leq b","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Trick-1-2","page":"Tips and tricks","title":"Trick 1","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Some solvers have native support for indicator constraints. In addition, if the variables involved have finite domains, then JuMP can automatically reformulate an indicator into a mixed-integer program.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x_1 + x_2 leq 1 if z = 1.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, 0 <= x[1:2] <= 10)\n@variable(model, z, Bin)\n@constraint(model, z --> {sum(x) <= 1})","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x_1 + x_2 leq 1 if z = 0.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, 0 <= x[1:2] <= 10)\n@variable(model, z, Bin)\n@constraint(model, !z --> {sum(x) <= 1})","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Trick-2-2","page":"Tips and tricks","title":"Trick 2","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"If the solver doesn't support indicator constraints and the variables do not have a finite domain, you can use the big-M trick.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x_1 + x_2 leq 1 if z = 1.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x[1:2] <= 10)\n@variable(model, z, Bin)\nM = 100\n@constraint(model, sum(x) <= 1 + M * (1 - z))","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x_1 + x_2 leq 1 if z = 0.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x[1:2] <= 10)\n@variable(model, z, Bin)\nM = 100\n@constraint(model, sum(x) <= 1 + M * z)","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Semi-continuous-variables","page":"Tips and tricks","title":"Semi-continuous variables","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A semi-continuous variable is a continuous variable between bounds lu that also can assume the value zero, that is: x in 0 cup lu","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x in 0cup 1 2","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x in Semicontinuous(1.0, 2.0))","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"You can also represent a semi-continuous variable using the reformulation:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x)\n@variable(model, z, Bin)\n@constraint(model, x <= 2 * z)\n@constraint(model, x >= 1 * z)","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"When z = 0 the two constraints are equivalent to 0 <= x <= 0. When z = 1, the two constraints are equivalent to 1 <= x <= 2.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Semi-integer-variables","page":"Tips and tricks","title":"Semi-integer variables","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A semi-integer variable is a variable which assumes integer values between bounds lu and can also assume the value zero: x in 0 cup l u cap mathbbZ","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x in Semiinteger(5.0, 10.0))","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"You can also represent a semi-integer variable using the reformulation:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x, Int)\n@variable(model, z, Bin)\n@constraint(model, x <= 10 * z)\n@constraint(model, x >= 5 * z)","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"When z = 0 the two constraints are equivalent to 0 <= x <= 0. When z = 1, the two constraints are equivalent to 5 <= x <= 10.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Special-Ordered-Sets-of-Type-1","page":"Tips and tricks","title":"Special Ordered Sets of Type 1","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A Special Ordered Set of Type 1 is a set of variables, at most one of which can take a non-zero value, all others being at 0.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"They most frequently apply where a set of variables are actually binary variables. In other words, we have to choose at most one from a set of possibilities.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x[1:3], Bin)\n@constraint(model, x in SOS1())","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"You can optionally pass SOS1 a weight vector like","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"@constraint(model, x in SOS1([0.2, 0.5, 0.3]))","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"If the decision variables are related and have a physical ordering, then the weight vector, although not used directly in the constraint, can help the solver make a better decision in the solution process.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#tip_sos2","page":"Tips and tricks","title":"Special Ordered Sets of Type 2","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A Special Ordered Set of type 2 is a set of non-negative variables, of which at most two can be non-zero, and if two are non-zero these must be consecutive in their ordering.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model();\n@variable(model, x[1:3])\n@constraint(model, x in SOS2([3.0, 1.0, 2.0]))","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"The ordering provided by the weight vector is more important in this case as the variables need to be consecutive according to the ordering. For example, in the above constraint, the possible pairs are:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Consecutive\n(x[1] and x[3]) as they correspond to 3 and 2 resp. and thus can be non-zero\n(x[2] and x[3]) as they correspond to 1 and 2 resp. and thus can be non-zero\nNon-consecutive\n(x[1] and x[2]) as they correspond to 3 and 1 resp. and thus cannot be non-zero","category":"page"},{"location":"tutorials/linear/tips_and_tricks/#Piecewise-linear-approximations","page":"Tips and tricks","title":"Piecewise linear approximations","text":"","category":"section"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"SOSII constraints are most often used to form piecewise linear approximations of a function.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Given a set of points for x:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x̂ = -1:0.5:2","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"and a set of corresponding points for y:","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"ŷ = x̂ .^ 2","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"the piecewise linear approximation is constructed by representing x and y as convex combinations of x̂ and ŷ.","category":"page"},{"location":"tutorials/linear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"N = length(x̂)\nmodel = Model();\n@variable(model, -1 <= x <= 2)\n@variable(model, y)\n@variable(model, 0 <= λ[1:N] <= 1)\n@objective(model, Max, y)\n@constraints(model, begin\n    x == sum(x̂[i] * λ[i] for i in 1:N)\n    y == sum(ŷ[i] * λ[i] for i in 1:N)\n    sum(λ) == 1\n    λ in SOS2()\nend)","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"EditURL = \"web_app.jl\"","category":"page"},{"location":"tutorials/applications/web_app/#Serving-web-apps","page":"Serving web apps","title":"Serving web apps","text":"","category":"section"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"This tutorial demonstrates how to setup and serve JuMP models via a REST API.","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"In the example app we are building, we solve a trivial mixed-integer program, which is parameterized by the lower bound of a variable. To call the service, users send an HTTP POST request with JSON contents indicating the lower bound. The returned value is the solution of the mixed-integer program as JSON.","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"First, we need JuMP and a solver:","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"using JuMP\nimport HiGHS","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"We also need HTTP.jl to act as our REST server, and JSON.jl to marshal data.","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"import HTTP\nimport JSON","category":"page"},{"location":"tutorials/applications/web_app/#The-server-side","page":"Serving web apps","title":"The server side","text":"","category":"section"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"The core components of our REST server are endpoints. These are functions which accept a Dict{String,Any} of input parameters, and return a Dict{String,Any} as output. The types are Dict{String,Any} because we're going to read these to and from JSON.","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"Here's a very simple endpoint: it accepts params as input, formulates and solves a trivial mixed-integer program, and then returns a dictionary with the result.","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"function endpoint_solve(params::Dict{String,Any})\n    if !haskey(params, \"lower_bound\")\n        return Dict{String,Any}(\n            \"status\" => \"failure\",\n            \"reason\" => \"missing lower_bound param\",\n        )\n    elseif !(params[\"lower_bound\"] isa Real)\n        return Dict{String,Any}(\n            \"status\" => \"failure\",\n            \"reason\" => \"lower_bound is not a number\",\n        )\n    end\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    @variable(model, x >= params[\"lower_bound\"], Int)\n    optimize!(model)\n    ret = Dict{String,Any}(\n        \"status\" => \"okay\",\n        \"terminaton_status\" => termination_status(model),\n        \"primal_status\" => primal_status(model),\n    )\n    # Only include the `x` key if it has a value.\n    if primal_status(model) == FEASIBLE_POINT\n        ret[\"x\"] = value(x)\n    end\n    return ret\nend","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"When we call this, we get:","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"endpoint_solve(Dict{String,Any}(\"lower_bound\" => 1.2))","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"endpoint_solve(Dict{String,Any}())","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"For a second function, we need a function that accepts an HTTP.Request object and returns an HTTP.Response object.","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"function serve_solve(request::HTTP.Request)\n    data = JSON.parse(String(request.body))\n    solution = endpoint_solve(data)\n    return HTTP.Response(200, JSON.json(solution))\nend","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"Finally, we need an HTTP server. There are a variety of ways you can do this in HTTP.jl. We use an explicit Sockets.listen so we have manual control of when we shutdown the server.","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"function setup_server(host, port)\n    server = HTTP.Sockets.listen(host, port)\n    HTTP.serve!(host, port; server = server) do request\n        try\n            # Extend the server by adding other endpoints here.\n            if request.target == \"/api/solve\"\n                return serve_solve(request)\n            else\n                return HTTP.Response(404, \"target $(request.target) not found\")\n            end\n        catch err\n            # Log details about the exception server-side\n            @info \"Unhandled exception: $err\"\n            # Return a response to the client\n            return HTTP.Response(500, \"internal error\")\n        end\n    end\n    return server\nend","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"warning: Warning\nHTTP.jl does not serve requests on a separate thread. Therefore, a long-running job will block the main thread, preventing concurrent users from submitting requests. To work-around this, read HTTP.jl issue 798 or watch Building Microservices and Applications in Julia from JuliaCon 2020.","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"server = setup_server(HTTP.ip\"127.0.0.1\", 8080)","category":"page"},{"location":"tutorials/applications/web_app/#The-client-side","page":"Serving web apps","title":"The client side","text":"","category":"section"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"Now that we have a server, we can send it requests via this function:","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"function send_request(data::Dict; endpoint::String = \"solve\")\n    ret = HTTP.request(\n        \"POST\",\n        # This should match the URL and endpoint we defined for our server.\n        \"http://127.0.0.1:8080/api/$endpoint\",\n        [\"Content-Type\" => \"application/json\"],\n        JSON.json(data),\n    )\n    if ret.status != 200\n        # This could happen if there are time-outs, network errors, etc.\n        return Dict(\n            \"status\" => \"failure\",\n            \"code\" => ret.status,\n            \"body\" => String(ret.body),\n        )\n    end\n    return JSON.parse(String(ret.body))\nend","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"Let's see what happens:","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"send_request(Dict(\"lower_bound\" => 0))","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"send_request(Dict(\"lower_bound\" => 1.2))","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"If we don't send a lower_bound, we get:","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"send_request(Dict(\"invalid_param\" => 1.2))","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"If we don't send a lower_bound that is a number, we get:","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"send_request(Dict(\"lower_bound\" => \"1.2\"))","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"Finally, we can shutdown our HTTP server:","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"close(server)","category":"page"},{"location":"tutorials/applications/web_app/#Next-steps","page":"Serving web apps","title":"Next steps","text":"","category":"section"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"For more complicated examples relating to HTTP servers, consult the HTTP.jl documentation.","category":"page"},{"location":"tutorials/applications/web_app/","page":"Serving web apps","title":"Serving web apps","text":"To see how you can integrate this with a larger JuMP model, read Design patterns for larger models.","category":"page"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"EditURL = \"https://github.com/jump-dev/SDPT3.jl/blob/b565aac2a58818090d521f2340e71f597688e4fb/README.md\"","category":"page"},{"location":"packages/SDPT3/#SDPT3.jl","page":"jump-dev/SDPT3.jl","title":"SDPT3.jl","text":"","category":"section"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"SDPT3.jl is wrapper for the SDPT3 solver.","category":"page"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"The wrapper has two components:","category":"page"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"an exported sdpt3 function that is a thin wrapper on top of the sdpt3 MATLAB function\nan interface to MathOptInterface","category":"page"},{"location":"packages/SDPT3/#Affiliation","page":"jump-dev/SDPT3.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"This wrapper is maintained by the JuMP community and is not an official wrapper of SDPT3.","category":"page"},{"location":"packages/SDPT3/#License","page":"jump-dev/SDPT3.jl","title":"License","text":"","category":"section"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"SDPT3.jl is licensed under the MIT License.","category":"page"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"The underlying solver, SDPT3 is licensed under the GPL v2 License.","category":"page"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"In addition, SDPT3 requires an installation of MATLAB, which is a closed-source commercial product for which you must obtain a license.","category":"page"},{"location":"packages/SDPT3/#Use-with-JuMP","page":"jump-dev/SDPT3.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"To use SDPT3 with JuMP, do:","category":"page"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"using JuMP, SDPT3\nmodel = Model(SDPT3.Optimizer)\nset_attribute(model, \"printlevel\", 0)","category":"page"},{"location":"packages/SDPT3/#Installation","page":"jump-dev/SDPT3.jl","title":"Installation","text":"","category":"section"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"First, make sure that you satisfy the requirements of the MATLAB.jl Julia package, and that the SeDuMi software is installed in your MATLAB™ installation.","category":"page"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"Then, install SDPT3.jl using Pkg.add:","category":"page"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"import Pkg\nPkg.add(\"SDPT3\")","category":"page"},{"location":"packages/SDPT3/#SDPT3-not-in-PATH","page":"jump-dev/SDPT3.jl","title":"SDPT3 not in PATH","text":"","category":"section"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"If you get the error:","category":"page"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"Error using save\nVariable 'jx_sdpt3_arg_out_1' not found.\n\nERROR: LoadError: MATLAB.MEngineError(\"failed to get variable jx_sdpt3_arg_out_1 from MATLAB session\")\nStacktrace:\n[...]","category":"page"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"The error means that we could not find the sdpt3 function with one output argument using the MATLAB C API. This most likely means that you did not add SDPT3 to the MATLAB's path (that is, the toolbox/local/pathdef.m file).","category":"page"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"If modifying toolbox/local/pathdef.m does not work, the following should work, where /path/to/sdpt3/ is the directory where the sdpt3 folder is located:","category":"page"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"julia> using MATLAB\n\njulia> cd(\"/path/to/sdpt3/\") do\n           MATLAB.mat\"install_sdpt3\"\n       end\n\njulia> MATLAB.mat\"savepath\"","category":"page"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"An alternative fix is suggested in the following issue.","category":"page"},{"location":"packages/SDPT3/#Error-in-validate","page":"jump-dev/SDPT3.jl","title":"Error in validate","text":"","category":"section"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"If you get the error:","category":"page"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"Brace indexing is not supported for variables of this type.\n\nError in validate\n\nError in sdpt3 (line 171)\n   [blk,At,C,b,blkdim,numblk,parbarrier] = validate(blk,At,C,b,par,parbarrier);\n\nError using save\nVariable 'jx_sdpt3_arg_out_1' not found.","category":"page"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"It might mean that you have added SDPNAL in addition to SDPT3 in the MATLAB's path (that is, the toolbox/local/pathdef.m file). Because SDPNAL also defines a validate function, this can make sdpt3 call SDPNAL's validate function instead of SDPT3's validate function, which causes the issue.","category":"page"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"One way to fix this from the Julia REPL is to reset the search path to the factory-installed state using restoredefaultpath:","category":"page"},{"location":"packages/SDPT3/","page":"jump-dev/SDPT3.jl","title":"jump-dev/SDPT3.jl","text":"julia> using MATLAB\n\njulia> MATLAB.restoredefaultpath()\n\njulia> MATLAB.mat\"savepath\"","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"EditURL = \"dualization.jl\"","category":"page"},{"location":"tutorials/conic/dualization/#Dualization","page":"Dualization","title":"Dualization","text":"","category":"section"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"The purpose of this tutorial is to explain how to use Dualization.jl to improve the performance of some conic optimization models. There are two important takeaways:","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"JuMP reformulates problems to meet the input requirements of the solver, potentially increasing the problem size by adding slack variables and constraints.\nSolving the dual of a conic model can be more efficient than solving the primal.","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"Dualization.jl is a package which fixes these problems, allowing you to solve the dual instead of the primal with a one-line change to your code.","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"This tutorial uses the following packages","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"using JuMP\nimport Dualization\nimport SCS","category":"page"},{"location":"tutorials/conic/dualization/#Background","page":"Dualization","title":"Background","text":"","category":"section"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"Conic optimization solvers typically accept one of two input formulations.","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"The first is the standard conic form:","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"beginalign\n    min_x in mathbbR^n   c^top x \n              textst   A x = b  \n                               x in mathcalK\nendalign","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"in which we have a set of linear equality constraints Ax = b and the variables belong to a cone mathcalK.","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"The second is the geometric conic form:","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"beginalign\n    min_x in mathbbR^n   c^top x \n              textst   A x - b in mathcalK\nendalign","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"in which an affine function Ax - b belongs to a cone mathcalK and the variables are free.","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"It is trivial to convert between these two representations, for example, to go from the geometric conic form to the standard conic form we introduce slack variables y:","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"beginalign\n    min_x in mathbbR^n   c^top x \n              textst   beginbmatrixA  -Iendbmatrix beginbmatrixxyendbmatrix = b \n                               beginbmatrixxyendbmatrix in mathbbR^n times mathcalK\nendalign","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"and to go from the standard conic form to the geometric conic form, we can rewrite the equality constraint as a function belonging to the {0} cone:","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"beginalign\n    min_x in mathbbR^n   c^top x \n              textst  beginbmatrixAIendbmatrix x - beginbmatrixb0endbmatrix in 0 times mathcalK\nendalign","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"From a theoretical perspective, the two formulations are equivalent, and if you implement a model in the standard conic form and pass it to a geometric conic form solver (or vice versa), then JuMP will automatically reformulate the problem into the correct formulation.","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"From a practical perspective though, the reformulations are problematic because the additional slack variables and constraints can make the problem much larger and therefore harder to solve.","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"You should also note many problems contain a mix of conic constraints and variables, and so they do not neatly fall into one of the two formulations. In these cases, JuMP reformulates only the variables and constraints as necessary to convert the problem into the desired form.","category":"page"},{"location":"tutorials/conic/dualization/#Primal-and-dual-formulations","page":"Dualization","title":"Primal and dual formulations","text":"","category":"section"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"Duality plays a large role in conic optimization. For a detailed description of conic duality, see Duality.","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"A useful observation is that if the primal problem is in standard conic form, then the dual problem is in geometric conic form, and vice versa. Moreover, the primal and dual may have a different number of variables and constraints, although which one is smaller depends on the problem. Therefore, instead of reformulating the problem from one form to the other, it can be more efficient to solve the dual instead of the primal.","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"To demonstrate, we use a variation of the Maximum cut via SDP example.","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"The primal formulation (in standard conic form) is:","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"model_primal = Model()\n@variable(model_primal, X[1:2, 1:2], PSD)\n@objective(model_primal, Max, sum([1 -1; -1 1] .* X))\n@constraint(model_primal, primal_c[i = 1:2], 1 - X[i, i] == 0)\nprint(model_primal)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"This problem has three scalar decision variables (the matrix X is symmetric), two scalar equality constraints, and a constraint that X is positive semidefinite.","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"The dual of model_primal is:","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"model_dual = Model()\n@variable(model_dual, y[1:2])\n@objective(model_dual, Min, sum(y))\n@constraint(model_dual, dual_c, [y[1]-1 1; 1 y[2]-1] in PSDCone())\nprint(model_dual)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"This problem has two scalar decision variables, and a 2x2 positive semidefinite matrix constraint.","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"tip: Tip\nIf you haven't seen conic duality before, try deriving the dual problem based on the description in Duality. You'll need to know that the dual cone of PSDCone is the PSDCone.","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"When we solve model_primal with SCS.Optimizer, SCS reports three variables (variables n: 3), five rows in the constraint matrix (constraints m: 5), and five non-zeros in the matrix (nnz(A): 5):","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"set_optimizer(model_primal, SCS.Optimizer)\noptimize!(model_primal)\n@assert is_solved_and_feasible(model_primal; dual = true)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"(There are five rows in the constraint matrix because SCS expects problems in geometric conic form, and so JuMP has reformulated the X, PSD variable constraint into the affine constraint X .+ 0 in PSDCone().)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"The solution we obtain is:","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"value.(X)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"dual.(primal_c)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"objective_value(model_primal)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"When we solve model_dual with SCS.Optimizer, SCS reports two variables (variables n: 2), three rows in the constraint matrix (constraints m: 3), and two non-zeros in the matrix (nnz(A): 2):","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"set_optimizer(model_dual, SCS.Optimizer)\noptimize!(model_dual)\n@assert is_solved_and_feasible(model_dual; dual = true)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"and the solution we obtain is:","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"dual.(dual_c)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"value.(y)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"objective_value(model_dual)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"This particular problem is small enough that it isn't meaningful to compare the solve times, but in general, we should expect model_dual to solve faster than model_primal because it contains fewer variables and constraints. The difference is particularly noticeable on large-scale optimization problems.","category":"page"},{"location":"tutorials/conic/dualization/#dual_optimizer","page":"Dualization","title":"dual_optimizer","text":"","category":"section"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"Manually deriving the conic dual is difficult and error-prone. The package Dualization.jl provides the Dualization.dual_optimizer meta-solver, which wraps any MathOptInterface-compatible solver in an interface that automatically formulates and solves the dual of an input problem.","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"To demonstrate, we use Dualization.dual_optimizer to solve model_primal:","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"set_optimizer(model_primal, Dualization.dual_optimizer(SCS.Optimizer))\noptimize!(model_primal)\n@assert is_solved_and_feasible(model_primal; dual = true)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"The performance is the same as if we solved model_dual, and the correct solution is returned to X:","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"value.(X)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"dual.(primal_c)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"Moreover, if we use dual_optimizer on model_dual, then we get the same performance as if we had solved model_primal:","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"set_optimizer(model_dual, Dualization.dual_optimizer(SCS.Optimizer))\noptimize!(model_dual)\n@assert is_solved_and_feasible(model_dual; dual = true)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"dual.(dual_c)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"value.(y)","category":"page"},{"location":"tutorials/conic/dualization/#A-mixed-example","page":"Dualization","title":"A mixed example","text":"","category":"section"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"The Maximum cut via SDP example is nicely defined because the primal is in standard conic form and the dual is in geometric conic form. However, many practical models contain a mix of the two formulations. One example is The minimum distortion problem:","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"D = [0 1 1 1; 1 0 2 2; 1 2 0 2; 1 2 2 0]\nmodel = Model()\n@variable(model, c²)\n@variable(model, Q[1:4, 1:4], PSD)\n@objective(model, Min, c²)\nfor i in 1:4, j in (i+1):4\n    @constraint(model, D[i, j]^2 <= Q[i, i] + Q[j, j] - 2 * Q[i, j])\n    @constraint(model, Q[i, i] + Q[j, j] - 2 * Q[i, j] <= c² * D[i, j]^2)\nend\n@constraint(model, Q[1, 1] == 0)\n@constraint(model, c² >= 1)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"In this formulation, the Q variable is of the form xinmathcalK, but there is also a free variable, c², a linear equality constraint, Q[1, 1] == 0, and some linear inequality constraints. Rather than attempting to derive the formulation that JuMP would pass to SCS and its dual, the simplest solution is to try solving the problem with and without dual_optimizer to see which formulation is most efficient.","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"set_optimizer(model, SCS.Optimizer)\noptimize!(model)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"set_optimizer(model, Dualization.dual_optimizer(SCS.Optimizer))\noptimize!(model)","category":"page"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"For this problem, SCS reports that the primal has variables n: 11, constraints m: 24 and that the dual has variables n: 14, constraints m: 24. Therefore, we should probably use the primal formulation because it has fewer variables and the same number of constraints.","category":"page"},{"location":"tutorials/conic/dualization/#When-to-use-dual_optimizer","page":"Dualization","title":"When to use dual_optimizer","text":"","category":"section"},{"location":"tutorials/conic/dualization/","page":"Dualization","title":"Dualization","text":"Because it can make the problem larger or smaller, depending on the problem and the choice of solver, there is no definitive rule on when you should use dual_optimizer. However, you should try dual_optimizer if your conic optimization problem takes a long time to solve, or if you need to repeatedly solve similarly structured problems with different data. In some cases solving the dual instead of the primal can make a large difference.","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"EditURL = \"ellipse_approx.jl\"","category":"page"},{"location":"tutorials/conic/ellipse_approx/#Ellipsoid-approximation","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"","category":"section"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"This tutorial considers the problem of computing extremal ellipsoids: finding ellipsoids that best approximate a given set. As an extension, we show how to use JuMP to inspect the bridges that were used, and how to explore alternative formulations.","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"The model comes from Section 4.9 of (Ben-Tal and Nemirovski, 2001).","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"For a related example, see also the Minimal ellipses tutorial.","category":"page"},{"location":"tutorials/conic/ellipse_approx/#Problem-formulation","page":"Ellipsoid approximation","title":"Problem formulation","text":"","category":"section"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"Suppose that we are given a set mathcalS consisting of m points in n-dimensional space:","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"mathcalS =  x_1 ldots x_m  subset mathbbR^n","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"Our goal is to determine an optimal vector c in  mathbbR^n and an optimal n times n real symmetric matrix D such that the ellipse:","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"E(D c) =  x  (x - c)^top D ( x - c) leq 1 ","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"contains mathcalS and has the smallest possible volume.","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"The optimal D and c are given by the optimization problem:","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"beginaligned\nmax        quad  t                                                                    \ntextst quad  Z succeq 0 \n                   beginbmatrix s  z^top  z  Z  endbmatrix succeq 0 \n                   x_i^top Z x_i - 2x_i^top z + s leq 1     quad i=1 ldots m \n                   t le sqrtndet(Z)\nendaligned","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"where D = Z_* and c = Z_*^-1 z_*.","category":"page"},{"location":"tutorials/conic/ellipse_approx/#Required-packages","page":"Ellipsoid approximation","title":"Required packages","text":"","category":"section"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"using JuMP\nimport LinearAlgebra\nimport Plots\nimport Random\nimport SCS\nimport Test","category":"page"},{"location":"tutorials/conic/ellipse_approx/#Data","page":"Ellipsoid approximation","title":"Data","text":"","category":"section"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"We first need to generate some points to work with.","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"function generate_point_cloud(\n    m;            # number of 2-dimensional points\n    a = 10,       # scaling in x direction\n    b = 2,        # scaling in y direction\n    rho = π / 6,  # rotation of points around origin\n    random_seed = 1,\n)\n    rng = Random.MersenneTwister(random_seed)\n    P = randn(rng, Float64, m, 2)\n    Phi = [a*cos(rho) a*sin(rho); -b*sin(rho) b*cos(rho)]\n    S = P * Phi\n    return S\nend","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"For the sake of this example, let's take m = 600:","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"S = generate_point_cloud(600);\nnothing #hide","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"We will visualise the points (and ellipse) using the Plots package:","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"r = 1.1 * maximum(abs.(S))\nplot = Plots.scatter(\n    S[:, 1],\n    S[:, 2];\n    xlim = (-r, r),\n    ylim = (-r, r),\n    label = nothing,\n    c = :green,\n    shape = :x,\n    size = (600, 600),\n)","category":"page"},{"location":"tutorials/conic/ellipse_approx/#JuMP-formulation","page":"Ellipsoid approximation","title":"JuMP formulation","text":"","category":"section"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"Now let's build and the JuMP model. We'll compute D and c after the solve.","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"model = Model(SCS.Optimizer)\n# We need to use a tighter tolerance for this example, otherwise the bounding\n# ellipse won't actually be bounding...\nset_attribute(model, \"eps_rel\", 1e-6)\nset_silent(model)\nm, n = size(S)\n@variable(model, z[1:n])\n@variable(model, Z[1:n, 1:n], PSD)\n@variable(model, s)\n@variable(model, t)\n@constraint(model, [s z'; z Z] >= 0, PSDCone())\n@constraint(\n    model,\n    [i in 1:m],\n    S[i, :]' * Z * S[i, :] - 2 * S[i, :]' * z + s <= 1,\n)\n@constraint(model, [t; vec(Z)] in MOI.RootDetConeSquare(n))\n@objective(model, Max, t)\noptimize!(model)\nTest.@test is_solved_and_feasible(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/conic/ellipse_approx/#Results","page":"Ellipsoid approximation","title":"Results","text":"","category":"section"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"After solving the model to optimality we can recover the solution in terms of D and c:","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"D = value.(Z)","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"c = D \\ value.(z)","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"Finally, overlaying the solution in the plot we see the minimal volume approximating ellipsoid:","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"P = sqrt(D)\nq = -P * c\ndata = [tuple(P \\ [cos(θ) - q[1], sin(θ) - q[2]]...) for θ in 0:0.05:(2pi+0.05)]\nPlots.plot!(plot, data; c = :crimson, label = nothing)","category":"page"},{"location":"tutorials/conic/ellipse_approx/#Alternative-formulations","page":"Ellipsoid approximation","title":"Alternative formulations","text":"","category":"section"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"The formulation of model uses MOI.RootDetConeSquare. However, because SCS does not natively support this cone, JuMP automatically reformulates the problem into an equivalent problem that SCS does support. You can see the reformulation that JuMP chose using print_active_bridges:","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"print_active_bridges(model)","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"There's a lot going on here, but the first bullet is:","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"* Unsupported objective: MOI.VariableIndex\n|  bridged by:\n|   MOIB.Objective.FunctionizeBridge{Float64}\n|  introduces:\n|   * Supported objective: MOI.ScalarAffineFunction{Float64}","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"This says that SCS does not support a MOI.VariableIndex objective function, and that JuMP used a MOI.Bridges.Objective.FunctionizeBridge to convert it into a MOI.ScalarAffineFunction{Float64} objective function.","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"We can leave JuMP to do the reformulation, or we can rewrite our model to have an objective function that SCS natively supports:","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"@objective(model, Max, 1.0 * t + 0.0);\nnothing #hide","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"Re-printing the active bridges:","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"print_active_bridges(model)","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"we get * Supported objective: MOI.ScalarAffineFunction{Float64}.","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"We can manually implement some other reformulations to change our model to something that SCS more closely supports by:","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"Replacing the MOI.VectorOfVariables in MOI.PositiveSemidefiniteConeTriangle constraint @variable(model, Z[1:n, 1:n], PSD) with the MOI.VectorAffineFunction in MOI.PositiveSemidefiniteConeTriangle @constraint(model, Z >= 0, PSDCone()).\nReplacing the MOI.VectorOfVariables in MOI.PositiveSemidefiniteConeSquare constraint [s z'; z Z] >= 0, PSDCone() with the MOI.VectorAffineFunction in MOI.PositiveSemidefiniteConeTriangle @constraint(model, LinearAlgebra.Symmetric([s z'; z Z]) >= 0, PSDCone()).\nReplacing the MOI.ScalarAffineFunction in MOI.GreaterThan constraints with the vectorized equivalent of MOI.VectorAffineFunction in MOI.Nonnegatives\nReplacing the MOI.VectorOfVariables in MOI.RootDetConeSquare constraint with MOI.VectorAffineFunction in MOI.RootDetConeTriangle.","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"Note that we still need to bridge MOI.PositiveSemidefiniteConeTriangle constraints because SCS uses an internal SCS.ScaledPSDCone set instead.","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"model = Model(SCS.Optimizer)\nset_attribute(model, \"eps_rel\", 1e-6)\nset_silent(model)\n@variable(model, z[1:n])\n@variable(model, s)\n@variable(model, t)\n# The former @variable(model, Z[1:n, 1:n], PSD)\n@variable(model, Z[1:n, 1:n], Symmetric)\n@constraint(model, Z >= 0, PSDCone())\n# The former [s z'; z Z] >= 0, PSDCone()\n@constraint(model, LinearAlgebra.Symmetric([s z'; z Z]) >= 0, PSDCone())\n# The former constraint S[i, :]' * Z * S[i, :] - 2 * S[i, :]' * z + s <= 1\nf = [1 - S[i, :]' * Z * S[i, :] + 2 * S[i, :]' * z - s for i in 1:m]\n@constraint(model, f in MOI.Nonnegatives(m))\n# The former constraint [t; vec(Z)] in MOI.RootDetConeSquare(n)\n@constraint(model, 1 * [t; triangle_vec(Z)] .+ 0 in MOI.RootDetConeTriangle(n))\n# The former @objective(model, Max, t)\n@objective(model, Max, 1 * t + 0)\noptimize!(model)\nTest.@test is_solved_and_feasible(model)\nsolve_time_1 = solve_time(model)","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"This formulation gives the much smaller graph:","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"print_active_bridges(model)","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"The last bullet shows how JuMP reformulated the MOI.RootDetConeTriangle constraint by adding a mix of MOI.PositiveSemidefiniteConeTriangle and MOI.GeometricMeanCone constraints.","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"Because SCS doesn't natively support the MOI.GeometricMeanCone, these constraints were further bridged using a MOI.Bridges.Constraint.GeoMeanToPowerBridge to a series of MOI.PowerCone constraints.","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"However, there are many other ways that a MOI.GeometricMeanCone can be reformulated into something that SCS supports. Let's see what happens if we use remove_bridge to remove the MOI.Bridges.Constraint.GeoMeanToPowerBridge:","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"remove_bridge(model, MOI.Bridges.Constraint.GeoMeanToPowerBridge)\noptimize!(model)\nTest.@test is_solved_and_feasible(model)","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"This time, the solve took:","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"solve_time_2 = solve_time(model)","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"where previously it took","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"solve_time_1","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"Why was the solve time different?","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"print_active_bridges(model)","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"This time, JuMP used a MOI.Bridges.Constraint.GeoMeanBridge to reformulate the constraint into a set of MOI.RotatedSecondOrderCone constraints, which were further reformulated into a set of supported MOI.SecondOrderCone constraints.","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"Since the two models are equivalent, we can conclude that for this particular model, the MOI.SecondOrderCone formulation is more efficient.","category":"page"},{"location":"tutorials/conic/ellipse_approx/","page":"Ellipsoid approximation","title":"Ellipsoid approximation","text":"In general though, the performance of a particular reformulation is problem- and solver-specific. Therefore, JuMP chooses to minimize the number of bridges in the default reformulation, leaving you to explore alternative formulations using the tools and techniques shown in this tutorial.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"DocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"manual/containers/#Containers","page":"Containers","title":"Containers","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"JuMP provides specialized containers similar to AxisArrays that enable multi-dimensional arrays with non-integer indices.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"These containers are created automatically by JuMP's macros. Each macro has the same basic syntax:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"@macroname(model, name[key1=index1, index2; optional_condition], other stuff)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"The containers are generated by the name[key1=index1, index2; optional_condition] syntax. Everything else is specific to the particular macro.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Containers can be named, for example, name[key=index], or unnamed, for example, [key=index]. We call unnamed containers anonymous.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"We call the bits inside the square brackets and before the ; the index sets. The index sets can be named, for example, [i = 1:4], or they can be unnamed, for example, [1:4].","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"We call the bit inside the square brackets and after the ; the condition. Conditions are optional.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"In addition to the standard JuMP macros like @variable and @constraint, which construct containers of variables and constraints respectively, you can use Containers.@container to construct containers with arbitrary elements.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"We will use this macro to explain the three types of containers that are natively supported by JuMP: Array, Containers.DenseAxisArray, and Containers.SparseAxisArray.","category":"page"},{"location":"manual/containers/#Array","page":"Containers","title":"Array","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"An Array is created when the index sets are rectangular and the index sets are of the form 1:n.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container(x[i = 1:2, j = 1:3], (i, j))\n2×3 Matrix{Tuple{Int64, Int64}}:\n (1, 1)  (1, 2)  (1, 3)\n (2, 1)  (2, 2)  (2, 3)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"The result is a normal Julia Array, so you can do all the usual things.","category":"page"},{"location":"manual/containers/#Slicing","page":"Containers","title":"Slicing","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Arrays can be sliced","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x[:, 1]\n2-element Vector{Tuple{Int64, Int64}}:\n (1, 1)\n (2, 1)\n\njulia> x[2, :]\n3-element Vector{Tuple{Int64, Int64}}:\n (2, 1)\n (2, 2)\n (2, 3)","category":"page"},{"location":"manual/containers/#Looping","page":"Containers","title":"Looping","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use eachindex to loop over the elements:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> for key in eachindex(x)\n           println(x[key])\n       end\n(1, 1)\n(2, 1)\n(1, 2)\n(2, 2)\n(1, 3)\n(2, 3)","category":"page"},{"location":"manual/containers/#Get-the-index-sets","page":"Containers","title":"Get the index sets","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use axes to obtain the index sets:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> axes(x)\n(Base.OneTo(2), Base.OneTo(3))","category":"page"},{"location":"manual/containers/#Broadcasting","page":"Containers","title":"Broadcasting","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Broadcasting over an Array returns an Array","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> swap(x::Tuple) = (last(x), first(x))\nswap (generic function with 1 method)\n\njulia> swap.(x)\n2×3 Matrix{Tuple{Int64, Int64}}:\n (1, 1)  (2, 1)  (3, 1)\n (1, 2)  (2, 2)  (3, 2)","category":"page"},{"location":"manual/containers/#Tables","page":"Containers","title":"Tables","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use Containers.rowtable to convert the Array into a Tables.jl compatible Vector{<:NamedTuple}:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> table = Containers.rowtable(x; header = [:I, :J, :value])\n6-element Vector{@NamedTuple{I::Int64, J::Int64, value::Tuple{Int64, Int64}}}:\n (I = 1, J = 1, value = (1, 1))\n (I = 2, J = 1, value = (2, 1))\n (I = 1, J = 2, value = (1, 2))\n (I = 2, J = 2, value = (2, 2))\n (I = 1, J = 3, value = (1, 3))\n (I = 2, J = 3, value = (2, 3))","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Because it supports the Tables.jl interface, you can pass it to any function which accepts a table as input:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> import DataFrames;\n\njulia> DataFrames.DataFrame(table)\n6×3 DataFrame\n Row │ I      J      value\n     │ Int64  Int64  Tuple…\n─────┼──────────────────────\n   1 │     1      1  (1, 1)\n   2 │     2      1  (2, 1)\n   3 │     1      2  (1, 2)\n   4 │     2      2  (2, 2)\n   5 │     1      3  (1, 3)\n   6 │     2      3  (2, 3)","category":"page"},{"location":"manual/containers/#DenseAxisArray","page":"Containers","title":"DenseAxisArray","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"A Containers.DenseAxisArray is created when the index sets are rectangular, but not of the form 1:n. The index sets can be of any type.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x = Containers.@container([i = 1:2, j = [:A, :B]], (i, j))\n2-dimensional DenseAxisArray{Tuple{Int64, Symbol},2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, [:A, :B]\nAnd data, a 2×2 Matrix{Tuple{Int64, Symbol}}:\n (1, :A)  (1, :B)\n (2, :A)  (2, :B)","category":"page"},{"location":"manual/containers/#Slicing-2","page":"Containers","title":"Slicing","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"DenseAxisArrays can be sliced","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x[:, :A]\n1-dimensional DenseAxisArray{Tuple{Int64, Symbol},1,...} with index sets:\n    Dimension 1, Base.OneTo(2)\nAnd data, a 2-element Vector{Tuple{Int64, Symbol}}:\n (1, :A)\n (2, :A)\n\njulia> x[1, :]\n1-dimensional DenseAxisArray{Tuple{Int64, Symbol},1,...} with index sets:\n    Dimension 1, [:A, :B]\nAnd data, a 2-element Vector{Tuple{Int64, Symbol}}:\n (1, :A)\n (1, :B)","category":"page"},{"location":"manual/containers/#Looping-2","page":"Containers","title":"Looping","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use eachindex to loop over the elements:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> for key in eachindex(x)\n           println(x[key])\n       end\n(1, :A)\n(2, :A)\n(1, :B)\n(2, :B)","category":"page"},{"location":"manual/containers/#Get-the-index-sets-2","page":"Containers","title":"Get the index sets","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use axes to obtain the index sets:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> axes(x)\n(Base.OneTo(2), [:A, :B])","category":"page"},{"location":"manual/containers/#Broadcasting-2","page":"Containers","title":"Broadcasting","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Broadcasting over a DenseAxisArray returns a DenseAxisArray","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> swap(x::Tuple) = (last(x), first(x))\nswap (generic function with 1 method)\n\njulia> swap.(x)\n2-dimensional DenseAxisArray{Tuple{Symbol, Int64},2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, [:A, :B]\nAnd data, a 2×2 Matrix{Tuple{Symbol, Int64}}:\n (:A, 1)  (:B, 1)\n (:A, 2)  (:B, 2)","category":"page"},{"location":"manual/containers/#Access-internal-data","page":"Containers","title":"Access internal data","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use Array(x) to copy the internal data array into a new Array:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Array(x)\n2×2 Matrix{Tuple{Int64, Symbol}}:\n (1, :A)  (1, :B)\n (2, :A)  (2, :B)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"To access the internal data without a copy, use x.data.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x.data\n2×2 Matrix{Tuple{Int64, Symbol}}:\n (1, :A)  (1, :B)\n (2, :A)  (2, :B)","category":"page"},{"location":"manual/containers/#Tables-2","page":"Containers","title":"Tables","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use Containers.rowtable to convert the DenseAxisArray into a Tables.jl compatible Vector{<:NamedTuple}:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> table = Containers.rowtable(x; header = [:I, :J, :value])\n4-element Vector{@NamedTuple{I::Int64, J::Symbol, value::Tuple{Int64, Symbol}}}:\n (I = 1, J = :A, value = (1, :A))\n (I = 2, J = :A, value = (2, :A))\n (I = 1, J = :B, value = (1, :B))\n (I = 2, J = :B, value = (2, :B))","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Because it supports the Tables.jl interface, you can pass it to any function which accepts a table as input:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> import DataFrames;\n\njulia> DataFrames.DataFrame(table)\n4×3 DataFrame\n Row │ I      J       value\n     │ Int64  Symbol  Tuple…\n─────┼────────────────────────\n   1 │     1  A       (1, :A)\n   2 │     2  A       (2, :A)\n   3 │     1  B       (1, :B)\n   4 │     2  B       (2, :B)","category":"page"},{"location":"manual/containers/#Keyword-indexing","page":"Containers","title":"Keyword indexing","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"If all axes are named, you can use keyword indexing:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x[i = 2, j = :A]\n(2, :A)\n\njulia> x[i = :, j = :B]\n1-dimensional DenseAxisArray{Tuple{Int64, Symbol},1,...} with index sets:\n    Dimension 1, Base.OneTo(2)\nAnd data, a 2-element Vector{Tuple{Int64, Symbol}}:\n (1, :B)\n (2, :B)","category":"page"},{"location":"manual/containers/#SparseAxisArray","page":"Containers","title":"SparseAxisArray","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"A Containers.SparseAxisArray is created when the index sets are non-rectangular. This occurs in two circumstances:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"An index depends on a prior index:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i = 1:2, j = i:2], (i, j))\nJuMP.Containers.SparseAxisArray{Tuple{Int64, Int64}, 2, Tuple{Int64, Int64}} with 3 entries:\n  [1, 1]  =  (1, 1)\n  [1, 2]  =  (1, 2)\n  [2, 2]  =  (2, 2)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"The [indices; condition] syntax is used:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x = Containers.@container([i = 1:3, j = [:A, :B]; i > 1], (i, j))\nJuMP.Containers.SparseAxisArray{Tuple{Int64, Symbol}, 2, Tuple{Int64, Symbol}} with 4 entries:\n  [2, A]  =  (2, :A)\n  [2, B]  =  (2, :B)\n  [3, A]  =  (3, :A)\n  [3, B]  =  (3, :B)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Here we have the index sets i = 1:3, j = [:A, :B], followed by ;, and then a condition, which evaluates to true or false: i > 1.","category":"page"},{"location":"manual/containers/#Slicing-3","page":"Containers","title":"Slicing","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Slicing is supported:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> y = x[:, :B]\nJuMP.Containers.SparseAxisArray{Tuple{Int64, Symbol}, 1, Tuple{Int64}} with 2 entries:\n  [2]  =  (2, :B)\n  [3]  =  (3, :B)","category":"page"},{"location":"manual/containers/#Looping-3","page":"Containers","title":"Looping","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use eachindex to loop over the elements:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> for key in eachindex(x)\n           println(x[key])\n       end\n(2, :A)\n(2, :B)\n(3, :A)\n(3, :B)\n\njulia> for key in eachindex(y)\n           println(y[key])\n       end\n(2, :B)\n(3, :B)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"warning: Warning\nIf you use a macro to construct a SparseAxisArray, then the iteration order is row-major, that is, indices are varied from right to left. As an example, when iterating over x above, the j index is iterated, keeping i constant. This order is in contrast to Base.Arrays, which iterate in column-major order, that is, by varying indices from left to right.","category":"page"},{"location":"manual/containers/#Broadcasting-3","page":"Containers","title":"Broadcasting","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Broadcasting over a SparseAxisArray returns a SparseAxisArray","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> swap(x::Tuple) = (last(x), first(x))\nswap (generic function with 1 method)\n\njulia> swap.(y)\nJuMP.Containers.SparseAxisArray{Tuple{Symbol, Int64}, 1, Tuple{Int64}} with 2 entries:\n  [2]  =  (:B, 2)\n  [3]  =  (:B, 3)","category":"page"},{"location":"manual/containers/#Tables-3","page":"Containers","title":"Tables","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use Containers.rowtable to convert the SparseAxisArray into a Tables.jl compatible Vector{<:NamedTuple}:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> table = Containers.rowtable(x; header = [:I, :J, :value])\n4-element Vector{@NamedTuple{I::Int64, J::Symbol, value::Tuple{Int64, Symbol}}}:\n (I = 2, J = :A, value = (2, :A))\n (I = 2, J = :B, value = (2, :B))\n (I = 3, J = :A, value = (3, :A))\n (I = 3, J = :B, value = (3, :B))","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Because it supports the Tables.jl interface, you can pass it to any function which accepts a table as input:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> import DataFrames;\n\njulia> DataFrames.DataFrame(table)\n4×3 DataFrame\n Row │ I      J       value\n     │ Int64  Symbol  Tuple…\n─────┼────────────────────────\n   1 │     2  A       (2, :A)\n   2 │     2  B       (2, :B)\n   3 │     3  A       (3, :A)\n   4 │     3  B       (3, :B)","category":"page"},{"location":"manual/containers/#Keyword-indexing-2","page":"Containers","title":"Keyword indexing","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"If all axes are named, you can use keyword indexing:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x[i = 2, j = :A]\n(2, :A)\n\njulia> x[i = :, j = :B]\nJuMP.Containers.SparseAxisArray{Tuple{Int64, Symbol}, 1, Tuple{Int64}} with 2 entries:\n  [2]  =  (2, :B)\n  [3]  =  (3, :B)","category":"page"},{"location":"manual/containers/#Forcing-the-container-type","page":"Containers","title":"Forcing the container type","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Pass container = T to use T as the container. For example:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i = 1:2, j = 1:2], i + j, container = Array)\n2×2 Matrix{Int64}:\n 2  3\n 3  4\n\njulia> Containers.@container([i = 1:2, j = 1:2], i + j, container = Dict)\nDict{Tuple{Int64, Int64}, Int64} with 4 entries:\n  (1, 2) => 3\n  (1, 1) => 2\n  (2, 2) => 4\n  (2, 1) => 3","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"You can also pass DenseAxisArray or SparseAxisArray.","category":"page"},{"location":"manual/containers/#How-different-container-types-are-chosen","page":"Containers","title":"How different container types are chosen","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"If the compiler can prove at compile time that the index sets are rectangular, and indexed by a compact set of integers that start at 1, Containers.@container will return an array. This is the case if your index sets are visible to the macro as 1:n:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i=1:3, j=1:5], i + j)\n3×5 Matrix{Int64}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"or an instance of Base.OneTo:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> set = Base.OneTo(3)\nBase.OneTo(3)\n\njulia> Containers.@container([i=set, j=1:5], i + j)\n3×5 Matrix{Int64}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"If the compiler can prove that the index set is rectangular, but not necessarily of the form 1:n at compile time, then a Containers.DenseAxisArray will be constructed instead:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> set = 1:3\n1:3\n\njulia> Containers.@container([i=set, j=1:5], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, Base.OneTo(5)\nAnd data, a 3×5 Matrix{Int64}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"info: Info\nWhat happened here? Although we know that set contains 1:3, at compile time the typeof(set) is a UnitRange{Int}. Therefore, Julia can't prove that the range starts at 1 (it only finds this out at runtime), and it defaults to a  DenseAxisArray. The case where we explicitly wrote i = 1:3 worked because the macro can \"see\" the 1 at compile time.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"However, if you know that the indices do form an Array, you can force the container type with container = Array:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> set = 1:3\n1:3\n\njulia> Containers.@container([i=set, j=1:5], i + j, container = Array)\n3×5 Matrix{Int64}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Here's another example with something similar:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> a = 1\n1\n\njulia> Containers.@container([i=a:3, j=1:5], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, Base.OneTo(5)\nAnd data, a 3×5 Matrix{Int64}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8\n\njulia> Containers.@container([i=1:a, j=1:5], i + j)\n1×5 Matrix{Int64}:\n 2  3  4  5  6","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Finally, if the compiler cannot prove that the index set is rectangular, a Containers.SparseAxisArray will be created.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"This occurs when some indices depend on a previous one:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i=1:3, j=1:i], i + j)\nJuMP.Containers.SparseAxisArray{Int64, 2, Tuple{Int64, Int64}} with 6 entries:\n  [1, 1]  =  2\n  [2, 1]  =  3\n  [2, 2]  =  4\n  [3, 1]  =  4\n  [3, 2]  =  5\n  [3, 3]  =  6","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"or if there is a condition on the index sets:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i = 1:5; isodd(i)], i^2)\nJuMP.Containers.SparseAxisArray{Int64, 1, Tuple{Int64}} with 3 entries:\n  [1]  =  1\n  [3]  =  9\n  [5]  =  25","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"The condition can depend on multiple indices, the only requirement is that it is an expression that returns true or false:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> condition(i, j) = isodd(i) && iseven(j)\ncondition (generic function with 1 method)\n\njulia> Containers.@container([i = 1:2, j = 1:4; condition(i, j)], i + j)\nJuMP.Containers.SparseAxisArray{Int64, 2, Tuple{Int64, Int64}} with 2 entries:\n  [1, 2]  =  3\n  [1, 4]  =  5","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/manual/solutions.md\"","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/solutions/#manual_solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"moi/manual/solutions/#Solving-and-retrieving-the-results","page":"Solutions","title":"Solving and retrieving the results","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Once an optimizer is loaded with the objective function and all of the constraints, we can ask the solver to solve the model by calling optimize!.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"MOI.optimize!(optimizer)","category":"page"},{"location":"moi/manual/solutions/#Why-did-the-solver-stop?","page":"Solutions","title":"Why did the solver stop?","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"The optimization procedure may stop for a number of reasons. The TerminationStatus attribute of the optimizer returns a TerminationStatusCode object which explains why the solver stopped.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"The termination statuses distinguish between proofs of optimality, infeasibility, local convergence, limits, and termination because of something unexpected like invalid problem data or failure to converge.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"A typical usage of the TerminationStatus attribute is as follows:","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"status = MOI.get(optimizer, TerminationStatus())\nif status == MOI.OPTIMAL\n    # Ok, we solved the problem!\nelse\n    # Handle other cases.\nend","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"After checking the TerminationStatus, check ResultCount. This attribute returns the number of results that the solver has available to return. A result is defined as a primal-dual pair, but either the primal or the dual may be missing from the result. While the OPTIMAL termination status normally implies that at least one result is available, other statuses do not. For example, in the case of infeasibility, a solver may return no result or a proof of infeasibility. The ResultCount attribute distinguishes between these two cases.","category":"page"},{"location":"moi/manual/solutions/#Primal-solutions","page":"Solutions","title":"Primal solutions","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Use the PrimalStatus optimizer attribute to return a ResultStatusCode describing the status of the primal solution.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Common returns are described below in the Common status situations section.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Query the primal solution using the VariablePrimal and ConstraintPrimal attributes.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Query the objective function value using the ObjectiveValue attribute.","category":"page"},{"location":"moi/manual/solutions/#Dual-solutions","page":"Solutions","title":"Dual solutions","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nSee Duality for a discussion of the MOI conventions for primal-dual pairs and certificates.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Use the DualStatus optimizer attribute to return a ResultStatusCode describing the status of the dual solution.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Query the dual solution using the ConstraintDual attribute.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Query the dual objective function value using the DualObjectiveValue attribute.","category":"page"},{"location":"moi/manual/solutions/#Common-status-situations","page":"Solutions","title":"Common status situations","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"The sections below describe how to interpret typical or interesting status cases for three common classes of solvers. The example cases are illustrative, not comprehensive. Solver wrappers may provide additional information on how the solver's statuses map to MOI statuses.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"info: Info\n* in the tables indicate that multiple different values are possible.","category":"page"},{"location":"moi/manual/solutions/#Primal-dual-convex-solver","page":"Solutions","title":"Primal-dual convex solver","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Linear programming and conic optimization solvers fall into this category.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"What happened? TerminationStatus ResultCount PrimalStatus DualStatus\nProved optimality OPTIMAL 1 FEASIBLE_POINT FEASIBLE_POINT\nProved infeasible INFEASIBLE 1 NO_SOLUTION INFEASIBILITY_CERTIFICATE\nOptimal within relaxed tolerances ALMOST_OPTIMAL 1 FEASIBLE_POINT FEASIBLE_POINT\nOptimal within relaxed tolerances ALMOST_OPTIMAL 1 ALMOST_FEASIBLE_POINT ALMOST_FEASIBLE_POINT\nDetected an unbounded ray of the primal DUAL_INFEASIBLE 1 INFEASIBILITY_CERTIFICATE NO_SOLUTION\nStall SLOW_PROGRESS 1 * *","category":"page"},{"location":"moi/manual/solutions/#Global-branch-and-bound-solvers","page":"Solutions","title":"Global branch-and-bound solvers","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Mixed-integer programming solvers fall into this category.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"What happened? TerminationStatus ResultCount PrimalStatus DualStatus\nProved optimality OPTIMAL 1 FEASIBLE_POINT NO_SOLUTION\nPresolve detected infeasibility or unboundedness INFEASIBLE_OR_UNBOUNDED 0 NO_SOLUTION NO_SOLUTION\nProved infeasibility INFEASIBLE 0 NO_SOLUTION NO_SOLUTION\nTimed out (no solution) TIME_LIMIT 0 NO_SOLUTION NO_SOLUTION\nTimed out (with a solution) TIME_LIMIT 1 FEASIBLE_POINT NO_SOLUTION\nCPXMIP_OPTIMAL_INFEAS ALMOST_OPTIMAL 1 INFEASIBLE_POINT NO_SOLUTION","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"info: Info\nCPXMIP_OPTIMAL_INFEAS is a CPLEX status that indicates that a preprocessed problem was solved to optimality, but the solver was unable to recover a feasible solution to the original problem. Handling this status was one of the motivating drivers behind the design of MOI.","category":"page"},{"location":"moi/manual/solutions/#Local-search-solvers","page":"Solutions","title":"Local search solvers","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Nonlinear programming solvers fall into this category. It also includes non-global tree search solvers like Juniper.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"What happened? TerminationStatus ResultCount PrimalStatus DualStatus\nConverged to a stationary point LOCALLY_SOLVED 1 FEASIBLE_POINT FEASIBLE_POINT\nCompleted a non-global tree search (with a solution) LOCALLY_SOLVED 1 FEASIBLE_POINT FEASIBLE_POINT\nConverged to an infeasible point LOCALLY_INFEASIBLE 1 INFEASIBLE_POINT *\nCompleted a non-global tree search (no solution found) LOCALLY_INFEASIBLE 0 NO_SOLUTION NO_SOLUTION\nIteration limit ITERATION_LIMIT 1 * *\nDiverging iterates NORM_LIMIT or OBJECTIVE_LIMIT 1 * *","category":"page"},{"location":"moi/manual/solutions/#Querying-solution-attributes","page":"Solutions","title":"Querying solution attributes","text":"","category":"section"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"Some solvers will not implement every solution attribute. Therefore, a call like MOI.get(model, MOI.SolveTimeSec()) may throw an UnsupportedAttribute error.","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"If you need to write code that is agnostic to the solver (for example, you are writing a library that an end-user passes their choice of solver to), you can work-around this problem using a try-catch:","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"function get_solve_time(model)\n    try\n        return MOI.get(model, MOI.SolveTimeSec())\n    catch err\n        if err isa MOI.UnsupportedAttribute\n            return NaN  # Solver doesn't support. Return a placeholder value.\n        end\n        rethrow(err)  # Something else went wrong. Rethrow the error\n    end\nend","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"If, after careful profiling, you find that the try-catch is taking a significant portion of your runtime, you can improve performance by caching the result of the try-catch:","category":"page"},{"location":"moi/manual/solutions/","page":"Solutions","title":"Solutions","text":"mutable struct CachedSolveTime{M}\n    model::M\n    supports_solve_time::Bool\n    CachedSolveTime(model::M) where {M} = new(model, true)\nend\n\nfunction get_solve_time(model::CachedSolveTime)\n    if !model.supports_solve_time\n        return NaN\n    end\n    try\n        return MOI.get(model, MOI.SolveTimeSec())\n    catch err\n        if err isa MOI.UnsupportedAttribute\n            model.supports_solve_time = false\n            return NaN\n        end\n        rethrow(err)  # Something else went wrong. Rethrow the error\n    end\nend","category":"page"},{"location":"tutorials/getting_started/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"tutorials/getting_started/introduction/","page":"Introduction","title":"Introduction","text":"The purpose of these \"Getting started\" tutorials is to teach new users the basics of Julia and JuMP.","category":"page"},{"location":"tutorials/getting_started/introduction/#How-these-tutorials-are-structured","page":"Introduction","title":"How these tutorials are structured","text":"","category":"section"},{"location":"tutorials/getting_started/introduction/","page":"Introduction","title":"Introduction","text":"Having a high-level overview of how this part of the documentation is structured will help you know where to look for certain things.","category":"page"},{"location":"tutorials/getting_started/introduction/","page":"Introduction","title":"Introduction","text":"The \"Getting started with\" tutorials are basic introductions to different aspects of JuMP and Julia. If you are new to JuMP and Julia, start by reading them in the following order:\nGetting started with Julia\nGetting started with JuMP\nGetting started with sets and indexing\nGetting started with data and plotting\nJulia has a reputation for being \"fast.\" Unfortunately, it is also easy to write slow Julia code. Performance tips contains a number of important tips on how to improve the performance of models you write in JuMP.\nDesign patterns for larger models is a more advanced tutorial that is aimed at users writing large JuMP models. It's in the \"Getting started\" section to give you an early preview of how JuMP makes it easy to structure larger models. If you are new to JuMP you may want to skip or briefly skim this tutorial, and come back to it once you have written a few JuMP models.","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"EditURL = \"two_stage_stochastic.jl\"","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/#Two-stage-stochastic-programs","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"","category":"section"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"The purpose of this tutorial is to demonstrate how to model and solve a two-stage stochastic program.","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"info: Info\nThe JuMP extension InfiniteOpt.jl can also be used to model and solve two-stage stochastic programs. The JuMP extension SDDP.jl can be used to model and solve multi-stage stochastic programs.","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"This tutorial uses the following packages","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"using JuMP\nimport Distributions\nimport HiGHS\nimport Plots\nimport StatsPlots\nimport Statistics","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/#Background","page":"Two-stage stochastic programs","title":"Background","text":"","category":"section"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"During the week, you are a busy practitioner of Operations Research. To escape the drudgery of mathematics, you decide to open a side business selling creamy mushroom pies with puff pastry. After a few weeks, it quickly becomes apparent that operating a food business is not so easy.","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"The pies must be prepared in the morning, before you open for the day and can gauge the level of demand. If you bake too many, the unsold pies at the end of the day must be discarded and you have wasted time and money on their production. But if you bake too few, then there may be un-served customers and you could have made more money by baking more pies.","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"After a few weeks of poor decision making, you decide to put your knowledge of Operations Research to good use, starting with some data collection.","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"Each pie costs you $2 to make, and you sell them at $5 each. Disposal of an unsold pie costs $0.10. Based on three weeks of data collected, in which you made 200 pies each week, you sold 150, 190, and 200 pies. Thus, as a guess, you assume a triangular distribution of demand with a minimum of 150, a median of 200, and a maximum of 250.","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"We can model this problem by a two-stage stochastic program. In the first stage, we decide a quantity of pies to make x. We make this decision before we observe the demand d_omega. In the second stage, we sell y_omega pies, and incur any costs for unsold pies.","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"We can formulate this problem as follows:","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"beginaligned\nmaxlimits_xy_omega   -2x + mathbbE_omega5y_omega - 01(x - y_omega) \n   y_omega le x               quad forall omega in Omega \n   0 le y_omega le d_omega  quad forall omega in Omega \n   x ge 0\nendaligned","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/#Sample-Average-approximation","page":"Two-stage stochastic programs","title":"Sample Average approximation","text":"","category":"section"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"If the distribution of demand is continuous, then our problem has an infinite number of variables and constraints. To form a computationally tractable problem, we instead use a finite set of samples drawn from the distribution. This is called sample average approximation (SAA).","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"D = Distributions.TriangularDist(150.0, 250.0, 200.0)\nN = 100\nd = sort!(rand(D, N));\nΩ = 1:N\nP = fill(1 / N, N);\nStatsPlots.histogram(d; bins = 20, label = \"\", xlabel = \"Demand\")","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/#JuMP-model","page":"Two-stage stochastic programs","title":"JuMP model","text":"","category":"section"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"The implementation of our two-stage stochastic program in JuMP is:","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, x >= 0)\n@variable(model, 0 <= y[ω in Ω] <= d[ω])\n@constraint(model, [ω in Ω], y[ω] <= x)\n@expression(model, z[ω in Ω], 5y[ω] - 0.1 * (x - y[ω]))\n@objective(model, Max, -2x + sum(P[ω] * z[ω] for ω in Ω))\noptimize!(model)\n@assert is_solved_and_feasible(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"The optimal number of pies to make is:","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"value(x)","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"The distribution of total profit is:","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"total_profit = [-2 * value(x) + value(z[ω]) for ω in Ω]","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"Let's plot it:","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"\"\"\"\n    bin_distribution(x::Vector{Float64}, N::Int)\n\nA helper function that discretizes `x` into bins of width `N`.\n\"\"\"\nbin_distribution(x, N) = N * (floor(minimum(x) / N):ceil(maximum(x) / N))\n\nplot = StatsPlots.histogram(\n    total_profit;\n    bins = bin_distribution(total_profit, 25),\n    label = \"\",\n    xlabel = \"Profit [\\$]\",\n    ylabel = \"Number of outcomes\",\n)\nμ = Statistics.mean(total_profit)\nPlots.vline!(\n    plot,\n    [μ];\n    label = \"Expected profit (\\$$(round(Int, μ)))\",\n    linewidth = 3,\n)\nplot","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/#Risk-measures","page":"Two-stage stochastic programs","title":"Risk measures","text":"","category":"section"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"A risk measure is a function which maps a random variable to a real number. Common risk measures include the mean (expectation), median, mode, and maximum. We need a risk measure to convert the distribution of second stage costs into a single number that can be optimized.","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"Our model currently uses the expectation risk measure, but others are possible too. One popular risk measure is the conditional value at risk (CVaR).","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"CVaR has a parameter gamma, and it computes the expectation of the worst gamma fraction of outcomes.","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"If we are maximizing, so that small outcomes are bad, the definition of CVaR is:","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"CVaR_gammaZ = maxlimits_xi  xi - frac1gammamathbbE_omegaleft(xi - Z)_+right","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"which can be formulated as the linear program:","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"beginaligned\nCVaR_gammaZ = maxlimits_xi z_omega   xi - frac1gammasum P_omega z_omega\n  z_omega ge xi - Z_omega  quad forall omega \n  z_omega ge 0  quad forall omega\nendaligned","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"function CVaR(Z::Vector{Float64}, P::Vector{Float64}; γ::Float64)\n    @assert 0 < γ <= 1\n    N = length(Z)\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    @variable(model, ξ)\n    @variable(model, z[1:N] >= 0)\n    @constraint(model, [i in 1:N], z[i] >= ξ - Z[i])\n    @objective(model, Max, ξ - 1 / γ * sum(P[i] * z[i] for i in 1:N))\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    return objective_value(model)\nend","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"When γ is 1.0, we compute the mean of the profit:","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"cvar_10 = CVaR(total_profit, P; γ = 1.0)","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"Statistics.mean(total_profit)","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"As γ approaches 0.0, we compute the worst-case (minimum) profit:","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"cvar_00 = CVaR(total_profit, P; γ = 0.0001)","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"minimum(total_profit)","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"By varying γ between 0 and 1 we can compute some trade-off of these two extremes:","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"cvar_05 = CVaR(total_profit, P; γ = 0.5)","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"Let's plot these outcomes on our distribution:","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"plot = StatsPlots.histogram(\n    total_profit;\n    bins = bin_distribution(total_profit, 25),\n    label = \"\",\n    xlabel = \"Profit [\\$]\",\n    ylabel = \"Number of outcomes\",\n)\nPlots.vline!(\n    plot,\n    [cvar_10 cvar_05 cvar_00];\n    label = [\"γ = 1.0\" \"γ = 0.5\" \"γ = 0.0\"],\n    linewidth = 3,\n)\nplot","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/#Risk-averse-sample-average-approximation","page":"Two-stage stochastic programs","title":"Risk averse sample average approximation","text":"","category":"section"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"Because CVaR can be formulated as a linear program, we can form a risk averse sample average approximation model by combining the two formulations:","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"γ = 0.4\nmodel = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, x >= 0)\n@variable(model, 0 <= y[ω in Ω] <= d[ω])\n@constraint(model, [ω in Ω], y[ω] <= x)\n@expression(model, Z[ω in Ω], 5 * y[ω] - 0.1(x - y[ω]))\n@variable(model, ξ)\n@variable(model, z[ω in Ω] >= 0)\n@constraint(model, [ω in Ω], z[ω] >= ξ - Z[ω])\n@objective(model, Max, -2x + ξ - 1 / γ * sum(P[ω] * z[ω] for ω in Ω))\noptimize!(model)\n@assert is_solved_and_feasible(model)","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"When gamma = 04, the optimal number of pies to bake is:","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"value(x)","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"The distribution of total profit is:","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"risk_averse_total_profit = [value(-2x + Z[ω]) for ω in Ω]\nbins = bin_distribution([total_profit; risk_averse_total_profit], 25)\nplot = StatsPlots.histogram(total_profit; label = \"Expectation\", bins = bins)\nStatsPlots.histogram!(\n    plot,\n    risk_averse_total_profit;\n    label = \"CV@R\",\n    bins = bins,\n    alpha = 0.5,\n)\nplot","category":"page"},{"location":"tutorials/applications/two_stage_stochastic/#Next-steps","page":"Two-stage stochastic programs","title":"Next steps","text":"","category":"section"},{"location":"tutorials/applications/two_stage_stochastic/","page":"Two-stage stochastic programs","title":"Two-stage stochastic programs","text":"Try solving this problem for different numbers of samples and different distributions.\nRefactor the example to avoid hard-coding the costs. What happens to the solution if the cost of disposing unsold pies increases?\nPlot the optimal number of pies to make for different values of the risk aversion parameter gamma. What is the relationship?","category":"page"},{"location":"packages/solvers/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"packages/solvers/","page":"Introduction","title":"Introduction","text":"This section of the documentation contains brief documentation for some of the solvers that JuMP supports. The list of solvers is not exhaustive, but instead is intended to help you discover commonly used solvers.","category":"page"},{"location":"packages/solvers/#Affiliation","page":"Introduction","title":"Affiliation","text":"","category":"section"},{"location":"packages/solvers/","page":"Introduction","title":"Introduction","text":"Packages beginning with jump-dev/ are developed and maintained by the JuMP developers. In many cases, these packages wrap external solvers that are not developed by the JuMP developers and, while the Julia packages are all open-source, in some cases the solvers themselves are closed source commercial products.","category":"page"},{"location":"packages/solvers/","page":"Introduction","title":"Introduction","text":"Packages that do not begin with jump-dev/ are developed independently. The developers of these packages requested or consented to the inclusion of their README contents in the JuMP documentation for the benefit of users.","category":"page"},{"location":"packages/solvers/#Adding-new-solvers","page":"Introduction","title":"Adding new solvers","text":"","category":"section"},{"location":"packages/solvers/","page":"Introduction","title":"Introduction","text":"Written a solver? Add it to this section of the JuMP documentation by making a pull request to the docs/packages.toml file.","category":"page"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/reference/models.md\"","category":"page"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"moi/reference/models/#Attribute-interface","page":"Models","title":"Attribute interface","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"is_set_by_optimize\nis_copyable\nget\nget!\nset\nsupports\nattribute_value_type","category":"page"},{"location":"moi/reference/models/#MathOptInterface.is_set_by_optimize","page":"Models","title":"MathOptInterface.is_set_by_optimize","text":"is_set_by_optimize(::AnyAttribute)\n\nReturn a Bool indicating whether the value of the attribute is set during an optimize! call, that is, the attribute is used to query the result of the optimization.\n\nIf an attribute can be set by the user, define is_copyable instead.\n\nAn attribute cannot be both is_copyable and is_set_by_optimize.\n\nDefault fallback\n\nThis function returns false by default so it should be implemented for attributes that are set by optimize!.\n\nUndefined behavior\n\nQuerying the value of the attribute that is_set_by_optimize before a call to optimize! is undefined and depends on solver-specific behavior.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.is_copyable","page":"Models","title":"MathOptInterface.is_copyable","text":"is_copyable(::AnyAttribute)\n\nReturn a Bool indicating whether the value of the attribute may be copied during copy_to using set.\n\nIf an attribute is_copyable, then it cannot be modified by the optimizer, and get must always return the value that was set by the user.\n\nIf an attribute is the result of an optimization, define is_set_by_optimize instead.\n\nAn attribute cannot be both is_set_by_optimize and is_copyable.\n\nDefault fallback\n\nBy default is_copyable(attr) returns !is_set_by_optimize(attr), which is most probably true.\n\nIf an attribute should not be copied, define is_copyable(::MyAttribute) = false.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.get","page":"Models","title":"MathOptInterface.get","text":"MOI.get(b::AbstractBridge, ::MOI.NumberOfVariables)::Int64\n\nReturn the number of variables created by the bridge b in the model.\n\nSee also MOI.NumberOfConstraints.\n\nImplementation notes\n\nThere is a default fallback, so you need only implement this if the bridge adds new variables.\n\n\n\n\n\nMOI.get(b::AbstractBridge, ::MOI.ListOfVariableIndices)\n\nReturn the list of variables created by the bridge b.\n\nSee also MOI.ListOfVariableIndices.\n\nImplementation notes\n\nThere is a default fallback, so you need only implement this if the bridge adds new variables.\n\n\n\n\n\nMOI.get(b::AbstractBridge, ::MOI.NumberOfConstraints{F,S})::Int64 where {F,S}\n\nReturn the number of constraints of the type F-in-S created by the bridge b.\n\nSee also MOI.NumberOfConstraints.\n\nImplementation notes\n\nThere is a default fallback, so you need only implement this for the constraint types returned by added_constraint_types.\n\n\n\n\n\nMOI.get(b::AbstractBridge, ::MOI.ListOfConstraintIndices{F,S}) where {F,S}\n\nReturn a  Vector{ConstraintIndex{F,S}} with indices of all constraints of type F-in-S created by the bride b.\n\nSee also MOI.ListOfConstraintIndices.\n\nImplementation notes\n\nThere is a default fallback, so you need only implement this for the constraint types returned by added_constraint_types.\n\n\n\n\n\nfunction MOI.get(\n    model::MOI.ModelLike,\n    attr::MOI.AbstractConstraintAttribute,\n    bridge::AbstractBridge,\n)\n\nReturn the value of the attribute attr of the model model for the constraint bridged by bridge.\n\n\n\n\n\nget(model::GenericModel, attr::MathOptInterface.AbstractOptimizerAttribute)\n\nReturn the value of the attribute attr from the model's MOI backend.\n\n\n\n\n\nget(model::GenericModel, attr::MathOptInterface.AbstractModelAttribute)\n\nReturn the value of the attribute attr from the model's MOI backend.\n\n\n\n\n\nget(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute)\n\nReturn an attribute attr of the optimizer optimizer.\n\nget(model::ModelLike, attr::AbstractModelAttribute)\n\nReturn an attribute attr of the model model.\n\nget(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex)\n\nIf the attribute attr is set for the variable v in the model model, return its value, return nothing otherwise. If the attribute attr is not supported by model then an error should be thrown instead of returning nothing.\n\nget(model::ModelLike, attr::AbstractVariableAttribute, v::Vector{VariableIndex})\n\nReturn a vector of attributes corresponding to each variable in the collection v in the model model.\n\nget(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex)\n\nIf the attribute attr is set for the constraint c in the model model, return its value, return nothing otherwise. If the attribute attr is not supported by model then an error should be thrown instead of returning nothing.\n\nget(\n    model::ModelLike,\n    attr::AbstractConstraintAttribute,\n    c::Vector{ConstraintIndex{F,S}},\n) where {F,S}\n\nReturn a vector of attributes corresponding to each constraint in the collection c in the model model.\n\nget(model::ModelLike, ::Type{VariableIndex}, name::String)\n\nIf a variable with name name exists in the model model, return the corresponding index, otherwise return nothing. Errors if two variables have the same name.\n\nget(\n    model::ModelLike,\n    ::Type{ConstraintIndex{F,S}},\n    name::String,\n) where {F,S}\n\nIf an F-in-S constraint with name name exists in the model model, return the corresponding index, otherwise return nothing. Errors if two constraints have the same name.\n\nget(model::ModelLike, ::Type{ConstraintIndex}, name::String)\n\nIf any constraint with name name exists in the model model, return the corresponding index, otherwise return nothing. This version is available for convenience but may incur a performance penalty because it is not type stable. Errors if two constraints have the same name.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.get!","page":"Models","title":"MathOptInterface.get!","text":"get!(output, model::ModelLike, args...)\n\nAn in-place version of get.\n\nThe signature matches that of get except that the result is placed in the vector output.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.set","page":"Models","title":"MathOptInterface.set","text":"function MOI.set(\n    model::MOI.ModelLike,\n    attr::MOI.AbstractConstraintAttribute,\n    bridge::AbstractBridge,\n    value,\n)\n\nSet the value of the attribute attr of the model model for the constraint bridged by bridge.\n\n\n\n\n\nset(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute, value)\n\nAssign value to the attribute attr of the optimizer optimizer.\n\nset(model::ModelLike, attr::AbstractModelAttribute, value)\n\nAssign value to the attribute attr of the model model.\n\nset(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex, value)\n\nAssign value to the attribute attr of variable v in model model.\n\nset(\n    model::ModelLike,\n    attr::AbstractVariableAttribute,\n    v::Vector{VariableIndex},\n    vector_of_values,\n)\n\nAssign a value respectively to the attribute attr of each variable in the collection v in model model.\n\nset(\n    model::ModelLike,\n    attr::AbstractConstraintAttribute,\n    c::ConstraintIndex,\n    value,\n)\n\nAssign a value to the attribute attr of constraint c in model model.\n\nset(\n    model::ModelLike,\n    attr::AbstractConstraintAttribute,\n    c::Vector{ConstraintIndex{F,S}},\n    vector_of_values,\n) where {F,S}\n\nAssign a value respectively to the attribute attr of each constraint in the collection c in model model.\n\nAn UnsupportedAttribute error is thrown if model does not support the attribute attr (see supports) and a SetAttributeNotAllowed error is thrown if it supports the attribute attr but it cannot be set.\n\nset(\n    model::ModelLike,\n    ::ConstraintSet,\n    c::ConstraintIndex{F,S},\n    set::S,\n) where {F,S}\n\nChange the set of constraint c to the new set set which should be of the same type as the original set.\n\nset(\n    model::ModelLike,\n    ::ConstraintFunction,\n    c::ConstraintIndex{F,S},\n    func::F,\n) where {F,S}\n\nReplace the function in constraint c with func. F must match the original function type used to define the constraint.\n\nnote: Note\nSetting the constraint function is not allowed if F is VariableIndex; a SettingVariableIndexNotAllowed error is thrown instead. This is because, it would require changing the index c since the index of VariableIndex constraints must be the same as the index of the variable.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.supports","page":"Models","title":"MathOptInterface.supports","text":"MOI.supports(\n    model::MOI.ModelLike,\n    attr::MOI.AbstractConstraintAttribute,\n    BT::Type{<:AbstractBridge},\n)\n\nReturn a Bool indicating whether BT supports setting attr to model.\n\n\n\n\n\nsupports(model::ModelLike, sub::AbstractSubmittable)::Bool\n\nReturn a Bool indicating whether model supports the submittable sub.\n\nsupports(model::ModelLike, attr::AbstractOptimizerAttribute)::Bool\n\nReturn a Bool indicating whether model supports the optimizer attribute attr. That is, it returns false if copy_to(model, src) shows a warning in case attr is in the ListOfOptimizerAttributesSet of src; see copy_to for more details on how unsupported optimizer attributes are handled in copy.\n\nsupports(model::ModelLike, attr::AbstractModelAttribute)::Bool\n\nReturn a Bool indicating whether model supports the model attribute attr. That is, it returns false if copy_to(model, src) cannot be performed in case attr is in the ListOfModelAttributesSet of src.\n\nsupports(\n    model::ModelLike,\n    attr::AbstractVariableAttribute,\n    ::Type{VariableIndex},\n)::Bool\n\nReturn a Bool indicating whether model supports the variable attribute attr. That is, it returns false if copy_to(model, src) cannot be performed in case attr is in the ListOfVariableAttributesSet of src.\n\nsupports(\n    model::ModelLike,\n    attr::AbstractConstraintAttribute,\n    ::Type{ConstraintIndex{F,S}},\n)::Bool where {F,S}\n\nReturn a Bool indicating whether model supports the constraint attribute attr applied to an F-in-S constraint. That is, it returns false if copy_to(model, src) cannot be performed in case attr is in the ListOfConstraintAttributesSet of src.\n\nFor all five methods, if the attribute is only not supported in specific circumstances, it should still return true.\n\nNote that supports is only defined for attributes for which is_copyable returns true as other attributes do not appear in the list of attributes set obtained by ListOfXXXAttributesSet.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.attribute_value_type","page":"Models","title":"MathOptInterface.attribute_value_type","text":"attribute_value_type(attr::AnyAttribute)\n\nGiven an attribute attr, return the type of value expected by get, or returned by set.\n\nNotes\n\nOnly implement this if it make sense to do so. If un-implemented, the default is Any.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#Model-interface","page":"Models","title":"Model interface","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"ModelLike\nis_empty\nempty!\nwrite_to_file\nread_from_file\nsupports_incremental_interface\ncopy_to\nIndexMap","category":"page"},{"location":"moi/reference/models/#MathOptInterface.ModelLike","page":"Models","title":"MathOptInterface.ModelLike","text":"ModelLike\n\nAbstract supertype for objects that implement the \"Model\" interface for defining an optimization problem.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.is_empty","page":"Models","title":"MathOptInterface.is_empty","text":"is_empty(model::ModelLike)\n\nReturns false if the model has any model attribute set or has any variables or constraints.\n\nNote that an empty model can have optimizer attributes set.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.empty!","page":"Models","title":"MathOptInterface.empty!","text":"empty!(model::ModelLike)\n\nEmpty the model, that is, remove all variables, constraints and model attributes but not optimizer attributes.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.write_to_file","page":"Models","title":"MathOptInterface.write_to_file","text":"write_to_file(model::ModelLike, filename::String)\n\nWrite the current model to the file at filename.\n\nSupported file types depend on the model type.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.read_from_file","page":"Models","title":"MathOptInterface.read_from_file","text":"read_from_file(model::ModelLike, filename::String)\n\nRead the file filename into the model model. If model is non-empty, this may throw an error.\n\nSupported file types depend on the model type.\n\nNote\n\nOnce the contents of the file are loaded into the model, users can query the variables via get(model, ListOfVariableIndices()). However, some filetypes, such as LP files, do not maintain an explicit ordering of the variables. Therefore, the returned list may be in an arbitrary order.\n\nTo avoid depending on the order of the indices, look up each variable index by name using  get(model, VariableIndex, \"name\").\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.supports_incremental_interface","page":"Models","title":"MathOptInterface.supports_incremental_interface","text":"supports_incremental_interface(model::ModelLike)\n\nReturn a Bool indicating whether model supports building incrementally via add_variable and add_constraint.\n\nThe main purpose of this function is to determine whether a model can be loaded into model incrementally or whether it should be cached and copied at once instead.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.copy_to","page":"Models","title":"MathOptInterface.copy_to","text":"copy_to(dest::ModelLike, src::ModelLike)::IndexMap\n\nCopy the model from src into dest.\n\nThe target dest is emptied, and all previous indices to variables and constraints in dest are invalidated.\n\nReturns an IndexMap object that translates variable and constraint indices from the src model to the corresponding indices in the dest model.\n\nNotes\n\nIf a constraint that in src is not supported by dest, then an UnsupportedConstraint error is thrown.\nIf an AbstractModelAttribute, AbstractVariableAttribute, or AbstractConstraintAttribute is set in src but not supported by dest, then an UnsupportedAttribute error is thrown.\n\nAbstractOptimizerAttributes are not copied  to the dest model.\n\nIndexMap\n\nImplementations of copy_to must return an IndexMap. For technical reasons, this type is defined in the Utilities submodule as MOI.Utilities.IndexMap. However, since it is an integral part of the MOI API, we provide MOI.IndexMap as an alias.\n\nExample\n\n# Given empty `ModelLike` objects `src` and `dest`.\n\nx = add_variable(src)\n\nis_valid(src, x)   # true\nis_valid(dest, x)  # false (`dest` has no variables)\n\nindex_map = copy_to(dest, src)\nis_valid(dest, x) # false (unless index_map[x] == x)\nis_valid(dest, index_map[x]) # true\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.IndexMap","page":"Models","title":"MathOptInterface.IndexMap","text":"IndexMap()\n\nThe dictionary-like object returned by copy_to.\n\nIndexMap\n\nImplementations of copy_to must return an IndexMap. For technical reasons, the IndexMap type is defined in the Utilities submodule as MOI.Utilities.IndexMap. However, since it is an integral part of the MOI API, we provide this MOI.IndexMap as an alias.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#Model-attributes","page":"Models","title":"Model attributes","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"AbstractModelAttribute\nName\nObjectiveFunction\nObjectiveFunctionType\nObjectiveSense\nOptimizationSense\nMIN_SENSE\nMAX_SENSE\nFEASIBILITY_SENSE\nNumberOfVariables\nListOfVariableIndices\nListOfConstraintTypesPresent\nNumberOfConstraints\nListOfConstraintIndices\nListOfOptimizerAttributesSet\nListOfModelAttributesSet\nListOfVariableAttributesSet\nListOfVariablesWithAttributeSet\nListOfConstraintAttributesSet\nListOfConstraintsWithAttributeSet\nUserDefinedFunction\nListOfSupportedNonlinearOperators","category":"page"},{"location":"moi/reference/models/#MathOptInterface.AbstractModelAttribute","page":"Models","title":"MathOptInterface.AbstractModelAttribute","text":"AbstractModelAttribute\n\nAbstract supertype for attribute objects that can be used to set or get attributes (properties) of the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.Name","page":"Models","title":"MathOptInterface.Name","text":"Name()\n\nA model attribute for the string identifying the model. It has a default value of \"\" if not set`.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ObjectiveFunction","page":"Models","title":"MathOptInterface.ObjectiveFunction","text":"ObjectiveFunction{F<:AbstractScalarFunction}()\n\nA model attribute for the objective function which has a type F<:AbstractScalarFunction.\n\nF should be guaranteed to be equivalent but not necessarily identical to the function type provided by the user.\n\nThrows an InexactError if the objective function cannot be converted to F, for example, the objective function is quadratic and F is ScalarAffineFunction{Float64} or it has non-integer coefficient and F is ScalarAffineFunction{Int}.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ObjectiveFunctionType","page":"Models","title":"MathOptInterface.ObjectiveFunctionType","text":"ObjectiveFunctionType()\n\nA model attribute for the type F of the objective function set using the ObjectiveFunction{F} attribute.\n\nExamples\n\nIn the following code, attr should be equal to MOI.VariableIndex:\n\nx = MOI.add_variable(model)\nMOI.set(model, MOI.ObjectiveFunction{MOI.VariableIndex}(), x)\nattr = MOI.get(model, MOI.ObjectiveFunctionType())\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ObjectiveSense","page":"Models","title":"MathOptInterface.ObjectiveSense","text":"ObjectiveSense()\n\nA model attribute for the objective sense of the objective function, which must be an OptimizationSense: MIN_SENSE, MAX_SENSE, or FEASIBILITY_SENSE. The default is FEASIBILITY_SENSE.\n\nInteraction with ObjectiveFunction\n\nSetting the sense to FEASIBILITY_SENSE unsets the ObjectiveFunction attribute. That is, if you first set ObjectiveFunction and then set ObjectiveSense to be FEASIBILITY_SENSE, no objective function will be passed to the solver.\n\nIn addition, some reformulations of ObjectiveFunction via bridges rely on the value of ObjectiveSense. Therefore, you should set ObjectiveSense before setting ObjectiveFunction.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.OptimizationSense","page":"Models","title":"MathOptInterface.OptimizationSense","text":"OptimizationSense\n\nAn enum for the value of the ObjectiveSense attribute.\n\nValues\n\nPossible values are:\n\nMIN_SENSE: the goal is to minimize the objective function\nMAX_SENSE: the goal is to maximize the objective function\nFEASIBILITY_SENSE: the model does not have an objective function\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.MIN_SENSE","page":"Models","title":"MathOptInterface.MIN_SENSE","text":"MIN_SENSE::OptimizationSense\n\nAn instance of the OptimizationSense enum.\n\nMIN_SENSE: the goal is to minimize the objective function\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.MAX_SENSE","page":"Models","title":"MathOptInterface.MAX_SENSE","text":"MAX_SENSE::OptimizationSense\n\nAn instance of the OptimizationSense enum.\n\nMAX_SENSE: the goal is to maximize the objective function\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.FEASIBILITY_SENSE","page":"Models","title":"MathOptInterface.FEASIBILITY_SENSE","text":"FEASIBILITY_SENSE::OptimizationSense\n\nAn instance of the OptimizationSense enum.\n\nFEASIBILITY_SENSE: the model does not have an objective function\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.NumberOfVariables","page":"Models","title":"MathOptInterface.NumberOfVariables","text":"NumberOfVariables()\n\nA model attribute for the number of variables in the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfVariableIndices","page":"Models","title":"MathOptInterface.ListOfVariableIndices","text":"ListOfVariableIndices()\n\nA model attribute for the Vector{VariableIndex} of all variable indices present in the model (that is, of length equal to the value of NumberOfVariables in the order in which they were added.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfConstraintTypesPresent","page":"Models","title":"MathOptInterface.ListOfConstraintTypesPresent","text":"ListOfConstraintTypesPresent()\n\nA model attribute for the list of tuples of the form (F,S), where F is a function type and S is a set type indicating that the attribute NumberOfConstraints{F,S} has a value greater than zero.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.NumberOfConstraints","page":"Models","title":"MathOptInterface.NumberOfConstraints","text":"NumberOfConstraints{F,S}()\n\nA model attribute for the number of constraints of the type F-in-S present in the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfConstraintIndices","page":"Models","title":"MathOptInterface.ListOfConstraintIndices","text":"ListOfConstraintIndices{F,S}()\n\nA model attribute for the Vector{ConstraintIndex{F,S}} of all constraint indices of type F-in-S in the model (that is, of length equal to the value of NumberOfConstraints{F,S}) in the order in which they were added.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfOptimizerAttributesSet","page":"Models","title":"MathOptInterface.ListOfOptimizerAttributesSet","text":"ListOfOptimizerAttributesSet()\n\nAn optimizer attribute for the Vector{AbstractOptimizerAttribute} of all optimizer attributes that were set.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfModelAttributesSet","page":"Models","title":"MathOptInterface.ListOfModelAttributesSet","text":"ListOfModelAttributesSet()\n\nA model attribute for the Vector{AbstractModelAttribute} of all model attributes attr such that:\n\nis_copyable(attr) returns true, and\nthe attribute was set to the model\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfVariableAttributesSet","page":"Models","title":"MathOptInterface.ListOfVariableAttributesSet","text":"ListOfVariableAttributesSet()\n\nA model attribute for the Vector{AbstractVariableAttribute} of all variable attributes attr such that 1) is_copyable(attr) returns true and 2) the attribute was set to variables.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfVariablesWithAttributeSet","page":"Models","title":"MathOptInterface.ListOfVariablesWithAttributeSet","text":"ListOfVariablesWithAttributeSet(attr::AbstractVariableAttribute)\n\nA model attribute for the Vector{VariableIndex} of all variables with the attribute attr set.\n\nThe returned list may not be minimal, so some elements may have their default value set.\n\nNote\n\nThis is an optional attribute to implement. The default fallback is to get ListOfVariableIndices.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfConstraintAttributesSet","page":"Models","title":"MathOptInterface.ListOfConstraintAttributesSet","text":"ListOfConstraintAttributesSet{F, S}()\n\nA model attribute for the Vector{AbstractConstraintAttribute} of all constraint attributes attr such that:\n\nis_copyable(attr) returns true and\nthe attribute was set to F-in-S constraints.\n\nNote\n\nThe attributes ConstraintFunction and ConstraintSet should not be included in the list even if then have been set with set.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfConstraintsWithAttributeSet","page":"Models","title":"MathOptInterface.ListOfConstraintsWithAttributeSet","text":"ListOfConstraintsWithAttributeSet{F,S}(attr:AbstractConstraintAttribute)\n\nA model attribute for the Vector{ConstraintIndex{F,S}} of all constraints with the attribute attr set.\n\nThe returned list may not be minimal, so some elements may have their default value set.\n\nNote\n\nThis is an optional attribute to implement. The default fallback is to get ListOfConstraintIndices.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.UserDefinedFunction","page":"Models","title":"MathOptInterface.UserDefinedFunction","text":"UserDefinedFunction(name::Symbol, arity::Int) <: AbstractModelAttribute\n\nSet this attribute to register a user-defined function by the name of name with arity arguments.\n\nOnce registered, name will appear in ListOfSupportedNonlinearOperators.\n\nYou cannot register multiple UserDefinedFunctions with the same name but different arity.\n\nValue type\n\nThe value to be set is a tuple containing one, two, or three functions to evaluate the function, the first-order derivative, and the second-order derivative respectively. Both derivatives are optional, but if you pass the second-order derivative you must also pass the first-order derivative.\n\nFor univariate functions with arity == 1, the functions in the tuple must have the form:\n\nf(x::T)::T: returns the value of the function at x\n∇f(x::T)::T: returns the first-order derivative of f with respect to x\n∇²f(x::T)::T: returns the second-order derivative of f with respect to x.\n\nFor multivariate functions with arity > 1, the functions in the tuple must have the form:\n\nf(x::T...)::T: returns the value of the function at x\n∇f(g::AbstractVector{T}, x::T...)::Nothing: fills the components of g, with g[i] being the first-order partial derivative of f with respect to x[i]\n∇²f(H::AbstractMatrix{T}, x::T...)::Nothing: fills the non-zero components  of H, with H[i, j] being the second-order partial derivative of f with  respect to x[i] and then x[j]. H is initialized to the zero matrix,  so you do not need to set any zero elements.\n\nExamples\n\njulia> import MathOptInterface as MOI\n\njulia> f(x, y) = x^2 + y^2\nf (generic function with 1 method)\n\njulia> function ∇f(g, x, y)\n           g .= 2 * x, 2 * y\n           return\n       end\n∇f (generic function with 1 method)\n\njulia> function ∇²f(H, x...)\n           H[1, 1] = H[2, 2] = 2.0\n           return\n       end\n∇²f (generic function with 1 method)\n\njulia> model = MOI.Utilities.UniversalFallback(MOI.Utilities.Model{Float64}())\nMOIU.UniversalFallback{MOIU.Model{Float64}}\nfallback for MOIU.Model{Float64}\n\njulia> MOI.set(model, MOI.UserDefinedFunction(:f, 2), (f,))\n\njulia> MOI.set(model, MOI.UserDefinedFunction(:g, 2), (f, ∇f))\n\njulia> MOI.set(model, MOI.UserDefinedFunction(:h, 2), (f, ∇f, ∇²f))\n\njulia> x = MOI.add_variables(model, 2)\n2-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(1)\n MOI.VariableIndex(2)\n\njulia> MOI.set(model, MOI.ObjectiveSense(), MOI.MIN_SENSE)\n\njulia> obj_f = MOI.ScalarNonlinearFunction(:f, Any[x[1], x[2]])\nf(MOI.VariableIndex(1), MOI.VariableIndex(2))\n\njulia> MOI.set(model, MOI.ObjectiveFunction{typeof(obj_f)}(), obj_f)\n\njulia> print(model)\nMinimize ScalarNonlinearFunction:\n f(v[1], v[2])\n\nSubject to:\n\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ListOfSupportedNonlinearOperators","page":"Models","title":"MathOptInterface.ListOfSupportedNonlinearOperators","text":"ListOfSupportedNonlinearOperators() <: AbstractModelAttribute\n\nWhen queried with get, return a Vector{Symbol} listing the operators supported by the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#Optimizer-interface","page":"Models","title":"Optimizer interface","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"AbstractOptimizer\nOptimizerWithAttributes\noptimize!\noptimize!(::ModelLike, ::ModelLike)\ninstantiate\ndefault_cache","category":"page"},{"location":"moi/reference/models/#MathOptInterface.AbstractOptimizer","page":"Models","title":"MathOptInterface.AbstractOptimizer","text":"AbstractOptimizer <: ModelLike\n\nAbstract supertype for objects representing an instance of an optimization problem tied to a particular solver. This is typically a solver's in-memory representation. In addition to ModelLike, AbstractOptimizer objects let you solve the model and query the solution.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.OptimizerWithAttributes","page":"Models","title":"MathOptInterface.OptimizerWithAttributes","text":"struct OptimizerWithAttributes\n    optimizer_constructor\n    params::Vector{Pair{AbstractOptimizerAttribute,<:Any}}\nend\n\nObject grouping an optimizer constructor and a list of optimizer attributes. Instances are created with instantiate.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.optimize!","page":"Models","title":"MathOptInterface.optimize!","text":"optimize!(optimizer::AbstractOptimizer)\n\nOptimize the problem contained in optimizer.\n\nBefore calling optimize!, the problem should first be constructed using the incremental interface (see supports_incremental_interface) or copy_to.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.optimize!-Tuple{MathOptInterface.ModelLike, MathOptInterface.ModelLike}","page":"Models","title":"MathOptInterface.optimize!","text":"optimize!(dest::AbstractOptimizer, src::ModelLike)::Tuple{IndexMap,Bool}\n\nA \"one-shot\" call that copies the problem from src into dest and then uses dest to optimize the problem.\n\nReturns a tuple of an IndexMap and a Bool copied.\n\nThe IndexMap object translates variable and constraint indices from the src model to the corresponding indices in the dest optimizer. See copy_to for details.\nIf copied == true, src was copied to dest and then cached, allowing incremental modification if supported by the solver.\nIf copied == false, a cache of the model was not kept in dest. Therefore, only the solution information (attributes for which is_set_by_optimize is true) is available to query.\n\nnote: Note\nThe main purpose of optimize! method with two arguments is for use in Utilities.CachingOptimizer.\n\nRelationship to the single-argument optimize!\n\nThe default fallback of optimize!(dest::AbstractOptimizer, src::ModelLike) is\n\nfunction optimize!(dest::AbstractOptimizer, src::ModelLike)\n    index_map = copy_to(dest, src)\n    optimize!(dest)\n    return index_map, true\nend\n\nTherefore, subtypes of AbstractOptimizer should either implement this two-argument method, or implement both copy_to(::Optimizer, ::ModelLike) and optimize!(::Optimizer).\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/models/#MathOptInterface.instantiate","page":"Models","title":"MathOptInterface.instantiate","text":"instantiate(\n    optimizer_constructor,\n    with_cache_type::Union{Nothing,Type} = nothing,\n    with_bridge_type::Union{Nothing,Type} = nothing,\n)\n\nCreate an instance of an optimizer by either:\n\ncalling optimizer_constructor.optimizer_constructor() and setting the parameters in optimizer_constructor.params if optimizer_constructor is a OptimizerWithAttributes\ncalling optimizer_constructor() if optimizer_constructor is callable.\n\nwithcachetype\n\nIf with_cache_type is not nothing, then the optimizer is wrapped in a Utilities.CachingOptimizer to store a cache of the model. This is most useful if the optimizer you are constructing does not support the incremental interface (see supports_incremental_interface).\n\nwithbridgetype\n\nIf with_bridge_type is not nothing, the optimizer is wrapped in a Bridges.full_bridge_optimizer, enabling all the bridges defined in the MOI.Bridges submodule with coefficient type with_bridge_type.\n\nIn addition, if the optimizer created by optimizer_constructor does not support the incremental interface (see supports_incremental_interface), then, irrespective of with_cache_type, the optimizer is wrapped in a Utilities.CachingOptimizer to store a cache of the bridged model.\n\nIf with_cache_type and with_bridge_type are both not nothing, then they must be the same type.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.default_cache","page":"Models","title":"MathOptInterface.default_cache","text":"default_cache(optimizer::ModelLike, ::Type{T}) where {T}\n\nReturn a new instance of the default model type to be used as cache for optimizer in a Utilities.CachingOptimizer for holding constraints of coefficient type T. By default, this returns Utilities.UniversalFallback(Utilities.Model{T}()). If copying from a instance of a given model type is faster for optimizer then a new method returning an instance of this model type should be defined.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#Optimizer-attributes","page":"Models","title":"Optimizer attributes","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"AbstractOptimizerAttribute\nSolverName\nSolverVersion\nSilent\nTimeLimitSec\nObjectiveLimit\nSolutionLimit\nRawOptimizerAttribute\nNumberOfThreads\nRawSolver\nAbsoluteGapTolerance\nRelativeGapTolerance\nAutomaticDifferentiationBackend","category":"page"},{"location":"moi/reference/models/#MathOptInterface.AbstractOptimizerAttribute","page":"Models","title":"MathOptInterface.AbstractOptimizerAttribute","text":"AbstractOptimizerAttribute\n\nAbstract supertype for attribute objects that can be used to set or get attributes (properties) of the optimizer.\n\nNotes\n\nThe difference between AbstractOptimizerAttribute and AbstractModelAttribute lies in the behavior of is_empty, empty! and copy_to. Typically optimizer attributes affect only how the model is solved.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.SolverName","page":"Models","title":"MathOptInterface.SolverName","text":"SolverName()\n\nAn optimizer attribute for the string identifying the solver/optimizer.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.SolverVersion","page":"Models","title":"MathOptInterface.SolverVersion","text":"SolverVersion()\n\nAn optimizer attribute for the string identifying the version of the solver.\n\nnote: Note\nFor solvers supporting semantic versioning, the SolverVersion should be a string of the form \"vMAJOR.MINOR.PATCH\", so that it can be converted to a Julia VersionNumber (for example, `VersionNumber(\"v1.2.3\")).We do not require Semantic Versioning because some solvers use alternate versioning systems. For example, CPLEX uses Calendar Versioning, so SolverVersion will return a string like \"202001\".\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.Silent","page":"Models","title":"MathOptInterface.Silent","text":"Silent()\n\nAn optimizer attribute for silencing the output of an optimizer. When set to true, it takes precedence over any other attribute controlling verbosity and requires the solver to produce no output. The default value is false which has no effect. In this case the verbosity is controlled by other attributes.\n\nNote\n\nEvery optimizer should have verbosity on by default. For instance, if a solver has a solver-specific log level attribute, the MOI implementation should set it to 1 by default. If the user sets Silent to true, then the log level should be set to 0, even if the user specifically sets a value of log level. If the value of Silent is false then the log level set to the solver is the value given by the user for this solver-specific parameter or 1 if none is given.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.TimeLimitSec","page":"Models","title":"MathOptInterface.TimeLimitSec","text":"TimeLimitSec()\n\nAn optimizer attribute for setting a time limit (in seconds) for an optimization. When set to nothing, it deactivates the solver time limit. The default value is nothing.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ObjectiveLimit","page":"Models","title":"MathOptInterface.ObjectiveLimit","text":"ObjectiveLimit()\n\nAn optimizer attribute for setting a limit on the objective value.\n\nThe provided limit must be a Union{Real,Nothing}.\n\nWhen set to nothing, the limit reverts to the solver's default.\n\nThe default value is nothing.\n\nThe solver may stop when the ObjectiveValue is better (lower for minimization, higher for maximization) than the ObjectiveLimit. If stopped, the TerminationStatus should be OBJECTIVE_LIMIT.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.SolutionLimit","page":"Models","title":"MathOptInterface.SolutionLimit","text":"SolutionLimit()\n\nAn optimizer attribute for setting a limit on the number of available feasible solutions.\n\nDefault values\n\nThe provided limit must be a Union{Nothing,Int}.\n\nWhen set to nothing, the limit reverts to the solver's default.\n\nThe default value is nothing.\n\nTermination criteria\n\nThe solver may stop when the ResultCount is larger than or equal to the SolutionLimit. If stopped because of this attribute, the TerminationStatus must be SOLUTION_LIMIT.\n\nSolution quality\n\nThe quality of the available solutions is solver-dependent. The set of resulting solutions is not guaranteed to contain an optimal solution.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.RawOptimizerAttribute","page":"Models","title":"MathOptInterface.RawOptimizerAttribute","text":"RawOptimizerAttribute(name::String)\n\nAn optimizer attribute for the solver-specific parameter identified by name.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.NumberOfThreads","page":"Models","title":"MathOptInterface.NumberOfThreads","text":"NumberOfThreads()\n\nAn optimizer attribute for setting the number of threads used for an optimization. When set to nothing uses solver default. Values are positive integers. The default value is nothing.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.RawSolver","page":"Models","title":"MathOptInterface.RawSolver","text":"RawSolver()\n\nA model attribute for the object that may be used to access a solver-specific API for this optimizer.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.AbsoluteGapTolerance","page":"Models","title":"MathOptInterface.AbsoluteGapTolerance","text":"AbsoluteGapTolerance()\n\nAn optimizer attribute for setting the absolute gap tolerance for an optimization. This is an optimizer attribute, and should be set before calling optimize!. When set to nothing (if supported), uses solver default.\n\nTo set a relative gap tolerance, see RelativeGapTolerance.\n\nwarning: Warning\nThe mathematical definition of \"absolute gap\", and its treatment during the optimization, are solver-dependent. However, assuming no other limit nor issue is encountered during the optimization, most solvers that implement this attribute will stop once f - b  g_abs, where b is the best bound, f is the best feasible objective value, and g_abs is the absolute gap.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.RelativeGapTolerance","page":"Models","title":"MathOptInterface.RelativeGapTolerance","text":"RelativeGapTolerance()\n\nAn optimizer attribute for setting the relative gap tolerance for an optimization. This is an optimizer attribute, and should be set before calling optimize!. When set to nothing (if supported), uses solver default.\n\nIf you are looking for the relative gap of the current best solution, see RelativeGap. If no limit nor issue is encountered during the optimization, the value of RelativeGap should be at most as large as RelativeGapTolerance.\n\n# Before optimizing: set relative gap tolerance\n# set 0.1% relative gap tolerance\nMOI.set(model, MOI.RelativeGapTolerance(), 1e-3)\nMOI.optimize!(model)\n\n# After optimizing (assuming all went well)\n# The relative gap tolerance has not changed...\nMOI.get(model, MOI.RelativeGapTolerance())  # returns 1e-3\n# ... and the relative gap of the obtained solution is smaller or equal to the\n# tolerance\nMOI.get(model, MOI.RelativeGap())  # should return something ≤ 1e-3\n\nwarning: Warning\nThe mathematical definition of \"relative gap\", and its allowed range, are solver-dependent. Typically, solvers expect a value between 0.0 and 1.0.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.AutomaticDifferentiationBackend","page":"Models","title":"MathOptInterface.AutomaticDifferentiationBackend","text":"AutomaticDifferentiationBackend() <: AbstractOptimizerAttribute\n\nAn AbstractOptimizerAttribute for setting the automatic differentiation backend used by the solver.\n\nThe value must be a subtype of Nonlinear.AbstractAutomaticDifferentiation.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"List of attributes useful for optimizers","category":"page"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"TerminationStatus\nTerminationStatusCode\nOPTIMIZE_NOT_CALLED\nOPTIMAL\nINFEASIBLE\nDUAL_INFEASIBLE\nLOCALLY_SOLVED\nLOCALLY_INFEASIBLE\nINFEASIBLE_OR_UNBOUNDED\nALMOST_OPTIMAL\nALMOST_INFEASIBLE\nALMOST_DUAL_INFEASIBLE\nALMOST_LOCALLY_SOLVED\nITERATION_LIMIT\nTIME_LIMIT\nNODE_LIMIT\nSOLUTION_LIMIT\nMEMORY_LIMIT\nOBJECTIVE_LIMIT\nNORM_LIMIT\nOTHER_LIMIT\nSLOW_PROGRESS\nNUMERICAL_ERROR\nINVALID_MODEL\nINVALID_OPTION\nINTERRUPTED\nOTHER_ERROR\nPrimalStatus\nDualStatus\nRawStatusString\nResultCount\nObjectiveValue\nDualObjectiveValue\nObjectiveBound\nRelativeGap\nSolveTimeSec\nSimplexIterations\nBarrierIterations\nNodeCount","category":"page"},{"location":"moi/reference/models/#MathOptInterface.TerminationStatus","page":"Models","title":"MathOptInterface.TerminationStatus","text":"TerminationStatus()\n\nA model attribute for the TerminationStatusCode explaining why the optimizer stopped.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.TerminationStatusCode","page":"Models","title":"MathOptInterface.TerminationStatusCode","text":"TerminationStatusCode\n\nAn Enum of possible values for the TerminationStatus attribute. This attribute is meant to explain the reason why the optimizer stopped executing in the most recent call to optimize!.\n\nValues\n\nPossible values are:\n\nOPTIMIZE_NOT_CALLED: The algorithm has not started.\nOPTIMAL: The algorithm found a globally optimal solution.\nINFEASIBLE: The algorithm concluded that no feasible solution exists.\nDUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem. If, additionally, a feasible (primal) solution is known to exist, this status typically implies that the problem is unbounded, with some technical exceptions.\nLOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.\nLOCALLY_INFEASIBLE: The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.\nINFEASIBLE_OR_UNBOUNDED: The algorithm stopped because it decided that the problem is infeasible or unbounded; this occasionally happens during MIP presolve.\nALMOST_OPTIMAL: The algorithm found a globally optimal solution to relaxed tolerances.\nALMOST_INFEASIBLE: The algorithm concluded that no feasible solution exists within relaxed tolerances.\nALMOST_DUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.\nALMOST_LOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.\nITERATION_LIMIT: An iterative algorithm stopped after conducting the maximum number of iterations.\nTIME_LIMIT: The algorithm stopped after a user-specified computation time.\nNODE_LIMIT: A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.\nSOLUTION_LIMIT: The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.\nMEMORY_LIMIT: The algorithm stopped because it ran out of memory.\nOBJECTIVE_LIMIT: The algorithm stopped because it found a solution better than a minimum limit set by the user.\nNORM_LIMIT: The algorithm stopped because the norm of an iterate became too large.\nOTHER_LIMIT: The algorithm stopped due to a limit not covered by one of the _LIMIT_ statuses above.\nSLOW_PROGRESS: The algorithm stopped because it was unable to continue making progress towards the solution.\nNUMERICAL_ERROR: The algorithm stopped because it encountered unrecoverable numerical error.\nINVALID_MODEL: The algorithm stopped because the model is invalid.\nINVALID_OPTION: The algorithm stopped because it was provided an invalid option.\nINTERRUPTED: The algorithm stopped because of an interrupt signal.\nOTHER_ERROR: The algorithm stopped because of an error not covered by one of the statuses defined above.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.OPTIMIZE_NOT_CALLED","page":"Models","title":"MathOptInterface.OPTIMIZE_NOT_CALLED","text":"OPTIMIZE_NOT_CALLED::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nOPTIMIZE_NOT_CALLED: The algorithm has not started.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.OPTIMAL","page":"Models","title":"MathOptInterface.OPTIMAL","text":"OPTIMAL::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nOPTIMAL: The algorithm found a globally optimal solution.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.INFEASIBLE","page":"Models","title":"MathOptInterface.INFEASIBLE","text":"INFEASIBLE::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nINFEASIBLE: The algorithm concluded that no feasible solution exists.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.DUAL_INFEASIBLE","page":"Models","title":"MathOptInterface.DUAL_INFEASIBLE","text":"DUAL_INFEASIBLE::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nDUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem. If, additionally, a feasible (primal) solution is known to exist, this status typically implies that the problem is unbounded, with some technical exceptions.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.LOCALLY_SOLVED","page":"Models","title":"MathOptInterface.LOCALLY_SOLVED","text":"LOCALLY_SOLVED::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nLOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.LOCALLY_INFEASIBLE","page":"Models","title":"MathOptInterface.LOCALLY_INFEASIBLE","text":"LOCALLY_INFEASIBLE::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nLOCALLY_INFEASIBLE: The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.INFEASIBLE_OR_UNBOUNDED","page":"Models","title":"MathOptInterface.INFEASIBLE_OR_UNBOUNDED","text":"INFEASIBLE_OR_UNBOUNDED::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nINFEASIBLE_OR_UNBOUNDED: The algorithm stopped because it decided that the problem is infeasible or unbounded; this occasionally happens during MIP presolve.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.ALMOST_OPTIMAL","page":"Models","title":"MathOptInterface.ALMOST_OPTIMAL","text":"ALMOST_OPTIMAL::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nALMOST_OPTIMAL: The algorithm found a globally optimal solution to relaxed tolerances.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.ALMOST_INFEASIBLE","page":"Models","title":"MathOptInterface.ALMOST_INFEASIBLE","text":"ALMOST_INFEASIBLE::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nALMOST_INFEASIBLE: The algorithm concluded that no feasible solution exists within relaxed tolerances.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.ALMOST_DUAL_INFEASIBLE","page":"Models","title":"MathOptInterface.ALMOST_DUAL_INFEASIBLE","text":"ALMOST_DUAL_INFEASIBLE::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nALMOST_DUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.ALMOST_LOCALLY_SOLVED","page":"Models","title":"MathOptInterface.ALMOST_LOCALLY_SOLVED","text":"ALMOST_LOCALLY_SOLVED::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nALMOST_LOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.ITERATION_LIMIT","page":"Models","title":"MathOptInterface.ITERATION_LIMIT","text":"ITERATION_LIMIT::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nITERATION_LIMIT: An iterative algorithm stopped after conducting the maximum number of iterations.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.TIME_LIMIT","page":"Models","title":"MathOptInterface.TIME_LIMIT","text":"TIME_LIMIT::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nTIME_LIMIT: The algorithm stopped after a user-specified computation time.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.NODE_LIMIT","page":"Models","title":"MathOptInterface.NODE_LIMIT","text":"NODE_LIMIT::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nNODE_LIMIT: A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.SOLUTION_LIMIT","page":"Models","title":"MathOptInterface.SOLUTION_LIMIT","text":"SOLUTION_LIMIT::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nSOLUTION_LIMIT: The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.MEMORY_LIMIT","page":"Models","title":"MathOptInterface.MEMORY_LIMIT","text":"MEMORY_LIMIT::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nMEMORY_LIMIT: The algorithm stopped because it ran out of memory.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.OBJECTIVE_LIMIT","page":"Models","title":"MathOptInterface.OBJECTIVE_LIMIT","text":"OBJECTIVE_LIMIT::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nOBJECTIVE_LIMIT: The algorithm stopped because it found a solution better than a minimum limit set by the user.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.NORM_LIMIT","page":"Models","title":"MathOptInterface.NORM_LIMIT","text":"NORM_LIMIT::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nNORM_LIMIT: The algorithm stopped because the norm of an iterate became too large.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.OTHER_LIMIT","page":"Models","title":"MathOptInterface.OTHER_LIMIT","text":"OTHER_LIMIT::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nOTHER_LIMIT: The algorithm stopped due to a limit not covered by one of the _LIMIT_ statuses above.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.SLOW_PROGRESS","page":"Models","title":"MathOptInterface.SLOW_PROGRESS","text":"SLOW_PROGRESS::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nSLOW_PROGRESS: The algorithm stopped because it was unable to continue making progress towards the solution.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.NUMERICAL_ERROR","page":"Models","title":"MathOptInterface.NUMERICAL_ERROR","text":"NUMERICAL_ERROR::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nNUMERICAL_ERROR: The algorithm stopped because it encountered unrecoverable numerical error.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.INVALID_MODEL","page":"Models","title":"MathOptInterface.INVALID_MODEL","text":"INVALID_MODEL::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nINVALID_MODEL: The algorithm stopped because the model is invalid.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.INVALID_OPTION","page":"Models","title":"MathOptInterface.INVALID_OPTION","text":"INVALID_OPTION::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nINVALID_OPTION: The algorithm stopped because it was provided an invalid option.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.INTERRUPTED","page":"Models","title":"MathOptInterface.INTERRUPTED","text":"INTERRUPTED::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nINTERRUPTED: The algorithm stopped because of an interrupt signal.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.OTHER_ERROR","page":"Models","title":"MathOptInterface.OTHER_ERROR","text":"OTHER_ERROR::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nOTHER_ERROR: The algorithm stopped because of an error not covered by one of the statuses defined above.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.PrimalStatus","page":"Models","title":"MathOptInterface.PrimalStatus","text":"PrimalStatus(result_index::Int = 1)\n\nA model attribute for the ResultStatusCode of the primal result result_index. If result_index is omitted, it defaults to 1.\n\nSee ResultCount for information on how the results are ordered.\n\nIf result_index is larger than the value of ResultCount then NO_SOLUTION is returned.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.DualStatus","page":"Models","title":"MathOptInterface.DualStatus","text":"DualStatus(result_index::Int = 1)\n\nA model attribute for the ResultStatusCode of the dual result result_index. If result_index is omitted, it defaults to 1.\n\nSee ResultCount for information on how the results are ordered.\n\nIf result_index is larger than the value of ResultCount then NO_SOLUTION is returned.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.RawStatusString","page":"Models","title":"MathOptInterface.RawStatusString","text":"RawStatusString()\n\nA model attribute for a solver specific string explaining why the optimizer stopped.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ResultCount","page":"Models","title":"MathOptInterface.ResultCount","text":"ResultCount()\n\nA model attribute for the number of results available.\n\nOrder of solutions\n\nA number of attributes contain an index, result_index, which is used to refer to one of the available results. Thus, result_index must be an integer between 1 and the number of available results.\n\nAs a general rule, the first result (result_index=1) is the most important result (for example, an optimal solution or an infeasibility certificate). Other results will typically be alternate solutions that the solver found during the search for the first result.\n\nIf a (local) optimal solution is available, that is, TerminationStatus is OPTIMAL or LOCALLY_SOLVED, the first result must correspond to the (locally) optimal solution. Other results may be alternative optimal solutions, or they may be other suboptimal solutions; use ObjectiveValue to distinguish between them.\n\nIf a primal or dual infeasibility certificate is available, that is, TerminationStatus is INFEASIBLE or DUAL_INFEASIBLE and the corresponding PrimalStatus or DualStatus is INFEASIBILITY_CERTIFICATE, then the first result must be a certificate. Other results may be alternate certificates, or infeasible points.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ObjectiveValue","page":"Models","title":"MathOptInterface.ObjectiveValue","text":"ObjectiveValue(result_index::Int = 1)\n\nA model attribute for the objective value of the primal solution result_index.\n\nIf the solver does not have a primal value for the objective because the result_index is beyond the available solutions (whose number is indicated by the ResultCount attribute), getting this attribute must throw a ResultIndexBoundsError. Otherwise, if the result is unavailable for another reason (for instance, only a dual solution is available), the result is undefined. Users should first check PrimalStatus before accessing the ObjectiveValue attribute.\n\nSee ResultCount for information on how the results are ordered.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.DualObjectiveValue","page":"Models","title":"MathOptInterface.DualObjectiveValue","text":"DualObjectiveValue(result_index::Int = 1)\n\nA model attribute for the value of the objective function of the dual problem for the result_indexth dual result.\n\nIf the solver does not have a dual value for the objective because the result_index is beyond the available solutions (whose number is indicated by the ResultCount attribute), getting this attribute must throw a ResultIndexBoundsError. Otherwise, if the result is unavailable for another reason (for instance, only a primal solution is available), the result is undefined. Users should first check DualStatus before accessing the DualObjectiveValue attribute.\n\nSee ResultCount for information on how the results are ordered.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ObjectiveBound","page":"Models","title":"MathOptInterface.ObjectiveBound","text":"ObjectiveBound()\n\nA model attribute for the best known bound on the optimal objective value.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.RelativeGap","page":"Models","title":"MathOptInterface.RelativeGap","text":"RelativeGap()\n\nA model attribute for the final relative optimality gap.\n\nwarning: Warning\nThe definition of this gap is solver-dependent. However, most solvers implementing this attribute define the relative gap as some variation of fracb-ff, where b is the best bound and f is the best feasible objective value.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.SolveTimeSec","page":"Models","title":"MathOptInterface.SolveTimeSec","text":"SolveTimeSec()\n\nA model attribute for the total elapsed solution time (in seconds) as reported by the optimizer.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.SimplexIterations","page":"Models","title":"MathOptInterface.SimplexIterations","text":"SimplexIterations()\n\nA model attribute for the cumulative number of simplex iterations during the optimization process.\n\nFor a mixed-integer program (MIP), the return value is the total simplex iterations for all nodes.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.BarrierIterations","page":"Models","title":"MathOptInterface.BarrierIterations","text":"BarrierIterations()\n\nA model attribute for the cumulative number of barrier iterations while solving a problem.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.NodeCount","page":"Models","title":"MathOptInterface.NodeCount","text":"NodeCount()\n\nA model attribute for the total number of branch-and-bound nodes explored while solving a mixed-integer program (MIP).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#ResultStatusCode","page":"Models","title":"ResultStatusCode","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"ResultStatusCode\nNO_SOLUTION\nFEASIBLE_POINT\nNEARLY_FEASIBLE_POINT\nINFEASIBLE_POINT\nINFEASIBILITY_CERTIFICATE\nNEARLY_INFEASIBILITY_CERTIFICATE\nREDUCTION_CERTIFICATE\nNEARLY_REDUCTION_CERTIFICATE\nUNKNOWN_RESULT_STATUS\nOTHER_RESULT_STATUS","category":"page"},{"location":"moi/reference/models/#MathOptInterface.ResultStatusCode","page":"Models","title":"MathOptInterface.ResultStatusCode","text":"ResultStatusCode\n\nAn Enum of possible values for the PrimalStatus and DualStatus attributes.\n\nThe values indicate how to interpret the result vector.\n\nValues\n\nPossible values are:\n\nNO_SOLUTION: the result vector is empty.\nFEASIBLE_POINT: the result vector is a feasible point.\nNEARLY_FEASIBLE_POINT: the result vector is feasible if some constraint tolerances are relaxed.\nINFEASIBLE_POINT: the result vector is an infeasible point.\nINFEASIBILITY_CERTIFICATE: the result vector is an infeasibility certificate. If the PrimalStatus is INFEASIBILITY_CERTIFICATE, then the primal result vector is a certificate of dual infeasibility. If the DualStatus is INFEASIBILITY_CERTIFICATE, then the dual result vector is a proof of primal infeasibility.\nNEARLY_INFEASIBILITY_CERTIFICATE: the result satisfies a relaxed criterion for a certificate of infeasibility.\nREDUCTION_CERTIFICATE: the result vector is an ill-posed certificate; see this article for details. If the PrimalStatus is REDUCTION_CERTIFICATE, then the primal result vector is a proof that the dual problem is ill-posed. If the DualStatus is REDUCTION_CERTIFICATE, then the dual result vector is a proof that the primal is ill-posed.\nNEARLY_REDUCTION_CERTIFICATE: the result satisfies a relaxed criterion for an ill-posed certificate.\nUNKNOWN_RESULT_STATUS: the result vector contains a solution with an unknown interpretation.\nOTHER_RESULT_STATUS: the result vector contains a solution with an interpretation not covered by one of the statuses defined above\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.NO_SOLUTION","page":"Models","title":"MathOptInterface.NO_SOLUTION","text":"NO_SOLUTION::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nNO_SOLUTION: the result vector is empty.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.FEASIBLE_POINT","page":"Models","title":"MathOptInterface.FEASIBLE_POINT","text":"FEASIBLE_POINT::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nFEASIBLE_POINT: the result vector is a feasible point.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.NEARLY_FEASIBLE_POINT","page":"Models","title":"MathOptInterface.NEARLY_FEASIBLE_POINT","text":"NEARLY_FEASIBLE_POINT::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nNEARLY_FEASIBLE_POINT: the result vector is feasible if some constraint tolerances are relaxed.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.INFEASIBLE_POINT","page":"Models","title":"MathOptInterface.INFEASIBLE_POINT","text":"INFEASIBLE_POINT::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nINFEASIBLE_POINT: the result vector is an infeasible point.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.INFEASIBILITY_CERTIFICATE","page":"Models","title":"MathOptInterface.INFEASIBILITY_CERTIFICATE","text":"INFEASIBILITY_CERTIFICATE::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nINFEASIBILITY_CERTIFICATE: the result vector is an infeasibility certificate. If the PrimalStatus is INFEASIBILITY_CERTIFICATE, then the primal result vector is a certificate of dual infeasibility. If the DualStatus is INFEASIBILITY_CERTIFICATE, then the dual result vector is a proof of primal infeasibility.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.NEARLY_INFEASIBILITY_CERTIFICATE","page":"Models","title":"MathOptInterface.NEARLY_INFEASIBILITY_CERTIFICATE","text":"NEARLY_INFEASIBILITY_CERTIFICATE::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nNEARLY_INFEASIBILITY_CERTIFICATE: the result satisfies a relaxed criterion for a certificate of infeasibility.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.REDUCTION_CERTIFICATE","page":"Models","title":"MathOptInterface.REDUCTION_CERTIFICATE","text":"REDUCTION_CERTIFICATE::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nREDUCTION_CERTIFICATE: the result vector is an ill-posed certificate; see this article for details. If the PrimalStatus is REDUCTION_CERTIFICATE, then the primal result vector is a proof that the dual problem is ill-posed. If the DualStatus is REDUCTION_CERTIFICATE, then the dual result vector is a proof that the primal is ill-posed.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.NEARLY_REDUCTION_CERTIFICATE","page":"Models","title":"MathOptInterface.NEARLY_REDUCTION_CERTIFICATE","text":"NEARLY_REDUCTION_CERTIFICATE::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nNEARLY_REDUCTION_CERTIFICATE: the result satisfies a relaxed criterion for an ill-posed certificate.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.UNKNOWN_RESULT_STATUS","page":"Models","title":"MathOptInterface.UNKNOWN_RESULT_STATUS","text":"UNKNOWN_RESULT_STATUS::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nUNKNOWN_RESULT_STATUS: the result vector contains a solution with an unknown interpretation.\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.OTHER_RESULT_STATUS","page":"Models","title":"MathOptInterface.OTHER_RESULT_STATUS","text":"OTHER_RESULT_STATUS::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nOTHER_RESULT_STATUS: the result vector contains a solution with an interpretation not covered by one of the statuses defined above\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#Conflict-Status","page":"Models","title":"Conflict Status","text":"","category":"section"},{"location":"moi/reference/models/","page":"Models","title":"Models","text":"compute_conflict!\nConflictStatus\nConstraintConflictStatus\nConflictStatusCode\nConflictParticipationStatusCode\nNOT_IN_CONFLICT\nIN_CONFLICT\nMAYBE_IN_CONFLICT","category":"page"},{"location":"moi/reference/models/#MathOptInterface.compute_conflict!","page":"Models","title":"MathOptInterface.compute_conflict!","text":"compute_conflict!(optimizer::AbstractOptimizer)\n\nComputes a minimal subset of constraints such that the model with the other constraint removed is still infeasible.\n\nSome solvers call a set of conflicting constraints an Irreducible Inconsistent Subsystem (IIS).\n\nSee also ConflictStatus and ConstraintConflictStatus.\n\nNote\n\nIf the model is modified after a call to compute_conflict!, the implementor is not obliged to purge the conflict. Any calls to the above attributes may return values for the original conflict without a warning. Similarly, when modifying the model, the conflict can be discarded.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/models/#MathOptInterface.ConflictStatus","page":"Models","title":"MathOptInterface.ConflictStatus","text":"ConflictStatus()\n\nA model attribute for the ConflictStatusCode explaining why the conflict refiner stopped when computing the conflict.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ConstraintConflictStatus","page":"Models","title":"MathOptInterface.ConstraintConflictStatus","text":"ConstraintConflictStatus()\n\nA constraint attribute indicating whether the constraint participates in the conflict. Its type is ConflictParticipationStatusCode.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ConflictStatusCode","page":"Models","title":"MathOptInterface.ConflictStatusCode","text":"ConflictStatusCode\n\nAn Enum of possible values for the ConflictStatus attribute. This attribute is meant to explain the reason why the conflict finder stopped executing in the most recent call to compute_conflict!.\n\nPossible values are:\n\nCOMPUTE_CONFLICT_NOT_CALLED: the function compute_conflict! has not yet been called\nNO_CONFLICT_EXISTS: there is no conflict because the problem is feasible\nNO_CONFLICT_FOUND: the solver could not find a conflict\nCONFLICT_FOUND: at least one conflict could be found\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.ConflictParticipationStatusCode","page":"Models","title":"MathOptInterface.ConflictParticipationStatusCode","text":"ConflictParticipationStatusCode\n\nAn Enum of possible values for the ConstraintConflictStatus attribute. This attribute is meant to indicate whether a given constraint participates or not in the last computed conflict.\n\nValues\n\nPossible values are:\n\nNOT_IN_CONFLICT: the constraint does not participate in the conflict\nIN_CONFLICT: the constraint participates in the conflict\nMAYBE_IN_CONFLICT: the constraint may participate in the conflict, the solver was not able to prove that the constraint can be excluded from the conflict\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/models/#MathOptInterface.NOT_IN_CONFLICT","page":"Models","title":"MathOptInterface.NOT_IN_CONFLICT","text":"NOT_IN_CONFLICT::ConflictParticipationStatusCode\n\nAn instance of the ConflictParticipationStatusCode enum.\n\nNOT_IN_CONFLICT: the constraint does not participate in the conflict\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.IN_CONFLICT","page":"Models","title":"MathOptInterface.IN_CONFLICT","text":"IN_CONFLICT::ConflictParticipationStatusCode\n\nAn instance of the ConflictParticipationStatusCode enum.\n\nIN_CONFLICT: the constraint participates in the conflict\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/models/#MathOptInterface.MAYBE_IN_CONFLICT","page":"Models","title":"MathOptInterface.MAYBE_IN_CONFLICT","text":"MAYBE_IN_CONFLICT::ConflictParticipationStatusCode\n\nAn instance of the ConflictParticipationStatusCode enum.\n\nMAYBE_IN_CONFLICT: the constraint may participate in the conflict, the solver was not able to prove that the constraint can be excluded from the conflict\n\n\n\n\n\n","category":"constant"},{"location":"moi/submodules/Nonlinear/reference/","page":"API Reference","title":"API Reference","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/submodules/Nonlinear/reference.md\"","category":"page"},{"location":"moi/submodules/Nonlinear/reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Nonlinear/reference/#NonlinearAPI","page":"API Reference","title":"Nonlinear Modeling","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/reference/","page":"API Reference","title":"API Reference","text":"More information can be found in the Nonlinear section of the manual.","category":"page"},{"location":"moi/submodules/Nonlinear/reference/","page":"API Reference","title":"API Reference","text":"Nonlinear\nNonlinear.Model","category":"page"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear","page":"API Reference","title":"MathOptInterface.Nonlinear","text":"Nonlinear\n\nwarning: Warning\nThe Nonlinear submodule is experimental. Until this message is removed, breaking changes may be introduced in any minor or patch release of MathOptInterface.\n\n\n\n\n\n","category":"module"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.Model","page":"API Reference","title":"MathOptInterface.Nonlinear.Model","text":"Model()\n\nThe core datastructure for representing a nonlinear optimization problem.\n\nIt has the following fields:\n\nobjective::Union{Nothing,Expression} : holds the nonlinear objective function, if one exists, otherwise nothing.\nexpressions::Vector{Expression} : a vector of expressions in the model.\nconstraints::OrderedDict{ConstraintIndex,Constraint} : a map from ConstraintIndex to the corresponding Constraint. An OrderedDict is used instead of a Vector to support constraint deletion.\nparameters::Vector{Float64} : holds the current values of the parameters.\noperators::OperatorRegistry : stores the operators used in the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Nonlinear/reference/#nonlinear_api_expressions","page":"API Reference","title":"Expressions","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/reference/","page":"API Reference","title":"API Reference","text":"Nonlinear.ExpressionIndex\nNonlinear.add_expression","category":"page"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.ExpressionIndex","page":"API Reference","title":"MathOptInterface.Nonlinear.ExpressionIndex","text":"ExpressionIndex\n\nAn index to a nonlinear expression that is returned by add_expression.\n\nGiven data::Model and ex::ExpressionIndex, use data[ex] to retrieve the corresponding Expression.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.add_expression","page":"API Reference","title":"MathOptInterface.Nonlinear.add_expression","text":"add_expression(model::Model, expr)::ExpressionIndex\n\nParse expr into a Expression and add to model. Returns an ExpressionIndex that can be interpolated into other input expressions.\n\nexpr must be a type that is supported by parse_expression.\n\nExamples\n\nmodel = Model()\nx = MOI.VariableIndex(1)\nex = add_expression(model, :($x^2 + 1))\nset_objective(model, :(sqrt($ex)))\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#nonlinear_api_parameters","page":"API Reference","title":"Parameters","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/reference/","page":"API Reference","title":"API Reference","text":"Nonlinear.ParameterIndex\nNonlinear.add_parameter","category":"page"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.ParameterIndex","page":"API Reference","title":"MathOptInterface.Nonlinear.ParameterIndex","text":"ParameterIndex\n\nAn index to a nonlinear parameter that is returned by add_parameter. Given data::Model and p::ParameterIndex, use data[p] to retrieve the current value of the parameter and data[p] = value to set a new value.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.add_parameter","page":"API Reference","title":"MathOptInterface.Nonlinear.add_parameter","text":"add_parameter(model::Model, value::Float64)::ParameterIndex\n\nAdd a new parameter to model with the default value value. Returns a ParameterIndex that can be interpolated into other input expressions and used to modify the value of the parameter.\n\nExamples\n\nmodel = Model()\nx = MOI.VariableIndex(1)\np = add_parameter(model, 1.2)\nc = add_constraint(model, :($x^2 - $p), MOI.LessThan(0.0))\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#nonlinear_api_objectives","page":"API Reference","title":"Objectives","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/reference/","page":"API Reference","title":"API Reference","text":"Nonlinear.set_objective","category":"page"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.set_objective","page":"API Reference","title":"MathOptInterface.Nonlinear.set_objective","text":"set_objective(model::Model, obj)::Nothing\n\nParse obj into a Expression and set as the objective function of model.\n\nobj must be a type that is supported by parse_expression.\n\nTo remove the objective, pass nothing.\n\nExamples\n\nmodel = Model()\nx = MOI.VariableIndex(1)\nset_objective(model, :($x^2 + 1))\nset_objective(model, x)\nset_objective(model, nothing)\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#nonlinear_api_constraints","page":"API Reference","title":"Constraints","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/reference/","page":"API Reference","title":"API Reference","text":"Nonlinear.ConstraintIndex\nNonlinear.add_constraint\nNonlinear.delete","category":"page"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.ConstraintIndex","page":"API Reference","title":"MathOptInterface.Nonlinear.ConstraintIndex","text":"ConstraintIndex\n\nAn index to a nonlinear constraint that is returned by add_constraint.\n\nGiven data::Model and c::ConstraintIndex, use data[c] to retrieve the corresponding Constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.add_constraint","page":"API Reference","title":"MathOptInterface.Nonlinear.add_constraint","text":"add_constraint(\n    model::Model,\n    func,\n    set::Union{\n        MOI.GreaterThan{Float64},\n        MOI.LessThan{Float64},\n        MOI.Interval{Float64},\n        MOI.EqualTo{Float64},\n    },\n)\n\nParse func and set into a Constraint and add to model. Returns a ConstraintIndex that can be used to delete the constraint or query solution information.\n\nExamples\n\nmodel = Model()\nx = MOI.VariableIndex(1)\nc = add_constraint(model, :($x^2), MOI.LessThan(1.0))\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.delete","page":"API Reference","title":"MathOptInterface.Nonlinear.delete","text":"delete(model::Model, c::ConstraintIndex)::Nothing\n\nDelete the constraint index c from model.\n\nExamples\n\nmodel = Model()\nx = MOI.VariableIndex(1)\nc = add_constraint(model, :($x^2), MOI.LessThan(1.0))\ndelete(model, c)\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#nonlinear_api_operators","page":"API Reference","title":"User-defined operators","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/reference/","page":"API Reference","title":"API Reference","text":"Nonlinear.OperatorRegistry\nNonlinear.DEFAULT_UNIVARIATE_OPERATORS\nNonlinear.DEFAULT_MULTIVARIATE_OPERATORS\nNonlinear.register_operator\nNonlinear.register_operator_if_needed\nNonlinear.assert_registered\nNonlinear.check_return_type\nNonlinear.eval_univariate_function\nNonlinear.eval_univariate_gradient\nNonlinear.eval_univariate_hessian\nNonlinear.eval_multivariate_function\nNonlinear.eval_multivariate_gradient\nNonlinear.eval_multivariate_hessian\nNonlinear.eval_logic_function\nNonlinear.eval_comparison_function","category":"page"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.OperatorRegistry","page":"API Reference","title":"MathOptInterface.Nonlinear.OperatorRegistry","text":"OperatorRegistry()\n\nCreate a new OperatorRegistry to store and evaluate univariate and multivariate operators.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.DEFAULT_UNIVARIATE_OPERATORS","page":"API Reference","title":"MathOptInterface.Nonlinear.DEFAULT_UNIVARIATE_OPERATORS","text":"DEFAULT_UNIVARIATE_OPERATORS\n\nThe list of univariate operators that are supported by default.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> MOI.Nonlinear.DEFAULT_UNIVARIATE_OPERATORS\n73-element Vector{Symbol}:\n :+\n :-\n :abs\n :sign\n :sqrt\n :cbrt\n :abs2\n :inv\n :log\n :log10\n ⋮\n :airybi\n :airyaiprime\n :airybiprime\n :besselj0\n :besselj1\n :bessely0\n :bessely1\n :erfcx\n :dawson\n\n\n\n\n\n","category":"constant"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.DEFAULT_MULTIVARIATE_OPERATORS","page":"API Reference","title":"MathOptInterface.Nonlinear.DEFAULT_MULTIVARIATE_OPERATORS","text":"DEFAULT_MULTIVARIATE_OPERATORS\n\nThe list of multivariate operators that are supported by default.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> MOI.Nonlinear.DEFAULT_MULTIVARIATE_OPERATORS\n9-element Vector{Symbol}:\n :+\n :-\n :*\n :^\n :/\n :ifelse\n :atan\n :min\n :max\n\n\n\n\n\n","category":"constant"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.register_operator","page":"API Reference","title":"MathOptInterface.Nonlinear.register_operator","text":"register_operator(\n    model::Model,\n    op::Symbol,\n    nargs::Int,\n    f::Function,\n    [∇f::Function],\n    [∇²f::Function],\n)\n\nRegister the user-defined operator op with nargs input arguments in model.\n\nUnivariate functions\n\nf(x::T)::T must be a function that takes a single input argument x and returns the function evaluated at x. If ∇f and ∇²f are not provided, f must support any Real input type T.\n∇f(x::T)::T is a function that takes a single input argument x and returns the first derivative of f with respect to x. If ∇²f is not provided, ∇f must support any Real input type T.\n∇²f(x::T)::T is a function that takes a single input argument x and returns the second derivative of f with respect to x.\n\nMultivariate functions\n\nf(x::T...)::T must be a function that takes a nargs input arguments x and returns the function evaluated at x. If ∇f and ∇²f are not provided, f must support any Real input type T.\n∇f(g::AbstractVector{T}, x::T...)::T is a function that takes a cache vector g of length length(x), and fills each element g[i] with the partial derivative of f with respect to x[i].\n∇²f(H::AbstractMatrix, x::T...)::T is a function that takes a matrix H and fills the lower-triangular components H[i, j] with the Hessian of f with respect to x[i] and x[j] for i >= j.\n\nNotes for multivariate Hessians\n\nH has size(H) == (length(x), length(x)), but you must not access elements H[i, j] for i > j.\nH is dense, but you do not need to fill structural zeros.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.register_operator_if_needed","page":"API Reference","title":"MathOptInterface.Nonlinear.register_operator_if_needed","text":"register_operator_if_needed(\n    registry::OperatorRegistry,\n    op::Symbol,\n    nargs::Int,\n    f::Function;\n)\n\nSimilar to register_operator, but this function warns if the function is not registered, and skips silently if it already is.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.assert_registered","page":"API Reference","title":"MathOptInterface.Nonlinear.assert_registered","text":"assert_registered(registry::OperatorRegistry, op::Symbol, nargs::Int)\n\nThrow an error if op is not registered in registry with nargs arguments.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.check_return_type","page":"API Reference","title":"MathOptInterface.Nonlinear.check_return_type","text":"check_return_type(::Type{T}, ret::S) where {T,S}\n\nOverload this method for new types S to throw an informative error if a user-defined function returns the type S instead of T.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.eval_univariate_function","page":"API Reference","title":"MathOptInterface.Nonlinear.eval_univariate_function","text":"eval_univariate_function(\n    registry::OperatorRegistry,\n    op::Symbol,\n    x::T,\n) where {T}\n\nEvaluate the operator op(x)::T, where op is a univariate function in registry.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.eval_univariate_gradient","page":"API Reference","title":"MathOptInterface.Nonlinear.eval_univariate_gradient","text":"eval_univariate_gradient(\n    registry::OperatorRegistry,\n    op::Symbol,\n    x::T,\n) where {T}\n\nEvaluate the first-derivative of the operator op(x)::T, where op is a univariate function in registry.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.eval_univariate_hessian","page":"API Reference","title":"MathOptInterface.Nonlinear.eval_univariate_hessian","text":"eval_univariate_hessian(\n    registry::OperatorRegistry,\n    op::Symbol,\n    x::T,\n) where {T}\n\nEvaluate the second-derivative of the operator op(x)::T, where op is a univariate function in registry.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.eval_multivariate_function","page":"API Reference","title":"MathOptInterface.Nonlinear.eval_multivariate_function","text":"eval_multivariate_function(\n    registry::OperatorRegistry,\n    op::Symbol,\n    x::AbstractVector{T},\n) where {T}\n\nEvaluate the operator op(x)::T, where op is a multivariate function in registry.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.eval_multivariate_gradient","page":"API Reference","title":"MathOptInterface.Nonlinear.eval_multivariate_gradient","text":"eval_multivariate_gradient(\n    registry::OperatorRegistry,\n    op::Symbol,\n    g::AbstractVector{T},\n    x::AbstractVector{T},\n) where {T}\n\nEvaluate the gradient of operator g .= ∇op(x), where op is a multivariate function in registry.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.eval_multivariate_hessian","page":"API Reference","title":"MathOptInterface.Nonlinear.eval_multivariate_hessian","text":"eval_multivariate_hessian(\n    registry::OperatorRegistry,\n    op::Symbol,\n    H::AbstractMatrix,\n    x::AbstractVector{T},\n) where {T}\n\nEvaluate the Hessian of operator ∇²op(x), where op is a multivariate function in registry.\n\nThe Hessian is stored in the lower-triangular part of the matrix H.\n\nnote: Note\nImplementations of the Hessian operators will not fill structural zeros. Therefore, before calling this function you should pre-populate the matrix H with 0.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.eval_logic_function","page":"API Reference","title":"MathOptInterface.Nonlinear.eval_logic_function","text":"eval_logic_function(\n    registry::OperatorRegistry,\n    op::Symbol,\n    lhs::T,\n    rhs::T,\n)::Bool where {T}\n\nEvaluate (lhs op rhs)::Bool, where op is a logic operator in registry.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.eval_comparison_function","page":"API Reference","title":"MathOptInterface.Nonlinear.eval_comparison_function","text":"eval_comparison_function(\n    registry::OperatorRegistry,\n    op::Symbol,\n    lhs::T,\n    rhs::T,\n)::Bool where {T}\n\nEvaluate (lhs op rhs)::Bool, where op is a comparison operator in registry.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#Automatic-differentiation-backends","page":"API Reference","title":"Automatic-differentiation backends","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/reference/","page":"API Reference","title":"API Reference","text":"Nonlinear.Evaluator\nNonlinear.AbstractAutomaticDifferentiation\nNonlinear.ExprGraphOnly\nNonlinear.SparseReverseMode","category":"page"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.Evaluator","page":"API Reference","title":"MathOptInterface.Nonlinear.Evaluator","text":"Evaluator(\n    model::Model,\n    backend::AbstractAutomaticDifferentiation,\n    ordered_variables::Vector{MOI.VariableIndex},\n)\n\nCreate Evaluator, a subtype of MOI.AbstractNLPEvaluator, from Model.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.AbstractAutomaticDifferentiation","page":"API Reference","title":"MathOptInterface.Nonlinear.AbstractAutomaticDifferentiation","text":"AbstractAutomaticDifferentiation\n\nAn abstract type for extending Evaluator.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.ExprGraphOnly","page":"API Reference","title":"MathOptInterface.Nonlinear.ExprGraphOnly","text":"ExprGraphOnly() <: AbstractAutomaticDifferentiation\n\nThe default implementation of AbstractAutomaticDifferentiation. The only supported feature is :ExprGraph.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.SparseReverseMode","page":"API Reference","title":"MathOptInterface.Nonlinear.SparseReverseMode","text":"SparseReverseMode() <: AbstractAutomaticDifferentiation\n\nAn implementation of AbstractAutomaticDifferentiation that uses sparse reverse-mode automatic differentiation to compute derivatives. Supports all features in the MOI nonlinear interface.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Nonlinear/reference/#Data-structure","page":"API Reference","title":"Data-structure","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/reference/","page":"API Reference","title":"API Reference","text":"Nonlinear.Node\nNonlinear.NodeType\nNonlinear.Expression\nNonlinear.Constraint\nNonlinear.adjacency_matrix\nNonlinear.parse_expression\nNonlinear.convert_to_expr\nNonlinear.ordinal_index","category":"page"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.Node","page":"API Reference","title":"MathOptInterface.Nonlinear.Node","text":"struct Node\n    type::NodeType\n    index::Int\n    parent::Int\nend\n\nA single node in a nonlinear expression tree. Used by Expression.\n\nSee the MathOptInterface documentation for information on how the nodes and values form an expression tree.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.NodeType","page":"API Reference","title":"MathOptInterface.Nonlinear.NodeType","text":"NodeType\n\nAn enum describing the possible node types. Each Node has a .index field, which should be interpreted as follows:\n\nNODE_CALL_MULTIVARIATE: the index into operators.multivariate_operators\nNODE_CALL_UNIVARIATE: the index into operators.univariate_operators\nNODE_LOGIC: the index into operators.logic_operators\nNODE_COMPARISON: the index into operators.comparison_operators\nNODE_MOI_VARIABLE: the value of MOI.VariableIndex(index) in the user's space of the model.\nNODE_VARIABLE: the 1-based index of the internal vector\nNODE_VALUE: the index into the .values field of Expression\nNODE_PARAMETER: the index into data.parameters\nNODE_SUBEXPRESSION:  the index into data.expressions\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.Expression","page":"API Reference","title":"MathOptInterface.Nonlinear.Expression","text":"struct Expression\n    nodes::Vector{Node}\n    values::Vector{Float64}\nend\n\nThe core type that represents a nonlinear expression. See the MathOptInterface documentation for information on how the nodes and values form an expression tree.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.Constraint","page":"API Reference","title":"MathOptInterface.Nonlinear.Constraint","text":"struct Constraint\n    expression::Expression\n    set::Union{\n        MOI.LessThan{Float64},\n        MOI.GreaterThan{Float64},\n        MOI.EqualTo{Float64},\n        MOI.Interval{Float64},\n    }\nend\n\nA type to hold information relating to the nonlinear constraint f(x) in S, where f(x) is defined by .expression, and S is .set.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.adjacency_matrix","page":"API Reference","title":"MathOptInterface.Nonlinear.adjacency_matrix","text":"adjacency_matrix(nodes::Vector{Node})\n\nCompute the sparse adjacency matrix describing the parent-child relationships in nodes.\n\nThe element (i, j) is true if there is an edge from node[j] to node[i]. Since we get a column-oriented matrix, this gives us a fast way to look up the edges leaving any node (that is, the children).\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.parse_expression","page":"API Reference","title":"MathOptInterface.Nonlinear.parse_expression","text":"parse_expression(data::Model, input)::Expression\n\nParse input into a Expression.\n\n\n\n\n\nparse_expression(\n    data::Model,\n    expr::Expression,\n    input::Any,\n    parent_index::Int,\n)::Expression\n\nParse input into a Expression, and add it to expr as a child of expr.nodes[parent_index]. Existing subexpressions and parameters are stored in data.\n\nYou can extend parsing support to new types of objects by overloading this method with a different type on input::Any.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.convert_to_expr","page":"API Reference","title":"MathOptInterface.Nonlinear.convert_to_expr","text":"convert_to_expr(data::Model, expr::Expression)\n\nConvert the Expression expr into a Julia Expr.\n\nsubexpressions are represented by a ExpressionIndex object.\nparameters are represented by a ParameterIndex object.\nvariables are represented by an MOI.VariableIndex object.\n\n\n\n\n\nconvert_to_expr(\n    evaluator::Evaluator,\n    expr::Expression;\n    moi_output_format::Bool,\n)\n\nConvert the Expression expr into a Julia Expr.\n\nIf moi_output_format = true:\n\nsubexpressions will be converted to Julia Expr and substituted into the output expression.\nthe current value of each parameter will be interpolated into the expression\nvariables will be represented in the form x[MOI.VariableIndex(i)]\n\nIf moi_output_format = false:\n\nsubexpressions will be represented by a ExpressionIndex object.\nparameters will be represented by a ParameterIndex object.\nvariables will be represented by an MOI.VariableIndex object.\n\nwarning: Warning\nTo use moi_output_format = true, you must have first called MOI.initialize with :ExprGraph as a requested feature.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Nonlinear/reference/#MathOptInterface.Nonlinear.ordinal_index","page":"API Reference","title":"MathOptInterface.Nonlinear.ordinal_index","text":"ordinal_index(evaluator::Evaluator, c::ConstraintIndex)::Int\n\nReturn the 1-indexed value of the constraint index c in evaluator.\n\nExamples\n\nmodel = Model()\nx = MOI.VariableIndex(1)\nc1 = add_constraint(model, :($x^2), MOI.LessThan(1.0))\nc2 = add_constraint(model, :($x^2), MOI.LessThan(1.0))\nevaluator = Evaluator(model)\nMOI.initialize(evaluator, Symbol[])\nordinal_index(evaluator, c2)  # Returns 2\ndelete(model, c1)\nevaluator = Evaluator(model)\nMOI.initialize(evaluator, Symbol[])\nordinal_index(model, c2)  # Returns 1\n\n\n\n\n\n","category":"function"},{"location":"packages/Juniper/","page":"lanl-ansi/Juniper.jl","title":"lanl-ansi/Juniper.jl","text":"EditURL = \"https://github.com/lanl-ansi/Juniper.jl/blob/v0.9.2/README.md\"","category":"page"},{"location":"packages/Juniper/#Juniper","page":"lanl-ansi/Juniper.jl","title":"Juniper","text":"","category":"section"},{"location":"packages/Juniper/","page":"lanl-ansi/Juniper.jl","title":"lanl-ansi/Juniper.jl","text":"(Image: CI) (Image: codecov) (Image: Documentation)","category":"page"},{"location":"packages/Juniper/","page":"lanl-ansi/Juniper.jl","title":"lanl-ansi/Juniper.jl","text":"Juniper (Jump Nonlinear Integer Program solver) is a solver for mixed-integer nonlinear programs. ","category":"page"},{"location":"packages/Juniper/","page":"lanl-ansi/Juniper.jl","title":"lanl-ansi/Juniper.jl","text":"It is a heuristic which is not guaranteed to find the global optimum. If you need the global optimum, check out Alpine.","category":"page"},{"location":"packages/Juniper/#Installation","page":"lanl-ansi/Juniper.jl","title":"Installation","text":"","category":"section"},{"location":"packages/Juniper/","page":"lanl-ansi/Juniper.jl","title":"lanl-ansi/Juniper.jl","text":"Install Juniper using the Julia package manager:","category":"page"},{"location":"packages/Juniper/","page":"lanl-ansi/Juniper.jl","title":"lanl-ansi/Juniper.jl","text":"import Pkg\nPkg.add(\"JuMP\")","category":"page"},{"location":"packages/Juniper/#Use-with-JuMP","page":"lanl-ansi/Juniper.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/Juniper/","page":"lanl-ansi/Juniper.jl","title":"lanl-ansi/Juniper.jl","text":"Use Juniper with JuMP as follows:","category":"page"},{"location":"packages/Juniper/","page":"lanl-ansi/Juniper.jl","title":"lanl-ansi/Juniper.jl","text":"using JuMP, Juniper, Ipopt\nipopt = optimizer_with_attributes(Ipopt.Optimizer, \"print_level\"=>0)\noptimizer = optimizer_with_attributes(Juniper.Optimizer, \"nl_solver\"=>ipopt)\nmodel = Model(optimizer)\nv = [10, 20, 12, 23, 42]\nw = [12, 45, 12, 22, 21]\n@variable(model, x[1:5], Bin)\n@objective(model, Max, v' * x)\n@constraint(model, sum(w[i]*x[i]^2 for i in 1:5) <= 45)\noptimize!(model)\nprintln(termination_status(model))\nprintln(objective_value(model))\nprintln(value.(x))","category":"page"},{"location":"packages/Juniper/","page":"lanl-ansi/Juniper.jl","title":"lanl-ansi/Juniper.jl","text":"The nl_solver is used by Juniper to solve continuous nonlinear sub-problems while Juniper searches for acceptable assignments to the discrete variables. A common choice is Ipopt, but any optimizer that supports the continuous relaxation of the model may be used.","category":"page"},{"location":"packages/Juniper/","page":"lanl-ansi/Juniper.jl","title":"lanl-ansi/Juniper.jl","text":"To solve problems with more complex nonlinear functions, use the @NLconstraint and @NLobjective JuMP macros.","category":"page"},{"location":"packages/Juniper/#Documentation","page":"lanl-ansi/Juniper.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/Juniper/","page":"lanl-ansi/Juniper.jl","title":"lanl-ansi/Juniper.jl","text":"The online documentation is available at https://lanl-ansi.github.io/Juniper.jl/stable/.","category":"page"},{"location":"packages/Juniper/#Feasibility-pump","page":"lanl-ansi/Juniper.jl","title":"Feasibility pump","text":"","category":"section"},{"location":"packages/Juniper/","page":"lanl-ansi/Juniper.jl","title":"lanl-ansi/Juniper.jl","text":"If Juniper has difficulty finding feasible solutions on your model, try adding a solver that supports integer variables (for example, HiGHS) to run a feasibility pump:","category":"page"},{"location":"packages/Juniper/","page":"lanl-ansi/Juniper.jl","title":"lanl-ansi/Juniper.jl","text":"using JuMP, Juniper, Ipopt, HiGHS\nipopt = optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0)\nhighs = optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => false)\nmodel = Model(\n    optimizer_with_attributes(\n        Juniper.Optimizer,\n        \"nl_solver\" => ipopt,\n        \"mip_solver\" => highs,\n    ),\n)","category":"page"},{"location":"packages/Juniper/","page":"lanl-ansi/Juniper.jl","title":"lanl-ansi/Juniper.jl","text":"The feasibility pump is used at the start of Juniper to find a feasible solution before the branch and bound part starts.  For some classes of problems this can be a highly effective pre-processor.","category":"page"},{"location":"packages/Juniper/#Citing-Juniper","page":"lanl-ansi/Juniper.jl","title":"Citing Juniper","text":"","category":"section"},{"location":"packages/Juniper/","page":"lanl-ansi/Juniper.jl","title":"lanl-ansi/Juniper.jl","text":"If you find Juniper useful in your work, we kindly request that you cite the following paper or technical report:","category":"page"},{"location":"packages/Juniper/","page":"lanl-ansi/Juniper.jl","title":"lanl-ansi/Juniper.jl","text":"@inproceedings{juniper,\n     Author = {Ole Kröger and Carleton Coffrin and Hassan Hijazi and Harsha Nagarajan},\n     Title = {Juniper: An Open-Source Nonlinear Branch-and-Bound Solver in Julia},\n     booktitle=\"Integration of Constraint Programming, Artificial Intelligence, and Operations Research\",\n     pages=\"377--386\",\n     year=\"2018\",\n     publisher=\"Springer International Publishing\",\n     isbn=\"978-3-319-93031-2\"\n}","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"EditURL = \"diet.jl\"","category":"page"},{"location":"tutorials/linear/diet/#The-diet-problem","page":"The diet problem","title":"The diet problem","text":"","category":"section"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"The purpose of this tutorial is to demonstrate how to incorporate DataFrames into a JuMP model. As an example, we use classic Stigler diet problem.","category":"page"},{"location":"tutorials/linear/diet/#Required-packages","page":"The diet problem","title":"Required packages","text":"","category":"section"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"This tutorial requires the following packages:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"using JuMP\nimport CSV\nimport DataFrames\nimport HiGHS\nimport Test","category":"page"},{"location":"tutorials/linear/diet/#Formulation","page":"The diet problem","title":"Formulation","text":"","category":"section"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"We wish to cook a nutritionally balanced meal by choosing the quantity of each food f to eat from a set of foods F in our kitchen.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Each food f has a cost, c_f, as well as a macro-nutrient profile a_mf for each macro-nutrient m in M.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Because we care about a nutritionally balanced meal, we set some minimum and maximum limits for each nutrient, which we denote l_m and u_m respectively.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Furthermore, because we are optimizers, we seek the minimum cost solution.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"With a little effort, we can formulate our dinner problem as the following linear program:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"beginaligned\nmin  sumlimits_f in F c_f x_f \ntextst   l_m le sumlimits_f in F a_mf x_f le u_m  forall m in M \n x_f ge 0  forall f in F\nendaligned","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"In the rest of this tutorial, we will create and solve this problem in JuMP, and learn what we should cook for dinner.","category":"page"},{"location":"tutorials/linear/diet/#Data","page":"The diet problem","title":"Data","text":"","category":"section"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"First, we need some data for the problem. For this tutorial, we'll write CSV files to a temporary directory from Julia. If you have existing files, you could change the filenames to point to them instead.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"dir = mktempdir()","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"The first file is a list of foods with their macro-nutrient profile:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"food_csv_filename = joinpath(dir, \"diet_foods.csv\")\nopen(food_csv_filename, \"w\") do io\n    write(\n        io,\n        \"\"\"\n        name,cost,calories,protein,fat,sodium\n        hamburger,2.49,410,24,26,730\n        chicken,2.89,420,32,10,1190\n        hot dog,1.50,560,20,32,1800\n        fries,1.89,380,4,19,270\n        macaroni,2.09,320,12,10,930\n        pizza,1.99,320,15,12,820\n        salad,2.49,320,31,12,1230\n        milk,0.89,100,8,2.5,125\n        ice cream,1.59,330,8,10,180\n        \"\"\",\n    )\n    return\nend\nfoods = CSV.read(food_csv_filename, DataFrames.DataFrame)","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Here, F is foods.name and c_f is foods.cost. (We're also playing a bit loose the term \"macro-nutrient\" by including calories and sodium.)","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"We also need our minimum and maximum limits:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"nutrient_csv_filename = joinpath(dir, \"diet_nutrient.csv\")\nopen(nutrient_csv_filename, \"w\") do io\n    write(\n        io,\n        \"\"\"\n        nutrient,min,max\n        calories,1800,2200\n        protein,91,\n        fat,0,65\n        sodium,0,1779\n        \"\"\",\n    )\n    return\nend\nlimits = CSV.read(nutrient_csv_filename, DataFrames.DataFrame)","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Protein is missing data for the maximum. Let's fix that using coalesce:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"limits.max = coalesce.(limits.max, Inf)\nlimits","category":"page"},{"location":"tutorials/linear/diet/#JuMP-formulation","page":"The diet problem","title":"JuMP formulation","text":"","category":"section"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Now we're ready to convert our mathematical formulation into a JuMP model.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"First, create a new JuMP model. Since we have a linear program, we'll use HiGHS as our optimizer:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Next, we create a set of decision variables x, with one element for each row in the DataFrame, and each x has a lower bound of 0:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"@variable(model, x[foods.name] >= 0)","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"To simplify things later on, we store the vector as a new column x in the DataFrame foods. Since x is a DenseAxisArray, we first need to convert it to an Array:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"foods.x = Array(x)","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Our objective is to minimize the total cost of purchasing food:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"@objective(model, Min, sum(foods.cost .* foods.x));\nnothing #hide","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"For the next component, we need to add a constraint that our total intake of each component is within the limits contained in the limits DataFrame:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"@constraint(\n    model,\n    [row in eachrow(limits)],\n    row.min <= sum(foods[!, row.nutrient] .* foods.x) <= row.max,\n);\nnothing #hide","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"What does our model look like?","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"print(model)","category":"page"},{"location":"tutorials/linear/diet/#Solution","page":"The diet problem","title":"Solution","text":"","category":"section"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"Let's optimize and take a look at the solution:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"optimize!(model)\n@assert is_solved_and_feasible(model)\nTest.@test objective_value(model) ≈ 11.8288 atol = 1e-4  #hide\nsolution_summary(model)","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"We found an optimal solution. Let's see what the optimal solution is:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"for row in eachrow(foods)\n    println(row.name, \" = \", value(row.x))\nend","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"That's a lot of milk and ice cream, and sadly, we only get 0.6 of a hamburger.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"We can also use the function Containers.rowtable to easily convert the result into a DataFrame:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"table = Containers.rowtable(value, x; header = [:food, :quantity])\nsolution = DataFrames.DataFrame(table)","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"This makes it easy to perform analyses our solution:","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"filter!(row -> row.quantity > 0.0, solution)","category":"page"},{"location":"tutorials/linear/diet/#Problem-modification","page":"The diet problem","title":"Problem modification","text":"","category":"section"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"JuMP makes it easy to take an existing model and modify it by adding extra constraints. Let's see what happens if we add a constraint that we can buy at most 6 units of milk or ice cream combined.","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"dairy_foods = [\"milk\", \"ice cream\"]\nis_dairy = map(name -> name in dairy_foods, foods.name)\ndairy_constraint = @constraint(model, sum(foods[is_dairy, :x]) <= 6)\noptimize!(model)\nTest.@test !is_solved_and_feasible(model)\nTest.@test termination_status(model) == INFEASIBLE\nTest.@test primal_status(model) == NO_SOLUTION\nsolution_summary(model)","category":"page"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"There exists no feasible solution to our problem. Looks like we're stuck eating ice cream for dinner.","category":"page"},{"location":"tutorials/linear/diet/#Next-steps","page":"The diet problem","title":"Next steps","text":"","category":"section"},{"location":"tutorials/linear/diet/","page":"The diet problem","title":"The diet problem","text":"You can delete a constraint using delete(model, dairy_constraint). Can you add a different constraint to provide a diet with less dairy?\nSome food items (like hamburgers) are discrete. You can use set_integer to force a variable to take integer values. What happens to the solution if you do?","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"EditURL = \"n-queens.jl\"","category":"page"},{"location":"tutorials/linear/n-queens/#N-Queens","page":"N-Queens","title":"N-Queens","text":"","category":"section"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"This tutorial was originally contributed by Matthew Helm and Mathieu Tanneau.","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"The N-Queens problem involves placing N queens on an N x N chessboard such that none of the queens attacks another. In chess, a queen can move vertically, horizontally, and diagonally so there cannot be more than one queen on any given row, column, or diagonal.","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"(Image: Four Queens)","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"Note that none of the queens above are able to attack any other as a result of their careful placement.","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"using JuMP\nimport HiGHS\nimport LinearAlgebra","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"N-Queens","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"N = 8\n\nmodel = Model(HiGHS.Optimizer)\nset_silent(model)","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"Next, let's create an N x N chessboard of binary values. 0 will represent an empty space on the board and 1 will represent a space occupied by one of our queens:","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"@variable(model, x[1:N, 1:N], Bin);\nnothing #hide","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"Now we can add our constraints:","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"There must be exactly one queen in a given row/column","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"for i in 1:N\n    @constraint(model, sum(x[i, :]) == 1)\n    @constraint(model, sum(x[:, i]) == 1)\nend","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"There can only be one queen on any given diagonal","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"for i in -(N - 1):(N-1)\n    @constraint(model, sum(LinearAlgebra.diag(x, i)) <= 1)\n    @constraint(model, sum(LinearAlgebra.diag(reverse(x; dims = 1), i)) <= 1)\nend","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"We are ready to put our model to work and see if it is able to find a feasible solution:","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"optimize!(model)\n@assert is_solved_and_feasible(model)","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"We can now review the solution that our model found:","category":"page"},{"location":"tutorials/linear/n-queens/","page":"N-Queens","title":"N-Queens","text":"solution = round.(Int, value.(x))","category":"page"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"EditURL = \"https://github.com/MAiNGO-github/MAiNGO.jl/blob/b6ea68189558558e44195c1f87c00d9f5038cf0d/README.md\"","category":"page"},{"location":"packages/MAiNGO/#MAiNGO.jl","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO.jl","text":"","category":"section"},{"location":"packages/MAiNGO/#What-is-MAiNGO?","page":"MAiNGO-github/MAiNGO.jl","title":"What is MAiNGO?","text":"","category":"section"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"MAiNGO (McCormick-based Algorithm for mixed-integer Nonlinear Global Optimization) is a deterministic global optimization solver for nonconvex mixed-integer nonlinear programs (MINLPs). For more information on MAiNGO, including installation, usage, and licensing, please see the repository and the documentation.","category":"page"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"MAiNGO.jl is a wrapper for using MAiNGO in Julia. It requires a working installation of MAiNGO, either the standalone version with parser support (Mode A), or the shared parser library version (Mode B). When building MAiNGO from source this is configurable in the CMake configuration of MAiNGO. Per default, precompiled version of MAiNGO is used that operates in Mode B. ","category":"page"},{"location":"packages/MAiNGO/#Using-the-precompiled-version-of-MAiNGO-from-the-Julia-Package-Manager","page":"MAiNGO-github/MAiNGO.jl","title":"Using the precompiled version of MAiNGO from the Julia Package Manager","text":"","category":"section"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"A Julia package containing a precompiled version of MAiNGO is available (MAiNGO_jll). This version is used by default on supported platforms (Linux/MacOs/Windows), but this can be changed (see here). The precompiled version contains only open-source components. If you would like to use commercial subsolvers with MAiNGO (for example CPLEX or KNITRO), it might still make sense to compile MAiNGO yourself and use this version rather than the precompiled one.","category":"page"},{"location":"packages/MAiNGO/#Quick-start","page":"MAiNGO-github/MAiNGO.jl","title":"Quick start","text":"","category":"section"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"using MAiNGO # if this fails, you need to add the package first manually\nusing JuMP\n#Set options in constructor\nmodel=Model(optimizer_with_attributes(MAiNGO.Optimizer, \"epsilonA\"=> 1e-8))\nset_silent(model)\n\n@variable(model, x, lower_bound=-20, upper_bound=20)\n@variable(model, 0<=y<=2)\n@variable(model, 0<=z<=2)\n@variable(model, 0<=d<=2)\n@variable(model, 0<=l<=6)\n@variable(model, 0<=b<=6)\n\n@NLobjective(model, Min, y*-1*x^2*(exp(-x^2+z+d+b)+l*b))\n@NLconstraint(model,(x^2+y^2>=1))\nJuMP.optimize!(model)\n#query results\nprintln(value(x),\" \",value(y))\nprintln(termination_status(model))\nprintln(primal_status(model))","category":"page"},{"location":"packages/MAiNGO/#Using-a-custom-MAiNGO-version","page":"MAiNGO-github/MAiNGO.jl","title":"Using a custom MAiNGO version","text":"","category":"section"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"If you want to make use of a MAiNGO version that you build from source yourself, you have to give the path to the correct binary file. The correct path depends on the mode of operation.","category":"page"},{"location":"packages/MAiNGO/#Modes-of-operation","page":"MAiNGO-github/MAiNGO.jl","title":"Modes of operation","text":"","category":"section"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"The following library allows to call MAiNGO from Julia. Currently two modes are supported:","category":"page"},{"location":"packages/MAiNGO/#Mode-A)","page":"MAiNGO-github/MAiNGO.jl","title":"Mode A)","text":"","category":"section"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"Using MAiNGO standalone exe with compiled parser support. This only allows to construct the problem in JuMP and call the MAiNGO executable with the filepath.   Thus, results are obtained in form of an output text file.","category":"page"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"If a JSON file is also written (by setting the corresponding MAiNGO option), then the contents of that file are parsed, allowing to query the model from JuMP. This requires the JSON module to be installed in Julia.","category":"page"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"#Set path to MAiNGO standalone exe with compiled parser support.\nENV[\"MAINGO_EXEC\"] = \"W:\\\\maingo_build\\\\Debug\\\\MAiNGO.exe\"  #replace \"W:\\\\maingo_build\\\\Debug\\\\\" with path to MAiNGO.exe\nusing MAiNGO # if this fails, you need to add the package first manually\n#create model\nusing JuMP\nmodel=Model(MAiNGO.Optimizer)\n@variable(model, x, lower_bound=0, upper_bound=5)\n@variable(model, y, lower_bound=0, upper_bound=2, start=0.5)\n\n#The following also works:\n#@variable(model,x in MOI.Interval(0,5)) \n#@variable(model, 0<=x<=5)\n#For integer variables use \n#@variable(model, y in MOI.Integer(), start=0.5)\n\n@constraint(model,y+x<=5)\n@constraint(model,x+y>=4)\n#Linear objective is also possible\n#@objective(model, Max, (1 - x)*y)\n@NLobjective(model, Max, (1 - x)^2 + 100 * (y - x^2)^2)\n@NLconstraint(model,min(x^2+y^2,y)<=5+y^2)\nMOI.set(model, MOI.RawOptimizerAttribute(\"writeJson\"),1) # write JSON file to enable querying of results from JuMP\nJuMP.optimize!(model)\nprintln(objective_value(model))","category":"page"},{"location":"packages/MAiNGO/#Mode-B)","page":"MAiNGO-github/MAiNGO.jl","title":"Mode B)","text":"","category":"section"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"Compiling an interface presenting a C-API to Julia. This must be configured when building MAiNGO, but allows several improvements.   The problem definition is passed in memory. Settings can be set from within Julia/JuMP and the results are returned as Julia variables/ are queryable from JuMP.","category":"page"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"For example:","category":"page"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"#Set path to shared library with C-API.\nENV[\"MAINGO_LIB\"]=\"W:\\\\maingo_build\\\\Debug\\\\shared_parser.dll\"  #replace \"W:\\\\maingo_build\\\\Debug\\\\\" with path to shared_parser.dll\n#include the wrapper\nusing MAiNGO # if this fails, you need to add the package first manually\n\n#Set options in constructor\nmodel=Model(optimizer_with_attributes(MAiNGO.Optimizer, \"epsilonA\"=> 1e-8,\"res_name\"=>\"res_new.txt\",\"prob_name\"=>\"problem.txt\"))\n#Alternate syntax\n#model=Model(() -> MAiNGO.Optimizer(epsilonA=1e-8))#, \"options\" => options))\n\n@variable(model, x, lower_bound=-20, upper_bound=20)\n#@variable(model, y in MOI.Integer(),lower_bound=-10,upper_bound=10, start=0.5)\n#Alterntaive forms\n#@variable(model,x in MOI.Interval(0,5))\n#@variable(model,y in MOI.Interval(0,2))\n#@variable(model, 0<=x<=5)\n@variable(model, 0<=y<=2)\n@variable(model, 0<=z<=2)\n@variable(model, 0<=d<=2)\n@variable(model, 0<=l<=6)\n@variable(model, 0<=b<=6)\n#@constraint(model,y+x<=5)\n#@constraint(model,x+y>=4)\n\n@NLobjective(model, Min, y*-1*x^2*(exp(-x^2+z+d+b)+l*b))\n@NLconstraint(model,(x^2+y^2>=1))\nJuMP.optimize!(model)\n#C-API allows us to query results\nprintln(value(x),\" \",value(y))\nprintln(termination_status(model))\nprintln(primal_status(model))","category":"page"},{"location":"packages/MAiNGO/#Supported-MAiNGO-Options","page":"MAiNGO-github/MAiNGO.jl","title":"Supported MAiNGO Options","text":"","category":"section"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"Both modes of operation allow setting MAiNGO options through the MatOptInterface-API. An example of how to do so is given below. All numerical and boolean options that are available in MAiNGO can be set using the MOI.RawOptimizerAttribute() function. Additionally, the following options can also be set through specific other MOI functions:","category":"page"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"Solver time limit (in seconds): MOI.TimeLimitSec()\nAbsolute gap: MOI.AbsoluteGapTolerance()\nRelative gap: MOI.RelativeGapTolerance()\nSilencing output: MOI.Silent() (this overwrites any other verbosity settings)","category":"page"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"# assuming necessary paths and using-statements have already been set\nmodel = Model(MAiNGO.Optimizer)\nMOI.set(model, MOI.Silent(), true) # silence all MAiNGO output\nMOI.set(model, MOI.AbsoluteGapTolerance(), 1e-8) # set the absolute gap tolerance\nMOI.set(model, MOI.RawOptimizerAttribute(\"PRE_pureMultistart\"), 1) # example of setting an option via the MOI.RawOptimizerAttribute() function","category":"page"},{"location":"packages/MAiNGO/#Switching-between-modes,-finding-the-MAiNGO-executable","page":"MAiNGO-github/MAiNGO.jl","title":"Switching between modes, finding the MAiNGO executable","text":"","category":"section"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"If you need to update the path to the MAiNGO executable during a session, this can be done as follows:","category":"page"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"\nusing MAiNGO\n# by default, MAiNGO_jll will be used\n# explicitly force use of standalone version (mode A)\nENV[\"MAINGO_EXEC\"] = \"W:\\\\maingo_build\\\\Debug\\\\MAiNGO.exe\"\nfindMAiNGO(preferred=MAiNGO.C_API) # see note on \"preferred\"-argument below\n# ...\n# for example switch to release version of MAiNGO\nENV[\"MAINGO_EXEC\"] = \"W:\\\\maingo_build\\\\Release\\\\MAiNGO.exe\"\nfindMAiNGO(preferred=MAiNGO.C_API)\n# now switch to C-API (mode B)\nENV[\"MAINGO_LIB\"]=\"W:\\\\maingo_build\\\\Debug\\\\shared_parser.dll\"  #replace \"W:\\\\maingo_build\\\\Debug\\\\\" with path to shared_parser.dll\nfindMAiNGO(preferred=MAiNGO.C_API)\n# switch back to MAiNGO_jll\nfindMAiNGO(preferred=MAiNGO.MAINGO_JLL)","category":"page"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"The findMAiNGO() function takes several optional arguments, which can be passed as keyword-arguments:","category":"page"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"verbose: boolean, whether or not progress on finding MAiNGO is reported. (Default value: false)\npreferred: either MAiNGO.MAINGOJLL or MAiNGO.CAPI, determines whether jll binaries or custom installation of MAiNGO is preferred. Note that the C-API is always preferred to the standalone version. If a custom standalone version should be used, set this value to C-API and pass an empty string as the capi argument (see next). (Default value: MAINGOJLL)\ncapi: string, path to C-API file. If set, this overrides the environment variable MAINGOLIB.\nstandalone: string, path to standalone executable file. If set, this overrides the environment variable MAINGO_EXEC.","category":"page"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"For example, to use the C-API at a new location, one could call:","category":"page"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"using MAiNGO\nfindMAiNGO(preferred=MAiNGO.C_API, c_api=\"path\\\\to\\\\c\\\\api\\\\shared_parser.dll\")","category":"page"},{"location":"packages/MAiNGO/#Currently-working:","page":"MAiNGO-github/MAiNGO.jl","title":"Currently working:","text":"","category":"section"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"Integer and binary variables.\nAffine, Quadratic and nonlinear constraints and objectives.\nOperations: min,max,*,/,+,-,-(unary), exp,log,abs,sqrt,^\nOther operations  are easy to add if supported by MathOptInterface,ALE and MAiNGO.\nWriting problem defined in JuMP syntax to an ALE problem.txt and calling MAiNGO.exe on a specified path.\nAlternatively using a C-API to call MAiNGO.","category":"page"},{"location":"packages/MAiNGO/#Restrictions-compared-to-using-the-Python-or-C-interface","page":"MAiNGO-github/MAiNGO.jl","title":"Restrictions compared to using the Python or C++ interface","text":"","category":"section"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"It is assumed that all variables are bounded. This interface assumes that integer variables are bounded between -1e6 and 1e6. For real variables these bounds are -1e8 and 1e8.","category":"page"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"Other functionality such as special support for growing datasets or MPI parallelization is not currently supported via this wrapper.  Additionally, constraint formulations are simply passed from their representation in JuMP/MathOptInterface to MAiNGO. As such, there is no way to make use of advanced techniques such as defining constraints that are only used for the relaxations, using special relaxations for functions used in thermodynamics and process engineering or formulating reduced space formulations.","category":"page"},{"location":"packages/MAiNGO/#Tests","page":"MAiNGO-github/MAiNGO.jl","title":"Tests","text":"","category":"section"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"A subset of test cases for MathOptInterface solvers can be run by running the script ./test/runtests.jl. The current release was tested in the following combinations:","category":"page"},{"location":"packages/MAiNGO/","page":"MAiNGO-github/MAiNGO.jl","title":"MAiNGO-github/MAiNGO.jl","text":"Julia 1.8.5 and MathOptInterface v1.18.0\nJulia 1.9.4 and MathOptInterface v1.23.0.","category":"page"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"EditURL = \"https://github.com/jump-dev/SDPNAL.jl/blob/00a3fa19f4e1235587948113b0b681da17f4dab5/README.md\"","category":"page"},{"location":"packages/SDPNAL/#SDPNAL.jl","page":"jump-dev/SDPNAL.jl","title":"SDPNAL.jl","text":"","category":"section"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"SDPNAL.jl is wrapper for the SDPNALplus solver.","category":"page"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"The wrapper has two components:","category":"page"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"an exported sdpnalplus function that is a thin wrapper on top of the sdpnalplus MATLAB function\nan interface to MathOptInterface","category":"page"},{"location":"packages/SDPNAL/#Affiliation","page":"jump-dev/SDPNAL.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"This wrapper is maintained by the JuMP community and is not an official wrapper of SDPNALplus.","category":"page"},{"location":"packages/SDPNAL/#License","page":"jump-dev/SDPNAL.jl","title":"License","text":"","category":"section"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"SDPNAL.jl is licensed under the MIT License.","category":"page"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"The underlying solver, SDPNALplus is licensed under the Creative Commons Attribution-ShareAlike 4.0 International Public License.","category":"page"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"In addition, SDPNAL requires an installation of MATLAB, which is a closed-source commercial product for which you must obtain a license.","category":"page"},{"location":"packages/SDPNAL/#Use-with-JuMP","page":"jump-dev/SDPNAL.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"To use SDPNAL with JuMP, do:","category":"page"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"using JuMP, SDPNAL\nmodel = Model(SDPNAL.Optimizer)\nset_attribute(model, \"printlevel\", 0)","category":"page"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"Note that, contrary to implementation of other solver-independent interfaces, using SDPNAL from JuMP or MOI fully exploits the particular structures of the SDPNAL interface and does not create superfluous slack variables and equality constraints as discussed in the SDPNAL guide:","category":"page"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"A new interface is necessary to facilitate the modeling of an SDP problem for SDPNAL+ because of latter’s flexibility to directly accept inequality constraints of the form “l ≤ B(X) ≤ u”, and bound constraints of the form “L ≤ X ≤ U”. The flexibility can significantly simplify the generation of the data in the SDPNAL+ format as compared to what need to be done in CVX or YALMIP to reformulate them as equality constraints through introducing extra variables. In addition, the final number of equality constraints present in the data input to SDPNAL+ can also be substantially fewer than those present in CVX or YALMIP. It is important to note here that the number of equality constraints present in the generated problem data can greatly affect the computational efficiency of the solvers, especially for interior-point based solvers.","category":"page"},{"location":"packages/SDPNAL/#Installation","page":"jump-dev/SDPNAL.jl","title":"Installation","text":"","category":"section"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"First, make sure that you satisfy the requirements of the MATLAB.jl Julia package, and that the SDPNALplus software is installed in your MATLAB™ installation.","category":"page"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"Then, install SDPNAL.jl using Pkg.add:","category":"page"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"import Pkg\nPkg.add(\"SDPNAL\")","category":"page"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"There is a startup.m file at the root of the SDPNAL folder. This adds all subdirectories recursively when MATLAB starts. However, the interface directory contains a .git subdirectory which contains a very large number of files. Because of this, MATLAB crashes if SDPNAL is in its path because the startup.m requests MATLAB to try to parse all the files in the .git folder. To resolve this problem, delete the startup.m file and .git folder, and add the subdirectories manually your toolbox/local/pathdef.m file as follows:","category":"page"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"function p = pathdef\n\n% (...)\n\np = [...\n%%% BEGIN ENTRIES %%%\n'/path/to/SDPNALv1.0:', ...\n'/path/to/SDPNALv1.0/interface:', ...\n'/path/to/SDPNALv1.0/mexfun:', ...\n'/path/to/SDPNALv1.0/solver:', ...\n'/path/to/SDPNALv1.0/solver_main_default:', ...\n'/path/to/SDPNALv1.0/util:', ...\n% (...)","category":"page"},{"location":"packages/SDPNAL/","page":"jump-dev/SDPNAL.jl","title":"jump-dev/SDPNAL.jl","text":"If you have SDPT3 in addition to SDPNAL in the MATLAB path (that is, the toolbox/local/pathdef.m file) then you might have issues because both solvers define a validate function, and this might make SDPNAL call SDPT3's validate function instead of SDPT3's validate function.","category":"page"},{"location":"should_i_use/#Should-you-use-JuMP?","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"","category":"section"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"JuMP is an algebraic modeling language for mathematical optimization written in the Julia language.","category":"page"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"This page explains when you should consider using JuMP, and importantly, when you should not use JuMP.","category":"page"},{"location":"should_i_use/#When-should-you-use-JuMP?","page":"Should you use JuMP?","title":"When should you use JuMP?","text":"","category":"section"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"You should use JuMP if you have a constrained optimization problem for which you can formulate using the language of mathematical programming, that is:","category":"page"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"a set of decision variables\na scalar- or vector-valued objective function\na set of constraints.","category":"page"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"Key reasons to use JuMP include:","category":"page"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"User friendliness\nJuMP has syntax that mimics natural mathematical expressions. (See the section on algebraic modeling languages.)\nSolver independence\nJuMP uses a generic solver-independent interface provided by the MathOptInterface package, making it easy to change between a number of open-source and commercial optimization software packages (\"solvers\"). The Supported solvers section contains a table of the currently supported solvers.\nEase of embedding\nJuMP itself is written purely in Julia. Solvers are the only binary dependencies.\nJuMP provides automatic installation of many open-source solvers. This is different to modeling languages in Python which require you to download and install a solver yourself.\nBecause it is embedded in a general-purpose programming language, JuMP makes it easy to solve optimization problems as part of a larger workflow, for example, inside a simulation, behind a web server, or as a subproblem in a decomposition algorithm. As a trade-off, JuMP's syntax is constrained by the syntax and functionality available in Julia.\nJuMP is MPL licensed, meaning that it can be embedded in commercial software that complies with the terms of the license.\nSpeed\nBenchmarking has shown that JuMP can create problems at similar speeds to special-purpose modeling languages such as AMPL.\nJuMP communicates with most solvers in memory, avoiding the need to write intermediary files.\nAccess to advanced algorithmic techniques\nJuMP supports efficient in-memory re-solves of linear programs, which previously required using solver-specific or low-level C++ libraries.\nJuMP provides access to solver-independent and solver-dependent Callbacks.","category":"page"},{"location":"should_i_use/#When-should-you-not-use-JuMP?","page":"Should you use JuMP?","title":"When should you not use JuMP?","text":"","category":"section"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"JuMP supports a broad range of optimization classes. However, there are still some that it doesn't support, or that are better supported by other software packages.","category":"page"},{"location":"should_i_use/#You-want-to-optimize-a-complicated-Julia-function","page":"Should you use JuMP?","title":"You want to optimize a complicated Julia function","text":"","category":"section"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"Packages in Julia compose well. It's common for people to pick two unrelated packages and use them in conjunction to create novel behavior. JuMP isn't one of those packages.","category":"page"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"If you want to optimize an ordinary differential equation from DifferentialEquations.jl or tune a neural network from Flux.jl, consider using other packages such as:","category":"page"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"Optim.jl\nOptimization.jl\nNLPModels.jl\nNonconvex.jl","category":"page"},{"location":"should_i_use/#Black-box,-derivative-free,-or-unconstrained-optimization","page":"Should you use JuMP?","title":"Black-box, derivative free, or unconstrained optimization","text":"","category":"section"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"JuMP does support nonlinear programs with constraints and objectives containing user-defined operators. However, the functions must be automatically differentiable, or need to provide explicit derivatives. (See User-defined operators for more information.)","category":"page"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"If your function is a black-box that is non-differentiable (for example, it is the output of a simulation written in C++), JuMP is not the right tool for the job. This also applies if you want to use a derivative free method.","category":"page"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"Even if your problem is differentiable, if it is unconstrained there is limited benefit (and downsides in the form of more overhead) to using JuMP over tools which are only concerned with function minimization.","category":"page"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"Alternatives to consider are:","category":"page"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"Optim.jl\nOptimization.jl\nNLopt.jl","category":"page"},{"location":"should_i_use/#Disciplined-convex-programming","page":"Should you use JuMP?","title":"Disciplined convex programming","text":"","category":"section"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"JuMP does not support disciplined convex programming (DCP).","category":"page"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"Alternatives to consider are:","category":"page"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"Convex.jl\nCVXPY [Python]\nYALMIP [MATLAB]","category":"page"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"note: Note\nConvex.jl is also built on MathOptInterface, and shares the same set of underlying solvers. However, you input problems differently, and Convex.jl checks that the problem is DCP.","category":"page"},{"location":"should_i_use/#Stochastic-programming","page":"Should you use JuMP?","title":"Stochastic programming","text":"","category":"section"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"JuMP requires deterministic input data.","category":"page"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"If you have stochastic input data, consider using a JuMP extension such as:","category":"page"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"InfiniteOpt.jl\nStochasticPrograms.jl\nSDDP.jl","category":"page"},{"location":"should_i_use/#Polyhedral-computations","page":"Should you use JuMP?","title":"Polyhedral computations","text":"","category":"section"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"JuMP does not provide tools for working with the polyhedron formed by the set of linear constraints.","category":"page"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"Alternatives to consider are:","category":"page"},{"location":"should_i_use/","page":"Should you use JuMP?","title":"Should you use JuMP?","text":"Polyhedra.jl (See the documentation to create a polyhedron from a JuMP model.)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"EditURL = \"design_patterns_for_larger_models.jl\"","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Design-patterns-for-larger-models","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"JuMP makes it easy to build and solve optimization models. However, once you start to construct larger models, and especially ones that interact with external data sources or have customizable sets of variables and constraints based on client choices, you may find that your scripts become unwieldy. This tutorial demonstrates a variety of ways in which you can structure larger JuMP models to improve their readability and maintainability.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"tip: Tip\nThis tutorial is more advanced than the other \"Getting started\" tutorials. It's in the \"Getting started\" section to give you an early preview of how JuMP makes it easy to structure larger models. However, if you are new to JuMP you may want to briefly skim the tutorial, and come back to it once you have written a few JuMP models.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Overview","page":"Design patterns for larger models","title":"Overview","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"This tutorial uses explanation-by-example. We're going to start with a simple knapsack model, and then expand it to add various features and structure.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#A-simple-script","page":"Design patterns for larger models","title":"A simple script","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Your first prototype of a JuMP model is probably a script that uses a small set of hard-coded data.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"using JuMP, HiGHS\nprofit = [5, 3, 2, 7, 4]\nweight = [2, 8, 4, 2, 5]\ncapacity = 10\nN = 5\nmodel = Model(HiGHS.Optimizer)\n@variable(model, x[1:N], Bin)\n@objective(model, Max, sum(profit[i] * x[i] for i in 1:N))\n@constraint(model, sum(weight[i] * x[i] for i in 1:N) <= capacity)\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue.(x)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"The benefits of this approach are:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"it is quick to code\nit is quick to make changes.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"The downsides include:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"all variables are global (read Performance tips)\nit is easy to introduce errors, for example, having profit and weight be vectors of different lengths, or not match N\nthe solution, x[i], is hard to interpret without knowing the order in which we provided the data.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Wrap-the-model-in-a-function","page":"Design patterns for larger models","title":"Wrap the model in a function","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"A good next step is to wrap your model in a function. This is useful for a few reasons:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"it removes global variables\nit encapsulates the JuMP model and forces you to clarify your inputs and outputs\nwe can add some error checking.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function solve_knapsack_1(profit::Vector, weight::Vector, capacity::Real)\n    if length(profit) != length(weight)\n        throw(DimensionMismatch(\"profit and weight are different sizes\"))\n    end\n    N = length(weight)\n    model = Model(HiGHS.Optimizer)\n    @variable(model, x[1:N], Bin)\n    @objective(model, Max, sum(profit[i] * x[i] for i in 1:N))\n    @constraint(model, sum(weight[i] * x[i] for i in 1:N) <= capacity)\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    return value.(x)\nend\n\nsolve_knapsack_1([5, 3, 2, 7, 4], [2, 8, 4, 2, 5], 10)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Create-better-data-structures","page":"Design patterns for larger models","title":"Create better data structures","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Although we can check for errors like mis-matched vector lengths, if you start to develop models with a lot of data, keeping track of vectors and lengths and indices is fragile and a common source of bugs. A good solution is to use Julia's type system to create an abstraction over your data.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"For example, we can create a struct that represents a single object, with a constructor that lets us validate assumptions on the input data:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"struct KnapsackObject\n    profit::Float64\n    weight::Float64\n    function KnapsackObject(profit::Float64, weight::Float64)\n        if weight < 0\n            throw(DomainError(\"Weight of object cannot be negative\"))\n        end\n        return new(profit, weight)\n    end\nend","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"as well as a struct that holds a dictionary of objects and the knapsack's capacity:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"struct KnapsackData\n    objects::Dict{String,KnapsackObject}\n    capacity::Float64\nend","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Here's what our data might look like now:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"objects = Dict(\n    \"apple\" => KnapsackObject(5.0, 2.0),\n    \"banana\" => KnapsackObject(3.0, 8.0),\n    \"cherry\" => KnapsackObject(2.0, 4.0),\n    \"date\" => KnapsackObject(7.0, 2.0),\n    \"eggplant\" => KnapsackObject(4.0, 5.0),\n)\ndata = KnapsackData(objects, 10.0)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"If you want, you can add custom printing to make it easier to visualize:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function Base.show(io::IO, data::KnapsackData)\n    println(io, \"A knapsack with capacity $(data.capacity) and possible items:\")\n    for (k, v) in data.objects\n        println(\n            io,\n            \"  $(rpad(k, 8)) : profit = $(v.profit), weight = $(v.weight)\",\n        )\n    end\n    return\nend\n\ndata","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Then, we can re-write our solve_knapsack function to take our KnapsackData as input:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function solve_knapsack_2(data::KnapsackData)\n    model = Model(HiGHS.Optimizer)\n    @variable(model, x[keys(data.objects)], Bin)\n    @objective(model, Max, sum(v.profit * x[k] for (k, v) in data.objects))\n    @constraint(\n        model,\n        sum(v.weight * x[k] for (k, v) in data.objects) <= data.capacity,\n    )\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    return value.(x)\nend\n\nsolve_knapsack_2(data)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Read-in-data-from-files","page":"Design patterns for larger models","title":"Read in data from files","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Having a data structure is a good step. But it is still annoying that we have to hard-code the data into Julia. A good next step is to separate the data into an external file format; JSON is a common choice.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"json_data = \"\"\"\n{\n    \"objects\": {\n        \"apple\": {\"profit\": 5.0, \"weight\": 2.0},\n        \"banana\": {\"profit\": 3.0, \"weight\": 8.0},\n        \"cherry\": {\"profit\": 2.0, \"weight\": 4.0},\n        \"date\": {\"profit\": 7.0, \"weight\": 2.0},\n        \"eggplant\": {\"profit\": 4.0, \"weight\": 5.0}\n    },\n    \"capacity\": 10.0\n}\n\"\"\"\ntemp_dir = mktempdir()\nknapsack_json_filename = joinpath(temp_dir, \"knapsack.json\")\n# Instead of writing a new file here you could replace `knapsack_json_filename`\n# with the path to a local file.\nwrite(knapsack_json_filename, json_data);\nnothing #hide","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Now let's write a function that reads this file and builds a KnapsackData object:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"import JSON\n\nfunction read_data(filename)\n    d = JSON.parsefile(filename)\n    return KnapsackData(\n        Dict(\n            k => KnapsackObject(v[\"profit\"], v[\"weight\"]) for\n            (k, v) in d[\"objects\"]\n        ),\n        d[\"capacity\"],\n    )\nend\n\ndata = read_data(knapsack_json_filename)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Add-options-via-if-else","page":"Design patterns for larger models","title":"Add options via if-else","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"At this point, we have data in a file format which we can load and solve a single problem. For many users, this might be sufficient. However, at some point you may be asked to add features like \"but what if we want to take more than one of a particular item?\"","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"If this is the first time that you've been asked to add a feature, adding options via if-else statements is a good approach. For example, we might write:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function solve_knapsack_3(data::KnapsackData; binary_knapsack::Bool)\n    model = Model(HiGHS.Optimizer)\n    if binary_knapsack\n        @variable(model, x[keys(data.objects)], Bin)\n    else\n        @variable(model, x[keys(data.objects)] >= 0, Int)\n    end\n    @objective(model, Max, sum(v.profit * x[k] for (k, v) in data.objects))\n    @constraint(\n        model,\n        sum(v.weight * x[k] for (k, v) in data.objects) <= data.capacity,\n    )\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    return value.(x)\nend","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Now we can solve the binary knapsack:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"solve_knapsack_3(data; binary_knapsack = true)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"And an integer knapsack where we can take more than one copy of each item:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"solve_knapsack_3(data; binary_knapsack = false)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Add-configuration-options-via-dispatch","page":"Design patterns for larger models","title":"Add configuration options via dispatch","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"If you get repeated requests to add different options, you'll quickly find yourself in a mess of different flags and if-else statements. It's hard to write, hard to read, and hard to ensure you haven't introduced any bugs. A good solution is to use Julia's type dispatch to control the configuration of the model. The easiest way to explain this is by example.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"First, start by defining a new abstract type, as well as new subtypes for each of our options. These types are going to control the configuration of the knapsack model.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"abstract type AbstractConfiguration end\n\nstruct BinaryKnapsackConfig <: AbstractConfiguration end\n\nstruct IntegerKnapsackConfig <: AbstractConfiguration end","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Then, we rewrite our solve_knapsack function to take a config argument, and we introduce an add_knapsack_variables function to abstract the creation of our variables.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function solve_knapsack_4(data::KnapsackData, config::AbstractConfiguration)\n    model = Model(HiGHS.Optimizer)\n    x = add_knapsack_variables(model, data, config)\n    @objective(model, Max, sum(v.profit * x[k] for (k, v) in data.objects))\n    @constraint(\n        model,\n        sum(v.weight * x[k] for (k, v) in data.objects) <= data.capacity,\n    )\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    return value.(x)\nend","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"For the binary knapsack problem, add_knapsack_variables looks like this:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function add_knapsack_variables(\n    model::Model,\n    data::KnapsackData,\n    ::BinaryKnapsackConfig,\n)\n    return @variable(model, x[keys(data.objects)], Bin)\nend","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"For the integer knapsack problem, add_knapsack_variables looks like this:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function add_knapsack_variables(\n    model::Model,\n    data::KnapsackData,\n    ::IntegerKnapsackConfig,\n)\n    return @variable(model, x[keys(data.objects)] >= 0, Int)\nend","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Now we can solve the binary knapsack:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"solve_knapsack_4(data, BinaryKnapsackConfig())","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"and the integer knapsack problem:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"solve_knapsack_4(data, IntegerKnapsackConfig())","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"The main benefit of the dispatch approach is that you can quickly add new options without needing to modify the existing code. For example:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"struct UpperBoundedKnapsackConfig <: AbstractConfiguration\n    limit::Int\nend\n\nfunction add_knapsack_variables(\n    model::Model,\n    data::KnapsackData,\n    config::UpperBoundedKnapsackConfig,\n)\n    return @variable(model, 0 <= x[keys(data.objects)] <= config.limit, Int)\nend\n\nsolve_knapsack_4(data, UpperBoundedKnapsackConfig(3))","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Generalize-constraints-and-objectives","page":"Design patterns for larger models","title":"Generalize constraints and objectives","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"It's easy to extend the dispatch approach to constraints and objectives as well. The key points to notice in the next two functions are that:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"we can access registered variables via model[:x]\nwe can define generic functions which accept any AbstractConfiguration as a configuration argument. That means we can implement a single method and have it apply to multiple configuration types.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function add_knapsack_constraints(\n    model::Model,\n    data::KnapsackData,\n    ::AbstractConfiguration,\n)\n    x = model[:x]\n    @constraint(\n        model,\n        capacity_constraint,\n        sum(v.weight * x[k] for (k, v) in data.objects) <= data.capacity,\n    )\n    return\nend\n\nfunction add_knapsack_objective(\n    model::Model,\n    data::KnapsackData,\n    ::AbstractConfiguration,\n)\n    x = model[:x]\n    @objective(model, Max, sum(v.profit * x[k] for (k, v) in data.objects))\n    return\nend\n\nfunction solve_knapsack_5(data::KnapsackData, config::AbstractConfiguration)\n    model = Model(HiGHS.Optimizer)\n    add_knapsack_variables(model, data, config)\n    add_knapsack_constraints(model, data, config)\n    add_knapsack_objective(model, data, config)\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    return value.(model[:x])\nend\n\nsolve_knapsack_5(data, BinaryKnapsackConfig())","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Remove-solver-dependence,-add-error-checks","page":"Design patterns for larger models","title":"Remove solver dependence, add error checks","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Compared to where we started, our knapsack model is now significantly different. We've wrapped it in a function, defined some data types, and introduced configuration options to control the variables and constraints that get added. There are a few other steps we can do to further improve things:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"remove the dependence on HiGHS\nadd checks that we found an optimal solution\nadd a helper function to avoid the need to explicitly construct the data.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"function solve_knapsack_6(\n    optimizer,\n    data::KnapsackData,\n    config::AbstractConfiguration,\n)\n    model = Model(optimizer)\n    add_knapsack_variables(model, data, config)\n    add_knapsack_constraints(model, data, config)\n    add_knapsack_objective(model, data, config)\n    optimize!(model)\n    if !is_solved_and_feasible(model)\n        @warn(\"Model not solved to optimality\")\n        return nothing\n    end\n    return value.(model[:x])\nend\n\nfunction solve_knapsack_6(\n    optimizer,\n    data::String,\n    config::AbstractConfiguration,\n)\n    return solve_knapsack_6(optimizer, read_data(data), config)\nend\n\nsolution = solve_knapsack_6(\n    HiGHS.Optimizer,\n    knapsack_json_filename,\n    BinaryKnapsackConfig(),\n)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Create-a-module","page":"Design patterns for larger models","title":"Create a module","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Now we're ready to expose our model to the wider world. That might be as part of a larger Julia project that we're contributing to, or as a stand-alone script that we can run on-demand. In either case, it's good practice to wrap everything in a module. This further encapsulates our code into a single namespace, and we can add documentation in the form of docstrings.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Some good rules to follow when creating a module are:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"use import in a module instead of using to make it clear which functions are from which packages\nuse _ to start function and type names that are considered private\nadd docstrings to all public variables and functions.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"module KnapsackModel\n\nimport JuMP\nimport JSON\n\nstruct _KnapsackObject\n    profit::Float64\n    weight::Float64\n    function _KnapsackObject(profit::Float64, weight::Float64)\n        if weight < 0\n            throw(DomainError(\"Weight of object cannot be negative\"))\n        end\n        return new(profit, weight)\n    end\nend\n\nstruct _KnapsackData\n    objects::Dict{String,_KnapsackObject}\n    capacity::Float64\nend\n\nfunction _read_data(filename)\n    d = JSON.parsefile(filename)\n    return _KnapsackData(\n        Dict(\n            k => _KnapsackObject(v[\"profit\"], v[\"weight\"]) for\n            (k, v) in d[\"objects\"]\n        ),\n        d[\"capacity\"],\n    )\nend\n\nabstract type _AbstractConfiguration end\n\n\"\"\"\n    BinaryKnapsackConfig()\n\nCreate a binary knapsack problem where each object can be taken 0 or 1 times.\n\"\"\"\nstruct BinaryKnapsackConfig <: _AbstractConfiguration end\n\n\"\"\"\n    IntegerKnapsackConfig()\n\nCreate an integer knapsack problem where each object can be taken any number of\ntimes.\n\"\"\"\nstruct IntegerKnapsackConfig <: _AbstractConfiguration end\n\nfunction _add_knapsack_variables(\n    model::JuMP.Model,\n    data::_KnapsackData,\n    ::BinaryKnapsackConfig,\n)\n    return JuMP.@variable(model, x[keys(data.objects)], Bin)\nend\n\nfunction _add_knapsack_variables(\n    model::JuMP.Model,\n    data::_KnapsackData,\n    ::IntegerKnapsackConfig,\n)\n    return JuMP.@variable(model, x[keys(data.objects)] >= 0, Int)\nend\n\nfunction _add_knapsack_constraints(\n    model::JuMP.Model,\n    data::_KnapsackData,\n    ::_AbstractConfiguration,\n)\n    x = model[:x]\n    JuMP.@constraint(\n        model,\n        capacity_constraint,\n        sum(v.weight * x[k] for (k, v) in data.objects) <= data.capacity,\n    )\n    return\nend\n\nfunction _add_knapsack_objective(\n    model::JuMP.Model,\n    data::_KnapsackData,\n    ::_AbstractConfiguration,\n)\n    x = model[:x]\n    JuMP.@objective(model, Max, sum(v.profit * x[k] for (k, v) in data.objects))\n    return\nend\n\nfunction _solve_knapsack(\n    optimizer,\n    data::_KnapsackData,\n    config::_AbstractConfiguration,\n)\n    model = JuMP.Model(optimizer)\n    _add_knapsack_variables(model, data, config)\n    _add_knapsack_constraints(model, data, config)\n    _add_knapsack_objective(model, data, config)\n    JuMP.optimize!(model)\n    if !JuMP.is_solved_and_feasible(model)\n        @warn(\"Model not solved to optimality\")\n        return nothing\n    end\n    return JuMP.value.(model[:x])\nend\n\n\"\"\"\n    solve_knapsack(\n        optimizer,\n        knapsack_json_filename::String,\n        config::_AbstractConfiguration,\n    )\n\nSolve the knapsack problem and return the optimal primal solution\n\n# Arguments\n\n * `optimizer` : an object that can be passed to `JuMP.Model` to construct a new\n   JuMP model.\n * `knapsack_json_filename` : the filename of a JSON file containing the data for the\n   problem.\n * `config` : an object to control the type of knapsack model constructed.\n   Valid options are:\n    * `BinaryKnapsackConfig()`\n    * `IntegerKnapsackConfig()`\n\n# Returns\n\n * If an optimal solution exists: a `JuMP.DenseAxisArray` that maps the `String`\n   name of each object to the number of objects to pack into the knapsack.\n * Otherwise, `nothing`, indicating that the problem does not have an optimal\n   solution.\n\n# Example\n\n```julia\nsolution = solve_knapsack(\n    HiGHS.Optimizer,\n    \"path/to/data.json\",\n    BinaryKnapsackConfig(),\n)\n```\n\n```julia\nsolution = solve_knapsack(\n    MOI.OptimizerWithAttributes(HiGHS.Optimizer, \"output_flag\" => false),\n    \"path/to/data.json\",\n    IntegerKnapsackConfig(),\n)\n```\n\"\"\"\nfunction solve_knapsack(\n    optimizer,\n    knapsack_json_filename::String,\n    config::_AbstractConfiguration,\n)\n    data = _read_data(knapsack_json_filename)\n    return _solve_knapsack(optimizer, data, config)\nend\n\nend","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Finally, you can call your model:","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"import .KnapsackModel\n\nKnapsackModel.solve_knapsack(\n    HiGHS.Optimizer,\n    knapsack_json_filename,\n    KnapsackModel.BinaryKnapsackConfig(),\n)","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"note: Note\nThe . in .KnapsackModel denotes that it is a submodule and not a separate package that we installed with Pkg.add. If you put the KnapsackModel in a separate file, load it with:include(\"path/to/KnapsackModel.jl\")\nimport .KnapsackModel","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Add-tests","page":"Design patterns for larger models","title":"Add tests","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"As a final step, you should add tests for your model. This often means testing on a small problem for which you can work out the optimal solution by hand. The Julia standard library Test has good unit-testing functionality.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"import .KnapsackModel\nusing Test\n\n@testset \"KnapsackModel\" begin\n    @testset \"feasible_binary_knapsack\" begin\n        x = KnapsackModel.solve_knapsack(\n            HiGHS.Optimizer,\n            knapsack_json_filename,\n            KnapsackModel.BinaryKnapsackConfig(),\n        )\n        @test isapprox(x[\"apple\"], 1, atol = 1e-5)\n        @test isapprox(x[\"banana\"], 0, atol = 1e-5)\n        @test isapprox(x[\"cherry\"], 0, atol = 1e-5)\n        @test isapprox(x[\"date\"], 1, atol = 1e-5)\n        @test isapprox(x[\"eggplant\"], 1, atol = 1e-5)\n    end\n    @testset \"feasible_integer_knapsack\" begin\n        x = KnapsackModel.solve_knapsack(\n            HiGHS.Optimizer,\n            knapsack_json_filename,\n            KnapsackModel.IntegerKnapsackConfig(),\n        )\n        @test isapprox(x[\"apple\"], 0, atol = 1e-5)\n        @test isapprox(x[\"banana\"], 0, atol = 1e-5)\n        @test isapprox(x[\"cherry\"], 0, atol = 1e-5)\n        @test isapprox(x[\"date\"], 5, atol = 1e-5)\n        @test isapprox(x[\"eggplant\"], 0, atol = 1e-5)\n    end\n    @testset \"infeasible_binary_knapsack\" begin\n        dir = mktempdir()\n        infeasible_filename = joinpath(dir, \"infeasible.json\")\n        write(\n            infeasible_filename,\n            \"\"\"{\n                \"objects\": {\n                    \"apple\": {\"profit\": 5.0, \"weight\": 2.0},\n                    \"banana\": {\"profit\": 3.0, \"weight\": 8.0},\n                    \"cherry\": {\"profit\": 2.0, \"weight\": 4.0},\n                    \"date\": {\"profit\": 7.0, \"weight\": 2.0},\n                    \"eggplant\": {\"profit\": 4.0, \"weight\": 5.0}\n                },\n                \"capacity\": -10.0\n            }\"\"\",\n        )\n        x = KnapsackModel.solve_knapsack(\n            HiGHS.Optimizer,\n            infeasible_filename,\n            KnapsackModel.BinaryKnapsackConfig(),\n        )\n        @test x === nothing\n    end\nend","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"tip: Tip\nPlace these tests in a separate file test_knapsack_model.jl so that you can run the tests by adding include(\"test_knapsack_model.jl\") to any file where needed.","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/#Next-steps","page":"Design patterns for larger models","title":"Next steps","text":"","category":"section"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"We've only briefly scratched the surface of ways to create and structure large JuMP models, so consider this tutorial a starting point, rather than a comprehensive list of all the possible ways to structure JuMP models.  If you are embarking on a large project that uses JuMP, a good next step is to look at ways people have written large JuMP projects \"in the wild.\"","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"Here are some good examples (all co-incidentally related to energy):","category":"page"},{"location":"tutorials/getting_started/design_patterns_for_larger_models/","page":"Design patterns for larger models","title":"Design patterns for larger models","text":"AnyMOD.jl\nJuMP-dev 2021 talk\nsource code\nPowerModels.jl\nJuMP-dev 2021 talk\nsource code\nPowerSimulations.jl\nJuliaCon 2021 talk\nsource code\nUnitCommitment.jl\nJuMP-dev 2021 talk\nsource code","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"EditURL = \"multi.jl\"","category":"page"},{"location":"tutorials/linear/multi/#The-multi-commodity-flow-problem","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"","category":"section"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"This tutorial was originally contributed by Louis Luangkesorn.","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"This tutorial is a JuMP implementation of the multi-commodity transportation model described in AMPL: A Modeling Language for Mathematical Programming, by R. Fourer, D.M. Gay and B.W. Kernighan.","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"The purpose of this tutorial is to demonstrate creating a JuMP model from an SQLite database.","category":"page"},{"location":"tutorials/linear/multi/#Required-packages","page":"The multi-commodity flow problem","title":"Required packages","text":"","category":"section"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"This tutorial uses the following packages","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"using JuMP\nimport DataFrames\nimport HiGHS\nimport SQLite\nimport Tables\nimport Test\n\nconst DBInterface = SQLite.DBInterface","category":"page"},{"location":"tutorials/linear/multi/#Formulation","page":"The multi-commodity flow problem","title":"Formulation","text":"","category":"section"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"The multi-commondity flow problem is a simple extension of The transportation problem to multiple types of products. Briefly, we start with the formulation of the transportation problem:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"beginaligned\nmin   sum_i in O j in D c_ij x_ij \nst   sum_j in D x_i j le s_i  forall i in O \n       sum_i in O x_i j = d_j  forall j in D \n       x_i j ge 0  forall i in O j in D\nendaligned","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"but introduce a set of products P, resulting in:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"beginaligned\nmin   sum_i in O j in D k in P c_ijk x_ijk \nst   sum_j in D x_i j k le s_ik  forall i in O k in P \n       sum_i in O x_i j k = d_jk  forall j in D k in P \n       x_i jk ge 0  forall i in O j in D k in P \n       sum_k in P x_i j k le u_ij  forall i in O j in D\nendaligned","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"Note that the last constraint is new; it says that there is a maximum quantity of goods (of any type) that can be transported from origin i to destination j.","category":"page"},{"location":"tutorials/linear/multi/#Data","page":"The multi-commodity flow problem","title":"Data","text":"","category":"section"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"For the purpose of this tutorial, the JuMP repository contains an example database called multi.sqlite.","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"filename = joinpath(@__DIR__, \"multi.sqlite\");\nnothing #hide","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"To run locally, download multi.sqlite and update filename appropriately.","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"Load the database using SQLite.DB:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"db = SQLite.DB(filename)","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"A quick way to see the schema of the database is via SQLite.tables:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"SQLite.tables(db)","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"We interact with the database by executing queries, and then piping the results to an appropriate table. One example is a DataFrame:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"DBInterface.execute(db, \"SELECT * FROM locations\") |> DataFrames.DataFrame","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"But other table types are supported, such as Tables.rowtable:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"DBInterface.execute(db, \"SELECT * FROM locations\") |> Tables.rowtable","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"A rowtable is a Vector of NamedTuples.","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"You can construct more complicated SQL queries:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"origins =\n    DBInterface.execute(\n        db,\n        \"SELECT location FROM locations WHERE type = \\\"origin\\\"\",\n    ) |> Tables.rowtable","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"But for our purpose, we just want the list of strings:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"origins = map(y -> y.location, origins)","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"We can compose these two operations to get a list of destinations:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"destinations =\n    DBInterface.execute(\n        db,\n        \"SELECT location FROM locations WHERE type = \\\"destination\\\"\",\n    ) |>\n    Tables.rowtable |>\n    x -> map(y -> y.location, x)","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"And a list of products from our products table:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"products =\n    DBInterface.execute(db, \"SELECT product FROM products\") |>\n    Tables.rowtable |>\n    x -> map(y -> y.product, x)","category":"page"},{"location":"tutorials/linear/multi/#JuMP-formulation","page":"The multi-commodity flow problem","title":"JuMP formulation","text":"","category":"section"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"We start by creating a model and our decision variables:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, x[origins, destinations, products] >= 0)","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"One approach when working with databases is to extract all of the data into a Julia datastructure. For example, let's pull the cost table into a DataFrame and then construct our objective by iterating over the rows of the DataFrame:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"cost = DBInterface.execute(db, \"SELECT * FROM cost\") |> DataFrames.DataFrame\n@objective(\n    model,\n    Max,\n    sum(r.cost * x[r.origin, r.destination, r.product] for r in eachrow(cost)),\n);\nnothing #hide","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"If we don't want to use a DataFrame, we can use a Tables.rowtable instead:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"supply = DBInterface.execute(db, \"SELECT * FROM supply\") |> Tables.rowtable\nfor r in supply\n    @constraint(model, sum(x[r.origin, :, r.product]) <= r.supply)\nend","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"Another approach is to execute the query, and then to iterate through the rows of the query using Tables.rows:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"demand = DBInterface.execute(db, \"SELECT * FROM demand\")\nfor r in Tables.rows(demand)\n    @constraint(model, sum(x[:, r.destination, r.product]) == r.demand)\nend","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"warning: Warning\nIterating through the rows of a query result works by incrementing a cursor inside the database. As a consequence, you cannot call Tables.rows twice on the same query result.","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"The SQLite queries can be arbitrarily complex. For example, here's a query which builds every possible origin-destination pair:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"od_pairs = DBInterface.execute(\n    db,\n    \"\"\"\n    SELECT a.location as 'origin',\n           b.location as 'destination'\n    FROM locations a\n    INNER JOIN locations b\n    ON a.type = 'origin' AND b.type = 'destination'\n    \"\"\",\n)","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"With a constraint that we cannot send more than 625 units between each pair:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"for r in Tables.rows(od_pairs)\n    @constraint(model, sum(x[r.origin, r.destination, :]) <= 625)\nend","category":"page"},{"location":"tutorials/linear/multi/#Solution","page":"The multi-commodity flow problem","title":"Solution","text":"","category":"section"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"Finally, we can optimize the model:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"optimize!(model)\nTest.@test is_solved_and_feasible(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"and print the solution:","category":"page"},{"location":"tutorials/linear/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"begin\n    println(\"         \", join(products, ' '))\n    for o in origins, d in destinations\n        v = lpad.([round(Int, value(x[o, d, p])) for p in products], 5)\n        println(o, \" \", d, \" \", join(replace.(v, \"   0\" => \"  . \"), \" \"))\n    end\nend","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"EditURL = \"finance.jl\"","category":"page"},{"location":"tutorials/linear/finance/#Financial-modeling-problems","page":"Financial modeling problems","title":"Financial modeling problems","text":"","category":"section"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"This tutorial was originally contributed by Arpit Bhatia.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Optimization models play an increasingly important role in financial decisions. Many computational finance problems can be solved efficiently using modern optimization techniques.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"In this tutorial we will discuss two such examples taken from (Cornuéjols et al., 2018).","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"This tutorial uses the following packages","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"using JuMP\nimport HiGHS","category":"page"},{"location":"tutorials/linear/finance/#Short-term-financing","page":"Financial modeling problems","title":"Short-term financing","text":"","category":"section"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Corporations routinely face the problem of financing short term cash commitments such as the following:","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Month Jan Feb Mar Apr May Jun\nNet Cash Flow -150 -100 200 -200 50 300","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Net cash flow requirements are given in thousands of dollars. The company has the following sources of funds:","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"A line of credit of up to $100K at an interest rate of 1% per month,\nIn any one of the first three months, it can issue 90-day commercial paper bearing a total interest of 2% for the 3-month period,\nExcess funds can be invested at an interest rate of 0.3% per month.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Our task is to find out the most economical way to use these 3 sources such that we end up with the most amount of money at the end of June.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"We model this problem in the following manner:","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"We will use the following decision variables:","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"the amount u_i drawn from the line of credit in month i\nthe amount v_i of commercial paper issued in month i\nthe excess funds w_i in month i","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Here we have three types of constraints:","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"for every month, cash inflow = cash outflow for each month\nupper bounds on u_i\nnonnegativity of the decision variables u_i, v_i and w_i.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Our objective will be to simply maximize the company's wealth in June, which say we represent with the variable m.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"financing = Model(HiGHS.Optimizer)\n\n@variables(financing, begin\n    0 <= u[1:5] <= 100\n    0 <= v[1:3]\n    0 <= w[1:5]\n    m\nend)\n\n@objective(financing, Max, m)\n\n@constraints(\n    financing,\n    begin\n        u[1] + v[1] - w[1] == 150 # January\n        u[2] + v[2] - w[2] - 1.01u[1] + 1.003w[1] == 100 # February\n        u[3] + v[3] - w[3] - 1.01u[2] + 1.003w[2] == -200 # March\n        u[4] - w[4] - 1.02v[1] - 1.01u[3] + 1.003w[3] == 200 # April\n        u[5] - w[5] - 1.02v[2] - 1.01u[4] + 1.003w[4] == -50 # May\n        -m - 1.02v[3] - 1.01u[5] + 1.003w[5] == -300 # June\n    end\n)\n\noptimize!(financing)\n@assert is_solved_and_feasible(financing)\nobjective_value(financing)","category":"page"},{"location":"tutorials/linear/finance/#Combinatorial-auctions","page":"Financial modeling problems","title":"Combinatorial auctions","text":"","category":"section"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"In many auctions, the value that a bidder has for a set of items may not be the sum of the values that he has for individual items.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Examples are equity trading, electricity markets, pollution right auctions and auctions for airport landing slots.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"To take this into account, combinatorial auctions allow the bidders to submit bids on combinations of items.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Let M=12 ldots m be the set of items that the auctioneer has to sell. A bid is a pair B_j=left(S_j p_jright) where S_j subseteq M is a nonempty set of items and p_j is the price offer for this set.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"Suppose that the auctioneer has received n bids B_1 B_2 ldots B_n The goal of this problem is to help an auctioneer determine the winners in order to maximize his revenue.","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"We model this problem by taking a decision variable y_j for every bid. We add a constraint that each item i is sold at most once. This gives us the following model:","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"beginaligned\nmax  sum_i=1^n p_j y_j \ntext  st    sum_j  i in S_j y_j leq 1  forall i=12 ldots m \n y_j in01  forall j in12 ldots n\nendaligned","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"bid_values = [6 3 12 12 8 16]\nbid_items = [[1], [2], [3 4], [1 3], [2 4], [1 3 4]]\n\nauction = Model(HiGHS.Optimizer)\n@variable(auction, y[1:6], Bin)\n@objective(auction, Max, sum(y' .* bid_values))\nfor i in 1:6\n    @constraint(auction, sum(y[j] for j in 1:6 if i in bid_items[j]) <= 1)\nend\noptimize!(auction)\n@assert is_solved_and_feasible(auction)\nobjective_value(auction)","category":"page"},{"location":"tutorials/linear/finance/","page":"Financial modeling problems","title":"Financial modeling problems","text":"value.(y)","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"EditURL = \"https://github.com/GAMS-dev/GAMS.jl/blob/e00a845d42653adf5d26c7cef1ef84fb990c91c7/README.md\"","category":"page"},{"location":"packages/GAMS/#GAMS.jl","page":"GAMS-dev/GAMS.jl","title":"GAMS.jl","text":"","category":"section"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"GAMS.jl provides a MathOptInterface Optimizer to solve JuMP models using GAMS.","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"GAMS comes with dozens of supported solvers. Among them are: ALPHAECP, ANTIGONE, BARON, CBC, CONOPT, CPLEX, DICOPT, GUROBI, IPOPT, KNITRO, LINDO, LINDOGLOBAL, MINOS, MOSEK, NLPEC, PATH, QUADMINOS, SBB, SHOT, SCIP, SNOPT, SOPLEX, XPRESS. Find a complete list here.","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"GAMS.jl supports the following JuMP features:","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"linear, quadratic and nonlinear (convex and non-convex) objective and constraints\ncontinuous, binary, integer, semi-continuous and semi-integer variables\nSOS1 and SOS2 sets\ncomplementarity constraints","category":"page"},{"location":"packages/GAMS/#Installation","page":"GAMS-dev/GAMS.jl","title":"Installation","text":"","category":"section"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"Download GAMS and obtain a GAMS license. Please note that GAMS also offers a free community license.\n(optional) Add the GAMS system directory to the PATH variable in order to find GAMS automatically.\nInstall GAMS.jl using the Julia package manager:\nusing Pkg\nPkg.add(\"GAMS\")","category":"page"},{"location":"packages/GAMS/#Usage","page":"GAMS-dev/GAMS.jl","title":"Usage","text":"","category":"section"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"Using GAMS as optimizer for your JuMP model:","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"using GAMS, JuMP\nmodel = Model(GAMS.Optimizer)","category":"page"},{"location":"packages/GAMS/#GAMS-System","page":"GAMS-dev/GAMS.jl","title":"GAMS System","text":"","category":"section"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"If the GAMS system directory has been added to the PATH variable (you can check this with print(ENV[\"PATH\"])), GAMS.jl will find it automatically. Otherwise, or if you like to switch between systems, the system directory can be specified by (one of the following):","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"set_optimizer_attribute(model, \"SysDir\", \"<gams_system_dir>\")\nset_optimizer_attribute(model, GAMS.SysDir(), \"<gams_system_dir>\")","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"Analogously, you can specify a working directory with \"WorkDir\" or GAMS.WorkDir(). If no working directory has been set, GAMS.jl will create a temporary one.","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"If you want to use the same GAMS workspace (same system and working directory) for multiple models, you can create a GAMSWorkspace first with either of the following","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"ws = GAMS.GAMSWorkspace()\nws = GAMS.GAMSWorkspace(\"<gams_system_dir>\")\nws = GAMS.GAMSWorkspace(\"<gams_system_dir>\", \"<gams_working_dir>\")","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"and then pass it to your models:","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"model = Model(() -> GAMS.Optimizer(ws))","category":"page"},{"location":"packages/GAMS/#GAMS-Options","page":"GAMS-dev/GAMS.jl","title":"GAMS Options","text":"","category":"section"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"GAMS command line options can be specified by","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"set_optimizer_attribute(model, \"<option>\", \"<solver_name>\")\nset_optimizer_attribute(model, GAMS.<option>(), \"<solver_name>\")","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"where <option> is either HoldFixed, IterLim, License, LogOption, NodLim, OptCA, OptCR, ResLim, Solver, Threads, Trace, TraceOpt as well as LP, MIP, RMIP, NLP, DNLP, CNS, MINLP, RMINLP, QCP, MIQCP, RMIQCP, MCP or MPEC. Note that GAMS.ResLim() is equivalent to MOI.TimeLimitSec() and GAMS.Threads() to MOI.NumberOfThreads(). Options LimCol, LimRow, SolPrint and SolveLink cannot be changed and are set to 0, 0, 0 and 5, respectively.","category":"page"},{"location":"packages/GAMS/#Model-Type","page":"GAMS-dev/GAMS.jl","title":"Model Type","text":"","category":"section"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"GAMS.jl will automatically choose a GAMS model type for you. Choosing a different model type:","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"set_optimizer_attribute(model, GAMS.ModelType(), \"<model_type>\")","category":"page"},{"location":"packages/GAMS/#GAMS-Solver-Options","page":"GAMS-dev/GAMS.jl","title":"GAMS Solver Options","text":"","category":"section"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"Specifying GAMS solver options:","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"set_optimizer_attribute(model, \"<solver_option_name>\", <option_value>)","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"Note that passing a solver option is only valid when explicitly choosing a GAMS solver and not using the default.","category":"page"},{"location":"packages/GAMS/#GAMS-Names-vs.-JuMP-Names","page":"GAMS-dev/GAMS.jl","title":"GAMS Names vs. JuMP Names","text":"","category":"section"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"GAMS uses generated variable and constraint names although it is possible to pass the JuMP names to the GAMS optimizer, because GAMS is more restrictive when it comes to variable and constraint naming. Use the attributes GeneratedVariableName, GeneratedConstraintName, OriginalVariableName, OriginalConstraintName to query a GAMS symbol name from a JuMP symbol and vice versa. This can help for debugging, for example in case of GAMS compilation errors. For example:","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"using GAMS\n\nmodel = direct_model(GAMS.Optimizer())\n\n@variable(model, x[1:2,1:3] >= 0)\n@constraint(model, c[i = 1:2], sum(x[i,j] for j = 1:3) <= 10)\n\nMOI.get(model, GAMS.GeneratedVariableName(), x[2,2]) # returns x4\nMOI.get(model, GAMS.OriginalVariableName(\"x6\"))      # returns x[2,3]\nMOI.get(model, GAMS.OriginalVariableName(\"x10\"))     # returns nothing\n\nMOI.get(model, GAMS.GeneratedConstraintName(), c[2]) # returns eq2\nMOI.get(model, GAMS.OriginalConstraintName(\"eq1\"))   # returns c[1]\nMOI.get(model, GAMS.OriginalConstraintName(\"eq10\"))  # returns nothing","category":"page"},{"location":"packages/GAMS/","page":"GAMS-dev/GAMS.jl","title":"GAMS-dev/GAMS.jl","text":"Note that JuMP direct-mode is used.","category":"page"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"EditURL = \"https://github.com/jump-dev/Pavito.jl/blob/v0.3.8/README.md\"","category":"page"},{"location":"packages/Pavito/#Pavito.jl","page":"jump-dev/Pavito.jl","title":"Pavito.jl","text":"","category":"section"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"(Image: Build Status) (Image: Coverage)","category":"page"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"Pavito.jl is a mixed-integer convex programming (MICP) solver package written in Julia.","category":"page"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"MICP problems are convex, except for restrictions that some variables take binary or integer values.","category":"page"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"Pavito solves MICP problems by constructing sequential polyhedral outer-approximations of the convex feasible set, similar to Bonmin.","category":"page"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"Pavito accesses state-of-the-art MILP solvers and continuous, derivative-based nonlinear programming (NLP) solvers through MathOptInterface.","category":"page"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"For algorithms that use a conic solver instead of an NLP solver, use Pajarito. Pajarito is a robust mixed-integer conic solver that can handle such established problem classes as mixed-integer second-order cone programming (MISOCP) and mixed-integer semidefinite programming (MISDP).","category":"page"},{"location":"packages/Pavito/#License","page":"jump-dev/Pavito.jl","title":"License","text":"","category":"section"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"Pavito.jl is licensed under the MPL 2.0 license.","category":"page"},{"location":"packages/Pavito/#Installation","page":"jump-dev/Pavito.jl","title":"Installation","text":"","category":"section"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"Install Pavito using Pkg.add:","category":"page"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"import Pkg\nPkg.add(\"Pavito\")","category":"page"},{"location":"packages/Pavito/#Use-with-JuMP","page":"jump-dev/Pavito.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"To use Pavito with JuMP, use Pavito.Optimizer:","category":"page"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"using JuMP, Pavito\nimport GLPK, Ipopt\nmodel = Model(\n    optimizer_with_attributes(\n        Pavito.Optimizer,\n        \"mip_solver\" => optimizer_with_attributes(GLPK.Optimizer),\n        \"cont_solver\" =>\n            optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0),\n    ),\n)","category":"page"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"The algorithm implemented by Pavito itself is relatively simple; most of the hard work is performed by the MILP solver passed as mip_solver and the NLP solver passed as cont_solver.","category":"page"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"The performance of Pavito depends on these two types of solvers.","category":"page"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"For better performance, you should use a commercial MILP solver such as CPLEX or Gurobi.","category":"page"},{"location":"packages/Pavito/#Options","page":"jump-dev/Pavito.jl","title":"Options","text":"","category":"section"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"The following optimizer attributes can set to a Pavito.Optimizer to modify its behavior:","category":"page"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"log_level::Int Verbosity flag: 0 for quiet, higher for basic solve info\ntimeout::Float64 Time limit for algorithm (in seconds)\nrel_gap::Float64 Relative optimality gap termination condition\nmip_solver_drives::Bool Let MILP solver manage convergence (\"branch and cut\")\nmip_solver::MOI.OptimizerWithAttributes MILP solver\ncont_solver::MOI.OptimizerWithAttributes Continuous NLP solver","category":"page"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"Pavito is not yet numerically robust and may require tuning of parameters to improve convergence.","category":"page"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"If the default parameters don't work for you, please let us know by opening an issue.","category":"page"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"For improved Pavito performance, MILP solver integrality tolerance and feasibility tolerances should typically be tightened, for example to 1e-8.","category":"page"},{"location":"packages/Pavito/#Bug-reports-and-support","page":"jump-dev/Pavito.jl","title":"Bug reports and support","text":"","category":"section"},{"location":"packages/Pavito/","page":"jump-dev/Pavito.jl","title":"jump-dev/Pavito.jl","text":"Please report any issues via the GitHub issue tracker. All types of issues are welcome and encouraged; this includes bug reports, documentation typos, feature requests, etc. The Optimization (Mathematical) category on Discourse is appropriate for general discussion.","category":"page"},{"location":"developers/contributing/#How-to-contribute-to-JuMP","page":"Contributing","title":"How to contribute to JuMP","text":"","category":"section"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Welcome, this document explains some ways you can contribute to JuMP.","category":"page"},{"location":"developers/contributing/#Code-of-Conduct","page":"Contributing","title":"Code of Conduct","text":"","category":"section"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"This project and everyone participating in it is governed by the JuMP Code of Conduct. By participating, you are expected to uphold this code.","category":"page"},{"location":"developers/contributing/#Join-the-community-forum","page":"Contributing","title":"Join the community forum","text":"","category":"section"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"First up, join the community forum.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"The forum is a good place to ask questions about how to use JuMP. You can also use the forum to discuss possible feature requests and bugs before raising a GitHub issue (more on this below).","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Aside from asking questions, the easiest way you can contribute to JuMP is to help answer questions on the forum.","category":"page"},{"location":"developers/contributing/#Join-the-developer-chatroom","page":"Contributing","title":"Join the developer chatroom","text":"","category":"section"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"If you're interested in contributing code to JuMP, the next place to join is the developer chatroom. Let us know what you have in mind, and we can point you in the right direction.","category":"page"},{"location":"developers/contributing/#Improve-the-documentation","page":"Contributing","title":"Improve the documentation","text":"","category":"section"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Chances are, if you asked (or answered) a question on the community forum, then it is a sign that the documentation could be improved. Moreover, since it is your question, you are probably the best-placed person to improve it.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"The docs are written in Markdown and are built using Documenter.jl. You can find the source of all the docs here.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"If your change is small (like fixing typos, or one or two sentence corrections), the easiest way to do this is via GitHub's online editor. (GitHub has help on how to do this.)","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"If your change is larger, or touches multiple files, you will need to make the change locally and then use Git to submit a pull request. (See Contribute code to JuMP below for more on this.)","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"tip: Tip\nIf you need any help, come join the developer chatroom and we will walk you through the process.","category":"page"},{"location":"developers/contributing/#File-a-bug-report","page":"Contributing","title":"File a bug report","text":"","category":"section"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Another way to contribute to JuMP is to file bug reports.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Make sure you read the info in the box where you write the body of the issue before posting. You can also find a copy of that info here.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"tip: Tip\nIf you're unsure whether you have a real bug, post on the community forum first. Someone will either help you fix the problem, or let you know the most appropriate place to open a bug report.","category":"page"},{"location":"developers/contributing/#Contribute-code-to-JuMP","page":"Contributing","title":"Contribute code to JuMP","text":"","category":"section"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Finally, you can also contribute code to JuMP.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"warning: Warning\nIf you do not have experience with Git, GitHub, and Julia development, the first steps can be a little daunting. However, there are lots of tutorials available online, including these for:GitHub\nGit and GitHub\nGit\nJulia package developmentIf you need any help, come join the developer chatroom and we will walk you through the process.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Once you are familiar with Git and GitHub, the workflow for contributing code to JuMP is similar to the following:","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 1: decide what to work on","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"The first step is to find an open issue (or open a new one) for the problem you want to solve. Then, before spending too much time on it, discuss what you are planning to do in the issue to see if other contributors are fine with your proposed changes. Getting feedback early can improve code quality, and avoid time spent writing code that does not get merged into JuMP.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"tip: Tip\nAt this point, remember to be patient and polite; you may get a lot of comments on your issue. However, do not be afraid. Comments mean that people are willing to help you improve the code that you are contributing to JuMP.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 2: fork JuMP","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Go to https://github.com/jump-dev/JuMP.jl and click the \"Fork\" button in the top-right corner. This will create a copy of JuMP under your GitHub account.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 3: install JuMP locally","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Open Julia and run:","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"] dev JuMP","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"This will download the JuMP Git repository to ~/.julia/dev/JuMP. If you're on Windows, this will be C:\\\\Users\\\\<my_name>\\\\.julia\\\\dev\\\\JuMP.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"warning: Warning\n] command means \"first type ] to enter the Julia pkg mode, then type the rest. Don't copy-paste the code directly.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 4: checkout a new branch","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nIn the following, replace any instance of GITHUB_ACCOUNT with your GitHub user name.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"The next step is to checkout a development branch. In a terminal (or command prompt on Windows), run:","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"$ cd ~/.julia/dev/JuMP\n\n$ git remote add GITHUB_ACCOUNT https://github.com/GITHUB_ACCOUNT/JuMP.jl.git\n\n$ git checkout master\n\n$ git pull\n\n$ git checkout -b my_new_branch","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"tip: Tip\nLines starting with $ mean \"run these in a terminal (command prompt on Windows).\"","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 5: make changes","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Now make any changes to the source code inside the ~/.julia/dev/JuMP directory.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Make sure you:","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Follow the Style guide and run JuliaFormatter\nAdd tests and documentation for any changes or new features","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"tip: Tip\nWhen you change the source code, you'll need to restart Julia for the changes to take effect. This is a pain, so install Revise.jl.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 6a: test your code changes","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"To test that your changes work, run the JuMP test-suite by opening Julia and running:","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"cd(\"~/.julia/dev/JuMP\")\n] activate .\n] test","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"warning: Warning\nRunning the tests might take a long time (~10–15 minutes).","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"tip: Tip\nIf you're using Revise.jl, you can also run the tests by calling include:include(\"test/runtests.jl\")This can be faster if you want to re-run the tests multiple times.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 6b: test your documentation changes","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Open Julia, then run:","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"cd(\"~/.julia/dev/JuMP/docs\")\n] activate .\ninclude(\"src/make.jl\")","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"warning: Warning\nBuilding the documentation might take a long time (~10 minutes).","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"tip: Tip\nIf there's a problem with the tests that you don't know how to fix, don't worry. Continue to step 5, and one of the JuMP contributors will comment on your pull request telling you how to fix things.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 7: make a pull request","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Once you've made changes, you're ready to push the changes to GitHub. Run:","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"$ cd ~/.julia/dev/JuMP\n\n$ git add .\n\n$ git commit -m \"A descriptive message of the changes\"\n\n$ git push -u GITHUB_ACCOUNT my_new_branch","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Then go to https://github.com/jump-dev/JuMP.jl and follow the instructions that pop up to open a pull request.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 8: respond to comments","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"At this point, remember to be patient and polite; you may get a lot of comments on your pull request. However, do not be afraid. A lot of comments means that people are willing to help you improve the code that you are contributing to JuMP.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"To respond to the comments, go back to step 5, make any changes, test the changes in step 6, and then make a new commit in step 7. Your PR will automatically update.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Step 9: cleaning up","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"Once the PR is merged, clean-up your Git repository ready for the next contribution.","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"$ cd ~/.julia/dev/JuMP\n\n$ git checkout master\n\n$ git pull","category":"page"},{"location":"developers/contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nIf you have suggestions to improve this guide, please make a pull request. It's particularly helpful if you do this after your first pull request because you'll know all the parts that could be explained better.","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"EditURL = \"knapsack.jl\"","category":"page"},{"location":"tutorials/linear/knapsack/#The-knapsack-problem-example","page":"The knapsack problem example","title":"The knapsack problem example","text":"","category":"section"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"The purpose of this tutorial is to demonstrate how to formulate and solve a simple optimization problem.","category":"page"},{"location":"tutorials/linear/knapsack/#Required-packages","page":"The knapsack problem example","title":"Required packages","text":"","category":"section"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"This tutorial requires the following packages:","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"using JuMP\nimport HiGHS","category":"page"},{"location":"tutorials/linear/knapsack/#Formulation","page":"The knapsack problem example","title":"Formulation","text":"","category":"section"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"The knapsack problem is a classical optimization problem: given a set of items and a container with a fixed capacity, choose a subset of items having the greatest combined value that will fit within the container without exceeding the capacity.","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"The name of the problem suggests its analogy to packing for a trip, where the baggage weight limit is the capacity and the goal is to pack the most profitable combination of belongings.","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"We can formulate the knapsack problem as the integer linear program:","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"beginaligned\nmax   sum_i=1^n c_i x_i      \nst   sum_i=1^n w_i x_i le C \n         x_i in 01quad forall i=1ldotsn\nendaligned","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"where C is the capacity, and there is a choice between n items, with item i having weight w_i, profit c_i. Decision variable x_i is equal to 1 if the item is chosen and 0 if not.","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"This formulation can be written more compactly as:","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"beginaligned\nmax   c^top x       \nst   w^top x le C \n         x text binary \nendaligned","category":"page"},{"location":"tutorials/linear/knapsack/#Data","page":"The knapsack problem example","title":"Data","text":"","category":"section"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"The data for the problem consists of two vectors (one for the profits and one for the weights) along with a capacity.","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"There are five objects:","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"n = 5;\nnothing #hide","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"For our example, we use a capacity of 10 units:","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"capacity = 10.0;\nnothing #hide","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"and the profit and cost data:","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"profit = [5.0, 3.0, 2.0, 7.0, 4.0];\nweight = [2.0, 8.0, 4.0, 2.0, 5.0];\nnothing #hide","category":"page"},{"location":"tutorials/linear/knapsack/#JuMP-formulation","page":"The knapsack problem example","title":"JuMP formulation","text":"","category":"section"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"Let's begin constructing the JuMP model for our knapsack problem.","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"First, we'll create a Model object for holding model elements as we construct each part. We'll also set the solver that will ultimately be called to solve the model, once it's constructed.","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"model = Model(HiGHS.Optimizer)","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"Next we need the decision variables representing which items are chosen:","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"@variable(model, x[1:n], Bin)","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"We now want to constrain those variables so that their combined weight is less than or equal to the given capacity:","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"@constraint(model, sum(weight[i] * x[i] for i in 1:n) <= capacity)","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"Finally, our objective is to maximize the combined profit of the chosen items:","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"@objective(model, Max, sum(profit[i] * x[i] for i in 1:n))","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"Let's print a human-readable description of the model and check that the model looks as expected:","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"print(model)","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"We can now solve the optimization problem and inspect the results.","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"optimize!(model)\n@assert is_solved_and_feasible(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"The items chosen are","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"items_chosen = [i for i in 1:n if value(x[i]) > 0.5]","category":"page"},{"location":"tutorials/linear/knapsack/#Writing-a-function","page":"The knapsack problem example","title":"Writing a function","text":"","category":"section"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"After working interactively, it is good practice to implement your model in a function.","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"The function can be used to ensure that the model is given well-defined input data with validation checks, and that the solution process went as expected.","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"function solve_knapsack_problem(;\n    profit::Vector{Float64},\n    weight::Vector{Float64},\n    capacity::Float64,\n)\n    n = length(weight)\n    # The profit and weight vectors must be of equal length.\n    @assert length(profit) == n\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    @variable(model, x[1:n], Bin)\n    @objective(model, Max, profit' * x)\n    @constraint(model, weight' * x <= capacity)\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    println(\"Objective is: \", objective_value(model))\n    println(\"Solution is:\")\n    for i in 1:n\n        print(\"x[$i] = \", round(Int, value(x[i])))\n        println(\", c[$i] / w[$i] = \", profit[i] / weight[i])\n    end\n    chosen_items = [i for i in 1:n if value(x[i]) > 0.5]\n    return return chosen_items\nend\n\nsolve_knapsack_problem(; profit = profit, weight = weight, capacity = capacity)","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"We observe that the chosen items (1, 4, and 5) have the best profit to weight ratio in this particular example.","category":"page"},{"location":"tutorials/linear/knapsack/#Next-steps","page":"The knapsack problem example","title":"Next steps","text":"","category":"section"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"Here are some things to try next:","category":"page"},{"location":"tutorials/linear/knapsack/","page":"The knapsack problem example","title":"The knapsack problem example","text":"Call the function with different data. What happens as the capacity increases?\nWhat happens if the profit and weight vectors are different lengths?\nInstead of creating a binary variable with Bin, we could have written @variable(model, 0 <= x[1:n] <= 1, Int). Verify that this formulation finds the same solution. What happens if we are allowed to take more than one of each item?","category":"page"},{"location":"developers/checklists/#Checklists","page":"Checklists","title":"Checklists","text":"","category":"section"},{"location":"developers/checklists/","page":"Checklists","title":"Checklists","text":"The purpose of this page is to collate a series of checklists for commonly performed changes to the source code of JuMP.","category":"page"},{"location":"developers/checklists/","page":"Checklists","title":"Checklists","text":"In each case, copy the checklist into the description of the pull request.","category":"page"},{"location":"developers/checklists/#Making-a-release","page":"Checklists","title":"Making a release","text":"","category":"section"},{"location":"developers/checklists/","page":"Checklists","title":"Checklists","text":"In preparation for a release, use the following checklist. These steps can be done in the same commit, or separately. The last commit should have the message \"Prep for vX.Y.Z.\"","category":"page"},{"location":"developers/checklists/","page":"Checklists","title":"Checklists","text":"## Pre-release\n\n - [ ] Check that the pinned packages in `docs/Project.toml` are updated. We pin\n       the versions so that changes in the solvers (changes in printing, small\n       numeric changes) do not break the printing of the JuMP docs in arbitrary\n       commits.\n - [ ] Check that the `rev` fields in `docs/packages.toml` are updated. We pin\n       the versions of solvers and extensions to ensure that changes to their\n       READMEs do not break the JuMP docs in arbitrary commits, and to ensure\n       that the versions are compatible with the latest JuMP and\n       MathOptInterface releases.\n - [ ] Check compat of `DimensionalData` in `Project.toml`\n - [ ] Check compat of `MacroTools` in `Project.toml`\n - [ ] Update `docs/src/changelog.md`\n - [ ] Run https://github.com/jump-dev/JuMP.jl/actions/workflows/extension-tests.yml\n       using a `workflow_dispatch` trigger to check for any changes in JuMP that\n       broke extensions.\n - [ ] Change the version number in `Project.toml`\n - [ ] The commit messages in this PR do not contain `[ci skip]`\n\n## The release\n\n - [ ] After merging this pull request, comment `[at]JuliaRegistrator register` in\n       the GitHub commit. This should automatically publish a new version to the\n       Julia registry, as well as create a tag, and rebuild the documentation\n       for this tag.\n\n       These steps can take quite a bit of time (1 hour or more), so don't be\n       surprised if the new documentation takes a while to appear. In addition,\n       the links in the README will be broken until JuliaHub fetches the new\n       version on their servers.\n\n## Post-release\n\n - [ ] Once the tag is created, update the relevant `release-` branch. The latest\n       release branch at the time of writing is `release-1.0` (we haven't\n       back-ported any patches that needed to create a `release-1.Y` branch). To\n       to update the release branch with the v1.10.0 tag, do:\n       ```\n       git checkout release-1.0\n       git pull\n       git merge v1.10.0\n       git push\n       ```","category":"page"},{"location":"developers/checklists/#Adding-a-new-solver-to-the-documentation","page":"Checklists","title":"Adding a new solver to the documentation","text":"","category":"section"},{"location":"developers/checklists/","page":"Checklists","title":"Checklists","text":"Use the following checklist when adding a new solver to the JuMP documentation.","category":"page"},{"location":"developers/checklists/","page":"Checklists","title":"Checklists","text":"## Basic\n\n - [ ] Check that the solver is a registered Julia package\n - [ ] Check that the solver supports the long-term support release of Julia\n - [ ] Check that the solver has a MathOptInterface wrapper\n - [ ] Check that the tests call `MOI.Test.runtests`. Some test excludes are\n       permissible, but the reason for skipping a particular test should be\n       documented.\n - [ ] Check that the README and/or documentation provides an example of how to\n       use the solver with JuMP\n\n## Documentation\n\n - [ ] Add a new row to the table in `docs/src/installation.md`\n\n## Optional\n\n - [ ] Add package metadata to `docs/packages.toml`","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"EditURL = \"simple_examples.jl\"","category":"page"},{"location":"tutorials/conic/simple_examples/#Simple-semidefinite-programming-examples","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"","category":"section"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"This tutorial is a collection of examples of small conic programs from the field of semidefinite programming (SDP).","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"This tutorial makes use of the following packages:","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"using JuMP\nimport LinearAlgebra\nimport Plots\nimport Random\nimport SCS\nimport Test","category":"page"},{"location":"tutorials/conic/simple_examples/#Maximum-cut-via-SDP","page":"Simple semidefinite programming examples","title":"Maximum cut via SDP","text":"","category":"section"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"The maximum cut problem is a classical example in graph theory, where we seek to partition a graph into two complementary sets, such that the weight of edges between the two sets is maximized. This problem is NP-hard, but it is possible to obtain an approximate solution using the semidefinite programming relaxation:","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"    textmax  quad   025 LX \n    text    st quad   mathrmdiag(X) = e \n                 qquad X succeq 0","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"where L is the weighted graph Laplacian and e is a vector of ones. For more details, see (Goemans and Williamson, 1995).","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"\"\"\"\n    svd_cholesky(X::AbstractMatrix, rtol)\n\nReturn the matrix `U` of the Cholesky decomposition of `X` as `U' * U`.\nNote that we do not use the `LinearAlgebra.cholesky` function because it\nrequires the matrix to be positive definite while `X` may be only\npositive *semi*definite.\n\nWe use the convention `U' * U` instead of `U * U'` to be consistent with\n`LinearAlgebra.cholesky`.\n\"\"\"\nfunction svd_cholesky(X::AbstractMatrix)\n    F = LinearAlgebra.svd(X)\n    # We now have `X ≈ `F.U * D² * F.U'` where:\n    D = LinearAlgebra.Diagonal(sqrt.(F.S))\n    # So `X ≈ U' * U` where `U` is:\n    return (F.U * D)'\nend\n\nfunction solve_max_cut_sdp(weights)\n    N = size(weights, 1)\n    # Calculate the (weighted) Laplacian of the graph: L = D - W.\n    L = LinearAlgebra.diagm(0 => weights * ones(N)) - weights\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, X[1:N, 1:N], PSD)\n    for i in 1:N\n        set_start_value(X[i, i], 1.0)\n    end\n    @objective(model, Max, 0.25 * LinearAlgebra.dot(L, X))\n    @constraint(model, LinearAlgebra.diag(X) .== 1)\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    V = svd_cholesky(value(X))\n    Random.seed!(N)\n    r = rand(N)\n    r /= LinearAlgebra.norm(r)\n    cut = [LinearAlgebra.dot(r, V[:, i]) > 0 for i in 1:N]\n    S = findall(cut)\n    T = findall(.!cut)\n    println(\"Solution:\")\n    println(\" (S, T) = ({\", join(S, \", \"), \"}, {\", join(T, \", \"), \"})\")\n    return S, T\nend","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"Given the graph","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"[1] --- 5 --- [2]","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"The solution is (S, T)  = ({1}, {2})","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"S, T = solve_max_cut_sdp([0 5; 5 0])","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"Given the graph","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"[1] --- 5 --- [2]\n |  \\          |\n |    \\        |\n 7      6      1\n |        \\    |\n |          \\  |\n[3] --- 1 --- [4]","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"The solution is (S, T)  = ({1}, {2, 3, 4})","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"S, T = solve_max_cut_sdp([0 5 7 6; 5 0 0 1; 7 0 0 1; 6 1 1 0])","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"Given the graph","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"[1] --- 1 --- [2]\n |             |\n |             |\n 5             9\n |             |\n |             |\n[3] --- 2 --- [4]","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"The solution is (S, T)  = ({1, 4}, {2, 3})","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"S, T = solve_max_cut_sdp([0 1 5 0; 1 0 0 9; 5 0 0 2; 0 9 2 0])","category":"page"},{"location":"tutorials/conic/simple_examples/#K-means-clustering-via-SDP","page":"Simple semidefinite programming examples","title":"K-means clustering via SDP","text":"","category":"section"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"Given a set of points a_1 ldots a_m  in mathbbR^n, allocate them to k clusters.","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"For more details, see (Peng and Wei, 2007).","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"function example_k_means_clustering()\n    a = [[2.0, 2.0], [2.5, 2.1], [7.0, 7.0], [2.2, 2.3], [6.8, 7.0], [7.2, 7.5]]\n    m = length(a)\n    num_clusters = 2\n    W = zeros(m, m)\n    for i in 1:m, j in i+1:m\n        W[i, j] = W[j, i] = exp(-LinearAlgebra.norm(a[i] - a[j]) / 1.0)\n    end\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, Z[1:m, 1:m] >= 0, PSD)\n    @objective(model, Min, LinearAlgebra.tr(W * (LinearAlgebra.I - Z)))\n    @constraint(model, [i = 1:m], sum(Z[i, :]) .== 1)\n    @constraint(model, LinearAlgebra.tr(Z) == num_clusters)\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    Z_val = value.(Z)\n    current_cluster, visited = 0, Set{Int}()\n    for i in 1:m\n        if !(i in visited)\n            current_cluster += 1\n            println(\"Cluster $current_cluster\")\n            for j in i:m\n                if isapprox(Z_val[i, i], Z_val[i, j]; atol = 1e-3)\n                    println(a[j])\n                    push!(visited, j)\n                end\n            end\n        end\n    end\n    return\nend\n\nexample_k_means_clustering()","category":"page"},{"location":"tutorials/conic/simple_examples/#The-correlation-problem","page":"Simple semidefinite programming examples","title":"The correlation problem","text":"","category":"section"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"Given three random variables A, B, and C, and given bounds on two of the three correlation coefficients:","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"    -02 leq ρ_AB leq -01 \n    04  leq ρ_BC leq  05","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"our problem is to determine upper and lower bounds on other correlation coefficient ρ_AC.","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"We solve an SDP to make use of the following positive semidefinite property of the correlation matrix:","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"beginbmatrix\n      1     ρ_AB   ρ_AC \n     ρ_AB   1      ρ_BC  \n     ρ_AC   ρ_BC   1\nendbmatrix succeq 0","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"function example_correlation_problem()\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, X[1:3, 1:3], PSD)\n    S = [\"A\", \"B\", \"C\"]\n    ρ = Containers.DenseAxisArray(X, S, S)\n    @constraint(model, [i in S], ρ[i, i] == 1)\n    @constraint(model, -0.2 <= ρ[\"A\", \"B\"] <= -0.1)\n    @constraint(model, 0.4 <= ρ[\"B\", \"C\"] <= 0.5)\n    @objective(model, Max, ρ[\"A\", \"C\"])\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    println(\"An upper bound for ρ_AC is $(value(ρ[\"A\", \"C\"]))\")\n    @objective(model, Min, ρ[\"A\", \"C\"])\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    println(\"A lower bound for ρ_AC is $(value(ρ[\"A\", \"C\"]))\")\n    return\nend\n\nexample_correlation_problem()","category":"page"},{"location":"tutorials/conic/simple_examples/#The-minimum-distortion-problem","page":"Simple semidefinite programming examples","title":"The minimum distortion problem","text":"","category":"section"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"This example arises from computational geometry, in particular the problem of embedding a general finite metric space into a Euclidean space.","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"It is known that the 4-point metric space defined by the star graph","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"  [1]\n    \\\n     1\n      \\\n      [0] —- 1 -- [2]\n      /\n     1\n    /\n  [3]","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"cannot be exactly embedded into a Euclidean space of any dimension, where distances are computed by length of the shortest path between vertices. A distance-preserving embedding would require the three leaf nodes to form an equilateral triangle of side length 2, with the centre node (0) mapped to an equidistant point at distance 1; this is impossible since the triangle inequality in Euclidean space implies all points would need to be simultaneously collinear.","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"Here we will formulate and solve an SDP to compute the best possible embedding, that is, the embedding f assigning each vertex v to a vector f(v) that minimizes the distortion c such that","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"    Da b leq f(a) - f(b) leq c  Da b","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"for all edges (a b) in the graph, where Da b is the distance in the graph metric space.","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"Any embedding f can be characterized by a Gram matrix Q, which is PSD and such that","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"    f(a) - f(b)^2 = Qa a + Qb b - 2 Qa b","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"The matrix entry Qab represents the inner product of f(a) with f(b).","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"We therefore impose the constraint","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"    Da b^2 leq Qa a + Qb b - 2 Qa b leq c^2  Da b^2","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"for all edges (a b) in the graph and minimize c^2, which gives us the SDP formulation below. Since we may choose any point to be the origin, we fix the first vertex at 0.","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"For more details, see (Matoušek, 2013; Linial, 2002).","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"function example_minimum_distortion()\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    D = [\n        0.0 1.0 1.0 1.0\n        1.0 0.0 2.0 2.0\n        1.0 2.0 0.0 2.0\n        1.0 2.0 2.0 0.0\n    ]\n    @variable(model, c² >= 1.0)\n    @variable(model, Q[1:4, 1:4], PSD)\n    for i in 1:4, j in (i+1):4\n        @constraint(model, D[i, j]^2 <= Q[i, i] + Q[j, j] - 2 * Q[i, j])\n        @constraint(model, Q[i, i] + Q[j, j] - 2 * Q[i, j] <= c² * D[i, j]^2)\n    end\n    fix(Q[1, 1], 0)\n    @objective(model, Min, c²)\n    optimize!(model)\n    Test.@test is_solved_and_feasible(model)\n    Test.@test objective_value(model) ≈ 4 / 3 atol = 1e-4\n    # Recover the minimal distorted embedding:\n    X = [zeros(3) sqrt(value.(Q)[2:end, 2:end])]\n    return Plots.plot(\n        X[1, :],\n        X[2, :],\n        X[3, :];\n        seriestype = :mesh3d,\n        connections = ([0, 0, 0, 1], [1, 2, 3, 2], [2, 3, 1, 3]),\n        legend = false,\n        fillalpha = 0.1,\n        lw = 3,\n        ratio = :equal,\n        xlim = (-1.1, 1.1),\n        ylim = (-1.1, 1.1),\n        zlim = (-1.5, 1.0),\n        zticks = -1:1,\n        camera = (60, 30),\n    )\nend\n\nexample_minimum_distortion()","category":"page"},{"location":"tutorials/conic/simple_examples/#Lovász-numbers","page":"Simple semidefinite programming examples","title":"Lovász numbers","text":"","category":"section"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"The Lovász number of a graph, also known as Lovász's theta-function, is a number that lies between two important and related numbers that are computationally hard to determine, namely the chromatic and clique numbers of the graph. It is possible however to efficient compute the Lovász number as the optimal value of a semidefinite program.","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"Consider the pentagon graph:","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"     [5]\n    /   \\\n   /     \\\n [1]     [4]\n  |       |\n  |       |\n [2] --- [3]","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"with five vertices and edges. Its Lovász number is known to be precisely sqrt5 approx 2236, lying between 2 (the largest clique size) and 3 (the smallest number needed for a vertex coloring).","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"Let i  j be integers such that 1 leq i  j leq 5. We define A^ij to be the 5 times 5 symmetric matrix with entries (ij) and (ji) equal to 1, with all other entries 0. Let  E be the graph's edge set; in this example, E contains (1,2), (2,3), (3,4), (4,5), (5,1) and their transposes. The Lovász number can be computed from the program","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"beginalign\n    textmax       quad    J  X  \n    text    st  quad A^ij  X = 0 text for all  (ij) notin E   \n                     quad I  X = 1 \n                     quad X succeq 0\nendalign","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"where J is the matrix filled with ones, and I is the identity matrix.","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"For more details, see (Barvinok, 2002; Knuth, 1994).","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"function example_theta_problem()\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    E = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]\n    @variable(model, X[1:5, 1:5], PSD)\n    for i in 1:5\n        for j in (i+1):5\n            if !((i, j) in E || (j, i) in E)\n                A = zeros(Int, 5, 5)\n                A[i, j] = 1\n                A[j, i] = 1\n                @constraint(model, LinearAlgebra.dot(A, X) == 0)\n            end\n        end\n    end\n    @constraint(model, LinearAlgebra.tr(LinearAlgebra.I * X) == 1)\n    J = ones(Int, 5, 5)\n    @objective(model, Max, LinearAlgebra.dot(J, X))\n    optimize!(model)\n    Test.@test is_solved_and_feasible(model)\n    Test.@test objective_value(model) ≈ sqrt(5) rtol = 1e-4\n    println(\"The Lovász number is: $(objective_value(model))\")\n    return\nend\n\nexample_theta_problem()","category":"page"},{"location":"tutorials/conic/simple_examples/#Robust-uncertainty-sets","page":"Simple semidefinite programming examples","title":"Robust uncertainty sets","text":"","category":"section"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"This example computes the Value at Risk for a data-driven uncertainty set. Closed-form expressions for the optimal value are available. For more details, see (Bertsimas et al., 2018).","category":"page"},{"location":"tutorials/conic/simple_examples/","page":"Simple semidefinite programming examples","title":"Simple semidefinite programming examples","text":"function example_robust_uncertainty_sets()\n    R, d, 𝛿, ɛ = 1, 3, 0.05, 0.05\n    N = ceil((2 + 2 * log(2 / 𝛿))^2) + 1\n    c, μhat, M = randn(d), rand(d), rand(d, d)\n    Σhat = 1 / (d - 1) * (M - ones(d) * μhat')' * (M - ones(d) * μhat')\n    Γ1(𝛿, N) = R / sqrt(N) * (2 + sqrt(2 * log(1 / 𝛿)))\n    Γ2(𝛿, N) = 2 * R^2 / sqrt(N) * (2 + sqrt(2 * log(2 / 𝛿)))\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, Σ[1:d, 1:d], PSD)\n    @variable(model, u[1:d])\n    @variable(model, μ[1:d])\n    @constraint(model, [Γ1(𝛿 / 2, N); μ - μhat] in SecondOrderCone())\n    @constraint(model, [Γ2(𝛿 / 2, N); vec(Σ - Σhat)] in SecondOrderCone())\n    @constraint(model, [((1-ɛ)/ɛ) (u - μ)'; (u-μ) Σ] >= 0, PSDCone())\n    @objective(model, Max, c' * u)\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    exact =\n        μhat' * c +\n        Γ1(𝛿 / 2, N) * LinearAlgebra.norm(c) +\n        sqrt((1 - ɛ) / ɛ) *\n        sqrt(c' * (Σhat + Γ2(𝛿 / 2, N) * LinearAlgebra.I) * c)\n    Test.@test objective_value(model) ≈ exact atol = 1e-2\n    return\nend\n\nexample_robust_uncertainty_sets()","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/callbacks/#callbacks_manual","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"","category":"section"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"Many mixed-integer (linear, conic, and nonlinear) programming solvers offer the ability to modify the solve process. Examples include changing branching decisions in branch-and-bound, adding custom cutting planes, providing custom heuristics to find feasible solutions, or implementing on-demand separators to add new constraints only when they are violated by the current solution (also known as lazy constraints).","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"While historically this functionality has been limited to solver-specific interfaces, JuMP provides solver-independent support for three types of callbacks:","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"lazy constraints\nuser-cuts\nheuristic solutions","category":"page"},{"location":"manual/callbacks/#Available-solvers","page":"Solver-independent Callbacks","title":"Available solvers","text":"","category":"section"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"Solver-independent callback support is limited to a few solvers. This includes CPLEX, GLPK, Gurobi, Xpress, and SCIP.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"warning: Warning\nWhile JuMP provides a solver-independent way of accessing callbacks, you should not assume that you will see identical behavior when running the same code on different solvers. For example, some solvers may ignore user-cuts for various reasons, while other solvers may add every user-cut. Read the underlying solver's callback documentation to understand details specific to each solver.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"tip: Tip\nThis page discusses solver-independent callbacks. However, each solver listed above also provides a solver-dependent callback to provide access to the full range of solver-specific features. Consult the solver's README for an example of how to use the solver-dependent callback. This will require you to understand the C interface of the solver.","category":"page"},{"location":"manual/callbacks/#Things-you-can-and-cannot-do-during-solver-independent-callbacks","page":"Solver-independent Callbacks","title":"Things you can and cannot do during solver-independent callbacks","text":"","category":"section"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"There is a limited range of things you can do during a callback. Only use the functions and macros explicitly stated in this page of the documentation, or in the Callbacks tutorial.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"Using any other part of the JuMP API (for example, adding a constraint with @constraint or modifying a variable bound with set_lower_bound) is undefined behavior, and your solver may throw an error, return an incorrect solution, or result in a segfault that aborts Julia.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"In each of the three solver-independent callbacks, there are two things you may query:","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"callback_node_status returns an MOI.CallbackNodeStatusCode enum indicating if the current primal solution is integer feasible.\ncallback_value returns the current primal solution of a variable.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"If you need to query any other information, use a solver-dependent callback instead. Each solver supporting a solver-dependent callback has information on how to use it in the README of their GitHub repository.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"If you want to modify the problem in a callback, you must use a lazy constraint.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"warning: Warning\nYou can only set each callback once. Calling set twice will over-write the earlier callback. In addition, if you use a solver-independent callback, you cannot set a solver-dependent callback.","category":"page"},{"location":"manual/callbacks/#Lazy-constraints","page":"Solver-independent Callbacks","title":"Lazy constraints","text":"","category":"section"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"Lazy constraints are useful when the full set of constraints is too large to explicitly include in the initial formulation. When a MIP solver reaches a new solution, for example with a heuristic or by solving a problem at a node in the branch-and-bound tree, it will give the user the chance to provide constraints that would make the current solution infeasible. For some more information about lazy constraints, see this blog post by Paul Rubin.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"A lazy constraint callback can be set using the following syntax:","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"julia> import GLPK\n\njulia> model = Model(GLPK.Optimizer);\n\njulia> @variable(model, x <= 10, Int)\nx\n\njulia> @objective(model, Max, x)\nx\n\njulia> function my_callback_function(cb_data)\n           status = callback_node_status(cb_data, model)\n           if status == MOI.CALLBACK_NODE_STATUS_FRACTIONAL\n               # `callback_value(cb_data, x)` is not integer (to some tolerance).\n               # If, for example, your lazy constraint generator requires an\n               # integer-feasible primal solution, you can add a `return` here.\n               return\n           elseif status == MOI.CALLBACK_NODE_STATUS_INTEGER\n               # `callback_value(cb_data, x)` is integer (to some tolerance).\n           else\n               @assert status == MOI.CALLBACK_NODE_STATUS_UNKNOWN\n               # `callback_value(cb_data, x)` might be fractional or integer.\n           end\n           x_val = callback_value(cb_data, x)\n           if x_val > 2 + 1e-6\n               con = @build_constraint(x <= 2)\n               MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n           end\n       end\nmy_callback_function (generic function with 1 method)\n\njulia> set_attribute(model, MOI.LazyConstraintCallback(), my_callback_function)","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"info: Info\nThe lazy constraint callback may be called at fractional or integer nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every primal solution.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"warning: Warning\nOnly add a lazy constraint if your primal solution violates the constraint. Adding the lazy constraint irrespective of feasibility may result in the solver returning an incorrect solution, or lead to many constraints being added, slowing down the solution process.model = Model(GLPK.Optimizer)\n@variable(model, x <= 10, Int)\n@objective(model, Max, x)\nfunction bad_callback_function(cb_data)\n    # Don't do this!\n    con = @build_constraint(x <= 2)\n    MOI.submit(model, MOI.LazyConstraint(cb_data), con)\nend\nfunction good_callback_function(cb_data)\n    if callback_value(x) > 2\n        con = @build_constraint(x <= 2)\n        MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n    end\nend\nset_attribute(model, MOI.LazyConstraintCallback(), good_callback_function)","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"warning: Warning\nDuring the solve, a solver may visit a point that was cut off by a previous lazy constraint, for example, because the earlier lazy constraint was removed during presolve. If this happens, you must re-add the lazy constraint.","category":"page"},{"location":"manual/callbacks/#User-cuts","page":"Solver-independent Callbacks","title":"User cuts","text":"","category":"section"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"User cuts, or simply cuts, provide a way for the user to tighten the LP relaxation using problem-specific knowledge that the solver cannot or is unable to infer from the model. Just like with lazy constraints, when a MIP solver reaches a new node in the branch-and-bound tree, it will give the user the chance to provide cuts to make the current relaxed (fractional) solution infeasible in the hopes of obtaining an integer solution. For more details about the difference between user cuts and lazy constraints see the aforementioned blog post.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"A user-cut callback can be set using the following syntax:","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"julia> import GLPK\n\njulia> model = Model(GLPK.Optimizer);\n\njulia> @variable(model, x <= 10.5, Int)\nx\n\njulia> @objective(model, Max, x)\nx\n\njulia> function my_callback_function(cb_data)\n           x_val = callback_value(cb_data, x)\n           con = @build_constraint(x <= floor(x_val))\n           MOI.submit(model, MOI.UserCut(cb_data), con)\n       end\nmy_callback_function (generic function with 1 method)\n\njulia> set_attribute(model, MOI.UserCutCallback(), my_callback_function)","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"warning: Warning\nUser cuts must not change the set of integer feasible solutions. Equivalently, user cuts can only remove fractional solutions. If you add a cut that removes an integer solution (even one that is not optimal), the solver may return an incorrect solution.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"info: Info\nThe user-cut callback may be called at fractional nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every fractional primal solution.","category":"page"},{"location":"manual/callbacks/#Heuristic-solutions","page":"Solver-independent Callbacks","title":"Heuristic solutions","text":"","category":"section"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"Integer programming solvers frequently include heuristics that run at the nodes of the branch-and-bound tree. They aim to find integer solutions quicker than plain branch-and-bound would to tighten the bound, allowing us to fathom nodes quicker and to tighten the integrality gap.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"Some heuristics take integer solutions and explore their \"local neighborhood\" (for example, flipping binary variables, fix some variables and solve a smaller MILP) and others take fractional solutions and attempt to round them in an intelligent way.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"You may want to add a heuristic of your own if you have some special insight into the problem structure that the solver is not aware of, for example, you can consistently take fractional solutions and intelligently guess integer solutions from them.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"A heuristic solution callback can be set using the following syntax:","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"julia> import GLPK\n\njulia> model = Model(GLPK.Optimizer);\n\njulia> @variable(model, x <= 10.5, Int)\nx\n\njulia> @objective(model, Max, x)\nx\n\njulia> function my_callback_function(cb_data)\n           x_val = callback_value(cb_data, x)\n           status = MOI.submit(\n               model, MOI.HeuristicSolution(cb_data), [x], [floor(Int, x_val)]\n           )\n           println(\"I submitted a heuristic solution, and the status was: \", status)\n       end\nmy_callback_function (generic function with 1 method)\n\njulia> set_attribute(model, MOI.HeuristicCallback(), my_callback_function)","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"The third argument to submit is a vector of JuMP variables, and the fourth argument is a vector of values corresponding to each variable.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"MOI.submit returns an enum that depends on whether the solver accepted the solution. The possible return codes are:","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"MOI.HEURISTIC_SOLUTION_ACCEPTED\nMOI.HEURISTIC_SOLUTION_REJECTED\nMOI.HEURISTIC_SOLUTION_UNKNOWN","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"warning: Warning\nSome solvers may accept partial solutions. Others require a feasible integer solution for every variable. If in doubt, provide a complete solution.","category":"page"},{"location":"manual/callbacks/","page":"Solver-independent Callbacks","title":"Solver-independent Callbacks","text":"info: Info\nThe heuristic solution callback may be called at fractional nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every fractional primal solution.","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/background/infeasibility_certificates.md\"","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/background/infeasibility_certificates/#Infeasibility-certificates","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"","category":"section"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"When given a conic problem that is infeasible or unbounded, some solvers can produce a certificate of infeasibility. This page explains what a certificate of infeasibility is, and the related conventions that MathOptInterface adopts.","category":"page"},{"location":"moi/background/infeasibility_certificates/#Conic-duality","page":"Infeasibility certificates","title":"Conic duality","text":"","category":"section"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"MathOptInterface uses conic duality to define infeasibility certificates. A full explanation is given in the section Duality, but here is a brief overview.","category":"page"},{"location":"moi/background/infeasibility_certificates/#Minimization-problems","page":"Infeasibility certificates","title":"Minimization problems","text":"","category":"section"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"For a minimization problem in geometric conic form, the primal is:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"beginalign\n min_x in mathbbR^n  a_0^top x + b_0\n\n textst  A_i x + b_i  in mathcalC_i  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"and the dual is a maximization problem in standard conic form:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"beginalign\n max_y_1 ldots y_m  -sum_i=1^m b_i^top y_i + b_0\n\n textst  a_0 - sum_i=1^m A_i^top y_i  = 0\n\n  y_i  in mathcalC_i^*  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"where each mathcalC_i is a closed convex cone and mathcalC_i^* is its dual cone.","category":"page"},{"location":"moi/background/infeasibility_certificates/#Maximization-problems","page":"Infeasibility certificates","title":"Maximization problems","text":"","category":"section"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"For a maximization problem in geometric conic form, the primal is:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"beginalign\n max_x in mathbbR^n  a_0^top x + b_0\n\n textst  A_i x + b_i  in mathcalC_i  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"and the dual is a minimization problem in standard conic form:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"beginalign\n min_y_1 ldots y_m  sum_i=1^m b_i^top y_i + b_0\n\n textst  a_0 + sum_i=1^m A_i^top y_i  = 0\n\n  y_i  in mathcalC_i^*  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/infeasibility_certificates/#Unbounded-problems","page":"Infeasibility certificates","title":"Unbounded problems","text":"","category":"section"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"A problem is unbounded if and only if:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"there exists a feasible primal solution\nthe dual is infeasible.","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"A feasible primal solution—if one exists—can be obtained by setting ObjectiveSense to FEASIBILITY_SENSE before optimizing. Therefore, most solvers stop after they prove the dual is infeasible via a certificate of dual infeasibility, but before they have found a feasible primal solution. This is also the reason that MathOptInterface defines the DUAL_INFEASIBLE status instead of UNBOUNDED.","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"A certificate of dual infeasibility is an improving ray of the primal problem. That is, there exists some vector d such that for all eta  0:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"A_i (x + eta d) + b_i in mathcalC_i  i = 1 ldots m","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"and (for minimization problems):","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"a_0^top (x + eta d) + b_0  a_0^top x + b_0","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"for any feasible point x. The latter simplifies to a_0^top d  0. For maximization problems, the inequality is reversed, so that a_0^top d  0.","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"If the solver has found a certificate of dual infeasibility:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"TerminationStatus must be DUAL_INFEASIBLE\nPrimalStatus must be INFEASIBILITY_CERTIFICATE\nVariablePrimal must be the corresponding value of d\nConstraintPrimal must be the corresponding value of A_i d\nObjectiveValue must be the value a_0^top d. Note that this is the value of the objective function at d, ignoring the constant b_0.","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"note: Note\nThe choice of whether to scale the ray d to have magnitude 1 is left to the solver.","category":"page"},{"location":"moi/background/infeasibility_certificates/#Infeasible-problems","page":"Infeasibility certificates","title":"Infeasible problems","text":"","category":"section"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"A certificate of primal infeasibility is an improving ray of the dual problem. However, because infeasibility is independent of the objective function, we first homogenize the primal problem by removing its objective.","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"For a minimization problem, a dual improving ray is some vector d such that for all eta  0:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"beginalign\n-sum_i=1^m A_i^top (y_i + eta d_i)  = 0 \n(y_i + eta d_i)  in mathcalC_i^*  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"and:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"-sum_i=1^m b_i^top (y_i + eta d_i)  -sum_i=1^m b_i^top y_i","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"for any feasible dual solution y. The latter simplifies to -sum_i=1^m b_i^top d_i  0. For a maximization problem, the inequality is sum_i=1^m b_i^top d_i  0. (Note that these are the same inequality, modulo a - sign.)","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"If the solver has found a certificate of primal infeasibility:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"TerminationStatus must be INFEASIBLE\nDualStatus must be INFEASIBILITY_CERTIFICATE\nConstraintDual must be the corresponding value of d\nDualObjectiveValue must be the value -sum_i=1^m b_i^top d_i for minimization problems and sum_i=1^m b_i^top d_i for maximization problems.","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"note: Note\nThe choice of whether to scale the ray d to have magnitude 1 is left to the solver.","category":"page"},{"location":"moi/background/infeasibility_certificates/#Infeasibility-certificates-of-variable-bounds","page":"Infeasibility certificates","title":"Infeasibility certificates of variable bounds","text":"","category":"section"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"Many linear solvers (for example, Gurobi) do not provide explicit access to the primal infeasibility certificate of a variable bound. However, given a set of linear constraints:","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"beginalign\nl_A le A x le u_A \nl_x le x le u_x\nendalign","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"the primal certificate of the variable bounds can be computed using the primal certificate associated with the affine constraints, d. (Note that d will have one element for each row of the A matrix, and that some or all of the elements in the vectors l_A and u_A may be pm infty. If both l_A and u_A are finite for some row, the corresponding element in `d  must be 0.)","category":"page"},{"location":"moi/background/infeasibility_certificates/","page":"Infeasibility certificates","title":"Infeasibility certificates","text":"Given d, compute bard = d^top A. If the bound is finite, a certificate for the lower variable bound of x_i is maxbard_i 0, and a certificate for the upper variable bound is minbard_i 0.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"EditURL = \"debugging.jl\"","category":"page"},{"location":"tutorials/getting_started/debugging/#Debugging","page":"Debugging","title":"Debugging","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Dealing with bugs is an unavoidable part of coding optimization models in any framework, including JuMP. Sources of bugs include not only generic coding errors (method errors, typos, off-by-one issues), but also semantic mistakes in the formulation of an optimization problem and the incorrect use of a solver.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"This tutorial explains some common sources of bugs and modeling issues that you might encounter when writing models in JuMP, and it suggests a variety of strategies to deal with them.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"tip: Tip\nThis tutorial is more advanced than the other \"Getting started\" tutorials. It's in the \"Getting started\" section to give you an early preview of how to debug JuMP models. However, if you are new to JuMP, you may want to briefly skim the tutorial, and come back to it once you have written a few JuMP models.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"using JuMP\nimport HiGHS","category":"page"},{"location":"tutorials/getting_started/debugging/#Getting-help","page":"Debugging","title":"Getting help","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Debugging can be a frustrating part of modeling, particularly if you're new to optimization and programming. If you're stuck, join the community forum to search for answers to commonly asked questions.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Before asking a new question, make sure to read the post Make it easier to help you, which contains a number of tips on how to ask a good question.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Above all else, take time to simplify your code as much as possible. The fewer lines of code you can post that reproduces the same issue, the faster someone can answer your question.","category":"page"},{"location":"tutorials/getting_started/debugging/#Debugging-Julia-code","page":"Debugging","title":"Debugging Julia code","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Read the Debugging chapter in the book ThinkJulia.jl. It has a number of great tips and tricks for debugging Julia code.","category":"page"},{"location":"tutorials/getting_started/debugging/#Solve-failures","page":"Debugging","title":"Solve failures","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"When a solver experiences an issue that prevents it from finding an optimal solution (or proving that one does not exist), JuMP may return one of a number of termination_statuses.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"For example, if the solver found a solution, but experienced numerical imprecision, it may return a status such as ALMOST_OPTIMAL or ALMOST_LOCALLY_SOLVED indicating that the problem was solved to a relaxed set of tolerances. Alternatively, the solver may return a problematic status such as NUMERICAL_ERROR, SLOW_PROGRESS, or OTHER_ERROR, indicating that it could not find a solution to the problem.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Most solvers can experience numerical imprecision because they use floating-point arithmetic to perform operations such as addition, subtraction, and multiplication. These operations aren't exact, and small errors can accrue between the theoretical value and the value that the computer computes. For example:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"0.1 * 3 == 0.3","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"tip: Tip\nRead the Guidelines for numerical issues section of the Gurobi documentation, along with the Debugging numerical problems section of the YALMIP documentation.","category":"page"},{"location":"tutorials/getting_started/debugging/#Common-sources","page":"Debugging","title":"Common sources","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Common sources of solve failures are:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Very large numbers and very small numbers as problem coefficients. Exactly what \"large\" is depends on the solver and the problem, but in general, values above 1e6 or smaller than 1e-6 cause problems.\nNonlinear problems with functions that are not defined in parts of their domain. For example, minimizing log(x) where x >= 0 is undefined when x = 0 (a common starting value).","category":"page"},{"location":"tutorials/getting_started/debugging/#Strategies","page":"Debugging","title":"Strategies","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Strategies to debug sources of solve failures include:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Rescale variables in the problem and their associated coefficients to make the magnitudes of all coefficients in the 1e-4 to 1e4 range. For example, that might mean rescaling a variable from measuring distance in centimeters to kilometers.\nTry a different solver. Some solvers might be more robust than others for a particular problem.\nRead the documentation of your solver, and try settings that encourage numerical robustness.\nSet bounds or add constraints so that all nonlinear functions are defined across all of the feasible region. This particularly applies for functions like 1 / x and log(x) which are not defined for x = 0.","category":"page"},{"location":"tutorials/getting_started/debugging/#Incorrect-results","page":"Debugging","title":"Incorrect results","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Sometimes, you might find that the solver returns an \"optimal\" solution that is incorrect according to the model you are trying to solve (perhaps the solution is suboptimal, or it doesn't satisfy some of the constraints).","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Incorrect results can be hard to detect and debug, because the solver gives no hints that there is a problem. Indeed, the termination_status will likely be OPTIMAL and a solution will be available.","category":"page"},{"location":"tutorials/getting_started/debugging/#Common-sources-2","page":"Debugging","title":"Common sources","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Common sources of incorrect results are:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"A modeling error, so that your JuMP model does not match the formulation you have on paper\nNot accounting for the tolerances that solvers use (for example, if x is binary, a value like x = 1.0000001 may still be considered feasible)\nA bug in JuMP or the solver.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"The probability of the issue being a bug in JuMP or the solver is much smaller than a modeling error. When in doubt, first assume there is a bug in your code before assuming that there is a bug in JuMP.","category":"page"},{"location":"tutorials/getting_started/debugging/#Strategies-2","page":"Debugging","title":"Strategies","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Strategies to debug sources of incorrect results include:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Print your JuMP model to see if it matches the formulation you have on paper. Look out for incorrect signs + instead of -, and off-by-one errors such as x[t] instead of x[t-1].\nCheck that you are not using exact comparisons like value(x) == 1.0; always use isapprox(value(x), 1.0; atol = 1e-6) where you manually specify the comparison tolerance.\nTry a different solver. If one solver succeeds where another doesn't this is a sign that the problem is a numerical issue or a bug in the solver.","category":"page"},{"location":"tutorials/getting_started/debugging/#Debugging-an-infeasible-model","page":"Debugging","title":"Debugging an infeasible model","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"A model is infeasible if there is no primal solution that satisfies all of the constraints. In general, an infeasible model means one of two things:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Your problem really has no feasible solution\nThere is a mistake in your model.","category":"page"},{"location":"tutorials/getting_started/debugging/#Example","page":"Debugging","title":"Example","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"A simple example of an infeasible model is:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"model = Model(HiGHS.Optimizer);\nset_silent(model)\n@variable(model, x >= 0)\n@objective(model, Max, 2x + 1)\n@constraint(model, con, 2x - 1 <= -2)","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"because the bound says that x >= 0, but we can rewrite the constraint to be x <= -1/2. When the problem is infeasible, JuMP may return one of a number of statuses. The most common is INFEASIBLE:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"optimize!(model)\ntermination_status(model)","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Depending on the solver, you may also receive INFEASIBLE_OR_UNBOUNDED or LOCALLY_INFEASIBLE.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"A termination status of INFEASIBLE_OR_UNBOUNDED means that the solver could not prove if the solver was infeasible or unbounded, only that the model does not have a finite feasible optimal solution.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Nonlinear optimizers such as Ipopt may return the status LOCALLY_INFEASIBLE. This does not mean that the solver proved no feasible solution exists, only that it could not find one. If you know a primal feasible point, try providing it as a starting point using set_start_value and re-optimize.","category":"page"},{"location":"tutorials/getting_started/debugging/#Common-sources-3","page":"Debugging","title":"Common sources","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Common sources of infeasibility are:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Incorrect units, for example, using a lower bound of megawatts and an upper bound of kilowatts\nUsing + instead of - in a constraint\nOff-by-one and related errors, for example, using x[t] instead of x[t-1] in part of a constraint\nOtherwise invalid mathematical formulations","category":"page"},{"location":"tutorials/getting_started/debugging/#Strategies-3","page":"Debugging","title":"Strategies","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Strategies to debug sources of infeasibility include:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Iteratively comment out a constraint (or block of constraints) and re-solve the problem. When you find a constraint that makes the problem infeasible when added, check the constraint carefully for errors.\nIf the problem is still infeasible with all constraints commented out, check all variable bounds. Do they use the right data?\nIf you have a known feasible solution, use primal_feasibility_report to evaluate the constraints and check for violations. You'll probably find that you have a typo in one of the constraints.\nTry a different solver. Sometimes, solvers have bugs, and they can incorrectly report a problem as infeasible when it isn't. If you find such a case where one solver reports the problem is infeasible and another can find an optimal solution, please report it by opening an issue on the GitHub repository of the solver that reports infeasibility.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"tip: Tip\nSome solvers also have specialized support for debugging sources of infeasibility via an irreducible infeasible subsystem. To see if your solver has support, try calling compute_conflict!:julia> compute_conflict!(model)\nERROR: ArgumentError: The optimizer HiGHS.Optimizer does not support `compute_conflict!`In this case, HiGHS does not support computing conflicts, but other solvers such as Gurobi and CPLEX do. If the solver does support computing conflicts, read Conflicts for more details.","category":"page"},{"location":"tutorials/getting_started/debugging/#Penalty-relaxation","page":"Debugging","title":"Penalty relaxation","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Another strategy to debug sources of infeasibility is the relax_with_penalty! function.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"The penalty relaxation modifies constraints of the form f(x) in S into f(x) + y - z in S, where y z ge 0, and then it introduces a penalty term into the objective of a times (y + z) (if minimizing, else -a), where a is a penalty.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"map = relax_with_penalty!(model)","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Here map is a dictionary which maps constraint indices to an affine expression representing (y + z).","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"If we optimize the relaxed model, this time we get a feasible solution:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"optimize!(model)\ntermination_status(model)","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Iterate over the contents of map to see which constraints are violated:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"for (con, penalty) in map\n    violation = value(penalty)\n    if violation > 0\n        println(\"Constraint `$(name(con))` is violated by $violation\")\n    end\nend","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Once you find a violated constraint in the relaxed problem, take a look to see if there is a typo or other common mistake in that particular constraint.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Consult the docstring relax_with_penalty! for information on how to modify the penalty cost term a, either for every constraint in the model or a particular subset of the constraints.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"When using relax_with_penalty!, you should be aware that:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Variable bounds and integrality restrictions are not relaxed. If the problem is still infeasible after calling relax_with_penalty!, check the variable bounds.\nYou cannot undo the penalty relaxation. If you need an unmodified model, rebuild the problem, or call copy_model before calling relax_with_penalty!.","category":"page"},{"location":"tutorials/getting_started/debugging/#Debugging-an-unbounded-model","page":"Debugging","title":"Debugging an unbounded model","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"A model is unbounded if there is no limit on how good the objective value can get. Most often, an unbounded model means that you have an error in your modeling, because all physical systems have limits. (You cannot make an infinite amount of profit.)","category":"page"},{"location":"tutorials/getting_started/debugging/#Example-2","page":"Debugging","title":"Example","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"A simple example of an unbounded model is:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"model = Model(HiGHS.Optimizer);\nset_silent(model)\n@variable(model, x >= 0)\n@objective(model, Max, 2x + 1)","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"because we can increase x without limit, and the objective value 2x + 1 gets better as x increases.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"When the problem is unbounded, JuMP may return one of a number of statuses. The most common is DUAL_INFEASIBLE:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"optimize!(model)\ntermination_status(model)","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Depending on the solver, you may also receive INFEASIBLE_OR_UNBOUNDED or an error code like NORM_LIMIT.","category":"page"},{"location":"tutorials/getting_started/debugging/#Common-sources-4","page":"Debugging","title":"Common sources","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Common sources of unboundedness are:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Using Max instead of Min\nOmitting variable bounds, such as 0 <= x <= 1\nUsing + instead of - in a term of the objective function.","category":"page"},{"location":"tutorials/getting_started/debugging/#Strategies-4","page":"Debugging","title":"Strategies","text":"","category":"section"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Strategies to debug sources of unboundedness include:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"Double check whether you intended Min or Max in the @objective line.\nPrint the objective function with print(objective_function(model)) and verify that the value and sign of each coefficient is as you expect.\nAdd large bounds to all variables that are free or have one-sided bounds, then re-solve the problem. Because all variables are now bounded, the problem will have a finite optimal solution. Look at the value of each variable in the optimal solution to see if it is at one of the new bounds. If it is, you either need to specify a better bound for that variable, or there might be a mistake in the objective function associated with that variable (for example, a + instead of a -).","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"If there are too many variables to add bounds to, or there are too many terms to examine by hand, another strategy is to create a new variable with a large upper bound (if maximizing, lower bound if minimizing) and a constraint that the variable must be less-than or equal to the expression of the objective function. For example:","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"model = Model(HiGHS.Optimizer);\nset_silent(model)\n@variable(model, x >= 0)\n# @objective(model, Max, 2x + 1)\n@variable(model, objective <= 10_000)\n@constraint(model, objective <= 2x + 1)\n@objective(model, Max, objective)","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"This new model has a finite optimal solution, so we can solve it and then look for variables with large positive or negative values in the optimal solution.","category":"page"},{"location":"tutorials/getting_started/debugging/","page":"Debugging","title":"Debugging","text":"optimize!(model)\n@assert is_solved_and_feasible(model)\nfor var in all_variables(model)\n    if var == objective\n        continue\n    end\n    if abs(value(var)) > 1e3\n        println(\"Variable `$(name(var))` may be unbounded\")\n    end\nend","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"EditURL = \"https://github.com/jump-dev/ECOS.jl/blob/v1.1.2/README.md\"","category":"page"},{"location":"packages/ECOS/#ECOS.jl","page":"jump-dev/ECOS.jl","title":"ECOS.jl","text":"","category":"section"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"ECOS.jl is a wrapper for the ECOS solver.","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"The wrapper has two components:","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"a thin wrapper around the complete C API\nan interface to MathOptInterface","category":"page"},{"location":"packages/ECOS/#Affiliation","page":"jump-dev/ECOS.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"This wrapper is maintained by the JuMP community and is not a product of Embotech AG.","category":"page"},{"location":"packages/ECOS/#License","page":"jump-dev/ECOS.jl","title":"License","text":"","category":"section"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"ECOS.jl is licensed under the MIT License.","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"The underlying solver, embotech/ecos, is licensed under the GPL v3 license.","category":"page"},{"location":"packages/ECOS/#Installation","page":"jump-dev/ECOS.jl","title":"Installation","text":"","category":"section"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"Install ECOS.jl using Pkg.add:","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"import Pkg\nPkg.add(\"ECOS\")","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"In addition to installing the ECOS.jl package, this will also download and install the ECOS binaries. You do not need to install ECOS separately.","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"To use a custom binary, read the Custom solver binaries section of the JuMP documentation.","category":"page"},{"location":"packages/ECOS/#Use-with-JuMP","page":"jump-dev/ECOS.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"To use ECOS with JuMP, use ECOS.Optimizer:","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"using JuMP, ECOS\nmodel = Model(ECOS.Optimizer)\nset_attribute(model, \"maxit\", 100)","category":"page"},{"location":"packages/ECOS/#MathOptInterface-API","page":"jump-dev/ECOS.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"The ECOS optimizer supports the following constraints and attributes.","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"List of supported objective functions:","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"MOI.Reals","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"MOI.VectorAffineFunction{Float64} in MOI.Nonnegatives\nMOI.VectorAffineFunction{Float64} in MOI.SecondOrderCone\nMOI.VectorAffineFunction{Float64} in MOI.Zeros","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"MOI.ObjectiveSense()","category":"page"},{"location":"packages/ECOS/#Options","page":"jump-dev/ECOS.jl","title":"Options","text":"","category":"section"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"The following options are supported:","category":"page"},{"location":"packages/ECOS/","page":"jump-dev/ECOS.jl","title":"jump-dev/ECOS.jl","text":"Parameter Explanation\ngamma scaling the final step length\ndelta regularization parameter\neps regularization threshold\nfeastol primal/dual infeasibility tolerance\nabstol absolute tolerance on duality gap\nreltol relative tolerance on duality gap\nfeastol_inacc primal/dual infeasibility relaxed tolerance\nabstol_inacc absolute relaxed tolerance on duality gap\nreltol_inacc relative relaxed tolerance on duality gap\nnitref number of iterative refinement steps\nmaxit maximum number of iterations\nverbose verbosity bool for PRINTLEVEL < 3","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/submodules/Nonlinear/overview.md\"","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#nonlinear_developers","page":"Overview","title":"Nonlinear","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"warning: Warning\nThe Nonlinear submodule is experimental. Until this message is removed, breaking changes may be introduced in any minor or patch release of MathOptInterface.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"The Nonlinear submodule contains data structures and functions for working with a nonlinear optimization problem in the form of an expression graph. This page explains the API and describes the rationale behind its design.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#Standard-form","page":"Overview","title":"Standard form","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Nonlinear programs (NLPs) are a class of optimization problems in which some of the constraints or the objective function are nonlinear:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"beginalign\n    min_x in mathbbR^n  f_0(x) \n    textst  l_j le f_j(x) le u_j  j = 1 ldots m\nendalign","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"There may be additional constraints, as well as things like variable bounds and integrality restrictions, but we do not consider them here because they are best dealt with by other components of MathOptInterface.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#API-overview","page":"Overview","title":"API overview","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"The core element of the Nonlinear submodule is Nonlinear.Model:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> const Nonlinear = MOI.Nonlinear;\n\njulia> model = Nonlinear.Model()\nA Nonlinear.Model with:\n 0 objectives\n 0 parameters\n 0 expressions\n 0 constraints","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Nonlinear.Model is a mutable struct that stores all of the nonlinear information added to the model.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#Decision-variables","page":"Overview","title":"Decision variables","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Decision variables are represented by VariableIndexes. The user is responsible for creating these using MOI.VariableIndex(i), where i is the column associated with the variable.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#Nonlinear_Expressions","page":"Overview","title":"Expressions","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"The input data structure is a Julia Expr. The input expressions can incorporate VariableIndexes, but these must be interpolated into the expression with $:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> x = MOI.VariableIndex(1)\nMOI.VariableIndex(1)\n\njulia> input = :(1 + sin($x)^2)\n:(1 + sin(MathOptInterface.VariableIndex(1)) ^ 2)","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"There are a number of restrictions on the input Expr:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"It cannot contain macros\nIt cannot contain broadcasting\nIt cannot contain splatting (except in limited situations)\nIt cannot contain linear algebra, such as matrix-vector products\nIt cannot contain generator expressions, including sum(i for i in S)","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Given an input expression, add an expression using Nonlinear.add_expression:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> expr = Nonlinear.add_expression(model, input)\nMathOptInterface.Nonlinear.ExpressionIndex(1)","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"The return value, expr, is a Nonlinear.ExpressionIndex that can then be interpolated into other input expressions.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Looking  again at model, we see:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> model\nA Nonlinear.Model with:\n 0 objectives\n 0 parameters\n 1 expression\n 0 constraints","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#Nonlinear_Parameters","page":"Overview","title":"Parameters","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"In addition to constant literals like 1 or 1.23, you can create parameters. Parameters are placeholders whose values can change before passing the expression to the solver. Create a parameter using Nonlinear.add_parameter, which accepts a default value:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> p = Nonlinear.add_parameter(model, 1.23)\nMathOptInterface.Nonlinear.ParameterIndex(1)","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"The return value, p, is a Nonlinear.ParameterIndex that can then be interpolated into other input expressions.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Looking  again at model, we see:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> model\nA Nonlinear.Model with:\n 0 objectives\n 1 parameter\n 1 expression\n 0 constraints","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Update a parameter as follows:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> model[p]\n1.23\n\njulia> model[p] = 4.56\n4.56\n\njulia> model[p]\n4.56","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#Nonlinear_Objectives","page":"Overview","title":"Objectives","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Set a nonlinear objective using Nonlinear.set_objective:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> Nonlinear.set_objective(model, :($p + $expr + $x))\n\njulia> model\nA Nonlinear.Model with:\n 1 objective\n 1 parameter\n 1 expression\n 0 constraints","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Clear a nonlinear objective by passing nothing:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> Nonlinear.set_objective(model, nothing)\n\njulia> model\nA Nonlinear.Model with:\n 0 objectives\n 1 parameter\n 1 expression\n 0 constraints","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"But we'll re-add the objective for later:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> Nonlinear.set_objective(model, :($p + $expr + $x));","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#Nonlinear_Constraints","page":"Overview","title":"Constraints","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Add a constraint using Nonlinear.add_constraint:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> c = Nonlinear.add_constraint(model, :(1 + sqrt($x)), MOI.LessThan(2.0))\nMathOptInterface.Nonlinear.ConstraintIndex(1)\n\njulia> model\nA Nonlinear.Model with:\n 1 objective\n 1 parameter\n 1 expression\n 1 constraint","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"The return value, c, is a Nonlinear.ConstraintIndex that is a unique identifier for the constraint. Interval constraints are also supported:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> c2 = Nonlinear.add_constraint(model, :(1 + sqrt($x)), MOI.Interval(-1.0, 2.0))\nMathOptInterface.Nonlinear.ConstraintIndex(2)\n\njulia> model\nA Nonlinear.Model with:\n 1 objective\n 1 parameter\n 1 expression\n 2 constraints","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Delete a constraint using Nonlinear.delete:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> Nonlinear.delete(model, c2)\n\njulia> model\nA Nonlinear.Model with:\n 1 objective\n 1 parameter\n 1 expression\n 1 constraint","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#User-defined-operators","page":"Overview","title":"User-defined operators","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"By default, Nonlinear supports a wide range of univariate and multivariate operators. However, you can also define your own operators by registering them.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#Univariate-operators","page":"Overview","title":"Univariate operators","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Register a univariate user-defined operator using Nonlinear.register_operator:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> f(x) = 1 + sin(x)^2\nf (generic function with 1 method)\n\njulia> Nonlinear.register_operator(model, :my_f, 1, f)","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Now, you can use :my_f in expressions:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> new_expr = Nonlinear.add_expression(model, :(my_f($x + 1)))\nMathOptInterface.Nonlinear.ExpressionIndex(2)","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"By default, Nonlinear will compute first- and second-derivatives of the registered operator using ForwardDiff.jl. Override this by passing functions which compute the respective derivative:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> f′(x) = 2 * sin(x) * cos(x)\nf′ (generic function with 1 method)\n\njulia> Nonlinear.register_operator(model, :my_f2, 1, f, f′)","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"or","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> f′′(x) = 2 * (cos(x)^2 - sin(x)^2)\nf′′ (generic function with 1 method)\n\njulia> Nonlinear.register_operator(model, :my_f3, 1, f, f′, f′′)","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#Multivariate-operators","page":"Overview","title":"Multivariate operators","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Register a multivariate user-defined operator using Nonlinear.register_operator:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> g(x...) = x[1]^2 + x[1] * x[2] + x[2]^2\ng (generic function with 1 method)\n\njulia> Nonlinear.register_operator(model, :my_g, 2, g)","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Now, you can use :my_g in expressions:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> new_expr = Nonlinear.add_expression(model, :(my_g($x + 1, $x)))\nMathOptInterface.Nonlinear.ExpressionIndex(3)","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"By default, Nonlinear will compute the gradient of the registered operator using ForwardDiff.jl. (Hessian information is not supported.) Override this by passing a function to compute the gradient:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> function ∇g(ret, x...)\n           ret[1] = 2 * x[1] + x[2]\n           ret[2] = x[1] + 2 * x[2]\n           return\n       end\n∇g (generic function with 1 method)\n\njulia> Nonlinear.register_operator(model, :my_g2, 2, g, ∇g)","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#Nonlinear_MOI_interface","page":"Overview","title":"MathOptInterface","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"MathOptInterface communicates the nonlinear portion of an optimization problem to solvers using concrete subtypes of AbstractNLPEvaluator, which implement the Nonlinear programming API.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Create an AbstractNLPEvaluator from Nonlinear.Model using Nonlinear.Evaluator.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Nonlinear.Evaluator requires an Nonlinear.AbstractAutomaticDifferentiation backend and an ordered list of the variables that are included in the model.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"There following backends are available to choose from within MOI, although other packages may add more options by sub-typing Nonlinear.AbstractAutomaticDifferentiation:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Nonlinear.ExprGraphOnly\nNonlinear.SparseReverseMode.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> evaluator = Nonlinear.Evaluator(model, Nonlinear.ExprGraphOnly(), [x])\nNonlinear.Evaluator with available features:\n  * :ExprGraph","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"The functions of the Nonlinear programming API implemented by Nonlinear.Evaluator depends upon the chosen Nonlinear.AbstractAutomaticDifferentiation backend.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"The :ExprGraph feature means we can call objective_expr and constraint_expr to retrieve the expression graph of the problem. However, we cannot call gradient terms such as eval_objective_gradient because Nonlinear.ExprGraphOnly does not have the capability to differentiate a nonlinear expression.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"If, instead, we pass Nonlinear.SparseReverseMode, then we get access to :Grad, the gradient of the objective function, :Jac, the Jacobian matrix of the constraints, :JacVec, the ability to compute Jacobian-vector products, and :ExprGraph.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> evaluator = Nonlinear.Evaluator(\n           model,\n           Nonlinear.SparseReverseMode(),\n           [x],\n       )\nNonlinear.Evaluator with available features:\n  * :Grad\n  * :Jac\n  * :JacVec\n  * :ExprGraph","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"However, before using the evaluator, we need to call initialize:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> MOI.initialize(evaluator, [:Grad, :Jac, :JacVec, :ExprGraph])","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Now we can call methods like eval_objective:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> x = [1.0]\n1-element Vector{Float64}:\n 1.0\n\njulia> MOI.eval_objective(evaluator, x)\n7.268073418273571","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"and eval_objective_gradient:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> grad = [0.0]\n1-element Vector{Float64}:\n 0.0\n\njulia> MOI.eval_objective_gradient(evaluator, grad, x)\n\njulia> grad\n1-element Vector{Float64}:\n 1.909297426825682","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Instead of passing Nonlinear.Evaluator directly to solvers, solvers query the NLPBlock attribute, which returns an NLPBlockData. This object wraps an Nonlinear.Evaluator and includes other information such as constraint bounds and whether the evaluator has a nonlinear objective. Create and set NLPBlockData as follows:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> block = MOI.NLPBlockData(evaluator);\n\njulia> model = MOI.Utilities.UniversalFallback(MOI.Utilities.Model{Float64}());\n\njulia> MOI.set(model, MOI.NLPBlock(), block);","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"warning: Warning\nOnly call NLPBlockData once you have finished modifying the problem in model.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Putting everything together, you can create a nonlinear optimization problem in MathOptInterface as follows:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"import MathOptInterface as MOI\n\nfunction build_model(\n    model::MOI.ModelLike;\n    backend::MOI.Nonlinear.AbstractAutomaticDifferentiation,\n)\n    x = MOI.add_variable(model)\n    y = MOI.add_variable(model)\n    MOI.set(model, MOI.ObjectiveSense(), MOI.MIN_SENSE)\n    nl_model = MOI.Nonlinear.Model()\n    MOI.Nonlinear.set_objective(nl_model, :($x^2 + $y^2))\n    evaluator = MOI.Nonlinear.Evaluator(nl_model, backend, [x, y])\n    MOI.set(model, MOI.NLPBlock(), MOI.NLPBlockData(evaluator))\n    return\nend\n\n# Replace `model` and `backend` with your optimizer and backend of choice.\nmodel = MOI.Utilities.UniversalFallback(MOI.Utilities.Model{Float64}())\nbuild_model(model; backend = MOI.Nonlinear.SparseReverseMode())","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#Expression-graph-representation","page":"Overview","title":"Expression-graph representation","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Nonlinear.Model stores nonlinear expressions in Nonlinear.Expressions. This section explains the design of the expression graph data structure in Nonlinear.Expression.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Given a nonlinear function like f(x) = sin(x)^2 + x, a conceptual aid for thinking about the graph representation of the expression is to convert it into Polish prefix notation:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"f(x, y) = (+ (^ (sin x) 2) x)","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"This format identifies each operator (function), as well as a list of arguments. Operators can be univariate, like sin, or multivariate, like +.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"A common way of representing Polish prefix notation in code is as follows:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> x = MOI.VariableIndex(1);\n\njulia> struct ExprNode\n           op::Symbol\n           children::Vector{Union{ExprNode,Float64,MOI.VariableIndex}}\n       end\n\njulia> expr = ExprNode(:+, [ExprNode(:^, [ExprNode(:sin, [x]), 2.0]), x]);","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"This data structure follows our Polish prefix notation very closely, and we can easily identify the arguments to an operator. However, it has a significant draw-back: each node in the graph requires a Vector, which is heap-allocated and tracked by Julia's garbage collector (GC). For large models, we can expect to have millions of nodes in the expression graph, so this overhead quickly becomes prohibitive for computation.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"An alternative is to record the expression as a linear tape:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> expr = Any[:+, 2, :^, 2, :sin, 1, x, 2.0, x]\n9-element Vector{Any}:\n  :+\n 2\n  :^\n 2\n  :sin\n 1\n  MOI.VariableIndex(1)\n 2.0\n  MOI.VariableIndex(1)","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"The Int after each operator Symbol specifies the number of arguments.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"This data-structure is a single vector, which resolves our problem with the GC, but each element is the abstract type, Any, and so any operations on it will lead to slower dynamic dispatch. It's also hard to identify the children of each operation without reading the entire tape.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"To summarize, representing expression graphs in Julia has the following challenges:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Nodes in the expression graph should not contain a heap-allocated object\nAll data-structures should be concretely typed\nIt should be easy to identify the children of a node","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#Sketch-of-the-design-in-Nonlinear","page":"Overview","title":"Sketch of the design in Nonlinear","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Nonlinear overcomes these problems by decomposing the data structure into a number of different concrete-typed vectors.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"First, we create vectors of the supported uni- and multivariate operators.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> const UNIVARIATE_OPERATORS = [:sin];\n\njulia> const MULTIVARIATE_OPERATORS = [:+, :^];","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"In practice, there are many more supported operations than the ones listed here.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Second, we create an enum to represent the different types of nodes present in the expression graph:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> @enum(\n           NodeType,\n           NODE_CALL_MULTIVARIATE,\n           NODE_CALL_UNIVARIATE,\n           NODE_VARIABLE,\n           NODE_VALUE,\n       )","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"In practice, there are node types other than the ones listed here.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Third, we create two concretely typed structs as follows:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> struct Node\n           type::NodeType\n           parent::Int\n           index::Int\n       end\n\njulia> struct Expression\n           nodes::Vector{Node}\n           values::Vector{Float64}\n       end","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"For each node node in the .nodes field, if node.type is:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"NODE_CALL_MULTIVARIATE, we look up MULTIVARIATE_OPERATORS[node.index] to retrieve the operator\nNODE_CALL_UNIVARIATE, we look up UNIVARIATE_OPERATORS[node.index] to retrieve the operator\nNODE_VARIABLE, we create MOI.VariableIndex(node.index)\nNODE_VALUE, we look up values[node.index]","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"The .parent field of each node is the integer index of the parent node in .nodes. For the first node, the parent is -1 by convention.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Therefore, we can represent our function as:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"julia> expr = Expression(\n           [\n               Node(NODE_CALL_MULTIVARIATE, -1, 1),\n               Node(NODE_CALL_MULTIVARIATE, 1, 2),\n               Node(NODE_CALL_UNIVARIATE, 2, 1),\n               Node(NODE_VARIABLE, 3, 1),\n               Node(NODE_VALUE, 2, 1),\n               Node(NODE_VARIABLE, 1, 1),\n           ],\n           [2.0],\n       );","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"The ordering of the nodes in the tape must satisfy two rules:","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"The children of a node must appear after the parent. This means that the tape is ordered topologically, so that a reverse pass of the nodes evaluates all children nodes before their parent\nThe arguments for a CALL node are ordered in the tape based on the order in which they appear in the function call.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#Design-goals","page":"Overview","title":"Design goals","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"This is less readable than the other options, but does this data structure meet our design goals?","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Instead of a heap-allocated object for each node, we only have two Vectors for each expression, nodes and values, as well as two constant vectors for the OPERATORS. In addition, all fields are concretely typed, and there are no Union or Any types.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"For our third goal, it is not easy to identify the children of a node, but it is easy to identify the parent of any node. Therefore, we can use Nonlinear.adjacency_matrix to compute a sparse matrix that maps parents to their children.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#The-design-in-practice","page":"Overview","title":"The design in practice","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"In practice, Node and Expression are exactly Nonlinear.Node and Nonlinear.Expression. However, Nonlinear.NodeType has more fields to account for comparison operators such as :>= and :<=, logic operators such as :&& and :||, nonlinear parameters, and nested subexpressions.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Moreover, instead of storing the operators as global constants, they are stored in Nonlinear.OperatorRegistry, and it also stores a vector of logic operators and a vector of comparison operators. In addition to Nonlinear.DEFAULT_UNIVARIATE_OPERATORS and Nonlinear.DEFAULT_MULTIVARIATE_OPERATORS, you can register user-defined functions using Nonlinear.register_operator.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Nonlinear.Model is a struct that stores the Nonlinear.OperatorRegistry, as well as a list of parameters and subexpressions in the model.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#ReverseAD","page":"Overview","title":"ReverseAD","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Nonlinear.ReverseAD is a submodule for computing derivatives of a nonlinear optimization problem using sparse reverse-mode automatic differentiation (AD).","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"This section does not attempt to explain how sparse reverse-mode AD works, but instead explains why MOI contains its own implementation, and highlights notable differences from similar packages.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"warning: Warning\nDon't use the API in ReverseAD to compute derivatives. Instead, create a Nonlinear.Evaluator object with Nonlinear.SparseReverseMode as the backend, and then query the MOI API methods.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#Design-goals-2","page":"Overview","title":"Design goals","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"The JuliaDiff organization maintains a list of packages for doing AD in Julia. At last count, there were at least ten packages——not including ReverseAD——for reverse-mode AD in Julia. ReverseAD exists because it has a different set of design goals.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Goal: handle scale and sparsity. The types of nonlinear optimization problems that MOI represents can be large scale (10^5 or more functions across 10^5 or more variables) with very sparse derivatives. The ability to compute a sparse Hessian matrix is essential. To the best of our knowledge, ReverseAD is the only reverse-mode AD system in Julia that handles sparsity by default.\nGoal: limit the scope to improve robustness. Most other AD packages accept arbitrary Julia functions as input and then trace an expression graph using operator overloading. This means they must deal (or detect and ignore) with control flow, I/O, and other vagaries of Julia. In contrast, ReverseAD only accepts functions in the form of Nonlinear.Expression, which greatly limits the range of syntax that it must deal with. By reducing the scope of what we accept as input to functions relevant for mathematical optimization, we can provide a simpler implementation with various performance optimizations.\nGoal: provide outputs which match what solvers expect. Other AD packages focus on differentiating individual Julia functions. In contrast, ReverseAD has a very specific use-case: to generate outputs needed by the MOI nonlinear API. This means it needs to efficiently compute sparse Hessians, and it needs subexpression handling to avoid recomputing subexpressions that are shared between functions.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/#History","page":"Overview","title":"History","text":"","category":"section"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"ReverseAD started life as ReverseDiffSparse.jl, development of which began in early 2014(!). This was well before the other AD packages started development. Because we had a well-tested, working AD in JuMP, there was less motivation to contribute to and explore other AD packages. The lack of historical interaction also meant that other packages were not optimized for the types of problems that JuMP is built for (that is, large-scale sparse problems). When we first created MathOptInterface, we kept the AD in JuMP to simplify the transition, and post-poned the development of a first-class nonlinear interface in MathOptInterface.","category":"page"},{"location":"moi/submodules/Nonlinear/overview/","page":"Overview","title":"Overview","text":"Prior to the introduction of Nonlinear, JuMP's nonlinear implementation was a confusing mix of functions and types spread across the code base and in the private _Derivatives submodule. This made it hard to swap the AD system for another. The main motivation for refactoring JuMP to create the Nonlinear submodule in MathOptInterface was to abstract the interface between JuMP and the AD system, allowing us to swap-in and test new AD systems in the future.","category":"page"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"EditURL = \"https://github.com/ds4dm/Tulip.jl/blob/v0.9.6/README.md\"","category":"page"},{"location":"packages/Tulip/#Tulip","page":"ds4dm/Tulip.jl","title":"Tulip","text":"","category":"section"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"(Image: DOI) (Image: ) (Image: )","category":"page"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"Tulip is an open-source interior-point solver for linear optimization, written in pure Julia. It implements the homogeneous primal-dual interior-point algorithm with multiple centrality corrections, and therefore handles unbounded and infeasible problems. Tulip’s main feature is that its algorithmic framework is disentangled from linear algebra implementations. This allows to seamlessly integrate specialized routines for structured problems.","category":"page"},{"location":"packages/Tulip/#License","page":"ds4dm/Tulip.jl","title":"License","text":"","category":"section"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"Tulip is licensed under the MPL 2.0 license.","category":"page"},{"location":"packages/Tulip/#Installation","page":"ds4dm/Tulip.jl","title":"Installation","text":"","category":"section"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"Install Tulip using the Julia package manager:","category":"page"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"import Pkg\nPkg.add(\"Tulip\")","category":"page"},{"location":"packages/Tulip/#Usage","page":"ds4dm/Tulip.jl","title":"Usage","text":"","category":"section"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"The recommended way of using Tulip is through JuMP or MathOptInterface (MOI).","category":"page"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"The low-level interface is still under development and is likely change in the future. The MOI interface is more stable.","category":"page"},{"location":"packages/Tulip/#Using-with-JuMP","page":"ds4dm/Tulip.jl","title":"Using with JuMP","text":"","category":"section"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"Tulip follows the syntax convention PackageName.Optimizer:","category":"page"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"using JuMP\nimport Tulip\nmodel = Model(Tulip.Optimizer)","category":"page"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"Linear objectives, linear constraints and lower/upper bounds on variables are supported.","category":"page"},{"location":"packages/Tulip/#Using-with-MOI","page":"ds4dm/Tulip.jl","title":"Using with MOI","text":"","category":"section"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"The type Tulip.Optimizer is parametrized by the model's arithmetic, for example, Float64 or BigFloat. This allows to solve problem in higher numerical precision. See the documentation for more details.","category":"page"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"import MathOptInterface as MOI\nimport Tulip\nmodel = Tulip.Optimizer{Float64}()   # Create a model in Float64 precision\nmodel = Tulip.Optimizer()            # Defaults to the above call\nmodel = Tulip.Optimizer{BigFloat}()  # Create a model in BigFloat precision","category":"page"},{"location":"packages/Tulip/#Solver-parameters","page":"ds4dm/Tulip.jl","title":"Solver parameters","text":"","category":"section"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"See the documentation for a full list of parameters.","category":"page"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"To set parameters in JuMP, use:","category":"page"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"using JuMP, Tulip\nmodel = Model(Tulip.Optimizer)\nset_attribute(model, \"IPM_IterationsLimit\", 200)","category":"page"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"To set parameters in MathOptInterface, use:","category":"page"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"using Tulip\nimport MathOptInterface as MOI\nmodel = Tulip.Optimizer{Float64}()\nMOI.set(model, MOI.RawOptimizerAttribute(\"IPM_IterationsLimit\"), 200)","category":"page"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"To set parameters in the Tulip API, use:","category":"page"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"using Tulip\nmodel = Tulip.Model{Float64}()\nTulip.set_parameter(model, \"IPM_IterationsLimit\", 200)","category":"page"},{"location":"packages/Tulip/#Command-line-executable","page":"ds4dm/Tulip.jl","title":"Command-line executable","text":"","category":"section"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"See app building instructions.","category":"page"},{"location":"packages/Tulip/#Citing-Tulip.jl","page":"ds4dm/Tulip.jl","title":"Citing Tulip.jl","text":"","category":"section"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"If you use Tulip in your work, we kindly ask that you cite the following reference (preprint available here).","category":"page"},{"location":"packages/Tulip/","page":"ds4dm/Tulip.jl","title":"ds4dm/Tulip.jl","text":"@Article{Tulip.jl,\n  author   = {Tanneau, Mathieu and Anjos, Miguel F. and Lodi, Andrea},\n  journal  = {Mathematical Programming Computation},\n  title    = {Design and implementation of a modular interior-point solver for linear optimization},\n  year     = {2021},\n  issn     = {1867-2957},\n  month    = feb,\n  doi      = {10.1007/s12532-020-00200-8},\n  language = {en},\n  url      = {https://doi.org/10.1007/s12532-020-00200-8},\n  urldate  = {2021-03-07},\n}","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"EditURL = \"transitioning_from_matlab.jl\"","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#Transitioning-from-MATLAB","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"YALMIP and CVX are two packages for mathematical optimization in MATLAB®. They are independently developed and are in no way affiliated with JuMP.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"The purpose of this tutorial is to help new users to JuMP who have previously used YALMIP or CVX by comparing and contrasting their different features.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"tip: Tip\nIf you have not used Julia before, read the Getting started with Julia tutorial.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#Namespaces","page":"Transitioning from MATLAB","title":"Namespaces","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"Julia has namespaces, which MATLAB lacks. Therefore one needs to either use the command:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"using JuMP","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"in order bring all names exported by JuMP into scope, or:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"import JuMP","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"in order to merely make the JuMP package available. import requires prefixing everything you use from JuMP with JuMP.. In this tutorial we use the former.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#Models","page":"Transitioning from MATLAB","title":"Models","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"YALMIP and CVX have a single, implicit optimization model that you build by defining variables and constraints.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"In JuMP, we create an explicit model first, and then, when you declare variables, constraints, or the objective function, you specify to which model they are being added.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"Create a new JuMP model with the command:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"model = Model()","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#Variables","page":"Transitioning from MATLAB","title":"Variables","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"In most cases there is a direct translation between variable declarations. The following table shows some common examples:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"JuMP YALMIP CVX\n@variable(model, x) x = sdpvar variable x\n@variable(model, x, Int) x = intvar variable x integer\n@variable(model, x, Bin) x = binvar variable x binary\n@variable(model, v[1:d]) v = sdpvar(d, 1) variable v(d)\n@variable(model, m[1:d, 1:d]) m = sdpvar(d,d,'full') variable m(d, d)\n@variable(model, m[1:d, 1:d] in ComplexPlane()) m = sdpvar(d,d,'full','complex') variable m(d,d) complex\n@variable(model, m[1:d, 1:d], Symmetric) m = sdpvar(d) variable m(d,d) symmetric\n@variable(model, m[1:d, 1:d], Hermitian) m = sdpvar(d,d,'hermitian','complex') variable m(d,d) hermitian","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"Like CVX, but unlike YALMIP, JuMP can also constrain variables upon creation:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"JuMP CVX\n@variable(model, v[1:d] >= 0) variable v(d) nonnegative\n@variable(model, m[1:d, 1:d], PSD) variable m(d,d) semidefinite\n@variable(model, m[1:d, 1:d] in PSDCone()) variable m(d,d) semidefinite\n@variable(model, m[1:d, 1:d] in HermitianPSDCone()) variable m(d,d) complex semidefinite","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"JuMP can additionally set variable bounds, which may be handled more efficiently by a solver than an equivalent linear constraint. For example:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"@variable(model, -1 <= x[i in 1:3] <= i)\nupper_bound.(x)","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"A more interesting case is when you want to declare, for example, n real symmetric matrices. Both YALMIP and CVX allow you to put the matrices as the slices of a 3-dimensional array, via the commands m = sdpvar(d, d, n) and variable m(d, d, n) symmetric, respectively. With JuMP this is not possible. Instead, to achieve the same result one needs to declare a vector of n matrices:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"d, n = 3, 2\nm = [@variable(model, [1:d, 1:d], Symmetric) for _ in 1:n]","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"m[1]","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"m[2]","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"The analogous construct in MATLAB would be a cell array containing the optimization variables, which every discerning programmer avoids as cell arrays are rather slow. This is not a problem in Julia: a vector of matrices is almost as fast as a 3-dimensional array.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#matlab_constraints","page":"Transitioning from MATLAB","title":"Constraints","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"As in the case of variables, in most cases there is a direct translation between the packages:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"JuMP YALMIP CVX\n@constraint(model, v == c) v == c v == c\n@constraint(model, v >= 0) v >= 0 v >= 0\n@constraint(model, m >= 0, PSDCone()) m >= 0 m == semidefinite(length(m))\n@constraint(model, m >= 0, HermitianPSDCone()) m >= 0 m == hermitian_semidefinite(length(m))\n@constraint(model, [t; v] in SecondOrderCone()) cone(v, t) {v, t} == lorentz(length(v))\n@constraint(model, [x, y, z] in MOI.ExponentialCone()) expcone([x, y, z]) {x, y, z} == exponential(1)","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"A subtlety appears when declaring equality constraints for matrices. In general, JuMP uses @constraint(model, m .== c), with the dot meaning broadcasting in Julia, except when m is Symmetric or Hermitian: in this case @constraint(model, m == c) is allowed, and is much better, as JuMP is smart enough to not generate redundant constraints for the lower diagonal and the imaginary part of the diagonal (in the complex case). Both YALMIP and CVX are also smart enough to do this and the syntax is always just m == c.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"Experienced YALMIP users will probably be relieved to see that you must pass PSDCone() or HermitianPSDCone() to make a matrix positive semidefinite, as the >= ambiguity in YALMIP is common source of bugs.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#Setting-the-objective","page":"Transitioning from MATLAB","title":"Setting the objective","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"Like CVX, but unlike YALMIP, JuMP has a specific command for setting an objective function:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"@objective(model, Min, sum(i * x[i] for i in 1:3))","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"Here the third argument is any expression you want to optimize, and Min is an objective sense (the other possibility is Max).","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#Setting-solver-and-options","page":"Transitioning from MATLAB","title":"Setting solver and options","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"In order to set an optimizer with JuMP, do:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"import Clarabel\nset_optimizer(model, Clarabel.Optimizer)","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"where \"Clarabel\" is an example solver. See the list of Supported solvers for other choices.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"To configure the solver options you use the command:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"set_attribute(model, \"verbose\", true)","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"where verbose is an option specific to Clarabel.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"A crucial difference is that with JuMP you must explicitly choose a solver before optimizing. Both YALMIP and CVX allow you to leave it empty and will try to guess an appropriate solver for the problem.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#Optimizing","page":"Transitioning from MATLAB","title":"Optimizing","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"Like YALMIP, but unlike CVX, with JuMP you need to explicitly start the optimization, with the command:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"optimize!(model)","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"The exclamation mark here is a Julia-ism that means the function is modifying its argument, model.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#Querying-solution-status","page":"Transitioning from MATLAB","title":"Querying solution status","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"After the optimization is done, you should check for the solution status to see what solution (if any) the solver found.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"Like YALMIP and CVX, JuMP provides a solver-independent way to check it, via the command:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"is_solved_and_feasible(model)","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"If the return value is false, you should investigate with termination_status, primal_status, and raw_status, See Solutions for more details on how to query and interpret solution statuses.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#Extracting-variables","page":"Transitioning from MATLAB","title":"Extracting variables","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"Like YALMIP, but unlike CVX, with JuMP you need to explicitly ask for the value of your variables after optimization is done, with the function call value(x) to obtain the value of variable x.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"value.(m[1][1, 1])","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"A subtlety is that, unlike YALMIP, the function value is only defined for scalars. For vectors and matrices you need to use Julia broadcasting: value.(v).","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"value.(m[1])","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"There is also a specialized function for extracting the value of the objective, objective_value(model), which is useful if your objective doesn't have a convenient expression.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"objective_value(model)","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#Dual-variables","page":"Transitioning from MATLAB","title":"Dual variables","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"Like YALMIP and CVX, JuMP allows you to recover the dual variables. In order to do that, the simplest method is to name the constraint you're interested in, for example, @constraint(model, bob, sum(v) == 1) and then, after the optimzation is done, call dual(bob). See Duality for more details.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#Reformulating-problems","page":"Transitioning from MATLAB","title":"Reformulating problems","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"Perhaps the biggest difference between JuMP and YALMIP and CVX is how far the package is willing to go in reformulating the problems you give to it.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"CVX is happy to reformulate anything it can, even using approximations if your solver cannot handle the problem.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"YALMIP will only do exact reformulations, but is still fairly adventurous, for example, being willing to reformulate a nonlinear objective in terms of conic constraints.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"JuMP does no such thing: it only reformulates objectives into objectives, and constraints into constraints, and is fairly conservative at that. As a result, you might need to do some reformulations manually, for which a good guide is the Tips and tricks tutorial.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#Vectorization","page":"Transitioning from MATLAB","title":"Vectorization","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"In MATLAB, it is absolutely essential to \"vectorize\" your code to obtain acceptable performance. This is because MATLAB is a slow interpreted language, which sends your commands to fast libraries. When you \"vectorize\" your code you are minimizing the MATLAB part of the work and sending it to the fast libraries instead.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"There's no such duality with Julia.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"Everything you write and most libraries you use will compile down to LLVM, so \"vectorization\" has no effect.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"For example, if you are writing a linear program in MATLAB and instead of the usual constraints = [v >= 0] you write:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"for i = 1:n\n   constraints = [constraints, v(i) >= 0];\nend","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"performance will be poor.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"With Julia, on the other hand, there is hardly any difference between","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"@constraint(model, v >= 0)","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"and","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"for i in 1:n\n    @constraint(model, v[i] >= 0)\nend","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#Symmetric-and-Hermitian-matrices","page":"Transitioning from MATLAB","title":"Symmetric and Hermitian matrices","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"Julia has specialized support for symmetric and Hermitian matrices in the LinearAlgebra package:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"import LinearAlgebra","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"If you have a matrix that is numerically symmetric:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"x = [1 2; 2 3]","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"LinearAlgebra.issymmetric(x)","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"then you can wrap it in a LinearAlgebra.Symmetric matrix to tell Julia's type system that the matrix is symmetric.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"LinearAlgebra.Symmetric(x)","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"Using a Symmetric matrix lets Julia and JuMP use more efficient algorithms when they are working with symmetric matrices.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"If you have a matrix that is nearly but not exactly symmetric:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"x = [1.0 2.0; 2.001 3.0]\nLinearAlgebra.issymmetric(x)","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"then you could, as you might do in MATLAB, make it numerically symmetric as follows:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"x_sym = 0.5 * (x + x')","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"In Julia, you can explicitly choose whether to use the lower or upper triangle of the matrix:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"x_sym = LinearAlgebra.Symmetric(x, :L)","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"x_sym = LinearAlgebra.Symmetric(x, :U)","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"The same applies for Hermitian matrices, using LinearAlgebra.Hermitian and LinearAlgebra.ishermitian.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#Primal-versus-dual-form","page":"Transitioning from MATLAB","title":"Primal versus dual form","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"When you translate some optimization problems from YALMIP or CVX to JuMP, you might be surprised to see it get much faster or much slower, even if you're using exactly the same solver. The most likely reason is that YALMIP will always interpret the problem as the dual form, whereas CVX and JuMP will try to interpret the problem in the form most appropriate to the solver. If the problem is more naturally formulated in the primal form it is likely that YALMIP's performance will suffer, or if JuMP gets it wrong, its performance will suffer. It might be worth trying both primal and dual forms if you're having trouble, which can be done automatically with the package Dualization.jl.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"For an in-depth explanation of this issue, see the Dualization tutorial.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#Rosetta-stone","page":"Transitioning from MATLAB","title":"Rosetta stone","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"In this section, we show a complete example of the same optimization problem being solved with JuMP, YALMIP, and CVX. It is a semidefinite program that computes a lower bound on the random robustness of entanglement using the partial transposition criterion.","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"The code is complete, apart from the function that does partial transposition. With both YALMIP and CVX we use the function PartialTranspose from QETLAB. With JuMP, we could use the function Convex.partialtranspose from Convex.jl, but we reproduce it here for simplicity:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"function partial_transpose(x::AbstractMatrix, sys::Int, dims::Vector)\n    @assert size(x, 1) == size(x, 2) == prod(dims)\n    @assert 1 <= sys <= length(dims)\n    n = length(dims)\n    s = n - sys + 1\n    p = collect(1:2n)\n    p[s], p[n+s] = n + s, s\n    r = reshape(x, (reverse(dims)..., reverse(dims)...))\n    return reshape(permutedims(r, p), size(x))\nend","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#JuMP","page":"Transitioning from MATLAB","title":"JuMP","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"The JuMP code to solve this problem is:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"using JuMP\nimport Clarabel\nimport LinearAlgebra\n\nfunction random_state_pure(d)\n    x = randn(Complex{Float64}, d)\n    y = x * x'\n    return LinearAlgebra.Hermitian(y / LinearAlgebra.tr(y))\nend\n\nfunction robustness_jump(d)\n    rho = random_state_pure(d^2)\n    id = LinearAlgebra.Hermitian(LinearAlgebra.I(d^2))\n    rhoT = LinearAlgebra.Hermitian(partial_transpose(rho, 1, [d, d]))\n    model = Model()\n    @variable(model, λ)\n    @constraint(model, PPT, rhoT + λ * id in HermitianPSDCone())\n    @objective(model, Min, λ)\n    set_optimizer(model, Clarabel.Optimizer)\n    set_attribute(model, \"verbose\", true)\n    optimize!(model)\n    if is_solved_and_feasible(model)\n        WT = dual(PPT)\n        return value(λ), real(LinearAlgebra.dot(WT, rhoT))\n    else\n        return \"Something went wrong: $(raw_status(model))\"\n    end\nend\n\nrobustness_jump(3)","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#YALMIP","page":"Transitioning from MATLAB","title":"YALMIP","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"The corresponding YALMIP code is:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"function robustness_yalmip(d)\n    rho = random_state_pure(d^2);\n    # PartialTranspose from https://github.com/nathanieljohnston/QETLAB\n    rhoT = PartialTranspose(rho, 1, [d d]);\n    lambda = sdpvar;\n    constraints = [(rhoT + lambda*eye(d^2) >= 0):'PPT'];\n    ops = sdpsettings(sdpsettings, 'verbose', 1, 'solver', 'sedumi');\n    sol = optimize(constraints, lambda, ops);\n    if sol.problem == 0\n        WT = dual(constraints('PPT'));\n        value(lambda)\n        real(WT(:).' * rhoT(:))\n    else\n        display(['Something went wrong: ', sol.info])\n    end\nend\n\nfunction rho = random_state_pure(d)\n    x = randn(d, 1) + 1i * randn(d, 1);\n    y = x * x';\n    rho = y / trace(y);\nend","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/#CVX","page":"Transitioning from MATLAB","title":"CVX","text":"","category":"section"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"The corresponding CVX code is:","category":"page"},{"location":"tutorials/transitioning/transitioning_from_matlab/","page":"Transitioning from MATLAB","title":"Transitioning from MATLAB","text":"function robustness_cvx(d)\n    rho = random_state_pure(d^2);\n    # PartialTranspose from https://github.com/nathanieljohnston/QETLAB\n    rhoT = PartialTranspose(rho, 1, [d d]);\n    cvx_begin\n        variable lambda\n        dual variable WT\n        WT : rhoT + lambda * eye(d^2) == hermitian_semidefinite(d^2)\n        minimise lambda\n    cvx_end\n    if strcmp(cvx_status, 'Solved')\n        lambda\n        real(WT(:)' * rhoT(:))\n    else\n        display('Something went wrong.')\n    end\nend\n\nfunction rho = random_state_pure(d)\n    x = randn(d, 1) + 1i * randn(d, 1);\n    y = x * x';\n    rho = y / trace(y);\nend","category":"page"},{"location":"tutorials/algorithms/parallelism/#Parallelism","page":"Parallelism","title":"Parallelism","text":"","category":"section"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"The purpose of this tutorial is to give a brief overview of parallelism in Julia as it pertains to JuMP, and to explain some of the things to be aware of when writing parallel algorithms involving JuMP models.","category":"page"},{"location":"tutorials/algorithms/parallelism/#Multi-threading-and-distributed-computing","page":"Parallelism","title":"Multi-threading and distributed computing","text":"","category":"section"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"There are two main types of parallelism in Julia:","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"Multi-threading\nDistributed computing","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"In multi-threading, multiple tasks are run in a single Julia process and share the same memory. In distributed computing, tasks are run in multiple Julia processes with independent memory spaces. This can include processes across multiple physical machines, such as in a high-performance computing cluster.","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"Choosing and understanding the type of parallelism you are using is important because the code you write for each type is different, and there are different limitations and benefits to each approach. However, the best choice is highly problem dependent, so you may want to experiment with both approaches to determine what works for your situation.","category":"page"},{"location":"tutorials/algorithms/parallelism/#Multi-threading","page":"Parallelism","title":"Multi-threading","text":"","category":"section"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"To use multi-threading with Julia, you must either start Julia with the command line flag --threads=N, or you must set the JULIA_NUM_THREADS environment variable before launching Julia. For this documentation, we set the environment variable to:","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"julia> ENV[\"JULIA_NUM_THREADS\"]\n\"4\"","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"You can check how many threads are available using:","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"julia> Threads.nthreads()\n4","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"The easiest way to use multi-threading in Julia is by placing the Threads.@threads macro in front of a for-loop:","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"julia> @time begin\n           ids = Int[]\n           my_lock = Threads.ReentrantLock()\n           Threads.@threads for i in 1:Threads.nthreads()\n               global ids, my_lock\n               Threads.lock(my_lock) do\n                   push!(ids, Threads.threadid())\n               end\n               sleep(1.0)\n           end\n       end\n  1.037087 seconds (31.32 k allocations: 1.836 MiB, 2.02% compilation time)","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"This for-loop sleeps for 1 second on each iteration. Thus, if it had executed sequentially, it should have taken the same number of seconds as there are threads available. Instead, it took only 1 second, showing that the iterations were executed simultaneously. We can verify this by checking the Threads.threadid() of the thread that executed each iteration:","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"julia> ids\n4-element Vector{Int64}:\n 2\n 4\n 1\n 3","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"warning: Warning\nWhen working with threads, you need to avoid race conditions, in which two threads attempt to write to the same variable at the same time. In the above example we avoided a race condition by using ReentrantLock. See the Multi-threading section of the Julia documentation for more details.","category":"page"},{"location":"tutorials/algorithms/parallelism/#Distributed-computing","page":"Parallelism","title":"Distributed computing","text":"","category":"section"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"To use distributed computing with Julia, use the Distributed package:","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"julia> import Distributed","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"Like multi-threading, we need to tell Julia how many processes to add. We can do this either by starting Julia with the -p N command line argument, or by using Distributed.addprocs:","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"julia> import Pkg\n\njulia> project = Pkg.project();\n\njulia> workers = Distributed.addprocs(4; exeflags = \"--project=$(project.path)\")\n4-element Vector{Int64}:\n 2\n 3\n 4\n 5","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"warning: Warning\nNot loading the parent environment with --project is a common mistake.","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"The added processes are \"worker\" processes that we can use to do computation with. They are orchestrated by the process with the id 1. You can check what process the code is currently running on using Distributed.myid()","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"julia> Distributed.myid()\n1","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"As a general rule, to get maximum performance you should add as many processes as you have logical cores available.","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"Unlike the for-loop approach of multi-threading, distributed computing extends the Julia map function to a \"parallel-map\" function Distributed.pmap. For each element in the list of arguments to map over, Julia will copy the element to an idle worker process and evaluate the function, passing the element as an input argument.","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"julia> function hard_work(i::Int)\n           sleep(1.0)\n           return Distributed.myid()\n       end\nhard_work (generic function with 1 method)\n\njulia> Distributed.pmap(hard_work, 1:4)\nERROR: On worker 2:\nUndefVarError: #hard_work not defined\nStacktrace:\n[...]","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"Unfortunately, if you try this code directly, you will get an error message that says On worker 2: UndefVarError: hard_work not defined. The error is thrown because, although process 1 knows what the hard_work function is, the worker processes do not.","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"To fix the error, we need to use Distributed.@everywhere, which evaluates the code on every process:","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"julia> Distributed.@everywhere begin\n           function hard_work(i::Int)\n               sleep(1.0)\n               return Distributed.myid()\n           end\n       end","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"Now if we run pmap, we see that it took only 1 second instead of 4, and that it executed on each of the worker processes:","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"julia> @time ids = Distributed.pmap(hard_work, 1:4)\n  1.202006 seconds (216.39 k allocations: 13.301 MiB, 4.07% compilation time)\n4-element Vector{Int64}:\n 2\n 3\n 5\n 4","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"tip: Tip\nFor more information, read the Julia documentation Distributed Computing.","category":"page"},{"location":"tutorials/algorithms/parallelism/#Using-parallelism-the-wrong-way","page":"Parallelism","title":"Using parallelism the wrong way","text":"","category":"section"},{"location":"tutorials/algorithms/parallelism/#When-building-a-JuMP-model","page":"Parallelism","title":"When building a JuMP model","text":"","category":"section"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"For large problems, building the model in JuMP can be a bottleneck, and you may consider trying to write code that builds the model in parallel, for example, by wrapping a for-loop that adds constraints with Threads.@threads.","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"Unfortunately, you cannot build a JuMP model in parallel, and attempting to do so may error or produce incorrect results.","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"In most cases, we find that the reason for the bottleneck is not JuMP, but in how you are constructing the problem data, and that with changes, it is possible to build a model in a way that is not the bottleneck in the solution process.","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"tip: Tip\nLooking for help to make your code run faster? Ask for help on the community forum. Make sure to include a reproducible example of your code.","category":"page"},{"location":"tutorials/algorithms/parallelism/#With-a-single-JuMP-model","page":"Parallelism","title":"With a single JuMP model","text":"","category":"section"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"A common approach people try is to use parallelism with a single JuMP model. For example, to optimize a model over multiple right-hand side vectors, you may try:","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"using JuMP\nimport HiGHS\nmodel = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, x)\n@objective(model, Min, x)\nsolutions = Pair{Int,Float64}[]\nmy_lock = Threads.ReentrantLock()\nThreads.@threads for i in 1:10\n    set_lower_bound(x, i)\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    Threads.lock(my_lock) do\n        push!(solutions, i => objective_value(model))\n    end\nend","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"This will not work, and attempting to do so may error, crash Julia or produce incorrect results.","category":"page"},{"location":"tutorials/algorithms/parallelism/#Using-parallelism-the-right-way","page":"Parallelism","title":"Using parallelism the right way","text":"","category":"section"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"To use parallelism with JuMP, the simplest rule to remember is that each worker must have its own instance of a JuMP model.","category":"page"},{"location":"tutorials/algorithms/parallelism/#With-multi-threading","page":"Parallelism","title":"With multi-threading","text":"","category":"section"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"With multi-threading, create a new instance of model in each iteration of the for-loop:","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"julia> using JuMP\n\njulia> import HiGHS\n\njulia> solutions = Pair{Int,Float64}[]\n\njulia> my_lock = Threads.ReentrantLock();\n\njulia> Threads.@threads for i in 1:10\n           model = Model(HiGHS.Optimizer)\n           set_silent(model)\n           set_attribute(model, MOI.NumberOfThreads(), 1)\n           @variable(model, x)\n           @objective(model, Min, x)\n           set_lower_bound(x, i)\n           optimize!(model)\n           @assert is_solved_and_feasible(sudoku)\n           Threads.lock(my_lock) do\n               push!(solutions, i => objective_value(model))\n           end\n       end\n\njulia> solutions\n10-element Vector{Pair{Int64, Float64}}:\n  7 => 7.0\n  4 => 4.0\n  1 => 1.0\n  9 => 9.0\n  5 => 5.0\n  8 => 8.0\n 10 => 10.0\n  2 => 2.0\n  6 => 6.0\n  3 => 3.0","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"warning: Warning\nFor some solvers, it may be necessary to limit the number of threads used internally by the solver to 1 by setting the MOI.NumberOfThreads attribute.","category":"page"},{"location":"tutorials/algorithms/parallelism/#With-distributed-computing","page":"Parallelism","title":"With distributed computing","text":"","category":"section"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"With distributed computing, remember to evaluate all of the code on all of the processes using Distributed.@everywhere, and then write a function which creates a new instance of the model on every evaluation:","category":"page"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"julia> Distributed.@everywhere begin\n           using JuMP\n           import HiGHS\n       end\n\njulia> Distributed.@everywhere begin\n           function solve_model_with_right_hand_side(i)\n               model = Model(HiGHS.Optimizer)\n               set_silent(model)\n               @variable(model, x)\n               @objective(model, Min, x)\n               set_lower_bound(x, i)\n               optimize!(model)\n               @assert is_solved_and_feasible(sudoku)\n               return objective_value(model)\n           end\n       end\n\njulia> solutions = Distributed.pmap(solve_model_with_right_hand_side, 1:10)\n10-element Vector{Float64}:\n  1.0\n  2.0\n  3.0\n  4.0\n  5.0\n  6.0\n  7.0\n  8.0\n  9.0\n 10.0","category":"page"},{"location":"tutorials/algorithms/parallelism/#Other-types-of-parallelism","page":"Parallelism","title":"Other types of parallelism","text":"","category":"section"},{"location":"tutorials/algorithms/parallelism/#GPU","page":"Parallelism","title":"GPU","text":"","category":"section"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"JuMP does not support GPU programming, and few solvers support execution on a GPU.","category":"page"},{"location":"tutorials/algorithms/parallelism/#Parallelism-within-the-solver","page":"Parallelism","title":"Parallelism within the solver","text":"","category":"section"},{"location":"tutorials/algorithms/parallelism/","page":"Parallelism","title":"Parallelism","text":"Many solvers use parallelism internally. For example, commercial solvers like Gurobi and CPLEX both parallelize the search in branch-and-bound. Solvers supporting internal parallelism will typically support the MOI.NumberOfThreads attribute, which you can set using set_attribute.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/manual/variables.md\"","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"moi/manual/variables/#Add-a-variable","page":"Variables","title":"Add a variable","text":"","category":"section"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"Use add_variable to add a single variable.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"julia> x = MOI.add_variable(model)\nMOI.VariableIndex(1)","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"add_variable returns a VariableIndex type, which is used to refer to the added variable in other calls.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"Check if a VariableIndex is valid using is_valid.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"julia> MOI.is_valid(model, x)\ntrue","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"Use add_variables to add a number of variables.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"julia> y = MOI.add_variables(model, 2)\n2-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(2)\n MOI.VariableIndex(3)","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"warning: Warning\nThe integer does not necessarily correspond to the column inside an optimizer.","category":"page"},{"location":"moi/manual/variables/#Delete-a-variable","page":"Variables","title":"Delete a variable","text":"","category":"section"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"Delete a variable using delete.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"julia> MOI.delete(model, x)\n\njulia> MOI.is_valid(model, x)\nfalse","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"warning: Warning\nNot all ModelLike models support deleting variables. A DeleteNotAllowed error is thrown if this is not supported.","category":"page"},{"location":"moi/manual/variables/#Variable-attributes","page":"Variables","title":"Variable attributes","text":"","category":"section"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"The following attributes are available for variables:","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"VariableName\nVariablePrimalStart\nVariablePrimal","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"Get and set these attributes using get and set.","category":"page"},{"location":"moi/manual/variables/","page":"Variables","title":"Variables","text":"julia> MOI.set(model, MOI.VariableName(), x, \"var_x\")\n\njulia> MOI.get(model, MOI.VariableName(), x)\n\"var_x\"","category":"page"},{"location":"packages/Optim/","page":"JuliaNLSolvers/Optim.jl","title":"JuliaNLSolvers/Optim.jl","text":"EditURL = \"https://github.com/JuliaNLSolvers/Optim.jl/blob/v1.9.4/README.md\"","category":"page"},{"location":"packages/Optim/#Optim.jl","page":"JuliaNLSolvers/Optim.jl","title":"Optim.jl","text":"","category":"section"},{"location":"packages/Optim/","page":"JuliaNLSolvers/Optim.jl","title":"JuliaNLSolvers/Optim.jl","text":"(Image: ) (Image: ) (Image: Build Status) (Image: Build Status) (Image: Build Status) (Image: Codecov branch) (Image: JOSS)","category":"page"},{"location":"packages/Optim/","page":"JuliaNLSolvers/Optim.jl","title":"JuliaNLSolvers/Optim.jl","text":"Univariate and multivariate optimization in Julia.","category":"page"},{"location":"packages/Optim/","page":"JuliaNLSolvers/Optim.jl","title":"JuliaNLSolvers/Optim.jl","text":"Optim.jl is part of the JuliaNLSolvers family.","category":"page"},{"location":"packages/Optim/#Help-and-support","page":"JuliaNLSolvers/Optim.jl","title":"Help and support","text":"","category":"section"},{"location":"packages/Optim/","page":"JuliaNLSolvers/Optim.jl","title":"JuliaNLSolvers/Optim.jl","text":"For help and support, please post on the Optimization (Mathematical) section of the Julia discourse or the #math-optimization channel of the Julia slack.","category":"page"},{"location":"packages/Optim/#Installation","page":"JuliaNLSolvers/Optim.jl","title":"Installation","text":"","category":"section"},{"location":"packages/Optim/","page":"JuliaNLSolvers/Optim.jl","title":"JuliaNLSolvers/Optim.jl","text":"Install Optim.jl using the Julia package manager:","category":"page"},{"location":"packages/Optim/","page":"JuliaNLSolvers/Optim.jl","title":"JuliaNLSolvers/Optim.jl","text":"import Pkg\nPkg.add(\"Optim\")","category":"page"},{"location":"packages/Optim/#Documentation","page":"JuliaNLSolvers/Optim.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/Optim/","page":"JuliaNLSolvers/Optim.jl","title":"JuliaNLSolvers/Optim.jl","text":"The online documentation is available at https://julianlsolvers.github.io/Optim.jl/stable.","category":"page"},{"location":"packages/Optim/#Example","page":"JuliaNLSolvers/Optim.jl","title":"Example","text":"","category":"section"},{"location":"packages/Optim/","page":"JuliaNLSolvers/Optim.jl","title":"JuliaNLSolvers/Optim.jl","text":"To minimize the Rosenbrock function, do:","category":"page"},{"location":"packages/Optim/","page":"JuliaNLSolvers/Optim.jl","title":"JuliaNLSolvers/Optim.jl","text":"julia> using Optim\n\njulia> rosenbrock(x) =  (1.0 - x[1])^2 + 100.0 * (x[2] - x[1]^2)^2\nrosenbrock (generic function with 1 method)\n\njulia> result = optimize(rosenbrock, zeros(2), BFGS())\n * Status: success\n\n * Candidate solution\n    Final objective value:     5.471433e-17\n\n * Found with\n    Algorithm:     BFGS\n\n * Convergence measures\n    |x - x'|               = 3.47e-07 ≰ 0.0e+00\n    |x - x'|/|x'|          = 3.47e-07 ≰ 0.0e+00\n    |f(x) - f(x')|         = 6.59e-14 ≰ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 1.20e+03 ≰ 0.0e+00\n    |g(x)|                 = 2.33e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   0  (vs limit Inf)\n    Iterations:    16\n    f(x) calls:    53\n    ∇f(x) calls:   53\n\njulia> Optim.minimizer(result)\n2-element Vector{Float64}:\n 0.9999999926033423\n 0.9999999852005355\n\njulia> Optim.minimum(result)\n5.471432670590216e-17","category":"page"},{"location":"packages/Optim/","page":"JuliaNLSolvers/Optim.jl","title":"JuliaNLSolvers/Optim.jl","text":"To get information on the keywords used to construct method instances, use the Julia REPL help prompt (?)","category":"page"},{"location":"packages/Optim/","page":"JuliaNLSolvers/Optim.jl","title":"JuliaNLSolvers/Optim.jl","text":"help?> LBFGS\nsearch: LBFGS\n\n  LBFGS\n  ≡≡≡≡≡\n\n  Constructor\n  ===========\n\n  LBFGS(; m::Integer = 10,\n  alphaguess = LineSearches.InitialStatic(),\n  linesearch = LineSearches.HagerZhang(),\n  P=nothing,\n  precondprep = (P, x) -> nothing,\n  manifold = Flat(),\n  scaleinvH0::Bool = true && (typeof(P) <: Nothing))\n\n  LBFGS has two special keywords; the memory length m, and the scaleinvH0 flag.\n  The memory length determines how many previous Hessian approximations to\n  store. When scaleinvH0 == true, then the initial guess in the two-loop\n  recursion to approximate the inverse Hessian is the scaled identity, as can be\n  found in Nocedal and Wright (2nd edition) (sec. 7.2).\n\n  In addition, LBFGS supports preconditioning via the P and precondprep keywords.\n\n  Description\n  ===========\n\n  The LBFGS method implements the limited-memory BFGS algorithm as described in\n  Nocedal and Wright (sec. 7.2, 2006) and original paper by Liu & Nocedal\n  (1989). It is a quasi-Newton method that updates an approximation to the\n  Hessian using past approximations as well as the gradient.\n\n  References\n  ==========\n\n    •  Wright, S. J. and J. Nocedal (2006), Numerical optimization, 2nd edition.\n       Springer\n\n    •  Liu, D. C. and Nocedal, J. (1989). \"On the Limited Memory Method for\n       Large Scale Optimization\". Mathematical Programming B. 45 (3): 503–528","category":"page"},{"location":"packages/Optim/#Use-with-JuMP","page":"JuliaNLSolvers/Optim.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/Optim/","page":"JuliaNLSolvers/Optim.jl","title":"JuliaNLSolvers/Optim.jl","text":"You can use Optim.jl with JuMP.jl as follows:","category":"page"},{"location":"packages/Optim/","page":"JuliaNLSolvers/Optim.jl","title":"JuliaNLSolvers/Optim.jl","text":"julia> using JuMP, Optim\n\njulia> model = Model(Optim.Optimizer);\n\njulia> set_optimizer_attribute(model, \"method\", BFGS())\n\njulia> @variable(model, x[1:2]);\n\njulia> @objective(model, Min, (1.0 - x[1])^2 + 100.0 * (x[2] - x[1]^2)^2)\n(x[1]² - 2 x[1] + 1) + (100.0 * ((-x[1]² + x[2]) ^ 2.0))\n\njulia> optimize!(model)\n\njulia> objective_value(model)\n3.7218241804173566e-21\n\njulia> value.(x)\n2-element Vector{Float64}:\n 0.9999999999373603\n 0.99999999986862","category":"page"},{"location":"packages/Optim/#Citation","page":"JuliaNLSolvers/Optim.jl","title":"Citation","text":"","category":"section"},{"location":"packages/Optim/","page":"JuliaNLSolvers/Optim.jl","title":"JuliaNLSolvers/Optim.jl","text":"If you use Optim.jl in your work, please cite the following:","category":"page"},{"location":"packages/Optim/","page":"JuliaNLSolvers/Optim.jl","title":"JuliaNLSolvers/Optim.jl","text":"@article{mogensen2018optim,\n  author  = {Mogensen, Patrick Kofod and Riseth, Asbj{\\o}rn Nilsen},\n  title   = {Optim: A mathematical optimization package for {Julia}},\n  journal = {Journal of Open Source Software},\n  year    = {2018},\n  volume  = {3},\n  number  = {24},\n  pages   = {615},\n  doi     = {10.21105/joss.00615}\n}","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"EditURL = \"https://github.com/PSORLab/EAGO.jl/blob/8bba4cf6d9ef1602b4cfe3ea31b847f21ce25837/docs/src/jump/README.md\"","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"<img src=\"https://github.com/PSORLab/EAGO.jl/blob/master/docs/src/assets/logo.png?raw=true\" width=\"75%\" height=\"75%\"/>","category":"page"},{"location":"packages/EAGO/#EAGO-Easy-Advanced-Global-Optimization","page":"PSORLab/EAGO.jl","title":"EAGO - Easy Advanced Global Optimization","text":"","category":"section"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"EAGO is an open-source development environment for robust and global optimization in Julia. See the full README for more information.","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"PSOR Lab Current Version Build Status Documentation\n(Image: ) (Image: ) (Image: Build Status) (Image: codecov) (Image: )","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"EAGO is a deterministic global optimizer designed to address a wide variety of optimization problems, emphasizing nonlinear programs (NLPs), by propagating McCormick relaxations along the factorable structure of each expression in the NLP. Most operators supported by modern automatic differentiation (AD) packages are supported by EAGO and a number utilities for sanitizing native Julia code and generating relaxations on a wide variety of user-defined functions have been included. Currently, EAGO supports problems that have a priori variable bounds defined and have differentiable constraints. That is, problems should be specified in the generic form below:","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"beginaligned\nf^* =  min_mathbf y in Y subset mathbb R^n_y f(mathbf y) \nrm st    mathbf h(mathbf y) = mathbf 0 \n mathbf g(mathbf y) leq mathbf 0 \n Y = mathbf y^L mathbf y^U in mathbbIR^n \n qquad mathbf y^L mathbf y^U in mathbb R^n\nendaligned","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"For each nonlinear term, EAGO makes use of factorable representations to construct bounds and relaxations.","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"For example, given the function","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"f(x) = x (x - 5) sin(x)","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"a list is generated and rules for constructing McCormick relaxations are used  to formulate relaxations in the original decision space, X [1]:","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"beginaligned\nv_1  = x \nv_2  = v_1 - 5 \nv_3  = sin(v_1) \nv_4  = v_1 v_2 \nv_5  = v_4 v_3 \nf(x)  = v_5 \nendaligned","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"<p align=\"center\">\n<img src=\"https://github.com/PSORLab/EAGO.jl/blob/master/docs/src/mccormick/Figure_1.png?raw=true\" width=\"60%\" height=\"60%\"/>\n</p>","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"Either these original relaxations, differentiable McCormick relaxations [2], or affine relaxations thereof can be used to construct relaxations of optimization problems useful in branch and bound routines for global optimization. Utilities are included to combine these with algorithms for relaxing implicit functions [3] and forward-reverse propagation of McCormick arithmetic [4].","category":"page"},{"location":"packages/EAGO/#License","page":"PSORLab/EAGO.jl","title":"License","text":"","category":"section"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"EAGO is licensed under the MIT License.","category":"page"},{"location":"packages/EAGO/#Installation","page":"PSORLab/EAGO.jl","title":"Installation","text":"","category":"section"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"EAGO is a registered Julia package that can be installed using the Julia package manager:","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"import Pkg\nPkg.add(\"EAGO\")","category":"page"},{"location":"packages/EAGO/#Use-with-JuMP","page":"PSORLab/EAGO.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"EAGO makes use of JuMP to improve the user's experience in setting up optimization models. Consider the \"process\" problem instance from [5]:","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"beginaligned\nmax_mathbf x in X  0063 x_4 x_7 - 504 x_1 - 0035 x_2 - 10 x_3 - 336 x_2 \nrm st    x_1 (112 + 013167 x_8 - 000667 x_8^2) + x_4 = 0 \n -0001 x_4 x_9 x_6  (98 - x_6) + x_3 = 0 \n -(1098 x_8 - 0038 x_8^2) - 0325 x_6 + x_7 = 0 \n -(x_2 + x_5)  x_1 + x_8 = 0 \n -x_1 + 122 x_4 - x_5 = 0 \n x_9 + 0222 x_10 - 3582 = 0 \n -30 x_7 + x_10 + 1330 = 0 \n X = 10 2000 times 0 16000 times 0 120 times 0 5000 \n qquad times 0 2000 times 85 93 times 909 5 times 3 12 times 12 4 times 145 162\nendaligned","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"This model can be formulated in Julia as:","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"using JuMP\nimport EAGO\n# Build model using EAGO's optimizer\nmodel = Model(EAGO.Optimizer)\n# Define bounded variables\nxL = [10.0, 0.0, 0.0, 0.0, 0.0, 85.0, 90.0, 3.0, 1.2, 145.0]\nxU = [2000.0, 16000.0, 120.0, 5000.0, 2000.0, 93.0, 95.0, 12.0, 4.0, 162.0]\n@variable(model, xL[i] <= x[i=1:10] <= xU[i])\n# Define nonlinear constraints\n@NLconstraints(model, begin\n    -x[1]*(1.12 + 0.13167*x[8] - 0.00667*(x[8])^2) + x[4] == 0.0\n    -0.001*x[4]*x[9]*x[6]/(98.0 - x[6]) + x[3] == 0.0\n    -(1.098*x[8] - 0.038*(x[8])^2) - 0.325*x[6] + x[7] == 57.425\n    -(x[2] + x[5])/x[1] + x[8] == 0.0\nend)\n# Define linear constraints\n@constraints(model, begin\n    -x[1] + 1.22*x[4] - x[5] == 0.0\n    x[9] + 0.222*x[10] == 35.82\n    -3.0*x[7] + x[10] == -133.0\nend)\n# Define nonlinear objective\n@NLobjective(\n    model, \n    Max,\n    0.063*x[4]*x[7] - 5.04*x[1] - 0.035*x[2] - 10*x[3] - 3.36*x[5],\n)\n# Solve the optimization problem\noptimize!(model)","category":"page"},{"location":"packages/EAGO/#Documentation","page":"PSORLab/EAGO.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"EAGO has numerous features: a solver accessible from JuMP/MathOptInterface (MOI), domain reduction routines, McCormick relaxations, and specialized nonconvex semi-infinite program solvers. A full description of all features can be found on the documentation website. ","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"A series of examples have been provided in the documentation and in the form of Jupyter Notebooks in the separate EAGO-notebooks repository.","category":"page"},{"location":"packages/EAGO/#A-Cautionary-Note-on-Global-Optimization","page":"PSORLab/EAGO.jl","title":"A Cautionary Note on Global Optimization","text":"","category":"section"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"As a global optimization platform, EAGO's solvers can be used to find solutions of general nonconvex problems with a guaranteed certificate of optimality. However, global solvers suffer from the curse of dimensionality and therefore their performance is outstripped by convex/local solvers.","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"For users interested in large-scale applications, be warned that problems generally larger than a few variables may prove challenging for certain types of global optimization problems.","category":"page"},{"location":"packages/EAGO/#Citing-EAGO","page":"PSORLab/EAGO.jl","title":"Citing EAGO","text":"","category":"section"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"Please cite the following paper when using EAGO. In plain text form this is:","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"Wilhelm, M.E. and Stuber, M.D. EAGO.jl: easy advanced global optimization in Julia.\nOptimization Methods and Software. 37(2): 425—450 (2022). DOI: 10.1080/10556788.2020.1786566","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"As a BibTeX entry:","category":"page"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"@article{doi:10.1080/10556788.2020.1786566,\n    author = {Wilhelm, M.E. and Stuber, M.D.},\n    title = {EAGO.jl: easy advanced global optimization in Julia},\n    journal = {Optimization Methods and Software},\n    volume = {37},\n    number = {2},\n    pages = {425-450},\n    year  = {2022},\n    publisher = {Taylor & Francis},\n    doi = {10.1080/10556788.2020.1786566},\n    URL = {https://doi.org/10.1080/10556788.2020.1786566},\n    eprint = {https://doi.org/10.1080/10556788.2020.1786566}\n}","category":"page"},{"location":"packages/EAGO/#References","page":"PSORLab/EAGO.jl","title":"References","text":"","category":"section"},{"location":"packages/EAGO/","page":"PSORLab/EAGO.jl","title":"PSORLab/EAGO.jl","text":"Mitsos, A., Chachuat, B., and Barton, P.I. McCormick-based relaxations of algorithms. SIAM Journal on Optimization. 20(2): 573—601 (2009).\nKhan, K.A., Watson, H.A.J., and Barton, P.I. Differentiable McCormick relaxations. Journal of Global Optimization. 67(4): 687—729 (2017).\nStuber, M.D., Scott, J.K., and Barton, P.I.: Convex and concave relaxations of implicit functions. Optimization Methods and Software 30(3): 424—460 (2015).\nWechsung, A., Scott, J.K., Watson, H.A.J., and Barton, P.I. Reverse propagation of McCormick relaxations. Journal of Global Optimization 63(1): 1—36 (2015).\nBracken, J., and McCormick, G.P. Selected Applications of Nonlinear Programming. John Wiley and Sons, New York (1968).","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"EditURL = \"complementarity.jl\"","category":"page"},{"location":"tutorials/nonlinear/complementarity/#Mixed-complementarity-problems","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"","category":"section"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"This tutorial is a collection of mixed complementarity programs.","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"using JuMP\nimport PATHSolver","category":"page"},{"location":"tutorials/nonlinear/complementarity/#Background","page":"Mixed complementarity problems","title":"Background","text":"","category":"section"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"A mixed complementarity problem has the form:","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"beginalign\n    F_i(x) perp x_i  i = 1 ldots n \n    l_i le x_i le u_i  i = 1 ldots n\nendalign","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"where the perp constraint enforces the following relations:","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"If l_i  x_i  u_i, then F_i(x) = 0\nIf l_i = x_i, then F_i(x) ge 0\nIf x_i = u_i, then F_i(x) le 0","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"You may have seen a complementarity problem written as 0 le F(x) perp x ge 0. This is a special case of a mixed complementarity problem in which l_i = 0 and u_i = infty.","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"Importantly, a mixed complementarity problem does not have an objective, and no other constraint types are present.","category":"page"},{"location":"tutorials/nonlinear/complementarity/#Linear-complementarity","page":"Mixed complementarity problems","title":"Linear complementarity","text":"","category":"section"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"Form a mixed complementarity problem using the perp symbol ⟂ (type \\perp<tab> in the REPL).","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"M = [0 0 -1 -1; 0 0 1 -2; 1 -1 2 -2; 1 2 -2 4]\nq = [2, 2, -2, -6]\nmodel = Model(PATHSolver.Optimizer)\nset_silent(model)\n@variable(model, 0 <= x[1:4] <= 10, start = 0)\n@constraint(model, M * x + q ⟂ x)\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue.(x)","category":"page"},{"location":"tutorials/nonlinear/complementarity/#Other-ways-of-writing-linear-complementarity-problems","page":"Mixed complementarity problems","title":"Other ways of writing linear complementarity problems","text":"","category":"section"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"You do not need to use a single vector of variables, and the complementarity constraints can be given in any order. In addition, you can use the perp symbol, the complements(F, x) syntax, or the MOI.Complements set.","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"model = Model(PATHSolver.Optimizer)\nset_silent(model)\n@variable(model, 0 <= w <= 10, start = 0)\n@variable(model, 0 <= x <= 10, start = 0)\n@variable(model, 0 <= y <= 10, start = 0)\n@variable(model, 0 <= z <= 10, start = 0)\n@constraint(model, complements(y - 2z + 2, x))\n@constraint(model, [-y - z + 2, w] in MOI.Complements(2))\n@constraint(model, w + 2x - 2y + 4z - 6 ⟂ z)\n@constraint(model, w - x + 2y - 2z - 2 ⟂ y)\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue.([w, x, y, z])","category":"page"},{"location":"tutorials/nonlinear/complementarity/#Transportation","page":"Mixed complementarity problems","title":"Transportation","text":"","category":"section"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"This example is a reformulation of the transportation problem from Chapter 3.3 of Dantzig, G.B. (1963). Linear Programming and Extensions. Princeton University Press, Princeton, New Jersey. It is based on the GAMS model gamslib_transmcp.","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"capacity = Dict(\"seattle\" => 350, \"san-diego\" => 600)\ndemand = Dict(\"new-york\" => 325, \"chicago\" => 300, \"topeka\" => 275)\ncost = Dict(\n    (\"seattle\" => \"new-york\") => 90 * 2.5 / 1_000,\n    (\"seattle\" => \"chicago\") => 90 * 1.7 / 1_000,\n    (\"seattle\" => \"topeka\") => 90 * 1.8 / 1_000,\n    (\"san-diego\" => \"new-york\") => 90 * 2.5 / 1_000,\n    (\"san-diego\" => \"chicago\") => 90 * 1.8 / 1_000,\n    (\"san-diego\" => \"topeka\") => 90 * 1.4 / 1_000,\n)\nplants, markets = keys(capacity), keys(demand)\nmodel = Model(PATHSolver.Optimizer)\nset_silent(model)\n@variable(model, w[i in plants] >= 0)\n@variable(model, p[j in markets] >= 0)\n@variable(model, x[i in plants, j in markets] >= 0)\n@constraints(\n    model,\n    begin\n        [i in plants, j in markets], w[i] + cost[i=>j] - p[j] ⟂ x[i, j]\n        [i in plants], capacity[i] - sum(x[i, :]) ⟂ w[i]\n        [j in markets], sum(x[:, j]) - demand[j] ⟂ p[j]\n    end\n)\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue.(p)","category":"page"},{"location":"tutorials/nonlinear/complementarity/#Expected-utility-of-insurance","page":"Mixed complementarity problems","title":"Expected utility of insurance","text":"","category":"section"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"This example is taken from a lecture of the course AAE706, given by Thomas F. Rutherford at the University of Wisconsin, Madison. It models the expected coverage of insurance K that a rational actor would obtain to insure a risk that occurs with probability pi and results in a loss of L.","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"pi = 0.01  # Probability of a bad outcome\nL = 0.5    # Loss with a bad outcome\nγ = 0.02   # Premium for coverage\nσ = 0.5    # Elasticity\nρ = -1     # Risk exponent\nU(C) = C^ρ / ρ\nMU(C) = C^(ρ - 1)\nmodel = Model(PATHSolver.Optimizer)\nset_silent(model)\n@variable(model, EU, start = 1)   # Expected utility\n@variable(model, EV, start = 1)   # Equivalent variation in income\n@variable(model, C_G, start = 1)  # Consumption on a good day\n@variable(model, C_B, start = 1)  # Consumption on a bad day\n@variable(model, K, start = 1)    # Coverage\n@constraints(\n    model,\n    begin\n        (1 - pi) * U(C_G) + pi * U(C_B) - EU ⟂ EU\n        100 * (((1 - pi) * C_G^ρ + pi * C_B^ρ)^(1 / ρ) - 1) - EV ⟂ EV\n        1 - γ * K - C_G ⟂ C_G\n        1 - L + (1 - γ) * K - C_B ⟂ C_B\n        γ * ((1 - pi) * MU(C_G) + pi * MU(C_B)) - pi * MU(C_B) ⟂ K\n    end\n)\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue(K)","category":"page"},{"location":"tutorials/nonlinear/complementarity/#Electricity-consumption","page":"Mixed complementarity problems","title":"Electricity consumption","text":"","category":"section"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"This example is a mixed complementarity formulation of Example 3.3.1 from (D’Aertrycke et al., 2017).","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"This example models a risk neutral competitive equilibrium between a producer and a consumer of electricity.","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"In our example, we assume a producer is looking to invest in a new power plant with capacity x [MW]. This plant has an annualized capital cost of I [€/MW] and an operating cost of C [€/MWh]. There are 8760 hours in a year.","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"After making the capital investment, there are five possible consumption scenarios, omega, which occur with probability theta_omega. In each scenario , the producer makes Y_ω MW of electricity.","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"There is one consumer in the model, who has a quadratic utility function, U(Q_ω) = A_ω Q_ω + fracB_ω Q_ω^22.","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"We now build and solve the mixed complementarity problem with a few brief comments. The economic justification for the model would require a larger tutorial than the space available here. Consult (D’Aertrycke et al., 2017) for details.","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"I = 90_000                     # Annualized capital cost\nC = 60                         # Operation cost per MWh\nτ = 8_760                      # Hours per year\nθ = [0.2, 0.2, 0.2, 0.2, 0.2]  # Scenario probabilities\nA = [300, 350, 400, 450, 500]  # Utility function coefficients\nB = 1                          # Utility function coefficients\nmodel = Model(PATHSolver.Optimizer)\nset_silent(model)\n@variable(model, x >= 0, start = 1)           # Installed capacity\n@variable(model, Q[ω = 1:5] >= 0, start = 1)  # Consumption\n@variable(model, Y[ω = 1:5] >= 0, start = 1)  # Production\n@variable(model, P[ω = 1:5], start = 1)       # Electricity price\n@variable(model, μ[ω = 1:5] >= 0, start = 1)  # Capital scarcity margin\n# Unit investment cost equals annualized scarcity profit or investment is 0\n@constraint(model, I - τ * θ' * μ ⟂ x)\n# Difference between price and scarcity margin is equal to operation cost\n@constraint(model, [ω = 1:5], C - (P[ω] - μ[ω]) ⟂ Y[ω])\n# Price is equal to consumer's marginal utility\n@constraint(model, [ω = 1:5], P[ω] - (A[ω] - B * Q[ω]) ⟂ Q[ω])\n# Production is equal to consumption\n@constraint(model, [ω = 1:5], Y[ω] - Q[ω] ⟂ P[ω])\n# Production does not exceed capacity\n@constraint(model, [ω = 1:5], x - Y[ω] ⟂ μ[ω])\noptimize!(model)\n@assert is_solved_and_feasible(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"An equilibrium solution is to build 389 MW:","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"value(x)","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"The production in each scenario is:","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"value.(Q)","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"The price in each scenario is:","category":"page"},{"location":"tutorials/nonlinear/complementarity/","page":"Mixed complementarity problems","title":"Mixed complementarity problems","text":"value.(P)","category":"page"},{"location":"developers/custom_solver_binaries/#How-to-use-a-custom-binary","page":"Custom binaries","title":"How to use a custom binary","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Many solvers are not written in Julia, but instead in languages like C or C++. JuMP interacts with these solvers through binary dependencies.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"For many open-source solvers, we automatically install the appropriate binary when you run Pkg.add(\"Solver\"). For example, Pkg.add(\"ECOS\") will also install the ECOS binary.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"This page explains how this installation works, and how you can use a custom binary.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"compat: Compat\nThese instructions require Julia 1.6 or later.","category":"page"},{"location":"developers/custom_solver_binaries/#Background","page":"Custom binaries","title":"Background","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Each solver that JuMP supports is structured as a Julia package. For example, the interface for the ECOS solver is provided by the ECOS.jl package.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"tip: Tip\nThis page uses the example of ECOS.jl because it is simple to compile. Other solvers follow similar conventions. For example, the interface to the Clp solver is provided by Clp.jl.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"The ECOS.jl package provides an interface between the C API of ECOS and MathOptInterface. However, it does not handle the installation of the solver binary; that is the job for a JLL package.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"A JLL is a Julia package that wraps a pre-compiled binary. Binaries are built using Yggdrasil (for example, ECOS) and hosted in the JuliaBinaryWrappers GitHub repository (for example, ECOS_jll.jl).","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"JLL packages contain little code. Their only job is to dlopen a dynamic library, along with any dependencies.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"JLL packages manage their binary dependencies using Julia's artifact system. Each JLL package has an Artifacts.toml file which describes where to find each binary artifact for each different platform that it might be installed on. Here is the Artifacts.toml file for ECOS_jll.jl.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"The binaries installed by the JLL package should be sufficient for most users. In rare cases, however, you may require a custom binary. The two main reasons to use a custom binary are:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"You want a binary with custom compilation settings (for example, debugging)\nYou want a binary with a set of dependencies that are not available on Yggdrasil (for example, a commercial solver like Gurobi or CPLEX).","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"The following sections explain how to replace the binaries provided by a JLL package with the custom ones you have compiled. As a reminder, we use ECOS as an example for simplicity, but the steps are the same for other solvers.","category":"page"},{"location":"developers/custom_solver_binaries/#jll_structure","page":"Custom binaries","title":"Explore the JLL you want to override","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"The first step is to explore the structure and filenames of the JLL package we want to override.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Find the location of the files using .artifact_dir:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"julia> using ECOS_jll\n\njulia> ECOS_jll.artifact_dir\n\"/Users/oscar/.julia/artifacts/2addb75332eff5a1657b46bb6bf30d2410bc7ecf\"","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"tip: Tip\nThis path may be different on other machines.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Here is what it contains:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"julia> readdir(ECOS_jll.artifact_dir)\n4-element Vector{String}:\n \"include\"\n \"lib\"\n \"logs\"\n \"share\"\n\njulia> readdir(joinpath(ECOS_jll.artifact_dir, \"lib\"))\n1-element Vector{String}:\n \"libecos.dylib\"","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Other solvers may have a bin directory containing executables. To use a custom binary of ECOS, we need to replace /lib/libecos.dylib with our custom binary.","category":"page"},{"location":"developers/custom_solver_binaries/#compile_ecos","page":"Custom binaries","title":"Compile a custom binary","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"The next step is to compile a custom binary. Because ECOS is written in C with no dependencies, this is easy to do if you have a C compiler:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"oscar@Oscars-MBP jll_example % git clone https://github.com/embotech/ecos.git\n[... lines omitted ...]\noscar@Oscars-MBP jll_example % cd ecos\noscar@Oscars-MBP ecos % make shared\n[... many lines omitted...]\noscar@Oscars-MBP ecos % mkdir lib\noscar@Oscars-MBP ecos % cp libecos.dylib lib","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"warning: Warning\nCompiling custom solver binaries is an advanced operation. Due to the complexities of compiling various solvers, the JuMP community is unable to help you diagnose and fix compilation issues.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"After this compilation step, we now have a folder /tmp/jll_example/ecos that contains lib and include directories with the same files as ECOS_jll:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"julia> readdir(joinpath(\"ecos\", \"lib\"))\n1-element Vector{String}:\n \"libecos.dylib\"","category":"page"},{"location":"developers/custom_solver_binaries/#Overriding-a-single-library","page":"Custom binaries","title":"Overriding a single library","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"To override the libecos library, we need to know what ECOS_jll calls it. (In most cases, it will also be libecos, but not always.)","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"There are two ways you can check.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Check the bottom of the JLL's GitHub README. For example, ECOS_jll has a single LibraryProduct called libecos.\nType ECOS_jll. and the press the [TAB] key twice to auto-complete available options:\njulia> ECOS_jll.\nLIBPATH           PATH_list          best_wrapper       get_libecos_path   libecos_handle\nLIBPATH_list      __init__           dev_jll            is_available       libecos_path\nPATH              artifact_dir       find_artifact_dir  libecos\nHere you can see there is libecos, and more usefully for us, libecos_path.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Once you know the name of the variable to override (the one that ends in _path), use  Preferences.jl to specify a new path:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"using Preferences\nset_preferences!(\n    \"LocalPreferences.toml\",\n    \"ECOS_jll\",\n    \"libecos_path\" => \"/tmp/jll_example/ecos/lib/libecos\"\n)","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"This will create a file in your current directory called LocalPreferences.toml with the contents:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"[ECOS_jll]\nlibecos_path = \"/tmp/jll_example/ecos/lib/libecos\"","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Now if you restart Julia, you will see:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"julia> using ECOS_jll\n\njulia> ECOS_jll.libecos\n\"/tmp/jll_example/ecos/lib/libecos\"","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"To go back to using the default library, just delete the LocalPreferences.toml file.","category":"page"},{"location":"developers/custom_solver_binaries/#Overriding-an-entire-artifact","page":"Custom binaries","title":"Overriding an entire artifact","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Sometimes a solver may provide a number of libraries and executables, and specifying the path for each of the becomes tedious. In this case, we can use Julia's Override.toml to replace an entire artifact.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Overriding an entire artifact requires you to replicate the structure and contents of the JLL package that we explored above.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"In most cases you need only reproduce the include, lib, and bin directories (if they exist). You can safely ignore any logs or share directories. Take careful note of what files each directory contains and what they are called.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"For our ECOS example, we already reproduced the structure when we compiled ECOS.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"So, now we need to tell Julia to use our custom installation instead of the default. We can do this by making an override file at ~/.julia/artifacts/Overrides.toml.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Overrides.toml has the following content:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"# Override for ECOS_jll\n2addb75332eff5a1657b46bb6bf30d2410bc7ecf = \"/tmp/jll_example/ecos\"","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"where 2addb75332eff5a1657b46bb6bf30d2410bc7ecf is the folder from the original ECOS_jll.artifact_dir and \"/tmp/jll_example/ecos\" is the location of our new installation. Replace these as appropriate for your system.","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"If you restart Julia after creating the override file, you will see:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"julia> using ECOS_jll\n\njulia> ECOS_jll.artifact_dir\n\"/tmp/jll_example/ecos\"","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Now when we use ECOS it will use our custom binary.","category":"page"},{"location":"developers/custom_solver_binaries/#Using-Cbc-with-a-custom-binary","page":"Custom binaries","title":"Using Cbc with a custom binary","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"As a second example, we demonstrate how to use Cbc.jl with a custom binary.","category":"page"},{"location":"developers/custom_solver_binaries/#Explore-the-JLL-you-want-to-override","page":"Custom binaries","title":"Explore the JLL you want to override","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"First, let's check where Cbc_jll is installed:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"julia> using Cbc_jll\n\njulia> Cbc_jll.artifact_dir\n\"/Users/oscar/.julia/artifacts/e481bc81db5e229ba1f52b2b4bd57484204b1b06\"\n\njulia> readdir(Cbc_jll.artifact_dir)\n5-element Vector{String}:\n \"bin\"\n \"include\"\n \"lib\"\n \"logs\"\n \"share\"\n\njulia> readdir(joinpath(Cbc_jll.artifact_dir, \"bin\"))\n1-element Vector{String}:\n \"cbc\"\n\njulia> readdir(joinpath(Cbc_jll.artifact_dir, \"lib\"))\n10-element Vector{String}:\n \"libCbc.3.10.5.dylib\"\n \"libCbc.3.dylib\"\n \"libCbc.dylib\"\n \"libCbcSolver.3.10.5.dylib\"\n \"libCbcSolver.3.dylib\"\n \"libCbcSolver.dylib\"\n \"libOsiCbc.3.10.5.dylib\"\n \"libOsiCbc.3.dylib\"\n \"libOsiCbc.dylib\"\n \"pkgconfig\"","category":"page"},{"location":"developers/custom_solver_binaries/#Compile-a-custom-binary","page":"Custom binaries","title":"Compile a custom binary","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Next, we need to compile Cbc. Cbc can be difficult to compile (it has a lot of dependencies), but for macOS users there is a homebrew recipe:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"(base) oscar@Oscars-MBP jll_example % brew install cbc\n[ ... lines omitted ... ]\n(base) oscar@Oscars-MBP jll_example % brew list cbc\n/usr/local/Cellar/cbc/2.10.5/bin/cbc\n/usr/local/Cellar/cbc/2.10.5/include/cbc/ (76 files)\n/usr/local/Cellar/cbc/2.10.5/lib/libCbc.3.10.5.dylib\n/usr/local/Cellar/cbc/2.10.5/lib/libCbcSolver.3.10.5.dylib\n/usr/local/Cellar/cbc/2.10.5/lib/libOsiCbc.3.10.5.dylib\n/usr/local/Cellar/cbc/2.10.5/lib/pkgconfig/ (2 files)\n/usr/local/Cellar/cbc/2.10.5/lib/ (6 other files)\n/usr/local/Cellar/cbc/2.10.5/share/cbc/ (59 files)\n/usr/local/Cellar/cbc/2.10.5/share/coin/ (4 files)","category":"page"},{"location":"developers/custom_solver_binaries/#Override-single-libraries","page":"Custom binaries","title":"Override single libraries","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"To use Preferences.jl to override specific libraries we first check the names of each library in Cbc_jll:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"julia> Cbc_jll.\nLIBPATH               cbc                    get_libcbcsolver_path  libOsiCbc_path\nLIBPATH_list          cbc_path               is_available           libcbcsolver\nPATH                  dev_jll                libCbc                 libcbcsolver_handle\nPATH_list             find_artifact_dir      libCbc_handle          libcbcsolver_path\n__init__              get_cbc_path           libCbc_path\nartifact_dir          get_libCbc_path        libOsiCbc\nbest_wrapper          get_libOsiCbc_path     libOsiCbc_handle","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"Then we add the following to LocalPreferences.toml:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"[Cbc_jll]\ncbc_path = \"/usr/local/Cellar/cbc/2.10.5/bin/cbc\"\nlibCbc_path = \"/usr/local/Cellar/cbc/2.10.5/lib/libCbc.3.10.5\"\nlibOsiCbc_path = \"/usr/local/Cellar/cbc/2.10.5/lib/libOsiCbc.3.10.5\"\nlibcbcsolver_path = \"/usr/local/Cellar/cbc/2.10.5/lib/libCbcSolver.3.10.5\"","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"info: Info\nNote that capitalization matters, so libcbcsolver_path corresponds to libCbcSolver.3.10.5.","category":"page"},{"location":"developers/custom_solver_binaries/#Override-entire-artifact","page":"Custom binaries","title":"Override entire artifact","text":"","category":"section"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"To use the homebrew install as our custom binary we add the following to ~/.julia/artifacts/Overrides.toml:","category":"page"},{"location":"developers/custom_solver_binaries/","page":"Custom binaries","title":"Custom binaries","text":"# Override for Cbc_jll\ne481bc81db5e229ba1f52b2b4bd57484204b1b06 = \"/usr/local/Cellar/cbc/2.10.5\"","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"EditURL = \"benders_decomposition.jl\"","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/#benders_decomposition_classical","page":"Benders decomposition","title":"Benders decomposition","text":"","category":"section"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"This tutorial was originally contributed by Shuvomoy Das Gupta.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"This tutorial describes how to implement Benders decomposition in JuMP. It uses the following packages:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"using JuMP\nimport GLPK\nimport Printf","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/#Theory","page":"Benders decomposition","title":"Theory","text":"","category":"section"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Benders decomposition is a useful algorithm for solving convex optimization problems with a large number of variables. It works best when a larger problem can be decomposed into two (or more) smaller problems that are individually much easier to solve. This tutorial demonstrates Benders decomposition on the following mixed-integer linear program:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"beginaligned\ntextmin          c_1^top x+c_2^top y   \ntextsubject to   A_1 x+ A_2 y le b      \n                     x ge 0                 \n                     y ge 0                 \n                     x in mathbbZ^n\nendaligned","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"where b in mathbbR^m, A_1 in mathbbR^m times n, A_2 in mathbbR^m times p and mathbbZ is the set of integers.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Any mixed integer programming problem can be written in the form above.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"If there are relatively few integer variables, and many more continuous variables, then it may be beneficial to decompose the problem into a small problem containing only integer variables and a linear program containing only continuous variables. Hopefully, the linear program will be much easier to solve in isolation than in the full mixed-integer linear program.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"For example, if we knew a feasible solution for x, we could obtain a solution for y by solving:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"beginaligned\nV_2(x) =  textmin            c_2^top y                        \n          textsubject to     A_2 y le b - A_1 x  quad pi \n                                 y ge 0\nendaligned","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"where pi is the dual variable associated with the constraints. Because this is a linear program, it is easy to solve.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Replacing the c_2^top y component of the objective in our original problem with V_2 yields:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"beginaligned\ntextmin          c_1^top x + V_2(x) \ntextsubject to   x ge 0             \n                     x in mathbbZ^n\nendaligned","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"This problem looks a lot simpler to solve, but we need to do something else with V_2 first.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Because x is a constant that appears on the right-hand side of the constraints, V_2 is a convex function with respect to x, and the dual variable pi can be multiplied by -A_1 to obtain a subgradient of V_2(x) with respect to x. Therefore, if we have a candidate solution x_k, then we can solve V_2(x_k) and obtain a feasible dual vector pi_k. Using these values, we can construct a first-order Taylor-series approximation of V_2 about the point x_k:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"V_2(x) ge V_2(x_k) + -pi_k^top A_1 (x - x_k)","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"By convexity, we know that this inequality holds for all x, and we call these inequalities cuts.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Benders decomposition is an iterative technique that replaces V_2(x) with a new decision variable theta, and approximates it from below using cuts:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"beginaligned\nV_1^K =  textmin           c_1^top x + theta  \n          textsubject to   x ge 0              \n                              x in mathbbZ^n   \n                              theta ge M         \n                              theta ge V_2(x_k) + pi_k^top(x - x_k)  quad forall k = 1ldotsK\nendaligned","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"This integer program is called the first-stage subproblem.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"To generate cuts, we solve V_1^K to obtain a candidate first-stage solution x_k, then we use that solution to solve V_2(x_k). Then, using the optimal objective value and dual solution from V_2, we add a new cut to form V_1^K+1 and repeat.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/#Bounds","page":"Benders decomposition","title":"Bounds","text":"","category":"section"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Due to convexity, we know that V_2(x) ge theta for all x. Therefore, the optimal objective value of V_1^K provides a valid lower bound on the objective value of the full problem. In addition, if we take a feasible solution for x from the first-stage problem, then c_1^top x + V_2(x) is a valid upper bound on the objective value of the full problem.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Benders decomposition uses the lower and upper bounds to determine when it has found the global optimal solution.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/#Input-data","page":"Benders decomposition","title":"Input data","text":"","category":"section"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"As an example for this tutorial, we use the input data is from page 139 of Garfinkel, R. & Nemhauser, G. L. Integer programming. (Wiley, 1972).","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"c_1 = [1, 4]\nc_2 = [2, 3]\ndim_x = length(c_1)\ndim_y = length(c_2)\nb = [-2; -3]\nA_1 = [1 -3; -1 -3]\nA_2 = [1 -2; -1 -1]\nM = -1000;\nnothing #hide","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/#benders_iterative","page":"Benders decomposition","title":"Iterative method","text":"","category":"section"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"warning: Warning\nThis is a basic implementation for pedagogical purposes. We haven't discussed Benders feasibility cuts, or any of the computational tricks that are required to build a performant implementation for large-scale problems. See In-place iterative method for one improvement that helps computation time.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"We start by formulating the first-stage subproblem:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"model = Model(GLPK.Optimizer)\n@variable(model, x[1:dim_x] >= 0, Int)\n@variable(model, θ >= M)\n@objective(model, Min, c_1' * x + θ)\nprint(model)","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"For the next step, we need a function that takes a first-stage candidate solution x and returns the optimal solution from the second-stage subproblem:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"function solve_subproblem(x)\n    model = Model(GLPK.Optimizer)\n    @variable(model, y[1:dim_y] >= 0)\n    con = @constraint(model, A_2 * y .<= b - A_1 * x)\n    @objective(model, Min, c_2' * y)\n    optimize!(model)\n    @assert is_solved_and_feasible(model; dual = true)\n    return (obj = objective_value(model), y = value.(y), π = dual.(con))\nend","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Note that solve_subproblem returns a NamedTuple of the objective value, the optimal primal solution for y, and the optimal dual solution for π.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"We're almost ready for our optimization loop, but first, here's a helpful function for logging:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"function print_iteration(k, args...)\n    f(x) = Printf.@sprintf(\"%12.4e\", x)\n    println(lpad(k, 9), \" \", join(f.(args), \" \"))\n    return\nend","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"We also need to put a limit on the number of iterations before termination:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"MAXIMUM_ITERATIONS = 100","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"And a way to check if the lower and upper bounds are close-enough to terminate:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"ABSOLUTE_OPTIMALITY_GAP = 1e-6","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Now we're ready to iterate Benders decomposition:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"println(\"Iteration  Lower Bound  Upper Bound          Gap\")\nfor k in 1:MAXIMUM_ITERATIONS\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    lower_bound = objective_value(model)\n    x_k = value.(x)\n    ret = solve_subproblem(x_k)\n    upper_bound = c_1' * x_k + ret.obj\n    gap = (upper_bound - lower_bound) / upper_bound\n    print_iteration(k, lower_bound, upper_bound, gap)\n    if gap < ABSOLUTE_OPTIMALITY_GAP\n        println(\"Terminating with the optimal solution\")\n        break\n    end\n    cut = @constraint(model, θ >= ret.obj + -ret.π' * A_1 * (x .- x_k))\n    @info \"Adding the cut $(cut)\"\nend","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Finally, we can obtain the optimal solution","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"optimize!(model)\n@assert is_solved_and_feasible(model)\nx_optimal = value.(x)","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"optimal_ret = solve_subproblem(x_optimal)\ny_optimal = optimal_ret.y","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/#Callback-method","page":"Benders decomposition","title":"Callback method","text":"","category":"section"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"The Iterative method section implemented Benders decomposition using a loop. In each iteration, we re-solved the first-stage subproblem to generate a candidate solution. However, modern MILP solvers such as CPLEX, Gurobi, and GLPK provide lazy constraint callbacks which allow us to add new cuts while the solver is running. This can be more efficient than an iterative method because we can avoid repeating work such as solving the root node of the first-stage MILP at each iteration.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"tip: Tip\nFor more information on callbacks, read the page Solver-independent callbacks.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"As before, we construct the same first-stage subproblem:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"lazy_model = Model(GLPK.Optimizer)\n@variable(lazy_model, x[1:dim_x] >= 0, Int)\n@variable(lazy_model, θ >= M)\n@objective(lazy_model, Min, c_1' * x + θ)\nprint(lazy_model)","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"What differs is that we write a callback function instead of a loop:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"number_of_subproblem_solves = 0\nfunction my_callback(cb_data)\n    status = callback_node_status(cb_data, lazy_model)\n    if status != MOI.CALLBACK_NODE_STATUS_INTEGER\n        # Only add the constraint if `x` is an integer feasible solution\n        return\n    end\n    x_k = callback_value.(cb_data, x)\n    θ_k = callback_value(cb_data, θ)\n    global number_of_subproblem_solves += 1\n    ret = solve_subproblem(x_k)\n    if θ_k < (ret.obj - 1e-6)\n        # Only add the constraint if θ_k violates the constraint\n        cut = @build_constraint(θ >= ret.obj + -ret.π' * A_1 * (x .- x_k))\n        MOI.submit(lazy_model, MOI.LazyConstraint(cb_data), cut)\n    end\n    return\nend\n\nset_attribute(lazy_model, MOI.LazyConstraintCallback(), my_callback)","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Now when we optimize!, our callback is run:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"optimize!(lazy_model)\n@assert is_solved_and_feasible(lazy_model)","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"For this model, the callback algorithm required more solves of the subproblem:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"number_of_subproblem_solves","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"But for larger problems, you can expect the callback algorithm to be more efficient than the iterative algorithm.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Finally, we can obtain the optimal solution:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"x_optimal = value.(x)","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"optimal_ret = solve_subproblem(x_optimal)\ny_optimal = optimal_ret.y","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/#In-place-iterative-method","page":"Benders decomposition","title":"In-place iterative method","text":"","category":"section"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Our implementation of the iterative method has a problem: every time we need to solve the subproblem, we must rebuild it from scratch. This is expensive, and it can be the bottleneck in the solution process. We can improve our implementation by using re-using the subproblem between solves.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"First, we create our first-stage problem as usual:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"model = Model(GLPK.Optimizer)\n@variable(model, x[1:dim_x] >= 0, Int)\n@variable(model, θ >= M)\n@objective(model, Min, c_1' * x + θ)\nprint(model)","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Then, instead of building the subproblem in a function, we build it once here:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"subproblem = Model(GLPK.Optimizer)\n@variable(subproblem, x_copy[1:dim_x])\n@variable(subproblem, y[1:dim_y] >= 0)\n@constraint(subproblem, A_1 * x_copy + A_2 * y .<= b)\n@objective(subproblem, Min, c_2' * y)\nprint(subproblem)","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"This formulation is slightly different. We have included a copy of the x variables, x_copy, and used x_copy in the left-hand side of the constraints.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Our function to solve the subproblem is also slightly different. First, we need to fix the value of the x_copy variables to the value of x from the first-stage problem, and second, we compute the dual using the reduced_cost of x_copy, not the dual of the linear constraints:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"function solve_subproblem(model, x)\n    fix.(model[:x_copy], x)\n    optimize!(model)\n    @assert is_solved_and_feasible(model; dual = true)\n    return (\n        obj = objective_value(model),\n        y = value.(model[:y]),\n        π = reduced_cost.(model[:x_copy]),\n    )\nend","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Now we're ready to iterate our in-place Benders decomposition, but this time the cut computation is slightly different. Because we used reduced_cost on the x_copy variables, the value of π is a valid subgradient on the objective of subproblem with respect to x. Therefore, we don't need to multiply the duals by -A_1, and so our cut uses ret.π' instead of -ret.π' * A_1:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"println(\"Iteration  Lower Bound  Upper Bound          Gap\")\nfor k in 1:MAXIMUM_ITERATIONS\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    lower_bound = objective_value(model)\n    x_k = value.(x)\n    ret = solve_subproblem(subproblem, x_k)\n    upper_bound = c_1' * x_k + ret.obj\n    gap = (upper_bound - lower_bound) / upper_bound\n    print_iteration(k, lower_bound, upper_bound, gap)\n    if gap < ABSOLUTE_OPTIMALITY_GAP\n        println(\"Terminating with the optimal solution\")\n        break\n    end\n    cut = @constraint(model, θ >= ret.obj + ret.π' * (x .- x_k))\n    @info \"Adding the cut $(cut)\"\nend","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"Finally, we can obtain the optimal solution:","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"optimize!(model)\n@assert is_solved_and_feasible(model)\nx_optimal = value.(x)","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"optimal_ret = solve_subproblem(subproblem, x_optimal)\ny_optimal = optimal_ret.y","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"For larger problems, the benefit of re-using the same subproblem and not needing to multiply the duals by A_1 in the cut coefficient usually outweights the cost of needing a copy of the x variables in the subproblem.","category":"page"},{"location":"tutorials/algorithms/benders_decomposition/","page":"Benders decomposition","title":"Benders decomposition","text":"As a secondary benefit, because we no longer need an explicit representation of A_1 in the cut, we can build the model and subproblem formulations using arbitrary JuMP syntax; they do not need to be in matrix form.","category":"page"},{"location":"tutorials/nonlinear/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"tutorials/nonlinear/introduction/","page":"Introduction","title":"Introduction","text":"Nonlinear programs (NLPs) are a class of optimization problems in which some of the constraints or the objective function are nonlinear:","category":"page"},{"location":"tutorials/nonlinear/introduction/","page":"Introduction","title":"Introduction","text":"beginalign\n    min_x in mathbbR^n  f_0(x) \n    textst  l_j le f_j(x) le u_j  j = 1 ldots m \n     l_i le x_i le u_i  i = 1 ldots n\nendalign","category":"page"},{"location":"tutorials/nonlinear/introduction/","page":"Introduction","title":"Introduction","text":"Mixed-integer nonlinear linear programs (MINLPs) are extensions of nonlinear programs in which some (or all) of the decision variables take discrete values.","category":"page"},{"location":"tutorials/nonlinear/introduction/#How-to-choose-a-solver","page":"Introduction","title":"How to choose a solver","text":"","category":"section"},{"location":"tutorials/nonlinear/introduction/","page":"Introduction","title":"Introduction","text":"JuMP supports a range of nonlinear solvers; look for \"NLP\" in the list of Supported solvers. However, very few solvers support mixed-integer nonlinear linear programs. Solvers supporting discrete variables start with \"(MI)\" in the list of Supported solvers.","category":"page"},{"location":"tutorials/nonlinear/introduction/","page":"Introduction","title":"Introduction","text":"If the only nonlinearities in your model are quadratic terms (that is, multiplication between two decision variables), you can also use second-order cone solvers, which are indicated by \"SOCP.\" In most cases, these solvers are restricted to convex quadratic problems and will error if you pass a nonconvex quadratic function; however, Gurobi has the ability to solve nonconvex quadratic terms.","category":"page"},{"location":"tutorials/nonlinear/introduction/#How-these-tutorials-are-structured","page":"Introduction","title":"How these tutorials are structured","text":"","category":"section"},{"location":"tutorials/nonlinear/introduction/","page":"Introduction","title":"Introduction","text":"Having a high-level overview of how this part of the documentation is structured will help you know where to look for certain things.","category":"page"},{"location":"tutorials/nonlinear/introduction/","page":"Introduction","title":"Introduction","text":"The following tutorials are worked examples that present a problem in words, then formulate it in mathematics, and then solve it in JuMP. This usually involves some sort of visualization of the solution. Start here if you are new to JuMP.\nRocket Control\nOptimal control for a Space Shuttle reentry trajectory\nPortfolio optimization\nThe Tips and tricks tutorial contains a number of helpful reformulations and tricks you can use when modeling nonlinear programs. Look here if you are stuck trying to formulate a problem as a nonlinear program.\nThe Computing Hessians is an advanced tutorial which explains how to compute the Hessian of the Lagrangian of a nonlinear program. This is useful only in particular cases.\nThe remaining tutorials are less verbose and styled in the form of short code examples. These tutorials have less explanation, but may contain useful code snippets, particularly if they are similar to a problem you are trying to solve.","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"EditURL = \"https://github.com/jump-dev/Pajarito.jl/blob/4c7efa915bdc900b51d1c8290dc771403b11230a/README.md\"","category":"page"},{"location":"packages/Pajarito/#Pajarito.jl","page":"jump-dev/Pajarito.jl","title":"Pajarito.jl","text":"","category":"section"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"Pajarito is a mixed-integer convex programming (MICP) solver package written in Julia.","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"MICP problems are convex except for restrictions that some variables take binary or integer values.","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"Pajarito solves MICP problems in conic form, by constructing sequential polyhedral outer approximations of the conic feasible set.","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"The underlying algorithm has theoretical finite-time convergence under reasonable assumptions.","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"Pajarito accesses state-of-the-art MILP solvers and continuous conic solvers through MathOptInterface.","category":"page"},{"location":"packages/Pajarito/#Pavito","page":"jump-dev/Pajarito.jl","title":"Pavito","text":"","category":"section"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"For algorithms that use a derivative-based nonlinear programming (NLP) solver (for example, Ipopt) instead of a conic solver, use Pavito.","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"Pavito is a convex mixed-integer nonlinear programming (convex MINLP) solver. Because Pavito relies on gradient cuts, it can fail near points of non-differentiability. Pajarito may be more robust than Pavito on non-smooth problems.","category":"page"},{"location":"packages/Pajarito/#License","page":"jump-dev/Pajarito.jl","title":"License","text":"","category":"section"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"Pajarito.jl is licensed under the MPL 2.0 license.","category":"page"},{"location":"packages/Pajarito/#Installation","page":"jump-dev/Pajarito.jl","title":"Installation","text":"","category":"section"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"Install Pajarito using Pkg.add:","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"import Pkg\nPkg.add(\"Pajarito\")","category":"page"},{"location":"packages/Pajarito/#MIP-and-continuous-solvers","page":"jump-dev/Pajarito.jl","title":"MIP and continuous solvers","text":"","category":"section"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"The algorithm implemented by Pajarito itself is relatively simple, and most of the hard work is performed by the MIP outer approximation (OA) solver and the continuous conic solver.","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"Therefore, in addition to installing Pajarito, you must also install a mixed-integer linear programming solver and a continuous conic solver.","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"The performance of Pajarito depends on these two types of solvers.","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"The OA solver (typically a mixed-integer linear solver) is specified by the oa_solver option. You must first load the Julia package that provides this solver, for example, using Gurobi. The continuous conic solver is specified by the conic_solver option.","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"See JuMP's list of supported solvers.","category":"page"},{"location":"packages/Pajarito/#Use-with-JuMP","page":"jump-dev/Pajarito.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"To use Pajarito with JuMP, use:","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"using JuMP, Pajarito, HiGHS, Hypatia\nmodel = Model(\n    optimizer_with_attributes(\n        Pajarito.Optimizer,\n        \"oa_solver\" => optimizer_with_attributes(\n            HiGHS.Optimizer,\n            MOI.Silent() => true,\n            \"mip_feasibility_tolerance\" => 1e-8,\n            \"mip_rel_gap\" => 1e-6,\n        ),\n        \"conic_solver\" =>\n            optimizer_with_attributes(Hypatia.Optimizer, MOI.Silent() => true),\n    )\n)\nset_attribute(model, \"time_limit\", 60)","category":"page"},{"location":"packages/Pajarito/#Options","page":"jump-dev/Pajarito.jl","title":"Options","text":"","category":"section"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"We list Pajarito's options below.","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"verbose::Bool toggles printing\ntol_feas::Float64 is the feasibility tolerance for conic constraints\ntol_rel_gap::Float64 is the relative optimality gap tolerance\ntol_abs_gap::Float64 is the absolute optimality gap tolerance\ntime_limit::Float64 sets the time limit (in seconds)\niteration_limit::Int sets the iteration limit (for the iterative method)\nuse_iterative_method::Union{Nothing,Bool} toggles the iterative algorithm; if nothing is specified, Pajarito defaults to the OA-solver-driven (single tree) algorithm if lazy callbacks are supported by the OA solver\nuse_extended_form::Bool toggles the use of extended formulations for the second-order cone\nsolve_relaxation::Bool toggles solution of the continuous conic relaxation\nsolve_subproblems::Bool toggles solution of the continuous conic subproblems\nuse_init_fixed_oa::Bool toggles initial fixed OA cuts\noa_solver::Union{Nothing,MOI.OptimizerWithAttributes} is the OA solver\nconic_solver::Union{Nothing,MOI.OptimizerWithAttributes} is the conic solver","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"Pajarito may require tuning of parameters to improve convergence.","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"For example, it often helps to tighten the OA solver's integrality tolerance. OA solver and conic solver options must be specified directly to those solvers.","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"Note: if solve_subproblems is true, Pajarito usually returns a solution constructed from one of the conic solver's feasible solutions; since the conic solver is not subject to the same feasibility tolerances as the OA solver, Pajarito's solution will not necessarily satisfy tol_feas.","category":"page"},{"location":"packages/Pajarito/#Cone-interface","page":"jump-dev/Pajarito.jl","title":"Cone interface","text":"","category":"section"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"Pajarito has a generic cone interface (see the cones folder that allows the user to add support for new convex cones.","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"To illustrate, in the experimental package PajaritoExtras we have extended Pajarito by adding support for several cones recognized by Hypatia.jl (a continuous conic solver with its own generic cone interface).","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"The examples folder of PajaritoExtras also contains many applied mixed-integer convex problems that are solved using Pajarito.","category":"page"},{"location":"packages/Pajarito/#Bug-reports-and-support","page":"jump-dev/Pajarito.jl","title":"Bug reports and support","text":"","category":"section"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"Please report any issues via the GitHub issue tracker.","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"All types of issues are welcome and encouraged; this includes bug reports, documentation typos, and feature requests. The Optimization (Mathematical) category on Discourse is appropriate for general discussion.","category":"page"},{"location":"packages/Pajarito/#References","page":"jump-dev/Pajarito.jl","title":"References","text":"","category":"section"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"If you find Pajarito useful in your work, we kindly request that you cite the following paper (arXiv preprint), which is recommended reading for advanced users:","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"@article{CoeyLubinVielma2020,\n    title={Outer approximation with conic certificates for mixed-integer convex problems},\n    author={Coey, Chris and Lubin, Miles and Vielma, Juan Pablo},\n    journal={Mathematical Programming Computation},\n    volume={12},\n    number={2},\n    pages={249--293},\n    year={2020},\n    publisher={Springer}\n}","category":"page"},{"location":"packages/Pajarito/","page":"jump-dev/Pajarito.jl","title":"jump-dev/Pajarito.jl","text":"Note this paper describes a legacy MathProgBase version of Pajarito, which is available on the mathprogbase branch of this repository. Starting with version v0.8.0, Pajarito supports MathOptInterface instead of MathProgBase.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/manual/models.md\"","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"The most significant part of MOI is the definition of the model API that is used to specify an instance of an optimization problem (for example, by adding variables and constraints). Objects that implement the model API must inherit from the ModelLike abstract type.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"Notably missing from the model API is the method to solve an optimization problem. ModelLike objects may store an instance (for example, in memory or backed by a file format) without being linked to a particular solver. In addition to the model API, MOI defines AbstractOptimizer and provides methods to solve the model and interact with solutions. See the Solutions section for more details.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"info: Info\nThroughout the rest of the manual, model is used as a generic ModelLike, and optimizer is used as a generic AbstractOptimizer.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"tip: Tip\nMOI does not export functions, but for brevity we often omit qualifying names with the MOI module. Best practice is to haveimport MathOptInterface as MOIand prefix all MOI methods with MOI. in user code. If a name is also available in base Julia, we always explicitly use the module prefix, for example, with MOI.get.","category":"page"},{"location":"moi/manual/models/#Attributes","page":"Models","title":"Attributes","text":"","category":"section"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"Attributes are properties of the model that can be queried and modified. These include constants such as the number of variables in a model NumberOfVariables), and properties of variables and constraints such as the name of a variable (VariableName).","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"There are four types of attributes:","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"Model attributes (subtypes of AbstractModelAttribute) refer to properties of a model.\nOptimizer attributes (subtypes of AbstractOptimizerAttribute) refer to properties of an optimizer.\nConstraint attributes (subtypes of AbstractConstraintAttribute) refer to properties of an individual constraint.\nVariable attributes (subtypes of AbstractVariableAttribute) refer to properties of an individual variable.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"Some attributes are values that can be queried by the user but not modified, while other attributes can be modified by the user.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"All interactions with attributes occur through the get and set functions.","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"Consult the docstrings of each attribute for information on what it represents.","category":"page"},{"location":"moi/manual/models/#ModelLike-API","page":"Models","title":"ModelLike API","text":"","category":"section"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"The following attributes are available:","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"ListOfConstraintAttributesSet\nListOfConstraintIndices\nListOfConstraintTypesPresent\nListOfConstraintsWithAttributeSet\nListOfModelAttributesSet\nListOfVariableAttributesSet\nListOfVariableIndices\nListOfVariablesWithAttributeSet\nNumberOfConstraints\nNumberOfVariables\nName\nObjectiveFunction\nObjectiveFunctionType\nObjectiveSense","category":"page"},{"location":"moi/manual/models/#AbstractOptimizer-API","page":"Models","title":"AbstractOptimizer API","text":"","category":"section"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"The following attributes are available:","category":"page"},{"location":"moi/manual/models/","page":"Models","title":"Models","text":"DualStatus\nPrimalStatus\nRawStatusString\nResultCount\nTerminationStatus\nBarrierIterations\nDualObjectiveValue\nNodeCount\nNumberOfThreads\nObjectiveBound\nObjectiveValue\nRelativeGap\nRawOptimizerAttribute\nRawSolver\nSilent\nSimplexIterations\nSolverName\nSolverVersion\nSolveTimeSec\nTimeLimitSec\nObjectiveLimit\nSolutionLimit\nAutomaticDifferentiationBackend","category":"page"},{"location":"packages/NLopt/#NLopt.jl","page":"JuliaOpt/NLopt.jl","title":"NLopt.jl","text":"","category":"section"},{"location":"packages/NLopt/","page":"JuliaOpt/NLopt.jl","title":"JuliaOpt/NLopt.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/NLopt/","page":"JuliaOpt/NLopt.jl","title":"JuliaOpt/NLopt.jl","text":"NLopt.jl is a wrapper for the NLopt library.","category":"page"},{"location":"packages/NLopt/#License","page":"JuliaOpt/NLopt.jl","title":"License","text":"","category":"section"},{"location":"packages/NLopt/","page":"JuliaOpt/NLopt.jl","title":"JuliaOpt/NLopt.jl","text":"NLopt.jl is licensed under the MIT License.","category":"page"},{"location":"packages/NLopt/","page":"JuliaOpt/NLopt.jl","title":"JuliaOpt/NLopt.jl","text":"The underlying solver, stevengj/nlopt, is licensed under the LGPL v3.0 license.","category":"page"},{"location":"packages/NLopt/#Installation","page":"JuliaOpt/NLopt.jl","title":"Installation","text":"","category":"section"},{"location":"packages/NLopt/","page":"JuliaOpt/NLopt.jl","title":"JuliaOpt/NLopt.jl","text":"Install NLopt.jl using the Julia package manager:","category":"page"},{"location":"packages/NLopt/","page":"JuliaOpt/NLopt.jl","title":"JuliaOpt/NLopt.jl","text":"import Pkg\nPkg.add(\"NLopt\")","category":"page"},{"location":"packages/NLopt/","page":"JuliaOpt/NLopt.jl","title":"JuliaOpt/NLopt.jl","text":"In addition to installing the NLopt.jl package, this will also download and install the NLopt binaries. You do not need to install NLopt separately.","category":"page"},{"location":"packages/NLopt/#Use-with-JuMP","page":"JuliaOpt/NLopt.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/NLopt/","page":"JuliaOpt/NLopt.jl","title":"JuliaOpt/NLopt.jl","text":"You can use NLopt with JuMP as follows:","category":"page"},{"location":"packages/NLopt/","page":"JuliaOpt/NLopt.jl","title":"JuliaOpt/NLopt.jl","text":"using JuMP, NLopt\nmodel = Model(NLopt.Optimizer)\nset_attribute(model, \"algorithm\", :LD_MMA)","category":"page"},{"location":"packages/NLopt/#Options","page":"JuliaOpt/NLopt.jl","title":"Options","text":"","category":"section"},{"location":"packages/NLopt/","page":"JuliaOpt/NLopt.jl","title":"JuliaOpt/NLopt.jl","text":"The algorithm attribute is required. The value must be one of the supported NLopt algorithms.","category":"page"},{"location":"packages/NLopt/#Documentation","page":"JuliaOpt/NLopt.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/NLopt/","page":"JuliaOpt/NLopt.jl","title":"JuliaOpt/NLopt.jl","text":"For more details, see the NLopt.jl README or the NLopt documentation.","category":"page"},{"location":"tutorials/linear/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"tutorials/linear/introduction/","page":"Introduction","title":"Introduction","text":"Linear programs (LPs) are a fundamental class of optimization problems of the form:","category":"page"},{"location":"tutorials/linear/introduction/","page":"Introduction","title":"Introduction","text":"beginalign\n    min_x in mathbbR^n  sumlimits_i=1^n c_i x_i \n    textst  l_j le sumlimits_i=1^n a_ij x_i le u_j  j = 1 ldots m \n     l_i le x_i le u_i  i = 1 ldots n\nendalign","category":"page"},{"location":"tutorials/linear/introduction/","page":"Introduction","title":"Introduction","text":"The most important thing to note is that all terms are of the form coefficient * variable, and that there are no nonlinear terms or multiplications between variables.","category":"page"},{"location":"tutorials/linear/introduction/","page":"Introduction","title":"Introduction","text":"Mixed-integer linear programs (MILPs) are extensions of linear programs in which some (or all) of the decision variables take discrete values.","category":"page"},{"location":"tutorials/linear/introduction/#How-to-choose-a-solver","page":"Introduction","title":"How to choose a solver","text":"","category":"section"},{"location":"tutorials/linear/introduction/","page":"Introduction","title":"Introduction","text":"Almost all solvers support linear programs; look for \"LP\" in the list of Supported solvers. However, fewer solvers support mixed-integer linear programs. Solvers supporting discrete variables start with \"(MI)\" in the list of Supported solvers.","category":"page"},{"location":"tutorials/linear/introduction/#How-these-tutorials-are-structured","page":"Introduction","title":"How these tutorials are structured","text":"","category":"section"},{"location":"tutorials/linear/introduction/","page":"Introduction","title":"Introduction","text":"Having a high-level overview of how this part of the documentation is structured will help you know where to look for certain things.","category":"page"},{"location":"tutorials/linear/introduction/","page":"Introduction","title":"Introduction","text":"The following tutorials are worked examples that present a problem in words, then formulate it in mathematics, and then solve it in JuMP. This usually involves some sort of visualization of the solution. Start here if you are new to JuMP.\nThe diet problem\nThe cannery problem\nThe facility location problem\nFinancial modeling problems\nNetwork flow problems\nN-Queens\nSudoku\nThe Tips and tricks tutorial contains a number of helpful reformulations and tricks you can use when modeling linear programs. Look here if you are stuck trying to formulate a problem as a linear program.\nThe Sensitivity analysis of a linear program tutorial explains how to create sensitivity reports like those produced by the Excel Solver.\nThe Callbacks tutorial explains how to write a variety of solver-independent callbacks. Look here if you want to write a callback.\nThe remaining tutorials are less verbose and styled in the form of short code examples. These tutorials have less explanation, but may contain useful code snippets, particularly if they are similar to a problem you are trying to solve.","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"EditURL = \"tips_and_tricks.jl\"","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/#nonlinear_tips_and_tricks","page":"Tips and tricks","title":"Tips and tricks","text":"","category":"section"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This example collates some tips and tricks you can use when formulating nonlinear programs. It uses the following packages:","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"using JuMP\nimport Ipopt\nimport Test","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/#User-defined-operators-with-vector-outputs","page":"Tips and tricks","title":"User-defined operators with vector outputs","text":"","category":"section"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A common situation is to have a user-defined operator like the following that returns multiple outputs (we define function_calls to keep track of how many times we call this method):","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"function_calls = 0\nfunction foo(x, y)\n    global function_calls += 1\n    common_term = x^2 + y^2\n    term_1 = sqrt(1 + common_term)\n    term_2 = common_term\n    return term_1, term_2\nend","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"For example, the first term might be used in the objective, and the second term might be used in a constraint, and often they share work that is expensive to evaluate.","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This is a problem for JuMP, because it requires user-defined operators to return a single number. One option is to define two separate functions, the first returning the first argument, and the second returning the second argument.","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"foo_1(x, y) = foo(x, y)[1]\nfoo_2(x, y) = foo(x, y)[2]","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"However, if the common term is expensive to compute, this approach is wasteful because it will evaluate the expensive term twice. Let's have a look at how many times we evaluate x^2 + y^2 during a solve:","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, x[1:2] >= 0, start = 0.1)\n@operator(model, op_foo_1, 2, foo_1)\n@operator(model, op_foo_2, 2, foo_2)\n@objective(model, Max, op_foo_1(x[1], x[2]))\n@constraint(model, op_foo_2(x[1], x[2]) <= 2)\nfunction_calls = 0\noptimize!(model)\n@assert is_solved_and_feasible(model)\nTest.@test objective_value(model) ≈ √3 atol = 1e-4\nTest.@test value.(x) ≈ [1.0, 1.0] atol = 1e-4\nprintln(\"Naive approach: function calls = $(function_calls)\")","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"An alternative approach is to use memoization, which uses a cache to store the result of function evaluations. We can write a memoization function as follows:","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"\"\"\"\n    memoize(foo::Function, n_outputs::Int)\n\nTake a function `foo` and return a vector of length `n_outputs`, where element\n`i` is a function that returns the equivalent of `foo(x...)[i]`.\n\nTo avoid duplication of work, cache the most-recent evaluations of `foo`.\nBecause `foo_i` is auto-differentiated with ForwardDiff, our cache needs to\nwork when `x` is a `Float64` and a `ForwardDiff.Dual`.\n\"\"\"\nfunction memoize(foo::Function, n_outputs::Int)\n    last_x, last_f = nothing, nothing\n    last_dx, last_dfdx = nothing, nothing\n    function foo_i(i, x::T...) where {T<:Real}\n        if T == Float64\n            if x !== last_x\n                last_x, last_f = x, foo(x...)\n            end\n            return last_f[i]::T\n        else\n            if x !== last_dx\n                last_dx, last_dfdx = x, foo(x...)\n            end\n            return last_dfdx[i]::T\n        end\n    end\n    return [(x...) -> foo_i(i, x...) for i in 1:n_outputs]\nend","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Let's see how it works. First, construct the memoized versions of foo:","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"memoized_foo = memoize(foo, 2)","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Now try evaluating the first element of memoized_foo.","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"function_calls = 0\nmemoized_foo[1](1.0, 1.0)\nprintln(\"function_calls = \", function_calls)","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"As expected, this evaluated the function once. However, if we call the function again, we hit the cache instead of needing to re-compute foo and function_calls is still 1!","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"memoized_foo[1](1.0, 1.0)\nprintln(\"function_calls = \", function_calls)","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Now let's see how this works during a real solve:","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, x[1:2] >= 0, start = 0.1)\n@operator(model, op_foo_1, 2, memoized_foo[1])\n@operator(model, op_foo_2, 2, memoized_foo[2])\n@objective(model, Max, op_foo_1(x[1], x[2]))\n@constraint(model, op_foo_2(x[1], x[2]) <= 2)\nfunction_calls = 0\noptimize!(model)\n@assert is_solved_and_feasible(model)\nTest.@test objective_value(model) ≈ √3 atol = 1e-4\nTest.@test value.(x) ≈ [1.0, 1.0] atol = 1e-4\nprintln(\"Memoized approach: function_calls = $(function_calls)\")","category":"page"},{"location":"tutorials/nonlinear/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Compared to the naive approach, the memoized approach requires half as many function evaluations.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"EditURL = \"rocket_control.jl\"","category":"page"},{"location":"tutorials/nonlinear/rocket_control/#Rocket-Control","page":"Rocket Control","title":"Rocket Control","text":"","category":"section"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"This tutorial was originally contributed by Iain Dunning.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"The purpose of this tutorial is to demonstrate how to setup and solve a nonlinear optimization problem.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"The example is an optimal control problem of a nonlinear rocket.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"info: Info\nThe JuMP extension InfiniteOpt.jl can also be used to model and solve optimal control problems.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"using JuMP\nimport Ipopt\nimport Plots","category":"page"},{"location":"tutorials/nonlinear/rocket_control/#Overview","page":"Rocket Control","title":"Overview","text":"","category":"section"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Our goal is to maximize the final altitude of a vertically launched rocket.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We can control the thrust of the rocket, and must take account of the rocket mass, fuel consumption rate, gravity, and aerodynamic drag.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Let us consider the basic description of the model (for the full description, including parameters for the rocket, see COPS3).","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"There are three state variables in our model:","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Velocity: x_v(t)\nAltitude: x_h(t)\nMass of rocket and remaining fuel, x_m(t)","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"and a single control variable:","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Thrust: u_t(t).","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"There are three equations that control the dynamics of the rocket:","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Rate of ascent: fracd x_hdt = x_v\nAcceleration: fracd x_vdt = fracu_t - D(x_h x_v)x_m - g(x_h)\nRate of mass loss: fracd x_mdt = -fracu_tc","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"where drag D(x_h x_v) is a function of altitude and velocity, gravity g(x_h) is a function of altitude, and c is a constant.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"These forces are defined as:","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"D(x_h x_v) = D_c cdot x_v^2 cdot e^-h_c left( fracx_h-x_h(0)x_h(0) right)","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"and g(x_h) = g_0 cdot left( fracx_h(0)x_h right)^2","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We use a discretized model of time, with a fixed number of time steps, T.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Our goal is thus to maximize x_h(T).","category":"page"},{"location":"tutorials/nonlinear/rocket_control/#Data","page":"Rocket Control","title":"Data","text":"","category":"section"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"All parameters in this model have been normalized to be dimensionless, and they are taken from COPS3.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"h_0 = 1                      # Initial height\nv_0 = 0                      # Initial velocity\nm_0 = 1.0                    # Initial mass\nm_T = 0.6                    # Final mass\ng_0 = 1                      # Gravity at the surface\nh_c = 500                    # Used for drag\nc = 0.5 * sqrt(g_0 * h_0)    # Thrust-to-fuel mass\nD_c = 0.5 * 620 * m_0 / g_0  # Drag scaling\nu_t_max = 3.5 * g_0 * m_0    # Maximum thrust\nT_max = 0.2                  # Number of seconds\nT = 1_000                    # Number of time steps\nΔt = 0.2 / T;                # Time per discretized step\nnothing #hide","category":"page"},{"location":"tutorials/nonlinear/rocket_control/#JuMP-formulation","page":"Rocket Control","title":"JuMP formulation","text":"","category":"section"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"First, we create a model and choose an optimizer. Since this is a nonlinear program, we need to use a nonlinear solver like Ipopt. We cannot use a linear solver like HiGHS.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"model = Model(Ipopt.Optimizer)\nset_silent(model)","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Next, we create our state and control variables, which are each indexed by t. It is good practice for nonlinear programs to always provide a starting solution for each variable.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"@variable(model, x_v[1:T] >= 0, start = v_0)           # Velocity\n@variable(model, x_h[1:T] >= 0, start = h_0)           # Height\n@variable(model, x_m[1:T] >= m_T, start = m_0)         # Mass\n@variable(model, 0 <= u_t[1:T] <= u_t_max, start = 0); # Thrust\nnothing #hide","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We implement boundary conditions by fixing variables to values.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"fix(x_v[1], v_0; force = true)\nfix(x_h[1], h_0; force = true)\nfix(x_m[1], m_0; force = true)\nfix(u_t[T], 0.0; force = true)","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"The objective is to maximize altitude at end of time of flight.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"@objective(model, Max, x_h[T])","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Forces are defined as functions:","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"D(x_h, x_v) = D_c * x_v^2 * exp(-h_c * (x_h - h_0) / h_0)\ng(x_h) = g_0 * (h_0 / x_h)^2","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"The dynamical equations are implemented as constraints.","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"ddt(x::Vector, t::Int) = (x[t] - x[t-1]) / Δt\n@constraint(model, [t in 2:T], ddt(x_h, t) == x_v[t-1])\n@constraint(\n    model,\n    [t in 2:T],\n    ddt(x_v, t) == (u_t[t-1] - D(x_h[t-1], x_v[t-1])) / x_m[t-1] - g(x_h[t-1]),\n)\n@constraint(model, [t in 2:T], ddt(x_m, t) == -u_t[t-1] / c);\nnothing #hide","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Now we optimize the model and check that we found a solution:","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"optimize!(model)\n@assert is_solved_and_feasible(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Finally, we plot the solution:","category":"page"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"function plot_trajectory(y; kwargs...)\n    return Plots.plot(\n        (1:T) * Δt,\n        value.(y);\n        xlabel = \"Time (s)\",\n        legend = false,\n        kwargs...,\n    )\nend\n\nPlots.plot(\n    plot_trajectory(x_h; ylabel = \"Altitude\"),\n    plot_trajectory(x_m; ylabel = \"Mass\"),\n    plot_trajectory(x_v; ylabel = \"Velocity\"),\n    plot_trajectory(u_t; ylabel = \"Thrust\");\n    layout = (2, 2),\n)","category":"page"},{"location":"tutorials/nonlinear/rocket_control/#Next-steps","page":"Rocket Control","title":"Next steps","text":"","category":"section"},{"location":"tutorials/nonlinear/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Experiment with different values for the constants. How does the solution change? In particular, what happens if you change T_max?\nThe dynamical equations use rectangular integration for the right-hand side terms. Modify the equations to use the Trapezoidal rule instead. (As an example, x_v[t-1] would become 0.5 * (x_v[t-1] + x_v[t]).) Is there a difference?","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"EditURL = \"querying_hessians.jl\"","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/#Computing-Hessians","page":"Computing Hessians","title":"Computing Hessians","text":"","category":"section"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"The purpose of this tutorial is to demonstrate how to compute the Hessian of the Lagrangian of a nonlinear program.","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"warning: Warning\nThis is an advanced tutorial that interacts with the low-level nonlinear interface of MathOptInterface.By default, JuMP exports the MOI symbol as an alias for the MathOptInterface.jl package. We recommend making this more explicit in your code by adding the following lines:import MathOptInterface as MOI","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Given a nonlinear program:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"beginalign\n min_x in mathbbR^n  f(x) \n textst  l le g_i(x) le u\nendalign","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"the Hessian of the Lagrangian is computed as:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"H(x sigma mu) = sigmanabla^2 f(x) + sum_i=1^m mu_i nabla^2 g_i(x)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"where x is a primal point, sigma is a scalar (typically 1), and mu is a vector of weights corresponding to the Lagrangian dual of the constraints.","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"using JuMP\nimport Ipopt\nimport LinearAlgebra\nimport Random\nimport SparseArrays","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/#The-basic-model","page":"Computing Hessians","title":"The basic model","text":"","category":"section"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"To demonstrate how to interact with the lower-level nonlinear interface, we need an example model. The exact model isn't important; we use the model from The Rosenbrock function tutorial, with some additional constraints to demonstrate various features of the lower-level interface.","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"model = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, x[i = 1:2], start = -i)\n@constraint(model, g_1, x[1]^2 <= 1)\n@constraint(model, g_2, (x[1] + x[2])^2 <= 2)\n@objective(model, Min, (1 - x[1])^2 + 100 * (x[2] - x[1]^2)^2)\noptimize!(model)\n@assert is_solved_and_feasible(model)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/#The-analytic-solution","page":"Computing Hessians","title":"The analytic solution","text":"","category":"section"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"With a little work, it is possible to analytically derive the correct hessian:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"function analytic_hessian(x, σ, μ)\n    g_1_H = [2.0 0.0; 0.0 0.0]\n    g_2_H = [2.0 2.0; 2.0 2.0]\n    f_H = zeros(2, 2)\n    f_H[1, 1] = 2.0 + 1200.0 * x[1]^2 - 400.0 * x[2]\n    f_H[1, 2] = f_H[2, 1] = -400.0 * x[1]\n    f_H[2, 2] = 200.0\n    return σ * f_H + μ' * [g_1_H, g_2_H]\nend","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Here are various points:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"analytic_hessian([1, 1], 0, [0, 0])","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"analytic_hessian([1, 1], 0, [1, 0])","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"analytic_hessian([1, 1], 0, [0, 1])","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"analytic_hessian([1, 1], 1, [0, 0])","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/#Create-a-nonlinear-model","page":"Computing Hessians","title":"Create a nonlinear model","text":"","category":"section"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"JuMP delegates automatic differentiation to the MOI.Nonlinear submodule. Therefore, to compute the Hessian of the Lagrangian, we need to create a MOI.Nonlinear.Model object:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"rows = Any[]\nnlp = MOI.Nonlinear.Model()\nfor (F, S) in list_of_constraint_types(model)\n    if F <: VariableRef\n        continue  # Skip variable bounds\n    end\n    for ci in all_constraints(model, F, S)\n        push!(rows, ci)\n        object = constraint_object(ci)\n        MOI.Nonlinear.add_constraint(nlp, object.func, object.set)\n    end\nend\nMOI.Nonlinear.set_objective(nlp, objective_function(model))\nnlp","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"It is important that we save the constraint indices in a vector rows, so that we know the order of the constraints in the nonlinear model.","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Next, we need to convert our model into an MOI.Nonlinear.Evaluator, specifying an automatic differentiation backend. In this case, we use MOI.Nonlinear.SparseReverseMode:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"evaluator = MOI.Nonlinear.Evaluator(\n    nlp,\n    MOI.Nonlinear.SparseReverseMode(),\n    index.(all_variables(model)),\n)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Before computing anything with the evaluator, we need to initialize it. Use MOI.features_available to see what we can query:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"MOI.features_available(evaluator)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Consult the MOI documentation for specifics, but to obtain the Hessian matrix, we need to initialize :Hess:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"MOI.initialize(evaluator, [:Hess])","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"MOI represents the Hessian as a sparse matrix. Get the sparsity pattern as follows:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"hessian_sparsity = MOI.hessian_lagrangian_structure(evaluator)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"The sparsity pattern has a few properties of interest:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Each element (i, j) indicates a structural non-zero in row i and column j\nThe list may contain duplicates, in which case we should add the values together\nThe list does not need to be sorted\nThe list may contain any mix of lower- or upper-triangular indices","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"This format matches Julia's sparse-triplet form of a SparseArray, so we can convert from the sparse Hessian representation to a Julia SparseArray as follows:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"I = [i for (i, _) in hessian_sparsity]\nJ = [j for (_, j) in hessian_sparsity]\nV = zeros(length(hessian_sparsity))\nn = num_variables(model)\nH = SparseArrays.sparse(I, J, V, n, n)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Of course, knowing where the zeros are isn't very interesting. We really want to compute the value of the Hessian matrix at a point.","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"MOI.eval_hessian_lagrangian(evaluator, V, ones(n), 1.0, ones(length(rows)))\nH = SparseArrays.sparse(I, J, V, n, n)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"In practice, we often want to compute the value of the hessian at the optimal solution.","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"First, we compute the primal solution. To do so, we need a vector of the variables in the order that they were passed to the solver:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"x = all_variables(model)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Here x[1] is the variable that corresponds to column 1, and so on. Here's the optimal primal solution:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"x_optimal = value.(x)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Next, we need the optimal dual solution associated with the nonlinear constraints (this is where it is important to record the order of the constraints as we added them to nlp):","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"y_optimal = dual.(rows)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Now we can compute the Hessian at the optimal primal-dual point:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"MOI.eval_hessian_lagrangian(evaluator, V, x_optimal, 1.0, y_optimal)\nH = SparseArrays.sparse(I, J, V, n, n)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"However, this Hessian isn't quite right because it isn't symmetric. We can fix this by filling in the appropriate off-diagonal terms:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"function fill_off_diagonal(H)\n    ret = H + H'\n    row_vals = SparseArrays.rowvals(ret)\n    non_zeros = SparseArrays.nonzeros(ret)\n    for col in 1:size(ret, 2)\n        for i in SparseArrays.nzrange(ret, col)\n            if col == row_vals[i]\n                non_zeros[i] /= 2\n            end\n        end\n    end\n    return ret\nend\n\nfill_off_diagonal(H)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"Putting everything together:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"function compute_optimal_hessian(model::Model)\n    rows = Any[]\n    nlp = MOI.Nonlinear.Model()\n    for (F, S) in list_of_constraint_types(model)\n        for ci in all_constraints(model, F, S)\n            push!(rows, ci)\n            object = constraint_object(ci)\n            MOI.Nonlinear.add_constraint(nlp, object.func, object.set)\n        end\n    end\n    MOI.Nonlinear.set_objective(nlp, objective_function(model))\n    x = all_variables(model)\n    backend = MOI.Nonlinear.SparseReverseMode()\n    evaluator = MOI.Nonlinear.Evaluator(nlp, backend, index.(x))\n    MOI.initialize(evaluator, [:Hess])\n    hessian_sparsity = MOI.hessian_lagrangian_structure(evaluator)\n    I = [i for (i, _) in hessian_sparsity]\n    J = [j for (_, j) in hessian_sparsity]\n    V = zeros(length(hessian_sparsity))\n    MOI.eval_hessian_lagrangian(evaluator, V, value.(x), 1.0, dual.(rows))\n    H = SparseArrays.sparse(I, J, V, length(x), length(x))\n    return Matrix(fill_off_diagonal(H))\nend\n\nH_star = compute_optimal_hessian(model)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"If we compare our solution against the analytical solution:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"analytic_hessian(value.(x), 1.0, dual.([g_1, g_2]))","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"If we look at the eigenvalues of the Hessian:","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"LinearAlgebra.eigvals(H_star)","category":"page"},{"location":"tutorials/nonlinear/querying_hessians/","page":"Computing Hessians","title":"Computing Hessians","text":"we see that they are all positive. Therefore, the Hessian is positive definite, and so the solution found by Ipopt is a local minimizer.","category":"page"},{"location":"packages/SumOfSquares/","page":"jump-dev/SumOfSquares.jl","title":"jump-dev/SumOfSquares.jl","text":"EditURL = \"https://github.com/jump-dev/SumOfSquares.jl/blob/v0.7.3/README.md\"","category":"page"},{"location":"packages/SumOfSquares/#SumOfSquares.jl","page":"jump-dev/SumOfSquares.jl","title":"SumOfSquares.jl","text":"","category":"section"},{"location":"packages/SumOfSquares/","page":"jump-dev/SumOfSquares.jl","title":"jump-dev/SumOfSquares.jl","text":"(Image: Build Status) (Image: codecov) (Image: )","category":"page"},{"location":"packages/SumOfSquares/","page":"jump-dev/SumOfSquares.jl","title":"jump-dev/SumOfSquares.jl","text":"SumOfSquares.jl is a JuMP extension that, when used in conjunction with MultivariatePolynomial and PolyJuMP, implements a sum of squares reformulation for polynomial optimization.","category":"page"},{"location":"packages/SumOfSquares/#License","page":"jump-dev/SumOfSquares.jl","title":"License","text":"","category":"section"},{"location":"packages/SumOfSquares/","page":"jump-dev/SumOfSquares.jl","title":"jump-dev/SumOfSquares.jl","text":"SumOfSquares.jl is licensed under the MIT license.","category":"page"},{"location":"packages/SumOfSquares/#Installation","page":"jump-dev/SumOfSquares.jl","title":"Installation","text":"","category":"section"},{"location":"packages/SumOfSquares/","page":"jump-dev/SumOfSquares.jl","title":"jump-dev/SumOfSquares.jl","text":"Install SumOfSquares using Pkg.add:","category":"page"},{"location":"packages/SumOfSquares/","page":"jump-dev/SumOfSquares.jl","title":"jump-dev/SumOfSquares.jl","text":"import Pkg\nPkg.add(\"SumOfSquares\")","category":"page"},{"location":"packages/SumOfSquares/#Documentation","page":"jump-dev/SumOfSquares.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/SumOfSquares/","page":"jump-dev/SumOfSquares.jl","title":"jump-dev/SumOfSquares.jl","text":"See https://jump.dev/SumOfSquares.jl/stable for the most recently tagged version of the documentation.","category":"page"},{"location":"packages/SumOfSquares/","page":"jump-dev/SumOfSquares.jl","title":"jump-dev/SumOfSquares.jl","text":"See https://jump.dev/SumOfSquares.jl/dev for the in-development version of the documentation.","category":"page"},{"location":"packages/SumOfSquares/#Presentations","page":"jump-dev/SumOfSquares.jl","title":"Presentations","text":"","category":"section"},{"location":"packages/SumOfSquares/","page":"jump-dev/SumOfSquares.jl","title":"jump-dev/SumOfSquares.jl","text":"Some presentations on, or using, SumOfSquares (see blegat/SumOfSquaresSlides for the source code of the presentations):","category":"page"},{"location":"packages/SumOfSquares/","page":"jump-dev/SumOfSquares.jl","title":"jump-dev/SumOfSquares.jl","text":"Benoît Legat at JuMP-dev 2023 [Slides]\nBenoît Legat, Marek Kaluba and Tillmann Weisser at INFORMS 2022 [Slides]\nBenoît Legat at POEMA Learning Week 2\nBenoît Legat, Marek Kaluba and Tillmann Weisser at JuMP-dev 2021 [Slides]\nBenoît Legat at INFORMS 2020 [Slides]\nTillmann Weisser, Benoît Legat, Chris Coey, Lea Kapelevich and Juan Pablo Vielma at JuliaCon 2019 [Slides] [Video]\nBenoît Legat at CNLS 2019 [Slides]\nBenoît Legat at EURO 2019 [Slides]\nBenoît Legat at juliaday Nantes 2019 [Slides]\nBenoît Legat at Summer School on Numerical Computing in Algebraic Geometry 2018 [Poster]\nBenoît Legat at The First Annual JuMP-dev Workshop 2017 [Slides] [Video]\nJoey Huchette at SIAM Opt 2017","category":"page"},{"location":"packages/SumOfSquares/#Citing","page":"jump-dev/SumOfSquares.jl","title":"Citing","text":"","category":"section"},{"location":"packages/SumOfSquares/","page":"jump-dev/SumOfSquares.jl","title":"jump-dev/SumOfSquares.jl","text":"See CITATION.bib.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"EditURL = \"cutting_stock_column_generation.jl\"","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/#Column-generation","page":"Column generation","title":"Column generation","text":"","category":"section"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"The purpose of this tutorial is to demonstrate the column generation algorithm. As an example, it solves the Cutting stock problem.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"using JuMP\nimport DataFrames\nimport HiGHS\nimport Plots\nimport SparseArrays","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/#Background","page":"Column generation","title":"Background","text":"","category":"section"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"The cutting stock problem is about cutting large rolls of paper into smaller pieces.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"We denote the set of possible sized pieces that a roll can be cut into by iin 1ldotsI. Each piece i has a width, w_i, and a demand, d_i. The width of the large roll is W.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Our objective is to minimize the number of rolls needed to meet all demand.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Here's the data that we are going to use in this tutorial:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"struct Piece\n    w::Float64\n    d::Int\nend\n\nstruct Data\n    pieces::Vector{Piece}\n    W::Float64\nend\n\nfunction Base.show(io::IO, d::Data)\n    println(io, \"Data for the cutting stock problem:\")\n    println(io, \"  W = $(d.W)\")\n    println(io, \"with pieces:\")\n    println(io, \"   i   w_i d_i\")\n    println(io, \"  ------------\")\n    for (i, p) in enumerate(d.pieces)\n        println(io, lpad(i, 4), \" \", lpad(p.w, 5), \" \", lpad(p.d, 3))\n    end\n    return\nend\n\nfunction get_data()\n    data = [\n        75.0 38\n        75.0 44\n        75.0 30\n        75.0 41\n        75.0 36\n        53.8 33\n        53.0 36\n        51.0 41\n        50.2 35\n        32.2 37\n        30.8 44\n        29.8 49\n        20.1 37\n        16.2 36\n        14.5 42\n        11.0 33\n        8.6 47\n        8.2 35\n        6.6 49\n        5.1 42\n    ]\n    return Data([Piece(data[i, 1], data[i, 2]) for i in axes(data, 1)], 100.0)\nend\n\ndata = get_data()","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/#Mathematical-formulation","page":"Column generation","title":"Mathematical formulation","text":"","category":"section"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"To formulate the cutting stock problem as a mixed-integer linear program, we assume that there is a set of large rolls j=1ldotsJ to use. Then, we introduce two classes of decision variables:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"x_ij ge 0 textinteger  forall i=1ldotsI j=1ldotsJ\ny_j in 0 1 forall j=1ldotsJ","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"y_j is a binary variable that indicates if we use roll j, and x_ij counts how many pieces of size i that we cut from roll j.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Our mixed-integer linear program is therefore:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"beginalign\n    min  sumlimits_j=1^J y_j \n    textst  sumlimits_i=1^N w_i x_ij le W y_j  forall j=1ldotsJ \n          sumlimits_j=1^J x_ij ge d_i  forall i=1ldotsI \n          x_ij ge 0  forall i=1ldotsN j=1ldotsJ \n          x_ij in mathbbZ  forall i=1ldotsI j=1ldotsJ \n          y_j in 0 1  forall j=1ldotsJ \nendalign","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"The objective is to minimize the number of rolls that we use, and the two constraints ensure that we respect the total width of each large roll and that we satisfy demand exactly.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"The JuMP formulation of this model is:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"I = length(data.pieces)\nJ = 1_000  # Some large number\nmodel = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, x[1:I, 1:J] >= 0, Int)\n@variable(model, y[1:J], Bin)\n@objective(model, Min, sum(y))\n@constraint(model, [i in 1:I], sum(x[i, :]) >= data.pieces[i].d)\n@constraint(\n    model,\n    [j in 1:J],\n    sum(data.pieces[i].w * x[i, j] for i in 1:I) <= data.W * y[j],\n);\nnothing #hide","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Unfortunately, we can't solve this formulation for realistic instances because it takes a very long time to solve. (Try removing the time limit.)","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"set_time_limit_sec(model, 5.0)\noptimize!(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"However, there is a formulation that solves much faster, and that is to use a column generation scheme.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/#Column-generation-theory","page":"Column generation","title":"Column generation theory","text":"","category":"section"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"The key insight for column generation is to recognize that feasible columns in the x matrix of variables encode cutting patterns.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"For example, if we look only at the roll j=1, then a feasible solution is:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"x_11 = 1 (1 unit of piece #1)\nx_131 = 1 (1 unit of piece #13)\nAll other x_i1 = 0","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Another solution is","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"x_201 = 19 (19 unit of piece #20)\nAll other x_i1 = 0","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Cutting patterns like x_11 = 1 and x_21 = 1 are infeasible because the combined length is greater than W.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Since there are a finite number of ways that we could cut a roll into a valid cutting pattern, we could create a set of all possible cutting patterns p = 1ldotsP, with data a_ip indicating how many units of piece i we cut in pattern p. Then, we can formulate our mixed-integer linear program as:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"beginalign\n    min  sumlimits_p=1^P x_p \n    textst  sumlimits_p=1^P a_ip x_p ge d_i  forall i=1ldotsI \n          x_p ge 0  forall p=1ldotsP \n          x_p in mathbbZ  forall p=1ldotsP\nendalign","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Unfortunately, there will be a very large number of these patterns, so it is often intractable to enumerate all columns p=1ldotsP.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Column generation is an iterative algorithm that starts with a small set of initial patterns, and then cleverly chooses new columns to add to the main MILP so that we find the optimal solution without having to enumerate every column.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/#Choosing-the-initial-set-of-patterns","page":"Column generation","title":"Choosing the initial set of patterns","text":"","category":"section"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"For the initial set of patterns, we create a trivial cutting pattern which cuts as many units of piece i as will fit.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"patterns = map(1:I) do i\n    n_pieces = floor(Int, data.W / data.pieces[i].w)\n    return SparseArrays.sparsevec([i], [n_pieces], I)\nend","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"We can visualize the patterns as follows:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"\"\"\"\n    cutting_locations(data::Data, pattern::SparseArrays.SparseVector)\n\nA function which returns a vector of the locations along the roll at which to\ncut in order to produce pattern `pattern`.\n\"\"\"\nfunction cutting_locations(data::Data, pattern::SparseArrays.SparseVector)\n    locations = Float64[]\n    offset = 0.0\n    for (i, c) in zip(SparseArrays.findnz(pattern)...)\n        for _ in 1:c\n            offset += data.pieces[i].w\n            push!(locations, offset)\n        end\n    end\n    return locations\nend\n\nfunction plot_patterns(data::Data, patterns)\n    plot = Plots.bar(;\n        xlims = (0, length(patterns) + 1),\n        ylims = (0, data.W),\n        xlabel = \"Pattern\",\n        ylabel = \"Roll length\",\n    )\n    for (i, p) in enumerate(patterns)\n        locations = cutting_locations(data, p)\n        Plots.bar!(\n            plot,\n            fill(i, length(locations)),\n            reverse(locations);\n            bar_width = 0.6,\n            label = false,\n            color = \"#90caf9\",\n        )\n    end\n    return plot\nend\n\nplot_patterns(data, patterns)","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/#The-base-problem","page":"Column generation","title":"The base problem","text":"","category":"section"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Using the initial set of patterns, we can create and optimize our base model:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, x[1:length(patterns)] >= 0, Int)\n@objective(model, Min, sum(x))\n@constraint(model, demand[i in 1:I], patterns[i]' * x >= data.pieces[i].d)\noptimize!(model)\n@assert is_solved_and_feasible(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"This solution requires 421 rolls. This solution is sub-optimal because the model does not contain the full set of possible patterns.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"How do we find a new column that leads to an improved solution?","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/#Choosing-new-columns","page":"Column generation","title":"Choosing new columns","text":"","category":"section"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Column generation chooses a new column by relaxing the integrality constraint on x and looking at the dual variable pi_i associated with demand constraint i.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"For example, the dual of demand[13] is:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"unset_integer.(x)\noptimize!(model)\n@assert is_solved_and_feasible(model; dual = true)\nπ_13 = dual(demand[13])","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Using the economic interpretation of the dual variable, we can say that a one unit increase in demand for piece i will cost an extra pi_i rolls. Alternatively, we can say that a one unit increase in the left-hand side (for example, due to a new cutting pattern) will save us pi_i rolls. Therefore, we want a new column that maximizes the savings associated with the dual variables, while respecting the total width of the roll:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"beginalign\n    max  sumlimits_i=1^I pi_i y_i \n    textst  sumlimits_i=1^I w_i y_i le W \n          y_i ge 0  forall i=1ldotsI \n          y_i in mathbbZ  forall i=1ldotsI \nendalign","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"If this problem, called the pricing problem, has an objective value greater than 1, then we estimate than adding y as the coefficients of a new column will decrease the objective by more than the cost of an extra roll.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Here is code to solve the pricing problem:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"function solve_pricing(data::Data, π::Vector{Float64})\n    I = length(π)\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    @variable(model, y[1:I] >= 0, Int)\n    @constraint(model, sum(data.pieces[i].w * y[i] for i in 1:I) <= data.W)\n    @objective(model, Max, sum(π[i] * y[i] for i in 1:I))\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    number_of_rolls_saved = objective_value(model)\n    if number_of_rolls_saved > 1 + 1e-8\n        # Benefit of pattern is more than the cost of a new roll plus some\n        # tolerance\n        return SparseArrays.sparse(round.(Int, value.(y)))\n    end\n    return nothing\nend","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"If we solve the pricing problem with an artificial dual vector:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"solve_pricing(data, [1.0 / i for i in 1:I])","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"the solution is a roll with 1 unit of piece #1, 1 unit of piece #17, and 3 units of piece #20.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"If we solve the pricing problem with a dual vector of zeros, then the benefit of the new pattern is less than the cost of a roll, and so the function returns nothing:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"solve_pricing(data, zeros(I))","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/#Iterative-algorithm","page":"Column generation","title":"Iterative algorithm","text":"","category":"section"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Now we can combine our base model with the pricing subproblem in an iterative column generation scheme:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"while true\n    # Solve the linear relaxation\n    optimize!(model)\n    @assert is_solved_and_feasible(model; dual = true)\n    # Obtain a new dual vector\n    π = dual.(demand)\n    # Solve the pricing problem\n    new_pattern = solve_pricing(data, π)\n    # Stop iterating if there is no new pattern\n    if new_pattern === nothing\n        @info \"No new patterns, terminating the algorithm.\"\n        break\n    end\n    push!(patterns, new_pattern)\n    # Create a new column\n    push!(x, @variable(model, lower_bound = 0))\n    # Update the objective coefficient of the new column\n    set_objective_coefficient(model, x[end], 1.0)\n    # Update the non-zeros in the coefficient matrix\n    for (i, count) in zip(SparseArrays.findnz(new_pattern)...)\n        set_normalized_coefficient(demand[i], x[end], count)\n    end\n    println(\"Found new pattern. Total patterns = $(length(patterns))\")\nend","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"We found lots of new patterns. Here's pattern 21:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"patterns[21]","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Let's have a look at the patterns now:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"plot_patterns(data, patterns)","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/#Looking-at-the-solution","page":"Column generation","title":"Looking at the solution","text":"","category":"section"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Let's see how many of each column we need:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"solution = DataFrames.DataFrame([\n    (pattern = p, rolls = value(x_p)) for (p, x_p) in enumerate(x)\n])\nfilter!(row -> row.rolls > 0, solution)","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Since we solved a linear program, some of our columns have fractional solutions. We can create a integer feasible solution by rounding up the orders. This requires 341 rolls:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"sum(ceil.(Int, solution.rolls))","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Alternatively, we can re-introduce the integrality constraints and resolve the problem:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"set_integer.(x)\noptimize!(model)\n@assert is_solved_and_feasible(model)\nsolution = DataFrames.DataFrame([\n    (pattern = p, rolls = value(x_p)) for (p, x_p) in enumerate(x)\n])\nfilter!(row -> row.rolls > 0, solution)","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"This now requires 334 rolls:","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"sum(solution.rolls)","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Note that this may not be the global minimum because we are not adding new columns during the solution of the mixed-integer problem model (an algorithm known as branch and price). Nevertheless, the column generation algorithm typically finds good integer feasible solutions to an otherwise intractable optimization problem.","category":"page"},{"location":"tutorials/algorithms/cutting_stock_column_generation/#Next-steps","page":"Column generation","title":"Next steps","text":"","category":"section"},{"location":"tutorials/algorithms/cutting_stock_column_generation/","page":"Column generation","title":"Column generation","text":"Our objective function is to minimize the total number of rolls. What is the total length of waste? How does that compare to the total demand?\nWriting the optimization algorithm is only part of the challenge. Can you develop a better way to communicate the solution to stakeholders?","category":"page"},{"location":"moi/reference/constraints/","page":"Constraints","title":"Constraints","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/reference/constraints.md\"","category":"page"},{"location":"moi/reference/constraints/","page":"Constraints","title":"Constraints","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/constraints/#constraints_ref","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"moi/reference/constraints/#Types","page":"Constraints","title":"Types","text":"","category":"section"},{"location":"moi/reference/constraints/","page":"Constraints","title":"Constraints","text":"ConstraintIndex","category":"page"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintIndex","page":"Constraints","title":"MathOptInterface.ConstraintIndex","text":"ConstraintIndex{F, S}\n\nA type-safe wrapper for Int64 for use in referencing F-in-S constraints in a model. The parameter F is the type of the function in the constraint, and the parameter S is the type of set in the constraint. To allow for deletion, indices need not be consecutive. Indices within a constraint type (that is, F-in-S) must be unique, but non-unique indices across different constraint types are allowed. If F is VariableIndex then the index is equal to the index of the variable. That is for an index::ConstraintIndex{VariableIndex}, we always have\n\nindex.value == MOI.get(model, MOI.ConstraintFunction(), index).value\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#Functions","page":"Constraints","title":"Functions","text":"","category":"section"},{"location":"moi/reference/constraints/","page":"Constraints","title":"Constraints","text":"is_valid(::ModelLike,::ConstraintIndex)\nadd_constraint\nadd_constraints\ntransform\nsupports_constraint","category":"page"},{"location":"moi/reference/constraints/#MathOptInterface.is_valid-Tuple{MathOptInterface.ModelLike, MathOptInterface.ConstraintIndex}","page":"Constraints","title":"MathOptInterface.is_valid","text":"is_valid(model::ModelLike, index::Index)::Bool\n\nReturn a Bool indicating whether this index refers to a valid object in the model model.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/constraints/#MathOptInterface.add_constraint","page":"Constraints","title":"MathOptInterface.add_constraint","text":"MOI.add_constraint(map::Map, vi::MOI.VariableIndex, set::MOI.AbstractScalarSet)\n\nRecord that a constraint vi-in-set is added and throws if a lower or upper bound is set by this constraint and such bound has already been set for vi.\n\n\n\n\n\nadd_constraint(model::ModelLike, func::F, set::S)::ConstraintIndex{F,S} where {F,S}\n\nAdd the constraint f(x) in mathcalS where f is defined by func, and mathcalS is defined by set.\n\nadd_constraint(model::ModelLike, v::VariableIndex, set::S)::ConstraintIndex{VariableIndex,S} where {S}\nadd_constraint(model::ModelLike, vec::Vector{VariableIndex}, set::S)::ConstraintIndex{VectorOfVariables,S} where {S}\n\nAdd the constraint v in mathcalS where v is the variable (or vector of variables) referenced by v and mathcalS is defined by set.\n\nAn UnsupportedConstraint error is thrown if model does not support F-in-S constraints,\na AddConstraintNotAllowed error is thrown if it supports F-in-S constraints but it cannot add the constraint in its current state and\na ScalarFunctionConstantNotZero error may be thrown if func is an AbstractScalarFunction with nonzero constant and set is EqualTo, GreaterThan, LessThan or Interval.\na LowerBoundAlreadySet error is thrown if F is a VariableIndex and a constraint was already added to this variable that sets a lower bound.\na UpperBoundAlreadySet error is thrown if F is a VariableIndex and a constraint was already added to this variable that sets an upper bound.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/constraints/#MathOptInterface.add_constraints","page":"Constraints","title":"MathOptInterface.add_constraints","text":"add_constraints(model::ModelLike, funcs::Vector{F}, sets::Vector{S})::Vector{ConstraintIndex{F,S}} where {F,S}\n\nAdd the set of constraints specified by each function-set pair in funcs and sets. F and S should be concrete types. This call is equivalent to add_constraint.(model, funcs, sets) but may be more efficient.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/constraints/#MathOptInterface.transform","page":"Constraints","title":"MathOptInterface.transform","text":"Transform Constraint Set\n\ntransform(model::ModelLike, c::ConstraintIndex{F,S1}, newset::S2)::ConstraintIndex{F,S2}\n\nReplace the set in constraint c with newset. The constraint index c will no longer be valid, and the function returns a new constraint index with the correct type.\n\nSolvers may only support a subset of constraint transforms that they perform efficiently (for example, changing from a LessThan to GreaterThan set). In addition, set modification (where S1 = S2) should be performed via the modify function.\n\nTypically, the user should delete the constraint and add a new one.\n\nExamples\n\nIf c is a ConstraintIndex{ScalarAffineFunction{Float64},LessThan{Float64}},\n\nc2 = transform(model, c, GreaterThan(0.0))\ntransform(model, c, LessThan(0.0)) # errors\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/constraints/#MathOptInterface.supports_constraint","page":"Constraints","title":"MathOptInterface.supports_constraint","text":"MOI.supports_constraint(\n    BT::Type{<:AbstractBridge},\n    F::Type{<:MOI.AbstractFunction},\n    S::Type{<:MOI.AbstractSet},\n)::Bool\n\nReturn a Bool indicating whether the bridges of type BT support bridging F-in-S constraints.\n\nImplementation notes\n\nThis method depends only on the type of the inputs, not the runtime values.\nThere is a default fallback, so you need only implement this method for constraint types that the bridge implements.\n\n\n\n\n\nsupports_constraint(\n    model::ModelLike,\n    ::Type{F},\n    ::Type{S},\n)::Bool where {F<:AbstractFunction,S<:AbstractSet}\n\nReturn a Bool indicating whether model supports F-in-S constraints, that is, copy_to(model, src) does not throw UnsupportedConstraint when src contains F-in-S constraints. If F-in-S constraints are only not supported in specific circumstances, for example, F-in-S constraints cannot be combined with another type of constraint, it should still return true.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/constraints/#Attributes","page":"Constraints","title":"Attributes","text":"","category":"section"},{"location":"moi/reference/constraints/","page":"Constraints","title":"Constraints","text":"AbstractConstraintAttribute\nConstraintName\nConstraintPrimalStart\nConstraintDualStart\nConstraintPrimal\nConstraintDual\nConstraintBasisStatus\nConstraintFunction\nCanonicalConstraintFunction\nConstraintSet\nBasisStatusCode\nBASIC\nNONBASIC\nNONBASIC_AT_LOWER\nNONBASIC_AT_UPPER\nSUPER_BASIC","category":"page"},{"location":"moi/reference/constraints/#MathOptInterface.AbstractConstraintAttribute","page":"Constraints","title":"MathOptInterface.AbstractConstraintAttribute","text":"AbstractConstraintAttribute\n\nAbstract supertype for attribute objects that can be used to set or get attributes (properties) of constraints in the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintName","page":"Constraints","title":"MathOptInterface.ConstraintName","text":"ConstraintName()\n\nA constraint attribute for a string identifying the constraint.\n\nIt is valid for constraints variables to have the same name; however, constraints with duplicate names cannot be looked up using get, regardless of whether they have the same F-in-S type.\n\nConstraintName has a default value of \"\" if not set.\n\nNotes\n\nYou should not implement ConstraintName for VariableIndex constraints.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintPrimalStart","page":"Constraints","title":"MathOptInterface.ConstraintPrimalStart","text":"ConstraintPrimalStart()\n\nA constraint attribute for the initial assignment to some constraint's ConstraintPrimal that the optimizer may use to warm-start the solve.\n\nMay be nothing (unset), a number for AbstractScalarFunction, or a vector for AbstractVectorFunction.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintDualStart","page":"Constraints","title":"MathOptInterface.ConstraintDualStart","text":"ConstraintDualStart()\n\nA constraint attribute for the initial assignment to some constraint's ConstraintDual that the optimizer may use to warm-start the solve.\n\nMay be nothing (unset), a number for AbstractScalarFunction, or a vector for AbstractVectorFunction.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintPrimal","page":"Constraints","title":"MathOptInterface.ConstraintPrimal","text":"ConstraintPrimal(result_index::Int = 1)\n\nA constraint attribute for the assignment to some constraint's primal value in result result_index.\n\nIf the constraint is f(x) in S, then in most cases the ConstraintPrimal is the value of f, evaluated at the corresponding VariablePrimal solution.\n\nHowever, some conic solvers reformulate b - Ax in S to s = b - Ax, s in S. These solvers may return the value of s for ConstraintPrimal, rather than b - Ax. (Although these are constrained by an equality constraint, due to numerical tolerances they may not be identical.)\n\nIf the solver does not have a primal value for the constraint because the result_index is beyond the available solutions (whose number is indicated by the ResultCount attribute), getting this attribute must throw a ResultIndexBoundsError. Otherwise, if the result is unavailable for another reason (for instance, only a dual solution is available), the result is undefined. Users should first check PrimalStatus before accessing the ConstraintPrimal attribute.\n\nIf result_index is omitted, it is 1 by default. See ResultCount for information on how the results are ordered.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintDual","page":"Constraints","title":"MathOptInterface.ConstraintDual","text":"ConstraintDual(result_index::Int = 1)\n\nA constraint attribute for the assignment to some constraint's dual value in result result_index. If result_index is omitted, it is 1 by default.\n\nIf the solver does not have a dual value for the variable because the result_index is beyond the available solutions (whose number is indicated by the ResultCount attribute), getting this attribute must throw a ResultIndexBoundsError. Otherwise, if the result is unavailable for another reason (for instance, only a primal solution is available), the result is undefined. Users should first check DualStatus before accessing the ConstraintDual attribute.\n\nSee ResultCount for information on how the results are ordered.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintBasisStatus","page":"Constraints","title":"MathOptInterface.ConstraintBasisStatus","text":"ConstraintBasisStatus(result_index::Int = 1)\n\nA constraint attribute for the BasisStatusCode of some constraint in result result_index, with respect to an available optimal solution basis. If result_index is omitted, it is 1 by default.\n\nIf the solver does not have a basis status for the constraint because the result_index is beyond the available solutions (whose number is indicated by the ResultCount attribute), getting this attribute must throw a ResultIndexBoundsError. Otherwise, if the result is unavailable for another reason (for instance, only a dual solution is available), the result is undefined. Users should first check PrimalStatus before accessing the ConstraintBasisStatus attribute.\n\nSee ResultCount for information on how the results are ordered.\n\nNotes\n\nFor the basis status of a variable, query VariableBasisStatus.\n\nConstraintBasisStatus does not apply to VariableIndex constraints. You can infer the basis status of a VariableIndex constraint by looking at the result of VariableBasisStatus.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintFunction","page":"Constraints","title":"MathOptInterface.ConstraintFunction","text":"ConstraintFunction()\n\nA constraint attribute for the AbstractFunction object used to define the constraint.\n\nIt is guaranteed to be equivalent but not necessarily identical to the function provided by the user.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.CanonicalConstraintFunction","page":"Constraints","title":"MathOptInterface.CanonicalConstraintFunction","text":"CanonicalConstraintFunction()\n\nA constraint attribute for a canonical representation of the AbstractFunction object used to define the constraint.\n\nGetting this attribute is guaranteed to return a function that is equivalent but not necessarily identical to the function provided by the user.\n\nBy default, MOI.get(model, MOI.CanonicalConstraintFunction(), ci) fallbacks to MOI.Utilities.canonical(MOI.get(model, MOI.ConstraintFunction(), ci)). However, if model knows that the constraint function is canonical then it can implement a specialized method that directly return the function without calling Utilities.canonical. Therefore, the value returned cannot be assumed to be a copy of the function stored in model. Moreover, Utilities.Model checks with Utilities.is_canonical whether the function stored internally is already canonical and if it's the case, then it returns the function stored internally instead of a copy.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.ConstraintSet","page":"Constraints","title":"MathOptInterface.ConstraintSet","text":"ConstraintSet()\n\nA constraint attribute for the AbstractSet object used to define the constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.BasisStatusCode","page":"Constraints","title":"MathOptInterface.BasisStatusCode","text":"BasisStatusCode\n\nAn Enum of possible values for the ConstraintBasisStatus and VariableBasisStatus attributes, explaining the status of a given element with respect to an optimal solution basis.\n\nNotes\n\nNONBASIC_AT_LOWER and NONBASIC_AT_UPPER should be used only for constraints with the Interval set. In this case, they are necessary to distinguish which side of the constraint is active. One-sided constraints (for example, LessThan and GreaterThan) should use NONBASIC instead of the NONBASIC_AT_* values. This restriction does not apply to VariableBasisStatus, which should return NONBASIC_AT_* regardless of whether the alternative bound exists.\nIn linear programs, SUPER_BASIC occurs when a variable with no bounds is not in the basis.\n\nValues\n\nPossible values are:\n\nBASIC: element is in the basis\nNONBASIC: element is not in the basis\nNONBASIC_AT_LOWER: element is not in the basis and is at its lower bound\nNONBASIC_AT_UPPER: element is not in the basis and is at its upper bound\nSUPER_BASIC: element is not in the basis but is also not at one of its bounds\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/constraints/#MathOptInterface.BASIC","page":"Constraints","title":"MathOptInterface.BASIC","text":"BASIC::BasisStatusCode\n\nAn instance of the BasisStatusCode enum.\n\nBASIC: element is in the basis\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/constraints/#MathOptInterface.NONBASIC","page":"Constraints","title":"MathOptInterface.NONBASIC","text":"NONBASIC::BasisStatusCode\n\nAn instance of the BasisStatusCode enum.\n\nNONBASIC: element is not in the basis\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/constraints/#MathOptInterface.NONBASIC_AT_LOWER","page":"Constraints","title":"MathOptInterface.NONBASIC_AT_LOWER","text":"NONBASIC_AT_LOWER::BasisStatusCode\n\nAn instance of the BasisStatusCode enum.\n\nNONBASIC_AT_LOWER: element is not in the basis and is at its lower bound\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/constraints/#MathOptInterface.NONBASIC_AT_UPPER","page":"Constraints","title":"MathOptInterface.NONBASIC_AT_UPPER","text":"NONBASIC_AT_UPPER::BasisStatusCode\n\nAn instance of the BasisStatusCode enum.\n\nNONBASIC_AT_UPPER: element is not in the basis and is at its upper bound\n\n\n\n\n\n","category":"constant"},{"location":"moi/reference/constraints/#MathOptInterface.SUPER_BASIC","page":"Constraints","title":"MathOptInterface.SUPER_BASIC","text":"SUPER_BASIC::BasisStatusCode\n\nAn instance of the BasisStatusCode enum.\n\nSUPER_BASIC: element is not in the basis but is also not at one of its bounds\n\n\n\n\n\n","category":"constant"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"EditURL = \"tsp_lazy_constraints.jl\"","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/#tsp_lazy","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"","category":"section"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"This tutorial was originally contributed by Daniel Schermer.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"This tutorial describes how to implement the Traveling Salesperson Problem in JuMP using solver-independent lazy constraints that dynamically separate subtours. To be more precise, we use lazy constraints to cut off infeasible subtours only when necessary and not before needed.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"It uses the following packages:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"using JuMP\nimport GLPK\nimport Random\nimport Plots","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/#tsp_model","page":"Traveling Salesperson Problem","title":"Mathematical Formulation","text":"","category":"section"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Assume that we are given a complete graph mathcalG(VE) where V is the set of vertices (or cities) and E is the set of edges (or roads). For each pair of vertices i j in V i neq j the edge (ij) in E is associated with a weight (or distance) d_ij in mathbbR^+.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"For this tutorial, we assume the problem to be symmetric, that is, d_ij = d_ji  forall ij in V.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"In the Traveling Salesperson Problem, we are tasked with finding a tour with minimal length that visits every vertex exactly once and then returns to the point of origin, that is, a Hamiltonian cycle with minimal weight.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"To model the problem, we introduce a binary variable, x_ij in 01  forall i j in V, that indicates if edge (ij) is part of the tour or not. Using these variables, the Traveling Salesperson Problem can be modeled as the following integer linear program.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/#tsp_objective","page":"Traveling Salesperson Problem","title":"Objective Function","text":"","category":"section"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"The objective is to minimize the length of the tour (due to the assumed symmetry, the second sum only contains ij):","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"textmin  sum_i in V  sum_j in V i  j d_ij x_ij","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Note that it is also possible to use the following objective function instead:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"textmin  sum_i in V  sum_j in V dfracd_ij x_ij2","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/#tsp_constraints","page":"Traveling Salesperson Problem","title":"Constraints","text":"","category":"section"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"There are four classes of constraints in our formulation.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"First, due to the presumed symmetry, the following constraints must hold:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"x_ij = x_ji quad forall ij in V","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Second, for each vertex i, exactly two edges must be selected that connect it to other vertices j in the graph G:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"sum_j in V x_ij = 2 quad forall i in V","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Third, we do not permit loops to occur:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"x_ii = 0 quad forall i in V","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"The fourth constraint is more complicated. A major difficulty of the Traveling Salesperson Problem arises from the fact that we need to prevent subtours, that is, several distinct Hamiltonian cycles existing on subgraphs of G.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Note that the previous constraints do not guarantee that the solution will be free of subtours. To this end, by S we label a subset of vertices. Then, for each proper subset S subset V, the following constraints guarantee that no subtour may occur:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"sum_i in S sum_j in S i  j x_ij leq vert S vert - 1 quad forall S subset V","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Problematically, we require exponentially many of these constraints as vert V vert increases. Therefore, we will add these constraints only when necessary.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/#tsp_implementation","page":"Traveling Salesperson Problem","title":"Implementation","text":"","category":"section"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"There are two ways we can eliminate subtours in JuMP, both of which will be shown in what follows:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"iteratively solving a new model that incorporates previously identified subtours,\nor adding violated subtours as lazy constraints.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/#Data","page":"Traveling Salesperson Problem","title":"Data","text":"","category":"section"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"The vertices are assumed to be randomly distributed in the Euclidean space; thus, the weight (distance) of each edge is defined as follows.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"function generate_distance_matrix(n; random_seed = 1)\n    rng = Random.MersenneTwister(random_seed)\n    X = 100 * rand(rng, n)\n    Y = 100 * rand(rng, n)\n    d = [sqrt((X[i] - X[j])^2 + (Y[i] - Y[j])^2) for i in 1:n, j in 1:n]\n    return X, Y, d\nend\n\nn = 40\nX, Y, d = generate_distance_matrix(n)","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"For the JuMP model, we first initialize the model object. Then, we create the binary decision variables and add the objective function and constraints. By defining the x matrix as Symmetric, we do not need to add explicit constraints that x[i, j] == x[j, i].","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"function build_tsp_model(d, n)\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:n, 1:n], Bin, Symmetric)\n    @objective(model, Min, sum(d .* x) / 2)\n    @constraint(model, [i in 1:n], sum(x[i, :]) == 2)\n    @constraint(model, [i in 1:n], x[i, i] == 0)\n    return model\nend","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"To search for violated constraints, based on the edges that are currently in the solution (that is, those that have value x_ij = 1), we identify the shortest cycle through the function subtour(). Whenever a subtour has been identified, a constraint corresponding to the form above can be added to the model.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"function subtour(edges::Vector{Tuple{Int,Int}}, n)\n    shortest_subtour, unvisited = collect(1:n), Set(collect(1:n))\n    while !isempty(unvisited)\n        this_cycle, neighbors = Int[], unvisited\n        while !isempty(neighbors)\n            current = pop!(neighbors)\n            push!(this_cycle, current)\n            if length(this_cycle) > 1\n                pop!(unvisited, current)\n            end\n            neighbors =\n                [j for (i, j) in edges if i == current && j in unvisited]\n        end\n        if length(this_cycle) < length(shortest_subtour)\n            shortest_subtour = this_cycle\n        end\n    end\n    return shortest_subtour\nend","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Let us declare a helper function selected_edges() that will be repeatedly used in what follows.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"function selected_edges(x::Matrix{Float64}, n)\n    return Tuple{Int,Int}[(i, j) for i in 1:n, j in 1:n if x[i, j] > 0.5]\nend","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Other helper functions for computing subtours:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"subtour(x::Matrix{Float64}) = subtour(selected_edges(x, size(x, 1)), size(x, 1))\nsubtour(x::AbstractMatrix{VariableRef}) = subtour(value.(x))","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/#Iterative-method","page":"Traveling Salesperson Problem","title":"Iterative method","text":"","category":"section"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"An iterative way of eliminating subtours is the following.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"However, it is reasonable to assume that this is not the most efficient way: whenever a new subtour elimination constraint is added to the model, the optimization has to start from the very beginning.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"That way, the solver will repeatedly discard useful information encountered during previous solves (for example, all cuts, the incumbent solution, or lower bounds).","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"info: Info\nNote that, in principle, it would also be feasible to add all subtours (instead of just the shortest one) to the model. However, preventing just the shortest cycle is often sufficient for breaking other subtours and will keep the model size smaller.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"iterative_model = build_tsp_model(d, n)\noptimize!(iterative_model)\n@assert is_solved_and_feasible(iterative_model)\ntime_iterated = solve_time(iterative_model)\ncycle = subtour(iterative_model[:x])\nwhile 1 < length(cycle) < n\n    println(\"Found cycle of length $(length(cycle))\")\n    S = [(i, j) for (i, j) in Iterators.product(cycle, cycle) if i < j]\n    @constraint(\n        iterative_model,\n        sum(iterative_model[:x][i, j] for (i, j) in S) <= length(cycle) - 1,\n    )\n    optimize!(iterative_model)\n    @assert is_solved_and_feasible(iterative_model)\n    global time_iterated += solve_time(iterative_model)\n    global cycle = subtour(iterative_model[:x])\nend\n\nobjective_value(iterative_model)","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"time_iterated","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"As a quick sanity check, we visualize the optimal tour to verify that no subtour is present:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"function plot_tour(X, Y, x)\n    plot = Plots.plot()\n    for (i, j) in selected_edges(x, size(x, 1))\n        Plots.plot!([X[i], X[j]], [Y[i], Y[j]]; legend = false)\n    end\n    return plot\nend\n\nplot_tour(X, Y, value.(iterative_model[:x]))","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/#Lazy-constraint-method","page":"Traveling Salesperson Problem","title":"Lazy constraint method","text":"","category":"section"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"A more sophisticated approach makes use of lazy constraints. To be more precise, we do this through the subtour_elimination_callback() below, which is only run whenever we encounter a new integer-feasible solution.","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"lazy_model = build_tsp_model(d, n)\nfunction subtour_elimination_callback(cb_data)\n    status = callback_node_status(cb_data, lazy_model)\n    if status != MOI.CALLBACK_NODE_STATUS_INTEGER\n        return  # Only run at integer solutions\n    end\n    cycle = subtour(callback_value.(cb_data, lazy_model[:x]))\n    if !(1 < length(cycle) < n)\n        return  # Only add a constraint if there is a cycle\n    end\n    println(\"Found cycle of length $(length(cycle))\")\n    S = [(i, j) for (i, j) in Iterators.product(cycle, cycle) if i < j]\n    con = @build_constraint(\n        sum(lazy_model[:x][i, j] for (i, j) in S) <= length(cycle) - 1,\n    )\n    MOI.submit(lazy_model, MOI.LazyConstraint(cb_data), con)\n    return\nend\nset_attribute(\n    lazy_model,\n    MOI.LazyConstraintCallback(),\n    subtour_elimination_callback,\n)\noptimize!(lazy_model)\n@assert is_solved_and_feasible(lazy_model)\nobjective_value(lazy_model)","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"This finds the same optimal tour:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"plot_tour(X, Y, value.(lazy_model[:x]))","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"Surprisingly, for this particular model with GLPK, the solution time is worse than the iterative method:","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"time_lazy = solve_time(lazy_model)","category":"page"},{"location":"tutorials/algorithms/tsp_lazy_constraints/","page":"Traveling Salesperson Problem","title":"Traveling Salesperson Problem","text":"In most other cases and solvers, however, the lazy time should be faster than the iterative method.","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"CurrentModule = JuMP","category":"page"},{"location":"changelog/#Release-notes","page":"Release notes","title":"Release notes","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"changelog/#Version-1.22.0-(May-12,-2024)","page":"Release notes","title":"Version 1.22.0 (May 12, 2024)","text":"","category":"section"},{"location":"changelog/#Added","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added Base.complex(r, i) where r and i may be real-valued variables or affine or quadratic expressions (#3734)\nAdded @force_nonlinear for controlling when affine and quadratic expressions are instead parsed as nonlinear expressions. This can be useful for advanced users in a limited set of circumstances. (#3732)\nAdded support for returning the variable coefficients of a vector-valued constraint via normalized_coefficient. In addition, set_normalized_coefficients has been softly deprecated (no warning is thrown and old code will still work for all future 1.X releases of JuMP) in favor of set_normalized_coefficient. This change was made to unify how we get and set variable coefficients. (#3743)","category":"page"},{"location":"changelog/#Fixed","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed missing promote_operation method that resulted in slow code (#3730)\nImproved performance of getindex for Containers.DenseAxisArray (#3731)\nFixed the error message when the legacy nonlinear API is mixed with the new nonlinear API. In particular, we now uniformly throw an error message when unexpected objects occur in nonlinear expressions. (#3741)","category":"page"},{"location":"changelog/#Other","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Updated documentation (#3727), (#3728), (#3739)\nUpdated versions in GitHub actions (#3735)","category":"page"},{"location":"changelog/#Version-1.21.1-(April-11,-2024)","page":"Release notes","title":"Version 1.21.1 (April 11, 2024)","text":"","category":"section"},{"location":"changelog/#Fixed-2","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed behavior of complex-value related functions like real, imag, conj and abs2 when called on GenericNonlinearExpr. This fixes a method error when calling x' where x is an array of nonlinear expressions. As a related consequence, we now always error when creating nonlinear expressions with complex components. Previously, only some constructors were checked for complex expressionns. (#3724)","category":"page"},{"location":"changelog/#Other-2","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Documentation improvements (#3719) (#3720) (#3721) (#3722)","category":"page"},{"location":"changelog/#Version-1.21.0-(March-31,-2024)","page":"Release notes","title":"Version 1.21.0 (March 31, 2024)","text":"","category":"section"},{"location":"changelog/#Added-2","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added support for matrix inequality constraints with the HermitianPSDCone (#3705)\nAdded batched modification methods for set_normalized_rhs, set_objective_coefficient and set_normalized_coefficient. Using these methods can be more efficient for some solvers (#3716)\nAdded the private constant _CONSTRAINT_LIMIT_FOR_PRINTING, which controls how many constraints are printed to the screen during print(model). The main purpose of this is to prevent large quantities of text being printed when print(model) is accidentally called on a large model. (#3686)","category":"page"},{"location":"changelog/#Fixed-3","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Changed Containers.SparseAxisArray to use an OrderedDict as the backing data structure. Iterating over the elements in a SparseAxisArray now iterates in the order that the elements were created. Previously, the order was undefined behavior. (#3681)\nFixed complex variables for non-Float64 coefficient types (#3691)\nFixed LinearAlgebra.hermitan(::AbstractJuMPScalar) (#3693)\nFixed multiplying real scalar by Hermitian matrix (#3695)","category":"page"},{"location":"changelog/#Other-3","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Documentation improvements (#3679) (#3683) (#3702) (#3703) (#3706) (#3696) (#3708) (#3709) (#3711)\nAdded new tutorials:\nBasis matrices (#3675)\nTransitioning from MATLAB (#3698)\nAutomatic differentiation of user-defined operators (#3713)\nUpdated versions and compat bounds (#3687) (#3707) (#3717)","category":"page"},{"location":"changelog/#Version-1.20.0-(February-15,-2024)","page":"Release notes","title":"Version 1.20.0 (February 15, 2024)","text":"","category":"section"},{"location":"changelog/#Added-3","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added is_solved_and_feasible (#3668)\nAdded support for MOI.ModelLike as the optimizer (#3667)","category":"page"},{"location":"changelog/#Fixed-4","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed compat of DimensionalData (#3666)\nFixed convert(::Type{NonlinearExpr}, ::Number)(#3672)","category":"page"},{"location":"changelog/#Other-4","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added Optim to list of solvers (#3624)\nImproved linking within documentation (#3669)","category":"page"},{"location":"changelog/#Version-1.19.0-(February-1,-2024)","page":"Release notes","title":"Version 1.19.0 (February 1, 2024)","text":"","category":"section"},{"location":"changelog/#Added-4","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added support for modifying quadratic coefficients (#3658)","category":"page"},{"location":"changelog/#Fixed-5","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed short circuiting of && and || in macros (#3655)","category":"page"},{"location":"changelog/#Other-5","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added SDPLR to list of solvers (#3644)\nAdded new roadmap items (#3645)\nFixed vale.sh version (#3650)\nImprove error messages in macros (#3653)\nRefactoring of set_normalized_coefficient (#3660) (#3661)\nUpdate docs/packages.toml (#3662)","category":"page"},{"location":"changelog/#Version-1.18.1-(January-6,-2024)","page":"Release notes","title":"Version 1.18.1 (January 6, 2024)","text":"","category":"section"},{"location":"changelog/#Fixed-6","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed escaping of the set keyword in @variable (#3647)","category":"page"},{"location":"changelog/#Version-1.18.0-(January-2,-2024)","page":"Release notes","title":"Version 1.18.0 (January 2, 2024)","text":"","category":"section"},{"location":"changelog/#Added-5","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"This release includes a large refactoring of the macro code that closes a roadmap item (#3629) Contributing pull requests include (#3600), (#3603), (#3606), (#3607), (#3610), (#3611), (#3612), (#3613), (#3614), (#3615), (#3617), (#3618), (#3619), (#3620), (#3621), (#3631), (#3632), (#3633)","category":"page"},{"location":"changelog/#Fixed-7","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed error for unsupported objective sense (#3601)\nFixed text/latex printing of GenericNonlinearExpr (#3609)\nFixed compat bounds of stdlib packages (#3626)\nFixed a bug that can accidentally modify the user's expressions in a macro (#3639)\nFixed a bug converting AffExpr to GenericNonlinearExpr (#3642)","category":"page"},{"location":"changelog/#Other-6","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added DisjunctiveProgrammingto extension-tests (#3597)\nAdded DisjunctiveProgrammingto docs (#3598)\nAdded DocumenterCitations to the docs (#3596), (#3630)\nMigrate from SnoopPrecompile to PrecompileTools (#3608)\nMinor documentation updates (#3623), (#3628), (#3635), (#3640), (#3643)","category":"page"},{"location":"changelog/#Version-1.17.0-(December-4,-2023)","page":"Release notes","title":"Version 1.17.0 (December 4, 2023)","text":"","category":"section"},{"location":"changelog/#Added-6","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added start_value, lower_bound, and upper_bound support for GenericAffExpr that are equivalent to a single GenericVariableRef (#3551)\nAdded SkipModelConvertScalarSetWrapper which is useful for extensions looking to avoid model_convert (#3552) (#3592)\nAdded lp_matrix_data (#3573) (#3591)","category":"page"},{"location":"changelog/#Fixed-8","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed variable_ref_type for unsupported types (#3556)\nFixed convert type of constraint starting values (#3571)\nFixed various methods to support AbstractJuMPScalar with Distances.jl (#3583)\nFixed eachindex for multiple arguments of Containers.DenseAxisArray and Containers.SparseAxisArray (#3587)\nExpressions with more than 60 terms now print in truncated form. This prevents large expressions from being accidentally printed to terminal or IJulia output (#3575)\nFixed a type instability in set_objective_coefficient (#3590)\nVarious fixes to the documentation (#3593) (#3595)","category":"page"},{"location":"changelog/#Other-7","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Improved error messages for:\nAddition and subtraction between a matrix and a scalar (#3557) (#3558)\nVariables with non-constant bounds (#3583)\nInvalid indicator constraints (#3584)\nAdded new solvers to the documentation:\nEAGO.jl (#3560) (#3561)\nManopt.jl (#3568)\nPercival.jl (#3567)\nAdded new tutorials:\nApproximating nonlinear functions (#3563)\nClassifiers (#3569)\nImproved documentation for:\nSemicontinuous and Semiinteger variables (#3562)\nSOS1 and SOS2 (#3565)\nstart_value of HermitianPSDCone (#3564)\nFunction tracing (#3570)\nNonlinear operators with vector arguments (#3577)\nIndicator constraints (#3582)\nUpdated package compat bounds (#3578)","category":"page"},{"location":"changelog/#Version-1.16.0-(October-24,-2023)","page":"Release notes","title":"Version 1.16.0 (October 24, 2023)","text":"","category":"section"},{"location":"changelog/#Added-7","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added := operator for Boolean satisfiability problems (#3530)","category":"page"},{"location":"changelog/#Fixed-9","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed text/latex printing of MOI.Interval sets (#3537)\nFixed tests with duplicate function names (#3539)","category":"page"},{"location":"changelog/#Other-8","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Updated documentation list of supported solvers (#3527) (#3529) (#3538) (#3542) (#3545) (#3546)\nUpdated to Documenter@1.1 (#3528)\nFixed various tutorials (#3534) (#3532)\nFixed Project.toml compat bounds for standard libraries (#3544)","category":"page"},{"location":"changelog/#Version-1.15.1-(September-24,-2023)","page":"Release notes","title":"Version 1.15.1 (September 24, 2023)","text":"","category":"section"},{"location":"changelog/#Fixed-10","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed support for single argument min and max operators (#3522)\nFixed error message for add_to_expression! when called with a GenericNonlinearExpr (#3506)\nFixed constraint tags with broadcasted constraints (#3515)\nFixed MethodError in MA.scaling (#3518)\nFixed support for arrays of Parameter variables (#3524)","category":"page"},{"location":"changelog/#Other-9","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Updated to Documenter@1 (#3501)\nFixed links to data in tutorials (#3512)\nFixed typo in TSP tutorial (#3516)\nImproved error message for VariableNotOwned errors (#3520)\nFixed various JET errors (#3519)","category":"page"},{"location":"changelog/#Version-1.15.0-(September-15,-2023)","page":"Release notes","title":"Version 1.15.0 (September 15, 2023)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"This is a large minor release because it adds an entirely new data structure and API path for working with nonlinear programs. The previous nonlinear interface remains unchanged and is documented at Nonlinear Modeling (Legacy). The new interface is a treated as a non-breaking feature addition and is documented at Nonlinear Modeling.","category":"page"},{"location":"changelog/#Breaking","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Although the new nonlinear interface is a feature addition, there are two changes which might be breaking for a very small number of users.","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"The syntax inside JuMP macros is parsed using a different code path, even for linear and quadratic expressions. We made this change to unify how we parse linear, quadratic, and nonlinear expressions. In all cases, the new code returns equivalent expressions, but because of the different order of operations, there are three changes to be aware of when updating:\nThe printed form of the expression may change, for example from x * y to y * x. This can cause tests which test the String representation of a model to fail.\nSome coefficients may change slightly due to floating point round-off error.\nParticularly when working with a JuMP extension, you may encounter a MethodError due to a missing or ambiguous method. These errors are due to previously existing bugs that were not triggered by the previous parsing code. If you encounter such an error, please open a GitHub issue.\nThe methods for Base.:^(x::VariableRef, n::Integer) and Base.:^(x::AffExpr, n::Integer) have changed. Previously, these methods supported only n = 0, 1, 2 and they always returned a QuadExpr, even for the case when n = 0 or n = 1. Now:\nx^0 returns one(T), where T is the value_type of the model (defaults to Float64)\nx^1 returns x\nx^2 returns a QuadExpr\nx^n where !(0 <= n <= 2) returns a NonlinearExpr.\nWe made this change to support nonlinear expressions and to align the mathematical definition of the operation with their return type. (Previously, users were surprised that x^1 returned a QuadExpr.) As a consequence of this change, the methods are now not type-stable. This means that the compiler cannot prove that x^2 returns a QuadExpr. If benchmarking shows that this is a performance problem, you can use the type-stable x * x instead of x^2.","category":"page"},{"location":"changelog/#Added-8","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added triangle_vec which simplifies adding MOI.LogDetConeTriangle and MOI.RootDetConeTriangle constraints (#3456)\nAdded the new nonlinear interface. This is a very large change. See the documentation at Nonlinear Modeling and the (long) discussion in JuMP.jl#3106. Related PRs are (#3468) (#3472) (#3475) (#3483) (#3487) (#3488) (#3489) (#3504) (#3509)","category":"page"},{"location":"changelog/#Fixed-11","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed uses of @nospecialize which cause precompilation failures in Julia v1.6.0 and v1.6.1. (#3464)\nFixed adding a container of Parameter (#3473)\nFixed return type of x^0 and x^1 to no longer return QuadExpr (see note in Breaking section above) (#3474)\nFixed error messages in LowerBoundRef, UpperBoundRef, FixRef, IntegerRef, BinaryRef, ParameterRef and related functions (#3494)\nFixed type inference of empty containers in JuMP macros (#3500)","category":"page"},{"location":"changelog/#Other-10","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added GAMS to solver documentation (#3357)\nUpdated various tutorials (#3459) (#3460) (#3462) (#3463) (#3465) (#3490) (#3492) (#3503)\nAdded The network multi-commodity flow problem tutorial (#3491)\nAdded Two-stage stochastic programs tutorial (#3466)\nAdded better error messages for unsupported operations in LinearAlgebra (#3476)\nUpdated to the latest version of Documenter (#3484) (#3495) (#3497)\nUpdated GitHub action versions (#3507)","category":"page"},{"location":"changelog/#Version-1.14.1-(September-2,-2023)","page":"Release notes","title":"Version 1.14.1 (September 2, 2023)","text":"","category":"section"},{"location":"changelog/#Fixed-12","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix links in Documentation (#3478)","category":"page"},{"location":"changelog/#Version-1.14.0-(August-27,-2023)","page":"Release notes","title":"Version 1.14.0 (August 27, 2023)","text":"","category":"section"},{"location":"changelog/#Added-9","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added DimensionalData.jl extension (#3413)\nAdded syntactic sugar for the MOI.Parameter set (#3443)\nParameter\nParameterRef\nis_parameter\nparameter_value\nset_parameter_value","category":"page"},{"location":"changelog/#Fixed-13","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed model_convert for BridgeableConstraint (#3437)\nFixed printing models with integer coefficients larger than typemax(Int) (#3447)\nFixed support for constant left-hand side functions in a complementarity constraint (#3452)","category":"page"},{"location":"changelog/#Other-11","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Updated packages used in documentation (#3444) (#3455)\nFixed docstring tests (#3445)\nFixed printing change for MathOptInterface (#3446)\nFixed typos in documentation (#3448) (#3457)\nAdded SCIP to callback documentation (#3449)","category":"page"},{"location":"changelog/#Version-1.13.0-(July-27,-2023)","page":"Release notes","title":"Version 1.13.0 (July 27, 2023)","text":"","category":"section"},{"location":"changelog/#Added-10","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added support for generic number types (#3377) (#3385)\nAdded fallback for MOI.AbstractSymmetricMatrixSetTriangle and MOI.AbstractSymmetricMatrixSetSquare (#3424)","category":"page"},{"location":"changelog/#Fixed-14","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed set_start_values with MOI.Bridges.Objective.SlackBridge (#3422)\nFixed flakey doctest in variables.md (#3425)\nFixed names on CITATION.bib (#3423)","category":"page"},{"location":"changelog/#Other-12","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added Loraine.jl to the installation table (#3426)\nRemoved Penopt.jl from packages.toml (#3428)\nImproved problem statement in cannery example of tutorial (#3430)\nMinor cleanups in Containers.DenseAxisArray implementation (#3429)\nChanged nested_problems.jl: outer/inner to upper/lower (#3433)\nRemoved second SDP relaxation in OPF tutorial (#3432)","category":"page"},{"location":"changelog/#Version-1.12.0-(June-19,-2023)","page":"Release notes","title":"Version 1.12.0 (June 19, 2023)","text":"","category":"section"},{"location":"changelog/#Added-11","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added coefficient_type keyword argument to add_bridge and remove_bridge (#3394)","category":"page"},{"location":"changelog/#Fixed-15","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed error message for matrix in HermitianPSDCone (#3369)\nFixed EditURL for custom documentation pages (#3373)\nFixed return type annotations for MOI.ConstraintPrimal and MOI.ConstraintDual (#3381)\nFixed printing change in Julia nightly (#3391)\nFixed printing of Complex coefficients (#3397)\nFixed printing of constraints in text/latex mode (#3405)\nFixed performance issue in Containers.rowtable (#3410)\nFixed bug when variables added to set of wrong dimension (#3411)","category":"page"},{"location":"changelog/#Other-13","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added more solver READMEs to the documentation (#3358) (#3360) (#3364) (#3365) (#3366) (#3368) (#3372) (#3374) (#3376) (#3379) (#3387) (#3389)\nAdded StatusSwitchingQP.jl to the installation table (#3354)\nUpdated checklist for adding a new solver (#3370)\nUpdated extension-tests.yml action (#3371) (#3375)\nColor logs in GitHub actions (#3392)\nAdded new tutorials\nOptimal power flow (#3395) (#3412)\nLovász numbers (#3399)\nDualization (#3402)\nUpdated JuMP paper citation (#3400)\nChanged GitHub action to upload LaTeX logs when building documentation (#3403)\nFixed printing of SCS log in documentation (#3406)\nUpdated solver versions (#3407)\nUpdated documentation to use Julia v1.9 (#3398)\nReplaced _value_type with MOI.Utilities.value_type (#3414)\nFixed a typo in docstring (#3415)\nRefactored API documentation (#3386)\nUpdated SCIP license (#3420)","category":"page"},{"location":"changelog/#Version-1.11.1-(May-19,-2023)","page":"Release notes","title":"Version 1.11.1 (May 19, 2023)","text":"","category":"section"},{"location":"changelog/#Fixed-16","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed a poor error message when sum(::DenseAxisArray; dims) was called (#3338)\nFixed support for dependent sets in the @variable macro (#3344)\nFixed a performance bug in constraints with sparse symmetric matrices (#3349)","category":"page"},{"location":"changelog/#Other-14","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Improved the printing of complex numbers (#3332)\nWhen printing, sets which contain constants ending in .0 now print as integers. This follows the behavior of constants in functions (#3341)\nAdded InfiniteOpt to the extensions documentation (#3343)\nAdded more documentation for the exponential cone (#3345) (#3347)\nAdded checklists for developers (#3346) (#3355)\nFixed test support upcoming Julia nightly (#3351)\nFixed extension-tests.yml action (#3353)\nAdd more solvers to the documentation (#3359) (#3361) (#3362)","category":"page"},{"location":"changelog/#Version-1.11.0-(May-3,-2023)","page":"Release notes","title":"Version 1.11.0 (May 3, 2023)","text":"","category":"section"},{"location":"changelog/#Added-12","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added new methods to print_active_bridges for printing a particular objective, constraint, or variable (#3316)","category":"page"},{"location":"changelog/#Fixed-17","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed tests for MOI v1.14.0 release (#3312)\nFixed indexing containers when an axis is Vector{Any} that contains a Vector{Any} element (#3280)\nFixed getindex(::AbstractJuMPScalar) which is called for an expression like x[] (#3314)\nFixed bug in set_string_names_on_creation with a vector of variables (#3322)\nFixed bug in memoize function in nonlinear documentation (#3337)","category":"page"},{"location":"changelog/#Other-15","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed typos in the documentation (#3317) (#3318) (#3328)\nAdded a test for the order of setting start values (#3315)\nAdded READMEs of solvers and extensions to the docs (#3309) (#3320) (#3327) (#3329) (#3333)\nStyle improvements to src/variables.jl (#3324)\nClarify that column generation does not find global optimum (#3325)\nAdd a GitHub actions workflow for testing extensions prior to release (#3331)\nDocument the release process for JuMP (#3334)\nFix links to discourse and chatroom (#3335)","category":"page"},{"location":"changelog/#Version-1.10.0-(April-3,-2023)","page":"Release notes","title":"Version 1.10.0 (April 3, 2023)","text":"","category":"section"},{"location":"changelog/#Added-13","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added Nonnegatives, Nonpositives and Zeros, and support vector-valued inequality syntax in the JuMP macros (#3273)\nAdded special support for LinearAlgebra.Symmetric and LinearAlgebra.Hermitian matrices in Zeros constraints (#3281) (#3296)\nAdded HermitianMatrixSpace and the Hermitian tag for generating a matrix of variables that is Hermitian (#3292) (#3293)\nAdded Semicontinuous and Semiinteger (#3302)\nAdded support for keyword indexing of containers (#3237)","category":"page"},{"location":"changelog/#Fixed-18","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed [compat] bound for MathOptInterface in Project.toml (#3272)","category":"page"},{"location":"changelog/#Other-16","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Split out the Nested optimization problems tutorial (#3274)\nUpdated doctests to ensure none have hidden state (#3275) (#3276)\nClarified how lazy constraints may revisit points (#3278)\nAdded P-Norm example (#3282)\nClarified docs that macros create new bindings (#3284)\nFixed threading example (#3283)\nAdded plot to The minimum distortion problem (#3288)\nAdded Google style rules for Vale and fixed warnings (#3285)\nAdded citation for the JuMP 1.0 paper (#3294)\nUpdated package versions in the documentation (#3298)\nAdded comment for the order in which start values must be set (#3303)\nImproved error message for unrecognized constraint operators (#3311)","category":"page"},{"location":"changelog/#Version-1.9.0-(March-7,-2023)","page":"Release notes","title":"Version 1.9.0 (March 7, 2023)","text":"","category":"section"},{"location":"changelog/#Added-14","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added get_attribute and set_attribute. These replace get_optimizer_attribute and set_optimizer_attribute, although the _optimizer_ functions remain for backward compatibility. (#3219)\nAdded set_start_values for setting all supported start values in a model (#3238)\nAdd remove_bridge and print_active_bridges (#3259)","category":"page"},{"location":"changelog/#Fixed-19","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"The matrix returned by a variable in HermitianPSDCone is now a LinearAlgebra.Hermitian matrix. This is potentially breaking if you have written code to assume the return is a Matrix. (#3245) (#3246)\nFixed missing support for Base.isreal of expressions (#3252)","category":"page"},{"location":"changelog/#Other-17","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed a thread safety issue in the Parallelism tutorial (#3240) (#3243)\nImproved the error message when unsupported operators are used in @NL macros (#3236)\nClarified the documentation to say that matrices in HermitianPSDCone must be LinearAlgebra.Hermitian (#3241)\nMinor style fixes to internal macro code (#3247)\nAdd Quantum state discrimination tutorial (#3250)\nImprove error message when begin...end not passed to plural macros (#3255)\nDocument how to register function with varying number of input arguments (#3258)\nTidy tests by removing unneeded JuMP. prefixes (#3260)\nClarified the introduction to the Complex number support tutorial (#3262)\nFixed typos in the Documentation (#3263) (#3266) (#3268) (#3269)","category":"page"},{"location":"changelog/#Version-1.8.2-(February-27,-2023)","page":"Release notes","title":"Version 1.8.2 (February 27, 2023)","text":"","category":"section"},{"location":"changelog/#Fixed-20","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed dot product between complex JuMP expression and number (#3244)","category":"page"},{"location":"changelog/#Other-18","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Polish simple SDP examples (#3232)","category":"page"},{"location":"changelog/#Version-1.8.1-(February-23,-2023)","page":"Release notes","title":"Version 1.8.1 (February 23, 2023)","text":"","category":"section"},{"location":"changelog/#Fixed-21","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed support for init in nonlinear generator expressions (#3226)","category":"page"},{"location":"changelog/#Other-19","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Use and document import MathOptInterface as MOI (#3222)\nRemoved references in documentation to multiobjective optimization being unsupported (#3223)\nAdded tutorial on multi-objective portfolio optimization (#3227)\nRefactored some of the conic tutorials (#3229)\nFixed typos in the documentation (#3230)\nAdded tutorial on parallelism (#3231)","category":"page"},{"location":"changelog/#Version-1.8.0-(February-16,-2023)","page":"Release notes","title":"Version 1.8.0 (February 16, 2023)","text":"","category":"section"},{"location":"changelog/#Added-15","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added --> syntax support for indicator constraints. The old syntax of => remains supported (#3207)\nAdded <--> syntax for reified constraints. For now, few solvers support reified constraints (#3206)\nAdded fix_discrete_variables. This is most useful for computing the dual of a mixed-integer program (#3208)\nAdded support for vector-valued objectives. For details, see the Multi-objective knapsack tutorial (#3176)","category":"page"},{"location":"changelog/#Fixed-22","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug in lp_sensitivity_report by switching to an explicit LU factorization of the basis matrix (#3182)\nFixed a bug that prevented [; kwarg] arguments in macros (#3220)","category":"page"},{"location":"changelog/#Other-20","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Minor fixes to the documentation (#3200) (#3201) (#3203) (#3210)\nAdded tutorial Constraint programming (#3202)\nAdded more examples to Tips and Tricks\nRemove _distance_to_set in favor of MOI.Utilities.distance_to_set (#3209)\nImprove The diet problem tutorial by adding the variable as a column in the dataframe (#3213)\nImprove The knapsack problem example tutorial (#3216) (#3217)\nAdded the Ellipsoid approximation tutorial (#3218)","category":"page"},{"location":"changelog/#Version-1.7.0-(January-25,-2023)","page":"Release notes","title":"Version 1.7.0 (January 25, 2023)","text":"","category":"section"},{"location":"changelog/#Added-16","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added support for view of a Containers.DenseAxisArray (#3152) (#3180)\nAdded support for containers of variables in ComplexPlane (#3184)\nAdded support for minimum and maximum generators in nonlinear expressions (#3189)\nAdded SnoopPrecompile statements that reduce the time-to-first-solve in Julia 1.9 (#3193) (#3195) (#3196) (#3197)","category":"page"},{"location":"changelog/#Other-21","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Large refactoring of the tests (#3166) (#3167) (#3168) (#3169) (#3170) (#3171)\nRemove unreachable code due to VERSION checks (#3172)\nDocument how to test JuMP extensions (#3174)\nFix method ambiguities in Containers (#3173)\nImprove error message that is thrown when = is used instead of == in the @constraint macro (#3178)\nImprove the error message when Bool is used instead of Bin in the @variable macro (#3180)\nUpdate versions of the documentation (#3185)\nTidy the import of packages and remove unnecessary prefixes (#3186) (#3187)\nRefactor src/JuMP.jl by moving methods into more relevant files (#3188)\nFix docstring of Model not appearing in the documentation (#3198)","category":"page"},{"location":"changelog/#Version-1.6.0-(January-1,-2023)","page":"Release notes","title":"Version 1.6.0 (January 1, 2023)","text":"","category":"section"},{"location":"changelog/#Added-17","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added a result keyword argument to solution_summary to allow summarizing models with multiple solutions (#3138)\nAdded relax_with_penalty!, which is a useful tool when debugging infeasible models (#3140)\nAdded has_start_value (#3157)\nAdded support for HermitianPSDCone in constraints (#3154)","category":"page"},{"location":"changelog/#Fixed-23","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed promotion of complex expressions (#3150) (#3164)","category":"page"},{"location":"changelog/#Other-22","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added Benders tutorial with in-place resolves (#3145)\nAdded more Tips and tricks for linear programs (#3144) (#3163)\nClarified documentation that start can depend on the indices of a variable container (#3148)\nReplace instances of length and size by the recommended eachindex and axes (#3149)\nAdded a warning explaining why the model is dirty when accessing solution results from a modified model (#3156)\nClarify documentation that PSD ensures a symmetric matrix (#3159)\nMaintenance of the JuMP test suite (#3146) (#3158) (#3162)","category":"page"},{"location":"changelog/#Version-1.5.0-(December-8,-2022)","page":"Release notes","title":"Version 1.5.0 (December 8, 2022)","text":"","category":"section"},{"location":"changelog/#Added-18","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Add support for complex-valued variables:\nHermitianPSDCone (#3109)\nComplexPlane and ComplexVariable (#3134)\nAdd support for MOI.OptimizerWithAttributes in set_optimizer_attribute and get_optimizer_attribute (#3129)","category":"page"},{"location":"changelog/#Fixed-24","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed error message for vectorized interval constraints (#3123)\nFixed passing AbstractString to set_optimizer_attribute (#3127)","category":"page"},{"location":"changelog/#Other-23","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Update package versions used in docs (#3119) (#3133) (#3139)\nFixed output of diet tutorial (#3120)\nExplain how to use Dates.period in set_time_limit_sec (#3121)\nUpdate to JuliaFormatter v1.0.15 (#3130)\nFixed HTTP server example in web_app.jl (#3131)\nUpdate docs to build with Documenter#master (#3094)\nAdd tests for LinearAlgebra operations (#3132)\nTidy these release notes (#3135)\nAdded documentation for Complex number support (#3141)\nRemoved the \"workforce scheduling\" and \"steelT3\" tutorials (#3143)","category":"page"},{"location":"changelog/#Version-1.4.0-(October-29,-2022)","page":"Release notes","title":"Version 1.4.0 (October 29, 2022)","text":"","category":"section"},{"location":"changelog/#Added-19","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added Containers.rowtable which converts a container into a vector of NamedTuples to support the Tables.jl interface. This simplifies converting Containers.DenseAxisArray and Containers.SparseAxisArray objects into tabular forms such as a DataFrame (#3104)\nAdded a new method to Containers.container so that index names are passed to the container (#3088)","category":"page"},{"location":"changelog/#Fixed-25","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug in copy_to(dest::Model, src::MOI.ModelLike) when src has nonlinear components (#3101)\nFixed the printing of (-1.0 + 0.0im) coefficients in complex expressions (#3112)\nFixed a parsing bug in nonlinear expressions with generator statements that contain multiple for statements (#3116)","category":"page"},{"location":"changelog/#Other-24","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Converted the multi-commodity flow tutorial to use an SQLite database (#3098)\nFixed a number of typos in the documentation (#3103) (#3107) (#3018)\nImproved various style aspects of the PDF documentation (#3095) (#3098) (#3102)","category":"page"},{"location":"changelog/#Version-1.3.1-(September-28,-2022)","page":"Release notes","title":"Version 1.3.1 (September 28, 2022)","text":"","category":"section"},{"location":"changelog/#Fixed-26","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed a performance issue in relax_integrality (#3087)\nFixed the type stability of operators with Complex arguments (#3072)\nFixed a bug which added additional +() terms to some nonlinear expressions (#3091)\nFixed potential method ambiguities with AffExpr and QuadExpr objects (#3092)","category":"page"},{"location":"changelog/#Other-25","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added vale as a linter for the documentation (#3080)\nAdded a tutorial on debugging JuMP models (#3043)\nFixed a number of typos in the documentation (#3079) (#3083)\nMany other small tweaks to the documentation (#3068) (#3073) (#3074) (#3075) (#3076) (#3077) (#3078) (#3081) (#3082) (#3084) (#3085) (#3089)","category":"page"},{"location":"changelog/#Version-1.3.0-(September-5,-2022)","page":"Release notes","title":"Version 1.3.0 (September 5, 2022)","text":"","category":"section"},{"location":"changelog/#Added-20","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Support slicing in SparseAxisArray (#3031)","category":"page"},{"location":"changelog/#Fixed-27","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug introduced in v1.2.0 that prevented DenseAxisArrays with Vector keys (#3064)","category":"page"},{"location":"changelog/#Other-26","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Released the JuMP logos under the CC BY 4.0 license (#3063)\nMinor tweaks to the documentation (#3054) (#3056) (#3057) (#3060) (#3061) (#3065)\nImproved code coverage of a number of files (#3048) (#3049) (#3050) (#3051) (#3052) (#3053) (#3058) (#3059)","category":"page"},{"location":"changelog/#Version-1.2.1-(August-22,-2022)","page":"Release notes","title":"Version 1.2.1 (August 22, 2022)","text":"","category":"section"},{"location":"changelog/#Fixed-28","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug when parsing two-sided nonlinear constraints (#3045)","category":"page"},{"location":"changelog/#Version-1.2.0-(August-16,-2022)","page":"Release notes","title":"Version 1.2.0 (August 16, 2022)","text":"","category":"section"},{"location":"changelog/#Breaking-2","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"This is a large minor release because it significantly refactors the internal code for handling nonlinear programs to use the MathOptInterface.Nonlinear submodule that was introduced in MathOptInterface v1.3.0. As a consequence, the internal datastructure in model.nlp_data has been removed, as has the JuMP._Derivatives submodule. Despite the changes, the public API for nonlinear programming has not changed, and any code that uses only the public API and that worked with v1.1.1 will continue to work with v1.2.0.","category":"page"},{"location":"changelog/#Added-21","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added all_constraints(model; include_variable_in_set_constraints) which simplifies returning a list of all constraint indices in the model.\nAdded the ability to delete nonlinear constraints via delete(::Model, ::NonlinearConstraintRef).\nAdded the ability to provide an explicit Hessian for a multivariate user-defined function.\nAdded support for querying the primal value of a nonlinear constraint via value(::NonlinearConstraintRef)","category":"page"},{"location":"changelog/#Fixed-29","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug in Containers.DenseAxisArray so that it now supports indexing with keys that hash to the same value, even if they are different types, for example, Int32 and Int64.\nFixed a bug printing the model when the solver does not support MOI.Name.","category":"page"},{"location":"changelog/#Other-27","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added a constraint programming formulation to the Sudoku tutorial.\nAdded newly supported solvers Pajarito, Clarabel, and COPT to the installation table.\nFixed a variety of other miscellaneous issues in the documentation.","category":"page"},{"location":"changelog/#Version-1.1.1-(June-14,-2022)","page":"Release notes","title":"Version 1.1.1 (June 14, 2022)","text":"","category":"section"},{"location":"changelog/#Other-28","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed problem displaying LaTeX in the documentation\nMinor updates to the style guide\nUpdated to MOI v1.4.0 in the documentation","category":"page"},{"location":"changelog/#Version-1.1.0-(May-25,-2022)","page":"Release notes","title":"Version 1.1.0 (May 25, 2022)","text":"","category":"section"},{"location":"changelog/#Added-22","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added num_constraints(::Model; count_variable_in_set_constraints) to simplify the process of counting the number of constraints in a model\nAdded VariableRef(::ConstraintRef) for querying the variable associated with a bound or integrality constraint.\nAdded set_normalized_coefficients for modifying the variable coefficients of a vector-valued constraint.\nAdded set_string_names_on_creation to disable creating String names for variables and constraints. This can improve performance.","category":"page"},{"location":"changelog/#Fixed-30","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug passing nothing to the start keyword of @variable","category":"page"},{"location":"changelog/#Other-29","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"New tutorials:\nSensitivity analysis of a linear program\nServing web apps\nMinimal ellipse SDP tutorial refactored and improved\nDocs updated to the latest version of each package\nLots of minor fixes and improvements to the documentation","category":"page"},{"location":"changelog/#Version-1.0.0-(March-24,-2022)","page":"Release notes","title":"Version 1.0.0 (March 24, 2022)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Read more about this release, along with an acknowledgement of all the contributors in our JuMP 1.0.0 is released blog post.","category":"page"},{"location":"changelog/#Breaking-3","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"The previously deprecated functions (v0.23.0, v0.23.1) have been removed. Deprecation was to improve consistency of function names:\nnum_nl_constraints (see num_nonlinear_constraints)\nall_nl_constraints (see all_nonlinear_constraints)\nadd_NL_expression (see add_nonlinear_expression)\nset_NL_objective  (see set_nonlinear_objective)\nadd_NL_constraint (see add_nonlinear_constraint)\nnl_expr_string (see nonlinear_expr_string)\nnl_constraint_string (see nonlinear_constraint_string)\nSymMatrixSpace (see SymmetricMatrixSpace)\nThe unintentionally exported variable JuMP.op_hint has been renamed to the unexported JuMP._OP_HINT","category":"page"},{"location":"changelog/#Fixed-31","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug writing .nl files\nFixed a bug broadcasting SparseAxisArrays","category":"page"},{"location":"changelog/#Version-0.23.2-(March-14,-2022)","page":"Release notes","title":"Version 0.23.2 (March 14, 2022)","text":"","category":"section"},{"location":"changelog/#Added-23","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added relative_gap to solution_summary\nregister now throws an informative error if the function is not differentiable using ForwardDiff. In some cases, the check in register will encounter a false negative, and the informative error will be thrown at run-time. This usually happens when the function is non-differentiable in a subset of the domain.","category":"page"},{"location":"changelog/#Fixed-32","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed a scoping issue when extending the container keyword of containers","category":"page"},{"location":"changelog/#Other-30","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Docs updated to the latest version of each package","category":"page"},{"location":"changelog/#Version-0.23.1-(March-2,-2022)","page":"Release notes","title":"Version 0.23.1 (March 2, 2022)","text":"","category":"section"},{"location":"changelog/#Deprecated","page":"Release notes","title":"Deprecated","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"nl_expr_string and nl_constraint_string have been renamed to nonlinear_expr_string and nonlinear_constraint_string. The old methods still exist with deprecation warnings. This change should impact very few users because to call them you must rely on private internals of the nonlinear API. Users are encouraged to use sprint(show, x) instead, where x is the nonlinear expression or constraint of interest.","category":"page"},{"location":"changelog/#Added-24","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added support for Base.abs2(x) where x is a variable or affine expression. This is mainly useful for complex-valued constraints.","category":"page"},{"location":"changelog/#Fixed-33","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed addition of complex and real affine expressions\nFixed arithmetic for Complex-valued quadratic expressions\nFixed variable bounds passed as Rational{Int}(Inf)\nFixed printing of the coefficient (0 + 1im)\nFixed a bug when solution_summary is called prior to optimize!","category":"page"},{"location":"changelog/#Version-0.23.0-(February-25,-2022)","page":"Release notes","title":"Version 0.23.0 (February 25, 2022)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"JuMP v0.23.0 is a breaking release. It is also a release-candidate for JuMP v1.0.0. That is, if no issues are found with the v0.23.0 release, then it will be re-tagged as v1.0.0.","category":"page"},{"location":"changelog/#Breaking-4","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Julia 1.6 is now the minimum supported version\nMathOptInterface has been updated to v1.0.0\nAll previously deprecated functionality has been removed\nPrintMode, REPLMode and IJuliaMode have been removed in favor of the MIME types MIME\"text/plain\" and MIME\"text/latex\". Replace instances of ::Type{REPLMode} with ::MIME\"text/plain\", REPLMode with MIME(\"text/plain\"), ::Type{IJuliaMode} with ::MIME\"text/latex\", and IJuliaMode with MIME(\"text/latex\").\nFunctions containing the nl_ acronym have been renamed to the more explicit nonlinear_. For example, num_nl_constraints is now num_nonlinear_constraints and set_NL_objective is now set_nonlinear_objective. Calls to the old functions throw an error explaining the new name.\nSymMatrixSpace has been renamed to SymmetricMatrixSpace","category":"page"},{"location":"changelog/#Added-25","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added nonlinear_dual_start_value and set_nonlinear_dual_start_value\nAdded preliminary support for Complex coefficient types","category":"page"},{"location":"changelog/#Fixed-34","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug in solution_summary","category":"page"},{"location":"changelog/#Other-31","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"MILP examples have been migrated from GLPK to HiGHS\nFixed various typos\nImproved section on setting constraint start values","category":"page"},{"location":"changelog/#Troubleshooting-problems-when-updating","page":"Release notes","title":"Troubleshooting problems when updating","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"If you experience problems when updating, you are likely using previously deprecated functionality. (By default, Julia does not warn when you use deprecated features.)","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"To find the deprecated features you are using, start Julia with --depwarn=yes:","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"$ julia --depwarn=yes","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Then install JuMP v0.22.3:","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"julia> using Pkg\njulia> pkg\"add JuMP@0.22.3\"","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"And then run your code. Apply any suggestions, or search the release notes below for advice on updating a specific deprecated feature.","category":"page"},{"location":"changelog/#Version-0.22.3-(February-10,-2022)","page":"Release notes","title":"Version 0.22.3 (February 10, 2022)","text":"","category":"section"},{"location":"changelog/#Fixed-35","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed a reproducibility issue in the TSP tutorial\nFixed a reproducibility issue in the max_cut_sdp tutorial\nFixed a bug broadcasting an empty SparseAxisArray","category":"page"},{"location":"changelog/#Other-32","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added a warning and improved documentation for the modify-then-query case\nFixed a typo in the docstring of RotatedSecondOrderCone\nAdded Aqua.jl as a check for code health\nAdded introductions to each section of the tutorials\nImproved the column generation and Benders decomposition tutorials\nUpdated documentation to MOI v0.10.8\nUpdated JuliaFormatter to v0.22.2","category":"page"},{"location":"changelog/#Version-0.22.2-(January-10,-2022)","page":"Release notes","title":"Version 0.22.2 (January 10, 2022)","text":"","category":"section"},{"location":"changelog/#Added-26","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"The function all_nl_constraints now returns all nonlinear constraints in a model\nstart_value and set_start_value can now be used to get and set the primal start for constraint references\nPlural macros now return a tuple containing the elements that were defined instead of nothing\nAnonymous variables are now printed as _[i] where i is the index of the variable instead of noname. Calling name(x) still returns \"\" so this is non-breaking.","category":"page"},{"location":"changelog/#Fixed-36","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed handling of min and max in nonlinear expressions\nCartesianIndex is no longer allowed as a key for DenseAxisArrays.","category":"page"},{"location":"changelog/#Other-33","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Improved the performance of GenericAffExpr\nAdded a tutorial on the Travelling Salesperson Problem\nAdded a tutorial on querying the Hessian of a nonlinear program\nAdded documentation on using custom solver binaries.","category":"page"},{"location":"changelog/#Version-0.22.1-(November-29,-2021)","page":"Release notes","title":"Version 0.22.1 (November 29, 2021)","text":"","category":"section"},{"location":"changelog/#Added-27","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Export OptimizationSense enum, with instances: MIN_SENSE, MAX_SENSE, and FEASIBILITY_SENSE\nAdd Base.isempty(::Model) to match Base.empty(::Model)","category":"page"},{"location":"changelog/#Fixed-37","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix bug in container with tuples as indices\nFix bug in set_time_limit_sec","category":"page"},{"location":"changelog/#Other-34","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Add tutorial \"Design patterns for larger models\"\nRemove release notes section from PDF\nGeneral edits of the documentation and error messages","category":"page"},{"location":"changelog/#Version-0.22.0-(November-10,-2021)","page":"Release notes","title":"Version 0.22.0 (November 10, 2021)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"JuMP v0.22 is a breaking release","category":"page"},{"location":"changelog/#Breaking-5","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"JuMP 0.22 contains a number of breaking changes. However, these should be invisible for the majority of users. You will mostly encounter these breaking changes if you: wrote a JuMP extension, accessed backend(model), or called @SDconstraint.","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"The breaking changes are as follows:","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"MathOptInterface has been updated to v0.10.4. For users who have interacted with the MOI backend, this contains a large number of breaking changes. Read the MathOptInterface release notes for more details.\nThe bridge_constraints keyword argument to Model and set_optimizer has been renamed add_bridges to reflect that more thing were bridged than just constraints.\nThe backend(model) field now contains a concrete instance of a MOI.Utilities.CachingOptimizer instead of one with an abstractly typed optimizer field. In most cases, this will lead to improved performance. However, calling set_optimizer after backend invalidates the old backend. For example:\nmodel = Model()\nb = backend(model)\nset_optimizer(model, GLPK.Optimizer)\n@variable(model, x)\n# b is not updated with `x`! Get a new b by calling `backend` again.\nnew_b = backend(model)\nAll usages of @SDconstraint are deprecated. The new syntax is @constraint(model, X >= Y, PSDCone()).\nCreating a DenseAxisArray with a Number as an axis will now display a warning. This catches a common error in which users write @variable(model, x[length(S)]) instead of @variable(model, x[1:length(S)]).\nThe caching_mode argument to Model, for example, Model(caching_mode = MOIU.MANUAL) mode has been removed. For more control over the optimizer, use direct_model instead.\nThe previously deprecated lp_objective_perturbation_range and lp_rhs_perturbation_range functions have been removed. Use lp_sensitivity_report instead.\nThe .m fields of NonlinearExpression and NonlinearParameter have been renamed to .model.\nInfinite variable bounds are now ignored. Thus, @variable(model, x <= Inf) will show has_upper_bound(x) == false. Previously, these bounds were passed through to the solvers which caused numerical issues for solvers expecting finite bounds.\nThe variable_type and constraint_type functions were removed. This should only affect users who previously wrote JuMP extensions. The functions can be deleted without consequence.\nThe internal functions moi_mode, moi_bridge_constraints, moi_add_constraint, and moi_add_to_function_constant are no longer exported.\nThe un-used method Containers.generate_container has been deleted.\nThe Containers API has been refactored, and _build_ref_sets is now public as Containers.build_ref_sets.\nThe parse_constraint_ methods for extending @constraint at parse time have been refactored in a breaking way. Consult the Extensions documentation for more details and examples.","category":"page"},{"location":"changelog/#Added-28","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"The TerminationStatusCode and ResultStatusCode enums are now exported by JuMP. Prefer termination_status(model) == OPTIMAL instead of == MOI.OPTIMAL, although the MOI. prefix way still works.\nCopy a x::DenseAxisArray to an Array by calling Array(x).\nNonlinearExpression is now a subtype of AbstractJuMPScalar\nConstraints such as @constraint(model, x + 1 in MOI.Integer()) are now supported.\nprimal_feasibility_report now accepts a function as the first argument.\nScalar variables @variable(model, x[1:2] in MOI.Integer()) creates two variables, both of which are constrained to be in the set MOI.Integer.\nConic constraints can now be specified as inequalities under a different partial ordering. So @constraint(model, x - y in MOI.Nonnegatives()) can now be written as @constraint(model, x >= y, MOI.Nonnegatives()).\nNames are now set for vectorized constraints.","category":"page"},{"location":"changelog/#Fixed-38","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed a performance issue when show was called on a SparseAxisArray with a large number of elements.\nFixed a bug displaying barrier and simplex iterations in solution_summary.\nFixed a bug by implementing hash for DenseAxisArray and SparseAxisArray.\nNames are now only set if the solver supports them. Previously, this prevented solvers such as Ipopt from being used with direct_model.\nMutableArithmetics.Zero is converted into a 0.0 before being returned to the user. Previously, some calls to @expression would return the undocumented MutableArithmetics.Zero() object. One example is summing over an empty set @expression(model, sum(x[i] for i in 1:0)). You will now get 0.0 instead.\nAffExpr and QuadExpr can now be used with == 0 instead of iszero. This fixes a number of issues relating to Julia standard libraries such as LinearAlgebra and SparseArrays.\nFixed a bug when registering a user-defined function with splatting.","category":"page"},{"location":"changelog/#Other-35","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"The documentation is now available as a PDF.\nThe documentation now includes a full copy of the MathOptInterface documentation to make it easy to link concepts between the docs. (The MathOptInterface documentation has also been significantly improved.)\nThe documentation contains a large number of improvements and clarifications on a range of topics. Thanks to @sshin23, @DilumAluthge, and @jlwether.\nThe documentation is now built with Julia 1.6 instead of 1.0.\nVarious error messages have been improved to be more readable.","category":"page"},{"location":"changelog/#Version-0.21.10-(September-4,-2021)","page":"Release notes","title":"Version 0.21.10 (September 4, 2021)","text":"","category":"section"},{"location":"changelog/#Added-29","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added add_NL_expression\nadd_NL_xxx functions now support AffExpr and QuadExpr as terms","category":"page"},{"location":"changelog/#Fixed-39","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug in solution_summary\nFixed a bug in relax_integrality","category":"page"},{"location":"changelog/#Other-36","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Improved error message in lp_sensitivity_report","category":"page"},{"location":"changelog/#Version-0.21.9-(August-1,-2021)","page":"Release notes","title":"Version 0.21.9 (August 1, 2021)","text":"","category":"section"},{"location":"changelog/#Added-30","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Containers now support arbitrary container types by passing the type to the container keyword and overloading Containers.container.\nis_valid now supports nonlinear constraints\nAdded unsafe_backend for querying the inner-most optimizer of a JuMP model.\nNonlinear parameters now support the plural @NLparameters macro.\nContainers (for example, DenseAxisArray) can now be used in vector-valued constraints.","category":"page"},{"location":"changelog/#Other-37","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Various improvements to the documentation.","category":"page"},{"location":"changelog/#Version-0.21.8-(May-8,-2021)","page":"Release notes","title":"Version 0.21.8 (May 8, 2021)","text":"","category":"section"},{"location":"changelog/#Added-31","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"The @constraint macro is now extendable in the same way as @variable.\nAffExpr and QuadExpr can now be used in nonlinear macros.","category":"page"},{"location":"changelog/#Fixed-40","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug in lp_sensitivity_report.\nFixed an inference issue when creating empty SparseAxisArrays.","category":"page"},{"location":"changelog/#Version-0.21.7-(April-12,-2021)","page":"Release notes","title":"Version 0.21.7 (April 12, 2021)","text":"","category":"section"},{"location":"changelog/#Added-32","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added primal_feasibility_report, which can be used to check whether a primal point satisfies primal feasibility.\nAdded coefficient, which returns the coefficient associated with a variable in affine and quadratic expressions.\nAdded copy_conflict, which returns the IIS of an infeasible model.\nAdded solution_summary, which returns (and prints) a struct containing a summary of the solution.\nAllow AbstractVector in vector constraints instead of just Vector.\nAdded latex_formulation(model) which returns an object representing the latex formulation of a model. Use print(latex_formulation(model)) to print the formulation as a string.\nUser-defined functions in nonlinear expressions are now automatically registered to aid quick model prototyping. However, a warning is printed to encourage the manual registration.\nDenseAxisArray's now support broadcasting over multiple arrays.\nContainer indices can now be iterators of Base.SizeUnknown.","category":"page"},{"location":"changelog/#Fixed-41","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed bug in rad2deg and deg2rad in nonlinear expressions.\nFixed a MethodError bug in Containers when forcing container type.\nAllow partial slicing of a DenseAxisArray, resolving an issue from 2014.\nFixed a bug printing variable names in IJulia.\nEnding an IJulia cell with model now prints a summary of the model (like in the REPL) not the latex formulation. Use print(model) to print the latex formulation.\nFixed a bug when copying models containing nested arrays.","category":"page"},{"location":"changelog/#Other-38","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Tutorials are now part of the documentation, and more refactoring has taken place.\nAdded JuliaFormatter added as a code formatter.\nAdded some precompilation statements to reduce initial latency.\nVarious improvements to error messages to make them more helpful.\nImproved performance of value(::NonlinearExpression).\nImproved performance of fix(::VariableRef).","category":"page"},{"location":"changelog/#Version-0.21.6-(January-29,-2021)","page":"Release notes","title":"Version 0.21.6 (January 29, 2021)","text":"","category":"section"},{"location":"changelog/#Added-33","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added support for skew symmetric variables via @variable(model, X[1:2, 1:2] in SkewSymmetricMatrixSpace()).\nlp_sensitivity_report has been added which significantly improves the performance of querying the sensitivity summary of an LP. lp_objective_perturbation_range and lp_rhs_perturbation_range are deprecated.\nDual warm-starts are now supported with set_dual_start_value and dual_start_value.\n∈ (\\in<tab>) can now be used in macros instead of = or in.\nUse haskey(model::Model, key::Symbol) to check if a name key is registered in a model.\nAdded unregister(model::Model, key::Symbol) to unregister a name key from model.\nAdded callback_node_status for use in callbacks.\nAdded print_bridge_graph to visualize the bridging graph generated by MathOptInterface.\nImproved error message for containers with duplicate indices.","category":"page"},{"location":"changelog/#Fixed-42","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Various fixes to pass tests on Julia 1.6.\nFixed a bug in the printing of nonlinear expressions in IJulia.\nFixed a bug when nonlinear expressions are passed to user-defined functions.\nSome internal functions that were previously exported are now no longer exported.\nFixed a bug when relaxing a fixed binary variable.\nFixed a StackOverflowError that occurred when SparseAxisArrays had a large number of elements.\nRemoved an unnecessary type assertion in list_of_constraint_types.\nFixed a bug when copying models with registered expressions.","category":"page"},{"location":"changelog/#Other-39","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"The documentation has been significantly overhauled. It now has distinct sections for the manual, API reference, and examples. The existing examples in /examples have now been moved to /docs/src/examples and rewritten using Literate.jl, and they are now included in the documentation.\nJuliaFormatter has been applied to most of the codebase. This will continue to roll out over time, as we fix upstream issues in the formatter, and will eventually become compulsory.\nThe root cause of a large number of method invalidations has been resolved.\nWe switched continuous integration from Travis and Appveyor to GitHub Actions.","category":"page"},{"location":"changelog/#Version-0.21.5-(September-18,-2020)","page":"Release notes","title":"Version 0.21.5 (September 18, 2020)","text":"","category":"section"},{"location":"changelog/#Fixed-43","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed deprecation warnings\nThrow DimensionMismatch for incompatibly sized functions and sets\nUnify treatment of keys(x) on JuMP containers","category":"page"},{"location":"changelog/#Version-0.21.4-(September-14,-2020)","page":"Release notes","title":"Version 0.21.4 (September 14, 2020)","text":"","category":"section"},{"location":"changelog/#Added-34","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Add debug info when adding unsupported constraints\nAdd relax_integrality for solving continuous relaxation\nAllow querying constraint conflicts","category":"page"},{"location":"changelog/#Fixed-44","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Dispatch on Real for MOI.submit\nImplement copy for CustomSet in tests\nDon't export private macros\nFix invalid assertion in nonlinear\nError if constraint has NaN right-hand side\nImprove speed of tests\nLots of work modularizing files in /test\nImprove line numbers in macro error messages\nPrint nonlinear subexpressions\nVarious documentation updates\nDependency updates:\nDatastructures 0.18\nMathOptFormat v0.5\nPrep for MathOptInterface 0.9.15","category":"page"},{"location":"changelog/#Version-0.21.3-(June-18,-2020)","page":"Release notes","title":"Version 0.21.3 (June 18, 2020)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added Special Order Sets (SOS1 and SOS2) to JuMP with default weights to ease the creation of such constraints (#2212).\nAdded functions simplex_iterations, barrier_iterations and node_count (#2201).\nAdded function reduced_cost (#2205).\nImplemented callback_value for affine and quadratic expressions (#2231).\nSupport MutableArithmetics.Zero in objective and constraints (#2219).\nDocumentation improvements:\nMention tutorials in the docs (#2223).\nUpdate COIN-OR links (#2242).\nExplicit link to the documentation of MOI.FileFormats (#2253).\nTypo fixes (#2261).\nContainers improvements:\nFix Base.map for DenseAxisArray (#2235).\nThrow BoundsError if number of indices is incorrect for DenseAxisArray and SparseAxisArray (#2240).\nExtensibility improvements:\nImplement a set_objective method fallback that redirects to set_objective_sense and set_objective_function (#2247).\nAdd parse_constraint method with arbitrary number of arguments (#2051).\nAdd parse_constraint_expr and parse_constraint_head (#2228).","category":"page"},{"location":"changelog/#Version-0.21.2-(April-2,-2020)","page":"Release notes","title":"Version 0.21.2 (April 2, 2020)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added relative_gap() to access MOI.RelativeGap() attribute (#2199).\nDocumentation fixes:\nAdded link to source for docstrings in the documentation (#2207).\nAdded docstring for @variables macro (#2216).\nTypo fixes (#2177, #2184, #2182).\nImplementation of methods for Base functions:\nImplemented Base.empty! for JuMP.Model (#2198).\nImplemented Base.conj for JuMP scalar types (#2209).","category":"page"},{"location":"changelog/#Fixed-45","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixed sum of expression with scalar product in macro (#2178).\nFixed writing of nonlinear models to MathOptFormat (#2181).\nFixed construction of empty SparseAxisArray (#2179).\nFixed constraint with zero function (#2188).","category":"page"},{"location":"changelog/#Version-0.21.1-(Feb-18,-2020)","page":"Release notes","title":"Version 0.21.1 (Feb 18, 2020)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Improved the clarity of the with_optimizer deprecation warning.","category":"page"},{"location":"changelog/#Version-0.21.0-(Feb-16,-2020)","page":"Release notes","title":"Version 0.21.0 (Feb 16, 2020)","text":"","category":"section"},{"location":"changelog/#Breaking-6","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Deprecated with_optimizer (#2090, #2084, #2141). You can replace with_optimizer by either nothing, optimizer_with_attributes or a closure:\nreplace with_optimizer(Ipopt.Optimizer) by Ipopt.Optimizer.\nreplace with_optimizer(Ipopt.Optimizer, max_cpu_time=60.0) by optimizer_with_attributes(Ipopt.Optimizer, \"max_cpu_time\" => 60.0).\nreplace with_optimizer(Gurobi.Optimizer, env) by () -> Gurobi.Optimizer(env).\nreplace with_optimizer(Gurobi.Optimizer, env, Presolve=0) by optimizer_with_attributes(() -> Gurobi.Optimizer(env), \"Presolve\" => 0).\nalternatively to optimizer_with_attributes, you can also set the attributes separately with set_optimizer_attribute.\nRenamed set_parameter and set_parameters to set_optimizer_attribute and set_optimizer_attributes (#2150).\nBroadcast should now be explicit inside macros. @SDconstraint(model, x >= 1) and @constraint(model, x + 1 in SecondOrderCone()) now throw an error instead of broadcasting 1 along the dimension of x (#2107).\n@SDconstraint(model, x >= 0) is now equivalent to @constraint(model, x in PSDCone()) instead of @constraint(model, (x .- 0) in PSDCone()) (#2107).\nThe macros now create the containers with map instead of for loops, as a consequence, containers created by @expression can now have any element type and containers of constraint references now have concrete element types when possible. This fixes a long-standing issue where @expression could only be used to generate a collection of linear expressions. Now it works for quadratic expressions as well (#2070).\nCalling deepcopy(::AbstractModel) now throws an error.\nThe constraint name is now printed in the model string (#2108).","category":"page"},{"location":"changelog/#Added-35","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Added support for solver-independent and solver-specific callbacks (#2101).\nAdded write_to_file and read_from_file, supported formats are CBF, LP, MathOptFormat, MPS and SDPA (#2114).\nAdded support for complementarity constraints (#2132).\nAdded support for indicator constraints (#2092).\nAdded support for querying multiple solutions with the result keyword (#2100).\nAdded support for constraining variables on creation (#2128).\nAdded method delete that deletes a vector of variables at once if it is supported by the underlying solver (#2135).\nThe arithmetic between JuMP expression has be refactored into the MutableArithmetics package (#2107).\nImproved error on complex values in NLP (#1978).\nAdded an example of column generation (#2010).","category":"page"},{"location":"changelog/#Fixed-46","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Incorrect coefficients generated when using Symmetric variables (#2102)","category":"page"},{"location":"changelog/#Version-0.20.1-(Oct-18,-2019)","page":"Release notes","title":"Version 0.20.1 (Oct 18, 2019)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Add sections on @variables and @constraints in the documentation (#2062).\nFixed product of sparse matrices for Julia v1.3 (#2063).\nAdded set_objective_coefficient to modify the coefficient of a linear term of the objective function (#2008).\nAdded set_time_limit_sec, unset_time_limit_sec and time_limit_sec to set and query the time limit for the solver in seconds (#2053).","category":"page"},{"location":"changelog/#Version-0.20.0-(Aug-24,-2019)","page":"Release notes","title":"Version 0.20.0 (Aug 24, 2019)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Documentation updates.\nNumerous bug fixes.\nBetter error messages (#1977, #1978, #1997, #2017).\nPerformance improvements (#1947, #2032).\nAdded LP sensitivity summary functions lp_objective_perturbation_range and lp_rhs_perturbation_range (#1917).\nAdded functions dual_objective_value, raw_status and set_parameter.\nAdded function set_objective_coefficient to modify the coefficient of a linear term of the objective (#2008).\nAdded functions set_normalized_rhs, normalized_rhs, and add_to_function_constant to modify and get the constant part of a constraint (#1935, #1960).\nAdded functions set_normalized_coefficient and normalized_coefficient to modify and get the coefficient of a linear term of a constraint (#1935, #1960).\nNumerous other improvements in MOI 0.9, see the NEWS.md file of MOI for more details.","category":"page"},{"location":"changelog/#Version-0.19.2-(June-8,-2019)","page":"Release notes","title":"Version 0.19.2 (June 8, 2019)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix a bug in derivatives that could arise in models with nested nonlinear subexpressions.","category":"page"},{"location":"changelog/#Version-0.19.1-(May-12,-2019)","page":"Release notes","title":"Version 0.19.1 (May 12, 2019)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Usability and performance improvements.\nBug fixes.","category":"page"},{"location":"changelog/#Version-0.19.0-(February-15,-2019)","page":"Release notes","title":"Version 0.19.0 (February 15, 2019)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"JuMP 0.19 contains significant breaking changes.","category":"page"},{"location":"changelog/#Breaking-7","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"JuMP's abstraction layer for communicating with solvers changed from MathProgBase (MPB) to MathOptInterface (MOI). MOI addresses many longstanding design issues. (See @mlubin's slides from JuMP-dev 2018.) JuMP 0.19 is compatible only with solvers that have been updated for MOI. See the installation guide for a list of solvers that have and have not yet been updated.\nMost solvers have been renamed to PackageName.Optimizer. For example, GurobiSolver() is now Gurobi.Optimizer.\nSolvers are no longer added to a model via Model(solver = XXX(kwargs...)). Instead use Model(with_optimizer(XXX, kwargs...)). For example, Model(with_optimizer(Gurobi.Optimizer, OutputFlag=0)).\nJuMP containers (for example, the objects returned by @variable) have been redesigned. Containers.SparseAxisArray replaces JuMPDict, JuMPArray was rewritten (inspired by AxisArrays) and renamed Containers.DenseAxisArray, and you can now request a container type with the container= keyword to the macros. See the corresponding documentation for more details.\nThe statuses returned by solvers have changed. See the possible status values here. The MOI statuses are much richer than the MPB statuses and can be used to distinguish between previously indistinguishable cases (for example, did the solver have a feasible solution when it stopped because of the time limit?).\nStarting values are separate from result values. Use value to query the value of a variable in a solution. Use start_value and set_start_value to get and set an initial starting point provided to the solver. The solutions from previous solves are no longer automatically set as the starting points for the next solve.\nThe data structures for affine and quadratic expressions AffExpr and QuadExpr have changed. Internally, terms are stored in dictionaries instead of lists. Duplicate coefficients can no longer exist. Accessors and iteration methods have changed.\nJuMPNLPEvaluator no longer includes the linear and quadratic parts of the model in the evaluation calls. These are now handled separately to allow NLP solvers that support various types of constraints.\nJuMP solver-independent callbacks have been replaced by solver-specific callbacks. See your favorite solver for more details. (See the note below: No solver-specific callbacks are implemented yet.)\nThe norm() syntax is no longer recognized inside macros. Use the SecondOrderCone() set instead.\nJuMP no longer performs automatic transformation between special quadratic forms and second-order cone constraints. Support for these constraint classes depends on the solver.\nThe symbols :Min and :Max are no longer used as optimization senses. Instead, JuMP uses the OptimizationSense enum from MathOptInterface. @objective(model, Max, ...), @objective(model, Min, ...), @NLobjective(model, Max, ...), and @objective(model, Min, ...) remain valid, but @objective(m, :Max, ...) is no longer accepted.\nThe sign conventions for duals has changed in some cases for consistency with conic duality (see the documentation). The shadow_price helper method returns duals with signs that match conventional LP interpretations of dual values as sensitivities of the objective value to relaxations of constraints.\n@constraintref is no longer defined. Instead, create the appropriate container to hold constraint references manually. For example,\nconstraints = Dict() # Optionally, specify types for improved performance.\nfor i in 1:N\n  constraints[i] = @constraint(model, ...)\nend\nThe lowerbound, upperbound, and basename keyword arguments to the @variable macro have been renamed to lower_bound, upper_bound, and base_name, for consistency with JuMP's new style recommendations.\nWe rely on broadcasting syntax to apply accessors to collections of variables, for example, value.(x) instead of getvalue(x) for collections. (Use value(x) when x is a scalar object.)","category":"page"},{"location":"changelog/#Added-36","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Splatting (like f(x...)) is recognized in restricted settings in nonlinear expressions.\nSupport for deleting constraints and variables.\nThe documentation has been completely rewritten using docstrings and Documenter.\nSupport for modeling mixed conic and quadratic models (for example, conic models with quadratic objectives and bi-linear matrix inequalities).\nSignificantly improved support for modeling new types of constraints and for extending JuMP's macros.\nSupport for providing dual warm starts.\nImproved support for accessing solver-specific attributes (for example, the irreducible inconsistent subsystem).\nExplicit control of whether symmetry-enforcing constraints are added to PSD constraints.\nSupport for modeling exponential cones.\nSignificant improvements in internal code quality and testing.\nStyle and naming guidelines.\nDirect mode and manual mode provide explicit control over when copies of a model are stored or regenerated. See the corresponding documentation.","category":"page"},{"location":"changelog/#Regressions","page":"Release notes","title":"Regressions","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"There are known regressions from JuMP 0.18 that will be addressed in a future release (0.19.x or later):","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Performance regressions in model generation (issue). Please file an issue anyway if you notice a significant performance regression. We have plans to address a number of performance issues, but we might not be aware of all of them.\nFast incremental NLP solves are not yet reimplemented (issue).\nWe do not yet have an implementation of solver-specific callbacks.\nThe column generation syntax in @variable has been removed (that is, the objective, coefficients, and inconstraints keyword arguments). Support for column generation will be re-introduced in a future release.\nThe ability to solve the continuous relaxation (that is, via solve(model; relaxation = true)) is not yet reimplemented (issue).","category":"page"},{"location":"changelog/#Version-0.18.5-(December-1,-2018)","page":"Release notes","title":"Version 0.18.5 (December 1, 2018)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Support views in some derivative evaluation functions.\nImproved compatibility with PackageCompiler.","category":"page"},{"location":"changelog/#Version-0.18.4-(October-8,-2018)","page":"Release notes","title":"Version 0.18.4 (October 8, 2018)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix a bug in model printing on Julia 0.7 and 1.0.","category":"page"},{"location":"changelog/#Version-0.18.3-(October-1,-2018)","page":"Release notes","title":"Version 0.18.3 (October 1, 2018)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Add support for Julia v1.0 (Thanks @ExpandingMan)\nFix matrix expressions with quadratic functions (#1508)","category":"page"},{"location":"changelog/#Version-0.18.2-(June-10,-2018)","page":"Release notes","title":"Version 0.18.2 (June 10, 2018)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix a bug in second-order derivatives when expressions are present (#1319)\nFix a bug in @constraintref (#1330)","category":"page"},{"location":"changelog/#Version-0.18.1-(April-9,-2018)","page":"Release notes","title":"Version 0.18.1 (April 9, 2018)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix for nested tuple destructuring (#1193)\nPreserve internal model when relaxation=true (#1209)\nMinor bug fixes and updates for example","category":"page"},{"location":"changelog/#Version-0.18.0-(July-27,-2017)","page":"Release notes","title":"Version 0.18.0 (July 27, 2017)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Drop support for Julia 0.5.\nUpdate for ForwardDiff 0.5.\nMinor bug fixes.","category":"page"},{"location":"changelog/#Version-0.17.1-(June-9,-2017)","page":"Release notes","title":"Version 0.17.1 (June 9, 2017)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Use of constructconstraint! in @SDconstraint.\nMinor bug fixes.","category":"page"},{"location":"changelog/#Version-0.17.0-(May-27,-2017)","page":"Release notes","title":"Version 0.17.0 (May 27, 2017)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Breaking change: Mixing quadratic and conic constraints is no longer supported.\nBreaking change: The getvariable and getconstraint functions are replaced by indexing on the corresponding symbol. For instance, to access the variable with name x, one should now write m[:x] instead of getvariable(m, :x). As a consequence, creating a variable and constraint with the same name now triggers a warning, and accessing one of them afterwards throws an error. This change is breaking only in the latter case.\nAddition of the getobjectivebound function that mirrors the functionality of the MathProgBase getobjbound function except that it takes into account transformations performed by JuMP.\nMinor bug fixes.","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"The following changes are primarily of interest to developers of JuMP extensions:","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"The new syntax @constraint(model, expr in Cone) creates the constraint ensuring that expr is inside Cone. The Cone argument is passed to constructconstraint! which enables the call to the dispatched to an extension.\nThe @variable macro now calls constructvariable! instead of directly calling the Variable constructor. Extra arguments and keyword arguments passed to @variable are passed to constructvariable! which enables the call to be dispatched to an extension.\nRefactor the internal function conicdata (used build the MathProgBase conic model) into smaller sub-functions to make these parts reusable by extensions.","category":"page"},{"location":"changelog/#Version-0.16.2-(March-28,-2017)","page":"Release notes","title":"Version 0.16.2 (March 28, 2017)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Minor bug fixes and printing tweaks\nAddress deprecation warnings for Julia 0.6","category":"page"},{"location":"changelog/#Version-0.16.1-(March-7,-2017)","page":"Release notes","title":"Version 0.16.1 (March 7, 2017)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Better support for AbstractArray in JuMP (Thanks @tkoolen)\nMinor bug fixes","category":"page"},{"location":"changelog/#Version-0.16.0-(February-23,-2017)","page":"Release notes","title":"Version 0.16.0 (February 23, 2017)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Breaking change: JuMP no longer has a mechanism for selecting solvers by default (the previous mechanism was flawed and incompatible with Julia 0.6). Not specifying a solver before calling solve() will result in an error.\nBreaking change: User-defined functions are no longer global. The first argument to JuMP.register is now a JuMP Model object within whose scope the function will be registered. Calling JuMP.register without a Model now produces an error.\nBreaking change: Use the new JuMP.fix method to fix a variable to a value or to update the value to which a variable is fixed. Calling setvalue on a fixed variable now results in an error in order to avoid silent behavior changes. (Thanks @joaquimg)\nNonlinear expressions now print out similarly to linear/quadratic expressions (useful for debugging!)\nNew category keyword to @variable. Used for specifying categories of anonymous variables.\nCompatibility with Julia 0.6-dev.\nMinor fixes and improvements (Thanks @cossio, @ccoffrin, @blegat)","category":"page"},{"location":"changelog/#Version-0.15.1-(January-31,-2017)","page":"Release notes","title":"Version 0.15.1 (January 31, 2017)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Bugfix for @LinearConstraints and friends","category":"page"},{"location":"changelog/#Version-0.15.0-(December-22,-2016)","page":"Release notes","title":"Version 0.15.0 (December 22, 2016)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Julia 0.5.0 is the minimum required version for this release.\nDocument support for BARON solver\nEnable info callbacks in more states than before, for example, for recording solutions. New when argument to addinfocallback (#814, thanks @yeesian)\nImproved support for anonymous variables. This includes new warnings for potentially confusing use of the traditional non-anonymous syntax:\nWhen multiple variables in a model are given the same name\nWhen non-symbols are used as names, for example, @variable(m, x[1][1:N])\nImprovements in iterating over JuMP containers (#836, thanks @IssamT)\nSupport for writing variable names in .lp file output (Thanks @leethargo)\nSupport for querying duals to SDP problems (Thanks @blegat)\nThe comprehension syntax with curly braces sum{}, prod{}, and norm2{} has been deprecated in favor of Julia's native comprehension syntax sum(), prod() and norm() as previously announced. (For early adopters of the new syntax, norm2() was renamed to norm() without deprecation.)\nUnit tests rewritten to use Base.Test instead of FactCheck\nImproved support for operations with matrices of JuMP types (Thanks @ExpandingMan)\nThe syntax to halt a solver from inside a callback has changed from throw(CallbackAbort()) to return JuMP.StopTheSolver\nMinor bug fixes","category":"page"},{"location":"changelog/#Version-0.14.2-(December-12,-2016)","page":"Release notes","title":"Version 0.14.2 (December 12, 2016)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Allow singleton anonymous variables (includes bugfix)","category":"page"},{"location":"changelog/#Version-0.14.1-(September-12,-2016)","page":"Release notes","title":"Version 0.14.1 (September 12, 2016)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"More consistent handling of states in informational callbacks, includes a new when parameter to addinfocallback for specifying in which state an informational callback should be called.","category":"page"},{"location":"changelog/#Version-0.14.0-(August-7,-2016)","page":"Release notes","title":"Version 0.14.0 (August 7, 2016)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Compatibility with Julia 0.5 and ForwardDiff 0.2\nSupport for \"anonymous\" variables, constraints, expressions, and parameters, for example, x = @variable(m, [1:N]) instead of @variable(m, x[1:N])\nSupport for retrieving constraints from a model by name via getconstraint\n@NLconstraint now returns constraint references (as expected).\nSupport for vectorized expressions within lazy constraints\nOn Julia 0.5, parse new comprehension syntax sum(x[i] for i in 1:N if isodd(i)) instead of sum{ x[i], i in 1:N; isodd(i) }. The old syntax with curly braces will be deprecated in JuMP 0.15.\nNow possible to provide nonlinear expressions as \"raw\" Julia Expr objects instead of using JuMP's nonlinear macros. This input format is useful for programmatically generated expressions.\ns/Mathematical Programming/Mathematical Optimization/\nSupport for local cuts (Thanks to @madanim, Mehdi Madani)\nDocument Xpress interface developed by @joaquimg, Joaquim Dias Garcia\nMinor bug and deprecation fixes (Thanks @odow, @jrevels)","category":"page"},{"location":"changelog/#Version-0.13.2-(May-16,-2016)","page":"Release notes","title":"Version 0.13.2 (May 16, 2016)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Compatibility update for MathProgBase","category":"page"},{"location":"changelog/#Version-0.13.1-(May-3,-2016)","page":"Release notes","title":"Version 0.13.1 (May 3, 2016)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix broken deprecation for registerNLfunction.","category":"page"},{"location":"changelog/#Version-0.13.0-(April-29,-2016)","page":"Release notes","title":"Version 0.13.0 (April 29, 2016)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Most exported methods and macros have been renamed to avoid camelCase. See the list of changes here. There is a 1-1 mapping from the old names to the new, and it is safe to simply replace the names to update existing models.\nSpecify variable lower/upper bounds in @variable using the lowerbound and upperbound keyword arguments.\nChange name printed for variable using the basename keyword argument to @variable.\nNew @variables macro allows multi-line declaration of groups of variables.\nA number of solver methods previously available only through MathProgBase are now exposed directly in JuMP. The fix was recorded live.\nCompatibility fixes with Julia 0.5.\nThe \"end\" indexing syntax is no longer supported within JuMPArrays which do not use 1-based indexing until upstream issues are resolved, see here.","category":"page"},{"location":"changelog/#Version-0.12.2-(March-9,-2016)","page":"Release notes","title":"Version 0.12.2 (March 9, 2016)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Small fixes for nonlinear optimization","category":"page"},{"location":"changelog/#Version-0.12.1-(March-1,-2016)","page":"Release notes","title":"Version 0.12.1 (March 1, 2016)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix a regression in slicing for JuMPArrays (when not using 1-based indexing)","category":"page"},{"location":"changelog/#Version-0.12.0-(February-27,-2016)","page":"Release notes","title":"Version 0.12.0 (February 27, 2016)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"The automatic differentiation functionality has been completely rewritten with a number of user-facing changes:\n@defExpr and @defNLExpr now take the model as the first argument. The previous one-argument version of @defExpr is deprecated; all expressions should be named. For example, replace @defExpr(2x+y) with @defExpr(jump_model, my_expr, 2x+y).\nJuMP no longer uses Julia's variable binding rules for efficiently re-solving a sequence of nonlinear models. Instead, we have introduced nonlinear parameters. This is a breaking change, so we have added a warning message when we detect models that may depend on the old behavior.\nSupport for user-defined functions integrated within nonlinear JuMP expressions.\nReplaced iteration over AffExpr with Number-like scalar iteration; previous iteration behavior is now available via linearterms(::AffExpr).\nStopping the solver via throw(CallbackAbort()) from a callback no longer triggers an exception. Instead, solve() returns UserLimit status.\ngetDual() now works for conic problems (Thanks @emreyamangil.)","category":"page"},{"location":"changelog/#Version-0.11.3-(February-4,-2016)","page":"Release notes","title":"Version 0.11.3 (February 4, 2016)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Bug-fix for problems with quadratic objectives and semidefinite constraints","category":"page"},{"location":"changelog/#Version-0.11.2-(January-14,-2016)","page":"Release notes","title":"Version 0.11.2 (January 14, 2016)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Compatibility update for Mosek","category":"page"},{"location":"changelog/#Version-0.11.1-(December-1,-2015)","page":"Release notes","title":"Version 0.11.1 (December 1, 2015)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Remove usage of @compat in tests.\nFix updating quadratic objectives for nonlinear models.","category":"page"},{"location":"changelog/#Version-0.11.0-(November-30,-2015)","page":"Release notes","title":"Version 0.11.0 (November 30, 2015)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Julia 0.4.0 is the minimum required version for this release.\nFix for scoping semantics of index variables in sum{}. Index variables no longer leak into the surrounding scope.\nAddition of the solve(m::Model, relaxation=true) keyword argument to solve the standard continuous relaxation of model m\nThe getConstraintBounds() method allows access to the lower and upper bounds of all constraints in a (nonlinear) model.\nUpdate for breaking changes in MathProgBase","category":"page"},{"location":"changelog/#Version-0.10.3-(November-20,-2015)","page":"Release notes","title":"Version 0.10.3 (November 20, 2015)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix a rare error when parsing quadratic expressions\nFix Variable() constructor with default arguments\nDetect unrecognized keywords in solve()","category":"page"},{"location":"changelog/#Version-0.10.2-(September-28,-2015)","page":"Release notes","title":"Version 0.10.2 (September 28, 2015)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix for deprecation warnings","category":"page"},{"location":"changelog/#Version-0.10.1-(September-3,-2015)","page":"Release notes","title":"Version 0.10.1 (September 3, 2015)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixes for ambiguity warnings.\nFix for breaking change in precompilation syntax in Julia 0.4-pre","category":"page"},{"location":"changelog/#Version-0.10.0-(August-31,-2015)","page":"Release notes","title":"Version 0.10.0 (August 31, 2015)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Support (on Julia 0.4 and later) for conditions in indexing @defVar and @addConstraint constructs, for example, @defVar(m, x[i=1:5,j=1:5; i+j >= 3])\nSupport for vectorized operations on Variables and expressions. See the documentation for details.\nNew getVar() method to access variables in a model by name\nSupport for semidefinite programming.\nDual solutions are now available for general nonlinear problems. You may call getDual on a reference object for a nonlinear constraint, and getDual on a variable object for Lagrange multipliers from active bounds.\nIntroduce warnings for two common performance traps: too many calls to getValue() on a collection of variables and use of the + operator in a loop to sum expressions.\nSecond-order cone constraints can be written directly with the norm() and norm2{} syntax.\nImplement MathProgBase interface for querying Hessian-vector products.\nIteration over JuMPContainers is deprecated; instead, use the keys and values functions, and zip(keys(d),values(d)) for the old behavior.\n@defVar returns Array{Variable,N} when each of N index sets are of the form 1:nᵢ.\nModule precompilation: on Julia 0.4 and later, using JuMP is now much faster.","category":"page"},{"location":"changelog/#Version-0.9.3-(August-11,-2015)","page":"Release notes","title":"Version 0.9.3 (August 11, 2015)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fixes for FactCheck testing on julia v0.4.","category":"page"},{"location":"changelog/#Version-0.9.2-(June-27,-2015)","page":"Release notes","title":"Version 0.9.2 (June 27, 2015)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix bug in @addConstraints.","category":"page"},{"location":"changelog/#Version-0.9.1-(April-25,-2015)","page":"Release notes","title":"Version 0.9.1 (April 25, 2015)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix for Julia 0.4-dev.\nSmall infrastructure improvements for extensions.","category":"page"},{"location":"changelog/#Version-0.9.0-(April-18,-2015)","page":"Release notes","title":"Version 0.9.0 (April 18, 2015)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Comparison operators for constructing constraints (for example, 2x >= 1) have been deprecated. Instead, construct the constraints explicitly in the @addConstraint macro to add them to the model, or in the @LinearConstraint macro to create a stand-alone linear constraint instance.\ngetValue() method implemented to compute the value of a nonlinear subexpression\nJuMP is now released under the Mozilla Public License version 2.0 (was previously LGPL). MPL is a copyleft license which is less restrictive than LGPL, especially for embedding JuMP within other applications.\nA number of performance improvements in ReverseDiffSparse for computing derivatives.\nMathProgBase.getsolvetime(m) now returns the solution time reported by the solver, if available. (Thanks @odow, Oscar Dowson)\nFormatting fix for LP format output. (Thanks @sbebo, Leonardo Taccari).","category":"page"},{"location":"changelog/#Version-0.8.0-(February-17,-2015)","page":"Release notes","title":"Version 0.8.0 (February 17, 2015)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Nonlinear subexpressions now supported with the @defNLExpr macro.\nSCS supported for solving second-order conic problems.\nsetXXXCallback family deprecated in favor of addXXXCallback.\nMultiple callbacks of the same type can be registered.\nAdded support for informational callbacks via addInfoCallback.\nA CallbackAbort exception can be thrown from callback to safely exit optimization.","category":"page"},{"location":"changelog/#Version-0.7.4-(February-4,-2015)","page":"Release notes","title":"Version 0.7.4 (February 4, 2015)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Reduced costs and linear constraint duals are now accessible when quadratic constraints are present.\nTwo-sided nonlinear constraints are supported.\nMethods for accessing the number of variables and constraints in a model are renamed.\nNew default procedure for setting initial values in nonlinear optimization: project zero onto the variable bounds.\nSmall bug fixes.","category":"page"},{"location":"changelog/#Version-0.7.3-(January-14,-2015)","page":"Release notes","title":"Version 0.7.3 (January 14, 2015)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix a method ambiguity conflict with Compose.jl (cosmetic fix)","category":"page"},{"location":"changelog/#Version-0.7.2-(January-9,-2015)","page":"Release notes","title":"Version 0.7.2 (January 9, 2015)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix a bug in sum(::JuMPDict)\nAdded the setCategory function to change a variables category (for example, continuous or binary)","category":"page"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"after construction, and getCategory to retrieve the variable category.","category":"page"},{"location":"changelog/#Version-0.7.1-(January-2,-2015)","page":"Release notes","title":"Version 0.7.1 (January 2, 2015)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix a bug in parsing linear expressions in macros. Affects only Julia 0.4 and later.","category":"page"},{"location":"changelog/#Version-0.7.0-(December-29,-2014)","page":"Release notes","title":"Version 0.7.0 (December 29, 2014)","text":"","category":"section"},{"location":"changelog/#Linear/quadratic/conic-programming","page":"Release notes","title":"Linear/quadratic/conic programming","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Breaking change: The syntax for column-wise model generation has been changed to use keyword arguments in @defVar.\nOn Julia 0.4 and later, variables and coefficients may be multiplied in any order within macros. That is, variable*coefficient is now valid syntax.\nECOS supported for solving second-order conic problems.","category":"page"},{"location":"changelog/#_nonlinear_programming_release_notes","page":"Release notes","title":"Nonlinear programming","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Support for skipping model generation when solving a sequence of nonlinear models with changing data.\nFix a memory leak when solving a sequence of nonlinear models.\nThe @addNLConstraint macro now supports the three-argument version to define sets of nonlinear constraints.\nKNITRO supported as a nonlinear solver.\nSpeed improvements for model generation.\nThe @addNLConstraints macro supports adding multiple (groups of) constraints at once. Syntax is similar to @addConstraints.\nDiscrete variables allowed in nonlinear problems for solvers which support them (currently only KNITRO).","category":"page"},{"location":"changelog/#General","page":"Release notes","title":"General","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Starting values for variables may now be specified with @defVar(m, x, start=value).\nThe setSolver function allows users to change the solver subsequent to model creation.\nSupport for \"fixed\" variables via the @defVar(m, x == 1) syntax.\nUnit tests rewritten to use FactCheck.jl, improved testing across solvers.","category":"page"},{"location":"changelog/#Version-0.6.3-(October-19,-2014)","page":"Release notes","title":"Version 0.6.3 (October 19, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix a bug in multiplying two AffExpr objects.","category":"page"},{"location":"changelog/#Version-0.6.2-(October-11,-2014)","page":"Release notes","title":"Version 0.6.2 (October 11, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Further improvements and bug fixes for printing.\nFixed a bug in @defExpr.\nSupport for accessing expression graphs through the MathProgBase NLP interface.","category":"page"},{"location":"changelog/#Version-0.6.1-(September-19,-2014)","page":"Release notes","title":"Version 0.6.1 (September 19, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Improvements and bug fixes for printing.","category":"page"},{"location":"changelog/#Version-0.6.0-(September-9,-2014)","page":"Release notes","title":"Version 0.6.0 (September 9, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Julia 0.3.0 is the minimum required version for this release.\nbuildInternalModel(m::Model) added to build solver-level model in memory without optimizing.\nDeprecate load_model_only keyword argument to solve.\nAdd groups of constraints with @addConstraints macro.\nUnicode operators now supported, including ∑ for sum, ∏ for prod, and ≤/≥\nQuadratic constraints supported in @addConstraint macro.\nQuadratic objectives supported in @setObjective macro.\nMathProgBase solver-independent interface replaces Ipopt-specific interface for nonlinear problems\nBreaking change: IpoptOptions no longer supported to specify solver options, use m = Model(solver=IpoptSolver(options...)) instead.\nNew solver interfaces: ECOS, NLopt, and nonlinear support for MOSEK\nNew option to control whether the lazy constraint callback is executed at each node in the B&B tree or just when feasible solutions are found\nAdd support for semicontinuous and semi-integer variables for those solvers that support them.\nAdd support for index dependencies (for example, triangular indexing) in @defVar, @addConstraint, and @defExpr (for example, @defVar(m, x[i=1:10,j=i:10])).\nThis required some changes to the internal structure of JuMP containers, which may break code that explicitly stored JuMPDict objects.","category":"page"},{"location":"changelog/#Version-0.5.8-(September-24,-2014)","page":"Release notes","title":"Version 0.5.8 (September 24, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix a bug with specifying solvers (affects Julia 0.2 only)","category":"page"},{"location":"changelog/#Version-0.5.7-(September-5,-2014)","page":"Release notes","title":"Version 0.5.7 (September 5, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix a bug in printing models","category":"page"},{"location":"changelog/#Version-0.5.6-(September-2,-2014)","page":"Release notes","title":"Version 0.5.6 (September 2, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Add support for semicontinuous and semi-integer variables for those solvers that support them.\nBreaking change: Syntax for Variable() constructor has changed (use of this interface remains discouraged)\nUpdate for breaking changes in MathProgBase","category":"page"},{"location":"changelog/#Version-0.5.5-(July-6,-2014)","page":"Release notes","title":"Version 0.5.5 (July 6, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix bug with problem modification: adding variables that did not appear in existing constraints or objective.","category":"page"},{"location":"changelog/#Version-0.5.4-(June-19,-2014)","page":"Release notes","title":"Version 0.5.4 (June 19, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Update for breaking change in MathProgBase which reduces loading times for using JuMP\nFix error when MIPs not solved to optimality","category":"page"},{"location":"changelog/#Version-0.5.3-(May-21,-2014)","page":"Release notes","title":"Version 0.5.3 (May 21, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Update for breaking change in ReverseDiffSparse","category":"page"},{"location":"changelog/#Version-0.5.2-(May-9,-2014)","page":"Release notes","title":"Version 0.5.2 (May 9, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix compatibility with Julia 0.3 prerelease","category":"page"},{"location":"changelog/#Version-0.5.1-(May-5,-2014)","page":"Release notes","title":"Version 0.5.1 (May 5, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix a bug in coefficient handling inside lazy constraints and user cuts","category":"page"},{"location":"changelog/#Version-0.5.0-(May-2,-2014)","page":"Release notes","title":"Version 0.5.0 (May 2, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Support for nonlinear optimization with exact, sparse second-order derivatives automatically computed. Ipopt is currently the only solver supported.\ngetValue for AffExpr and QuadExpr\nBreaking change: getSolverModel replaced by getInternalModel, which returns the internal MathProgBase-level model\nGroups of constraints can be specified with @addConstraint (see documentation for details). This is not a breaking change.\ndot(::JuMPDict{Variable},::JuMPDict{Variable}) now returns the corresponding quadratic expression.","category":"page"},{"location":"changelog/#Version-0.4.1-(March-24,-2014)","page":"Release notes","title":"Version 0.4.1 (March 24, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Fix bug where change in objective sense was ignored when re-solving a model.\nFix issue with handling zero coefficients in AffExpr.","category":"page"},{"location":"changelog/#Version-0.4.0-(March-10,-2014)","page":"Release notes","title":"Version 0.4.0 (March 10, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Support for SOS1 and SOS2 constraints.\nSolver-independent callback for user heuristics.\ndot and sum implemented for JuMPDict objects. Now you can say @addConstraint(m, dot(a,x) <= b).\nDevelopers: support for extensions to JuMP. See definition of Model in src/JuMP.jl for more details.\nOption to construct the low-level model before optimizing.","category":"page"},{"location":"changelog/#Version-0.3.2-(February-17,-2014)","page":"Release notes","title":"Version 0.3.2 (February 17, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Improved model printing\nPreliminary support for IJulia output","category":"page"},{"location":"changelog/#Version-0.3.1-(January-30,-2014)","page":"Release notes","title":"Version 0.3.1 (January 30, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Documentation updates\nSupport for MOSEK\nCPLEXLink renamed to CPLEX","category":"page"},{"location":"changelog/#Version-0.3.0-(January-21,-2014)","page":"Release notes","title":"Version 0.3.0 (January 21, 2014)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Unbounded/infeasibility rays: getValue() will return the corresponding components of an unbounded ray when a model is unbounded, if supported by the selected solver. getDual() will return an infeasibility ray (Farkas proof) if a model is infeasible and the selected solver supports this feature.\nSolver-independent callbacks for user generated cuts.\nUse new interface for solver-independent QCQP.\nsetlazycallback renamed to setLazyCallback for consistency.","category":"page"},{"location":"changelog/#Version-0.2.0-(December-15,-2013)","page":"Release notes","title":"Version 0.2.0 (December 15, 2013)","text":"","category":"section"},{"location":"changelog/#Breaking-8","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Objective sense is specified in setObjective instead of in the Model constructor.\nlpsolver and mipsolver merged into single solver option.","category":"page"},{"location":"changelog/#Added-37","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Problem modification with efficient LP restarts and MIP warm-starts.\nRelatedly, column-wise modeling now supported.\nSolver-independent callbacks supported. Currently we support only a \"lazy constraint\" callback, which works with Gurobi, CPLEX, and GLPK. More callbacks coming soon.","category":"page"},{"location":"changelog/#Version-0.1.2-(November-16,-2013)","page":"Release notes","title":"Version 0.1.2 (November 16, 2013)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Bug fixes for printing, improved error messages.\nAllow AffExpr to be used in macros; for example, ex = y + z; @addConstraint(m, x + 2*ex <= 3)","category":"page"},{"location":"changelog/#Version-0.1.1-(October-23,-2013)","page":"Release notes","title":"Version 0.1.1 (October 23, 2013)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Update for solver specification API changes in MathProgBase.","category":"page"},{"location":"changelog/#Version-0.1.0-(October-3,-2013)","page":"Release notes","title":"Version 0.1.0 (October 3, 2013)","text":"","category":"section"},{"location":"changelog/","page":"Release notes","title":"Release notes","text":"Initial public release.","category":"page"},{"location":"packages/CDDLib/","page":"JuliaPolyhedra/CDDLib.jl","title":"JuliaPolyhedra/CDDLib.jl","text":"EditURL = \"https://github.com/JuliaPolyhedra/CDDLib.jl/blob/v0.9.3/README.md\"","category":"page"},{"location":"packages/CDDLib/#CDDLib","page":"JuliaPolyhedra/CDDLib.jl","title":"CDDLib","text":"","category":"section"},{"location":"packages/CDDLib/","page":"JuliaPolyhedra/CDDLib.jl","title":"JuliaPolyhedra/CDDLib.jl","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"packages/CDDLib/","page":"JuliaPolyhedra/CDDLib.jl","title":"JuliaPolyhedra/CDDLib.jl","text":"CDDLib.jl is a wrapper for cddlib.","category":"page"},{"location":"packages/CDDLib/","page":"JuliaPolyhedra/CDDLib.jl","title":"JuliaPolyhedra/CDDLib.jl","text":"CDDLib.jl can be used with C API of cddlib, the higher level interface of Polyhedra.jl, or as a linear programming solver with JuMP or MathOptInterface.","category":"page"},{"location":"packages/CDDLib/#Problem-description","page":"JuliaPolyhedra/CDDLib.jl","title":"Problem description","text":"","category":"section"},{"location":"packages/CDDLib/","page":"JuliaPolyhedra/CDDLib.jl","title":"JuliaPolyhedra/CDDLib.jl","text":"As written in the README of cddlib:","category":"page"},{"location":"packages/CDDLib/","page":"JuliaPolyhedra/CDDLib.jl","title":"JuliaPolyhedra/CDDLib.jl","text":"The C-library  cddlib is a C implementation of the Double Description Method of Motzkin et al. for generating all vertices (that is, extreme points) and extreme rays of a general convex polyhedron in R^d given by a system of linear inequalities:P = { x=(x1, ..., xd)^T :  b - A  x  >= 0 }where  A  is a given m x d real matrix, b is a given m-vector and 0 is the m-vector of all zeros.The program can be used for the reverse operation (that is, convex hull computation).  This means that  one can move back and forth between an inequality representation  and a generator (that is, vertex and ray) representation of a polyhedron with cdd.  Also, cdd can solve a linear programming problem, that is, a problem of maximizing and minimizing a linear function over P.","category":"page"},{"location":"packages/CDDLib/#License","page":"JuliaPolyhedra/CDDLib.jl","title":"License","text":"","category":"section"},{"location":"packages/CDDLib/","page":"JuliaPolyhedra/CDDLib.jl","title":"JuliaPolyhedra/CDDLib.jl","text":"CDDLib.jl is licensed under the GPL v2 license.","category":"page"},{"location":"packages/CDDLib/","page":"JuliaPolyhedra/CDDLib.jl","title":"JuliaPolyhedra/CDDLib.jl","text":"The underlying solver, cddlib/cddlib is also licensed under the GPL v2 license.","category":"page"},{"location":"packages/CDDLib/#Installation","page":"JuliaPolyhedra/CDDLib.jl","title":"Installation","text":"","category":"section"},{"location":"packages/CDDLib/","page":"JuliaPolyhedra/CDDLib.jl","title":"JuliaPolyhedra/CDDLib.jl","text":"Install CDDLib.jl using the Julia package manager:","category":"page"},{"location":"packages/CDDLib/","page":"JuliaPolyhedra/CDDLib.jl","title":"JuliaPolyhedra/CDDLib.jl","text":"import Pkg\nPkg.add(\"CDDLib\")","category":"page"},{"location":"packages/CDDLib/","page":"JuliaPolyhedra/CDDLib.jl","title":"JuliaPolyhedra/CDDLib.jl","text":"Building the package will download binaries of cddlib that are provided by cddlib_jll.jl.","category":"page"},{"location":"packages/CDDLib/#Use-with-JuMP","page":"JuliaPolyhedra/CDDLib.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/CDDLib/","page":"JuliaPolyhedra/CDDLib.jl","title":"JuliaPolyhedra/CDDLib.jl","text":"Use CDDLib.Optimizer{Float64} to use CDDLib.jl with JuMP:","category":"page"},{"location":"packages/CDDLib/","page":"JuliaPolyhedra/CDDLib.jl","title":"JuliaPolyhedra/CDDLib.jl","text":"using JuMP, CDDLib\nmodel = Model(CDDLib.Optimizer{Float64})","category":"page"},{"location":"packages/CDDLib/","page":"JuliaPolyhedra/CDDLib.jl","title":"JuliaPolyhedra/CDDLib.jl","text":"When using CDDLib.jl with MathOptInterface, you can pass a different number type:","category":"page"},{"location":"packages/CDDLib/","page":"JuliaPolyhedra/CDDLib.jl","title":"JuliaPolyhedra/CDDLib.jl","text":"using MathOptInterface, CDDLib\nmodel = CDDLib.Optimizer{Rational{BigInt}}()","category":"page"},{"location":"packages/CDDLib/#Debugging","page":"JuliaPolyhedra/CDDLib.jl","title":"Debugging","text":"","category":"section"},{"location":"packages/CDDLib/","page":"JuliaPolyhedra/CDDLib.jl","title":"JuliaPolyhedra/CDDLib.jl","text":"CDDLib.jl uses two global Boolean variables to enable debugging outputs: debug and log.","category":"page"},{"location":"packages/CDDLib/","page":"JuliaPolyhedra/CDDLib.jl","title":"JuliaPolyhedra/CDDLib.jl","text":"You can query the value of debug and log with get_debug and get_log, and set their values with set_debug and set_log.","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"EditURL = \"https://github.com/scipopt/SCIP.jl/blob/v0.11.14/README.md\"","category":"page"},{"location":"packages/SCIP/#SCIP.jl","page":"scipopt/SCIP.jl","title":"SCIP.jl","text":"","category":"section"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"(Image: Build Status) (Image: codecov) (Image: Genie Downloads)","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"SCIP.jl is a Julia interface to the SCIP solver.","category":"page"},{"location":"packages/SCIP/#Affiliation","page":"scipopt/SCIP.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"This wrapper is maintained by the SCIP project with the help of the JuMP community.","category":"page"},{"location":"packages/SCIP/#License","page":"scipopt/SCIP.jl","title":"License","text":"","category":"section"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"SCIP.jl is licensed under the MIT License.","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"The underlying solver, scipopt/scip, is licensed under the Apache 2.0 license.","category":"page"},{"location":"packages/SCIP/#Installation","page":"scipopt/SCIP.jl","title":"Installation","text":"","category":"section"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"Install SCIP.jl using Pkg.add:","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"import Pkg\nPkg.add(\"SCIP\")","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"On MacOS and Linux, installing the SCIP Julia package will work out of the box and install the SCIP_jll.jl and SCIP_PaPILO_jll.jl dependencies.","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"On Windows, a separate installation of SCIP is still mandatory, as detailed in the \"Custom installation\" section below.","category":"page"},{"location":"packages/SCIP/#Custom-installations","page":"scipopt/SCIP.jl","title":"Custom installations","text":"","category":"section"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"If you use an older Julia version, Windows, or you want a custom SCIP installation, you must manually install the SCIP binaries.","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"Once installed, set the SCIPOPTDIR environment variable to point to the installation path, that is, depending on your operating system, $SCIPOPTDIR/lib/libscip.so, $SCIPOPTDIR/lib/libscip.dylib, or $SCIPOPTDIR/bin/scip.dll must exist.","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"Then, install SCIP.jl using Pkg.add and Pkg.build:","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"ENV[\"SCIPOPTDIR\"] = \"/Users/Oscar/code/SCIP\"\nimport Pkg\nPkg.add(\"SCIP\")\nPkg.build(\"SCIP\")","category":"page"},{"location":"packages/SCIP/#Use-with-JuMP","page":"scipopt/SCIP.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"Use SCIP with JuMP as follows:","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"using JuMP, SCIP\nmodel = Model(SCIP.Optimizer)\nset_attribute(model, \"display/verblevel\", 0)\nset_attribute(model, \"limits/gap\", 0.05)","category":"page"},{"location":"packages/SCIP/#Options","page":"scipopt/SCIP.jl","title":"Options","text":"","category":"section"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"See the SCIP documentation for a list of supported options.","category":"page"},{"location":"packages/SCIP/#MathOptInterface-API","page":"scipopt/SCIP.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"The SCIP optimizer supports the following constraints and attributes.","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"List of supported objective functions:","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"MOI.Reals","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"MOI.ScalarAffineFunction{Float64} in MOI.EqualTo{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.Interval{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.LessThan{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.EqualTo{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.Interval{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.EqualTo{Float64}\nMOI.VariableIndex in MOI.GreaterThan{Float64}\nMOI.VariableIndex in MOI.Integer\nMOI.VariableIndex in MOI.Interval{Float64}\nMOI.VariableIndex in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.ZeroOne\nMOI.VectorOfVariables in MOI.SOS1{Float64}\nMOI.VectorOfVariables in MOI.SOS2{Float64}","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"MOI.NLPBlock()\nMOI.ObjectiveSense()\nMOI.UserCutCallback()","category":"page"},{"location":"packages/SCIP/#Design-considerations","page":"scipopt/SCIP.jl","title":"Design considerations","text":"","category":"section"},{"location":"packages/SCIP/#Wrapping-the-public-API","page":"scipopt/SCIP.jl","title":"Wrapping the public API","text":"","category":"section"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"All of the public API methods are wrapped and available within the SCIP package. This includes the scip_*.h and pub_*.h headers that are collected in scip.h, as well as all default constraint handlers (cons_*.h.) ","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"The wrapped functions do not transform any data structures and work on the raw pointers (for example, SCIP* in C, Ptr{SCIP_} in Julia). Convenience wrapper functions based on Julia types are added as needed.","category":"page"},{"location":"packages/SCIP/#Memory-management","page":"scipopt/SCIP.jl","title":"Memory management","text":"","category":"section"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"Programming with SCIP requires dealing with variable and constraint objects that use reference counting for memory management.","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"The SCIP.Optimizer wrapper type collects lists of SCIP_VAR* and SCIP_CONS* under the hood, and it releases all references when it is garbage collected itself (via finalize).","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"When adding a variable (add_variable) or a constraint (add_linear_constraint), an integer index is returned. This index can be used to retrieve the SCIP_VAR* or SCIP_CONS* pointer via get_var and get_cons respectively.","category":"page"},{"location":"packages/SCIP/#Supported-nonlinear-operators","page":"scipopt/SCIP.jl","title":"Supported nonlinear operators","text":"","category":"section"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"Supported operators in nonlinear expressions are as follows:","category":"page"},{"location":"packages/SCIP/","page":"scipopt/SCIP.jl","title":"scipopt/SCIP.jl","text":"+\n-\n*\n/\n^\nsqrt\nexp\nlog\nabs\ncos\nsin","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"EditURL = \"nested_problems.jl\"","category":"page"},{"location":"tutorials/nonlinear/nested_problems/#Nested-optimization-problems","page":"Nested optimization problems","title":"Nested optimization problems","text":"","category":"section"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"In this tutorial we explain how to write a nested optimization problem, where an upper problem uses the results from the optimization of a lower subproblem.","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"To model the problem, we define a user-defined operator to handle the decomposition of the lower problem inside the upper one. Finally, we show how to improve the performance by using a cache that avoids resolving the lower problem.","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"For a simpler example of writing a user-defined operator, see the User-defined Hessians tutorial.","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"info: Info\nThe JuMP extension BilevelJuMP.jl can also be used to model and solve bilevel optimization problems.","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"using JuMP\nimport Ipopt","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"In the rest of this tutorial, our goal is to solve the bilevel optimization problem:","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"beginarrayr l\nminlimits_xz  x_1^2 + x_2^2 + z \nst             beginarrayr l\n                      z = maxlimits_y  x_1^2 y_1 + x_2^2 y_2  - x_1 y_1^4 - 2 x_2 y_2^4 \n                      st                   (y_1 - 10)^2 + (y_2 - 10)^2 le 25\n                  endarray \n                 x ge 0\nendarray","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"This bilevel optimization problem is composed of two nested optimization problems. An upper level, involving variables x, and a lower level, involving variables y. From the perspective of the lower-level problem, the values of x are fixed parameters, and so the model optimizes y given those fixed parameters. Simultaneously, the upper-level problem optimizes x and z given the response of y.","category":"page"},{"location":"tutorials/nonlinear/nested_problems/#Decomposition","page":"Nested optimization problems","title":"Decomposition","text":"","category":"section"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"There are a few ways to solve this problem, but we are going to use a nonlinear decomposition method. The first step is to write a function to compute the lower-level problem:","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"beginarrayr l\n  V(x_1 x_2) = maxlimits_y  x_1^2 y_1 + x_2^2 y_2  - x_1 y_1^4 - 2 x_2 y_2^4 \n                           st  (y_1 - 10)^2 + (y_2 - 10)^2 le 25\nendarray","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"function solve_lower_level(x...)\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, y[1:2])\n    @objective(\n        model,\n        Max,\n        x[1]^2 * y[1] + x[2]^2 * y[2] - x[1] * y[1]^4 - 2 * x[2] * y[2]^4,\n    )\n    @constraint(model, (y[1] - 10)^2 + (y[2] - 10)^2 <= 25)\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    return objective_value(model), value.(y)\nend","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"The next function takes a value of x and returns the optimal lower-level objective-value and the optimal response y. The reason why we need both the objective and the optimal y will be made clear shortly, but for now let us define:","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"function V(x...)\n    f, _ = solve_lower_level(x...)\n    return f\nend","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"Then, we can substitute V into our full problem to create:","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"beginarrayr l\nminlimits_x  x_1^2 + x_2^2 + V(x_1 x_2) \nst             x ge 0\nendarray","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"This looks like a nonlinear optimization problem with a user-defined operator V! However, because V solves an optimization problem internally, we can't use automatic differentiation to compute the first and second derivatives. Instead, we can use JuMP's ability to pass callback functions for the gradient and Hessian instead.","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"First up, we need to define the gradient of V with respect to x. In general, this may be difficult to compute, but because x appears only in the objective, we can just differentiate the objective function with respect to x, giving:","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"function ∇V(g::AbstractVector, x...)\n    _, y = solve_lower_level(x...)\n    g[1] = 2 * x[1] * y[1] - y[1]^4\n    g[2] = 2 * x[2] * y[2] - 2 * y[2]^4\n    return\nend","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"Second, we need to define the Hessian of V with respect to x. This is a symmetric matrix, but in our example only the diagonal elements are non-zero:","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"function ∇²V(H::AbstractMatrix, x...)\n    _, y = solve_lower_level(x...)\n    H[1, 1] = 2 * y[1]\n    H[2, 2] = 2 * y[2]\n    return\nend","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"info: Info\nProviding an explicit Hessian function is optional if first derivatives are already available.","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"We now have enough to define our bilevel optimization problem:","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"model = Model(Ipopt.Optimizer)\n@variable(model, x[1:2] >= 0)\n@operator(model, op_V, 2, V, ∇V, ∇²V)\n@objective(model, Min, x[1]^2 + x[2]^2 + op_V(x[1], x[2]))\noptimize!(model)\n@assert is_solved_and_feasible(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"The optimal objective value is:","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"objective_value(model)","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"and the optimal upper-level decision variables x are:","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"value.(x)","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"To compute the optimal lower-level decision variables, we need to call solve_lower_level with the optimal upper-level decision variables:","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"_, y = solve_lower_level(value.(x)...)\ny","category":"page"},{"location":"tutorials/nonlinear/nested_problems/#Improving-performance","page":"Nested optimization problems","title":"Improving performance","text":"","category":"section"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"Our solution approach works, but it has a performance problem: every time we need to compute the value, gradient, or Hessian of V, we have to re-solve the lower-level optimization problem. This is wasteful, because we will often call the gradient and Hessian at the same point, and so solving the problem twice with the same input repeats work unnecessarily.","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"We can work around this by using a cache:","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"mutable struct Cache\n    x::Any\n    f::Float64\n    y::Vector{Float64}\nend","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"with a function to update the cache if needed:","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"function _update_if_needed(cache::Cache, x...)\n    if cache.x !== x\n        cache.f, cache.y = solve_lower_level(x...)\n        cache.x = x\n    end\n    return\nend","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"Then, we define cached versions of out three functions which call _updated_if_needed and return values from the cache.","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"function cached_f(cache::Cache, x...)\n    _update_if_needed(cache, x...)\n    return cache.f\nend\n\nfunction cached_∇f(cache::Cache, g::AbstractVector, x...)\n    _update_if_needed(cache, x...)\n    g[1] = 2 * x[1] * cache.y[1] - cache.y[1]^4\n    g[2] = 2 * x[2] * cache.y[2] - 2 * cache.y[2]^4\n    return\nend\n\nfunction cached_∇²f(cache::Cache, H::AbstractMatrix, x...)\n    _update_if_needed(cache, x...)\n    H[1, 1] = 2 * cache.y[1]\n    H[2, 2] = 2 * cache.y[2]\n    return\nend","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"Now we're ready to setup and solve the upper level optimization problem:","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"model = Model(Ipopt.Optimizer)\n@variable(model, x[1:2] >= 0)\ncache = Cache(Float64[], NaN, Float64[])\n@operator(\n    model,\n    op_cached_f,\n    2,\n    (x...) -> cached_f(cache, x...),\n    (g, x...) -> cached_∇f(cache, g, x...),\n    (H, x...) -> cached_∇²f(cache, H, x...),\n)\n@objective(model, Min, x[1]^2 + x[2]^2 + op_cached_f(x[1], x[2]))\noptimize!(model)\n@assert is_solved_and_feasible(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"an we can check we get the same objective value:","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"objective_value(model)","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"and upper-level decision variable x:","category":"page"},{"location":"tutorials/nonlinear/nested_problems/","page":"Nested optimization problems","title":"Nested optimization problems","text":"value.(x)","category":"page"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"EditURL = \"https://github.com/jump-dev/PolyJuMP.jl/blob/v0.7.4/README.md\"","category":"page"},{"location":"packages/PolyJuMP/#PolyJuMP.jl","page":"jump-dev/PolyJuMP.jl","title":"PolyJuMP.jl","text":"","category":"section"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"PolyJuMP.jl is a JuMP extension for formulating and solving polynomial optimization problems. This extension includes the following:","category":"page"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"Polynomial functions on JuMP decisions variables. These can be solved with the PolyJuMP.QCQP.Optimizer or PolyJuMP.KKT.Optimizer.\nConstraints that a polynomial is nonnegative where the coefficients of the polynomials depend on JuMP decision variables. These nonnegativity constraints can be reformulated using sufficient conditions using PolyJuMP.RelativeEntropy submodule or SumOfSquares.jl.","category":"page"},{"location":"packages/PolyJuMP/#License","page":"jump-dev/PolyJuMP.jl","title":"License","text":"","category":"section"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"PolyJuMP.jl is licensed under the MIT license.","category":"page"},{"location":"packages/PolyJuMP/#Installation","page":"jump-dev/PolyJuMP.jl","title":"Installation","text":"","category":"section"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"Install PolyJuMP using Pkg.add:","category":"page"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"import Pkg\nPkg.add(\"PolyJuMP\")","category":"page"},{"location":"packages/PolyJuMP/#Use-with-JuMP","page":"jump-dev/PolyJuMP.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/PolyJuMP/#Polynomial-nonnegativity-constraints","page":"jump-dev/PolyJuMP.jl","title":"Polynomial nonnegativity constraints","text":"","category":"section"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"PolyJuMP allows encoding a constraint that a polynomial should be nonnegative for all values of some symbolic variables defined with DynamicPolynomials.@polyvar or TypedPolynomials.@polyvar as follows. For instance, the following constrains the JuMP decision variable a to be such that a * x * y^2 + y^3 - a * x is nonnegative for all real values of x and y:","category":"page"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"using DynamicPolynomials\n@polyvar x y\nusing JuMP\nmodel = Model()\n@variable(model, a)\n@constraint(model, a * x * y^2 + y^3 >= a * x)","category":"page"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"Determining the nonnegativity of a multivariate polynomial is however NP-hard so sufficient conditions are used instead. You need to specify which sufficient condition is used explicitly. To use Sum-of-Arithmetic-Geometric-Exponentials (SAGE), use","category":"page"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"import PolyJuMP\nPolyJuMP.setpolymodule!(model, PolyJuMP.SAGE)","category":"page"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"To use Sum-of-Squares (SOS), use","category":"page"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"import SumOfSquares\nPolyJuMP.setpolymodule!(model, SumOfSquares)","category":"page"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"or replace model = Model() by model = SOSModel().","category":"page"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"Alternatively, the nonnegativity constraint can be explicit:","category":"page"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"@constraint(model, a * x * y^2 + y^3 - a * x in PolyJuMP.SAGE.Polynomials())\n@constraint(model, a * x * y^2 + y^3 - a * x in SumOfSquares.SOSCone())","category":"page"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"This allows mixing SAGE and SOS constraints in the same model.","category":"page"},{"location":"packages/PolyJuMP/#Polynomial-optimization","page":"jump-dev/PolyJuMP.jl","title":"Polynomial optimization","text":"","category":"section"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"PolyJuMP also allows solving polynomial optimization problems using the QCQP and KKT solvers. Polynomial optimization problems do not involve any symbolic variables from DynamicPolynomials or TypedPolynomials, instead all variables are JuMP decision variables.","category":"page"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"The QCQP solver is parametrized by a nonconvex QCQP inner solver. It reformulates the polynomial optimization problem into a nonconvex QCQP and relies on the inner solver to solve it. For instance, to use the QCQP solver with JuMP with Gurobi.Optimizer as inner solver, use:","category":"page"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"using JuMP, PolyJuMP, Gurobi\nmodel = Model(() -> PolyJuMP.QCQP.Optimizer(Gurobi.Optimizer))","category":"page"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"The KKT solver is parametrized by an inner solver of algebraic systems of equations implementing the SemialgebraicSets interface. It reformulates the polynomial optimization problem into a system of polynomial equations and relies on the inner solver to solve it. For instance, to use the QCQP solver with JuMP with HomotopyContinuation.SemialgebraicSetsHCSolver as inner solver, use:","category":"page"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"using JuMP, PolyJuMP, HomotopyContinuation\nmodel = Model(optimizer_with_attributes(\n    PolyJuMP.KKT.Optimizer,\n    \"solver\" => HomotopyContinuation.SemialgebraicSetsHCSolver(),\n))","category":"page"},{"location":"packages/PolyJuMP/#Documentation","page":"jump-dev/PolyJuMP.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/PolyJuMP/","page":"jump-dev/PolyJuMP.jl","title":"jump-dev/PolyJuMP.jl","text":"Documentation for PolyJuMP.jl is included in the documentation for SumOfSquares.jl.","category":"page"},{"location":"extensions/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"extensions/introduction/","page":"Introduction","title":"Introduction","text":"This section of the documentation contains brief documentation for some popular JuMP extensions. The list of extensions is not exhaustive, but instead is intended to help you discover popular JuMP extensions, and to give you an overview of the types of extensions that are possible to write with JuMP.","category":"page"},{"location":"extensions/introduction/#Affiliation","page":"Introduction","title":"Affiliation","text":"","category":"section"},{"location":"extensions/introduction/","page":"Introduction","title":"Introduction","text":"Packages beginning with jump-dev/ are developed and maintained by the JuMP developers.","category":"page"},{"location":"extensions/introduction/","page":"Introduction","title":"Introduction","text":"Packages that do not begin with jump-dev/ are developed independently. The developers of these packages requested or consented to the inclusion of their README contents in the JuMP documentation for the benefit of users.","category":"page"},{"location":"extensions/introduction/#Adding-new-extensions","page":"Introduction","title":"Adding new extensions","text":"","category":"section"},{"location":"extensions/introduction/","page":"Introduction","title":"Introduction","text":"Written an extension? Add it to this section of the JuMP documentation by making a pull request to the docs/packages.toml file.","category":"page"},{"location":"extensions/introduction/#Weak-dependencies","page":"Introduction","title":"Weak dependencies","text":"","category":"section"},{"location":"extensions/introduction/","page":"Introduction","title":"Introduction","text":"Some extensions listed in this section are implemented using the weak dependency feature added to Julia in v1.9. These extensions are activated if and only if you have JuMP and the other package loaded into your current scope with using or import.","category":"page"},{"location":"extensions/introduction/","page":"Introduction","title":"Introduction","text":"compat: Compat\nUsing a weak dependency requires Julia v1.9 or later.","category":"page"},{"location":"installation/#Installation-Guide","page":"Installation Guide","title":"Installation Guide","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"This guide explains how to install Julia and  JuMP. If you have installation troubles, read the Common installation issues section below.","category":"page"},{"location":"installation/#Install-Julia","page":"Installation Guide","title":"Install Julia","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"JuMP is a package for Julia. To use JuMP, first download and install Julia.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"tip: Tip\nIf you are new to Julia, read our Getting started with Julia tutorial.","category":"page"},{"location":"installation/#Choosing-a-version","page":"Installation Guide","title":"Choosing a version","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"You can install the \"Current stable release\" or the \"Long-term support (LTS) release.\"","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"The \"Current stable release\" is the latest release of Julia. It has access to newer features, and is likely faster.\nThe \"Long-term support release\" is an older version of Julia that has continued to receive bug and security fixes. However, it may not have the latest features or performance improvements.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"For most users, you should install the \"Current stable release,\" and whenever Julia releases a new version of the current stable release, you should update your version of Julia. Note that any code you write on one version of the current stable release will continue to work on all subsequent releases.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"For users in restricted software environments (for example, your enterprise IT controls what software you can install), you may be better off installing the long-term support release because you will not have to update Julia as frequently.","category":"page"},{"location":"installation/#Install-JuMP","page":"Installation Guide","title":"Install JuMP","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"From Julia, JuMP is installed using the built-in package manager:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.add(\"JuMP\")","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"tip: Tip\nWe recommend you create a Pkg environment for each project you use JuMP for, instead of adding lots of packages to the global environment. The Pkg manager documentation has more information on this topic.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"When we release a new version of JuMP, you can update with:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.update(\"JuMP\")","category":"page"},{"location":"installation/#Install-a-solver","page":"Installation Guide","title":"Install a solver","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"JuMP depends on solvers to solve optimization problems. Therefore, you will need to install one before you can solve problems with JuMP.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Install a solver using the Julia package manager, replacing \"Clp\" by the Julia package name as appropriate.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.add(\"Clp\")","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Once installed, you can use Clp as a solver with JuMP as follows, using set_attribute to set solver-specific options:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"using JuMP\nusing Clp\nmodel = Model(Clp.Optimizer)\nset_attribute(model, \"LogLevel\" => 1)\nset_attribute(model, \"PrimalTolerance\" => 1e-7)","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nMost packages follow the ModuleName.Optimizer naming convention, but exceptions may exist. See the README of the Julia package's GitHub repository for more details on how to use a particular solver, including any solver-specific options.","category":"page"},{"location":"installation/#Supported-solvers","page":"Installation Guide","title":"Supported solvers","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Most solvers are not written in Julia, and some require commercial licenses to use, so installation is often more complex.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"If a solver has Manual in the Installation column, the solver requires a manual installation step, such as downloading and installing a binary, or obtaining a commercial license. Consult the README of the relevant Julia package for more information.\nIf the solver has Manualᴹ in the Installation column, the solver requires an installation of MATLAB.\nIf the Installation column is missing an entry, installing the Julia package will download and install any relevant solver binaries automatically, and you shouldn't need to do anything other than Pkg.add.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Solvers with a missing entry in the Julia Package column are written in Julia. The link in the Solver column is the corresponding Julia package.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Solver Julia Package Installation License Supports\nAlpine.jl   Triad NS (MI)NLP\nArtelys Knitro KNITRO.jl Manual Comm. (MI)LP, (MI)SOCP, (MI)NLP\nBARON BARON.jl Manual Comm. (MI)NLP\nBonmin AmplNLWriter.jl  EPL (MI)NLP\nCbc Cbc.jl  EPL (MI)LP\nCDCS CDCS.jl Manualᴹ GPL LP, SOCP, SDP\nCDD CDDLib.jl  GPL LP\nClarabel.jl   Apache LP, QP, SOCP, SDP\nClp Clp.jl  EPL LP\nCOPT COPT.jl  Comm. (MI)LP, SOCP, SDP\nCOSMO.jl   Apache LP, QP, SOCP, SDP\nCouenne AmplNLWriter.jl  EPL (MI)NLP\nCPLEX CPLEX.jl Manual Comm. (MI)LP, (MI)SOCP\nCSDP CSDP.jl  EPL LP, SDP\nDAQP DAQP.jl  MIT (Mixed-binary) QP\nEAGO.jl   MIT (MI)NLP\nECOS ECOS.jl  GPL LP, SOCP\nFICO Xpress Xpress.jl Manual Comm. (MI)LP, (MI)SOCP\nGLPK GLPK.jl  GPL (MI)LP\nGurobi Gurobi.jl Manual Comm. (MI)LP, (MI)SOCP\nHiGHS HiGHS.jl  MIT (MI)LP, QP\nHypatia.jl   MIT LP, SOCP, SDP\nIpopt Ipopt.jl  EPL LP, QP, NLP\nJuniper.jl   MIT (MI)SOCP, (MI)NLP\nLoraine.jl   MIT LP, SDP\nMadNLP.jl   MIT LP, QP, NLP\nMAiNGO MAiNGO.jl  EPL 2.0 (MI)NLP\nManopt.jl   MIT NLP\nMiniZinc MiniZinc.jl Manual MPL-2 CP-SAT\nMinotaur AmplNLWriter.jl Manual BSD-like (MI)NLP\nMOSEK MosekTools.jl Manual Comm. (MI)LP, (MI)SOCP, SDP\nNLopt NLopt.jl  GPL LP, QP, NLP\nOcteract AmplNLWriter.jl  Comm. (MI)NLP\nOptim.jl   MIT NLP\nOSQP OSQP.jl  Apache LP, QP\nPATH PATHSolver.jl  MIT MCP\nPajarito.jl   MPL-2 (MI)NLP, (MI)SOCP, (MI)SDP\nPavito.jl   MPL-2 (MI)NLP\nPenbmi Penopt.jl  Comm. Bilinear SDP\nPercival.jl   MPL-2 NLP\nPolyJuMP.KKT PolyJuMP.jl  MIT NLP\nPolyJuMP.QCQP PolyJuMP.jl  MIT NLP\nProxSDP.jl   MIT LP, SOCP, SDP\nRAPOSa AmplNLWriter.jl Manual RAPOSa (MI)NLP\nSCIP SCIP.jl  Apache (MI)LP, (MI)NLP\nSCS SCS.jl  MIT LP, QP, SOCP, SDP\nSDPA SDPA.jl, SDPAFamily.jl  GPL LP, SDP\nSDPLR SDPLR.jl  GPL LP, SDP\nSDPNAL SDPNAL.jl Manualᴹ CC BY-SA LP, SDP\nSDPT3 SDPT3.jl Manualᴹ GPL LP, SOCP, SDP\nSeDuMi SeDuMi.jl Manualᴹ GPL LP, SOCP, SDP\nStatusSwitchingQP.jl   MIT LP, QP\nTulip.jl   MPL-2 LP","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Where:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"LP = Linear programming\nQP = Quadratic programming\nSOCP = Second-order conic programming (including problems with convex quadratic constraints or objective)\nMCP = Mixed-complementarity programming\nNLP = Nonlinear programming\nSDP = Semidefinite programming\n(MI)XXX = Mixed-integer equivalent of problem type XXX\nCP-SAT = Constraint programming and Boolean satisfiability","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nDeveloped a solver or solver wrapper? This table is open for new contributions. Edit the installation.md file, and use the checklist Adding a new solver to the documentation when opening the pull request.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nDeveloping a solver or solver wrapper? See Models and the MathOptInterface docs for more details on how JuMP interacts with solvers. Please get in touch via the Developer Chatroom with any questions about connecting new solvers with JuMP.","category":"page"},{"location":"installation/#AMPL-based-solvers","page":"Installation Guide","title":"AMPL-based solvers","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Use AmplNLWriter to access solvers that support the NL format.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Some solvers, such as Bonmin and Couenne can be installed via the Julia package manager. Others need to be manually installed.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Consult the AMPL documentation for a complete list of supported solvers.","category":"page"},{"location":"installation/#GAMS-based-solvers","page":"Installation Guide","title":"GAMS-based solvers","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Use GAMS.jl to access solvers available through GAMS. Such solvers include: AlphaECP, Antigone, BARON, CONOPT, Couenne, LocalSolver, PATHNLP, SHOT, SNOPT, SoPlex. See a complete list here.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nGAMS.jl requires an installation of the commercial software GAMS for which a free community license exists.","category":"page"},{"location":"installation/#NEOS-based-solvers","page":"Installation Guide","title":"NEOS-based solvers","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Use NEOSServer.jl to access solvers available through the NEOS Server.","category":"page"},{"location":"installation/#Common-installation-issues","page":"Installation Guide","title":"Common installation issues","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"tip: Tip\nWhen in doubt, run import Pkg; Pkg.update() to see if updating your packages fixes the issue. Remember you will need to exit Julia and start a new session for the changes to take effect.","category":"page"},{"location":"installation/#Check-the-version-of-your-packages","page":"Installation Guide","title":"Check the version of your packages","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Each package is versioned with a three-part number of the form vX.Y.Z. You can check which versions you have installed with import Pkg; Pkg.status().","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"This should almost always be the most-recent release. You can check the releases of a package by going to the relevant GitHub page, and navigating to the \"releases\" page. For example, the list of JuMP releases is available at: https://github.com/jump-dev/JuMP.jl/releases.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"If you post on the community forum, please include the output of Pkg.status().","category":"page"},{"location":"installation/#Unsatisfiable-requirements-detected","page":"Installation Guide","title":"Unsatisfiable requirements detected","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Did you get an error like Unsatisfiable requirements detected for package JuMP? The Pkg documentation has a section on how to understand and manage these conflicts.","category":"page"},{"location":"installation/#Installing-new-packages-can-make-JuMP-downgrade-to-an-earlier-version","page":"Installation Guide","title":"Installing new packages can make JuMP downgrade to an earlier version","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Another common complaint is that after adding a new package, code that previously worked no longer works.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"This usually happens because the new package is not compatible with the latest version of JuMP. Therefore, the package manager rolls-back JuMP to an earlier version. Here's an example.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"First, we add JuMP:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"(jump_example) pkg> add JuMP\n  Resolving package versions...\nUpdating `~/jump_example/Project.toml`\n  [4076af6c] + JuMP v0.21.5\nUpdating `~/jump_example/Manifest.toml`\n  ... lines omitted ...","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"The + JuMP v0.21.5 line indicates that JuMP has been added at version 0.21.5. However, watch what happens when we add JuMPeR:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"(jump_example) pkg> add JuMPeR\n  Resolving package versions...\nUpdating `~/jump_example/Project.toml`\n  [4076af6c] ↓ JuMP v0.21.5 ⇒ v0.18.6\n  [707a9f91] + JuMPeR v0.6.0\nUpdating `~/jump_example/Manifest.toml`\n  ... lines omitted ...","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"JuMPeR gets added at version 0.6.0 (+ JuMPeR v0.6.0), but JuMP gets downgraded from 0.21.5 to 0.18.6 (↓ JuMP v0.21.5 ⇒ v0.18.6)! The reason for this is that JuMPeR doesn't support a version of JuMP newer than 0.18.6.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"tip: Tip\nPay careful attention to the output of the package manager when adding new packages, especially when you see a package being downgraded.","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/reference/errors.md\"","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/errors/#Errors","page":"Errors","title":"Errors","text":"","category":"section"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"When an MOI call fails on a model, precise errors should be thrown when possible instead of simply calling error with a message. The docstrings for the respective methods describe the errors that the implementation should throw in certain situations. This error-reporting system allows code to distinguish between internal errors (that should be shown to the user) and unsupported operations which may have automatic workarounds.","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"When an invalid index is used in an MOI call, an InvalidIndex is thrown:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"InvalidIndex","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.InvalidIndex","page":"Errors","title":"MathOptInterface.InvalidIndex","text":"struct InvalidIndex{IndexType<:Index} <: Exception\n    index::IndexType\nend\n\nAn error indicating that the index index is invalid.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"When an invalid result index is used to retrieve an attribute, a ResultIndexBoundsError is thrown:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"ResultIndexBoundsError\ncheck_result_index_bounds","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.ResultIndexBoundsError","page":"Errors","title":"MathOptInterface.ResultIndexBoundsError","text":"struct ResultIndexBoundsError{AttrType} <: Exception\n    attr::AttrType\n    result_count::Int\nend\n\nAn error indicating that the requested attribute attr could not be retrieved, because the solver returned too few results compared to what was requested. For instance, the user tries to retrieve VariablePrimal(2) when only one solution is available, or when the model is infeasible and has no solution.\n\nSee also: check_result_index_bounds.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.check_result_index_bounds","page":"Errors","title":"MathOptInterface.check_result_index_bounds","text":"check_result_index_bounds(model::ModelLike, attr)\n\nThis function checks whether enough results are available in the model for the requested attr, using its result_index field. If the model does not have sufficient results to answer the query, it throws a ResultIndexBoundsError.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"As discussed in JuMP mapping, for scalar constraint with a nonzero function constant, a ScalarFunctionConstantNotZero exception may be thrown:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"ScalarFunctionConstantNotZero","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.ScalarFunctionConstantNotZero","page":"Errors","title":"MathOptInterface.ScalarFunctionConstantNotZero","text":"struct ScalarFunctionConstantNotZero{T, F, S} <: Exception\n    constant::T\nend\n\nAn error indicating that the constant part of the function in the constraint F-in-S is nonzero.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"Some VariableIndex constraints cannot be combined on the same variable:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"LowerBoundAlreadySet\nUpperBoundAlreadySet","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.LowerBoundAlreadySet","page":"Errors","title":"MathOptInterface.LowerBoundAlreadySet","text":"LowerBoundAlreadySet{S1, S2}\n\nError thrown when setting a VariableIndex-in-S2 when a VariableIndex-in-S1 has already been added and the sets S1, S2 both set a lower bound, that is, they are EqualTo, GreaterThan, Interval, Semicontinuous or Semiinteger.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.UpperBoundAlreadySet","page":"Errors","title":"MathOptInterface.UpperBoundAlreadySet","text":"UpperBoundAlreadySet{S1, S2}\n\nError thrown when setting a VariableIndex-in-S2 when a VariableIndex-in-S1 has already been added and the sets S1, S2 both set an upper bound, that is, they are EqualTo, LessThan, Interval, Semicontinuous or Semiinteger.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"As discussed in AbstractCallback, trying to get attributes inside a callback may throw:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"OptimizeInProgress","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.OptimizeInProgress","page":"Errors","title":"MathOptInterface.OptimizeInProgress","text":"struct OptimizeInProgress{AttrType<:AnyAttribute} <: Exception\n    attr::AttrType\nend\n\nError thrown from optimizer when MOI.get(optimizer, attr) is called inside an AbstractCallback while it is only defined once optimize! has completed. This can only happen when is_set_by_optimize(attr) is true.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"Trying to submit the wrong type of AbstractSubmittable inside an AbstractCallback (for example, a UserCut inside a LazyConstraintCallback) will throw:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"InvalidCallbackUsage","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.InvalidCallbackUsage","page":"Errors","title":"MathOptInterface.InvalidCallbackUsage","text":"struct InvalidCallbackUsage{C, S} <: Exception\n    callback::C\n    submittable::S\nend\n\nAn error indicating that submittable cannot be submitted inside callback.\n\nFor example, UserCut cannot be submitted inside LazyConstraintCallback.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"The rest of the errors defined in MOI fall in two categories represented by the following two abstract types:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"UnsupportedError\nNotAllowedError","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.UnsupportedError","page":"Errors","title":"MathOptInterface.UnsupportedError","text":"UnsupportedError <: Exception\n\nAbstract type for error thrown when an element is not supported by the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.NotAllowedError","page":"Errors","title":"MathOptInterface.NotAllowedError","text":"NotAllowedError <: Exception\n\nAbstract type for error thrown when an operation is supported but cannot be applied in the current state of the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"The different UnsupportedError and NotAllowedError are the following errors:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"UnsupportedAttribute\nSetAttributeNotAllowed\nAddVariableNotAllowed\nUnsupportedConstraint\nAddConstraintNotAllowed\nModifyConstraintNotAllowed\nModifyObjectiveNotAllowed\nDeleteNotAllowed\nUnsupportedSubmittable\nSubmitNotAllowed\nUnsupportedNonlinearOperator","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.UnsupportedAttribute","page":"Errors","title":"MathOptInterface.UnsupportedAttribute","text":"struct UnsupportedAttribute{AttrType} <: UnsupportedError\n    attr::AttrType\n    message::String\nend\n\nAn error indicating that the attribute attr is not supported by the model, that is, that supports returns false.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.SetAttributeNotAllowed","page":"Errors","title":"MathOptInterface.SetAttributeNotAllowed","text":"struct SetAttributeNotAllowed{AttrType} <: NotAllowedError\n    attr::AttrType\n    message::String\nend\n\nAn error indicating that the attribute attr is supported (see supports) but cannot be set for some reason (see the error string).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.AddVariableNotAllowed","page":"Errors","title":"MathOptInterface.AddVariableNotAllowed","text":"struct AddVariableNotAllowed <: NotAllowedError\n    message::String # Human-friendly explanation why the attribute cannot be set\nend\n\nAn error indicating that variables cannot be added to the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.UnsupportedConstraint","page":"Errors","title":"MathOptInterface.UnsupportedConstraint","text":"struct UnsupportedConstraint{F<:AbstractFunction, S<:AbstractSet} <: UnsupportedError\n    message::String # Human-friendly explanation why the attribute cannot be set\nend\n\nAn error indicating that constraints of type F-in-S are not supported by the model, that is, that supports_constraint returns false.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.AddConstraintNotAllowed","page":"Errors","title":"MathOptInterface.AddConstraintNotAllowed","text":"struct AddConstraintNotAllowed{F<:AbstractFunction, S<:AbstractSet} <: NotAllowedError\n    message::String # Human-friendly explanation why the attribute cannot be set\nend\n\nAn error indicating that constraints of type F-in-S are supported (see supports_constraint) but cannot be added.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.ModifyConstraintNotAllowed","page":"Errors","title":"MathOptInterface.ModifyConstraintNotAllowed","text":"struct ModifyConstraintNotAllowed{F<:AbstractFunction, S<:AbstractSet,\n                                  C<:AbstractFunctionModification} <: NotAllowedError\n    constraint_index::ConstraintIndex{F, S}\n    change::C\n    message::String\nend\n\nAn error indicating that the constraint modification change cannot be applied to the constraint of index ci.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.ModifyObjectiveNotAllowed","page":"Errors","title":"MathOptInterface.ModifyObjectiveNotAllowed","text":"struct ModifyObjectiveNotAllowed{C<:AbstractFunctionModification} <: NotAllowedError\n    change::C\n    message::String\nend\n\nAn error indicating that the objective modification change cannot be applied to the objective.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.DeleteNotAllowed","page":"Errors","title":"MathOptInterface.DeleteNotAllowed","text":"struct DeleteNotAllowed{IndexType <: Index} <: NotAllowedError\n    index::IndexType\n    message::String\nend\n\nAn error indicating that the index index cannot be deleted.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.UnsupportedSubmittable","page":"Errors","title":"MathOptInterface.UnsupportedSubmittable","text":"struct UnsupportedSubmittable{SubmitType} <: UnsupportedError\n    sub::SubmitType\n    message::String\nend\n\nAn error indicating that the submittable sub is not supported by the model, that is, that supports returns false.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.SubmitNotAllowed","page":"Errors","title":"MathOptInterface.SubmitNotAllowed","text":"struct SubmitNotAllowed{SubmitTyp<:AbstractSubmittable} <: NotAllowedError\n    sub::SubmitType\n    message::String\nend\n\nAn error indicating that the submittable sub is supported (see supports) but cannot be added for some reason (see the error string).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/#MathOptInterface.UnsupportedNonlinearOperator","page":"Errors","title":"MathOptInterface.UnsupportedNonlinearOperator","text":"UnsupportedNonlinearOperator(head::Symbol[, message::String]) <: UnsupportedError\n\nAn error thrown by optimizers if they do not support the operator head in a ScalarNonlinearFunction.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> throw(MOI.UnsupportedNonlinearOperator(:black_box))\nERROR: MathOptInterface.UnsupportedNonlinearOperator: The nonlinear operator `:black_box` is not supported by the model.\nStacktrace:\n[...]\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"Note that setting the ConstraintFunction of a VariableIndex constraint is not allowed:","category":"page"},{"location":"moi/reference/errors/","page":"Errors","title":"Errors","text":"SettingVariableIndexNotAllowed","category":"page"},{"location":"moi/reference/errors/#MathOptInterface.SettingVariableIndexNotAllowed","page":"Errors","title":"MathOptInterface.SettingVariableIndexNotAllowed","text":"SettingVariableIndexNotAllowed()\n\nError type that should be thrown when the user calls set to change the ConstraintFunction of a VariableIndex constraint.\n\n\n\n\n\n","category":"type"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"EditURL = \"https://github.com/jump-dev/CPLEX.jl/blob/v1.0.3/README.md\"","category":"page"},{"location":"packages/CPLEX/#CPLEX.jl","page":"jump-dev/CPLEX.jl","title":"CPLEX.jl","text":"","category":"section"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"CPLEX.jl is a wrapper for the IBM® ILOG® CPLEX® Optimization Studio.","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"CPLEX.jl has two components:","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"a thin wrapper around the complete C API\nan interface to MathOptInterface","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"The C API can be accessed via CPLEX.CPXxx functions, where the names and arguments are identical to the C API. See the CPLEX documentation for details.","category":"page"},{"location":"packages/CPLEX/#Affiliation","page":"jump-dev/CPLEX.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"This wrapper is maintained by the JuMP community and is not officially supported by IBM. However, we thank IBM for providing us with a CPLEX license to test CPLEX.jl on GitHub. If you are a commercial customer interested in official support for CPLEX in Julia, let them know.","category":"page"},{"location":"packages/CPLEX/#License","page":"jump-dev/CPLEX.jl","title":"License","text":"","category":"section"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"CPLEX.jl is licensed under the MIT License.","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"The underlying solver is a closed-source commercial product for which you must purchase a license.","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"Free CPLEX licenses are available for academics and students.","category":"page"},{"location":"packages/CPLEX/#Installation","page":"jump-dev/CPLEX.jl","title":"Installation","text":"","category":"section"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"CPLEX.jl requires CPLEX version 12.10, 20.1, or 22.1.","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"First, obtain a license of CPLEX and install CPLEX solver, following the instructions on IBM's website.","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"Once installed, set the CPLEX_STUDIO_BINARIES environment variable as appropriate and run Pkg.add(\"CPLEX\"). For example:","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"# On Windows, this might be:\nENV[\"CPLEX_STUDIO_BINARIES\"] = \"C:\\\\Program Files\\\\CPLEX_Studio1210\\\\cplex\\\\bin\\\\x86-64_win\\\\\"\n# On OSX, this might be:\nENV[\"CPLEX_STUDIO_BINARIES\"] = \"/Applications/CPLEX_Studio1210/cplex/bin/x86-64_osx/\"\n# On Unix, this might be:\nENV[\"CPLEX_STUDIO_BINARIES\"] = \"/opt/CPLEX_Studio1210/cplex/bin/x86-64_linux/\"\n\nimport Pkg\nPkg.add(\"CPLEX\")","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"note: Note\nThe exact path may differ. Check which folder you installed CPLEX in, and update the path accordingly.","category":"page"},{"location":"packages/CPLEX/#Use-with-JuMP","page":"jump-dev/CPLEX.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"Use CPLEX.jl with JuMP as follows:","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"using JuMP, CPLEX\nmodel = Model(CPLEX.Optimizer)\nset_attribute(model, \"CPX_PARAM_EPINT\", 1e-8)","category":"page"},{"location":"packages/CPLEX/#MathOptInterface-API","page":"jump-dev/CPLEX.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"The CPLEX optimizer supports the following constraints and attributes.","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"List of supported objective functions:","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}\nMOI.ObjectiveFunction{MOI.ScalarQuadraticFunction{Float64}}\nMOI.ObjectiveFunction{MOI.VariableIndex}\nMOI.ObjectiveFunction{MOI.VectorAffineFunction{Float64}}","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"MOI.Reals","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"MOI.ScalarAffineFunction{Float64} in MOI.EqualTo{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.LessThan{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.EqualTo{Float64}\nMOI.VariableIndex in MOI.GreaterThan{Float64}\nMOI.VariableIndex in MOI.Integer\nMOI.VariableIndex in MOI.Interval{Float64}\nMOI.VariableIndex in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.Semicontinuous{Float64}\nMOI.VariableIndex in MOI.Semiinteger{Float64}\nMOI.VariableIndex in MOI.ZeroOne\nMOI.VectorOfVariables in MOI.SOS1{Float64}\nMOI.VectorOfVariables in MOI.SOS2{Float64}\nMOI.VectorOfVariables in MOI.SecondOrderCone","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"MOI.ConflictStatus()\nMOI.HeuristicCallback()\nMOI.LazyConstraintCallback()\nMOI.Name()\nMOI.ObjectiveSense()\nMOI.UserCutCallback()","category":"page"},{"location":"packages/CPLEX/#Options","page":"jump-dev/CPLEX.jl","title":"Options","text":"","category":"section"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"Options match those of the C API in the CPLEX documentation.","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"Set options using JuMP.set_attribute:","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"using JuMP, CPLEX\nmodel = Model(CPLEX.Optimizer)\nset_attribute(model, \"CPX_PARAM_EPINT\", 1e-8)","category":"page"},{"location":"packages/CPLEX/#Callbacks","page":"jump-dev/CPLEX.jl","title":"Callbacks","text":"","category":"section"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"CPLEX.jl provides a solver-specific callback to CPLEX:","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"using JuMP, CPLEX, Test\n\nmodel = direct_model(CPLEX.Optimizer())\nset_silent(model)\n\n# This is very, very important!!! Only use callbacks in single-threaded mode.\nMOI.set(model, MOI.NumberOfThreads(), 1)\n\n@variable(model, 0 <= x <= 2.5, Int)\n@variable(model, 0 <= y <= 2.5, Int)\n@objective(model, Max, y)\ncb_calls = Clong[]\nfunction my_callback_function(cb_data::CPLEX.CallbackContext, context_id::Clong)\n    # You can reference variables outside the function as normal\n    push!(cb_calls, context_id)\n    # You can select where the callback is run\n    if context_id != CPX_CALLBACKCONTEXT_CANDIDATE\n        return\n    end\n    ispoint_p = Ref{Cint}()\n    ret = CPXcallbackcandidateispoint(cb_data, ispoint_p)\n    if ret != 0 || ispoint_p[] == 0\n        return  # No candidate point available or error\n    end\n    # You can query CALLBACKINFO items\n    valueP = Ref{Cdouble}()\n    ret = CPXcallbackgetinfodbl(cb_data, CPXCALLBACKINFO_BEST_BND, valueP)\n    @info \"Best bound is currently: $(valueP[])\"\n    # As well as any other C API\n    x_p = Vector{Cdouble}(undef, 2)\n    obj_p = Ref{Cdouble}()\n    ret = CPXcallbackgetincumbent(cb_data, x_p, 0, 1, obj_p)\n    if ret == 0\n        @info \"Objective incumbent is: $(obj_p[])\"\n        @info \"Incumbent solution is: $(x_p)\"\n        # Use CPLEX.column to map between variable references and the 1-based\n        # column.\n        x_col = CPLEX.column(cb_data, index(x))\n        @info \"x = $(x_p[x_col])\"\n    else\n        # Unable to query incumbent.\n    end\n\n    # Before querying `callback_value`, you must call:\n    CPLEX.load_callback_variable_primal(cb_data, context_id)\n    x_val = callback_value(cb_data, x)\n    y_val = callback_value(cb_data, y)\n    # You can submit solver-independent MathOptInterface attributes such as\n    # lazy constraints, user-cuts, and heuristic solutions.\n    if y_val - x_val > 1 + 1e-6\n        con = @build_constraint(y - x <= 1)\n        MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n    elseif y_val + x_val > 3 + 1e-6\n        con = @build_constraint(y + x <= 3)\n        MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n    end\nend\nMOI.set(model, CPLEX.CallbackFunction(), my_callback_function)\noptimize!(model)\n@test termination_status(model) == MOI.OPTIMAL\n@test primal_status(model) == MOI.FEASIBLE_POINT\n@test value(x) == 1\n@test value(y) == 2","category":"page"},{"location":"packages/CPLEX/#Annotations-for-automatic-Benders'-decomposition","page":"jump-dev/CPLEX.jl","title":"Annotations for automatic Benders' decomposition","text":"","category":"section"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"Here is an example of using the annotation feature for automatic Benders' decomposition:","category":"page"},{"location":"packages/CPLEX/","page":"jump-dev/CPLEX.jl","title":"jump-dev/CPLEX.jl","text":"using JuMP, CPLEX\n\nfunction add_annotation(\n    model::JuMP.Model,\n    variable_classification::Dict;\n    all_variables::Bool = true,\n)\n    num_variables = sum(length(it) for it in values(variable_classification))\n    if all_variables\n        @assert num_variables == JuMP.num_variables(model)\n    end\n    indices, annotations = CPXINT[], CPXLONG[]\n    for (key, value) in variable_classification\n        for variable_ref in value\n            push!(indices, variable_ref.index.value - 1)\n            push!(annotations, CPX_BENDERS_MASTERVALUE + key)\n        end\n    end\n    cplex = backend(model)\n    index_p = Ref{CPXINT}()\n    CPXnewlongannotation(\n        cplex.env,\n        cplex.lp,\n        CPX_BENDERS_ANNOTATION,\n        CPX_BENDERS_MASTERVALUE,\n    )\n    CPXgetlongannotationindex(\n        cplex.env,\n        cplex.lp,\n        CPX_BENDERS_ANNOTATION,\n        index_p,\n    )\n    CPXsetlongannotations(\n        cplex.env,\n        cplex.lp,\n        index_p[],\n        CPX_ANNOTATIONOBJ_COL,\n        length(indices),\n        indices,\n        annotations,\n    )\n    return\nend\n\n# Problem\n\nfunction illustrate_full_annotation()\n    c_1, c_2 = [1, 4], [2, 3]\n    dim_x, dim_y = length(c_1), length(c_2)\n    b = [-2; -3]\n    A_1, A_2 = [1 -3; -1 -3], [1 -2; -1 -1]\n    model = JuMP.direct_model(CPLEX.Optimizer())\n    set_optimizer_attribute(model, \"CPXPARAM_Benders_Strategy\", 1)\n    @variable(model, x[1:dim_x] >= 0, Bin)\n    @variable(model, y[1:dim_y] >= 0)\n    variable_classification = Dict(0 => [x[1], x[2]], 1 => [y[1], y[2]])\n    @constraint(model, A_2 * y + A_1 * x .<= b)\n    @objective(model, Min, c_1' * x + c_2' * y)\n    add_annotation(model, variable_classification)\n    optimize!(model)\n    x_optimal = value.(x)\n    y_optimal = value.(y)\n    println(\"x: $(x_optimal), y: $(y_optimal)\")\nend\n\nfunction illustrate_partial_annotation()\n    c_1, c_2 = [1, 4], [2, 3]\n    dim_x, dim_y = length(c_1), length(c_2)\n    b = [-2; -3]\n    A_1, A_2 = [1 -3; -1 -3], [1 -2; -1 -1]\n    model = JuMP.direct_model(CPLEX.Optimizer())\n    # Note that the \"CPXPARAM_Benders_Strategy\" has to be set to 2 if partial\n    # annotation is provided. If \"CPXPARAM_Benders_Strategy\" is set to 1, then\n    # the following error will be thrown:\n    # `CPLEX Error  2002: Invalid Benders decomposition.`\n    set_optimizer_attribute(model, \"CPXPARAM_Benders_Strategy\", 2)\n    @variable(model, x[1:dim_x] >= 0, Bin)\n    @variable(model, y[1:dim_y] >= 0)\n    variable_classification = Dict(0 => [x[1]], 1 => [y[1], y[2]])\n    @constraint(model, A_2 * y + A_1 * x .<= b)\n    @objective(model, Min, c_1' * x + c_2' * y)\n    add_annotation(model, variable_classification; all_variables = false)\n    optimize!(model)\n    x_optimal = value.(x)\n    y_optimal = value.(y)\n    println(\"x: $(x_optimal), y: $(y_optimal)\")\nend","category":"page"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"EditURL = nothing","category":"page"},{"location":"api/JuMP/#DocumenterReference_JuMP","page":"JuMP","title":"JuMP","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"This page lists the public API of JuMP.","category":"page"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"info: Info\nThis page is an unstructured list of the JuMP API. For a more structured overview, read the Manual or Tutorial parts of this documentation.","category":"page"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"Load all of the public the API into the current scope with:","category":"page"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"using JuMP","category":"page"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"Alternatively, load only the module with:","category":"page"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"import JuMP","category":"page"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"and then prefix all calls with JuMP. to create JuMP.<NAME>.","category":"page"},{"location":"api/JuMP/#@build_constraint","page":"JuMP","title":"@build_constraint","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.@build_constraint","category":"page"},{"location":"api/JuMP/#JuMP.@build_constraint","page":"JuMP","title":"JuMP.@build_constraint","text":"@build_constraint(constraint_expr)\n\nConstructs a ScalarConstraint or VectorConstraint using the same machinery as @constraint but without adding the constraint to a model.\n\nConstraints using broadcast operators like x .<= 1 are also supported and will create arrays of ScalarConstraint or VectorConstraint.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @build_constraint(2x >= 1)\nScalarConstraint{AffExpr, MathOptInterface.GreaterThan{Float64}}(2 x, MathOptInterface.GreaterThan{Float64}(1.0))\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP/#@constraint","page":"JuMP","title":"@constraint","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.@constraint","category":"page"},{"location":"api/JuMP/#JuMP.@constraint","page":"JuMP","title":"JuMP.@constraint","text":"@constraint(model, expr, args...; kwargs...)\n@constraint(model, [index_sets...], expr, args...; kwargs...)\n@constraint(model, name, expr, args...; kwargs...)\n@constraint(model, name[index_sets...], expr, args...; kwargs...)\n\nAdd a constraint described by the expression expr.\n\nThe name argument is optional. If index sets are passed, a container is built and the constraint may depend on the indices of the index sets.\n\nThe expression expr may be one of following forms:\n\nfunc in set, constraining the function func to belong to the set set, which is either a MOI.AbstractSet or one of the JuMP shortcuts like SecondOrderCone or PSDCone\na <op> b, where <op> is one of ==, ≥, >=, ≤, <=\nl <= f <= u or u >= f >= l, constraining the expression f to lie between l and u\nf(x) ⟂ x, which defines a complementarity constraint\nz --> {expr}, which defines an indicator constraint that activates when z is 1\n!z --> {expr}, which defines an indicator constraint that activates\n\nwhen z is 0\n\nz <--> {expr}, which defines a reified constraint\nexpr := rhs, which defines a Boolean equality constraint\n\nBroadcasted comparison operators like .== are also supported for the case when the left- and right-hand sides of the comparison operator are arrays.\n\nJuMP extensions may additionally provide support for constraint expressions which are not listed here.\n\nKeyword arguments\n\nbase_name: sets the name prefix used to generate constraint names. It corresponds to the constraint name for scalar constraints, otherwise, the constraint names are set to base_name[...] for each index ....\ncontainer = :Auto: force the container type by passing container = Array,\n\ncontainer = DenseAxisArray, container = SparseAxisArray, or any another   container type which is supported by a JuMP extension.\n\nset_string_name::Bool = true: control whether to set the MOI.ConstraintName attribute. Passing set_string_name = false can improve performance.\n\nOther keyword arguments may be supported by JuMP extensions.\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP/#@constraints","page":"JuMP","title":"@constraints","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.@constraints","category":"page"},{"location":"api/JuMP/#JuMP.@constraints","page":"JuMP","title":"JuMP.@constraints","text":"@constraints(model, args...)\n\nAdds groups of constraints at once, in the same fashion as the @constraint macro.\n\nThe model must be the first argument, and multiple constraints can be added on multiple lines wrapped in a begin ... end block.\n\nThe macro returns a tuple containing the constraints that were defined.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, w);\n\njulia> @variable(model, x);\n\njulia> @variable(model, y);\n\njulia> @variable(model, z[1:3]);\n\njulia> @constraints(model, begin\n           x >= 1\n           y - w <= 2\n           sum_to_one[i=1:3], z[i] + y == 1\n       end);\n\njulia> print(model)\nFeasibility\nSubject to\n sum_to_one[1] : y + z[1] = 1\n sum_to_one[2] : y + z[2] = 1\n sum_to_one[3] : y + z[3] = 1\n x ≥ 1\n -w + y ≤ 2\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP/#@expression","page":"JuMP","title":"@expression","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.@expression","category":"page"},{"location":"api/JuMP/#JuMP.@expression","page":"JuMP","title":"JuMP.@expression","text":"@expression(model::GenericModel, expression)\n@expression(model::GenericModel, [index_sets...], expression)\n@expression(model::GenericModel, name, expression)\n@expression(model::GenericModel, name[index_sets...], expression)\n\nEfficiently builds and returns an expression.\n\nThe name argument is optional. If index sets are passed, a container is built and the expression may depend on the indices of the index sets.\n\nKeyword arguments\n\ncontainer = :Auto: force the container type by passing container = Array, container = DenseAxisArray, container = SparseAxisArray, or any another container type which is supported by a JuMP extension.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x[1:5]);\n\njulia> @expression(model, shared, sum(i * x[i] for i in 1:5))\nx[1] + 2 x[2] + 3 x[3] + 4 x[4] + 5 x[5]\n\njulia> shared\nx[1] + 2 x[2] + 3 x[3] + 4 x[4] + 5 x[5]\n\nIn the same way as @variable, the second argument may define index sets, and those indices can be used in the construction of the expressions:\n\njulia> model = Model();\n\njulia> @variable(model, x[1:3]);\n\njulia> @expression(model, expr[i = 1:3], i * sum(x[j] for j in 1:3))\n3-element Vector{AffExpr}:\n x[1] + x[2] + x[3]\n 2 x[1] + 2 x[2] + 2 x[3]\n 3 x[1] + 3 x[2] + 3 x[3]\n\nAnonymous syntax is also supported:\n\njulia> model = Model();\n\njulia> @variable(model, x[1:3]);\n\njulia> expr = @expression(model, [i in 1:3], i * sum(x[j] for j in 1:3))\n3-element Vector{AffExpr}:\n x[1] + x[2] + x[3]\n 2 x[1] + 2 x[2] + 2 x[3]\n 3 x[1] + 3 x[2] + 3 x[3]\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP/#@expressions","page":"JuMP","title":"@expressions","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.@expressions","category":"page"},{"location":"api/JuMP/#JuMP.@expressions","page":"JuMP","title":"JuMP.@expressions","text":"@expressions(model, args...)\n\nAdds multiple expressions to model at once, in the same fashion as the @expression macro.\n\nThe model must be the first argument, and multiple expressions can be added on multiple lines wrapped in a begin ... end block.\n\nThe macro returns a tuple containing the expressions that were defined.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @variable(model, y);\n\njulia> @variable(model, z[1:2]);\n\njulia> a = [4, 5];\n\njulia> @expressions(model, begin\n           my_expr, x^2 + y^2\n           my_expr_1[i = 1:2], a[i] - z[i]\n       end)\n(x² + y², AffExpr[-z[1] + 4, -z[2] + 5])\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP/#@force_nonlinear","page":"JuMP","title":"@force_nonlinear","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.@force_nonlinear","category":"page"},{"location":"api/JuMP/#JuMP.@force_nonlinear","page":"JuMP","title":"JuMP.@force_nonlinear","text":"@force_nonlinear(expr)\n\nChange the parsing of expr to construct GenericNonlinearExpr instead of GenericAffExpr or GenericQuadExpr.\n\nThis macro works by walking expr and substituting all calls to +, -, *, /, and ^ in favor of ones that construct GenericNonlinearExpr.\n\nThis macro will error if the resulting expression does not produce a GenericNonlinearExpr because, for example, it is used on an expression that does not use the basic arithmetic operators.\n\nWhen to use this macro\n\nIn most cases, you should not use this macro.\n\nUse this macro only if the intended output type is a GenericNonlinearExpr and the regular macro calls destroy problem structure, or in rare cases, if the regular macro calls introduce a large amount of intermediate variables, for example, because they promote types to a common quadratic expression.\n\nExample\n\nUse-case one: preserve problem structure.\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @expression(model, (x - 0.1)^2)\nx² - 0.2 x + 0.010000000000000002\n\njulia> @expression(model, @force_nonlinear((x - 0.1)^2))\n(x - 0.1) ^ 2\n\njulia> (x - 0.1)^2\nx² - 0.2 x + 0.010000000000000002\n\njulia> @force_nonlinear((x - 0.1)^2)\n(x - 0.1) ^ 2\n\nUse-case two: reduce allocations\n\nIn this example, we know that x * 2.0 * (1 + x) * x is going to construct a nonlinear expression.\n\nHowever, the default parsing first constructs:\n\nthe GenericAffExpr a = x * 2.0,\nanother GenericAffExpr b = 1 + x\nthe GenericQuadExpr c = a * b\na GenericNonlinearExpr *(c, x)\n\nIn contrast, the modified parsing constructs:\n\nthe GenericNonlinearExpr a = GenericNonlinearExpr(:+, 1, x)\nthe GenericNonlinearExpr GenericNonlinearExpr(:*, x, 2.0, a, x)\n\nThis results in significantly fewer allocations.\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @expression(model, x * 2.0 * (1 + x) * x)\n(2 x² + 2 x) * x\n\njulia> @expression(model, @force_nonlinear(x * 2.0 * (1 + x) * x))\nx * 2.0 * (1 + x) * x\n\njulia> @allocated @expression(model, x * 2.0 * (1 + x) * x)\n3200\n\njulia> @allocated @expression(model, @force_nonlinear(x * 2.0 * (1 + x) * x))\n640\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP/#@objective","page":"JuMP","title":"@objective","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.@objective","category":"page"},{"location":"api/JuMP/#JuMP.@objective","page":"JuMP","title":"JuMP.@objective","text":"@objective(model::GenericModel, sense, func)\n\nSet the objective sense to sense and objective function to func.\n\nThe objective sense can be either Min, Max, MOI.MIN_SENSE, MOI.MAX_SENSE or MOI.FEASIBILITY_SENSE. In order to set the sense programmatically, that is, when sense is a variable whose value is the sense, one of the three MOI.OptimizationSense values must be used.\n\nExample\n\nMinimize the value of the variable x, do:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @objective(model, Min, x)\nx\n\nMaximize the value of the affine expression 2x - 1:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @objective(model, Max, 2x - 1)\n2 x - 1\n\nSet the objective sense programmatically:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> sense = MIN_SENSE\nMIN_SENSE::OptimizationSense = 0\n\njulia> @objective(model, sense, x^2 - 2x + 1)\nx² - 2 x + 1\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP/#@operator","page":"JuMP","title":"@operator","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.@operator","category":"page"},{"location":"api/JuMP/#JuMP.@operator","page":"JuMP","title":"JuMP.@operator","text":"@operator(model, operator, dim, f[, ∇f[, ∇²f]])\n\nAdd the nonlinear operator operator in model with dim arguments, and create a new NonlinearOperator object called operator in the current scope.\n\nThe function f evaluates the operator and must return a scalar.\n\nThe optional function ∇f evaluates the first derivative, and the optional function ∇²f evaluates the second derivative.\n\n∇²f may be provided only if ∇f is also provided.\n\nUnivariate syntax\n\nIf dim == 1, then the method signatures of each function must be:\n\nf(::T)::T where {T<:Real}\n∇f(::T)::T where {T<:Real}\n∇²f(::T)::T where {T<:Real}\n\nMultivariate syntax\n\nIf dim > 1, then the method signatures of each function must be:\n\nf(x::T...)::T where {T<:Real}\n∇f(g::AbstractVector{T}, x::T...)::Nothing where {T<:Real}\n∇²f(H::AbstractMatrix{T}, x::T...)::Nothing where {T<:Real}\n\nWhere the gradient vector g and Hessian matrix H are filled in-place. For the Hessian, you must fill in the non-zero lower-triangular entries only. Setting an off-diagonal upper-triangular element may error.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> f(x::Float64) = x^2\nf (generic function with 1 method)\n\njulia> ∇f(x::Float64) = 2 * x\n∇f (generic function with 1 method)\n\njulia> ∇²f(x::Float64) = 2.0\n∇²f (generic function with 1 method)\n\njulia> @operator(model, op_f, 1, f, ∇f, ∇²f)\nNonlinearOperator(f, :op_f)\n\njulia> @objective(model, Min, op_f(x))\nop_f(x)\n\njulia> op_f(2.0)\n4.0\n\njulia> model[:op_f]\nNonlinearOperator(f, :op_f)\n\njulia> model[:op_f](x)\nop_f(x)\n\nNon-macro version\n\nThis macro is provided as helpful syntax that matches the style of the rest of the JuMP macros. However, you may also add operators outside the macro using add_nonlinear_operator. For example:\n\njulia> model = Model();\n\njulia> f(x) = x^2\nf (generic function with 1 method)\n\njulia> @operator(model, op_f, 1, f)\nNonlinearOperator(f, :op_f)\n\nis equivalent to\n\njulia> model = Model();\n\njulia> f(x) = x^2\nf (generic function with 1 method)\n\njulia> op_f = model[:op_f] = add_nonlinear_operator(model, 1, f; name = :op_f)\nNonlinearOperator(f, :op_f)\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP/#@variable","page":"JuMP","title":"@variable","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.@variable","category":"page"},{"location":"api/JuMP/#JuMP.@variable","page":"JuMP","title":"JuMP.@variable","text":"@variable(model, expr, args..., kw_args...)\n\nAdd a variable to the model model described by the expression expr, the positional arguments args and the keyword arguments kw_args.\n\nAnonymous and named variables\n\nexpr must be one of the forms:\n\nOmitted, like @variable(model), which creates an anonymous variable\nA single symbol like @variable(model, x)\nA container expression like @variable(model, x[i=1:3])\nAn anonymous container expression like @variable(model, [i=1:3])\n\nBounds\n\nIn addition, the expression can have bounds, such as:\n\n@variable(model, x >= 0)\n@variable(model, x <= 0)\n@variable(model, x == 0)\n@variable(model, 0 <= x <= 1)\n\nand bounds can depend on the indices of the container expressions:\n\n@variable(model, -i <= x[i=1:3] <= i)\n\nSets\n\nYou can explicitly specify the set to which the variable belongs:\n\n@variable(model, x in MOI.Interval(0.0, 1.0))\n\nFor more information on this syntax, read Variables constrained on creation.\n\nPositional arguments\n\nThe recognized positional arguments in args are the following:\n\nBin: restricts the variable to the MOI.ZeroOne set, that is, {0, 1}. For example, @variable(model, x, Bin). Note: you cannot use @variable(model, Bin), use the binary keyword instead.\nInt: restricts the variable to the set of integers, that is, ..., -2, -1,  0, 1, 2, ... For example, @variable(model, x, Int). Note: you cannot use  @variable(model, Int), use the integer keyword instead.\nSymmetric: Only available when creating a square matrix of variables, that is when expr is of the form varname[1:n,1:n] or varname[i=1:n,j=1:n], it creates a symmetric matrix of variables.\nPSD: A restrictive extension to Symmetric which constraints a square matrix of variables to Symmetric and constrains to be positive semidefinite.\n\nKeyword arguments\n\nFour keyword arguments are useful in all cases:\n\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes.\nstart::Float64: specify the value passed to set_start_value for each variable\ncontainer: specify the container type. See Forcing the container type for more information.\nset_string_name::Bool = true: control whether to set the MOI.VariableName attribute. Passing set_string_name = false can improve performance.\n\nOther keyword arguments are needed to disambiguate sitations with anonymous variables:\n\nlower_bound::Float64: an alternative to x >= lb, sets the value of the variable lower bound.\nupper_bound::Float64: an alternative to x <= ub, sets the value of the variable upper bound.\nbinary::Bool: an alternative to passing Bin, sets whether the variable is binary or not.\ninteger::Bool: an alternative to passing Int, sets whether the variable is integer or not.\nset::MOI.AbstractSet: an alternative to using x in set\nvariable_type: used by JuMP extensions. See Extend @variable for more information.\n\nExample\n\nThe following are equivalent ways of creating a variable x of name x with lower bound 0:\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0)\nx\n\njulia> model = Model();\n\njulia> @variable(model, x, lower_bound = 0)\nx\n\njulia> model = Model();\n\njulia> x = @variable(model, base_name = \"x\", lower_bound = 0)\nx\n\nOther examples:\n\njulia> model = Model();\n\njulia> @variable(model, x[i=1:3] <= i, Int, start = sqrt(i), lower_bound = -i)\n3-element Vector{VariableRef}:\n x[1]\n x[2]\n x[3]\n\njulia> @variable(model, y[i=1:3], container = DenseAxisArray, set = MOI.ZeroOne())\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Base.OneTo(3)\nAnd data, a 3-element Vector{VariableRef}:\n y[1]\n y[2]\n y[3]\n\njulia> @variable(model, z[i=1:3], set_string_name = false)\n3-element Vector{VariableRef}:\n _[7]\n _[8]\n _[9]\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP/#@variables","page":"JuMP","title":"@variables","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.@variables","category":"page"},{"location":"api/JuMP/#JuMP.@variables","page":"JuMP","title":"JuMP.@variables","text":"@variables(model, args...)\n\nAdds multiple variables to model at once, in the same fashion as the @variable macro.\n\nThe model must be the first argument, and multiple variables can be added on multiple lines wrapped in a begin ... end block.\n\nThe macro returns a tuple containing the variables that were defined.\n\nExample\n\njulia> model = Model();\n\njulia> @variables(model, begin\n           x\n           y[i = 1:2] >= 0, (start = i)\n           z, Bin, (start = 0, base_name = \"Z\")\n       end)\n(x, VariableRef[y[1], y[2]], Z)\n\nnote: Note\nKeyword arguments must be contained within parentheses (refer to the example above).\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP/#add_bridge","page":"JuMP","title":"add_bridge","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.add_bridge","category":"page"},{"location":"api/JuMP/#JuMP.add_bridge","page":"JuMP","title":"JuMP.add_bridge","text":"add_bridge(\n    model::GenericModel{T},\n    BT::Type{<:MOI.Bridges.AbstractBridge};\n    coefficient_type::Type{S} = T,\n) where {T,S}\n\nAdd BT{T} to the list of bridges that can be used to transform unsupported constraints into an equivalent formulation using only constraints supported by the optimizer.\n\nSee also: remove_bridge.\n\nExample\n\njulia> model = Model();\n\njulia> add_bridge(model, MOI.Bridges.Constraint.SOCtoNonConvexQuadBridge)\n\njulia> add_bridge(\n           model,\n           MOI.Bridges.Constraint.NumberConversionBridge;\n           coefficient_type = Complex{Float64}\n       )\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#add_constraint","page":"JuMP","title":"add_constraint","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.add_constraint","category":"page"},{"location":"api/JuMP/#JuMP.add_constraint","page":"JuMP","title":"JuMP.add_constraint","text":"add_constraint(model::GenericModel, con::AbstractConstraint, name::String=\"\")\n\nAdd a constraint con to Model model and sets its name.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#add_nonlinear_operator","page":"JuMP","title":"add_nonlinear_operator","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.add_nonlinear_operator","category":"page"},{"location":"api/JuMP/#JuMP.add_nonlinear_operator","page":"JuMP","title":"JuMP.add_nonlinear_operator","text":"add_nonlinear_operator(\n    model::Model,\n    dim::Int,\n    f::Function,\n    [∇f::Function,]\n    [∇²f::Function];\n    [name::Symbol = Symbol(f),]\n)\n\nAdd a new nonlinear operator with dim input arguments to model and associate it with the name name.\n\nThe function f evaluates the operator and must return a scalar.\n\nThe optional function ∇f evaluates the first derivative, and the optional function ∇²f evaluates the second derivative.\n\n∇²f may be provided only if ∇f is also provided.\n\nUnivariate syntax\n\nIf dim == 1, then the method signatures of each function must be:\n\nf(::T)::T where {T<:Real}\n∇f(::T)::T where {T<:Real}\n∇²f(::T)::T where {T<:Real}\n\nMultivariate syntax\n\nIf dim > 1, then the method signatures of each function must be:\n\nf(x::T...)::T where {T<:Real}\n∇f(g::AbstractVector{T}, x::T...)::Nothing where {T<:Real}\n∇²f(H::AbstractMatrix{T}, x::T...)::Nothing where {T<:Real}\n\nWhere the gradient vector g and Hessian matrix H are filled in-place. For the Hessian, you must fill in the non-zero lower-triangular entries only. Setting an off-diagonal upper-triangular element may error.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> f(x::Float64) = x^2\nf (generic function with 1 method)\n\njulia> ∇f(x::Float64) = 2 * x\n∇f (generic function with 1 method)\n\njulia> ∇²f(x::Float64) = 2.0\n∇²f (generic function with 1 method)\n\njulia> op_f = add_nonlinear_operator(model, 1, f, ∇f, ∇²f)\nNonlinearOperator(f, :f)\n\njulia> @objective(model, Min, op_f(x))\nf(x)\n\njulia> op_f(2.0)\n4.0\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#add_nonlinear_parameter","page":"JuMP","title":"add_nonlinear_parameter","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.add_nonlinear_parameter","category":"page"},{"location":"api/JuMP/#JuMP.add_nonlinear_parameter","page":"JuMP","title":"JuMP.add_nonlinear_parameter","text":"add_nonlinear_parameter(model::Model, value::Real)\n\nAdd an anonymous parameter to the model.\n\ncompat: Compat\nThis function is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#add_to_expression!","page":"JuMP","title":"add_to_expression!","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.add_to_expression!","category":"page"},{"location":"api/JuMP/#JuMP.add_to_expression!","page":"JuMP","title":"JuMP.add_to_expression!","text":"add_to_expression!(expression, terms...)\n\nUpdates expression in place to expression + (*)(terms...). This is typically much more efficient than expression += (*)(terms...). For example, add_to_expression!(expression, a, b) produces the same result as expression += a*b, and add_to_expression!(expression, a) produces the same result as expression += a.\n\nOnly a few methods are defined, mostly for internal use, and only for the cases when (1) they can be implemented efficiently and (2) expression is capable of storing the result. For example, add_to_expression!(::AffExpr, ::GenericVariableRef, ::GenericVariableRef) is not defined because a GenericAffExpr cannot store the product of two variables.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#add_to_function_constant","page":"JuMP","title":"add_to_function_constant","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.add_to_function_constant","category":"page"},{"location":"api/JuMP/#JuMP.add_to_function_constant","page":"JuMP","title":"JuMP.add_to_function_constant","text":"add_to_function_constant(constraint::ConstraintRef, value)\n\nAdd value to the function constant term of constraint.\n\nNote that for scalar constraints, JuMP will aggregate all constant terms onto the right-hand side of the constraint so instead of modifying the function, the set will be translated by -value. For example, given a constraint 2x <= 3, add_to_function_constant(c, 4) will modify it to 2x <= -1.\n\nExample\n\nFor scalar constraints, the set is translated by -value:\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @constraint(model, con, 0 <= 2x - 1 <= 2)\ncon : 2 x ∈ [1, 3]\n\njulia> add_to_function_constant(con, 4)\n\njulia> con\ncon : 2 x ∈ [-3, -1]\n\nFor vector constraints, the constant is added to the function:\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @variable(model, y);\n\njulia> @constraint(model, con, [x + y, x, y] in SecondOrderCone())\ncon : [x + y, x, y] ∈ MathOptInterface.SecondOrderCone(3)\n\njulia> add_to_function_constant(con, [1, 2, 2])\n\njulia> con\ncon : [x + y + 1, x + 2, y + 2] ∈ MathOptInterface.SecondOrderCone(3)\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#add_variable","page":"JuMP","title":"add_variable","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.add_variable","category":"page"},{"location":"api/JuMP/#JuMP.add_variable","page":"JuMP","title":"JuMP.add_variable","text":"add_variable(m::GenericModel, v::AbstractVariable, name::String=\"\")\n\nAdd a variable v to Model m and sets its name.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#all_constraints","page":"JuMP","title":"all_constraints","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.all_constraints","category":"page"},{"location":"api/JuMP/#JuMP.all_constraints","page":"JuMP","title":"JuMP.all_constraints","text":"all_constraints(model::GenericModel, function_type, set_type)::Vector{<:ConstraintRef}\n\nReturn a list of all constraints currently in the model where the function has type function_type and the set has type set_type. The constraints are ordered by creation time.\n\nSee also list_of_constraint_types and num_constraints.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> all_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n1-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64}}, ScalarShape}}:\n x ≥ 0\n\njulia> all_constraints(model, VariableRef, MOI.ZeroOne)\n1-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}, ScalarShape}}:\n x binary\n\njulia> all_constraints(model, AffExpr, MOI.LessThan{Float64})\n1-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n 2 x ≤ 1\n\n\n\n\n\nall_constraints(\n    model::GenericModel;\n    include_variable_in_set_constraints::Bool,\n)::Vector{ConstraintRef}\n\nReturn a list of all constraints in model.\n\nIf include_variable_in_set_constraints == true, then VariableRef constraints such as VariableRef-in-Integer are included. To return only the structural constraints (for example, the rows in the constraint matrix of a linear program), pass include_variable_in_set_constraints = false.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Int);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> @NLconstraint(model, x^2 <= 1);\n\njulia> all_constraints(model; include_variable_in_set_constraints = true)\n4-element Vector{ConstraintRef}:\n 2 x ≤ 1\n x ≥ 0\n x integer\n x ^ 2.0 - 1.0 ≤ 0\n\njulia> all_constraints(model; include_variable_in_set_constraints = false)\n2-element Vector{ConstraintRef}:\n 2 x ≤ 1\n x ^ 2.0 - 1.0 ≤ 0\n\nPerformance considerations\n\nNote that this function is type-unstable because it returns an abstractly typed vector. If performance is a problem, consider using list_of_constraint_types and a function barrier. See the Performance tips for extensions section of the documentation for more details.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#all_variables","page":"JuMP","title":"all_variables","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.all_variables","category":"page"},{"location":"api/JuMP/#JuMP.all_variables","page":"JuMP","title":"JuMP.all_variables","text":"all_variables(model::GenericModel{T})::Vector{GenericVariableRef{T}} where {T}\n\nReturns a list of all variables currently in the model. The variables are ordered by creation time.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @variable(model, y);\n\njulia> all_variables(model)\n2-element Vector{VariableRef}:\n x\n y\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#anonymous_name","page":"JuMP","title":"anonymous_name","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.anonymous_name","category":"page"},{"location":"api/JuMP/#JuMP.anonymous_name","page":"JuMP","title":"JuMP.anonymous_name","text":"anonymous_name(::MIME, x::AbstractVariableRef)\n\nThe name to use for an anonymous variable x when printing.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#backend","page":"JuMP","title":"backend","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.backend","category":"page"},{"location":"api/JuMP/#JuMP.backend","page":"JuMP","title":"JuMP.backend","text":"backend(model::GenericModel)\n\nReturn the lower-level MathOptInterface model that sits underneath JuMP. This model depends on which operating mode JuMP is in (see mode).\n\nIf JuMP is in DIRECT mode (that is, the model was created using direct_model), the backend will be the optimizer passed to direct_model.\nIf JuMP is in MANUAL or AUTOMATIC mode, the backend is a MOI.Utilities.CachingOptimizer.\n\nUse index to get the index of a variable or constraint in the backend model.\n\nwarning: Warning\nThis function should only be used by advanced users looking to access low-level MathOptInterface or solver-specific functionality.\n\nNotes\n\nIf JuMP is not in DIRECT mode, the type returned by backend may change between any JuMP releases. Therefore, only use the public API exposed by MathOptInterface, and do not access internal fields. If you require access to the innermost optimizer, see unsafe_backend. Alternatively, use direct_model to create a JuMP model in DIRECT mode.\n\nSee also: unsafe_backend.\n\nExample\n\njulia> import HiGHS\n\njulia> model = direct_model(HiGHS.Optimizer());\n\njulia> set_silent(model)\n\njulia> @variable(model, x >= 0)\nx\n\njulia> highs = backend(model)\nA HiGHS model with 1 columns and 0 rows.\n\njulia> index(x)\nMOI.VariableIndex(1)\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#barrier_iterations","page":"JuMP","title":"barrier_iterations","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.barrier_iterations","category":"page"},{"location":"api/JuMP/#JuMP.barrier_iterations","page":"JuMP","title":"JuMP.barrier_iterations","text":"barrier_iterations(model::GenericModel)\n\nGets the cumulative number of barrier iterations during the most recent optimization.\n\nSolvers must implement MOI.BarrierIterations() to use this function.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#bridge_constraints","page":"JuMP","title":"bridge_constraints","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.bridge_constraints","category":"page"},{"location":"api/JuMP/#JuMP.bridge_constraints","page":"JuMP","title":"JuMP.bridge_constraints","text":"bridge_constraints(model::GenericModel)\n\nWhen in direct mode, return false.\n\nWhen in manual or automatic mode, return a Bool indicating whether the optimizer is set and unsupported constraints are automatically bridged to equivalent supported constraints when an appropriate transformation is available.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#build_constraint","page":"JuMP","title":"build_constraint","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.build_constraint","category":"page"},{"location":"api/JuMP/#JuMP.build_constraint","page":"JuMP","title":"JuMP.build_constraint","text":"build_constraint(\n    error_fn::Function,\n    Q::LinearAlgebra.Symmetric{V, M},\n    ::PSDCone,\n) where {V<:AbstractJuMPScalar,M<:AbstractMatrix{V}}\n\nReturn a VectorConstraint of shape SymmetricMatrixShape constraining the matrix Q to be positive semidefinite.\n\nThis function is used by the @constraint macros as follows:\n\njulia> import LinearAlgebra\n\njulia> model = Model();\n\njulia> @variable(model, Q[1:2, 1:2]);\n\njulia> @constraint(model, LinearAlgebra.Symmetric(Q) in PSDCone())\n[Q[1,1]  Q[1,2];\n Q[1,2]  Q[2,2]] ∈ PSDCone()\n\nThe form above is usually used when the entries of Q are affine or quadratic expressions, but it can also be used when the entries are variables to get the reference of the semidefinite constraint, for example,\n\njulia> model = Model();\n\njulia> @variable(model, Q[1:2, 1:2], Symmetric)\n2×2 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:\n Q[1,1]  Q[1,2]\n Q[1,2]  Q[2,2]\n\njulia> @constraint(model, Q in PSDCone())\n[Q[1,1]  Q[1,2];\n Q[1,2]  Q[2,2]] ∈ PSDCone()\n\n\n\n\n\nbuild_constraint(\n    error_fn::Function,\n    Q::AbstractMatrix{<:AbstractJuMPScalar},\n    ::PSDCone,\n)\n\nReturn a VectorConstraint of shape SquareMatrixShape constraining the matrix Q to be symmetric and positive semidefinite.\n\nThis function is used by the @constraint macro as follows:\n\njulia> model = Model();\n\njulia> @variable(model, Q[1:2, 1:2]);\n\njulia> @constraint(model, Q in PSDCone())\n[Q[1,1]  Q[1,2];\n Q[2,1]  Q[2,2]] ∈ PSDCone()\n\n\n\n\n\nbuild_constraint(\n    error_fn::Function,\n    Q::LinearAlgebra.Hermitian{V,M},\n    ::HermitianPSDCone,\n) where {V<:AbstractJuMPScalar,M<:AbstractMatrix{V}}\n\nReturn a VectorConstraint of shape HermitianMatrixShape constraining the matrix Q to be Hermitian positive semidefinite.\n\nThis function is used by the @constraint macros as follows:\n\njulia> import LinearAlgebra\n\njulia> model = Model();\n\njulia> @variable(model, Q[1:2, 1:2]);\n\njulia> @constraint(model, LinearAlgebra.Hermitian(Q) in HermitianPSDCone())\n[Q[1,1]  Q[1,2];\n Q[1,2]  Q[2,2]] ∈ HermitianPSDCone()\n\n\n\n\n\nbuild_constraint(\n    error_fn::Function,\n    f::AbstractVector{<:AbstractJuMPScalar},\n    ::Nonnegatives,\n    extra::Union{MOI.AbstractVectorSet,AbstractVectorSet},\n)\n\nA helper method that re-writes\n\n@constraint(model, X >= Y, extra)\n\ninto\n\n@constraint(model, X - Y in extra)\n\n\n\n\n\nbuild_constraint(\n    error_fn::Function,\n    f::AbstractVector{<:AbstractJuMPScalar},\n    ::Nonpositives,\n    extra::Union{MOI.AbstractVectorSet,AbstractVectorSet},\n)\n\nA helper method that re-writes\n\n@constraint(model, Y <= X, extra)\n\ninto\n\n@constraint(model, X - Y in extra)\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#build_variable","page":"JuMP","title":"build_variable","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.build_variable","category":"page"},{"location":"api/JuMP/#JuMP.build_variable","page":"JuMP","title":"JuMP.build_variable","text":"build_variable(\n    error_fn::Function,\n    info::VariableInfo,\n    args...;\n    kwargs...,\n)\n\nReturn a new AbstractVariable object.\n\nThis method should only be implemented by developers creating JuMP extensions. It should never be called by users of JuMP.\n\nArguments\n\nerror_fn: a function to call instead of error. error_fn annotates the error message with additional information for the user.\ninfo: an instance of VariableInfo. This has a variety of fields relating to the variable such as info.lower_bound and info.binary.\nargs: optional additional positional arguments for extending the @variable macro.\nkwargs: optional keyword arguments for extending the @variable macro.\n\nSee also: @variable\n\nwarning: Warning\nExtensions should define a method with ONE positional argument to dispatch the call to a different method. Creating an extension that relies on multiple positional arguments leads to MethodErrors if the user passes the arguments in the wrong order.\n\nExample\n\n@variable(model, x, Foo)\n\nwill call\n\nbuild_variable(error_fn::Function, info::VariableInfo, ::Type{Foo})\n\nPassing special-case positional arguments such as Bin, Int, and PSD is okay, along with keyword arguments:\n\n@variable(model, x, Int, Foo(), mykwarg = true)\n# or\n@variable(model, x, Foo(), Int, mykwarg = true)\n\nwill call\n\nbuild_variable(error_fn::Function, info::VariableInfo, ::Foo; mykwarg)\n\nand info.integer will be true.\n\nNote that the order of the positional arguments does not matter.\n\n\n\n\n\nbuild_variable(error_fn::Function, variables, ::SymmetricMatrixSpace)\n\nReturn a VariablesConstrainedOnCreation of shape SymmetricMatrixShape creating variables in MOI.Reals, that is, \"free\" variables unless they are constrained after their creation.\n\nThis function is used by the @variable macro as follows:\n\njulia> model = Model();\n\njulia> @variable(model, Q[1:2, 1:2], Symmetric)\n2×2 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:\n Q[1,1]  Q[1,2]\n Q[1,2]  Q[2,2]\n\n\n\n\n\nbuild_variable(error_fn::Function, variables, ::SkewSymmetricMatrixSpace)\n\nReturn a VariablesConstrainedOnCreation of shape SkewSymmetricMatrixShape creating variables in MOI.Reals, that is, \"free\" variables unless they are constrained after their creation.\n\nThis function is used by the @variable macro as follows:\n\njulia> model = Model();\n\njulia> @variable(model, Q[1:2, 1:2] in SkewSymmetricMatrixSpace())\n2×2 Matrix{AffExpr}:\n 0        Q[1,2]\n -Q[1,2]  0\n\n\n\n\n\nbuild_variable(error_fn::Function, variables, ::HermitianMatrixSpace)\n\nReturn a VariablesConstrainedOnCreation of shape HermitianMatrixShape creating variables in MOI.Reals, that is, \"free\" variables unless they are constrained after their creation.\n\nThis function is used by the @variable macro as follows:\n\njulia> model = Model();\n\njulia> @variable(model, Q[1:2, 1:2] in HermitianMatrixSpace())\n2×2 LinearAlgebra.Hermitian{GenericAffExpr{ComplexF64, VariableRef}, Matrix{GenericAffExpr{ComplexF64, VariableRef}}}:\n real(Q[1,1])                    real(Q[1,2]) + imag(Q[1,2]) im\n real(Q[1,2]) - imag(Q[1,2]) im  real(Q[2,2])\n\n\n\n\n\nbuild_variable(error_fn::Function, variables, ::PSDCone)\n\nReturn a VariablesConstrainedOnCreation of shape SymmetricMatrixShape constraining the variables to be positive semidefinite.\n\nThis function is used by the @variable macro as follows:\n\njulia> model = Model();\n\njulia> @variable(model, Q[1:2, 1:2], PSD)\n2×2 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:\n Q[1,1]  Q[1,2]\n Q[1,2]  Q[2,2]\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#callback_node_status","page":"JuMP","title":"callback_node_status","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.callback_node_status","category":"page"},{"location":"api/JuMP/#JuMP.callback_node_status","page":"JuMP","title":"JuMP.callback_node_status","text":"callback_node_status(cb_data, model::GenericModel)\n\nReturn an MOI.CallbackNodeStatusCode enum, indicating if the current primal solution available from callback_value is integer feasible.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#callback_value","page":"JuMP","title":"callback_value","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.callback_value","category":"page"},{"location":"api/JuMP/#JuMP.callback_value","page":"JuMP","title":"JuMP.callback_value","text":"callback_value(cb_data, x::GenericVariableRef)\n\nReturn the primal solution of a variable inside a callback.\n\ncb_data is the argument to the callback function, and the type is dependent on the solver.\n\n\n\n\n\ncallback_value(cb_data, expr::Union{GenericAffExpr, GenericQuadExpr})\n\nReturn the primal solution of an affine or quadratic expression inside a callback by getting the value for each variable appearing in the expression.\n\ncb_data is the argument to the callback function, and the type is dependent on the solver.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#check_belongs_to_model","page":"JuMP","title":"check_belongs_to_model","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.check_belongs_to_model","category":"page"},{"location":"api/JuMP/#JuMP.check_belongs_to_model","page":"JuMP","title":"JuMP.check_belongs_to_model","text":"check_belongs_to_model(func::AbstractJuMPScalar, model::AbstractModel)\n\nThrow VariableNotOwned if the owner_model of one of the variables of the function func is not model.\n\ncheck_belongs_to_model(constraint::AbstractConstraint, model::AbstractModel)\n\nThrow VariableNotOwned if the owner_model of one of the variables of the constraint constraint is not model.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#coefficient","page":"JuMP","title":"coefficient","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.coefficient","category":"page"},{"location":"api/JuMP/#JuMP.coefficient","page":"JuMP","title":"JuMP.coefficient","text":"coefficient(v1::GenericVariableRef{T}, v2::GenericVariableRef{T}) where {T}\n\nReturn one(T) if v1 == v2, and zero(T) otherwise.\n\nThis is a fallback for other coefficient methods to simplify code in which the expression may be a single variable.\n\n\n\n\n\ncoefficient(a::GenericAffExpr{C,V}, v::V) where {C,V}\n\nReturn the coefficient associated with variable v in the affine expression a.\n\n\n\n\n\ncoefficient(a::GenericAffExpr{C,V}, v1::V, v2::V) where {C,V}\n\nReturn the coefficient associated with the term v1 * v2 in the quadratic expression a.\n\nNote that coefficient(a, v1, v2) is the same as coefficient(a, v2, v1).\n\n\n\n\n\ncoefficient(a::GenericQuadExpr{C,V}, v::V) where {C,V}\n\nReturn the coefficient associated with variable v in the affine component of a.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#compute_conflict!","page":"JuMP","title":"compute_conflict!","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.compute_conflict!","category":"page"},{"location":"api/JuMP/#JuMP.compute_conflict!","page":"JuMP","title":"JuMP.compute_conflict!","text":"compute_conflict!(model::GenericModel)\n\nCompute a conflict if the model is infeasible. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nThe status of the conflict can be checked with the MOI.ConflictStatus model attribute. Then, the status for each constraint can be queried with the MOI.ConstraintConflictStatus attribute.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#constant","page":"JuMP","title":"constant","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.constant","category":"page"},{"location":"api/JuMP/#JuMP.constant","page":"JuMP","title":"JuMP.constant","text":"constant(aff::GenericAffExpr{C, V})::C\n\nReturn the constant of the affine expression.\n\n\n\n\n\nconstant(aff::GenericQuadExpr{C, V})::C\n\nReturn the constant of the quadratic expression.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#constraint_by_name","page":"JuMP","title":"constraint_by_name","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.constraint_by_name","category":"page"},{"location":"api/JuMP/#JuMP.constraint_by_name","page":"JuMP","title":"JuMP.constraint_by_name","text":"constraint_by_name(model::AbstractModel,\n                   name::String)::Union{ConstraintRef, Nothing}\n\nReturn the reference of the constraint with name attribute name or Nothing if no constraint has this name attribute. Throws an error if several constraints have name as their name attribute.\n\nconstraint_by_name(model::AbstractModel,\n                   name::String,\n                   F::Type{<:Union{AbstractJuMPScalar,\n                                   Vector{<:AbstractJuMPScalar},\n                                   MOI.AbstactFunction}},\n                   S::Type{<:MOI.AbstractSet})::Union{ConstraintRef, Nothing}\n\nSimilar to the method above, except that it throws an error if the constraint is not an F-in-S contraint where F is either the JuMP or MOI type of the function, and S is the MOI type of the set. This method is recommended if you know the type of the function and set since its returned type can be inferred while for the method above (that is, without F and S), the exact return type of the constraint index cannot be inferred.\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x^2 == 1)\ncon : x² = 1\n\njulia> constraint_by_name(model, \"kon\")\n\njulia> constraint_by_name(model, \"con\")\ncon : x² = 1\n\njulia> constraint_by_name(model, \"con\", AffExpr, MOI.EqualTo{Float64})\n\njulia> constraint_by_name(model, \"con\", QuadExpr, MOI.EqualTo{Float64})\ncon : x² = 1\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#constraint_object","page":"JuMP","title":"constraint_object","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.constraint_object","category":"page"},{"location":"api/JuMP/#JuMP.constraint_object","page":"JuMP","title":"JuMP.constraint_object","text":"constraint_object(con_ref::ConstraintRef)\n\nReturn the underlying constraint data for the constraint referenced by ref.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#constraint_ref_with_index","page":"JuMP","title":"constraint_ref_with_index","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.constraint_ref_with_index","category":"page"},{"location":"api/JuMP/#JuMP.constraint_ref_with_index","page":"JuMP","title":"JuMP.constraint_ref_with_index","text":"constraint_ref_with_index(model::AbstractModel, index::MOI.ConstraintIndex)\n\nReturn a ConstraintRef of model corresponding to index.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#constraint_string","page":"JuMP","title":"constraint_string","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.constraint_string","category":"page"},{"location":"api/JuMP/#JuMP.constraint_string","page":"JuMP","title":"JuMP.constraint_string","text":"constraint_string(\n    mode::MIME,\n    ref::ConstraintRef;\n    in_math_mode::Bool = false)\n\nReturn a string representation of the constraint ref, given the mode.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#constraints_string","page":"JuMP","title":"constraints_string","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.constraints_string","category":"page"},{"location":"api/JuMP/#JuMP.constraints_string","page":"JuMP","title":"JuMP.constraints_string","text":"constraints_string(mode, model::AbstractModel)::Vector{String}\n\nReturn a list of Strings describing each constraint of the model.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#copy_conflict","page":"JuMP","title":"copy_conflict","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.copy_conflict","category":"page"},{"location":"api/JuMP/#JuMP.copy_conflict","page":"JuMP","title":"JuMP.copy_conflict","text":"copy_conflict(model::GenericModel)\n\nReturn a copy of the current conflict for the model model and a GenericReferenceMap that can be used to obtain the variable and constraint reference of the new model corresponding to a given model's reference.\n\nThis is a convenience function that provides a filtering function for copy_model.\n\nNote\n\nModel copy is not supported in DIRECT mode, that is, when a model is constructed using the direct_model constructor instead of the Model constructor. Moreover, independently on whether an optimizer was provided at model construction, the new model will have no optimizer, that is, an optimizer will have to be provided to the new model in the optimize! call.\n\nExample\n\nIn the following example, a model model is constructed with a variable x and two constraints c1 and c2. This model has no solution, as the two constraints are mutually exclusive. The solver is asked to compute a conflict with compute_conflict!. The parts of model participating in the conflict are then copied into a model iis_model.\n\njulia> using JuMP\n\njulia> import Gurobi\n\njulia> model = Model(Gurobi.Optimizer);\n\njulia> set_silent(model)\n\njulia> @variable(model, x >= 0)\nx\n\njulia> @constraint(model, c1, x >= 2)\nc1 : x ≥ 2\n\njulia> @constraint(model, c2, x <= 1)\nc2 : x ≤ 1\n\njulia> optimize!(model)\n\njulia> compute_conflict!(model)\n\njulia> if get_attribute(model, MOI.ConflictStatus()) == MOI.CONFLICT_FOUND\n           iis_model, reference_map = copy_conflict(model)\n           print(iis_model)\n       end\nFeasibility\nSubject to\n c1 : x ≥ 2\n c2 : x ≤ 1\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#copy_extension_data","page":"JuMP","title":"copy_extension_data","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.copy_extension_data","category":"page"},{"location":"api/JuMP/#JuMP.copy_extension_data","page":"JuMP","title":"JuMP.copy_extension_data","text":"copy_extension_data(data, new_model::AbstractModel, model::AbstractModel)\n\nReturn a copy of the extension data data of the model model to the extension data of the new model new_model.\n\nA method should be added for any JuMP extension storing data in the ext field.\n\nwarning: Warning\nDo not engage in type piracy by implementing this method for types of data that you did not define! JuMP extensions should store types that they define in model.ext, rather than regular Julia types.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#copy_model","page":"JuMP","title":"copy_model","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.copy_model","category":"page"},{"location":"api/JuMP/#JuMP.copy_model","page":"JuMP","title":"JuMP.copy_model","text":"copy_model(model::GenericModel; filter_constraints::Union{Nothing, Function}=nothing)\n\nReturn a copy of the model model and a GenericReferenceMap that can be used to obtain the variable and constraint reference of the new model corresponding to a given model's reference. A Base.copy(::AbstractModel) method has also been implemented, it is similar to copy_model but does not return the reference map.\n\nIf the filter_constraints argument is given, only the constraints for which this function returns true will be copied. This function is given a constraint reference as argument.\n\nNote\n\nModel copy is not supported in DIRECT mode, that is, when a model is constructed using the direct_model constructor instead of the Model constructor. Moreover, independently on whether an optimizer was provided at model construction, the new model will have no optimizer, that is, an optimizer will have to be provided to the new model in the optimize! call.\n\nExample\n\nIn the following example, a model model is constructed with a variable x and a constraint cref. It is then copied into a model new_model with the new references assigned to x_new and cref_new.\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, cref, x == 2)\ncref : x = 2\n\njulia> new_model, reference_map = copy_model(model);\n\njulia> x_new = reference_map[x]\nx\n\njulia> cref_new = reference_map[cref]\ncref : x = 2\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#delete","page":"JuMP","title":"delete","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.delete","category":"page"},{"location":"api/JuMP/#JuMP.delete","page":"JuMP","title":"JuMP.delete","text":"delete(model::GenericModel, con_ref::ConstraintRef)\n\nDelete the constraint associated with constraint_ref from the model model.\n\nNote that delete does not unregister the name from the model, so adding a new constraint of the same name will throw an error. Use unregister to unregister the name after deletion.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @constraint(model, c, 2x <= 1)\nc : 2 x ≤ 1\n\njulia> delete(model, c)\n\njulia> unregister(model, :c)\n\njulia> print(model)\nFeasibility\nSubject to\n\njulia> model[:c]\nERROR: KeyError: key :c not found\nStacktrace:\n[...]\n\n\n\n\n\ndelete(model::GenericModel, con_refs::Vector{<:ConstraintRef})\n\nDelete the constraints associated with con_refs from the model model. Solvers may implement specialized methods for deleting multiple constraints of the same concrete type, that is, when isconcretetype(eltype(con_refs)). These may be more efficient than repeatedly calling the single constraint delete method.\n\nSee also: unregister\n\n\n\n\n\ndelete(model::GenericModel, variable_ref::GenericVariableRef)\n\nDelete the variable associated with variable_ref from the model model.\n\nNote that delete does not unregister the name from the model, so adding a new variable of the same name will throw an error. Use unregister to unregister the name after deletion.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> delete(model, x)\n\njulia> unregister(model, :x)\n\njulia> print(model)\nFeasibility\nSubject to\n\njulia> model[:x]\nERROR: KeyError: key :x not found\nStacktrace:\n[...]\n\n\n\n\n\ndelete(model::GenericModel, variable_refs::Vector{<:GenericVariableRef})\n\nDelete the variables associated with variable_refs from the model model. Solvers may implement methods for deleting multiple variables that are more efficient than repeatedly calling the single variable delete method.\n\nSee also: unregister\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> delete(model, x)\n\njulia> unregister(model, :x)\n\njulia> print(model)\nFeasibility\nSubject to\n\njulia> model[:x]\nERROR: KeyError: key :x not found\nStacktrace:\n[...]\n\n\n\n\n\ndelete(model::Model, c::NonlinearConstraintRef)\n\nDelete the nonlinear constraint c from model.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#delete_lower_bound","page":"JuMP","title":"delete_lower_bound","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.delete_lower_bound","category":"page"},{"location":"api/JuMP/#JuMP.delete_lower_bound","page":"JuMP","title":"JuMP.delete_lower_bound","text":"delete_lower_bound(v::GenericVariableRef)\n\nDelete the lower bound constraint of a variable.\n\nSee also LowerBoundRef, has_lower_bound, lower_bound, set_lower_bound.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 1.0);\n\njulia> has_lower_bound(x)\ntrue\n\njulia> delete_lower_bound(x)\n\njulia> has_lower_bound(x)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#delete_upper_bound","page":"JuMP","title":"delete_upper_bound","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.delete_upper_bound","category":"page"},{"location":"api/JuMP/#JuMP.delete_upper_bound","page":"JuMP","title":"JuMP.delete_upper_bound","text":"delete_upper_bound(v::GenericVariableRef)\n\nDelete the upper bound constraint of a variable.\n\nErrors if one does not exist.\n\nSee also UpperBoundRef, has_upper_bound, upper_bound, set_upper_bound.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x <= 1.0);\n\njulia> has_upper_bound(x)\ntrue\n\njulia> delete_upper_bound(x)\n\njulia> has_upper_bound(x)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#direct_generic_model","page":"JuMP","title":"direct_generic_model","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.direct_generic_model","category":"page"},{"location":"api/JuMP/#JuMP.direct_generic_model","page":"JuMP","title":"JuMP.direct_generic_model","text":"direct_generic_model(\n    value_type::Type{T},\n    backend::MOI.ModelLike;\n) where {T<:Real}\n\nReturn a new JuMP model using backend to store the model and solve it.\n\nAs opposed to the Model constructor, no cache of the model is stored outside of backend and no bridges are automatically applied to backend.\n\nNotes\n\nThe absence of a cache reduces the memory footprint but, it is important to bear in mind the following implications of creating models using this direct mode:\n\nWhen backend does not support an operation, such as modifying constraints or adding variables/constraints after solving, an error is thrown. For models created using the Model constructor, such situations can be dealt with by storing the modifications in a cache and loading them into the optimizer when optimize! is called.\nNo constraint bridging is supported by default.\nThe optimizer used cannot be changed the model is constructed.\nThe model created cannot be copied.\n\n\n\n\n\ndirect_generic_model(::Type{T}, factory::MOI.OptimizerWithAttributes)\n\nCreate a direct_generic_model using factory, a MOI.OptimizerWithAttributes object created by optimizer_with_attributes.\n\nExample\n\njulia> import HiGHS\n\njulia> optimizer = optimizer_with_attributes(\n           HiGHS.Optimizer,\n           \"presolve\" => \"off\",\n           MOI.Silent() => true,\n       );\n\njulia> model = direct_generic_model(Float64, optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: DIRECT\nSolver name: HiGHS\n\nis equivalent to:\n\njulia> import HiGHS\n\njulia> model = direct_generic_model(Float64, HiGHS.Optimizer())\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: DIRECT\nSolver name: HiGHS\n\njulia> set_attribute(model, \"presolve\", \"off\")\n\njulia> set_attribute(model, MOI.Silent(), true)\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#direct_model","page":"JuMP","title":"direct_model","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.direct_model","category":"page"},{"location":"api/JuMP/#JuMP.direct_model","page":"JuMP","title":"JuMP.direct_model","text":"direct_model(backend::MOI.ModelLike)\n\nReturn a new JuMP model using backend to store the model and solve it.\n\nAs opposed to the Model constructor, no cache of the model is stored outside of backend and no bridges are automatically applied to backend.\n\nNotes\n\nThe absence of a cache reduces the memory footprint but, it is important to bear in mind the following implications of creating models using this direct mode:\n\nWhen backend does not support an operation, such as modifying constraints or adding variables/constraints after solving, an error is thrown. For models created using the Model constructor, such situations can be dealt with by storing the modifications in a cache and loading them into the optimizer when optimize! is called.\nNo constraint bridging is supported by default.\nThe optimizer used cannot be changed the model is constructed.\nThe model created cannot be copied.\n\n\n\n\n\ndirect_model(factory::MOI.OptimizerWithAttributes)\n\nCreate a direct_model using factory, a MOI.OptimizerWithAttributes object created by optimizer_with_attributes.\n\nExample\n\njulia> import HiGHS\n\njulia> optimizer = optimizer_with_attributes(\n           HiGHS.Optimizer,\n           \"presolve\" => \"off\",\n           MOI.Silent() => true,\n       );\n\njulia> model = direct_model(optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: DIRECT\nSolver name: HiGHS\n\nis equivalent to:\n\njulia> import HiGHS\n\njulia> model = direct_model(HiGHS.Optimizer())\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: DIRECT\nSolver name: HiGHS\n\njulia> set_attribute(model, \"presolve\", \"off\")\n\njulia> set_attribute(model, MOI.Silent(), true)\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#drop_zeros!","page":"JuMP","title":"drop_zeros!","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.drop_zeros!","category":"page"},{"location":"api/JuMP/#JuMP.drop_zeros!","page":"JuMP","title":"JuMP.drop_zeros!","text":"drop_zeros!(expr::GenericAffExpr)\n\nRemove terms in the affine expression with 0 coefficients.\n\n\n\n\n\ndrop_zeros!(expr::GenericQuadExpr)\n\nRemove terms in the quadratic expression with 0 coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#dual","page":"JuMP","title":"dual","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.dual","category":"page"},{"location":"api/JuMP/#JuMP.dual","page":"JuMP","title":"JuMP.dual","text":"dual(con_ref::ConstraintRef; result::Int = 1)\n\nReturn the dual value of constraint con_ref associated with result index result of the most-recent solution returned by the solver.\n\nUse has_dual to check if a result exists before asking for values.\n\nSee also: result_count, shadow_price.\n\n\n\n\n\ndual(c::NonlinearConstraintRef)\n\nReturn the dual of the nonlinear constraint c.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#dual_objective_value","page":"JuMP","title":"dual_objective_value","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.dual_objective_value","category":"page"},{"location":"api/JuMP/#JuMP.dual_objective_value","page":"JuMP","title":"JuMP.dual_objective_value","text":"dual_objective_value(model::GenericModel; result::Int = 1)\n\nReturn the value of the objective of the dual problem associated with result index result of the most-recent solution returned by the solver.\n\nThrows MOI.UnsupportedAttribute{MOI.DualObjectiveValue} if the solver does not support this attribute.\n\nThis function is equivalent to querying the MOI.DualObjectiveValue attribute.\n\nSee also: result_count.\n\nExample\n\njulia> import HiGHS\n\njulia> model = Model(HiGHS.Optimizer);\n\njulia> set_silent(model)\n\njulia> @variable(model, x >= 1);\n\njulia> @objective(model, Min, 2 * x + 1);\n\njulia> optimize!(model)\n\njulia> dual_objective_value(model)\n3.0\n\njulia> dual_objective_value(model; result = 2)\nERROR: Result index of attribute MathOptInterface.DualObjectiveValue(2) out of bounds. There are currently 1 solution(s) in the model.\nStacktrace:\n[...]\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#dual_shape","page":"JuMP","title":"dual_shape","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.dual_shape","category":"page"},{"location":"api/JuMP/#JuMP.dual_shape","page":"JuMP","title":"JuMP.dual_shape","text":"dual_shape(shape::AbstractShape)::AbstractShape\n\nReturns the shape of the dual space of the space of objects of shape shape. By default, the dual_shape of a shape is itself. See the examples section below for an example for which this is not the case.\n\nExample\n\nConsider polynomial constraints for which the dual is moment constraints and moment constraints for which the dual is polynomial constraints. Shapes for polynomials can be defined as follows:\n\nstruct Polynomial\n    coefficients::Vector{Float64}\n    monomials::Vector{Monomial}\nend\nstruct PolynomialShape <: AbstractShape\n    monomials::Vector{Monomial}\nend\nJuMP.reshape_vector(x::Vector, shape::PolynomialShape) = Polynomial(x, shape.monomials)\n\nand a shape for moments can be defined as follows:\n\nstruct Moments\n    coefficients::Vector{Float64}\n    monomials::Vector{Monomial}\nend\nstruct MomentsShape <: AbstractShape\n    monomials::Vector{Monomial}\nend\nJuMP.reshape_vector(x::Vector, shape::MomentsShape) = Moments(x, shape.monomials)\n\nThen dual_shape allows the definition of the shape of the dual of polynomial and moment constraints:\n\ndual_shape(shape::PolynomialShape) = MomentsShape(shape.monomials)\ndual_shape(shape::MomentsShape) = PolynomialShape(shape.monomials)\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#dual_start_value","page":"JuMP","title":"dual_start_value","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.dual_start_value","category":"page"},{"location":"api/JuMP/#JuMP.dual_start_value","page":"JuMP","title":"JuMP.dual_start_value","text":"dual_start_value(con_ref::ConstraintRef)\n\nReturn the dual start value (MOI attribute ConstraintDualStart) of the constraint con_ref.\n\nNote: If no dual start value has been set, dual_start_value will return nothing.\n\nSee also set_dual_start_value.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#dual_status","page":"JuMP","title":"dual_status","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.dual_status","category":"page"},{"location":"api/JuMP/#JuMP.dual_status","page":"JuMP","title":"JuMP.dual_status","text":"dual_status(model::GenericModel; result::Int = 1)\n\nReturn a MOI.ResultStatusCode describing the status of the most recent dual solution of the solver (that is, the MOI.DualStatus attribute) associated with the result index result.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#error_if_direct_mode","page":"JuMP","title":"error_if_direct_mode","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.error_if_direct_mode","category":"page"},{"location":"api/JuMP/#JuMP.error_if_direct_mode","page":"JuMP","title":"JuMP.error_if_direct_mode","text":"error_if_direct_mode(model::GenericModel, func::Symbol)\n\nErrors if model is in direct mode during a call from the function named func.\n\nUsed internally within JuMP, or by JuMP extensions who do not want to support models in direct mode.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#fix","page":"JuMP","title":"fix","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.fix","category":"page"},{"location":"api/JuMP/#JuMP.fix","page":"JuMP","title":"JuMP.fix","text":"fix(v::GenericVariableRef, value::Number; force::Bool = false)\n\nFix a variable to a value. Update the fixing constraint if one exists, otherwise create a new one.\n\nIf the variable already has variable bounds and force=false, calling fix will throw an error. If force=true, existing variable bounds will be deleted, and the fixing constraint will be added. Note a variable will have no bounds after a call to unfix.\n\nSee also FixRef, is_fixed, fix_value, unfix.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> is_fixed(x)\nfalse\n\njulia> fix(x, 1.0)\n\njulia> is_fixed(x)\ntrue\n\njulia> model = Model();\n\njulia> @variable(model, 0 <= x <= 1);\n\njulia> is_fixed(x)\nfalse\n\njulia> fix(x, 1.0; force = true)\n\njulia> is_fixed(x)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#fix_discrete_variables","page":"JuMP","title":"fix_discrete_variables","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.fix_discrete_variables","category":"page"},{"location":"api/JuMP/#JuMP.fix_discrete_variables","page":"JuMP","title":"JuMP.fix_discrete_variables","text":"fix_discrete_variables([var_value::Function = value,] model::GenericModel)\n\nModifies model to convert all binary and integer variables to continuous variables with fixed bounds of var_value(x).\n\nReturn\n\nReturns a function that can be called without any arguments to restore the original model. The behavior of this function is undefined if additional changes are made to the affected variables in the meantime.\n\nNotes\n\nAn error is thrown if semi-continuous or semi-integer constraints are present (support may be added for these in the future).\nAll other constraints are ignored (left in place). This includes discrete constraints like SOS and indicator constraints.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x, Bin, start = 1);\n\njulia> @variable(model, 1 <= y <= 10, Int, start = 2);\n\njulia> @objective(model, Min, x + y);\n\njulia> undo_relax = fix_discrete_variables(start_value, model);\n\njulia> print(model)\nMin x + y\nSubject to\n x = 1\n y = 2\n\njulia> undo_relax()\n\njulia> print(model)\nMin x + y\nSubject to\n y ≥ 1\n y ≤ 10\n y integer\n x binary\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#fix_value","page":"JuMP","title":"fix_value","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.fix_value","category":"page"},{"location":"api/JuMP/#JuMP.fix_value","page":"JuMP","title":"JuMP.fix_value","text":"fix_value(v::GenericVariableRef)\n\nReturn the value to which a variable is fixed.\n\nError if one does not exist.\n\nSee also FixRef, is_fixed, fix, unfix.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x == 1);\n\njulia> fix_value(x)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#flatten!","page":"JuMP","title":"flatten!","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.flatten!","category":"page"},{"location":"api/JuMP/#JuMP.flatten!","page":"JuMP","title":"JuMP.flatten!","text":"flatten!(expr::GenericNonlinearExpr)\n\nFlatten a nonlinear expression in-place by lifting nested + and * nodes into a single n-ary operation.\n\nMotivation\n\nNonlinear expressions created using operator overloading can be deeply nested and unbalanced. For example, prod(x for i in 1:4) creates *(x, *(x, *(x, x))) instead of the more preferable *(x, x, x, x).\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> y = prod(x for i in 1:4)\n((x²) * x) * x\n\njulia> flatten!(y)\n(x²) * x * x\n\njulia> flatten!(sin(prod(x for i in 1:4)))\nsin((x²) * x * x)\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#function_string","page":"JuMP","title":"function_string","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.function_string","category":"page"},{"location":"api/JuMP/#JuMP.function_string","page":"JuMP","title":"JuMP.function_string","text":"function_string(\n    mode::MIME,\n    func::Union{JuMP.AbstractJuMPScalar,Vector{<:JuMP.AbstractJuMPScalar}},\n)\n\nReturn a String representing the function func using print mode mode.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#get_attribute","page":"JuMP","title":"get_attribute","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.get_attribute","category":"page"},{"location":"api/JuMP/#JuMP.get_attribute","page":"JuMP","title":"JuMP.get_attribute","text":"get_attribute(model::GenericModel, attr::MOI.AbstractModelAttribute)\nget_attribute(x::GenericVariableRef, attr::MOI.AbstractVariableAttribute)\nget_attribute(cr::ConstraintRef, attr::MOI.AbstractConstraintAttribute)\n\nGet the value of a solver-specifc attribute attr.\n\nThis is equivalent to calling MOI.get with the associated MOI model and, for variables and constraints, with the associated MOI.VariableIndex or MOI.ConstraintIndex.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, c, 2 * x <= 1)\nc : 2 x ≤ 1\n\njulia> get_attribute(model, MOI.Name())\n\"\"\n\njulia> get_attribute(x, MOI.VariableName())\n\"x\"\n\njulia> get_attribute(c, MOI.ConstraintName())\n\"c\"\n\n\n\n\n\nget_attribute(\n    model::Union{GenericModel,MOI.OptimizerWithAttributes},\n    attr::Union{AbstractString,MOI.AbstractOptimizerAttribute},\n)\n\nGet the value of a solver-specifc attribute attr.\n\nThis is equivalent to calling MOI.get with the associated MOI model.\n\nIf attr is an AbstractString, it is converted to MOI.RawOptimizerAttribute.\n\nExample\n\njulia> import HiGHS\n\njulia> opt = optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => true);\n\njulia> model = Model(opt);\n\njulia> get_attribute(model, \"output_flag\")\ntrue\n\njulia> get_attribute(model, MOI.RawOptimizerAttribute(\"output_flag\"))\ntrue\n\njulia> get_attribute(opt, \"output_flag\")\ntrue\n\njulia> get_attribute(opt, MOI.RawOptimizerAttribute(\"output_flag\"))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#has_duals","page":"JuMP","title":"has_duals","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.has_duals","category":"page"},{"location":"api/JuMP/#JuMP.has_duals","page":"JuMP","title":"JuMP.has_duals","text":"has_duals(model::GenericModel; result::Int = 1)\n\nReturn true if the solver has a dual solution in result index result available to query, otherwise return false.\n\nSee also dual, shadow_price, and result_count.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#has_lower_bound","page":"JuMP","title":"has_lower_bound","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.has_lower_bound","category":"page"},{"location":"api/JuMP/#JuMP.has_lower_bound","page":"JuMP","title":"JuMP.has_lower_bound","text":"has_lower_bound(v::GenericVariableRef)\n\nReturn true if v has a lower bound. If true, the lower bound can be queried with lower_bound.\n\nSee also LowerBoundRef, lower_bound, set_lower_bound, delete_lower_bound.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 1.0);\n\njulia> has_lower_bound(x)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#has_start_value","page":"JuMP","title":"has_start_value","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.has_start_value","category":"page"},{"location":"api/JuMP/#JuMP.has_start_value","page":"JuMP","title":"JuMP.has_start_value","text":"has_start_value(variable::AbstractVariableRef)\n\nReturn true if the variable has a start value set otherwise return false.\n\nSee also set_start_value.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#has_upper_bound","page":"JuMP","title":"has_upper_bound","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.has_upper_bound","category":"page"},{"location":"api/JuMP/#JuMP.has_upper_bound","page":"JuMP","title":"JuMP.has_upper_bound","text":"has_upper_bound(v::GenericVariableRef)\n\nReturn true if v has a upper bound. If true, the upper bound can be queried with upper_bound.\n\nSee also UpperBoundRef, upper_bound, set_upper_bound, delete_upper_bound.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x <= 1.0);\n\njulia> has_upper_bound(x)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#has_values","page":"JuMP","title":"has_values","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.has_values","category":"page"},{"location":"api/JuMP/#JuMP.has_values","page":"JuMP","title":"JuMP.has_values","text":"has_values(model::GenericModel; result::Int = 1)\n\nReturn true if the solver has a primal solution in result index result available to query, otherwise return false.\n\nSee also value and result_count.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#in_set_string","page":"JuMP","title":"in_set_string","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.in_set_string","category":"page"},{"location":"api/JuMP/#JuMP.in_set_string","page":"JuMP","title":"JuMP.in_set_string","text":"in_set_string(mode::MIME, set)\n\nReturn a String representing the membership to the set set using print mode mode.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#index","page":"JuMP","title":"index","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.index","category":"page"},{"location":"api/JuMP/#JuMP.index","page":"JuMP","title":"JuMP.index","text":"index(cr::ConstraintRef)::MOI.ConstraintIndex\n\nReturn the index of the constraint that corresponds to cr in the MOI backend.\n\n\n\n\n\nindex(v::GenericVariableRef)::MOI.VariableIndex\n\nReturn the index of the variable that corresponds to v in the MOI backend.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> index(x)\nMOI.VariableIndex(1)\n\n\n\n\n\nindex(p::NonlinearParameter)::MOI.Nonlinear.ParameterIndex\n\nReturn the index of the nonlinear parameter associated with p.\n\n\n\n\n\nindex(ex::NonlinearExpression)::MOI.Nonlinear.ExpressionIndex\n\nReturn the index of the nonlinear expression associated with ex.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#is_binary","page":"JuMP","title":"is_binary","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.is_binary","category":"page"},{"location":"api/JuMP/#JuMP.is_binary","page":"JuMP","title":"JuMP.is_binary","text":"is_binary(v::GenericVariableRef)\n\nReturn true if v is constrained to be binary.\n\nSee also BinaryRef, set_binary, unset_binary.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x, Bin);\n\njulia> is_binary(x)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#is_fixed","page":"JuMP","title":"is_fixed","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.is_fixed","category":"page"},{"location":"api/JuMP/#JuMP.is_fixed","page":"JuMP","title":"JuMP.is_fixed","text":"is_fixed(v::GenericVariableRef)\n\nReturn true if v is a fixed variable. If true, the fixed value can be queried with fix_value.\n\nSee also FixRef, fix_value, fix, unfix.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> is_fixed(x)\nfalse\n\njulia> fix(x, 1.0)\n\njulia> is_fixed(x)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#is_integer","page":"JuMP","title":"is_integer","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.is_integer","category":"page"},{"location":"api/JuMP/#JuMP.is_integer","page":"JuMP","title":"JuMP.is_integer","text":"is_integer(v::GenericVariableRef)\n\nReturn true if v is constrained to be integer.\n\nSee also IntegerRef, set_integer, unset_integer.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> is_integer(x)\nfalse\n\njulia> set_integer(x)\n\njulia> is_integer(x)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#is_parameter","page":"JuMP","title":"is_parameter","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.is_parameter","category":"page"},{"location":"api/JuMP/#JuMP.is_parameter","page":"JuMP","title":"JuMP.is_parameter","text":"is_parameter(x::GenericVariableRef)::Bool\n\nReturn true if x is constrained to be a parameter.\n\nSee also ParameterRef, set_parameter_value, parameter_value.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, p in Parameter(2))\np\n\njulia> is_parameter(p)\ntrue\n\njulia> @variable(model, x)\nx\n\njulia> is_parameter(x)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#is_solved_and_feasible","page":"JuMP","title":"is_solved_and_feasible","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.is_solved_and_feasible","category":"page"},{"location":"api/JuMP/#JuMP.is_solved_and_feasible","page":"JuMP","title":"JuMP.is_solved_and_feasible","text":"is_solved_and_feasible(\n    model::GenericModel;\n    allow_local::Bool = true,\n    allow_almost::Bool = false,\n    dual::Bool = false,\n    result::Int = 1,\n)\n\nReturn true if the model has a feasible primal solution associated with result index result and the termination_status is OPTIMAL (the solver found a global optimum) or LOCALLY_SOLVED (the solver found a local optimum, which may also be the global optimum, but the solver could not prove so).\n\nIf allow_local = false, then this function returns true only if the termination_status is OPTIMAL.\n\nIf allow_almost = true, then the termination_status may additionally be ALMOST_OPTIMAL or ALMOST_LOCALLY_SOLVED (if allow_local), and the primal_status and dual_status may additionally be NEARLY_FEASIBLE_POINT.\n\nIf dual, additionally check that an optimal dual solution is available.\n\nIf this function returns false, use termination_status, result_count, primal_status and dual_status to understand what solutions are available (if any).\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#is_valid","page":"JuMP","title":"is_valid","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.is_valid","category":"page"},{"location":"api/JuMP/#JuMP.is_valid","page":"JuMP","title":"JuMP.is_valid","text":"is_valid(model::GenericModel, con_ref::ConstraintRef{<:AbstractModel})\n\nReturn true if constraint_ref refers to a valid constraint in model.\n\n\n\n\n\nis_valid(model::GenericModel, variable_ref::GenericVariableRef)\n\nReturn true if variable refers to a valid variable in model.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> is_valid(model, x)\ntrue\n\njulia> model_2 = Model();\n\njulia> is_valid(model_2, x)\nfalse\n\n\n\n\n\nis_valid(model::Model, c::NonlinearConstraintRef)\n\nReturn true if c refers to a valid nonlinear constraint in model.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#isequal_canonical","page":"JuMP","title":"isequal_canonical","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.isequal_canonical","category":"page"},{"location":"api/JuMP/#JuMP.isequal_canonical","page":"JuMP","title":"JuMP.isequal_canonical","text":"isequal_canonical(\n    aff::GenericAffExpr{C,V},\n    other::GenericAffExpr{C,V}\n) where {C,V}\n\nReturn true if aff is equal to other after dropping zeros and disregarding the order. Mainly useful for testing.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#jump_function","page":"JuMP","title":"jump_function","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.jump_function","category":"page"},{"location":"api/JuMP/#JuMP.jump_function","page":"JuMP","title":"JuMP.jump_function","text":"jump_function(x)\n\nGiven an MathOptInterface object x, return the JuMP equivalent.\n\nSee also: moi_function.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#jump_function_type","page":"JuMP","title":"jump_function_type","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.jump_function_type","category":"page"},{"location":"api/JuMP/#JuMP.jump_function_type","page":"JuMP","title":"JuMP.jump_function_type","text":"jump_function_type(::Type{T}) where {T}\n\nGiven an MathOptInterface object type T, return the JuMP equivalent.\n\nSee also: moi_function_type.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#latex_formulation","page":"JuMP","title":"latex_formulation","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.latex_formulation","category":"page"},{"location":"api/JuMP/#JuMP.latex_formulation","page":"JuMP","title":"JuMP.latex_formulation","text":"latex_formulation(model::AbstractModel)\n\nWrap model in a type so that it can be pretty-printed as text/latex in a notebook like IJulia, or in Documenter.\n\nTo render the model, end the cell with latex_formulation(model), or call display(latex_formulation(model)) in to force the display of the model from inside a function.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#linear_terms","page":"JuMP","title":"linear_terms","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.linear_terms","category":"page"},{"location":"api/JuMP/#JuMP.linear_terms","page":"JuMP","title":"JuMP.linear_terms","text":"linear_terms(aff::GenericAffExpr{C, V})\n\nProvides an iterator over coefficient-variable tuples (a_i::C, x_i::V) in the linear part of the affine expression.\n\n\n\n\n\nlinear_terms(quad::GenericQuadExpr{C, V})\n\nProvides an iterator over tuples (coefficient::C, variable::V) in the linear part of the quadratic expression.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#list_of_constraint_types","page":"JuMP","title":"list_of_constraint_types","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.list_of_constraint_types","category":"page"},{"location":"api/JuMP/#JuMP.list_of_constraint_types","page":"JuMP","title":"JuMP.list_of_constraint_types","text":"list_of_constraint_types(model::GenericModel)::Vector{Tuple{Type,Type}}\n\nReturn a list of tuples of the form (F, S) where F is a JuMP function type and S is an MOI set type such that all_constraints(model, F, S) returns a nonempty list.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> list_of_constraint_types(model)\n3-element Vector{Tuple{Type, Type}}:\n (AffExpr, MathOptInterface.LessThan{Float64})\n (VariableRef, MathOptInterface.GreaterThan{Float64})\n (VariableRef, MathOptInterface.ZeroOne)\n\nPerformance considerations\n\nIterating over the list of function and set types is a type-unstable operation. Consider using a function barrier. See the Performance tips for extensions section of the documentation for more details.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#lower_bound","page":"JuMP","title":"lower_bound","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.lower_bound","category":"page"},{"location":"api/JuMP/#JuMP.lower_bound","page":"JuMP","title":"JuMP.lower_bound","text":"lower_bound(v::GenericVariableRef)\n\nReturn the lower bound of a variable. Error if one does not exist.\n\nSee also LowerBoundRef, has_lower_bound, set_lower_bound, delete_lower_bound.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 1.0);\n\njulia> lower_bound(x)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#lp_matrix_data","page":"JuMP","title":"lp_matrix_data","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.lp_matrix_data","category":"page"},{"location":"api/JuMP/#JuMP.lp_matrix_data","page":"JuMP","title":"JuMP.lp_matrix_data","text":"lp_matrix_data(model::GenericModel{T})\n\nGiven a JuMP model of a linear program, return an LPMatrixData{T} struct storing data for an equivalent linear program in the form:\n\nbeginaligned\nmin  c^top x + c_0\n       b_l le A x le b_u \n       x_l le x le x_u\nendaligned\n\nwhere elements in x may be continuous, integer, or binary variables.\n\nFields\n\nThe struct returned by lp_matrix_data has the fields:\n\nA::SparseArrays.SparseMatrixCSC{T,Int}: the constraint matrix in sparse matrix form.\nb_lower::Vector{T}: the dense vector of row lower bounds. If missing, the value of typemin(T) is used.\nb_upper::Vector{T}: the dense vector of row upper bounds. If missing, the value of typemax(T) is used.\nx_lower::Vector{T}: the dense vector of variable lower bounds. If missing, the value of typemin(T) is used.\nx_upper::Vector{T}: the dense vector of variable upper bounds. If missing, the value of typemax(T) is used.\nc::Vector{T}: the dense vector of linear objective coefficients\nc_offset::T: the constant term in the objective function.\nsense::MOI.OptimizationSense: the objective sense of the model.\nintegers::Vector{Int}: the sorted list of column indices that are integer variables.\nbinaries::Vector{Int}: the sorted list of column indices that are binary variables.\nvariables::Vector{GenericVariableRef{T}}: a vector of GenericVariableRef, corresponding to order of the columns in the matrix form.\naffine_constraints::Vector{ConstraintRef}: a vector of ConstraintRef, corresponding to the order of rows in the matrix form.\n\nLimitations\n\nThe models supported by lp_matrix_data are intentionally limited to linear programs.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#lp_sensitivity_report","page":"JuMP","title":"lp_sensitivity_report","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.lp_sensitivity_report","category":"page"},{"location":"api/JuMP/#JuMP.lp_sensitivity_report","page":"JuMP","title":"JuMP.lp_sensitivity_report","text":"lp_sensitivity_report(model::GenericModel{T}; atol::T = Base.rtoldefault(T))::SensitivityReport{T} where {T}\n\nGiven a linear program model with a current optimal basis, return a SensitivityReport object, which maps:\n\nEvery variable reference to a tuple (d_lo, d_hi)::Tuple{T,T}, explaining how much the objective coefficient of the corresponding variable can change by, such that the original basis remains optimal.\nEvery constraint reference to a tuple (d_lo, d_hi)::Tuple{T,T}, explaining how much the right-hand side of the corresponding constraint can change by, such that the basis remains optimal.\n\nBoth tuples are relative, rather than absolute. So given a objective coefficient of 1.0 and a tuple (-0.5, 0.5), the objective coefficient can range between 1.0 - 0.5 an 1.0 + 0.5.\n\natol is the primal/dual optimality tolerance, and should match the tolerance of the solver used to compute the basis.\n\nNote: interval constraints are NOT supported.\n\nExample\n\njulia> import HiGHS\n\njulia> model = Model(HiGHS.Optimizer);\n\njulia> set_silent(model)\n\njulia> @variable(model, -1 <= x <= 2)\nx\n\njulia> @objective(model, Min, x)\nx\n\njulia> optimize!(model)\n\njulia> report = lp_sensitivity_report(model; atol = 1e-7);\n\njulia> dx_lo, dx_hi = report[x]\n(-1.0, Inf)\n\njulia> println(\n           \"The objective coefficient of `x` can decrease by $dx_lo or \" *\n           \"increase by $dx_hi.\"\n       )\nThe objective coefficient of `x` can decrease by -1.0 or increase by Inf.\n\njulia> dRHS_lo, dRHS_hi = report[LowerBoundRef(x)]\n(-Inf, 3.0)\n\njulia> println(\n           \"The lower bound of `x` can decrease by $dRHS_lo or increase \" *\n           \"by $dRHS_hi.\"\n       )\nThe lower bound of `x` can decrease by -Inf or increase by 3.0.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#map_coefficients","page":"JuMP","title":"map_coefficients","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.map_coefficients","category":"page"},{"location":"api/JuMP/#JuMP.map_coefficients","page":"JuMP","title":"JuMP.map_coefficients","text":"map_coefficients(f::Function, a::GenericAffExpr)\n\nApply f to the coefficients and constant term of an GenericAffExpr a and return a new expression.\n\nSee also: map_coefficients_inplace!\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> a = GenericAffExpr(1.0, x => 1.0)\nx + 1\n\njulia> map_coefficients(c -> 2 * c, a)\n2 x + 2\n\njulia> a\nx + 1\n\n\n\n\n\nmap_coefficients(f::Function, a::GenericQuadExpr)\n\nApply f to the coefficients and constant term of an GenericQuadExpr a and return a new expression.\n\nSee also: map_coefficients_inplace!\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> a = @expression(model, x^2 + x + 1)\nx² + x + 1\n\njulia> map_coefficients(c -> 2 * c, a)\n2 x² + 2 x + 2\n\njulia> a\nx² + x + 1\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#map_coefficients_inplace!","page":"JuMP","title":"map_coefficients_inplace!","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.map_coefficients_inplace!","category":"page"},{"location":"api/JuMP/#JuMP.map_coefficients_inplace!","page":"JuMP","title":"JuMP.map_coefficients_inplace!","text":"map_coefficients_inplace!(f::Function, a::GenericAffExpr)\n\nApply f to the coefficients and constant term of an GenericAffExpr a and update them in-place.\n\nSee also: map_coefficients\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> a = GenericAffExpr(1.0, x => 1.0)\nx + 1\n\njulia> map_coefficients_inplace!(c -> 2 * c, a)\n2 x + 2\n\njulia> a\n2 x + 2\n\n\n\n\n\nmap_coefficients_inplace!(f::Function, a::GenericQuadExpr)\n\nApply f to the coefficients and constant term of an GenericQuadExpr a and update them in-place.\n\nSee also: map_coefficients\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> a = @expression(model, x^2 + x + 1)\nx² + x + 1\n\njulia> map_coefficients_inplace!(c -> 2 * c, a)\n2 x² + 2 x + 2\n\njulia> a\n2 x² + 2 x + 2\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#mode","page":"JuMP","title":"mode","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.mode","category":"page"},{"location":"api/JuMP/#JuMP.mode","page":"JuMP","title":"JuMP.mode","text":"mode(model::GenericModel)\n\nReturn the ModelMode (DIRECT, AUTOMATIC, or MANUAL) of model.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#model_convert","page":"JuMP","title":"model_convert","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.model_convert","category":"page"},{"location":"api/JuMP/#JuMP.model_convert","page":"JuMP","title":"JuMP.model_convert","text":"model_convert(\n    model::AbstractModel,\n    rhs::Union{\n        AbstractConstraint,\n        Number,\n        AbstractJuMPScalar,\n        MOI.AbstractSet,\n    },\n)\n\nConvert the coefficients and constants of functions and sets in the rhs to the coefficient type value_type(typeof(model)).\n\nPurpose\n\nCreating and adding a constraint is a two-step process. The first step calls build_constraint, and the result of that is passed to add_constraint.\n\nHowever, because build_constraint does not take the model as an argument, the coefficients and constants of the function or set might be different than value_type(typeof(model)).\n\nTherefore, the result of build_constraint is converted in a call to model_convert before the result is passed to add_constraint.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#model_string","page":"JuMP","title":"model_string","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.model_string","category":"page"},{"location":"api/JuMP/#JuMP.model_string","page":"JuMP","title":"JuMP.model_string","text":"model_string(mode::MIME, model::AbstractModel)\n\nReturn a String representation of model given the mode.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#moi_function","page":"JuMP","title":"moi_function","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.moi_function","category":"page"},{"location":"api/JuMP/#JuMP.moi_function","page":"JuMP","title":"JuMP.moi_function","text":"moi_function(x)\n\nGiven a JuMP object x, return the MathOptInterface equivalent.\n\nSee also: jump_function.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#moi_function_type","page":"JuMP","title":"moi_function_type","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.moi_function_type","category":"page"},{"location":"api/JuMP/#JuMP.moi_function_type","page":"JuMP","title":"JuMP.moi_function_type","text":"moi_function_type(::Type{T}) where {T}\n\nGiven a JuMP object type T, return the MathOptInterface equivalent.\n\nSee also: jump_function_type.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#moi_set","page":"JuMP","title":"moi_set","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.moi_set","category":"page"},{"location":"api/JuMP/#JuMP.moi_set","page":"JuMP","title":"JuMP.moi_set","text":"moi_set(constraint::AbstractConstraint)\n\nReturn the set of the constraint constraint in the function-in-set form as a MathOptInterface.AbstractSet.\n\nmoi_set(s::AbstractVectorSet, dim::Int)\n\nReturns the MOI set of dimension dim corresponding to the JuMP set s.\n\nmoi_set(s::AbstractScalarSet)\n\nReturns the MOI set corresponding to the JuMP set s.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#name","page":"JuMP","title":"name","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.name","category":"page"},{"location":"api/JuMP/#JuMP.name","page":"JuMP","title":"JuMP.name","text":"name(con_ref::ConstraintRef)\n\nGet a constraint's name attribute.\n\n\n\n\n\nname(v::GenericVariableRef)::String\n\nGet a variable's name attribute.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x[1:2])\n2-element Vector{VariableRef}:\n x[1]\n x[2]\n\njulia> name(x[1])\n\"x[1]\"\n\n\n\n\n\nname(model::AbstractModel)\n\nReturn the MOI.Name attribute of model's backend, or a default if empty.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#node_count","page":"JuMP","title":"node_count","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.node_count","category":"page"},{"location":"api/JuMP/#JuMP.node_count","page":"JuMP","title":"JuMP.node_count","text":"node_count(model::GenericModel)\n\nGets the total number of branch-and-bound nodes explored during the most recent optimization in a Mixed Integer Program.\n\nSolvers must implement MOI.NodeCount() to use this function.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#normalized_coefficient","page":"JuMP","title":"normalized_coefficient","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.normalized_coefficient","category":"page"},{"location":"api/JuMP/#JuMP.normalized_coefficient","page":"JuMP","title":"JuMP.normalized_coefficient","text":"normalized_coefficient(\n    constraint::ConstraintRef,\n    variable::GenericVariableRef,\n)\n\nReturn the coefficient associated with variable in constraint after JuMP has normalized the constraint into its standard form.\n\nSee also set_normalized_coefficient.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, 2x + 3x <= 2)\ncon : 5 x ≤ 2\n\njulia> normalized_coefficient(con, x)\n5.0\n\njulia> @constraint(model, con_vec, [x, 2x + 1, 3] >= 0)\ncon_vec : [x, 2 x + 1, 3] ∈ MathOptInterface.Nonnegatives(3)\n\njulia> normalized_coefficient(con_vec, x)\n2-element Vector{Tuple{Int64, Float64}}:\n (1, 1.0)\n (2, 2.0)\n\n\n\n\n\nnormalized_coefficient(\n    constraint::ConstraintRef,\n    variable_1::GenericVariableRef,\n    variable_2::GenericVariableRef,\n)\n\nReturn the quadratic coefficient associated with variable_1 and variable_2 in constraint after JuMP has normalized the constraint into its standard form.\n\nSee also set_normalized_coefficient.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @constraint(model, con, 2x[1]^2 + 3 * x[1] * x[2] + x[2] <= 2)\ncon : 2 x[1]² + 3 x[1]*x[2] + x[2] ≤ 2\n\njulia> normalized_coefficient(con, x[1], x[1])\n2.0\n\njulia> normalized_coefficient(con, x[1], x[2])\n3.0\n\njulia> @constraint(model, con_vec, x.^2 <= [1, 2])\ncon_vec : [x[1]² - 1, x[2]² - 2] ∈ MathOptInterface.Nonpositives(2)\n\njulia> normalized_coefficient(con_vec, x[1], x[1])\n1-element Vector{Tuple{Int64, Float64}}:\n (1, 1.0)\n\njulia> normalized_coefficient(con_vec, x[1], x[2])\nTuple{Int64, Float64}[]\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#normalized_rhs","page":"JuMP","title":"normalized_rhs","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.normalized_rhs","category":"page"},{"location":"api/JuMP/#JuMP.normalized_rhs","page":"JuMP","title":"JuMP.normalized_rhs","text":"normalized_rhs(constraint::ConstraintRef)\n\nReturn the right-hand side term of constraint after JuMP has converted the constraint into its normalized form.\n\nSee also set_normalized_rhs.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @constraint(model, con, 2x + 1 <= 2)\ncon : 2 x ≤ 1\n\njulia> normalized_rhs(con)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#num_constraints","page":"JuMP","title":"num_constraints","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.num_constraints","category":"page"},{"location":"api/JuMP/#JuMP.num_constraints","page":"JuMP","title":"JuMP.num_constraints","text":"num_constraints(model::GenericModel, function_type, set_type)::Int64\n\nReturn the number of constraints currently in the model where the function has type function_type and the set has type set_type.\n\nSee also list_of_constraint_types and all_constraints.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @variable(model, y);\n\njulia> @constraint(model, y in MOI.GreaterThan(1.0));\n\njulia> @constraint(model, y <= 1.0);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> num_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n2\n\njulia> num_constraints(model, VariableRef, MOI.ZeroOne)\n1\n\njulia> num_constraints(model, AffExpr, MOI.LessThan{Float64})\n2\n\n\n\n\n\nnum_constraints(model::GenericModel; count_variable_in_set_constraints::Bool)\n\nReturn the number of constraints in model.\n\nIf count_variable_in_set_constraints == true, then VariableRef constraints such as VariableRef-in-Integer are included. To count only the number of structural constraints (for example, the rows in the constraint matrix of a linear program), pass count_variable_in_set_constraints = false.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Int);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> num_constraints(model; count_variable_in_set_constraints = true)\n3\n\njulia> num_constraints(model; count_variable_in_set_constraints = false)\n1\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#num_variables","page":"JuMP","title":"num_variables","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.num_variables","category":"page"},{"location":"api/JuMP/#JuMP.num_variables","page":"JuMP","title":"JuMP.num_variables","text":"num_variables(model::GenericModel)::Int64\n\nReturns number of variables in model.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> num_variables(model)\n2\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#object_dictionary","page":"JuMP","title":"object_dictionary","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.object_dictionary","category":"page"},{"location":"api/JuMP/#JuMP.object_dictionary","page":"JuMP","title":"JuMP.object_dictionary","text":"object_dictionary(model::GenericModel)\n\nReturn the dictionary that maps the symbol name of a variable, constraint, or expression to the corresponding object.\n\nObjects are registered to a specific symbol in the macros. For example, @variable(model, x[1:2, 1:2]) registers the array of variables x to the symbol :x.\n\nThis method should be defined for any subtype of AbstractModel.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#objective_bound","page":"JuMP","title":"objective_bound","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.objective_bound","category":"page"},{"location":"api/JuMP/#JuMP.objective_bound","page":"JuMP","title":"JuMP.objective_bound","text":"objective_bound(model::GenericModel)\n\nReturn the best known bound on the optimal objective value after a call to optimize!(model).\n\nFor scalar-valued objectives, this function returns a Float64. For vector-valued objectives, it returns a Vector{Float64}.\n\nIn the case of a vector-valued objective, this returns the ideal point, that is, the point obtained if each objective was optimized independently.\n\nThis function is equivalent to querying the MOI.ObjectiveBound attribute.\n\nExample\n\njulia> import HiGHS\n\njulia> model = Model(HiGHS.Optimizer);\n\njulia> set_silent(model)\n\njulia> @variable(model, x >= 1, Int);\n\njulia> @objective(model, Min, 2 * x + 1);\n\njulia> optimize!(model)\n\njulia> objective_bound(model)\n3.0\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#objective_function","page":"JuMP","title":"objective_function","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.objective_function","category":"page"},{"location":"api/JuMP/#JuMP.objective_function","page":"JuMP","title":"JuMP.objective_function","text":"objective_function(\n    model::GenericModel,\n    ::Type{F} = objective_function_type(model),\n) where {F}\n\nReturn an object of type F representing the objective function.\n\nErrors if the objective is not convertible to type F.\n\nThis function is equivalent to querying the MOI.ObjectiveFunction{F} attribute.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @objective(model, Min, 2x + 1)\n2 x + 1\n\njulia> objective_function(model, AffExpr)\n2 x + 1\n\njulia> objective_function(model, QuadExpr)\n2 x + 1\n\njulia> typeof(objective_function(model, QuadExpr))\nQuadExpr (alias for GenericQuadExpr{Float64, GenericVariableRef{Float64}})\n\nWe see with the last two commands that even if the objective function is affine, as it is convertible to a quadratic function, it can be queried as a quadratic function and the result is quadratic.\n\nHowever, it is not convertible to a variable:\n\njulia> objective_function(model, VariableRef)\nERROR: InexactError: convert(MathOptInterface.VariableIndex, 1.0 + 2.0 MOI.VariableIndex(1))\n[...]\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#objective_function_string","page":"JuMP","title":"objective_function_string","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.objective_function_string","category":"page"},{"location":"api/JuMP/#JuMP.objective_function_string","page":"JuMP","title":"JuMP.objective_function_string","text":"objective_function_string(mode, model::AbstractModel)::String\n\nReturn a String describing the objective function of the model.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#objective_function_type","page":"JuMP","title":"objective_function_type","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.objective_function_type","category":"page"},{"location":"api/JuMP/#JuMP.objective_function_type","page":"JuMP","title":"JuMP.objective_function_type","text":"objective_function_type(model::GenericModel)::AbstractJuMPScalar\n\nReturn the type of the objective function.\n\nThis function is equivalent to querying the MOI.ObjectiveFunctionType attribute.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @objective(model, Min, 2 * x + 1);\n\njulia> objective_function_type(model)\nAffExpr (alias for GenericAffExpr{Float64, GenericVariableRef{Float64}})\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#objective_sense","page":"JuMP","title":"objective_sense","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.objective_sense","category":"page"},{"location":"api/JuMP/#JuMP.objective_sense","page":"JuMP","title":"JuMP.objective_sense","text":"objective_sense(model::GenericModel)::MOI.OptimizationSense\n\nReturn the objective sense.\n\nThis function is equivalent to querying the MOI.ObjectiveSense attribute.\n\nExample\n\njulia> model = Model();\n\njulia> objective_sense(model)\nFEASIBILITY_SENSE::OptimizationSense = 2\n\njulia> @variable(model, x);\n\njulia> @objective(model, Max, x)\nx\n\njulia> objective_sense(model)\nMAX_SENSE::OptimizationSense = 1\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#objective_value","page":"JuMP","title":"objective_value","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.objective_value","category":"page"},{"location":"api/JuMP/#JuMP.objective_value","page":"JuMP","title":"JuMP.objective_value","text":"objective_value(model::GenericModel; result::Int = 1)\n\nReturn the objective value associated with result index result of the most-recent solution returned by the solver.\n\nFor scalar-valued objectives, this function returns a Float64. For vector-valued objectives, it returns a Vector{Float64}.\n\nThis function is equivalent to querying the MOI.ObjectiveValue attribute.\n\nSee also: result_count.\n\nExample\n\njulia> import HiGHS\n\njulia> model = Model(HiGHS.Optimizer);\n\njulia> set_silent(model)\n\njulia> @variable(model, x >= 1);\n\njulia> @objective(model, Min, 2 * x + 1);\n\njulia> optimize!(model)\n\njulia> objective_value(model)\n3.0\n\njulia> objective_value(model; result = 2)\nERROR: Result index of attribute MathOptInterface.ObjectiveValue(2) out of bounds. There are currently 1 solution(s) in the model.\nStacktrace:\n[...]\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#op_ifelse","page":"JuMP","title":"op_ifelse","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.op_ifelse","category":"page"},{"location":"api/JuMP/#JuMP.op_ifelse","page":"JuMP","title":"JuMP.op_ifelse","text":"op_ifelse(a, x, y)\n\nA function that falls back to ifelse(a, x, y), but when called with a JuMP variables or expression in the first argument, returns a GenericNonlinearExpr.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> op_ifelse(true, 1.0, 2.0)\n1.0\n\njulia> op_ifelse(x, 1.0, 2.0)\nifelse(x, 1.0, 2.0)\n\njulia> op_ifelse(true, x, 2.0)\nx\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#op_string","page":"JuMP","title":"op_string","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.op_string","category":"page"},{"location":"api/JuMP/#JuMP.op_string","page":"JuMP","title":"JuMP.op_string","text":"op_string(mime::MIME, x::GenericNonlinearExpr, ::Val{op}) where {op}\n\nReturn the string that should be printed for the operator op when function_string is called with mime and x.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#operator_to_set","page":"JuMP","title":"operator_to_set","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.operator_to_set","category":"page"},{"location":"api/JuMP/#JuMP.operator_to_set","page":"JuMP","title":"JuMP.operator_to_set","text":"operator_to_set(error_fn::Function, ::Val{sense_symbol})\n\nConverts a sense symbol to a set set such that @constraint(model, func sense_symbol 0) is equivalent to @constraint(model, func in set) for any func::AbstractJuMPScalar.\n\nExample\n\nOnce a custom set is defined you can directly create a JuMP constraint with it:\n\njulia> struct CustomSet{T} <: MOI.AbstractScalarSet\n           value::T\n       end\n\njulia> Base.copy(x::CustomSet) = CustomSet(x.value)\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> cref = @constraint(model, x in CustomSet(1.0))\nx ∈ CustomSet{Float64}(1.0)\n\nHowever, there might be an appropriate sign that could be used in order to provide a more convenient syntax:\n\njulia> JuMP.operator_to_set(::Function, ::Val{:⊰}) = CustomSet(0.0)\n\njulia> MOIU.supports_shift_constant(::Type{<:CustomSet}) = true\n\njulia> MOIU.shift_constant(set::CustomSet, value) = CustomSet(set.value + value)\n\njulia> cref = @constraint(model, x ⊰ 1)\nx ∈ CustomSet{Float64}(1.0)\n\nNote that the whole function is first moved to the right-hand side, then the sign is transformed into a set with zero constant and finally the constant is moved to the set with MOIU.shift_constant.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#operator_warn","page":"JuMP","title":"operator_warn","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.operator_warn","category":"page"},{"location":"api/JuMP/#JuMP.operator_warn","page":"JuMP","title":"JuMP.operator_warn","text":"operator_warn(model::AbstractModel)\noperator_warn(model::GenericModel)\n\nThis function is called on the model whenever two affine expressions are added together without using destructive_add!, and at least one of the two expressions has more than 50 terms.\n\nFor the case of Model, if this function is called more than 20,000 times then a warning is generated once.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#optimize!","page":"JuMP","title":"optimize!","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.optimize!","category":"page"},{"location":"api/JuMP/#JuMP.optimize!","page":"JuMP","title":"JuMP.optimize!","text":"optimize!(\n    model::GenericModel;\n    ignore_optimize_hook = (model.optimize_hook === nothing),\n    _differentiation_backend::MOI.Nonlinear.AbstractAutomaticDifferentiation =\n        MOI.Nonlinear.SparseReverseMode(),\n    kwargs...,\n)\n\nOptimize the model.\n\nIf an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nIf ignore_optimize_hook == true, the optimize hook is ignored and the model is solved as if the hook was not set. Keyword arguments kwargs are passed to the optimize_hook. An error is thrown if optimize_hook is nothing and keyword arguments are provided.\n\nExperimental features\n\nThese features may change or be removed in any future version of JuMP.\n\nPass _differentiation_backend to set the MOI.Nonlinear.AbstractAutomaticDifferentiation backend used to compute derivatives of nonlinear programs.\n\nIf you require only :ExprGraph, it is more efficient to pass _differentiation_backend = MOI.Nonlinear.ExprGraphOnly().\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#optimizer_index","page":"JuMP","title":"optimizer_index","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.optimizer_index","category":"page"},{"location":"api/JuMP/#JuMP.optimizer_index","page":"JuMP","title":"JuMP.optimizer_index","text":"optimizer_index(x::GenericVariableRef)::MOI.VariableIndex\noptimizer_index(x::ConstraintRef{<:GenericModel})::MOI.ConstraintIndex\n\nReturn the variable or constraint index that corresponds to x in the associated model unsafe_backend(owner_model(x)).\n\nThis function should be used with unsafe_backend.\n\nAs a safer alternative, use backend and index. See the docstrings of backend and unsafe_backend for more details.\n\nThrows\n\nThrows NoOptimizer if no optimizer is set.\nThrows an ErrorException if the optimizer is set but is not attached.\nThrows an ErrorException if the index is bridged.\n\nExample\n\njulia> import HiGHS\n\njulia> model = Model(HiGHS.Optimizer);\n\njulia> set_silent(model)\n\njulia> @variable(model, x >= 0)\nx\n\njulia> MOI.Utilities.attach_optimizer(model)\n\njulia> highs = unsafe_backend(model)\nA HiGHS model with 1 columns and 0 rows.\n\njulia> optimizer_index(x)\nMOI.VariableIndex(1)\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#optimizer_with_attributes","page":"JuMP","title":"optimizer_with_attributes","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.optimizer_with_attributes","category":"page"},{"location":"api/JuMP/#JuMP.optimizer_with_attributes","page":"JuMP","title":"JuMP.optimizer_with_attributes","text":"optimizer_with_attributes(optimizer_constructor, attrs::Pair...)\n\nGroups an optimizer constructor with the list of attributes attrs. Note that it is equivalent to MOI.OptimizerWithAttributes.\n\nWhen provided to the Model constructor or to set_optimizer, it creates an optimizer by calling optimizer_constructor(), and then sets the attributes using set_attribute.\n\nSee also: set_attribute, get_attribute.\n\nNote\n\nThe string names of the attributes are specific to each solver. One should consult the solver's documentation to find the attributes of interest.\n\nExample\n\njulia> import HiGHS\n\njulia> optimizer = optimizer_with_attributes(\n           HiGHS.Optimizer, \"presolve\" => \"off\", MOI.Silent() => true,\n       );\n\njulia> model = Model(optimizer);\n\nis equivalent to:\n\njulia> import HiGHS\n\njulia> model = Model(HiGHS.Optimizer);\n\njulia> set_attribute(model, \"presolve\", \"off\")\n\njulia> set_attribute(model, MOI.Silent(), true)\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#owner_model","page":"JuMP","title":"owner_model","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.owner_model","category":"page"},{"location":"api/JuMP/#JuMP.owner_model","page":"JuMP","title":"JuMP.owner_model","text":"owner_model(s::AbstractJuMPScalar)\n\nReturn the model owning the scalar s.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#parameter_value","page":"JuMP","title":"parameter_value","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.parameter_value","category":"page"},{"location":"api/JuMP/#JuMP.parameter_value","page":"JuMP","title":"JuMP.parameter_value","text":"parameter_value(x::GenericVariableRef)\n\nReturn the value of the parameter x.\n\nErrors if x is not a parameter.\n\nSee also ParameterRef, is_parameter, set_parameter_value.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, p in Parameter(2))\np\n\njulia> parameter_value(p)\n2.0\n\njulia> set_parameter_value(p, 2.5)\n\njulia> parameter_value(p)\n2.5\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#parse_constraint","page":"JuMP","title":"parse_constraint","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.parse_constraint","category":"page"},{"location":"api/JuMP/#JuMP.parse_constraint","page":"JuMP","title":"JuMP.parse_constraint","text":"parse_constraint(error_fn::Function, expr::Expr)\n\nThe entry-point for all constraint-related parsing.\n\nArguments\n\nThe error_fn function is passed everywhere to provide better error messages\nexpr comes from the @constraint macro. There are two possibilities:\n@constraint(model, expr)\n@constraint(model, name[args], expr)\nIn both cases, expr is the main component of the constraint.\n\nSupported syntax\n\nJuMP currently supports the following expr objects:\n\nlhs <= rhs\nlhs == rhs\nlhs >= rhs\nl <= body <= u\nu >= body >= l\nlhs ⟂ rhs\nlhs in rhs\nlhs ∈ rhs\nz --> {constraint}\n!z --> {constraint}\nz <--> {constraint}\n!z <--> {constraint}\nz => {constraint}\n!z => {constraint}\n\nas well as all broadcasted variants.\n\nExtensions\n\nThe infrastructure behind parse_constraint is extendable. See parse_constraint_head and parse_constraint_call for details.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#parse_constraint_call","page":"JuMP","title":"parse_constraint_call","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.parse_constraint_call","category":"page"},{"location":"api/JuMP/#JuMP.parse_constraint_call","page":"JuMP","title":"JuMP.parse_constraint_call","text":"parse_constraint_call(\n    error_fn::Function,\n    is_vectorized::Bool,\n    ::Val{op},\n    args...,\n)\n\nImplement this method to intercept the parsing of a :call expression with operator op.\n\nwarning: Warning\nExtending the constraint macro at parse time is an advanced operation and has the potential to interfere with existing JuMP syntax. Please discuss with the developer chatroom before publishing any code that implements these methods.\n\nArguments\n\nerror_fn: a function that accepts a String and throws the string as an error, along with some descriptive information of the macro from which it was thrown.\nis_vectorized: a boolean to indicate if op should be broadcast or not\nop: the first element of the .args field of the Expr to intercept\nargs...: the .args field of the Expr.\n\nReturns\n\nThis function must return:\n\nparse_code::Expr: an expression containing any setup or rewriting code that needs to be called before build_constraint\nbuild_code::Expr: an expression that calls build_constraint( or build_constraint.( depending on is_vectorized.\n\nSee also: parse_constraint_head, build_constraint\n\n\n\n\n\nparse_constraint_call(\n    error_fn::Function,\n    vectorized::Bool,\n    ::Val{op},\n    lhs,\n    rhs,\n) where {op}\n\nFallback handler for binary operators. These might be infix operators like @constraint(model, lhs op rhs), or normal operators like @constraint(model, op(lhs, rhs)).\n\nIn both cases, we rewrite as lhs - rhs in operator_to_set(error_fn, op).\n\nSee operator_to_set for details.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#parse_constraint_head","page":"JuMP","title":"parse_constraint_head","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.parse_constraint_head","category":"page"},{"location":"api/JuMP/#JuMP.parse_constraint_head","page":"JuMP","title":"JuMP.parse_constraint_head","text":"parse_constraint_head(error_fn::Function, ::Val{head}, args...)\n\nImplement this method to intercept the parsing of an expression with head head.\n\nwarning: Warning\nExtending the constraint macro at parse time is an advanced operation and has the potential to interfere with existing JuMP syntax. Please discuss with the developer chatroom before publishing any code that implements these methods.\n\nArguments\n\nerror_fn: a function that accepts a String and throws the string as an error, along with some descriptive information of the macro from which it was thrown.\nhead: the .head field of the Expr to intercept\nargs...: the .args field of the Expr.\n\nReturns\n\nThis function must return:\n\nis_vectorized::Bool: whether the expression represents a broadcasted expression like x .<= 1\nparse_code::Expr: an expression containing any setup or rewriting code that needs to be called before build_constraint\nbuild_code::Expr: an expression that calls build_constraint( or build_constraint.( depending on is_vectorized.\n\nExisting implementations\n\nJuMP currently implements:\n\n::Val{:call}, which forwards calls to parse_constraint_call\n::Val{:comparison}, which handles the special case of l <= body <= u.\n\nSee also: parse_constraint_call, build_constraint\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#parse_one_operator_variable","page":"JuMP","title":"parse_one_operator_variable","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.parse_one_operator_variable","category":"page"},{"location":"api/JuMP/#JuMP.parse_one_operator_variable","page":"JuMP","title":"JuMP.parse_one_operator_variable","text":"parse_one_operator_variable(\n    error_fn::Function,\n    info_expr::_VariableInfoExpr,\n    sense::Val{S},\n    value,\n) where {S}\n\nUpdate infoexr for a variable expression in the @variable macro of the form variable name S value.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#parse_ternary_variable","page":"JuMP","title":"parse_ternary_variable","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.parse_ternary_variable","category":"page"},{"location":"api/JuMP/#JuMP.parse_ternary_variable","page":"JuMP","title":"JuMP.parse_ternary_variable","text":"parse_ternary_variable(error_fn, info_expr, lhs_sense, lhs, rhs_sense, rhs)\n\nA hook for JuMP extensions to intercept the parsing of a :comparison expression, which has the form lhs lhs_sense variable rhs_sense rhs.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#parse_variable","page":"JuMP","title":"parse_variable","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.parse_variable","category":"page"},{"location":"api/JuMP/#JuMP.parse_variable","page":"JuMP","title":"JuMP.parse_variable","text":"parse_variable(error_fn::Function, ::_VariableInfoExpr, args...)\n\nA hook for extensions to intercept the parsing of inequality constraints in the @variable macro.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#primal_feasibility_report","page":"JuMP","title":"primal_feasibility_report","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.primal_feasibility_report","category":"page"},{"location":"api/JuMP/#JuMP.primal_feasibility_report","page":"JuMP","title":"JuMP.primal_feasibility_report","text":"primal_feasibility_report(\n    model::GenericModel{T},\n    point::AbstractDict{GenericVariableRef{T},T} = _last_primal_solution(model),\n    atol::T = zero(T),\n    skip_missing::Bool = false,\n)::Dict{Any,T}\n\nGiven a dictionary point, which maps variables to primal values, return a dictionary whose keys are the constraints with an infeasibility greater than the supplied tolerance atol. The value corresponding to each key is the respective infeasibility. Infeasibility is defined as the distance between the primal value of the constraint (see MOI.ConstraintPrimal) and the nearest point by Euclidean distance in the corresponding set.\n\nNotes\n\nIf skip_missing = true, constraints containing variables that are not in point will be ignored.\nIf skip_missing = false and a partial primal solution is provided, an error will be thrown.\nIf no point is provided, the primal solution from the last time the model was solved is used.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, 0.5 <= x <= 1);\n\njulia> primal_feasibility_report(model, Dict(x => 0.2))\nDict{Any, Float64} with 1 entry:\n  x ≥ 0.5 => 0.3\n\n\n\n\n\nprimal_feasibility_report(\n    point::Function,\n    model::GenericModel{T};\n    atol::T = zero(T),\n    skip_missing::Bool = false,\n) where {T}\n\nA form of primal_feasibility_report where a function is passed as the first argument instead of a dictionary as the second argument.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, 0.5 <= x <= 1, start = 1.3);\n\njulia> primal_feasibility_report(model) do v\n           return start_value(v)\n       end\nDict{Any, Float64} with 1 entry:\n  x ≤ 1 => 0.3\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#primal_status","page":"JuMP","title":"primal_status","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.primal_status","category":"page"},{"location":"api/JuMP/#JuMP.primal_status","page":"JuMP","title":"JuMP.primal_status","text":"primal_status(model::GenericModel; result::Int = 1)\n\nReturn a MOI.ResultStatusCode describing the status of the most recent primal solution of the solver (that is, the MOI.PrimalStatus attribute) associated with the result index result.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#print_active_bridges","page":"JuMP","title":"print_active_bridges","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.print_active_bridges","category":"page"},{"location":"api/JuMP/#JuMP.print_active_bridges","page":"JuMP","title":"JuMP.print_active_bridges","text":"print_active_bridges([io::IO = stdout,] model::GenericModel)\n\nPrint a list of the variable, constraint, and objective bridges that are currently used in the model.\n\n\n\n\n\nprint_active_bridges([io::IO = stdout,] model::GenericModel, ::Type{F}) where {F}\n\nPrint a list of bridges required for an objective function of type F.\n\n\n\n\n\nprint_active_bridges(\n    [io::IO = stdout,]\n    model::GenericModel,\n    F::Type,\n    S::Type{<:MOI.AbstractSet},\n)\n\nPrint a list of bridges required for a constraint of type F-in-S.\n\n\n\n\n\nprint_active_bridges(\n    [io::IO = stdout,]\n    model::GenericModel,\n    S::Type{<:MOI.AbstractSet},\n)\n\nPrint a list of bridges required to add a variable constrained to the set S.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#print_bridge_graph","page":"JuMP","title":"print_bridge_graph","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.print_bridge_graph","category":"page"},{"location":"api/JuMP/#JuMP.print_bridge_graph","page":"JuMP","title":"JuMP.print_bridge_graph","text":" print_bridge_graph([io::IO,] model::GenericModel)\n\nPrint the hyper-graph containing all variable, constraint, and objective types that could be obtained by bridging the variables, constraints, and objectives that are present in the model.\n\nwarning: Warning\nThis function is intended for advanced users. If you want to see only the bridges that are currently used, use print_active_bridges instead.\n\nExplanation of output\n\nEach node in the hyper-graph corresponds to a variable, constraint, or objective type.\n\nVariable nodes are indicated by [ ]\nConstraint nodes are indicated by ( )\nObjective nodes are indicated by | |\n\nThe number inside each pair of brackets is an index of the node in the hyper-graph.\n\nNote that this hyper-graph is the full list of possible transformations. When the bridged model is created, we select the shortest hyper-path(s) from this graph, so many nodes may be un-used.\n\nFor more information, see Legat, B., Dowson, O., Garcia, J., and Lubin, M. (2020).  \"MathOptInterface: a data structure for mathematical optimization problems.\" URL: https://arxiv.org/abs/2002.03447\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#quad_terms","page":"JuMP","title":"quad_terms","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.quad_terms","category":"page"},{"location":"api/JuMP/#JuMP.quad_terms","page":"JuMP","title":"JuMP.quad_terms","text":"quad_terms(quad::GenericQuadExpr{C, V})\n\nProvides an iterator over tuples (coefficient::C, var_1::V, var_2::V) in the quadratic part of the quadratic expression.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#raw_status","page":"JuMP","title":"raw_status","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.raw_status","category":"page"},{"location":"api/JuMP/#JuMP.raw_status","page":"JuMP","title":"JuMP.raw_status","text":"raw_status(model::GenericModel)\n\nReturn the reason why the solver stopped in its own words (that is, the MathOptInterface model attribute RawStatusString).\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#read_from_file","page":"JuMP","title":"read_from_file","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.read_from_file","category":"page"},{"location":"api/JuMP/#JuMP.read_from_file","page":"JuMP","title":"JuMP.read_from_file","text":"read_from_file(\n    filename::String;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_AUTOMATIC,\n    kwargs...,\n)\n\nReturn a JuMP model read from filename in the format format.\n\nIf the filename ends in .gz, it will be uncompressed using GZip. If the filename ends in .bz2, it will be uncompressed using BZip2.\n\nOther kwargs are passed to the Model constructor of the chosen format.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#reduced_cost","page":"JuMP","title":"reduced_cost","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.reduced_cost","category":"page"},{"location":"api/JuMP/#JuMP.reduced_cost","page":"JuMP","title":"JuMP.reduced_cost","text":"reduced_cost(x::GenericVariableRef{T})::T where {T}\n\nReturn the reduced cost associated with variable x.\n\nEquivalent to querying the shadow price of the active variable bound (if one exists and is active).\n\nSee also: shadow_price.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#relative_gap","page":"JuMP","title":"relative_gap","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.relative_gap","category":"page"},{"location":"api/JuMP/#JuMP.relative_gap","page":"JuMP","title":"JuMP.relative_gap","text":"relative_gap(model::GenericModel)\n\nReturn the final relative optimality gap after a call to optimize!(model).\n\nExact value depends upon implementation of MOI.RelativeGap by the particular solver used for optimization.\n\nThis function is equivalent to querying the MOI.RelativeGap attribute.\n\nExample\n\njulia> import HiGHS\n\njulia> model = Model(HiGHS.Optimizer);\n\njulia> set_silent(model)\n\njulia> @variable(model, x >= 1, Int);\n\njulia> @objective(model, Min, 2 * x + 1);\n\njulia> optimize!(model)\n\njulia> relative_gap(model)\n0.0\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#relax_integrality","page":"JuMP","title":"relax_integrality","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.relax_integrality","category":"page"},{"location":"api/JuMP/#JuMP.relax_integrality","page":"JuMP","title":"JuMP.relax_integrality","text":"relax_integrality(model::GenericModel)\n\nModifies model to \"relax\" all binary and integrality constraints on variables. Specifically,\n\nBinary constraints are deleted, and variable bounds are tightened if necessary to ensure the variable is constrained to the interval 0 1.\nIntegrality constraints are deleted without modifying variable bounds.\nAn error is thrown if semi-continuous or semi-integer constraints are present (support may be added for these in the future).\nAll other constraints are ignored (left in place). This includes discrete constraints like SOS and indicator constraints.\n\nReturns a function that can be called without any arguments to restore the original model. The behavior of this function is undefined if additional changes are made to the affected variables in the meantime.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x, Bin);\n\njulia> @variable(model, 1 <= y <= 10, Int);\n\njulia> @objective(model, Min, x + y);\n\njulia> undo_relax = relax_integrality(model);\n\njulia> print(model)\nMin x + y\nSubject to\n x ≥ 0\n y ≥ 1\n x ≤ 1\n y ≤ 10\n\njulia> undo_relax()\n\njulia> print(model)\nMin x + y\nSubject to\n y ≥ 1\n y ≤ 10\n y integer\n x binary\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#relax_with_penalty!","page":"JuMP","title":"relax_with_penalty!","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.relax_with_penalty!","category":"page"},{"location":"api/JuMP/#JuMP.relax_with_penalty!","page":"JuMP","title":"JuMP.relax_with_penalty!","text":"relax_with_penalty!(\n    model::GenericModel{T},\n    [penalties::Dict{ConstraintRef,T}];\n    [default::Union{Nothing,Real} = nothing,]\n) where {T}\n\nDestructively modify the model in-place to create a penalized relaxation of the constraints.\n\nwarning: Warning\nThis is a destructive routine that modifies the model in-place. If you don't want to modify the original model, use copy_model to create a copy before calling relax_with_penalty!.\n\nReformulation\n\nSee MOI.Utilities.ScalarPenaltyRelaxation for details of the reformulation.\n\nFor each constraint ci, the penalty passed to MOI.Utilities.ScalarPenaltyRelaxation is get(penalties, ci, default). If the value is nothing, because ci does not exist in penalties and default = nothing, then the constraint is skipped.\n\nReturn value\n\nThis function returns a Dict{ConstraintRef,AffExpr} that maps each constraint index to the corresponding y + z as an AffExpr. In an optimal solution, query the value of these functions to compute the violation of each constraint.\n\nRelax a subset of constraints\n\nTo relax a subset of constraints, pass a penalties dictionary and set default = nothing.\n\nExample\n\njulia> function new_model()\n           model = Model()\n           @variable(model, x)\n           @objective(model, Max, 2x + 1)\n           @constraint(model, c1, 2x - 1 <= -2)\n           @constraint(model, c2, 3x >= 0)\n           return model\n       end\nnew_model (generic function with 1 method)\n\njulia> model_1 = new_model();\n\njulia> penalty_map = relax_with_penalty!(model_1; default = 2.0);\n\njulia> penalty_map[model_1[:c1]]\n_[3]\n\njulia> penalty_map[model_1[:c2]]\n_[2]\n\njulia> print(model_1)\nMax 2 x - 2 _[2] - 2 _[3] + 1\nSubject to\n c2 : 3 x + _[2] ≥ 0\n c1 : 2 x - _[3] ≤ -1\n _[2] ≥ 0\n _[3] ≥ 0\n\njulia> model_2 = new_model();\n\njulia> relax_with_penalty!(model_2, Dict(model_2[:c2] => 3.0))\nDict{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}, ScalarShape}, AffExpr} with 1 entry:\n  c2 : 3 x + _[2] ≥ 0 => _[2]\n\njulia> print(model_2)\nMax 2 x - 3 _[2] + 1\nSubject to\n c2 : 3 x + _[2] ≥ 0\n c1 : 2 x ≤ -1\n _[2] ≥ 0\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#remove_bridge","page":"JuMP","title":"remove_bridge","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.remove_bridge","category":"page"},{"location":"api/JuMP/#JuMP.remove_bridge","page":"JuMP","title":"JuMP.remove_bridge","text":"remove_bridge(\n    model::GenericModel{S},\n    BT::Type{<:MOI.Bridges.AbstractBridge};\n    coefficient_type::Type{T} = S,\n) where {S,T}\n\nRemove BT{T} from the list of bridges that can be used to transform unsupported constraints into an equivalent formulation using only constraints supported by the optimizer.\n\nSee also: add_bridge.\n\nExample\n\njulia> model = Model();\n\njulia> add_bridge(model, MOI.Bridges.Constraint.SOCtoNonConvexQuadBridge)\n\njulia> remove_bridge(model, MOI.Bridges.Constraint.SOCtoNonConvexQuadBridge)\n\njulia> add_bridge(\n           model,\n           MOI.Bridges.Constraint.NumberConversionBridge;\n           coefficient_type = Complex{Float64},\n       )\n\njulia> remove_bridge(\n           model,\n           MOI.Bridges.Constraint.NumberConversionBridge;\n           coefficient_type = Complex{Float64},\n       )\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#reshape_set","page":"JuMP","title":"reshape_set","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.reshape_set","category":"page"},{"location":"api/JuMP/#JuMP.reshape_set","page":"JuMP","title":"JuMP.reshape_set","text":"reshape_set(vectorized_set::MOI.AbstractSet, shape::AbstractShape)\n\nReturn a set in its original shape shape given its vectorized form vectorized_form.\n\nExample\n\nGiven a SymmetricMatrixShape of vectorized form [1, 2, 3] in MOI.PositiveSemidefinieConeTriangle(2), the following code returns the set of the original constraint Symmetric(Matrix[1 2; 2 3]) in PSDCone():\n\njulia> reshape_set(MOI.PositiveSemidefiniteConeTriangle(2), SymmetricMatrixShape(2))\nPSDCone()\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#reshape_vector","page":"JuMP","title":"reshape_vector","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.reshape_vector","category":"page"},{"location":"api/JuMP/#JuMP.reshape_vector","page":"JuMP","title":"JuMP.reshape_vector","text":"reshape_vector(vectorized_form::Vector, shape::AbstractShape)\n\nReturn an object in its original shape shape given its vectorized form vectorized_form.\n\nExample\n\nGiven a SymmetricMatrixShape of vectorized form [1, 2, 3], the following code returns the matrix Symmetric(Matrix[1 2; 2 3]):\n\njulia> reshape_vector([1, 2, 3], SymmetricMatrixShape(2))\n2×2 LinearAlgebra.Symmetric{Int64, Matrix{Int64}}:\n 1  2\n 2  3\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#result_count","page":"JuMP","title":"result_count","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.result_count","category":"page"},{"location":"api/JuMP/#JuMP.result_count","page":"JuMP","title":"JuMP.result_count","text":"result_count(model::GenericModel)\n\nReturn the number of results available to query after a call to optimize!.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#reverse_sense","page":"JuMP","title":"reverse_sense","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.reverse_sense","category":"page"},{"location":"api/JuMP/#JuMP.reverse_sense","page":"JuMP","title":"JuMP.reverse_sense","text":"reverse_sense(::Val{T}) where {T}\n\nGiven an (in)equality symbol T, return a new Val object with the opposite (in)equality symbol.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_attribute","page":"JuMP","title":"set_attribute","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_attribute","category":"page"},{"location":"api/JuMP/#JuMP.set_attribute","page":"JuMP","title":"JuMP.set_attribute","text":"set_attribute(model::GenericModel, attr::MOI.AbstractModelAttribute, value)\nset_attribute(x::GenericVariableRef, attr::MOI.AbstractVariableAttribute, value)\nset_attribute(cr::ConstraintRef, attr::MOI.AbstractConstraintAttribute, value)\n\nSet the value of a solver-specifc attribute attr to value.\n\nThis is equivalent to calling MOI.set with the associated MOI model and, for variables and constraints, with the associated MOI.VariableIndex or MOI.ConstraintIndex.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, c, 2 * x <= 1)\nc : 2 x ≤ 1\n\njulia> set_attribute(model, MOI.Name(), \"model_new\")\n\njulia> set_attribute(x, MOI.VariableName(), \"x_new\")\n\njulia> set_attribute(c, MOI.ConstraintName(), \"c_new\")\n\n\n\n\n\nset_attribute(\n    model::Union{GenericModel,MOI.OptimizerWithAttributes},\n    attr::Union{AbstractString,MOI.AbstractOptimizerAttribute},\n    value,\n)\n\nSet the value of a solver-specifc attribute attr to value.\n\nThis is equivalent to calling MOI.set with the associated MOI model.\n\nIf attr is an AbstractString, it is converted to MOI.RawOptimizerAttribute.\n\nExample\n\njulia> import HiGHS\n\njulia> opt = optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => false);\n\njulia> model = Model(opt);\n\njulia> set_attribute(model, \"output_flag\", false)\n\njulia> set_attribute(model, MOI.RawOptimizerAttribute(\"output_flag\"), true)\n\njulia> set_attribute(opt, \"output_flag\", true)\n\njulia> set_attribute(opt, MOI.RawOptimizerAttribute(\"output_flag\"), false)\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_attributes","page":"JuMP","title":"set_attributes","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_attributes","category":"page"},{"location":"api/JuMP/#JuMP.set_attributes","page":"JuMP","title":"JuMP.set_attributes","text":"set_attributes(\n    destination::Union{\n        GenericModel,\n        MOI.OptimizerWithAttributes,\n        GenericVariableRef,\n        ConstraintRef,\n    },\n    pairs::Pair...,\n)\n\nGiven a list of attribute => value pairs, calls set_attribute(destination, attribute, value) for each pair.\n\nSee also: set_attribute, get_attribute.\n\nExample\n\njulia> import Ipopt\n\njulia> model = Model(Ipopt.Optimizer);\n\njulia> set_attributes(model, \"tol\" => 1e-4, \"max_iter\" => 100)\n\nis equivalent to:\n\njulia> import Ipopt\n\njulia> model = Model(Ipopt.Optimizer);\n\njulia> set_attribute(model, \"tol\", 1e-4)\n\njulia> set_attribute(model, \"max_iter\", 100)\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_binary","page":"JuMP","title":"set_binary","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_binary","category":"page"},{"location":"api/JuMP/#JuMP.set_binary","page":"JuMP","title":"JuMP.set_binary","text":"set_binary(v::GenericVariableRef)\n\nAdd a constraint on the variable v that it must take values in the set 01.\n\nSee also BinaryRef, is_binary, unset_binary.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> is_binary(x)\nfalse\n\njulia> set_binary(x)\n\njulia> is_binary(x)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_dual_start_value","page":"JuMP","title":"set_dual_start_value","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_dual_start_value","category":"page"},{"location":"api/JuMP/#JuMP.set_dual_start_value","page":"JuMP","title":"JuMP.set_dual_start_value","text":"set_dual_start_value(con_ref::ConstraintRef, value)\n\nSet the dual start value (MOI attribute ConstraintDualStart) of the constraint con_ref to value. To remove a dual start value set it to nothing.\n\nSee also dual_start_value.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_integer","page":"JuMP","title":"set_integer","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_integer","category":"page"},{"location":"api/JuMP/#JuMP.set_integer","page":"JuMP","title":"JuMP.set_integer","text":"set_integer(variable_ref::GenericVariableRef)\n\nAdd an integrality constraint on the variable variable_ref.\n\nSee also IntegerRef, is_integer, unset_integer.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> is_integer(x)\nfalse\n\njulia> set_integer(x)\n\njulia> is_integer(x)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_lower_bound","page":"JuMP","title":"set_lower_bound","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_lower_bound","category":"page"},{"location":"api/JuMP/#JuMP.set_lower_bound","page":"JuMP","title":"JuMP.set_lower_bound","text":"set_lower_bound(v::GenericVariableRef, lower::Number)\n\nSet the lower bound of a variable. If one does not exist, create a new lower bound constraint.\n\nSee also LowerBoundRef, has_lower_bound, lower_bound, delete_lower_bound.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 1.0);\n\njulia> lower_bound(x)\n1.0\n\njulia> set_lower_bound(x, 2.0)\n\njulia> lower_bound(x)\n2.0\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_name","page":"JuMP","title":"set_name","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_name","category":"page"},{"location":"api/JuMP/#JuMP.set_name","page":"JuMP","title":"JuMP.set_name","text":"set_name(con_ref::ConstraintRef, s::AbstractString)\n\nSet a constraint's name attribute.\n\n\n\n\n\nset_name(v::GenericVariableRef, s::AbstractString)\n\nSet a variable's name attribute.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> set_name(x, \"x_foo\")\n\njulia> x\nx_foo\n\njulia> name(x)\n\"x_foo\"\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_normalized_coefficient","page":"JuMP","title":"set_normalized_coefficient","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_normalized_coefficient","category":"page"},{"location":"api/JuMP/#JuMP.set_normalized_coefficient","page":"JuMP","title":"JuMP.set_normalized_coefficient","text":"set_normalized_coefficient(\n    constraint::ConstraintRef,\n    variable::GenericVariableRef,\n    value::Number,\n)\n\nSet the coefficient of variable in the constraint constraint to value.\n\nNote that prior to this step, JuMP will aggregate multiple terms containing the same variable. For example, given a constraint 2x + 3x <= 2, set_normalized_coefficient(con, x, 4) will create the constraint 4x <= 2.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, 2x + 3x <= 2)\ncon : 5 x ≤ 2\n\njulia> set_normalized_coefficient(con, x, 4)\n\njulia> con\ncon : 4 x ≤ 2\n\n\n\n\n\nset_normalized_coefficient(\n    constraints::AbstractVector{<:ConstraintRef},\n    variables::AbstractVector{<:GenericVariableRef},\n    values::AbstractVector{<:Number},\n)\n\nSet multiple coefficient of variables in the constraints constraints to values.\n\nNote that prior to this step, JuMP will aggregate multiple terms containing the same variable. For example, given a constraint 2x + 3x <= 2, set_normalized_coefficient(con, [x], [4]) will create the constraint 4x <= 2.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @constraint(model, con, 2x + 3x + 4y <= 2)\ncon : 5 x + 4 y ≤ 2\n\njulia> set_normalized_coefficient([con, con], [x, y], [6, 7])\n\njulia> con\ncon : 6 x + 7 y ≤ 2\n\n\n\n\n\nset_normalized_coefficient(\n    con_ref::ConstraintRef,\n    variable::AbstractVariableRef,\n    new_coefficients::Vector{Tuple{Int64,T}},\n)\n\nSet the coefficients of variable in the constraint con_ref to new_coefficients, where each element in new_coefficients is a tuple which maps the row to a new coefficient.\n\nNote that prior to this step, during constraint creation, JuMP will aggregate multiple terms containing the same variable.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, [2x + 3x, 4x] in MOI.Nonnegatives(2))\ncon : [5 x, 4 x] ∈ MathOptInterface.Nonnegatives(2)\n\njulia> set_normalized_coefficient(con, x, [(1, 2.0), (2, 5.0)])\n\njulia> con\ncon : [2 x, 5 x] ∈ MathOptInterface.Nonnegatives(2)\n\n\n\n\n\nset_normalized_coefficient(\n    constraint::ConstraintRef,\n    variable_1:GenericVariableRef,\n    variable_2:GenericVariableRef,\n    value::Number,\n)\n\nSet the quadratic coefficient associated with variable_1 and variable_2 in the constraint constraint to value.\n\nNote that prior to this step, JuMP will aggregate multiple terms containing the same variable. For example, given a constraint 2x^2 + 3x^2 <= 2, set_normalized_coefficient(con, x, x, 4) will create the constraint 4x^2 <= 2.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @constraint(model, con, 2x[1]^2 + 3 * x[1] * x[2] + x[2] <= 2)\ncon : 2 x[1]² + 3 x[1]*x[2] + x[2] ≤ 2\n\njulia> set_normalized_coefficient(con, x[1], x[1], 4)\n\njulia> set_normalized_coefficient(con, x[1], x[2], 5)\n\njulia> con\ncon : 4 x[1]² + 5 x[1]*x[2] + x[2] ≤ 2\n\n\n\n\n\nset_normalized_coefficient(\n    constraints::AbstractVector{<:ConstraintRef},\n    variables_1:AbstractVector{<:GenericVariableRef},\n    variables_2:AbstractVector{<:GenericVariableRef},\n    values::AbstractVector{<:Number},\n)\n\nSet multiple quadratic coefficients associated with variables_1 and variables_2 in the constraints constraints to values.\n\nNote that prior to this step, JuMP will aggregate multiple terms containing the same variable. For example, given a constraint 2x^2 + 3x^2 <= 2, set_normalized_coefficient(con, [x], [x], [4]) will create the constraint 4x^2 <= 2.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @constraint(model, con, 2x[1]^2 + 3 * x[1] * x[2] + x[2] <= 2)\ncon : 2 x[1]² + 3 x[1]*x[2] + x[2] ≤ 2\n\njulia> set_normalized_coefficient([con, con], [x[1], x[1]], [x[1], x[2]], [4, 5])\n\njulia> con\ncon : 4 x[1]² + 5 x[1]*x[2] + x[2] ≤ 2\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_normalized_coefficients","page":"JuMP","title":"set_normalized_coefficients","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_normalized_coefficients","category":"page"},{"location":"api/JuMP/#JuMP.set_normalized_coefficients","page":"JuMP","title":"JuMP.set_normalized_coefficients","text":"set_normalized_coefficients(\n    constraint::ConstraintRef{<:AbstractModel,<:MOI.ConstraintIndex{F}},\n    variable::AbstractVariableRef,\n    new_coefficients::Vector{Tuple{Int64,T}},\n) where {T,F<:Union{MOI.VectorAffineFunction{T},MOI.VectorQuadraticFunction{T}}}\n\nA deprecated method that now redirects to set_normalized_coefficient.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_normalized_rhs","page":"JuMP","title":"set_normalized_rhs","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_normalized_rhs","category":"page"},{"location":"api/JuMP/#JuMP.set_normalized_rhs","page":"JuMP","title":"JuMP.set_normalized_rhs","text":"set_normalized_rhs(constraint::ConstraintRef, value::Number)\n\nSet the right-hand side term of constraint to value.\n\nNote that prior to this step, JuMP will aggregate all constant terms onto the right-hand side of the constraint. For example, given a constraint 2x + 1 <= 2, set_normalized_rhs(con, 4) will create the constraint 2x <= 4, not 2x + 1 <= 4.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @constraint(model, con, 2x + 1 <= 2)\ncon : 2 x ≤ 1\n\njulia> set_normalized_rhs(con, 4)\n\njulia> con\ncon : 2 x ≤ 4\n\n\n\n\n\nset_normalized_rhs(\n    constraints::AbstractVector{<:ConstraintRef},\n    values::AbstractVector{<:Number}\n)\n\nSet the right-hand side terms of all constraints to values.\n\nNote that prior to this step, JuMP will aggregate all constant terms onto the right-hand side of the constraint. For example, given a constraint 2x + 1 <= 2, set_normalized_rhs([con], [4]) will create the constraint 2x <= 4, not 2x + 1 <= 4.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @constraint(model, con1, 2x + 1 <= 2)\ncon1 : 2 x ≤ 1\n\njulia> @constraint(model, con2, 3x + 2 <= 4)\ncon2 : 3 x ≤ 2\n\njulia> set_normalized_rhs([con1, con2], [4, 5])\n\njulia> con1\ncon1 : 2 x ≤ 4\n\njulia> con2\ncon2 : 3 x ≤ 5\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_objective","page":"JuMP","title":"set_objective","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_objective","category":"page"},{"location":"api/JuMP/#JuMP.set_objective","page":"JuMP","title":"JuMP.set_objective","text":"set_objective(model::AbstractModel, sense::MOI.OptimizationSense, func)\n\nThe functional equivalent of the @objective macro.\n\nSets the objective sense and objective function simultaneously, and is equivalent to calling set_objective_sense and set_objective_function separately.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> set_objective(model, MIN_SENSE, x)\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_objective_coefficient","page":"JuMP","title":"set_objective_coefficient","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_objective_coefficient","category":"page"},{"location":"api/JuMP/#JuMP.set_objective_coefficient","page":"JuMP","title":"JuMP.set_objective_coefficient","text":"set_objective_coefficient(\n    model::GenericModel,\n    variable::GenericVariableRef,\n    coefficient::Real,\n)\n\nSet the linear objective coefficient associated with variable to coefficient.\n\nNote: this function will throw an error if a nonlinear objective is set.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @objective(model, Min, 2x + 1)\n2 x + 1\n\njulia> set_objective_coefficient(model, x, 3)\n\njulia> objective_function(model)\n3 x + 1\n\n\n\n\n\nset_objective_coefficient(\n    model::GenericModel,\n    variables::Vector{<:GenericVariableRef},\n    coefficients::Vector{<:Real},\n)\n\nSet multiple linear objective coefficients associated with variables to coefficients, in a single call.\n\nNote: this function will throw an error if a nonlinear objective is set.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @variable(model, y);\n\njulia> @objective(model, Min, 3x + 2y + 1)\n3 x + 2 y + 1\n\njulia> set_objective_coefficient(model, [x, y], [5, 4])\n\njulia> objective_function(model)\n5 x + 4 y + 1\n\n\n\n\n\nset_objective_coefficient(\n    model::GenericModel{T},\n    variable_1::GenericVariableRef{T},\n    variable_2::GenericVariableRef{T},\n    coefficient::Real,\n) where {T}\n\nSet the quadratic objective coefficient associated with variable_1 and variable_2 to coefficient.\n\nNote: this function will throw an error if a nonlinear objective is set.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @objective(model, Min, x[1]^2 + x[1] * x[2])\nx[1]² + x[1]*x[2]\n\njulia> set_objective_coefficient(model, x[1], x[1], 2)\n\njulia> set_objective_coefficient(model, x[1], x[2], 3)\n\njulia> objective_function(model)\n2 x[1]² + 3 x[1]*x[2]\n\n\n\n\n\nset_objective_coefficient(\n    model::GenericModel{T},\n    variables_1::AbstractVector{<:GenericVariableRef{T}},\n    variables_2::AbstractVector{<:GenericVariableRef{T}},\n    coefficients::AbstractVector{<:Real},\n) where {T}\n\nSet multiple quadratic objective coefficients associated with variables_1 and variables_2 to coefficients, in a single call.\n\nNote: this function will throw an error if a nonlinear objective is set.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @objective(model, Min, x[1]^2 + x[1] * x[2])\nx[1]² + x[1]*x[2]\n\njulia> set_objective_coefficient(model, [x[1], x[1]], [x[1], x[2]], [2, 3])\n\njulia> objective_function(model)\n2 x[1]² + 3 x[1]*x[2]\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_objective_function","page":"JuMP","title":"set_objective_function","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_objective_function","category":"page"},{"location":"api/JuMP/#JuMP.set_objective_function","page":"JuMP","title":"JuMP.set_objective_function","text":"set_objective_function(model::GenericModel, func::MOI.AbstractFunction)\nset_objective_function(model::GenericModel, func::AbstractJuMPScalar)\nset_objective_function(model::GenericModel, func::Real)\nset_objective_function(model::GenericModel, func::Vector{<:AbstractJuMPScalar})\n\nSets the objective function of the model to the given function.\n\nSee set_objective_sense to set the objective sense.\n\nThese are low-level functions; the recommended way to set the objective is with the @objective macro.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @objective(model, Min, x);\n\njulia> objective_function(model)\nx\n\njulia> set_objective_function(model, 2 * x + 1)\n\njulia> objective_function(model)\n2 x + 1\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_objective_sense","page":"JuMP","title":"set_objective_sense","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_objective_sense","category":"page"},{"location":"api/JuMP/#JuMP.set_objective_sense","page":"JuMP","title":"JuMP.set_objective_sense","text":"set_objective_sense(model::GenericModel, sense::MOI.OptimizationSense)\n\nSets the objective sense of the model to the given sense.\n\nSee set_objective_function to set the objective function.\n\nThese are low-level functions; the recommended way to set the objective is with the @objective macro.\n\nExample\n\njulia> model = Model();\n\njulia> objective_sense(model)\nFEASIBILITY_SENSE::OptimizationSense = 2\n\njulia> set_objective_sense(model, MOI.MAX_SENSE)\n\njulia> objective_sense(model)\nMAX_SENSE::OptimizationSense = 1\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_optimize_hook","page":"JuMP","title":"set_optimize_hook","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_optimize_hook","category":"page"},{"location":"api/JuMP/#JuMP.set_optimize_hook","page":"JuMP","title":"JuMP.set_optimize_hook","text":"set_optimize_hook(model::GenericModel, f::Union{Function,Nothing})\n\nSet the function f as the optimize hook for model.\n\nf should have a signature f(model::GenericModel; kwargs...), where the kwargs are those passed to optimize!.\n\nNotes\n\nThe optimize hook should generally modify the model, or some external state in some way, and then call optimize!(model; ignore_optimize_hook = true) to optimize the problem, bypassing the hook.\nUse set_optimize_hook(model, nothing) to unset an optimize hook.\n\nExample\n\njulia> model = Model();\n\njulia> function my_hook(model::Model; kwargs...)\n           println(kwargs)\n           println(\"Calling with `ignore_optimize_hook = true`\")\n           optimize!(model; ignore_optimize_hook = true)\n           return\n       end\nmy_hook (generic function with 1 method)\n\njulia> set_optimize_hook(model, my_hook)\nmy_hook (generic function with 1 method)\n\njulia> optimize!(model; test_arg = true)\nBase.Pairs{Symbol, Bool, Tuple{Symbol}, @NamedTuple{test_arg::Bool}}(:test_arg => 1)\nCalling with `ignore_optimize_hook = true`\nERROR: NoOptimizer()\n[...]\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_optimizer","page":"JuMP","title":"set_optimizer","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_optimizer","category":"page"},{"location":"api/JuMP/#JuMP.set_optimizer","page":"JuMP","title":"JuMP.set_optimizer","text":"set_optimizer(\n    model::GenericModel,\n    optimizer_factory;\n    add_bridges::Bool = true,\n)\n\nCreates an empty MathOptInterface.AbstractOptimizer instance by calling optimizer_factory() and sets it as the optimizer of model. Specifically, optimizer_factory must be callable with zero arguments and return an empty MathOptInterface.AbstractOptimizer.\n\nIf add_bridges is true, constraints and objectives that are not supported by the optimizer are automatically bridged to equivalent supported formulation. Passing add_bridges = false can improve performance if the solver natively supports all of the elements in model.\n\nSee set_attribute for setting solver-specific parameters of the optimizer.\n\nExample\n\njulia> import HiGHS\n\njulia> model = Model();\n\njulia> set_optimizer(model, () -> HiGHS.Optimizer())\n\njulia> set_optimizer(model, HiGHS.Optimizer; add_bridges = false)\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_optimizer_attributes","page":"JuMP","title":"set_optimizer_attributes","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_optimizer_attributes","category":"page"},{"location":"api/JuMP/#JuMP.set_optimizer_attributes","page":"JuMP","title":"JuMP.set_optimizer_attributes","text":"set_optimizer_attributes(\n    model::Union{GenericModel,MOI.OptimizerWithAttributes},\n    pairs::Pair...,\n)\n\nGiven a list of attribute => value pairs, calls set_optimizer_attribute(model, attribute, value) for each pair.\n\ncompat: Compat\nThis method will remain in all v1.X releases of JuMP, but it may be removed in a future v2.0 release. We recommend using set_attributes instead.\n\nSee also: set_optimizer_attribute, get_optimizer_attribute.\n\nExample\n\njulia> import Ipopt\n\njulia> model = Model(Ipopt.Optimizer);\n\njulia> set_optimizer_attributes(model, \"tol\" => 1e-4, \"max_iter\" => 100)\n\nis equivalent to:\n\njulia> import Ipopt\n\njulia> model = Model(Ipopt.Optimizer);\n\njulia> set_optimizer_attribute(model, \"tol\", 1e-4)\n\njulia> set_optimizer_attribute(model, \"max_iter\", 100)\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_parameter_value","page":"JuMP","title":"set_parameter_value","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_parameter_value","category":"page"},{"location":"api/JuMP/#JuMP.set_parameter_value","page":"JuMP","title":"JuMP.set_parameter_value","text":"set_parameter_value(x::GenericVariableRef, value)\n\nUpdate the parameter constraint on the variable x to value.\n\nErrors if x is not a parameter.\n\nSee also ParameterRef, is_parameter, parameter_value.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, p in Parameter(2))\np\n\njulia> parameter_value(p)\n2.0\n\njulia> set_parameter_value(p, 2.5)\n\njulia> parameter_value(p)\n2.5\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_silent","page":"JuMP","title":"set_silent","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_silent","category":"page"},{"location":"api/JuMP/#JuMP.set_silent","page":"JuMP","title":"JuMP.set_silent","text":"set_silent(model::GenericModel)\n\nTakes precedence over any other attribute controlling verbosity and requires the solver to produce no output.\n\nSee also: unset_silent.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_start_value","page":"JuMP","title":"set_start_value","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_start_value","category":"page"},{"location":"api/JuMP/#JuMP.set_start_value","page":"JuMP","title":"JuMP.set_start_value","text":"set_start_value(con_ref::ConstraintRef, value)\n\nSet the primal start value (MOI.ConstraintPrimalStart) of the constraint con_ref to value. To remove a primal start value set it to nothing.\n\nSee also start_value.\n\n\n\n\n\nset_start_value(variable::GenericVariableRef, value::Union{Real,Nothing})\n\nSet the start value (MOI attribute VariablePrimalStart) of the variable to value.\n\nPass nothing to unset the start value.\n\nNote: VariablePrimalStarts are sometimes called \"MIP-starts\" or \"warmstarts\".\n\nSee also start_value.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_start_values","page":"JuMP","title":"set_start_values","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_start_values","category":"page"},{"location":"api/JuMP/#JuMP.set_start_values","page":"JuMP","title":"JuMP.set_start_values","text":"set_start_values(\n    model::GenericModel;\n    variable_primal_start::Union{Nothing,Function} = value,\n    constraint_primal_start::Union{Nothing,Function} = value,\n    constraint_dual_start::Union{Nothing,Function} = dual,\n    nonlinear_dual_start::Union{Nothing,Function} = nonlinear_dual_start_value,\n)\n\nSet the primal and dual starting values in model using the functions provided.\n\nIf any keyword argument is nothing, the corresponding start value is skipped.\n\nIf the optimizer does not support setting the starting value, the value will be skipped.\n\nvariable_primal_start\n\nThis function controls the primal starting solution for the variables. It is equivalent to calling set_start_value for each variable, or setting the MOI.VariablePrimalStart attribute.\n\nIf it is a function, it must have the form variable_primal_start(x::VariableRef) that maps each variable x to the starting primal value.\n\nThe default is value.\n\nconstraint_primal_start\n\nThis function controls the primal starting solution for the constraints. It is equivalent to calling set_start_value for each constraint, or setting the MOI.ConstraintPrimalStart attribute.\n\nIf it is a function, it must have the form constraint_primal_start(ci::ConstraintRef) that maps each constraint ci to the starting primal value.\n\nThe default is value.\n\nconstraint_dual_start\n\nThis function controls the dual starting solution for the constraints. It is equivalent to calling set_dual_start_value for each constraint, or setting the MOI.ConstraintDualStart attribute.\n\nIf it is a function, it must have the form constraint_dual_start(ci::ConstraintRef) that maps each constraint ci to the starting dual value.\n\nThe default is dual.\n\nnonlinear_dual_start\n\nThis function controls the dual starting solution for the nonlinear constraints It is equivalent to calling set_nonlinear_dual_start_value.\n\nIf it is a function, it must have the form nonlinear_dual_start(model::GenericModel) that returns a vector corresponding to the dual start of the constraints.\n\nThe default is nonlinear_dual_start_value.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_string_names_on_creation","page":"JuMP","title":"set_string_names_on_creation","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_string_names_on_creation","category":"page"},{"location":"api/JuMP/#JuMP.set_string_names_on_creation","page":"JuMP","title":"JuMP.set_string_names_on_creation","text":"set_string_names_on_creation(model::GenericModel, value::Bool)\n\nSet the default argument of the set_string_name keyword in the @variable and @constraint macros to value. This is used to determine whether to assign String names to all variables and constraints in model.\n\nBy default, value is true. However, for larger models calling set_string_names_on_creation(model, false) can improve performance at the cost of reducing the readability of printing and solver log messages.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_time_limit_sec","page":"JuMP","title":"set_time_limit_sec","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_time_limit_sec","category":"page"},{"location":"api/JuMP/#JuMP.set_time_limit_sec","page":"JuMP","title":"JuMP.set_time_limit_sec","text":"set_time_limit_sec(model::GenericModel, limit::Float64)\n\nSet the time limit (in seconds) of the solver.\n\nCan be unset using unset_time_limit_sec or with limit set to nothing.\n\nSee also: unset_time_limit_sec, time_limit_sec.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_upper_bound","page":"JuMP","title":"set_upper_bound","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_upper_bound","category":"page"},{"location":"api/JuMP/#JuMP.set_upper_bound","page":"JuMP","title":"JuMP.set_upper_bound","text":"set_upper_bound(v::GenericVariableRef, upper::Number)\n\nSet the upper bound of a variable. If one does not exist, create an upper bound constraint.\n\nSee also UpperBoundRef, has_upper_bound, upper_bound, delete_upper_bound.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x <= 1.0);\n\njulia> upper_bound(x)\n1.0\n\njulia> set_upper_bound(x, 2.0)\n\njulia> upper_bound(x)\n2.0\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#shadow_price","page":"JuMP","title":"shadow_price","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.shadow_price","category":"page"},{"location":"api/JuMP/#JuMP.shadow_price","page":"JuMP","title":"JuMP.shadow_price","text":"shadow_price(con_ref::ConstraintRef)\n\nReturn the change in the objective from an infinitesimal relaxation of the constraint.\n\nThis value is computed from dual and can be queried only when has_duals is true and the objective sense is MIN_SENSE or MAX_SENSE (not FEASIBILITY_SENSE). For linear constraints, the shadow prices differ at most in sign from the dual value depending on the objective sense.\n\nSee also reduced_cost.\n\nNotes\n\nThe function simply translates signs from dual and does not validate the conditions needed to guarantee the sensitivity interpretation of the shadow price. The caller is responsible, for example, for checking whether the solver converged to an optimal primal-dual pair or a proof of infeasibility.\nThe computation is based on the current objective sense of the model. If this has changed since the last solve, the results will be incorrect.\nRelaxation of equality constraints (and hence the shadow price) is defined based on which sense of the equality constraint is active.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#shape","page":"JuMP","title":"shape","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.shape","category":"page"},{"location":"api/JuMP/#JuMP.shape","page":"JuMP","title":"JuMP.shape","text":"shape(c::AbstractConstraint)::AbstractShape\n\nReturn the shape of the constraint c.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#show_backend_summary","page":"JuMP","title":"show_backend_summary","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.show_backend_summary","category":"page"},{"location":"api/JuMP/#JuMP.show_backend_summary","page":"JuMP","title":"JuMP.show_backend_summary","text":"show_backend_summary(io::IO, model::GenericModel)\n\nPrint a summary of the optimizer backing model.\n\nAbstractModels should implement this method.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#show_constraints_summary","page":"JuMP","title":"show_constraints_summary","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.show_constraints_summary","category":"page"},{"location":"api/JuMP/#JuMP.show_constraints_summary","page":"JuMP","title":"JuMP.show_constraints_summary","text":"show_constraints_summary(io::IO, model::AbstractModel)\n\nWrite to io a summary of the number of constraints.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#show_objective_function_summary","page":"JuMP","title":"show_objective_function_summary","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.show_objective_function_summary","category":"page"},{"location":"api/JuMP/#JuMP.show_objective_function_summary","page":"JuMP","title":"JuMP.show_objective_function_summary","text":"show_objective_function_summary(io::IO, model::AbstractModel)\n\nWrite to io a summary of the objective function type.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#simplex_iterations","page":"JuMP","title":"simplex_iterations","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.simplex_iterations","category":"page"},{"location":"api/JuMP/#JuMP.simplex_iterations","page":"JuMP","title":"JuMP.simplex_iterations","text":"simplex_iterations(model::GenericModel)\n\nGets the cumulative number of simplex iterations during the most-recent optimization.\n\nSolvers must implement MOI.SimplexIterations() to use this function.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#solution_summary","page":"JuMP","title":"solution_summary","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.solution_summary","category":"page"},{"location":"api/JuMP/#JuMP.solution_summary","page":"JuMP","title":"JuMP.solution_summary","text":"solution_summary(model::GenericModel; result::Int = 1, verbose::Bool = false)\n\nReturn a struct that can be used print a summary of the solution in result result.\n\nIf verbose=true, write out the primal solution for every variable and the dual solution for every constraint, excluding those with empty names.\n\nExample\n\nWhen called at the REPL, the summary is automatically printed:\n\njulia> model = Model();\n\njulia> solution_summary(model)\n* Solver : No optimizer attached.\n\n* Status\n  Result count       : 0\n  Termination status : OPTIMIZE_NOT_CALLED\n  Message from the solver:\n  \"optimize not called\"\n\n* Candidate solution (result #1)\n  Primal status      : NO_SOLUTION\n  Dual status        : NO_SOLUTION\n\n* Work counters\n\nUse print to force the printing of the summary from inside a function:\n\njulia> model = Model();\n\njulia> function foo(model)\n           print(solution_summary(model))\n           return\n       end\nfoo (generic function with 1 method)\n\njulia> foo(model)\n* Solver : No optimizer attached.\n\n* Status\n  Result count       : 0\n  Termination status : OPTIMIZE_NOT_CALLED\n  Message from the solver:\n  \"optimize not called\"\n\n* Candidate solution (result #1)\n  Primal status      : NO_SOLUTION\n  Dual status        : NO_SOLUTION\n\n* Work counters\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#solve_time","page":"JuMP","title":"solve_time","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.solve_time","category":"page"},{"location":"api/JuMP/#JuMP.solve_time","page":"JuMP","title":"JuMP.solve_time","text":"solve_time(model::GenericModel)\n\nIf available, returns the solve time reported by the solver. Returns \"ArgumentError: ModelLike of type Solver.Optimizer does not support accessing the attribute MathOptInterface.SolveTimeSec()\" if the attribute is not implemented.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#solver_name","page":"JuMP","title":"solver_name","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.solver_name","category":"page"},{"location":"api/JuMP/#JuMP.solver_name","page":"JuMP","title":"JuMP.solver_name","text":"solver_name(model::GenericModel)\n\nIf available, returns the SolverName property of the underlying optimizer.\n\nReturns \"No optimizer attached\" in AUTOMATIC or MANUAL modes when no optimizer is attached.\n\nReturns \"SolverName() attribute not implemented by the optimizer.\" if the attribute is not implemented.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#start_value","page":"JuMP","title":"start_value","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.start_value","category":"page"},{"location":"api/JuMP/#JuMP.start_value","page":"JuMP","title":"JuMP.start_value","text":"start_value(con_ref::ConstraintRef)\n\nReturn the primal start value (MOI.ConstraintPrimalStart) of the constraint con_ref.\n\nNote: If no primal start value has been set, start_value will return nothing.\n\nSee also set_start_value.\n\n\n\n\n\nstart_value(v::GenericVariableRef)\n\nReturn the start value (MOI attribute VariablePrimalStart) of the variable v.\n\nNote: VariablePrimalStarts are sometimes called \"MIP-starts\" or \"warmstarts\".\n\nSee also set_start_value.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#termination_status","page":"JuMP","title":"termination_status","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.termination_status","category":"page"},{"location":"api/JuMP/#JuMP.termination_status","page":"JuMP","title":"JuMP.termination_status","text":"termination_status(model::GenericModel)\n\nReturn a MOI.TerminationStatusCode describing why the solver stopped (that is, the MOI.TerminationStatus attribute).\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#time_limit_sec","page":"JuMP","title":"time_limit_sec","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.time_limit_sec","category":"page"},{"location":"api/JuMP/#JuMP.time_limit_sec","page":"JuMP","title":"JuMP.time_limit_sec","text":"time_limit_sec(model::GenericModel)\n\nReturn the time limit (in seconds) of the model.\n\nReturns nothing if unset.\n\nSee also: set_time_limit_sec, unset_time_limit_sec.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#triangle_vec","page":"JuMP","title":"triangle_vec","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.triangle_vec","category":"page"},{"location":"api/JuMP/#JuMP.triangle_vec","page":"JuMP","title":"JuMP.triangle_vec","text":"triangle_vec(matrix::Matrix)\n\nReturn the upper triangle of a matrix concatenated into a vector in the order required by JuMP and MathOptInterface for Triangle sets.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, X[1:3, 1:3], Symmetric);\n\njulia> @variable(model, t)\nt\n\njulia> @constraint(model, [t; triangle_vec(X)] in MOI.RootDetConeTriangle(3))\n[t, X[1,1], X[1,2], X[2,2], X[1,3], X[2,3], X[3,3]] ∈ MathOptInterface.RootDetConeTriangle(3)\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#unfix","page":"JuMP","title":"unfix","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.unfix","category":"page"},{"location":"api/JuMP/#JuMP.unfix","page":"JuMP","title":"JuMP.unfix","text":"unfix(v::GenericVariableRef)\n\nDelete the fixing constraint of a variable.\n\nError if one does not exist.\n\nSee also FixRef, is_fixed, fix_value, fix.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x == 1);\n\njulia> is_fixed(x)\ntrue\n\njulia> unfix(x)\n\njulia> is_fixed(x)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#unregister","page":"JuMP","title":"unregister","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.unregister","category":"page"},{"location":"api/JuMP/#JuMP.unregister","page":"JuMP","title":"JuMP.unregister","text":"unregister(model::GenericModel, key::Symbol)\n\nUnregister the name key from model so that a new variable, constraint, or expression can be created with the same key.\n\nNote that this will not delete the object model[key]; it will just remove the reference at model[key]. To delete the object, use delete as well.\n\nSee also: delete, object_dictionary.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, x)\nERROR: An object of name x is already attached to this model. If this\n    is intended, consider using the anonymous construction syntax, for example,\n    `x = @variable(model, [1:N], ...)` where the name of the object does\n    not appear inside the macro.\n\n    Alternatively, use `unregister(model, :x)` to first unregister\n    the existing name from the model. Note that this will not delete the\n    object; it will just remove the reference at `model[:x]`.\n\nStacktrace:\n[...]\n\njulia> num_variables(model)\n1\n\njulia> unregister(model, :x)\n\njulia> @variable(model, x)\nx\n\njulia> num_variables(model)\n2\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#unsafe_backend","page":"JuMP","title":"unsafe_backend","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.unsafe_backend","category":"page"},{"location":"api/JuMP/#JuMP.unsafe_backend","page":"JuMP","title":"JuMP.unsafe_backend","text":"unsafe_backend(model::GenericModel)\n\nReturn the innermost optimizer associated with the JuMP model model.\n\nThis function should only be used by advanced users looking to access low-level solver-specific functionality. It has a high-risk of incorrect usage. We strongly suggest you use the alternative suggested below.\n\nSee also: backend.\n\nTo obtain the index of a variable or constraint in the unsafe backend, use optimizer_index.\n\nUnsafe behavior\n\nThis function is unsafe for two main reasons.\n\nFirst, the formulation and order of variables and constraints in the unsafe backend may be different to the variables and constraints in model. This can happen because of bridges, or because the solver requires the variables or constraints in a specific order. In addition, the variable or constraint index returned by index at the JuMP level may be different to the index of the corresponding variable or constraint in the unsafe_backend. There is no solution to this. Use the alternative suggested below instead.\n\nSecond, the unsafe_backend may be empty, or lack some modifications made to the JuMP model. Thus, before calling unsafe_backend you should first call MOI.Utilities.attach_optimizer to ensure that the backend is synchronized with the JuMP model.\n\njulia> import HiGHS\n\njulia> model = Model(HiGHS.Optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: HiGHS\n\njulia> MOI.Utilities.attach_optimizer(model)\n\njulia> inner = unsafe_backend(model)\nA HiGHS model with 0 columns and 0 rows.\n\nMoreover, if you modify the JuMP model, the reference you have to the backend (that is, inner in the example above) may be out-dated, and you should call MOI.Utilities.attach_optimizer again.\n\nThis function is also unsafe in the reverse direction: if you modify the unsafe backend, for example, by adding a new constraint to inner, the changes may be silently discarded by JuMP when the JuMP model is modified or solved.\n\nAlternative\n\nInstead of unsafe_backend, create a model using direct_model and call backend instead.\n\nFor example, instead of:\n\njulia> import HiGHS\n\njulia> model = Model(HiGHS.Optimizer);\n\njulia> set_silent(model)\n\njulia> @variable(model, x >= 0)\nx\n\njulia> MOI.Utilities.attach_optimizer(model)\n\njulia> highs = unsafe_backend(model)\nA HiGHS model with 1 columns and 0 rows.\n\njulia> optimizer_index(x)\nMOI.VariableIndex(1)\n\nUse:\n\njulia> import HiGHS\n\njulia> model = direct_model(HiGHS.Optimizer());\n\njulia> set_silent(model)\n\njulia> @variable(model, x >= 0)\nx\n\njulia> highs = backend(model)  # No need to call `attach_optimizer`.\nA HiGHS model with 1 columns and 0 rows.\n\njulia> index(x)\nMOI.VariableIndex(1)\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#unset_binary","page":"JuMP","title":"unset_binary","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.unset_binary","category":"page"},{"location":"api/JuMP/#JuMP.unset_binary","page":"JuMP","title":"JuMP.unset_binary","text":"unset_binary(variable_ref::GenericVariableRef)\n\nRemove the binary constraint on the variable variable_ref.\n\nSee also BinaryRef, is_binary, set_binary.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x, Bin);\n\njulia> is_binary(x)\ntrue\n\njulia> unset_binary(x)\n\njulia> is_binary(x)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#unset_integer","page":"JuMP","title":"unset_integer","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.unset_integer","category":"page"},{"location":"api/JuMP/#JuMP.unset_integer","page":"JuMP","title":"JuMP.unset_integer","text":"unset_integer(variable_ref::GenericVariableRef)\n\nRemove the integrality constraint on the variable variable_ref.\n\nErrors if one does not exist.\n\nSee also IntegerRef, is_integer, set_integer.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x, Int);\n\njulia> is_integer(x)\ntrue\n\njulia> unset_integer(x)\n\njulia> is_integer(x)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#unset_silent","page":"JuMP","title":"unset_silent","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.unset_silent","category":"page"},{"location":"api/JuMP/#JuMP.unset_silent","page":"JuMP","title":"JuMP.unset_silent","text":"unset_silent(model::GenericModel)\n\nNeutralize the effect of the set_silent function and let the solver attributes control the verbosity.\n\nSee also: set_silent.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#unset_time_limit_sec","page":"JuMP","title":"unset_time_limit_sec","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.unset_time_limit_sec","category":"page"},{"location":"api/JuMP/#JuMP.unset_time_limit_sec","page":"JuMP","title":"JuMP.unset_time_limit_sec","text":"unset_time_limit_sec(model::GenericModel)\n\nUnset the time limit of the solver.\n\nSee also: set_time_limit_sec, time_limit_sec.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#upper_bound","page":"JuMP","title":"upper_bound","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.upper_bound","category":"page"},{"location":"api/JuMP/#JuMP.upper_bound","page":"JuMP","title":"JuMP.upper_bound","text":"upper_bound(v::GenericVariableRef)\n\nReturn the upper bound of a variable.\n\nError if one does not exist.\n\nSee also UpperBoundRef, has_upper_bound, set_upper_bound, delete_upper_bound.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x <= 1.0);\n\njulia> upper_bound(x)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#value","page":"JuMP","title":"value","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.value","category":"page"},{"location":"api/JuMP/#JuMP.value","page":"JuMP","title":"JuMP.value","text":"value(con_ref::ConstraintRef; result::Int = 1)\n\nReturn the primal value of constraint con_ref associated with result index result of the most-recent solution returned by the solver.\n\nThat is, if con_ref is the reference of a constraint func-in-set, it returns the value of func evaluated at the value of the variables (given by value(::GenericVariableRef)).\n\nUse has_values to check if a result exists before asking for values.\n\nSee also: result_count.\n\nNote\n\nFor scalar constraints, the constant is moved to the set so it is not taken into account in the primal value of the constraint. For instance, the constraint @constraint(model, 2x + 3y + 1 == 5) is transformed into 2x + 3y-in-MOI.EqualTo(4) so the value returned by this function is the evaluation of 2x + 3y.\n\n\n\n\n\nvalue(var_value::Function, con_ref::ConstraintRef)\n\nEvaluate the primal value of the constraint con_ref using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(v::GenericVariableRef; result = 1)\n\nReturn the value of variable v associated with result index result of the most-recent returned by the solver.\n\nUse has_values to check if a result exists before asking for values.\n\nSee also: result_count.\n\n\n\n\n\nvalue(var_value::Function, v::GenericVariableRef)\n\nEvaluate the value of the variable v as var_value(v).\n\n\n\n\n\nvalue(var_value::Function, ex::GenericAffExpr)\n\nEvaluate ex using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(v::GenericAffExpr; result::Int = 1)\n\nReturn the value of the GenericAffExpr v associated with result index result of the most-recent solution returned by the solver.\n\nSee also: result_count.\n\n\n\n\n\nvalue(var_value::Function, ex::GenericQuadExpr)\n\nEvaluate ex using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(v::GenericQuadExpr; result::Int = 1)\n\nReturn the value of the GenericQuadExpr v associated with result index result of the most-recent solution returned by the solver.\n\nReplaces getvalue for most use cases.\n\nSee also: result_count.\n\n\n\n\n\nvalue(p::NonlinearParameter)\n\nReturn the current value stored in the nonlinear parameter p.\n\nExample\n\njulia> model = Model();\n\njulia> @NLparameter(model, p == 10)\np == 10.0\n\njulia> value(p)\n10.0\n\n\n\n\n\nvalue(ex::NonlinearExpression; result::Int = 1)\n\nReturn the value of the NonlinearExpression ex associated with result index result of the most-recent solution returned by the solver.\n\nSee also: result_count.\n\n\n\n\n\nvalue(var_value::Function, ex::NonlinearExpression)\n\nEvaluate ex using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(c::NonlinearConstraintRef; result::Int = 1)\n\nReturn the value of the NonlinearConstraintRef c associated with result index result of the most-recent solution returned by the solver.\n\nSee also: result_count.\n\n\n\n\n\nvalue(var_value::Function, c::NonlinearConstraintRef)\n\nEvaluate c using var_value(v) as the value for each variable v.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#value_type","page":"JuMP","title":"value_type","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.value_type","category":"page"},{"location":"api/JuMP/#JuMP.value_type","page":"JuMP","title":"JuMP.value_type","text":"value_type(::Type{<:Union{AbstractModel,AbstractVariableRef}})\n\nReturn the return type of value for variables of that model. It defaults to Float64 if it is not implemented.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#variable_by_name","page":"JuMP","title":"variable_by_name","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.variable_by_name","category":"page"},{"location":"api/JuMP/#JuMP.variable_by_name","page":"JuMP","title":"JuMP.variable_by_name","text":"variable_by_name(\n    model::AbstractModel,\n    name::String,\n)::Union{AbstractVariableRef,Nothing}\n\nReturns the reference of the variable with name attribute name or Nothing if no variable has this name attribute. Throws an error if several variables have name as their name attribute.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> variable_by_name(model, \"x\")\nx\n\njulia> @variable(model, base_name=\"x\")\nx\n\njulia> variable_by_name(model, \"x\")\nERROR: Multiple variables have the name x.\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] get(::MOIU.Model{Float64}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/model.jl:222\n [3] get at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/universalfallback.jl:201 [inlined]\n [4] get(::MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.AbstractOptimizer,MathOptInterface.Utilities.UniversalFallback{MOIU.Model{Float64}}}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/cachingoptimizer.jl:490\n [5] variable_by_name(::GenericModel, ::String) at /home/blegat/.julia/dev/JuMP/src/variables.jl:268\n [6] top-level scope at none:0\n\njulia> var = @variable(model, base_name=\"y\")\ny\n\njulia> variable_by_name(model, \"y\")\ny\n\njulia> set_name(var, \"z\")\n\njulia> variable_by_name(model, \"y\")\n\njulia> variable_by_name(model, \"z\")\nz\n\njulia> @variable(model, u[1:2])\n2-element Vector{VariableRef}:\n u[1]\n u[2]\n\njulia> variable_by_name(model, \"u[2]\")\nu[2]\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#variable_ref_type","page":"JuMP","title":"variable_ref_type","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.variable_ref_type","category":"page"},{"location":"api/JuMP/#JuMP.variable_ref_type","page":"JuMP","title":"JuMP.variable_ref_type","text":"variable_ref_type(::Union{F,Type{F}}) where {F}\n\nA helper function used internally by JuMP and some JuMP extensions. Returns the variable type associated with the model or expression type F.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#vectorize","page":"JuMP","title":"vectorize","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.vectorize","category":"page"},{"location":"api/JuMP/#JuMP.vectorize","page":"JuMP","title":"JuMP.vectorize","text":"vectorize(matrix::AbstractMatrix, ::Shape)\n\nConvert the matrix into a vector according to Shape.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#write_to_file","page":"JuMP","title":"write_to_file","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.write_to_file","category":"page"},{"location":"api/JuMP/#JuMP.write_to_file","page":"JuMP","title":"JuMP.write_to_file","text":"write_to_file(\n    model::GenericModel,\n    filename::String;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_AUTOMATIC,\n    kwargs...,\n)\n\nWrite the JuMP model model to filename in the format format.\n\nIf the filename ends in .gz, it will be compressed using GZip. If the filename ends in .bz2, it will be compressed using BZip2.\n\nOther kwargs are passed to the Model constructor of the chosen format.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#AbstractConstraint","page":"JuMP","title":"AbstractConstraint","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.AbstractConstraint","category":"page"},{"location":"api/JuMP/#JuMP.AbstractConstraint","page":"JuMP","title":"JuMP.AbstractConstraint","text":"abstract type AbstractConstraint\n\nAn abstract base type for all constraint types. AbstractConstraints store the function and set directly, unlike ConstraintRefs that are merely references to constraints stored in a model. AbstractConstraints do not need to be attached to a model.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#AbstractJuMPScalar","page":"JuMP","title":"AbstractJuMPScalar","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.AbstractJuMPScalar","category":"page"},{"location":"api/JuMP/#JuMP.AbstractJuMPScalar","page":"JuMP","title":"JuMP.AbstractJuMPScalar","text":"AbstractJuMPScalar <: MutableArithmetics.AbstractMutable\n\nAbstract base type for all scalar types\n\nThe subtyping of AbstractMutable will allow calls of some Base functions to be redirected to a method in MA that handles type promotion more carefully (for example the promotion in sparse matrix products in SparseArrays usually does not work for JuMP types) and exploits the mutability of AffExpr and QuadExpr.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#AbstractModel","page":"JuMP","title":"AbstractModel","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.AbstractModel","category":"page"},{"location":"api/JuMP/#JuMP.AbstractModel","page":"JuMP","title":"JuMP.AbstractModel","text":"AbstractModel\n\nAn abstract type that should be subtyped for users creating JuMP extensions.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#AbstractScalarSet","page":"JuMP","title":"AbstractScalarSet","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.AbstractScalarSet","category":"page"},{"location":"api/JuMP/#JuMP.AbstractScalarSet","page":"JuMP","title":"JuMP.AbstractScalarSet","text":"AbstractScalarSet\n\nAn abstract type for defining new scalar sets in JuMP.\n\nImplement moi_set(::AbstractScalarSet) to convert the type into an MOI set.\n\nSee also: moi_set.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#AbstractShape","page":"JuMP","title":"AbstractShape","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.AbstractShape","category":"page"},{"location":"api/JuMP/#JuMP.AbstractShape","page":"JuMP","title":"JuMP.AbstractShape","text":"AbstractShape\n\nAbstract vectorizable shape. Given a flat vector form of an object of shape shape, the original object can be obtained by reshape_vector.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#AbstractVariable","page":"JuMP","title":"AbstractVariable","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.AbstractVariable","category":"page"},{"location":"api/JuMP/#JuMP.AbstractVariable","page":"JuMP","title":"JuMP.AbstractVariable","text":"AbstractVariable\n\nVariable returned by build_variable. It represents a variable that has not been added yet to any model. It can be added to a given model with add_variable.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#AbstractVariableRef","page":"JuMP","title":"AbstractVariableRef","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.AbstractVariableRef","category":"page"},{"location":"api/JuMP/#JuMP.AbstractVariableRef","page":"JuMP","title":"JuMP.AbstractVariableRef","text":"AbstractVariableRef\n\nVariable returned by add_variable. Affine (resp. quadratic) operations with variables of type V<:AbstractVariableRef and coefficients of type T     create a GenericAffExpr{T,V} (resp. GenericQuadExpr{T,V}).\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#AbstractVectorSet","page":"JuMP","title":"AbstractVectorSet","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.AbstractVectorSet","category":"page"},{"location":"api/JuMP/#JuMP.AbstractVectorSet","page":"JuMP","title":"JuMP.AbstractVectorSet","text":"AbstractVectorSet\n\nAn abstract type for defining new sets in JuMP.\n\nImplement moi_set(::AbstractVectorSet, dim::Int) to convert the type into an MOI set.\n\nSee also: moi_set.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#AffExpr","page":"JuMP","title":"AffExpr","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.AffExpr","category":"page"},{"location":"api/JuMP/#JuMP.AffExpr","page":"JuMP","title":"JuMP.AffExpr","text":"AffExpr\n\nAlias for GenericAffExpr{Float64,VariableRef}, the specific GenericAffExpr used by JuMP.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#BinaryRef","page":"JuMP","title":"BinaryRef","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.BinaryRef","category":"page"},{"location":"api/JuMP/#JuMP.BinaryRef","page":"JuMP","title":"JuMP.BinaryRef","text":"BinaryRef(v::GenericVariableRef)\n\nReturn a constraint reference to the constraint constraining v to be binary. Errors if one does not exist.\n\nSee also is_binary, set_binary, unset_binary.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x, Bin);\n\njulia> BinaryRef(x)\nx binary\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#BridgeableConstraint","page":"JuMP","title":"BridgeableConstraint","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.BridgeableConstraint","category":"page"},{"location":"api/JuMP/#JuMP.BridgeableConstraint","page":"JuMP","title":"JuMP.BridgeableConstraint","text":"BridgeableConstraint(\n    constraint::C,\n    bridge_type::B;\n    coefficient_type::Type{T} = Float64,\n) where {C<:AbstractConstraint,B<:Type{<:MOI.Bridges.AbstractBridge},T}\n\nAn AbstractConstraint representinng that constraint that can be bridged by the bridge of type bridge_type{coefficient_type}.\n\nAdding a BridgeableConstraint to a model is equivalent to:\n\nadd_bridge(model, bridge_type; coefficient_type = coefficient_type)\nadd_constraint(model, constraint)\n\nExample\n\nGiven a new scalar set type CustomSet with a bridge CustomBridge that can bridge F-in-CustomSet constraints, when the user does:\n\nmodel = Model()\n@variable(model, x)\n@constraint(model, x + 1 in CustomSet())\noptimize!(model)\n\nwith an optimizer that does not support F-in-CustomSet constraints, the constraint will not be bridged unless they first call add_bridge(model, CustomBridge).\n\nIn order to automatically add the CustomBridge to any model to which an F-in-CustomSet is added, add the following method:\n\nfunction JuMP.build_constraint(\n    error_fn::Function,\n    func::AbstractJuMPScalar,\n    set::CustomSet,\n)\n    constraint = ScalarConstraint(func, set)\n    return BridgeableConstraint(constraint, CustomBridge)\nend\n\nNote\n\nJuMP extensions should extend JuMP.build_constraint only if they also defined CustomSet, for three reasons:\n\nIt is problematic if multiple extensions overload the same JuMP method.\nA missing method will not inform the users that they forgot to load the extension module defining the build_constraint method.\nDefining a method where neither the function nor any of the argument types are defined in the package is called type piracy and is discouraged in the Julia style guide.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#ComplexPlane","page":"JuMP","title":"ComplexPlane","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.ComplexPlane","category":"page"},{"location":"api/JuMP/#JuMP.ComplexPlane","page":"JuMP","title":"JuMP.ComplexPlane","text":"ComplexPlane\n\nComplex plane object that can be used to create a complex variable in the @variable macro.\n\nExample\n\nConsider the following example:\n\njulia> model = Model();\n\njulia> @variable(model, x in ComplexPlane())\nreal(x) + imag(x) im\n\njulia> all_variables(model)\n2-element Vector{VariableRef}:\n real(x)\n imag(x)\n\nWe see in the output of the last command that two real variables were created. The Julia variable x binds to an affine expression in terms of these two variables that parametrize the complex plane.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#ComplexVariable","page":"JuMP","title":"ComplexVariable","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.ComplexVariable","category":"page"},{"location":"api/JuMP/#JuMP.ComplexVariable","page":"JuMP","title":"JuMP.ComplexVariable","text":"ComplexVariable{S,T,U,V} <: AbstractVariable\n\nA struct used when adding complex variables.\n\nSee also: ComplexPlane.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#ConstraintNotOwned","page":"JuMP","title":"ConstraintNotOwned","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.ConstraintNotOwned","category":"page"},{"location":"api/JuMP/#JuMP.ConstraintNotOwned","page":"JuMP","title":"JuMP.ConstraintNotOwned","text":"struct ConstraintNotOwned{C <: ConstraintRef} <: Exception\n    constraint_ref::C\nend\n\nThe constraint constraint_ref was used in a model different to owner_model(constraint_ref).\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#ConstraintRef","page":"JuMP","title":"ConstraintRef","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.ConstraintRef","category":"page"},{"location":"api/JuMP/#JuMP.ConstraintRef","page":"JuMP","title":"JuMP.ConstraintRef","text":"ConstraintRef\n\nHolds a reference to the model and the corresponding MOI.ConstraintIndex.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#FixRef","page":"JuMP","title":"FixRef","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.FixRef","category":"page"},{"location":"api/JuMP/#JuMP.FixRef","page":"JuMP","title":"JuMP.FixRef","text":"FixRef(v::GenericVariableRef)\n\nReturn a constraint reference to the constraint fixing the value of v.\n\nErrors if one does not exist.\n\nSee also is_fixed, fix_value, fix, unfix.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x == 1);\n\njulia> FixRef(x)\nx = 1\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#GenericAffExpr","page":"JuMP","title":"GenericAffExpr","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.GenericAffExpr","category":"page"},{"location":"api/JuMP/#JuMP.GenericAffExpr","page":"JuMP","title":"JuMP.GenericAffExpr","text":"mutable struct GenericAffExpr{CoefType,VarType} <: AbstractJuMPScalar\n    constant::CoefType\n    terms::OrderedDict{VarType,CoefType}\nend\n\nAn expression type representing an affine expression of the form: sum a_i x_i + c.\n\nFields\n\n.constant: the constant c in the expression.\n.terms: an OrderedDict, with keys of VarType and values of CoefType describing the sparse vector a.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#GenericModel","page":"JuMP","title":"GenericModel","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.GenericModel","category":"page"},{"location":"api/JuMP/#JuMP.GenericModel","page":"JuMP","title":"JuMP.GenericModel","text":"GenericModel{T}(\n    [optimizer_factory;]\n    add_bridges::Bool = true,\n) where {T<:Real}\n\nCreate a new instance of a JuMP model.\n\nIf optimizer_factory is provided, the model is initialized with the optimizer returned by MOI.instantiate(optimizer_factory).\n\nIf optimizer_factory is not provided, use set_optimizer to set the optimizer before calling optimize!.\n\nIf add_bridges, JuMP adds a MOI.Bridges.LazyBridgeOptimizer to automatically reformulate the problem into a form supported by the optimizer.\n\nValue type T\n\nPassing a type other than Float64 as the value type T is an advanced operation. The value type must match that expected by the chosen optimizer. Consult the optimizers documentation for details.\n\nIf not documented, assume that the optimizer supports only Float64.\n\nChoosing an unsupported value type will throw an MOI.UnsupportedConstraint or an MOI.UnsupportedAttribute error, the timing of which (during the model construction or during a call to optimize!) depends on how the solver is interfaced to JuMP.\n\nExample\n\njulia> model = GenericModel{BigFloat}();\n\njulia> typeof(model)\nGenericModel{BigFloat}\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#GenericNonlinearExpr","page":"JuMP","title":"GenericNonlinearExpr","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.GenericNonlinearExpr","category":"page"},{"location":"api/JuMP/#JuMP.GenericNonlinearExpr","page":"JuMP","title":"JuMP.GenericNonlinearExpr","text":"GenericNonlinearExpr{V}(head::Symbol, args::Vector{Any})\nGenericNonlinearExpr{V}(head::Symbol, args::Any...)\n\nThe scalar-valued nonlinear function head(args...), represented as a symbolic expression tree, with the call operator head and ordered arguments in args.\n\nV is the type of AbstractVariableRef present in the expression, and is used to help dispatch JuMP extensions.\n\nhead\n\nThe head::Symbol must be an operator supported by the model.\n\nThe default list of supported univariate operators is given by:\n\nMOI.Nonlinear.DEFAULT_UNIVARIATE_OPERATORS\n\nand the default list of supported multivariate operators is given by:\n\nMOI.Nonlinear.DEFAULT_MULTIVARIATE_OPERATORS\n\nAdditional operators can be add using @operator.\n\nSee the full list of operators supported by a MOI.ModelLike by querying the MOI.ListOfSupportedNonlinearOperators attribute.\n\nargs\n\nThe vector args contains the arguments to the nonlinear function. If the operator is univariate, it must contain one element. Otherwise, it may contain multiple elements.\n\nGiven a subtype of AbstractVariableRef, V, for GenericNonlinearExpr{V}, each element must be one of the following:\n\nA constant value of type <:Real\nA V\nA GenericAffExpr{T,V}\nA GenericQuadExpr{T,V}\nA GenericNonlinearExpr{V}\n\nwhere T<:Real and T == value_type(V).\n\nUnsupported operators\n\nIf the optimizer does not support head, an MOI.UnsupportedNonlinearOperator error will be thrown.\n\nThere is no guarantee about when this error will be thrown; it may be thrown when the function is first added to the model, or it may be thrown when optimize! is called.\n\nExample\n\nTo represent the function f(x) = sin(x)^2, do:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> f = sin(x)^2\nsin(x) ^ 2.0\n\njulia> f = GenericNonlinearExpr{VariableRef}(\n           :^,\n           GenericNonlinearExpr{VariableRef}(:sin, x),\n           2.0,\n       )\nsin(x) ^ 2.0\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#GenericQuadExpr","page":"JuMP","title":"GenericQuadExpr","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.GenericQuadExpr","category":"page"},{"location":"api/JuMP/#JuMP.GenericQuadExpr","page":"JuMP","title":"JuMP.GenericQuadExpr","text":"mutable struct GenericQuadExpr{CoefType,VarType} <: AbstractJuMPScalar\n    aff::GenericAffExpr{CoefType,VarType}\n    terms::OrderedDict{UnorderedPair{VarType}, CoefType}\nend\n\nAn expression type representing an quadratic expression of the form: sum q_ij x_i x_j + sum a_i x_i + c.\n\nFields\n\n.aff: an GenericAffExpr representing the affine portion of the expression.\n.terms: an OrderedDict, with keys of UnorderedPair{VarType} and values of CoefType, describing the sparse list of terms q.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#GenericReferenceMap","page":"JuMP","title":"GenericReferenceMap","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.GenericReferenceMap","category":"page"},{"location":"api/JuMP/#JuMP.GenericReferenceMap","page":"JuMP","title":"JuMP.GenericReferenceMap","text":"GenericReferenceMap{T}\n\nMapping between variable and constraint reference of a model and its copy. The reference of the copied model can be obtained by indexing the map with the reference of the corresponding reference of the original model.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#GenericVariableRef","page":"JuMP","title":"GenericVariableRef","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.GenericVariableRef","category":"page"},{"location":"api/JuMP/#JuMP.GenericVariableRef","page":"JuMP","title":"JuMP.GenericVariableRef","text":"GenericVariableRef{T} <: AbstractVariableRef\n\nHolds a reference to the model and the corresponding MOI.VariableIndex.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#HermitianMatrixShape","page":"JuMP","title":"HermitianMatrixShape","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.HermitianMatrixShape","category":"page"},{"location":"api/JuMP/#JuMP.HermitianMatrixShape","page":"JuMP","title":"JuMP.HermitianMatrixShape","text":"HermitianMatrixShape\n\nShape object for a Hermitian square matrix of side_dimension rows and columns. The vectorized form corresponds to MOI.HermitianPositiveSemidefiniteConeTriangle.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#HermitianMatrixSpace","page":"JuMP","title":"HermitianMatrixSpace","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.HermitianMatrixSpace","category":"page"},{"location":"api/JuMP/#JuMP.HermitianMatrixSpace","page":"JuMP","title":"JuMP.HermitianMatrixSpace","text":"HermitianMatrixSpace()\n\nUse in the @variable macro to constrain a matrix of variables to be hermitian.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, Q[1:2, 1:2] in HermitianMatrixSpace())\n2×2 LinearAlgebra.Hermitian{GenericAffExpr{ComplexF64, VariableRef}, Matrix{GenericAffExpr{ComplexF64, VariableRef}}}:\n real(Q[1,1])                    real(Q[1,2]) + imag(Q[1,2]) im\n real(Q[1,2]) - imag(Q[1,2]) im  real(Q[2,2])\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#HermitianPSDCone","page":"JuMP","title":"HermitianPSDCone","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.HermitianPSDCone","category":"page"},{"location":"api/JuMP/#JuMP.HermitianPSDCone","page":"JuMP","title":"JuMP.HermitianPSDCone","text":"HermitianPSDCone\n\nHermitian positive semidefinite cone object that can be used to create a Hermitian positive semidefinite square matrix in the @variable and @constraint macros.\n\nExample\n\nConsider the following example:\n\njulia> model = Model();\n\njulia> @variable(model, H[1:3, 1:3] in HermitianPSDCone())\n3×3 LinearAlgebra.Hermitian{GenericAffExpr{ComplexF64, VariableRef}, Matrix{GenericAffExpr{ComplexF64, VariableRef}}}:\n real(H[1,1])                    …  real(H[1,3]) + imag(H[1,3]) im\n real(H[1,2]) - imag(H[1,2]) im     real(H[2,3]) + imag(H[2,3]) im\n real(H[1,3]) - imag(H[1,3]) im     real(H[3,3])\n\njulia> all_variables(model)\n9-element Vector{VariableRef}:\n real(H[1,1])\n real(H[1,2])\n real(H[2,2])\n real(H[1,3])\n real(H[2,3])\n real(H[3,3])\n imag(H[1,2])\n imag(H[1,3])\n imag(H[2,3])\n\njulia> all_constraints(model, Vector{VariableRef}, MOI.HermitianPositiveSemidefiniteConeTriangle)\n1-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.HermitianPositiveSemidefiniteConeTriangle}}}:\n [real(H[1,1]), real(H[1,2]), real(H[2,2]), real(H[1,3]), real(H[2,3]), real(H[3,3]), imag(H[1,2]), imag(H[1,3]), imag(H[2,3])] ∈ MathOptInterface.HermitianPositiveSemidefiniteConeTriangle(3)\n\nWe see in the output of the last commands that 9 real variables were created. The matrix H constrains affine expressions in terms of these 9 variables that parametrize a Hermitian matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#IntegerRef","page":"JuMP","title":"IntegerRef","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.IntegerRef","category":"page"},{"location":"api/JuMP/#JuMP.IntegerRef","page":"JuMP","title":"JuMP.IntegerRef","text":"IntegerRef(v::GenericVariableRef)\n\nReturn a constraint reference to the constraint constraining v to be integer.\n\nErrors if one does not exist.\n\nSee also is_integer, set_integer, unset_integer.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x, Int);\n\njulia> IntegerRef(x)\nx integer\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#LPMatrixData","page":"JuMP","title":"LPMatrixData","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.LPMatrixData","category":"page"},{"location":"api/JuMP/#JuMP.LPMatrixData","page":"JuMP","title":"JuMP.LPMatrixData","text":"LPMatrixData{T}\n\nThe struct returned by lp_matrix_data. See lp_matrix_data for a description of the public fields.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#LinearTermIterator","page":"JuMP","title":"LinearTermIterator","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.LinearTermIterator","category":"page"},{"location":"api/JuMP/#JuMP.LinearTermIterator","page":"JuMP","title":"JuMP.LinearTermIterator","text":"LinearTermIterator{GAE<:GenericAffExpr}\n\nA struct that implements the iterate protocol in order to iterate over tuples of (coefficient, variable) in the GenericAffExpr.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#LowerBoundRef","page":"JuMP","title":"LowerBoundRef","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.LowerBoundRef","category":"page"},{"location":"api/JuMP/#JuMP.LowerBoundRef","page":"JuMP","title":"JuMP.LowerBoundRef","text":"LowerBoundRef(v::GenericVariableRef)\n\nReturn a constraint reference to the lower bound constraint of v.\n\nErrors if one does not exist.\n\nSee also has_lower_bound, lower_bound, set_lower_bound, delete_lower_bound.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 1.0);\n\njulia> LowerBoundRef(x)\nx ≥ 1\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#Model","page":"JuMP","title":"Model","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.Model","category":"page"},{"location":"api/JuMP/#JuMP.Model","page":"JuMP","title":"JuMP.Model","text":"Model([optimizer_factory;] add_bridges::Bool = true)\n\nCreate a new instance of a JuMP model.\n\nIf optimizer_factory is provided, the model is initialized with thhe optimizer returned by MOI.instantiate(optimizer_factory).\n\nIf optimizer_factory is not provided, use set_optimizer to set the optimizer before calling optimize!.\n\nIf add_bridges, JuMP adds a MOI.Bridges.LazyBridgeOptimizer to automatically reformulate the problem into a form supported by the optimizer.\n\nExample\n\njulia> import Ipopt\n\njulia> model = Model(Ipopt.Optimizer);\n\njulia> solver_name(model)\n\"Ipopt\"\n\njulia> import HiGHS\n\njulia> import MultiObjectiveAlgorithms as MOA\n\njulia> model = Model(() -> MOA.Optimizer(HiGHS.Optimizer); add_bridges = false);\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#ModelMode","page":"JuMP","title":"ModelMode","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.ModelMode","category":"page"},{"location":"api/JuMP/#JuMP.ModelMode","page":"JuMP","title":"JuMP.ModelMode","text":"ModelMode\n\nAn enum to describe the state of the CachingOptimizer inside a JuMP model.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#NLPEvaluator","page":"JuMP","title":"NLPEvaluator","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.NLPEvaluator","category":"page"},{"location":"api/JuMP/#JuMP.NLPEvaluator","page":"JuMP","title":"JuMP.NLPEvaluator","text":"NLPEvaluator(\n    model::Model,\n    _differentiation_backend::MOI.Nonlinear.AbstractAutomaticDifferentiation =\n        MOI.Nonlinear.SparseReverseMode(),\n)\n\nReturn an MOI.AbstractNLPEvaluator constructed from model\n\nwarning: Warning\nBefore using, you must initialize the evaluator using MOI.initialize.\n\nExperimental\n\nThese features may change or be removed in any future version of JuMP.\n\nPass _differentiation_backend to specify the differentiation backend used to compute derivatives.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#NoOptimizer","page":"JuMP","title":"NoOptimizer","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.NoOptimizer","category":"page"},{"location":"api/JuMP/#JuMP.NoOptimizer","page":"JuMP","title":"JuMP.NoOptimizer","text":"struct NoOptimizer <: Exception end\n\nNo optimizer is set. The optimizer can be provided to the Model constructor or by calling set_optimizer.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#NonlinearExpr","page":"JuMP","title":"NonlinearExpr","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.NonlinearExpr","category":"page"},{"location":"api/JuMP/#JuMP.NonlinearExpr","page":"JuMP","title":"JuMP.NonlinearExpr","text":"NonlinearExpr\n\nAlias for GenericNonlinearExpr{VariableRef}, the specific GenericNonlinearExpr used by JuMP.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#NonlinearOperator","page":"JuMP","title":"NonlinearOperator","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.NonlinearOperator","category":"page"},{"location":"api/JuMP/#JuMP.NonlinearOperator","page":"JuMP","title":"JuMP.NonlinearOperator","text":"NonlinearOperator(func::Function, head::Symbol)\n\nA callable struct (functor) representing a function named head.\n\nWhen called with AbstractJuMPScalars, the struct returns a GenericNonlinearExpr.\n\nWhen called with non-JuMP types, the struct returns the evaluation of func(args...).\n\nUnless head is special-cased by the optimizer, the operator must have already been added to the model using add_nonlinear_operator or @operator.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> f(x::Float64) = x^2\nf (generic function with 1 method)\n\njulia> ∇f(x::Float64) = 2 * x\n∇f (generic function with 1 method)\n\njulia> ∇²f(x::Float64) = 2.0\n∇²f (generic function with 1 method)\n\njulia> @operator(model, op_f, 1, f, ∇f, ∇²f)\nNonlinearOperator(f, :op_f)\n\njulia> bar = NonlinearOperator(f, :op_f)\nNonlinearOperator(f, :op_f)\n\njulia> @objective(model, Min, bar(x))\nop_f(x)\n\njulia> bar(2.0)\n4.0\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#Nonnegatives","page":"JuMP","title":"Nonnegatives","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.Nonnegatives","category":"page"},{"location":"api/JuMP/#JuMP.Nonnegatives","page":"JuMP","title":"JuMP.Nonnegatives","text":"Nonnegatives()\n\nThe JuMP equivalent of the MOI.Nonnegatives set, in which the dimension is inferred from the corresponding function.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x[1:2])\n2-element Vector{VariableRef}:\n x[1]\n x[2]\n\njulia> @constraint(model, x in Nonnegatives())\n[x[1], x[2]] ∈ MathOptInterface.Nonnegatives(2)\n\njulia> A = [1 2; 3 4];\n\njulia> b = [5, 6];\n\njulia> @constraint(model, A * x >= b)\n[x[1] + 2 x[2] - 5, 3 x[1] + 4 x[2] - 6] ∈ MathOptInterface.Nonnegatives(2)\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#Nonpositives","page":"JuMP","title":"Nonpositives","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.Nonpositives","category":"page"},{"location":"api/JuMP/#JuMP.Nonpositives","page":"JuMP","title":"JuMP.Nonpositives","text":"Nonpositives()\n\nThe JuMP equivalent of the MOI.Nonpositives set, in which the dimension is inferred from the corresponding function.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x[1:2])\n2-element Vector{VariableRef}:\n x[1]\n x[2]\n\njulia> @constraint(model, x in Nonpositives())\n[x[1], x[2]] ∈ MathOptInterface.Nonpositives(2)\n\njulia> A = [1 2; 3 4];\n\njulia> b = [5, 6];\n\njulia> @constraint(model, A * x <= b)\n[x[1] + 2 x[2] - 5, 3 x[1] + 4 x[2] - 6] ∈ MathOptInterface.Nonpositives(2)\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#OptimizationSense","page":"JuMP","title":"OptimizationSense","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.OptimizationSense","category":"page"},{"location":"api/JuMP/#JuMP.OptimizationSense","page":"JuMP","title":"JuMP.OptimizationSense","text":"OptimizationSense\n\nAn enum for the value of the ObjectiveSense attribute.\n\nValues\n\nPossible values are:\n\nMIN_SENSE: the goal is to minimize the objective function\nMAX_SENSE: the goal is to maximize the objective function\nFEASIBILITY_SENSE: the model does not have an objective function\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#OptimizeNotCalled","page":"JuMP","title":"OptimizeNotCalled","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.OptimizeNotCalled","category":"page"},{"location":"api/JuMP/#JuMP.OptimizeNotCalled","page":"JuMP","title":"JuMP.OptimizeNotCalled","text":"struct OptimizeNotCalled <: Exception end\n\nA result attribute cannot be queried before optimize! is called.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#PSDCone","page":"JuMP","title":"PSDCone","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.PSDCone","category":"page"},{"location":"api/JuMP/#JuMP.PSDCone","page":"JuMP","title":"JuMP.PSDCone","text":"PSDCone\n\nPositive semidefinite cone object that can be used to constrain a square matrix to be positive semidefinite in the @constraint macro. If the matrix has type Symmetric then the columns vectorization (the vector obtained by concatenating the columns) of its upper triangular part is constrained to belong to the MOI.PositiveSemidefiniteConeTriangle set, otherwise its column vectorization is constrained to belong to the MOI.PositiveSemidefiniteConeSquare set.\n\nExample\n\nConsider the following example:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> a = [ x 2x\n            2x  x];\n\njulia> b = [1 2\n            2 4];\n\njulia> cref = @constraint(model, a >= b, PSDCone())\n[x - 1    2 x - 2;\n 2 x - 2  x - 4] ∈ PSDCone()\n\njulia> jump_function(constraint_object(cref))\n4-element Vector{AffExpr}:\n x - 1\n 2 x - 2\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeSquare(2)\n\nWe see in the output of the last command that the vectorization of the matrix is constrained to belong to the PositiveSemidefiniteConeSquare.\n\njulia> using LinearAlgebra # For Symmetric\n\njulia> cref = @constraint(model, Symmetric(a - b) in PSDCone())\n[x - 1    2 x - 2;\n 2 x - 2  x - 4] ∈ PSDCone()\n\njulia> jump_function(constraint_object(cref))\n3-element Vector{AffExpr}:\n x - 1\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeTriangle(2)\n\nAs we see in the output of the last command, the vectorization of only the upper triangular part of the matrix is constrained to belong to the PositiveSemidefiniteConeSquare.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#Parameter","page":"JuMP","title":"Parameter","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.Parameter","category":"page"},{"location":"api/JuMP/#JuMP.Parameter","page":"JuMP","title":"JuMP.Parameter","text":"Parameter(value)\n\nA short-cut for the MOI.Parameter set.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x in Parameter(2))\nx\n\njulia> print(model)\nFeasibility\nSubject to\n x ∈ MathOptInterface.Parameter{Float64}(2.0)\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#ParameterRef","page":"JuMP","title":"ParameterRef","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.ParameterRef","category":"page"},{"location":"api/JuMP/#JuMP.ParameterRef","page":"JuMP","title":"JuMP.ParameterRef","text":"ParameterRef(x::GenericVariableRef)\n\nReturn a constraint reference to the constraint constraining x to be a parameter.\n\nErrors if one does not exist.\n\nSee also is_parameter, set_parameter_value, parameter_value.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, p in Parameter(2))\np\n\njulia> ParameterRef(p)\np ∈ MathOptInterface.Parameter{Float64}(2.0)\n\njulia> @variable(model, x);\n\njulia> ParameterRef(x)\nERROR: Variable x is not a parameter.\nStacktrace:\n[...]\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#QuadExpr","page":"JuMP","title":"QuadExpr","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.QuadExpr","category":"page"},{"location":"api/JuMP/#JuMP.QuadExpr","page":"JuMP","title":"JuMP.QuadExpr","text":"QuadExpr\n\nAn alias for GenericQuadExpr{Float64,VariableRef}, the specific GenericQuadExpr used by JuMP.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#QuadTermIterator","page":"JuMP","title":"QuadTermIterator","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.QuadTermIterator","category":"page"},{"location":"api/JuMP/#JuMP.QuadTermIterator","page":"JuMP","title":"JuMP.QuadTermIterator","text":"QuadTermIterator{GQE<:GenericQuadExpr}\n\nA struct that implements the iterate protocol in order to iterate over tuples of (coefficient, variable, variable) in the GenericQuadExpr.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#ReferenceMap","page":"JuMP","title":"ReferenceMap","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.ReferenceMap","category":"page"},{"location":"api/JuMP/#JuMP.ReferenceMap","page":"JuMP","title":"JuMP.ReferenceMap","text":"GenericReferenceMap{T}\n\nMapping between variable and constraint reference of a model and its copy. The reference of the copied model can be obtained by indexing the map with the reference of the corresponding reference of the original model.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#ResultStatusCode","page":"JuMP","title":"ResultStatusCode","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.ResultStatusCode","category":"page"},{"location":"api/JuMP/#JuMP.ResultStatusCode","page":"JuMP","title":"JuMP.ResultStatusCode","text":"ResultStatusCode\n\nAn Enum of possible values for the PrimalStatus and DualStatus attributes.\n\nThe values indicate how to interpret the result vector.\n\nValues\n\nPossible values are:\n\nNO_SOLUTION: the result vector is empty.\nFEASIBLE_POINT: the result vector is a feasible point.\nNEARLY_FEASIBLE_POINT: the result vector is feasible if some constraint tolerances are relaxed.\nINFEASIBLE_POINT: the result vector is an infeasible point.\nINFEASIBILITY_CERTIFICATE: the result vector is an infeasibility certificate. If the PrimalStatus is INFEASIBILITY_CERTIFICATE, then the primal result vector is a certificate of dual infeasibility. If the DualStatus is INFEASIBILITY_CERTIFICATE, then the dual result vector is a proof of primal infeasibility.\nNEARLY_INFEASIBILITY_CERTIFICATE: the result satisfies a relaxed criterion for a certificate of infeasibility.\nREDUCTION_CERTIFICATE: the result vector is an ill-posed certificate; see this article for details. If the PrimalStatus is REDUCTION_CERTIFICATE, then the primal result vector is a proof that the dual problem is ill-posed. If the DualStatus is REDUCTION_CERTIFICATE, then the dual result vector is a proof that the primal is ill-posed.\nNEARLY_REDUCTION_CERTIFICATE: the result satisfies a relaxed criterion for an ill-posed certificate.\nUNKNOWN_RESULT_STATUS: the result vector contains a solution with an unknown interpretation.\nOTHER_RESULT_STATUS: the result vector contains a solution with an interpretation not covered by one of the statuses defined above\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#RotatedSecondOrderCone","page":"JuMP","title":"RotatedSecondOrderCone","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.RotatedSecondOrderCone","category":"page"},{"location":"api/JuMP/#JuMP.RotatedSecondOrderCone","page":"JuMP","title":"JuMP.RotatedSecondOrderCone","text":"RotatedSecondOrderCone\n\nRotated second order cone object that can be used to constrain the square of the euclidean norm of a vector x to be less than or equal to 2tu where t and u are nonnegative scalars. This is a shortcut for the MOI.RotatedSecondOrderCone.\n\nExample\n\nThe following constrains (x-1 x-2)^2_2 le 2tx and t x ge 0:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, t)\nt\n\njulia> @constraint(model, [t, x, x-1, x-2] in RotatedSecondOrderCone())\n[t, x, x - 1, x - 2] ∈ MathOptInterface.RotatedSecondOrderCone(4)\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#SOS1","page":"JuMP","title":"SOS1","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.SOS1","category":"page"},{"location":"api/JuMP/#JuMP.SOS1","page":"JuMP","title":"JuMP.SOS1","text":"SOS1(weights = Real[])\n\nThe SOS1 (Special Ordered Set of Type 1) set constrains a vector x to the set where at most one variable can take a non-zero value, and all other elements are zero.\n\nThe weights vector, if specified, induces an ordering of the variables; as such, it should contain unique values. The weights vector must have the same number of elements as the vector x, and the element weights[i] corresponds to element x[i]. If not provided, the weights vector defaults to weights[i] = i.\n\nThis is a shortcut for the MOI.SOS1 set.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#SOS2","page":"JuMP","title":"SOS2","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.SOS2","category":"page"},{"location":"api/JuMP/#JuMP.SOS2","page":"JuMP","title":"JuMP.SOS2","text":"SOS2(weights = Real[])\n\nThe SOS2 (Special Ordered Set of Type 2) set constrains a vector x to the set where at most two variables can take a non-zero value, and all other elements are zero. In addition, the two non-zero values must be consecutive given the ordering of the x vector induced by weights.\n\nThe weights vector, if specified, induces an ordering of the variables; as such, it must contain unique values. The weights vector must have the same number of elements as the vector x, and the element weights[i] corresponds to element x[i]. If not provided, the weights vector defaults to weights[i] = i.\n\nThis is a shortcut for the MOI.SOS2 set.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#ScalarConstraint","page":"JuMP","title":"ScalarConstraint","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.ScalarConstraint","category":"page"},{"location":"api/JuMP/#JuMP.ScalarConstraint","page":"JuMP","title":"JuMP.ScalarConstraint","text":"struct ScalarConstraint\n\nThe data for a scalar constraint. The func field contains a JuMP object representing the function and the set field contains the MOI set. See also the documentation on JuMP's representation of constraints for more background.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#ScalarShape","page":"JuMP","title":"ScalarShape","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.ScalarShape","category":"page"},{"location":"api/JuMP/#JuMP.ScalarShape","page":"JuMP","title":"JuMP.ScalarShape","text":"ScalarShape\n\nShape of scalar constraints.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#ScalarVariable","page":"JuMP","title":"ScalarVariable","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.ScalarVariable","category":"page"},{"location":"api/JuMP/#JuMP.ScalarVariable","page":"JuMP","title":"JuMP.ScalarVariable","text":"ScalarVariable{S,T,U,V} <: AbstractVariable\n\nA struct used when adding variables.\n\nSee also: add_variable.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#SecondOrderCone","page":"JuMP","title":"SecondOrderCone","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.SecondOrderCone","category":"page"},{"location":"api/JuMP/#JuMP.SecondOrderCone","page":"JuMP","title":"JuMP.SecondOrderCone","text":"SecondOrderCone\n\nSecond order cone object that can be used to constrain the euclidean norm of a vector x to be less than or equal to a nonnegative scalar t. This is a shortcut for the MOI.SecondOrderCone.\n\nExample\n\nThe following constrains (x-1 x-2)_2 le t and t ge 0:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, t)\nt\n\njulia> @constraint(model, [t, x-1, x-2] in SecondOrderCone())\n[t, x - 1, x - 2] ∈ MathOptInterface.SecondOrderCone(3)\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#Semicontinuous","page":"JuMP","title":"Semicontinuous","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.Semicontinuous","category":"page"},{"location":"api/JuMP/#JuMP.Semicontinuous","page":"JuMP","title":"JuMP.Semicontinuous","text":"Semicontinuous(lower, upper)\n\nA short-cut for the MOI.Semicontinuous set.\n\nThis short-cut is useful because it automatically promotes lower and upper to the same type, and converts them into the element type supported by the JuMP model.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x in Semicontinuous(1, 2))\nx\n\njulia> print(model)\nFeasibility\nSubject to\n x ∈ MathOptInterface.Semicontinuous{Int64}(1, 2)\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#Semiinteger","page":"JuMP","title":"Semiinteger","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.Semiinteger","category":"page"},{"location":"api/JuMP/#JuMP.Semiinteger","page":"JuMP","title":"JuMP.Semiinteger","text":"Semiinteger(lower, upper)\n\nA short-cut for the MOI.Semiinteger set.\n\nThis short-cut is useful because it automatically promotes lower and upper to the same type, and converts them into the element type supported by the JuMP model.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x in Semiinteger(3, 5))\nx\n\njulia> print(model)\nFeasibility\nSubject to\n x ∈ MathOptInterface.Semiinteger{Int64}(3, 5)\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#SensitivityReport","page":"JuMP","title":"SensitivityReport","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.SensitivityReport","category":"page"},{"location":"api/JuMP/#JuMP.SensitivityReport","page":"JuMP","title":"JuMP.SensitivityReport","text":"SensitivityReport\n\nSee lp_sensitivity_report.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#SkewSymmetricMatrixShape","page":"JuMP","title":"SkewSymmetricMatrixShape","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.SkewSymmetricMatrixShape","category":"page"},{"location":"api/JuMP/#JuMP.SkewSymmetricMatrixShape","page":"JuMP","title":"JuMP.SkewSymmetricMatrixShape","text":"SkewSymmetricMatrixShape\n\nShape object for a skew symmetric square matrix of side_dimension rows and columns. The vectorized form contains the entries of the upper-right triangular part of the matrix (without the diagonal) given column by column (or equivalently, the entries of the lower-left triangular part given row by row). The diagonal is zero.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#SkewSymmetricMatrixSpace","page":"JuMP","title":"SkewSymmetricMatrixSpace","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.SkewSymmetricMatrixSpace","category":"page"},{"location":"api/JuMP/#JuMP.SkewSymmetricMatrixSpace","page":"JuMP","title":"JuMP.SkewSymmetricMatrixSpace","text":"SkewSymmetricMatrixSpace()\n\nUse in the @variable macro to constrain a matrix of variables to be skew-symmetric.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, Q[1:2, 1:2] in SkewSymmetricMatrixSpace())\n2×2 Matrix{AffExpr}:\n 0        Q[1,2]\n -Q[1,2]  0\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#SkipModelConvertScalarSetWrapper","page":"JuMP","title":"SkipModelConvertScalarSetWrapper","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.SkipModelConvertScalarSetWrapper","category":"page"},{"location":"api/JuMP/#JuMP.SkipModelConvertScalarSetWrapper","page":"JuMP","title":"JuMP.SkipModelConvertScalarSetWrapper","text":"SkipModelConvertScalarSetWrapper(set::MOI.AbstractScalarSet)\n\nJuMP uses model_convert to automatically promote MOI.AbstractScalarSet sets to the same value_type as the model.\n\nIn cases there this is undesirable, wrap the set in SkipModelConvertScalarSetWrapper to pass the set un-changed to the solver.\n\nwarning: Warning\nThis struct is intended for use internally by JuMP extensions. You should not need to use it in regular JuMP code.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @constraint(model, x in MOI.EqualTo(1 // 2))\nx = 0.5\n\njulia> @constraint(model, x in SkipModelConvertScalarSetWrapper(MOI.EqualTo(1 // 2)))\nx = 1//2\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#SquareMatrixShape","page":"JuMP","title":"SquareMatrixShape","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.SquareMatrixShape","category":"page"},{"location":"api/JuMP/#JuMP.SquareMatrixShape","page":"JuMP","title":"JuMP.SquareMatrixShape","text":"SquareMatrixShape\n\nShape object for a square matrix of side_dimension rows and columns. The vectorized form contains the entries of the matrix given column by column (or equivalently, the entries of the lower-left triangular part given row by row).\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#SymmetricMatrixShape","page":"JuMP","title":"SymmetricMatrixShape","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.SymmetricMatrixShape","category":"page"},{"location":"api/JuMP/#JuMP.SymmetricMatrixShape","page":"JuMP","title":"JuMP.SymmetricMatrixShape","text":"SymmetricMatrixShape\n\nShape object for a symmetric square matrix of side_dimension rows and columns. The vectorized form contains the entries of the upper-right triangular part of the matrix given column by column (or equivalently, the entries of the lower-left triangular part given row by row).\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#SymmetricMatrixSpace","page":"JuMP","title":"SymmetricMatrixSpace","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.SymmetricMatrixSpace","category":"page"},{"location":"api/JuMP/#JuMP.SymmetricMatrixSpace","page":"JuMP","title":"JuMP.SymmetricMatrixSpace","text":"SymmetricMatrixSpace()\n\nUse in the @variable macro to constrain a matrix of variables to be symmetric.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, Q[1:2, 1:2] in SymmetricMatrixSpace())\n2×2 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:\n Q[1,1]  Q[1,2]\n Q[1,2]  Q[2,2]\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#TerminationStatusCode","page":"JuMP","title":"TerminationStatusCode","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.TerminationStatusCode","category":"page"},{"location":"api/JuMP/#JuMP.TerminationStatusCode","page":"JuMP","title":"JuMP.TerminationStatusCode","text":"TerminationStatusCode\n\nAn Enum of possible values for the TerminationStatus attribute. This attribute is meant to explain the reason why the optimizer stopped executing in the most recent call to optimize!.\n\nValues\n\nPossible values are:\n\nOPTIMIZE_NOT_CALLED: The algorithm has not started.\nOPTIMAL: The algorithm found a globally optimal solution.\nINFEASIBLE: The algorithm concluded that no feasible solution exists.\nDUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem. If, additionally, a feasible (primal) solution is known to exist, this status typically implies that the problem is unbounded, with some technical exceptions.\nLOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.\nLOCALLY_INFEASIBLE: The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.\nINFEASIBLE_OR_UNBOUNDED: The algorithm stopped because it decided that the problem is infeasible or unbounded; this occasionally happens during MIP presolve.\nALMOST_OPTIMAL: The algorithm found a globally optimal solution to relaxed tolerances.\nALMOST_INFEASIBLE: The algorithm concluded that no feasible solution exists within relaxed tolerances.\nALMOST_DUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.\nALMOST_LOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.\nITERATION_LIMIT: An iterative algorithm stopped after conducting the maximum number of iterations.\nTIME_LIMIT: The algorithm stopped after a user-specified computation time.\nNODE_LIMIT: A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.\nSOLUTION_LIMIT: The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.\nMEMORY_LIMIT: The algorithm stopped because it ran out of memory.\nOBJECTIVE_LIMIT: The algorithm stopped because it found a solution better than a minimum limit set by the user.\nNORM_LIMIT: The algorithm stopped because the norm of an iterate became too large.\nOTHER_LIMIT: The algorithm stopped due to a limit not covered by one of the _LIMIT_ statuses above.\nSLOW_PROGRESS: The algorithm stopped because it was unable to continue making progress towards the solution.\nNUMERICAL_ERROR: The algorithm stopped because it encountered unrecoverable numerical error.\nINVALID_MODEL: The algorithm stopped because the model is invalid.\nINVALID_OPTION: The algorithm stopped because it was provided an invalid option.\nINTERRUPTED: The algorithm stopped because of an interrupt signal.\nOTHER_ERROR: The algorithm stopped because of an error not covered by one of the statuses defined above.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#UnorderedPair","page":"JuMP","title":"UnorderedPair","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.UnorderedPair","category":"page"},{"location":"api/JuMP/#JuMP.UnorderedPair","page":"JuMP","title":"JuMP.UnorderedPair","text":"UnorderedPair(a::T, b::T)\n\nA wrapper type used by GenericQuadExpr with fields .a and .b.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#UpperBoundRef","page":"JuMP","title":"UpperBoundRef","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.UpperBoundRef","category":"page"},{"location":"api/JuMP/#JuMP.UpperBoundRef","page":"JuMP","title":"JuMP.UpperBoundRef","text":"UpperBoundRef(v::GenericVariableRef)\n\nReturn a constraint reference to the upper bound constraint of v.\n\nErrors if one does not exist.\n\nSee also has_upper_bound, upper_bound, set_upper_bound, delete_upper_bound.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x <= 1.0);\n\njulia> UpperBoundRef(x)\nx ≤ 1\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#VariableConstrainedOnCreation","page":"JuMP","title":"VariableConstrainedOnCreation","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.VariableConstrainedOnCreation","category":"page"},{"location":"api/JuMP/#JuMP.VariableConstrainedOnCreation","page":"JuMP","title":"JuMP.VariableConstrainedOnCreation","text":"VariableConstrainedOnCreation <: AbstractVariable\n\nVariable scalar_variables constrained to belong to set.\n\nAdding this variable can be understood as doing:\n\nfunction JuMP.add_variable(\n    model::GenericModel,\n    variable::VariableConstrainedOnCreation,\n    names,\n)\n    var_ref = add_variable(model, variable.scalar_variable, name)\n    add_constraint(model, VectorConstraint(var_ref, variable.set))\n    return var_ref\nend\n\nbut adds the variables with MOI.add_constrained_variable(model, variable.set) instead. See the MOI documentation for the difference between adding the variables with MOI.add_constrained_variable and adding them with MOI.add_variable and adding the constraint separately.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#VariableInfo","page":"JuMP","title":"VariableInfo","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.VariableInfo","category":"page"},{"location":"api/JuMP/#JuMP.VariableInfo","page":"JuMP","title":"JuMP.VariableInfo","text":"VariableInfo{S,T,U,V}\n\nA struct by JuMP internally when creating variables. This may also be used by JuMP extensions to create new types of variables.\n\nSee also: ScalarVariable.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#VariableNotOwned","page":"JuMP","title":"VariableNotOwned","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.VariableNotOwned","category":"page"},{"location":"api/JuMP/#JuMP.VariableNotOwned","page":"JuMP","title":"JuMP.VariableNotOwned","text":"struct VariableNotOwned{V<:AbstractVariableRef} <: Exception\n    variable::V\nend\n\nThe variable variable was used in a model different to owner_model(variable).\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#VariableRef","page":"JuMP","title":"VariableRef","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.VariableRef","category":"page"},{"location":"api/JuMP/#JuMP.VariableRef","page":"JuMP","title":"JuMP.VariableRef","text":"GenericVariableRef{T} <: AbstractVariableRef\n\nHolds a reference to the model and the corresponding MOI.VariableIndex.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#VariablesConstrainedOnCreation","page":"JuMP","title":"VariablesConstrainedOnCreation","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.VariablesConstrainedOnCreation","category":"page"},{"location":"api/JuMP/#JuMP.VariablesConstrainedOnCreation","page":"JuMP","title":"JuMP.VariablesConstrainedOnCreation","text":"VariablesConstrainedOnCreation <: AbstractVariable\n\nVector of variables scalar_variables constrained to belong to set. Adding this variable can be thought as doing:\n\nfunction JuMP.add_variable(\n    model::GenericModel,\n    variable::VariablesConstrainedOnCreation,\n    names,\n)\n    v_names = vectorize(names, variable.shape)\n    var_refs = add_variable.(model, variable.scalar_variables, v_names)\n    add_constraint(model, VectorConstraint(var_refs, variable.set))\n    return reshape_vector(var_refs, variable.shape)\nend\n\nbut adds the variables with MOI.add_constrained_variables(model, variable.set) instead. See the MOI documentation for the difference between adding the variables with MOI.add_constrained_variables and adding them with MOI.add_variables and adding the constraint separately.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#VectorConstraint","page":"JuMP","title":"VectorConstraint","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.VectorConstraint","category":"page"},{"location":"api/JuMP/#JuMP.VectorConstraint","page":"JuMP","title":"JuMP.VectorConstraint","text":"struct VectorConstraint\n\nThe data for a vector constraint. The func field contains a JuMP object representing the function and the set field contains the MOI set. The shape field contains an AbstractShape matching the form in which the constraint was constructed (for example, by using matrices or flat vectors). See also the documentation on JuMP's representation of constraints.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#VectorShape","page":"JuMP","title":"VectorShape","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.VectorShape","category":"page"},{"location":"api/JuMP/#JuMP.VectorShape","page":"JuMP","title":"JuMP.VectorShape","text":"VectorShape\n\nVector for which the vectorized form corresponds exactly to the vector given.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#Zeros","page":"JuMP","title":"Zeros","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.Zeros","category":"page"},{"location":"api/JuMP/#JuMP.Zeros","page":"JuMP","title":"JuMP.Zeros","text":"Zeros()\n\nThe JuMP equivalent of the MOI.Zeros set, in which the dimension is inferred from the corresponding function.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x[1:2])\n2-element Vector{VariableRef}:\n x[1]\n x[2]\n\njulia> @constraint(model, x in Zeros())\n[x[1], x[2]] ∈ MathOptInterface.Zeros(2)\n\njulia> A = [1 2; 3 4];\n\njulia> b = [5, 6];\n\njulia> @constraint(model, A * x == b)\n[x[1] + 2 x[2] - 5, 3 x[1] + 4 x[2] - 6] ∈ MathOptInterface.Zeros(2)\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#ALMOST_DUAL_INFEASIBLE","page":"JuMP","title":"ALMOST_DUAL_INFEASIBLE","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.ALMOST_DUAL_INFEASIBLE","category":"page"},{"location":"api/JuMP/#JuMP.ALMOST_DUAL_INFEASIBLE","page":"JuMP","title":"JuMP.ALMOST_DUAL_INFEASIBLE","text":"ALMOST_DUAL_INFEASIBLE::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nALMOST_DUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#ALMOST_INFEASIBLE","page":"JuMP","title":"ALMOST_INFEASIBLE","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.ALMOST_INFEASIBLE","category":"page"},{"location":"api/JuMP/#JuMP.ALMOST_INFEASIBLE","page":"JuMP","title":"JuMP.ALMOST_INFEASIBLE","text":"ALMOST_INFEASIBLE::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nALMOST_INFEASIBLE: The algorithm concluded that no feasible solution exists within relaxed tolerances.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#ALMOST_LOCALLY_SOLVED","page":"JuMP","title":"ALMOST_LOCALLY_SOLVED","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.ALMOST_LOCALLY_SOLVED","category":"page"},{"location":"api/JuMP/#JuMP.ALMOST_LOCALLY_SOLVED","page":"JuMP","title":"JuMP.ALMOST_LOCALLY_SOLVED","text":"ALMOST_LOCALLY_SOLVED::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nALMOST_LOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#ALMOST_OPTIMAL","page":"JuMP","title":"ALMOST_OPTIMAL","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.ALMOST_OPTIMAL","category":"page"},{"location":"api/JuMP/#JuMP.ALMOST_OPTIMAL","page":"JuMP","title":"JuMP.ALMOST_OPTIMAL","text":"ALMOST_OPTIMAL::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nALMOST_OPTIMAL: The algorithm found a globally optimal solution to relaxed tolerances.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#AUTOMATIC","page":"JuMP","title":"AUTOMATIC","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.AUTOMATIC","category":"page"},{"location":"api/JuMP/#JuMP.AUTOMATIC","page":"JuMP","title":"JuMP.AUTOMATIC","text":"moi_backend field holds a CachingOptimizer in AUTOMATIC mode.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#DIRECT","page":"JuMP","title":"DIRECT","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.DIRECT","category":"page"},{"location":"api/JuMP/#JuMP.DIRECT","page":"JuMP","title":"JuMP.DIRECT","text":"moi_backend field holds an AbstractOptimizer. No extra copy of the model is stored. The moi_backend must support add_constraint etc.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#DUAL_INFEASIBLE","page":"JuMP","title":"DUAL_INFEASIBLE","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.DUAL_INFEASIBLE","category":"page"},{"location":"api/JuMP/#JuMP.DUAL_INFEASIBLE","page":"JuMP","title":"JuMP.DUAL_INFEASIBLE","text":"DUAL_INFEASIBLE::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nDUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem. If, additionally, a feasible (primal) solution is known to exist, this status typically implies that the problem is unbounded, with some technical exceptions.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#FEASIBILITY_SENSE","page":"JuMP","title":"FEASIBILITY_SENSE","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.FEASIBILITY_SENSE","category":"page"},{"location":"api/JuMP/#JuMP.FEASIBILITY_SENSE","page":"JuMP","title":"JuMP.FEASIBILITY_SENSE","text":"FEASIBILITY_SENSE::OptimizationSense\n\nAn instance of the OptimizationSense enum.\n\nFEASIBILITY_SENSE: the model does not have an objective function\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#FEASIBLE_POINT","page":"JuMP","title":"FEASIBLE_POINT","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.FEASIBLE_POINT","category":"page"},{"location":"api/JuMP/#JuMP.FEASIBLE_POINT","page":"JuMP","title":"JuMP.FEASIBLE_POINT","text":"FEASIBLE_POINT::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nFEASIBLE_POINT: the result vector is a feasible point.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#INFEASIBILITY_CERTIFICATE","page":"JuMP","title":"INFEASIBILITY_CERTIFICATE","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.INFEASIBILITY_CERTIFICATE","category":"page"},{"location":"api/JuMP/#JuMP.INFEASIBILITY_CERTIFICATE","page":"JuMP","title":"JuMP.INFEASIBILITY_CERTIFICATE","text":"INFEASIBILITY_CERTIFICATE::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nINFEASIBILITY_CERTIFICATE: the result vector is an infeasibility certificate. If the PrimalStatus is INFEASIBILITY_CERTIFICATE, then the primal result vector is a certificate of dual infeasibility. If the DualStatus is INFEASIBILITY_CERTIFICATE, then the dual result vector is a proof of primal infeasibility.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#INFEASIBLE","page":"JuMP","title":"INFEASIBLE","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.INFEASIBLE","category":"page"},{"location":"api/JuMP/#JuMP.INFEASIBLE","page":"JuMP","title":"JuMP.INFEASIBLE","text":"INFEASIBLE::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nINFEASIBLE: The algorithm concluded that no feasible solution exists.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#INFEASIBLE_OR_UNBOUNDED","page":"JuMP","title":"INFEASIBLE_OR_UNBOUNDED","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.INFEASIBLE_OR_UNBOUNDED","category":"page"},{"location":"api/JuMP/#JuMP.INFEASIBLE_OR_UNBOUNDED","page":"JuMP","title":"JuMP.INFEASIBLE_OR_UNBOUNDED","text":"INFEASIBLE_OR_UNBOUNDED::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nINFEASIBLE_OR_UNBOUNDED: The algorithm stopped because it decided that the problem is infeasible or unbounded; this occasionally happens during MIP presolve.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#INFEASIBLE_POINT","page":"JuMP","title":"INFEASIBLE_POINT","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.INFEASIBLE_POINT","category":"page"},{"location":"api/JuMP/#JuMP.INFEASIBLE_POINT","page":"JuMP","title":"JuMP.INFEASIBLE_POINT","text":"INFEASIBLE_POINT::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nINFEASIBLE_POINT: the result vector is an infeasible point.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#INTERRUPTED","page":"JuMP","title":"INTERRUPTED","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.INTERRUPTED","category":"page"},{"location":"api/JuMP/#JuMP.INTERRUPTED","page":"JuMP","title":"JuMP.INTERRUPTED","text":"INTERRUPTED::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nINTERRUPTED: The algorithm stopped because of an interrupt signal.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#INVALID_MODEL","page":"JuMP","title":"INVALID_MODEL","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.INVALID_MODEL","category":"page"},{"location":"api/JuMP/#JuMP.INVALID_MODEL","page":"JuMP","title":"JuMP.INVALID_MODEL","text":"INVALID_MODEL::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nINVALID_MODEL: The algorithm stopped because the model is invalid.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#INVALID_OPTION","page":"JuMP","title":"INVALID_OPTION","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.INVALID_OPTION","category":"page"},{"location":"api/JuMP/#JuMP.INVALID_OPTION","page":"JuMP","title":"JuMP.INVALID_OPTION","text":"INVALID_OPTION::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nINVALID_OPTION: The algorithm stopped because it was provided an invalid option.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#ITERATION_LIMIT","page":"JuMP","title":"ITERATION_LIMIT","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.ITERATION_LIMIT","category":"page"},{"location":"api/JuMP/#JuMP.ITERATION_LIMIT","page":"JuMP","title":"JuMP.ITERATION_LIMIT","text":"ITERATION_LIMIT::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nITERATION_LIMIT: An iterative algorithm stopped after conducting the maximum number of iterations.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#LOCALLY_INFEASIBLE","page":"JuMP","title":"LOCALLY_INFEASIBLE","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.LOCALLY_INFEASIBLE","category":"page"},{"location":"api/JuMP/#JuMP.LOCALLY_INFEASIBLE","page":"JuMP","title":"JuMP.LOCALLY_INFEASIBLE","text":"LOCALLY_INFEASIBLE::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nLOCALLY_INFEASIBLE: The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#LOCALLY_SOLVED","page":"JuMP","title":"LOCALLY_SOLVED","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.LOCALLY_SOLVED","category":"page"},{"location":"api/JuMP/#JuMP.LOCALLY_SOLVED","page":"JuMP","title":"JuMP.LOCALLY_SOLVED","text":"LOCALLY_SOLVED::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nLOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#MANUAL","page":"JuMP","title":"MANUAL","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.MANUAL","category":"page"},{"location":"api/JuMP/#JuMP.MANUAL","page":"JuMP","title":"JuMP.MANUAL","text":"moi_backend field holds a CachingOptimizer in MANUAL mode.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#MAX_SENSE","page":"JuMP","title":"MAX_SENSE","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.MAX_SENSE","category":"page"},{"location":"api/JuMP/#JuMP.MAX_SENSE","page":"JuMP","title":"JuMP.MAX_SENSE","text":"MAX_SENSE::OptimizationSense\n\nAn instance of the OptimizationSense enum.\n\nMAX_SENSE: the goal is to maximize the objective function\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#MEMORY_LIMIT","page":"JuMP","title":"MEMORY_LIMIT","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.MEMORY_LIMIT","category":"page"},{"location":"api/JuMP/#JuMP.MEMORY_LIMIT","page":"JuMP","title":"JuMP.MEMORY_LIMIT","text":"MEMORY_LIMIT::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nMEMORY_LIMIT: The algorithm stopped because it ran out of memory.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#MIN_SENSE","page":"JuMP","title":"MIN_SENSE","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.MIN_SENSE","category":"page"},{"location":"api/JuMP/#JuMP.MIN_SENSE","page":"JuMP","title":"JuMP.MIN_SENSE","text":"MIN_SENSE::OptimizationSense\n\nAn instance of the OptimizationSense enum.\n\nMIN_SENSE: the goal is to minimize the objective function\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#NEARLY_FEASIBLE_POINT","page":"JuMP","title":"NEARLY_FEASIBLE_POINT","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.NEARLY_FEASIBLE_POINT","category":"page"},{"location":"api/JuMP/#JuMP.NEARLY_FEASIBLE_POINT","page":"JuMP","title":"JuMP.NEARLY_FEASIBLE_POINT","text":"NEARLY_FEASIBLE_POINT::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nNEARLY_FEASIBLE_POINT: the result vector is feasible if some constraint tolerances are relaxed.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#NEARLY_INFEASIBILITY_CERTIFICATE","page":"JuMP","title":"NEARLY_INFEASIBILITY_CERTIFICATE","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.NEARLY_INFEASIBILITY_CERTIFICATE","category":"page"},{"location":"api/JuMP/#JuMP.NEARLY_INFEASIBILITY_CERTIFICATE","page":"JuMP","title":"JuMP.NEARLY_INFEASIBILITY_CERTIFICATE","text":"NEARLY_INFEASIBILITY_CERTIFICATE::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nNEARLY_INFEASIBILITY_CERTIFICATE: the result satisfies a relaxed criterion for a certificate of infeasibility.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#NEARLY_REDUCTION_CERTIFICATE","page":"JuMP","title":"NEARLY_REDUCTION_CERTIFICATE","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.NEARLY_REDUCTION_CERTIFICATE","category":"page"},{"location":"api/JuMP/#JuMP.NEARLY_REDUCTION_CERTIFICATE","page":"JuMP","title":"JuMP.NEARLY_REDUCTION_CERTIFICATE","text":"NEARLY_REDUCTION_CERTIFICATE::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nNEARLY_REDUCTION_CERTIFICATE: the result satisfies a relaxed criterion for an ill-posed certificate.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#NODE_LIMIT","page":"JuMP","title":"NODE_LIMIT","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.NODE_LIMIT","category":"page"},{"location":"api/JuMP/#JuMP.NODE_LIMIT","page":"JuMP","title":"JuMP.NODE_LIMIT","text":"NODE_LIMIT::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nNODE_LIMIT: A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#NORM_LIMIT","page":"JuMP","title":"NORM_LIMIT","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.NORM_LIMIT","category":"page"},{"location":"api/JuMP/#JuMP.NORM_LIMIT","page":"JuMP","title":"JuMP.NORM_LIMIT","text":"NORM_LIMIT::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nNORM_LIMIT: The algorithm stopped because the norm of an iterate became too large.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#NO_SOLUTION","page":"JuMP","title":"NO_SOLUTION","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.NO_SOLUTION","category":"page"},{"location":"api/JuMP/#JuMP.NO_SOLUTION","page":"JuMP","title":"JuMP.NO_SOLUTION","text":"NO_SOLUTION::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nNO_SOLUTION: the result vector is empty.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#NUMERICAL_ERROR","page":"JuMP","title":"NUMERICAL_ERROR","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.NUMERICAL_ERROR","category":"page"},{"location":"api/JuMP/#JuMP.NUMERICAL_ERROR","page":"JuMP","title":"JuMP.NUMERICAL_ERROR","text":"NUMERICAL_ERROR::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nNUMERICAL_ERROR: The algorithm stopped because it encountered unrecoverable numerical error.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#OBJECTIVE_LIMIT","page":"JuMP","title":"OBJECTIVE_LIMIT","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.OBJECTIVE_LIMIT","category":"page"},{"location":"api/JuMP/#JuMP.OBJECTIVE_LIMIT","page":"JuMP","title":"JuMP.OBJECTIVE_LIMIT","text":"OBJECTIVE_LIMIT::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nOBJECTIVE_LIMIT: The algorithm stopped because it found a solution better than a minimum limit set by the user.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#OPTIMAL","page":"JuMP","title":"OPTIMAL","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.OPTIMAL","category":"page"},{"location":"api/JuMP/#JuMP.OPTIMAL","page":"JuMP","title":"JuMP.OPTIMAL","text":"OPTIMAL::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nOPTIMAL: The algorithm found a globally optimal solution.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#OPTIMIZE_NOT_CALLED","page":"JuMP","title":"OPTIMIZE_NOT_CALLED","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.OPTIMIZE_NOT_CALLED","category":"page"},{"location":"api/JuMP/#JuMP.OPTIMIZE_NOT_CALLED","page":"JuMP","title":"JuMP.OPTIMIZE_NOT_CALLED","text":"OPTIMIZE_NOT_CALLED::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nOPTIMIZE_NOT_CALLED: The algorithm has not started.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#OTHER_ERROR","page":"JuMP","title":"OTHER_ERROR","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.OTHER_ERROR","category":"page"},{"location":"api/JuMP/#JuMP.OTHER_ERROR","page":"JuMP","title":"JuMP.OTHER_ERROR","text":"OTHER_ERROR::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nOTHER_ERROR: The algorithm stopped because of an error not covered by one of the statuses defined above.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#OTHER_LIMIT","page":"JuMP","title":"OTHER_LIMIT","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.OTHER_LIMIT","category":"page"},{"location":"api/JuMP/#JuMP.OTHER_LIMIT","page":"JuMP","title":"JuMP.OTHER_LIMIT","text":"OTHER_LIMIT::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nOTHER_LIMIT: The algorithm stopped due to a limit not covered by one of the _LIMIT_ statuses above.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#OTHER_RESULT_STATUS","page":"JuMP","title":"OTHER_RESULT_STATUS","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.OTHER_RESULT_STATUS","category":"page"},{"location":"api/JuMP/#JuMP.OTHER_RESULT_STATUS","page":"JuMP","title":"JuMP.OTHER_RESULT_STATUS","text":"OTHER_RESULT_STATUS::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nOTHER_RESULT_STATUS: the result vector contains a solution with an interpretation not covered by one of the statuses defined above\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#REDUCTION_CERTIFICATE","page":"JuMP","title":"REDUCTION_CERTIFICATE","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.REDUCTION_CERTIFICATE","category":"page"},{"location":"api/JuMP/#JuMP.REDUCTION_CERTIFICATE","page":"JuMP","title":"JuMP.REDUCTION_CERTIFICATE","text":"REDUCTION_CERTIFICATE::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nREDUCTION_CERTIFICATE: the result vector is an ill-posed certificate; see this article for details. If the PrimalStatus is REDUCTION_CERTIFICATE, then the primal result vector is a proof that the dual problem is ill-posed. If the DualStatus is REDUCTION_CERTIFICATE, then the dual result vector is a proof that the primal is ill-posed.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#SLOW_PROGRESS","page":"JuMP","title":"SLOW_PROGRESS","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.SLOW_PROGRESS","category":"page"},{"location":"api/JuMP/#JuMP.SLOW_PROGRESS","page":"JuMP","title":"JuMP.SLOW_PROGRESS","text":"SLOW_PROGRESS::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nSLOW_PROGRESS: The algorithm stopped because it was unable to continue making progress towards the solution.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#SOLUTION_LIMIT","page":"JuMP","title":"SOLUTION_LIMIT","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.SOLUTION_LIMIT","category":"page"},{"location":"api/JuMP/#JuMP.SOLUTION_LIMIT","page":"JuMP","title":"JuMP.SOLUTION_LIMIT","text":"SOLUTION_LIMIT::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nSOLUTION_LIMIT: The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#TIME_LIMIT","page":"JuMP","title":"TIME_LIMIT","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.TIME_LIMIT","category":"page"},{"location":"api/JuMP/#JuMP.TIME_LIMIT","page":"JuMP","title":"JuMP.TIME_LIMIT","text":"TIME_LIMIT::TerminationStatusCode\n\nAn instance of the TerminationStatusCode enum.\n\nTIME_LIMIT: The algorithm stopped after a user-specified computation time.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#UNKNOWN_RESULT_STATUS","page":"JuMP","title":"UNKNOWN_RESULT_STATUS","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.UNKNOWN_RESULT_STATUS","category":"page"},{"location":"api/JuMP/#JuMP.UNKNOWN_RESULT_STATUS","page":"JuMP","title":"JuMP.UNKNOWN_RESULT_STATUS","text":"UNKNOWN_RESULT_STATUS::ResultStatusCode\n\nAn instance of the ResultStatusCode enum.\n\nUNKNOWN_RESULT_STATUS: the result vector contains a solution with an unknown interpretation.\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#op_and","page":"JuMP","title":"op_and","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.op_and","category":"page"},{"location":"api/JuMP/#JuMP.op_and","page":"JuMP","title":"JuMP.op_and","text":"op_and(x, y)\n\nA function that falls back to x & y, but when called with JuMP variables or expressions, returns a GenericNonlinearExpr.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> op_and(true, false)\nfalse\n\njulia> op_and(true, x)\ntrue && x\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#op_equal_to","page":"JuMP","title":"op_equal_to","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.op_equal_to","category":"page"},{"location":"api/JuMP/#JuMP.op_equal_to","page":"JuMP","title":"JuMP.op_equal_to","text":"op_equal_to(x, y)\n\nA function that falls back to x == y, but when called with JuMP variables or expressions, returns a GenericNonlinearExpr.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> op_equal_to(2, 2)\ntrue\n\njulia> op_equal_to(x, 2)\nx == 2\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#op_greater_than_or_equal_to","page":"JuMP","title":"op_greater_than_or_equal_to","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.op_greater_than_or_equal_to","category":"page"},{"location":"api/JuMP/#JuMP.op_greater_than_or_equal_to","page":"JuMP","title":"JuMP.op_greater_than_or_equal_to","text":"op_greater_than_or_equal_to(x, y)\n\nA function that falls back to x >= y, but when called with JuMP variables or expressions, returns a GenericNonlinearExpr.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> op_greater_than_or_equal_to(2, 2)\ntrue\n\njulia> op_greater_than_or_equal_to(x, 2)\nx >= 2\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#op_less_than_or_equal_to","page":"JuMP","title":"op_less_than_or_equal_to","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.op_less_than_or_equal_to","category":"page"},{"location":"api/JuMP/#JuMP.op_less_than_or_equal_to","page":"JuMP","title":"JuMP.op_less_than_or_equal_to","text":"op_less_than_or_equal_to(x, y)\n\nA function that falls back to x <= y, but when called with JuMP variables or expressions, returns a GenericNonlinearExpr.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> op_less_than_or_equal_to(2, 2)\ntrue\n\njulia> op_less_than_or_equal_to(x, 2)\nx <= 2\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#op_or","page":"JuMP","title":"op_or","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.op_or","category":"page"},{"location":"api/JuMP/#JuMP.op_or","page":"JuMP","title":"JuMP.op_or","text":"op_or(x, y)\n\nA function that falls back to x | y, but when called with JuMP variables or expressions, returns a GenericNonlinearExpr.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> op_or(true, false)\ntrue\n\njulia> op_or(true, x)\ntrue || x\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#op_strictly_greater_than","page":"JuMP","title":"op_strictly_greater_than","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.op_strictly_greater_than","category":"page"},{"location":"api/JuMP/#JuMP.op_strictly_greater_than","page":"JuMP","title":"JuMP.op_strictly_greater_than","text":"op_strictly_greater_than(x, y)\n\nA function that falls back to x > y, but when called with JuMP variables or expressions, returns a GenericNonlinearExpr.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> op_strictly_greater_than(1, 2)\nfalse\n\njulia> op_strictly_greater_than(x, 2)\nx > 2\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#op_strictly_less_than","page":"JuMP","title":"op_strictly_less_than","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.op_strictly_less_than","category":"page"},{"location":"api/JuMP/#JuMP.op_strictly_less_than","page":"JuMP","title":"JuMP.op_strictly_less_than","text":"op_strictly_less_than(x, y)\n\nA function that falls back to x < y, but when called with JuMP variables or expressions, returns a GenericNonlinearExpr.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> op_strictly_less_than(1, 2)\ntrue\n\njulia> op_strictly_less_than(x, 2)\nx < 2\n\n\n\n\n\n","category":"constant"},{"location":"api/JuMP/#Base.empty!(::GenericModel)","page":"JuMP","title":"Base.empty!(::GenericModel)","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.Base.empty!(::GenericModel)","category":"page"},{"location":"api/JuMP/#Base.empty!-Tuple{GenericModel}","page":"JuMP","title":"Base.empty!","text":"empty!(model::GenericModel)::GenericModel\n\nEmpty the model, that is, remove all variables, constraints and model attributes but not optimizer attributes. Always return the argument.\n\nNote: removes extensions data.\n\n\n\n\n\n","category":"method"},{"location":"api/JuMP/#Base.isempty(::GenericModel)","page":"JuMP","title":"Base.isempty(::GenericModel)","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.Base.isempty(::GenericModel)","category":"page"},{"location":"api/JuMP/#Base.isempty-Tuple{GenericModel}","page":"JuMP","title":"Base.isempty","text":"isempty(model::GenericModel)\n\nVerifies whether the model is empty, that is, whether the MOI backend is empty and whether the model is in the same state as at its creation apart from optimizer attributes.\n\n\n\n\n\n","category":"method"},{"location":"api/JuMP/#Base.copy(::AbstractModel)","page":"JuMP","title":"Base.copy(::AbstractModel)","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.Base.copy(::AbstractModel)","category":"page"},{"location":"api/JuMP/#Base.copy-Tuple{AbstractModel}","page":"JuMP","title":"Base.copy","text":"copy(model::AbstractModel)\n\nReturn a copy of the model model. It is similar to copy_model except that it does not return the mapping between the references of model and its copy.\n\nNote\n\nModel copy is not supported in DIRECT mode, that is, when a model is constructed using the direct_model constructor instead of the Model constructor. Moreover, independently on whether an optimizer was provided at model construction, the new model will have no optimizer, that is, an optimizer will have to be provided to the new model in the optimize! call.\n\nExample\n\nIn the following example, a model model is constructed with a variable x and a constraint cref. It is then copied into a model new_model with the new references assigned to x_new and cref_new.\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, cref, x == 2)\ncref : x = 2\n\njulia> new_model = copy(model);\n\njulia> x_new = model[:x]\nx\n\njulia> cref_new = model[:cref]\ncref : x = 2\n\n\n\n\n\n","category":"method"},{"location":"api/JuMP/#Base.write(::IO,-::GenericModel;-::MOI.FileFormats.FileFormat)","page":"JuMP","title":"Base.write(::IO, ::GenericModel; ::MOI.FileFormats.FileFormat)","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.Base.write(::IO, ::GenericModel; ::MOI.FileFormats.FileFormat)","category":"page"},{"location":"api/JuMP/#Base.write-Tuple{IO, GenericModel}","page":"JuMP","title":"Base.write","text":"Base.write(\n    io::IO,\n    model::GenericModel;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_MOF,\n    kwargs...,\n)\n\nWrite the JuMP model model to io in the format format.\n\nOther kwargs are passed to the Model constructor of the chosen format.\n\n\n\n\n\n","category":"method"},{"location":"api/JuMP/#MOI.Utilities.reset_optimizer(::GenericModel)","page":"JuMP","title":"MOI.Utilities.reset_optimizer(::GenericModel)","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.MOI.Utilities.reset_optimizer(::GenericModel)","category":"page"},{"location":"api/JuMP/#MathOptInterface.Utilities.reset_optimizer-Tuple{GenericModel}","page":"JuMP","title":"MathOptInterface.Utilities.reset_optimizer","text":"MOIU.reset_optimizer(model::GenericModel)\n\nCall MOIU.reset_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"method"},{"location":"api/JuMP/#MOI.Utilities.drop_optimizer(::GenericModel)","page":"JuMP","title":"MOI.Utilities.drop_optimizer(::GenericModel)","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.MOI.Utilities.drop_optimizer(::GenericModel)","category":"page"},{"location":"api/JuMP/#MathOptInterface.Utilities.drop_optimizer-Tuple{GenericModel}","page":"JuMP","title":"MathOptInterface.Utilities.drop_optimizer","text":"MOIU.drop_optimizer(model::GenericModel)\n\nCall MOIU.drop_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"method"},{"location":"api/JuMP/#MOI.Utilities.attach_optimizer(::GenericModel)","page":"JuMP","title":"MOI.Utilities.attach_optimizer(::GenericModel)","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.MOI.Utilities.attach_optimizer(::GenericModel)","category":"page"},{"location":"api/JuMP/#MathOptInterface.Utilities.attach_optimizer-Tuple{GenericModel}","page":"JuMP","title":"MathOptInterface.Utilities.attach_optimizer","text":"MOIU.attach_optimizer(model::GenericModel)\n\nCall MOIU.attach_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"method"},{"location":"api/JuMP/#@NLconstraint","page":"JuMP","title":"@NLconstraint","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.@NLconstraint","category":"page"},{"location":"api/JuMP/#JuMP.@NLconstraint","page":"JuMP","title":"JuMP.@NLconstraint","text":"@NLconstraint(model::GenericModel, expr)\n\nAdd a constraint described by the nonlinear expression expr. See also @constraint.\n\ncompat: Compat\nThis macro is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling. In most cases, you can replace @NLconstraint with @constraint.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @NLconstraint(model, sin(x) <= 1)\nsin(x) - 1.0 ≤ 0\n\njulia> @NLconstraint(model, [i = 1:3], sin(i * x) <= 1 / i)\n3-element Vector{NonlinearConstraintRef{ScalarShape}}:\n (sin(1.0 * x) - 1.0 / 1.0) - 0.0 ≤ 0\n (sin(2.0 * x) - 1.0 / 2.0) - 0.0 ≤ 0\n (sin(3.0 * x) - 1.0 / 3.0) - 0.0 ≤ 0\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP/#@NLconstraints","page":"JuMP","title":"@NLconstraints","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.@NLconstraints","category":"page"},{"location":"api/JuMP/#JuMP.@NLconstraints","page":"JuMP","title":"JuMP.@NLconstraints","text":"@NLconstraints(model, args...)\n\nAdds multiple nonlinear constraints to model at once, in the same fashion as the @NLconstraint macro.\n\nThe model must be the first argument, and multiple constraints can be added on multiple lines wrapped in a begin ... end block.\n\nThe macro returns a tuple containing the constraints that were defined.\n\ncompat: Compat\nThis macro is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling. In most cases, you can replace @NLconstraints with @constraints.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @variable(model, y);\n\njulia> @variable(model, t);\n\njulia> @variable(model, z[1:2]);\n\njulia> a = [4, 5];\n\njulia> @NLconstraints(model, begin\n           t >= sqrt(x^2 + y^2)\n           [i = 1:2], z[i] <= log(a[i])\n       end)\n((t - sqrt(x ^ 2.0 + y ^ 2.0)) - 0.0 ≥ 0, NonlinearConstraintRef{ScalarShape}[(z[1] - log(4.0)) - 0.0 ≤ 0, (z[2] - log(5.0)) - 0.0 ≤ 0])\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP/#@NLexpression","page":"JuMP","title":"@NLexpression","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.@NLexpression","category":"page"},{"location":"api/JuMP/#JuMP.@NLexpression","page":"JuMP","title":"JuMP.@NLexpression","text":"@NLexpression(args...)\n\nEfficiently build a nonlinear expression which can then be inserted in other nonlinear constraints and the objective. See also [@expression].\n\ncompat: Compat\nThis macro is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling. In most cases, you can replace @NLexpression with @expression.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @NLexpression(model, my_expr, sin(x)^2 + cos(x^2))\nsubexpression[1]: sin(x) ^ 2.0 + cos(x ^ 2.0)\n\njulia> @NLconstraint(model, my_expr + y >= 5)\n(subexpression[1] + y) - 5.0 ≥ 0\n\njulia> @NLobjective(model, Min, my_expr)\n\nIndexing over sets and anonymous expressions are also supported:\n\njulia> @NLexpression(model, my_expr_1[i=1:3], sin(i * x))\n3-element Vector{NonlinearExpression}:\n subexpression[2]: sin(1.0 * x)\n subexpression[3]: sin(2.0 * x)\n subexpression[4]: sin(3.0 * x)\n\njulia> my_expr_2 = @NLexpression(model, log(1 + sum(exp(my_expr_1[i]) for i in 1:2)))\nsubexpression[5]: log(1.0 + (exp(subexpression[2]) + exp(subexpression[3])))\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP/#@NLexpressions","page":"JuMP","title":"@NLexpressions","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.@NLexpressions","category":"page"},{"location":"api/JuMP/#JuMP.@NLexpressions","page":"JuMP","title":"JuMP.@NLexpressions","text":"@NLexpressions(model, args...)\n\nAdds multiple nonlinear expressions to model at once, in the same fashion as the @NLexpression macro.\n\nThe model must be the first argument, and multiple expressions can be added on multiple lines wrapped in a begin ... end block.\n\nThe macro returns a tuple containing the expressions that were defined.\n\ncompat: Compat\nThis macro is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling. In most cases, you can replace @NLexpressions with @expressions.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @variable(model, y);\n\njulia> @variable(model, z[1:2]);\n\njulia> a = [4, 5];\n\njulia> @NLexpressions(model, begin\n           my_expr, sqrt(x^2 + y^2)\n           my_expr_1[i = 1:2], log(a[i]) - z[i]\n       end)\n(subexpression[1]: sqrt(x ^ 2.0 + y ^ 2.0), NonlinearExpression[subexpression[2]: log(4.0) - z[1], subexpression[3]: log(5.0) - z[2]])\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP/#@NLobjective","page":"JuMP","title":"@NLobjective","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.@NLobjective","category":"page"},{"location":"api/JuMP/#JuMP.@NLobjective","page":"JuMP","title":"JuMP.@NLobjective","text":"@NLobjective(model, sense, expression)\n\nAdd a nonlinear objective to model with optimization sense sense. sense must be Max or Min.\n\ncompat: Compat\nThis macro is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling. In most cases, you can replace @NLobjective with @objective.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @NLobjective(model, Max, 2x + 1 + sin(x))\n\njulia> print(model)\nMax 2.0 * x + 1.0 + sin(x)\nSubject to\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP/#@NLparameter","page":"JuMP","title":"@NLparameter","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.@NLparameter","category":"page"},{"location":"api/JuMP/#JuMP.@NLparameter","page":"JuMP","title":"JuMP.@NLparameter","text":"@NLparameter(model, param == value)\n\nCreate and return a nonlinear parameter param attached to the model model with initial value set to value. Nonlinear parameters may be used only in nonlinear expressions.\n\nExample\n\njulia> model = Model();\n\njulia> @NLparameter(model, x == 10)\nx == 10.0\n\njulia> value(x)\n10.0\n\n@NLparameter(model, value = param_value)\n\nCreate and return an anonymous nonlinear parameter param attached to the model model with initial value set to param_value. Nonlinear parameters may be used only in nonlinear expressions.\n\nExample\n\njulia> model = Model();\n\njulia> x = @NLparameter(model, value = 10)\nparameter[1] == 10.0\n\njulia> value(x)\n10.0\n\n@NLparameter(model, param_collection[...] == value_expr)\n\nCreate and return a collection of nonlinear parameters param_collection attached to the model model with initial value set to value_expr (may depend on index sets). Uses the same syntax for specifying index sets as @variable.\n\nExample\n\njulia> model = Model();\n\njulia> @NLparameter(model, y[i = 1:3] == 2 * i)\n3-element Vector{NonlinearParameter}:\n parameter[1] == 2.0\n parameter[2] == 4.0\n parameter[3] == 6.0\n\njulia> value(y[2])\n4.0\n\n@NLparameter(model, [...] == value_expr)\n\nCreate and return an anonymous collection of nonlinear parameters attached to the model model with initial value set to value_expr (may depend on index sets). Uses the same syntax for specifying index sets as @variable.\n\ncompat: Compat\nThis macro is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling. In most cases, you can replace a call like @NLparameter(model, p == value) with @variable(model, p in Parameter(value)).\n\nExample\n\njulia> model = Model();\n\njulia> y = @NLparameter(model, [i = 1:3] == 2 * i)\n3-element Vector{NonlinearParameter}:\n parameter[1] == 2.0\n parameter[2] == 4.0\n parameter[3] == 6.0\n\njulia> value(y[2])\n4.0\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP/#@NLparameters","page":"JuMP","title":"@NLparameters","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.@NLparameters","category":"page"},{"location":"api/JuMP/#JuMP.@NLparameters","page":"JuMP","title":"JuMP.@NLparameters","text":" @NLparameters(model, args...)\n\nCreate and return multiple nonlinear parameters attached to model model, in the same fashion as @NLparameter macro.\n\nThe model must be the first argument, and multiple parameters can be added on multiple lines wrapped in a begin ... end block. Distinct parameters need to be placed on separate lines as in the following example.\n\nThe macro returns a tuple containing the parameters that were defined.\n\ncompat: Compat\nThis macro is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling. In most cases, you can replace a call like@NLparameters(model, begin\n    p == value\nend)with@variables(model, begin\n    p in Parameter(value)\nend)\n\nExample\n\njulia> model = Model();\n\njulia> @NLparameters(model, begin\n           x == 10\n           b == 156\n       end);\n\njulia> value(x)\n10.0\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP/#add_nonlinear_constraint","page":"JuMP","title":"add_nonlinear_constraint","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.add_nonlinear_constraint","category":"page"},{"location":"api/JuMP/#JuMP.add_nonlinear_constraint","page":"JuMP","title":"JuMP.add_nonlinear_constraint","text":"add_nonlinear_constraint(model::Model, expr::Expr)\n\nAdd a nonlinear constraint described by the Julia expression ex to model.\n\nThis function is most useful if the expression ex is generated programmatically, and you cannot use @NLconstraint.\n\ncompat: Compat\nThis function is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\nNotes\n\nYou must interpolate the variables directly into the expression expr.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> add_nonlinear_constraint(model, :($(x) + $(x)^2 <= 1))\n(x + x ^ 2.0) - 1.0 ≤ 0\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#add_nonlinear_expression","page":"JuMP","title":"add_nonlinear_expression","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.add_nonlinear_expression","category":"page"},{"location":"api/JuMP/#JuMP.add_nonlinear_expression","page":"JuMP","title":"JuMP.add_nonlinear_expression","text":"add_nonlinear_expression(model::Model, expr::Expr)\n\nAdd a nonlinear expression expr to model.\n\nThis function is most useful if the expression expr is generated programmatically, and you cannot use @NLexpression.\n\ncompat: Compat\nThis function is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\nNotes\n\nYou must interpolate the variables directly into the expression expr.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> add_nonlinear_expression(model, :($(x) + $(x)^2))\nsubexpression[1]: x + x ^ 2.0\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#all_nonlinear_constraints","page":"JuMP","title":"all_nonlinear_constraints","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.all_nonlinear_constraints","category":"page"},{"location":"api/JuMP/#JuMP.all_nonlinear_constraints","page":"JuMP","title":"JuMP.all_nonlinear_constraints","text":"all_nonlinear_constraints(model::GenericModel)\n\nReturn a vector of all nonlinear constraint references in the model in the order they were added to the model.\n\ncompat: Compat\nThis function is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\nThis function returns only the constraints added with @NLconstraint and add_nonlinear_constraint. It does not return GenericNonlinearExpr constraints.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#get_optimizer_attribute","page":"JuMP","title":"get_optimizer_attribute","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.get_optimizer_attribute","category":"page"},{"location":"api/JuMP/#JuMP.get_optimizer_attribute","page":"JuMP","title":"JuMP.get_optimizer_attribute","text":"get_optimizer_attribute(\n    model::Union{GenericModel,MOI.OptimizerWithAttributes},\n    attr::Union{AbstractString,MOI.AbstractOptimizerAttribute},\n)\n\nReturn the value associated with the solver-specific attribute attr.\n\nIf attr is an AbstractString, this is equivalent to get_optimizer_attribute(model, MOI.RawOptimizerAttribute(name)).\n\ncompat: Compat\nThis method will remain in all v1.X releases of JuMP, but it may be removed in a future v2.0 release. We recommend using get_attribute instead.\n\nSee also: set_optimizer_attribute, set_optimizer_attributes.\n\nExample\n\njulia> import Ipopt\n\njulia> model = Model(Ipopt.Optimizer);\n\njulia> get_optimizer_attribute(model, MOI.Silent())\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#nonlinear_constraint_string","page":"JuMP","title":"nonlinear_constraint_string","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.nonlinear_constraint_string","category":"page"},{"location":"api/JuMP/#JuMP.nonlinear_constraint_string","page":"JuMP","title":"JuMP.nonlinear_constraint_string","text":"nonlinear_constraint_string(\n    model::GenericModel,\n    mode::MIME,\n    c::_NonlinearConstraint,\n)\n\nReturn a string representation of the nonlinear constraint c belonging to model, given the mode.\n\ncompat: Compat\nThis function is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#nonlinear_dual_start_value","page":"JuMP","title":"nonlinear_dual_start_value","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.nonlinear_dual_start_value","category":"page"},{"location":"api/JuMP/#JuMP.nonlinear_dual_start_value","page":"JuMP","title":"JuMP.nonlinear_dual_start_value","text":"nonlinear_dual_start_value(model::Model)\n\nReturn the current value of the MOI attribute MOI.NLPBlockDualStart.\n\ncompat: Compat\nThis function is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#nonlinear_expr_string","page":"JuMP","title":"nonlinear_expr_string","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.nonlinear_expr_string","category":"page"},{"location":"api/JuMP/#JuMP.nonlinear_expr_string","page":"JuMP","title":"JuMP.nonlinear_expr_string","text":"nonlinear_expr_string(\n    model::GenericModel,\n    mode::MIME,\n    c::MOI.Nonlinear.Expression,\n)\n\nReturn a string representation of the nonlinear expression c belonging to model, given the mode.\n\ncompat: Compat\nThis function is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#nonlinear_model","page":"JuMP","title":"nonlinear_model","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.nonlinear_model","category":"page"},{"location":"api/JuMP/#JuMP.nonlinear_model","page":"JuMP","title":"JuMP.nonlinear_model","text":"nonlinear_model(\n    model::GenericModel;\n    force::Bool = false,\n)::Union{MOI.Nonlinear.Model,Nothing}\n\nIf model has nonlinear components, return a MOI.Nonlinear.Model, otherwise return nothing.\n\nIf force, always return a MOI.Nonlinear.Model, and if one does not exist for the model, create an empty one.\n\ncompat: Compat\nThis function is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#num_nonlinear_constraints","page":"JuMP","title":"num_nonlinear_constraints","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.num_nonlinear_constraints","category":"page"},{"location":"api/JuMP/#JuMP.num_nonlinear_constraints","page":"JuMP","title":"JuMP.num_nonlinear_constraints","text":"num_nonlinear_constraints(model::GenericModel)\n\nReturns the number of nonlinear constraints associated with the model.\n\ncompat: Compat\nThis function is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\nThis function counts only the constraints added with @NLconstraint and add_nonlinear_constraint. It does not count GenericNonlinearExpr constraints.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#register","page":"JuMP","title":"register","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.register","category":"page"},{"location":"api/JuMP/#JuMP.register","page":"JuMP","title":"JuMP.register","text":"register(\n    model::Model,\n    op::Symbol,\n    dimension::Integer,\n    f::Function;\n    autodiff:Bool = false,\n)\n\nRegister the user-defined function f that takes dimension arguments in model as the symbol op.\n\nThe function f must support all subtypes of Real as arguments. Do not assume that the inputs are Float64.\n\ncompat: Compat\nThis function is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\nNotes\n\nFor this method, you must explicitly set autodiff = true, because no user-provided gradient function ∇f is given.\nSecond-derivative information is only computed if dimension == 1.\nop does not have to be the same symbol as f, but it is generally more readable if it is.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> f(x::T) where {T<:Real} = x^2\nf (generic function with 1 method)\n\njulia> register(model, :foo, 1, f; autodiff = true)\n\njulia> @NLobjective(model, Min, foo(x))\n\njulia> model = Model();\n\njulia> @variable(model, x[1:2])\n2-element Vector{VariableRef}:\n x[1]\n x[2]\n\njulia> g(x::T, y::T) where {T<:Real} = x * y\ng (generic function with 1 method)\n\njulia> register(model, :g, 2, g; autodiff = true)\n\njulia> @NLobjective(model, Min, g(x[1], x[2]))\n\n\n\n\n\nregister(\n    model::Model,\n    s::Symbol,\n    dimension::Integer,\n    f::Function,\n    ∇f::Function;\n    autodiff:Bool = false,\n)\n\nRegister the user-defined function f that takes dimension arguments in model as the symbol s. In addition, provide a gradient function ∇f.\n\nThe functions fand ∇f must support all subtypes of Real as arguments. Do not assume that the inputs are Float64.\n\ncompat: Compat\nThis function is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\nNotes\n\nIf the function f is univariate (that is, dimension == 1), ∇f must return a number which represents the first-order derivative of the function f.\nIf the function f is multi-variate, ∇f must have a signature matching ∇f(g::AbstractVector{T}, args::T...) where {T<:Real}, where the first argument is a vector g that is modified in-place with the gradient.\nIf autodiff = true and dimension == 1, use automatic differentiation to compute the second-order derivative information. If autodiff = false, only first-order derivative information will be used.\ns does not have to be the same symbol as f, but it is generally more readable if it is.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> f(x::T) where {T<:Real} = x^2\nf (generic function with 1 method)\n\njulia> ∇f(x::T) where {T<:Real} = 2 * x\n∇f (generic function with 1 method)\n\njulia> register(model, :foo, 1, f, ∇f; autodiff = true)\n\njulia> @NLobjective(model, Min, foo(x))\n\njulia> model = Model();\n\njulia> @variable(model, x[1:2])\n2-element Vector{VariableRef}:\n x[1]\n x[2]\n\njulia> g(x::T, y::T) where {T<:Real} = x * y\ng (generic function with 1 method)\n\njulia> function ∇g(g::AbstractVector{T}, x::T, y::T) where {T<:Real}\n           g[1] = y\n           g[2] = x\n           return\n       end\n∇g (generic function with 1 method)\n\njulia> register(model, :g, 2, g, ∇g)\n\njulia> @NLobjective(model, Min, g(x[1], x[2]))\n\n\n\n\n\nregister(\n    model::Model,\n    s::Symbol,\n    dimension::Integer,\n    f::Function,\n    ∇f::Function,\n    ∇²f::Function,\n)\n\nRegister the user-defined function f that takes dimension arguments in model as the symbol s. In addition, provide a gradient function ∇f and a hessian function ∇²f.\n\n∇f and ∇²f must return numbers corresponding to the first- and second-order derivatives of the function f respectively.\n\ncompat: Compat\nThis function is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\nNotes\n\nBecause automatic differentiation is not used, you can assume the inputs are all Float64.\nThis method will throw an error if dimension > 1.\ns does not have to be the same symbol as f, but it is generally more readable if it is.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> f(x::Float64) = x^2\nf (generic function with 1 method)\n\njulia> ∇f(x::Float64) = 2 * x\n∇f (generic function with 1 method)\n\njulia> ∇²f(x::Float64) = 2.0\n∇²f (generic function with 1 method)\n\njulia> register(model, :foo, 1, f, ∇f, ∇²f)\n\njulia> @NLobjective(model, Min, foo(x))\n\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_nonlinear_dual_start_value","page":"JuMP","title":"set_nonlinear_dual_start_value","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_nonlinear_dual_start_value","category":"page"},{"location":"api/JuMP/#JuMP.set_nonlinear_dual_start_value","page":"JuMP","title":"JuMP.set_nonlinear_dual_start_value","text":"set_nonlinear_dual_start_value(\n    model::Model,\n    start::Union{Nothing,Vector{Float64}},\n)\n\nSet the value of the MOI attribute MOI.NLPBlockDualStart.\n\ncompat: Compat\nThis function is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\nThe start vector corresponds to the Lagrangian duals of the nonlinear constraints, in the order given by all_nonlinear_constraints. That is, you must pass a single start vector corresponding to all of the nonlinear constraints in a single function call; you cannot set the dual start value of nonlinear constraints one-by-one. The example below demonstrates how to use all_nonlinear_constraints to create a mapping between the nonlinear constraint references and the start vector.\n\nPass nothing to unset a previous start.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> nl1 = @NLconstraint(model, x[1] <= sqrt(x[2]));\n\njulia> nl2 = @NLconstraint(model, x[1] >= exp(x[2]));\n\njulia> start = Dict(nl1 => -1.0, nl2 => 1.0);\n\njulia> start_vector = [start[con] for con in all_nonlinear_constraints(model)]\n2-element Vector{Float64}:\n -1.0\n  1.0\n\njulia> set_nonlinear_dual_start_value(model, start_vector)\n\njulia> nonlinear_dual_start_value(model)\n2-element Vector{Float64}:\n -1.0\n  1.0\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_nonlinear_objective","page":"JuMP","title":"set_nonlinear_objective","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_nonlinear_objective","category":"page"},{"location":"api/JuMP/#JuMP.set_nonlinear_objective","page":"JuMP","title":"JuMP.set_nonlinear_objective","text":"set_nonlinear_objective(\n    model::Model,\n    sense::MOI.OptimizationSense,\n    expr::Expr,\n)\n\nSet the nonlinear objective of model to the expression expr, with the optimization sense sense.\n\nThis function is most useful if the expression expr is generated programmatically, and you cannot use @NLobjective.\n\ncompat: Compat\nThis function is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\nNotes\n\nYou must interpolate the variables directly into the expression expr.\nYou must use MIN_SENSE or MAX_SENSE instead of Min and Max.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x);\n\njulia> set_nonlinear_objective(model, MIN_SENSE, :($(x) + $(x)^2))\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_optimizer_attribute","page":"JuMP","title":"set_optimizer_attribute","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_optimizer_attribute","category":"page"},{"location":"api/JuMP/#JuMP.set_optimizer_attribute","page":"JuMP","title":"JuMP.set_optimizer_attribute","text":"set_optimizer_attribute(\n    model::Union{GenericModel,MOI.OptimizerWithAttributes},\n    attr::Union{AbstractString,MOI.AbstractOptimizerAttribute},\n    value,\n)\n\nSet the solver-specific attribute attr in model to value.\n\nIf attr is an AbstractString, this is equivalent to set_optimizer_attribute(model, MOI.RawOptimizerAttribute(name), value).\n\ncompat: Compat\nThis method will remain in all v1.X releases of JuMP, but it may be removed in a future v2.0 release. We recommend using set_attribute instead.\n\nSee also: set_optimizer_attributes, get_optimizer_attribute.\n\nExample\n\njulia> model = Model();\n\njulia> set_optimizer_attribute(model, MOI.Silent(), true)\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#set_value","page":"JuMP","title":"set_value","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.set_value","category":"page"},{"location":"api/JuMP/#JuMP.set_value","page":"JuMP","title":"JuMP.set_value","text":"set_value(p::NonlinearParameter, v::Number)\n\nStore the value v in the nonlinear parameter p.\n\ncompat: Compat\nThis function is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\nExample\n\njulia> model = Model();\n\njulia> @NLparameter(model, p == 0)\np == 0.0\n\njulia> set_value(p, 5)\n5\n\njulia> value(p)\n5.0\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP/#NonlinearConstraintIndex","page":"JuMP","title":"NonlinearConstraintIndex","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.NonlinearConstraintIndex","category":"page"},{"location":"api/JuMP/#JuMP.NonlinearConstraintIndex","page":"JuMP","title":"JuMP.NonlinearConstraintIndex","text":"ConstraintIndex\n\nAn index to a nonlinear constraint that is returned by add_constraint.\n\nGiven data::Model and c::ConstraintIndex, use data[c] to retrieve the corresponding Constraint.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#NonlinearConstraintRef","page":"JuMP","title":"NonlinearConstraintRef","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.NonlinearConstraintRef","category":"page"},{"location":"api/JuMP/#JuMP.NonlinearConstraintRef","page":"JuMP","title":"JuMP.NonlinearConstraintRef","text":"NonlinearConstraintRef\n\ncompat: Compat\nThis type is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#NonlinearExpression","page":"JuMP","title":"NonlinearExpression","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.NonlinearExpression","category":"page"},{"location":"api/JuMP/#JuMP.NonlinearExpression","page":"JuMP","title":"JuMP.NonlinearExpression","text":"NonlinearExpression <: AbstractJuMPScalar\n\nA struct to represent a nonlinear expression.\n\nCreate an expression using @NLexpression.\n\ncompat: Compat\nThis type is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP/#NonlinearParameter","page":"JuMP","title":"NonlinearParameter","text":"","category":"section"},{"location":"api/JuMP/","page":"JuMP","title":"JuMP","text":"JuMP.NonlinearParameter","category":"page"},{"location":"api/JuMP/#JuMP.NonlinearParameter","page":"JuMP","title":"JuMP.NonlinearParameter","text":"NonlinearParameter <: AbstractJuMPScalar\n\nA struct to represent a nonlinear parameter.\n\nCreate a parameter using @NLparameter.\n\ncompat: Compat\nThis type is part of the legacy nonlinear interface. Consider using the new nonlinear interface documented in Nonlinear Modeling.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"EditURL = \"constraint_programming.jl\"","category":"page"},{"location":"tutorials/linear/constraint_programming/#Constraint-programming","page":"Constraint programming","title":"Constraint programming","text":"","category":"section"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"JuMP supports a range of constraint-programming type constraints via the corresponding sets in MathOptInterface. For most constraints, there are reformulations built-in that convert the constraint programming constraint into a mixed-integer programming equivalent.","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"Because of this reformulation, all variables must be integer, and they must typically have finite bounds. An error will be thrown if the reformulation requires finiteness and you have a variable with non-finite bounds.","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"using JuMP\nimport HiGHS","category":"page"},{"location":"tutorials/linear/constraint_programming/#AllDifferent","page":"Constraint programming","title":"AllDifferent","text":"","category":"section"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"The MOI.AllDifferent set ensures that every element in a list takes a different integer value.","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, 1 <= x[1:4] <= 4, Int)\n@constraint(model, x in MOI.AllDifferent(4))\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue.(x)","category":"page"},{"location":"tutorials/linear/constraint_programming/#BinPacking","page":"Constraint programming","title":"BinPacking","text":"","category":"section"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"The MOI.BinPacking set can be used to divide up a set of items into different groups, such that the sum of their weights does not exceed the capacity of a bin.","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"weights, capacity = Float64[1, 1, 2, 2, 3], 3.0;\nnumber_of_bins = 3\nmodel = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, 1 <= x[1:length(weights)] <= number_of_bins, Int)\n@constraint(model, x in MOI.BinPacking(capacity, weights))\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue.(x)","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"Here, the value of x[i] is the bin that item i was placed into.","category":"page"},{"location":"tutorials/linear/constraint_programming/#Circuit","page":"Constraint programming","title":"Circuit","text":"","category":"section"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"The MOI.Circuit set is used to construct a tour of a list of N variables. They will each be assigned an integer from 1 to N, that describes the successor to each variable in the list:","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, x[1:4], Int)\n@constraint(model, x in MOI.Circuit(4))\noptimize!(model)\n@assert is_solved_and_feasible(model)","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"Let's see what tour was found, starting at node number 1:","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"y = round.(Int, value.(x))\ntour = Int[1]\nwhile length(tour) < length(y)\n    push!(tour, y[tour[end]])\nend\ntour","category":"page"},{"location":"tutorials/linear/constraint_programming/#CountAtLeast","page":"Constraint programming","title":"CountAtLeast","text":"","category":"section"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"The MOI.CountAtLeast set is used to ensure that at least n elements in a set of variables belong to a set of values.","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"For example, here is a model with three variables, constrained between 0 and 5:","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, 0 <= x[1:3] <= 5, Int)","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"If we want to ensure that at least one element of each set {x[1], x[2]} and {x[2], x[3]} is in the set {3}, then we create a list of variables by concatenating the sets together:","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"variables = [x[1], x[2], x[2], x[3]]","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"Then we need a partition list that contains the number of elements in each set of variables:","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"partitions = [2, 2]","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"Finally, we need a set of values that the elements must be a part of:","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"values = Set([3])","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"And the number of elements that must be part of the set values:","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"n = 1","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"The constraint is:","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"@constraint(model, variables in MOI.CountAtLeast(n, partitions, values))","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"To ensure the uniqueness of the solution, we'll add a constraint that x[2] must be <= 2. This ensures that the only feasible solution is for x[1] and x[3] to be 3:","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"@constraint(model, x[2] <= 2)","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"Let's check that we found a valid solution:","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"optimize!(model)\n@assert is_solved_and_feasible(model)\nvalue.(x)","category":"page"},{"location":"tutorials/linear/constraint_programming/#CountBelongs","page":"Constraint programming","title":"CountBelongs","text":"","category":"section"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"The MOI.CountBelongs set is used to count how many elements in a set of variables belong to a set of values.","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"For example, to count how many elements in a set of 4 variables belong to the set {2, 3}, do:","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, 0 <= x[i = 1:4] <= i, Int)\n@variable(model, n, Int)\n@objective(model, Max, sum(x))\nset = Set([2, 3])\n@constraint(model, [n; x] in MOI.CountBelongs(1 + length(x), set))\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue(n), value.(x)","category":"page"},{"location":"tutorials/linear/constraint_programming/#CountDistinct","page":"Constraint programming","title":"CountDistinct","text":"","category":"section"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"The MOI.CountDistinct set is used to count the number of distinct elements in a set of variables.","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, 0 <= x[i = 1:4] <= i, Int)\n@variable(model, n, Int)\n@objective(model, Max, sum(x))\n@constraint(model, [n; x] in MOI.CountDistinct(1 + length(x)))\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue(n), value.(x)","category":"page"},{"location":"tutorials/linear/constraint_programming/#CountGreaterThan","page":"Constraint programming","title":"CountGreaterThan","text":"","category":"section"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"The MOI.CountGreaterThan set is used to strictly upper-bound the number of distinct elements in a set of variables that have a value equal to another variable.","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"For example, to count the number n of times that y appears in the vector x, use:","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, 0 <= x[i = 1:4] <= i, Int)\n@variable(model, n, Int)\n@variable(model, 3 <= y <= 4, Int)\n@objective(model, Max, sum(x))\n@constraint(model, [n; y; x] in MOI.CountGreaterThan(1 + 1 + length(x)))\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue(n), value(y), value.(x)","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"Here n is strictly greater than the count, and there is no limit on how large n could be. For example, n = 100 is also a feasible solution. The only constraint is that n cannot be equal to or smaller than the number of times that y appears.","category":"page"},{"location":"tutorials/linear/constraint_programming/#Table","page":"Constraint programming","title":"Table","text":"","category":"section"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"The MOI.Table set is used to select a single row from a matrix of values.","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"For example, given a matrix:","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"table = Float64[1 1 0; 0 1 1; 1 0 1; 1 1 1]","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"we can constraint a 3-element vector x to equal one of the rows in table via:","category":"page"},{"location":"tutorials/linear/constraint_programming/","page":"Constraint programming","title":"Constraint programming","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, x[i = 1:3], Int)\n@constraint(model, x in MOI.Table(table))\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue.(x)","category":"page"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"EditURL = \"https://github.com/oxfordcontrol/COSMO.jl/blob/v0.8.9/README.md\"","category":"page"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"<div style=\"display: flex; justify-content: flex-end\" margin=0px>\n    <img src=\"https://github.com/migarstka/COSMO_assets/blob/master/star_badge_3.png?raw=true\" align=\"right\" width=6%>\n</div>","category":"page"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"<h1 align=\"center\" margin=0px>\n  <img src=\"https://github.com/migarstka/COSMO_assets/blob/master/cosmo_rocket_with_convex_set.png?raw=true\" width=70%>\n</h1>","category":"page"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"<p align=\"center\">\n   <a href=\"https://github.com/oxfordcontrol/COSMO.jl/actions\"><img src=\"https://github.com/oxfordcontrol/COSMO.jl/workflows/ci/badge.svg?branch=master\"></a>\n  <a href=\"https://codecov.io/gh/oxfordcontrol/COSMO.jl\"><img src=\"https://codecov.io/gh/oxfordcontrol/COSMO.jl/branch/master/graph/badge.svg?raw=true\"></a>\n  <a href=\"https://oxfordcontrol.github.io/COSMO.jl/stable\"><img src=\"https://img.shields.io/badge/Documentation-stable-purple.svg?raw=true\"></a>\n  <a href=\"https://opensource.org/licenses/Apache-2.0\"><img src=\"https://img.shields.io/badge/License-Apache%202.0-blue.svg?raw=true\"></a>\n  <a href=\"https://github.com/oxfordcontrol/COSMO.jl/releases\"><img src=\"https://img.shields.io/badge/Release-v0.8.9-blue.svg?raw=true\"></a>\n</p>","category":"page"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"<p align=\"center\">\n  <a href=\"#features\">Features</a> •\n  <a href=\"#installation\">Installation</a> •\n  <a href=\"NEWS.md\">News</a> •\n  <a href=\"#citing-\">Citing</a> •\n  <a href=\"#contributing\">Contributing</a>\n</p>","category":"page"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"This is a Julia implementation of the Conic operator splitting method (COSMO) solver. It can solve large convex conic optimization problems of the following form:","category":"page"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"<p align=\"center\">\n<img src=\"https://github.com/migarstka/COSMO_assets/blob/master/cosmo_format.png?raw=true\" width=220px>\n</p>","category":"page"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"with decision variables x ϵ R^n, s ϵ R^m and data matrices P=P'>=0, q ϵ R^n, A ϵ R^(m×n), and b ϵ R^m. The convex set K is a composition of convex sets and cones.","category":"page"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"For more information take a look at the COSMO.jl Documentation (stable |  dev).","category":"page"},{"location":"packages/COSMO/#Features","page":"oxfordcontrol/COSMO.jl","title":"Features","text":"","category":"section"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"Versatile: COSMO solves linear programs, quadratic programs, second-order cone programs, semidefinite programs and problems involving exponential and power cones\nQuad SDPs: Positive semidefinite programs with quadratic objective functions are natively supported\nSafeguarded acceleration: robust and faster convergence to higher precision using COSMOAccelerators\nInfeasibility detection: Infeasible problems are detected without a homogeneous self-dual embedding of the problem\nJuMP / Convex.jl support: We provide an interface to MathOptInterface (MOI), which allows you to describe your problem in JuMP and Convex.jl.\nWarm starting: COSMO supports warm starting of the decision variables\nCustom sets and linear solver: Customize COSMO's components by defining your own convex constraint sets and by choosing from a number of direct and indirect linear system solvers, for example, QDLDL, Pardiso, Conjugate Gradient and MINRES\nArbitrary precision types: You can solve problems with any floating point precision.\nOpen Source: Our code is free to use and distributed under the Apache 2.0 Licence\nChordal decomposition: COSMO tries to decompose large structured PSD constraints using chordal decomposition techniques. This often results in a significant speedup compared to the original problem.\nSmart clique merging: After an initial decomposition of a structured SDP, COSMO recombines overlapping cliques/blocks to speed up the algorithm.","category":"page"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"<div align=\"center\" margin=0px>\n  <img src=\"https://github.com/oxfordcontrol/COSMO.jl/blob/master/docs/src/assets/example_decomposition.gif?raw=true\" width=45%>\n</div>","category":"page"},{"location":"packages/COSMO/#Installation","page":"oxfordcontrol/COSMO.jl","title":"Installation","text":"","category":"section"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"COSMO can be added via the Julia package manager (type ]): pkg> add COSMO","category":"page"},{"location":"packages/COSMO/#Citing","page":"oxfordcontrol/COSMO.jl","title":"Citing","text":"","category":"section"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"If you find COSMO useful in your project, we kindly request that you cite the following paper:","category":"page"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"@Article{Garstka_2021,\n  author  = {Michael Garstka and Mark Cannon and Paul Goulart},\n  journal = {Journal of Optimization Theory and Applications},\n  title   = {{COSMO}: A Conic Operator Splitting Method for Convex Conic Problems},\n  volume  = {190},\n  number  = {3},\n  pages   = {779--810},\n  year    = {2021},\n  publisher = {Springer},\n  doi     = {10.1007/s10957-021-01896-x},\n  url     = {https://doi.org/10.1007/s10957-021-01896-x}\n}","category":"page"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"The article is available under Open Access here.","category":"page"},{"location":"packages/COSMO/#Contributing","page":"oxfordcontrol/COSMO.jl","title":"Contributing","text":"","category":"section"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"Contributions are always welcome. Our style guide can be found here.\nCurrent issues, tasks and future ideas are listed in Issues. Please report any issues or bugs that you encounter.\nAs an open source project we are also interested in any projects and applications that use COSMO. Please let us know by opening a GitHub issue.","category":"page"},{"location":"packages/COSMO/#Python-Interface","page":"oxfordcontrol/COSMO.jl","title":"Python - Interface","text":"","category":"section"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"COSMO can also be called from Python. Take a look at: cosmo-python","category":"page"},{"location":"packages/COSMO/#Licence","page":"oxfordcontrol/COSMO.jl","title":"Licence 🔍","text":"","category":"section"},{"location":"packages/COSMO/","page":"oxfordcontrol/COSMO.jl","title":"oxfordcontrol/COSMO.jl","text":"This project is licensed under the Apache License - see the LICENSE.md file for details.","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"EditURL = \"https://github.com/jump-dev/Hypatia.jl/blob/v0.8.0/README.md\"","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"<img src=\"https://github.com/jump-dev/Hypatia.jl/wiki/hypatia_logo.png?raw=true\" alt=\"Hypatia logo\" width=\"358\"/>","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"(Image: Build Status) (Image: codecov) (Image: ) (Image: )","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"Hypatia is a highly customizable open source interior point solver for generic conic optimization problems, written in Julia.","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"For more information on Hypatia, please see:","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"documentation for Hypatia's conic form, predefined cones, and interfaces\ncones reference for cone definitions and oracles\nexamples folder for applied examples and instances\nbenchmarks folder for scripts used to run and analyze various computational benchmarks","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"and preprints of our papers:","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"Solving natural conic formulations with Hypatia.jl for computational arguments for expanding the class of cones recognized by conic solvers\nPerformance enhancements for a generic conic interior point algorithm for a description of Hypatia's algorithm and our enhanced stepping procedures\nSum of squares generalizations for conic sets for barriers and computational techniques for our generalized polynomial sum of squares cones\nConic optimization with spectral functions on Euclidean Jordan algebras for barriers and computational techniques for many of our epigraph/hypograph cones","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"and corresponding raw results CSV files generated by our run scripts in the benchmarks folder.","category":"page"},{"location":"packages/Hypatia/#License","page":"jump-dev/Hypatia.jl","title":"License","text":"","category":"section"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"Hypatia is licensed under the MIT License (see LICENSE).","category":"page"},{"location":"packages/Hypatia/#Installation","page":"jump-dev/Hypatia.jl","title":"Installation","text":"","category":"section"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"To use Hypatia, install Julia, then at the Julia REPL, type:","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"using Hypatia\nusing Pkg\nPkg.add(\"Hypatia\")","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"Hypatia is an experimental solver and a work in progress, and may not run with older releases of Julia. Default options/parameters are not well-tuned, so we encourage you to experiment with these.","category":"page"},{"location":"packages/Hypatia/#Usage","page":"jump-dev/Hypatia.jl","title":"Usage","text":"","category":"section"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"Hypatia can be accessed through a low-level native Julia interface or through open-source modeling tools such as JuMP and Convex.jl. The native interface is more expressive, allowing Hypatia to solve conic models expressed with generic real floating point types and structured matrices or linear operators, for example. However, it is typically sufficient and more convenient to use JuMP.","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"Using JuMP, we can model a simple D-optimal experiment design problem and call Hypatia:","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"using LinearAlgebra\nusing JuMP\nusing Hypatia\n\nmodel = Model(() -> Hypatia.Optimizer(verbose = false))\n@variable(model, x[1:3] >= 0)\n@constraint(model, sum(x) == 5)\n@variable(model, hypo)\n@objective(model, Max, hypo)\nV = rand(2, 3)\nQ = V * diagm(x) * V'\naff = vcat(hypo, [Q[i, j] for i in 1:2 for j in 1:i]...)\n@constraint(model, aff in MOI.RootDetConeTriangle(2))\n\n# solve and query solution\noptimize!(model)\ntermination_status(model)\nobjective_value(model)\nvalue.(x)","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"See our D-optimal design example for more information and references.","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"Many more examples using the native interface or JuMP can be found in the examples folder.","category":"page"},{"location":"packages/Hypatia/#Contributing","page":"jump-dev/Hypatia.jl","title":"Contributing","text":"","category":"section"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"Comments, questions, suggestions, and improvements/extensions to the code or documentation are welcomed. Please reach out on Discourse, or submit an issue or contribute a PR on our GitHub. If contributing code, try to maintain consistent style and add docstrings or comments for clarity. New examples are welcomed and should be implemented similarly to the existing examples.","category":"page"},{"location":"packages/Hypatia/#Acknowledgements","page":"jump-dev/Hypatia.jl","title":"Acknowledgements","text":"","category":"section"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"This work has been partially funded by the National Science Foundation under grant OAC-1835443 and the Office of Naval Research under grant N00014-18-1-2079.","category":"page"},{"location":"packages/Hypatia/#Citing-Hypatia","page":"jump-dev/Hypatia.jl","title":"Citing Hypatia","text":"","category":"section"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"If you find Hypatia solver useful, please cite our solver paper:","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"@article{coey2022solving,\n    title={Solving natural conic formulations with {H}ypatia.jl},\n    author={Chris Coey and Lea Kapelevich and Juan Pablo Vielma},\n    year={2022},\n    journal={INFORMS Journal on Computing},\n    publisher={INFORMS},\n    volume={34},\n    number={5},\n    pages={2686--2699},\n    doi={https://doi.org/10.1287/ijoc.2022.1202}\n}","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"If you find aspects of Hypatia's IPM implementation useful, please cite our algorithm paper:","category":"page"},{"location":"packages/Hypatia/","page":"jump-dev/Hypatia.jl","title":"jump-dev/Hypatia.jl","text":"@article{coey2022performance,\n    title={Performance enhancements for a generic conic interior point algorithm},\n    author={Chris Coey and Lea Kapelevich and Juan Pablo Vielma},\n    year={2023},\n    journal={Mathematical Programming Computation},\n    publisher={Springer},\n    volume={15},\n    pages={53--101},\n    doi={https://doi.org/10.1007/s12532-022-00226-0}\n}","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"EditURL = \"arbitrary_precision.jl\"","category":"page"},{"location":"tutorials/conic/arbitrary_precision/#Arbitrary-precision-arithmetic","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"","category":"section"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"The purpose of this tutorial is to explain how to use a solver which supports arithmetic using a number type other than Float64.","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"using JuMP\nimport CDDLib\nimport Clarabel","category":"page"},{"location":"tutorials/conic/arbitrary_precision/#Higher-precision-arithmetic","page":"Arbitrary precision arithmetic","title":"Higher-precision arithmetic","text":"","category":"section"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"To create a model with a number type other than Float64, use GenericModel with an optimizer which supports the same number type:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"model = GenericModel{BigFloat}(Clarabel.Optimizer{BigFloat})","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"The syntax for adding decision variables is the same as a normal JuMP model, except that values are converted to BigFloat:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"@variable(model, -1 <= x[1:2] <= sqrt(big\"2\"))","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"Note that each x is now a GenericVariableRef{BigFloat}, which means that the value of x in a solution will be a BigFloat.","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"The lower and upper bounds of the decision variables are also BigFloat:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"lower_bound(x[1])","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"typeof(lower_bound(x[1]))","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"upper_bound(x[2])","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"typeof(upper_bound(x[2]))","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"The syntax for adding constraints is the same as a normal JuMP model, except that coefficients are converted to BigFloat:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"@constraint(model, c, x[1] == big\"2\" * x[2])","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"The function is a GenericAffExpr with BigFloat for the coefficient and variable types;","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"constraint = constraint_object(c)\ntypeof(constraint.func)","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"and the set is a MOI.EqualTo{BigFloat}:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"typeof(constraint.set)","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"The syntax for adding and objective is the same as a normal JuMP model, except that coefficients are converted to BigFloat:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"@objective(model, Min, 3x[1]^2 + 2x[2]^2 - x[1] - big\"4\" * x[2])","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"typeof(objective_function(model))","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"Here's the model we have built:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"print(model)","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"Let's solve and inspect the solution:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"optimize!(model)\n@assert is_solved_and_feasible(model; dual = true)\nsolution_summary(model)","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"The value of each decision variable is a BigFloat:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"value.(x)","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"as well as other solution attributes like the objective value:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"objective_value(model)","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"and dual solution:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"dual(c)","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"This problem has an analytic solution of x = [3//7, 3//14]. Currently, our solution has an error of approximately 1e-9:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"value.(x) .- [3 // 7, 3 // 14]","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"But by reducing the tolerances, we can obtain a more accurate solution:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"set_attribute(model, \"tol_gap_abs\", 1e-32)\nset_attribute(model, \"tol_gap_rel\", 1e-32)\noptimize!(model)\n@assert is_solved_and_feasible(model)\nvalue.(x) .- [3 // 7, 3 // 14]","category":"page"},{"location":"tutorials/conic/arbitrary_precision/#Rational-arithmetic","page":"Arbitrary precision arithmetic","title":"Rational arithmetic","text":"","category":"section"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"In addition to higher-precision floating point number types like BigFloat, JuMP also supports solvers with exact rational arithmetic. One example is CDDLib.jl, which supports the Rational{BigInt} number type:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"model = GenericModel{Rational{BigInt}}(CDDLib.Optimizer{Rational{BigInt}})","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"As before, we can create variables using rational bounds:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"@variable(model, 1 // 7 <= x[1:2] <= 2 // 3)","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"lower_bound(x[1])","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"typeof(lower_bound(x[1]))","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"As well as constraints:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"@constraint(model, c1, (2 // 1) * x[1] + x[2] <= 1)","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"@constraint(model, c2, x[1] + 3x[2] <= 9 // 4)","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"and objective functions:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"@objective(model, Max, sum(x))","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"Here's the model we have built:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"print(model)","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"Let's solve and inspect the solution:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"optimize!(model)\n@assert is_solved_and_feasible(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"The optimal values are given in exact rational arithmetic:","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"value.(x)","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"objective_value(model)","category":"page"},{"location":"tutorials/conic/arbitrary_precision/","page":"Arbitrary precision arithmetic","title":"Arbitrary precision arithmetic","text":"value(c2)","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/manual/standard_form.md\"","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/standard_form/#Standard-form-problem","page":"Standard form problem","title":"Standard form problem","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"MathOptInterface represents optimization problems in the standard form:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"beginalign\n     min_x in mathbbR^n  f_0(x)\n    \n     textst  f_i(x)  in mathcalS_i  i = 1 ldots m\nendalign","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"where:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"the functions f_0 f_1 ldots f_m are specified by AbstractFunction objects\nthe sets mathcalS_1 ldots mathcalS_m are specified by AbstractSet objects","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"tip: Tip\nFor more information on this standard form, read our paper.","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"MOI defines some commonly used functions and sets, but the interface is extensible to other sets recognized by the solver.","category":"page"},{"location":"moi/manual/standard_form/#Functions","page":"Standard form problem","title":"Functions","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"The function types implemented in MathOptInterface.jl are:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"Function Description\nVariableIndex x_j, the projection onto a single coordinate defined by a variable index j.\nVectorOfVariables The projection onto multiple coordinates (that is, extracting a sub-vector).\nScalarAffineFunction a^T x + b, where a is a vector and b scalar.\nScalarNonlinearFunction f(x), where f is a nonlinear function.\nVectorAffineFunction A x + b, where A is a matrix and b is a vector.\nScalarQuadraticFunction frac12 x^T Q x + a^T x + b, where Q is a symmetric matrix, a is a vector, and b is a constant.\nVectorQuadraticFunction A vector of scalar-valued quadratic functions.\nVectorNonlinearFunction f(x), where f is a vector-valued nonlinear function.","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"Extensions for nonlinear programming are present but not yet well documented.","category":"page"},{"location":"moi/manual/standard_form/#One-dimensional-sets","page":"Standard form problem","title":"One-dimensional sets","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"The one-dimensional set types implemented in MathOptInterface.jl are:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"Set Description\nLessThan(u) (-infty u\nGreaterThan(l) l infty)\nEqualTo(v) v\nInterval(l, u) l u\nInteger() mathbbZ\nZeroOne()  0 1 \nSemicontinuous(l, u)  0 cup l u\nSemiinteger(l, u)  0 cup ll+1ldotsu-1u","category":"page"},{"location":"moi/manual/standard_form/#Vector-cones","page":"Standard form problem","title":"Vector cones","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"The vector-valued set types implemented in MathOptInterface.jl are:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"Set Description\nReals(d) mathbbR^d\nZeros(d) 0^d\nNonnegatives(d)  x in mathbbR^d  x ge 0 \nNonpositives(d)  x in mathbbR^d  x le 0 \nSecondOrderCone(d)  (tx) in mathbbR^d  t ge lVert x rVert_2 \nRotatedSecondOrderCone(d)  (tux) in mathbbR^d  2tu ge lVert x rVert_2^2 t ge 0u ge 0 \nExponentialCone()  (xyz) in mathbbR^3  y exp (xy) le z y  0 \nDualExponentialCone()  (uvw) in mathbbR^3  -u exp (vu) le exp(1) w u  0 \nGeometricMeanCone(d)  (tx) in mathbbR^1+n  x ge 0 t le sqrtnx_1 x_2 cdots x_n  where n is d - 1\nPowerCone(α)  (xyz) in mathbbR^3  x^alpha y^1-alpha ge z x ge 0y ge 0 \nDualPowerCone(α)  (uvw) in mathbbR^3  left(fracualpharight)^alphaleft(fracv1-alpharight)^1-alpha ge w uv ge 0 \nNormOneCone(d)  (tx) in mathbbR^d  t ge sum_i lvert x_i rvert \nNormInfinityCone(d)  (tx) in mathbbR^d  t ge max_i lvert x_i rvert \nRelativeEntropyCone(d)  (u v w) in mathbbR^d  u ge sum_i w_i log (fracw_iv_i) v_i ge 0 w_i ge 0 \nHyperRectangle(l, u) x in barmathbbR^d x_i in l_i u_i forall i=1ldotsd\nNormCone(p, d)  (tx) in mathbbR^d  t ge left(sumlimits_i lvert x_i rvert^pright)^frac1p ","category":"page"},{"location":"moi/manual/standard_form/#Matrix-cones","page":"Standard form problem","title":"Matrix cones","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"The matrix-valued set types implemented in MathOptInterface.jl are:","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"Set Description\nRootDetConeTriangle(d)  (tX) in mathbbR^1+d(1+d)2  t le det(X)^1d X mbox is the upper triangle of a PSD matrix \nRootDetConeSquare(d)  (tX) in mathbbR^1+d^2  t le det(X)^1d X mbox is a PSD matrix \nPositiveSemidefiniteConeTriangle(d)  X in mathbbR^d(d+1)2  X mbox is the upper triangle of a PSD matrix \nPositiveSemidefiniteConeSquare(d)  X in mathbbR^d^2  X mbox is a PSD matrix \nLogDetConeTriangle(d)  (tuX) in mathbbR^2+d(1+d)2  t le ulog(det(Xu)) X mbox is the upper triangle of a PSD matrix u  0  \nLogDetConeSquare(d)  (tuX) in mathbbR^2+d^2  t le u log(det(Xu)) X mbox is a PSD matrix u  0 \nNormSpectralCone(r, c)  (t X) in mathbbR^1 + r times c  t ge sigma_1(X) X mbox is a  rtimes cmbox matrix \nNormNuclearCone(r, c)  (t X) in mathbbR^1 + r times c  t ge sum_i sigma_i(X) X mbox is a  rtimes cmbox matrix \nHermitianPositiveSemidefiniteConeTriangle(d) The cone of Hermitian positive semidefinite matrices, with\nside_dimension rows and columns. \nScaled(S) The set S scaled so that Utilities.set_dot corresponds to LinearAlgebra.dot","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"Some of these cones can take two forms: XXXConeTriangle and XXXConeSquare.","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"In XXXConeTriangle sets, the matrix is assumed to be symmetric, and the elements are provided by a vector, in which the entries of the upper-right triangular part of the matrix are given column by column (or equivalently, the entries of the lower-left triangular part are given row by row).","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"In XXXConeSquare sets, the entries of the matrix are given column by column (or equivalently, row by row), and the matrix is constrained to be symmetric. As an example, given a 2-by-2 matrix of variables X and a one-dimensional variable t, we can specify a root-det constraint as [t, X11, X12, X22] ∈ RootDetConeTriangle or [t, X11, X12, X21, X22] ∈ RootDetConeSquare.","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"We provide both forms to enable flexibility for solvers who may natively support one or the other. Transformations between XXXConeTriangle and XXXConeSquare are handled by bridges, which removes the chance of conversion mistakes by users or solver developers.","category":"page"},{"location":"moi/manual/standard_form/#Multi-dimensional-sets-with-combinatorial-structure","page":"Standard form problem","title":"Multi-dimensional sets with combinatorial structure","text":"","category":"section"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"Other sets are vector-valued, with a particular combinatorial structure. Read their docstrings for more information on how to interpret them.","category":"page"},{"location":"moi/manual/standard_form/","page":"Standard form problem","title":"Standard form problem","text":"Set Description\nSOS1 A Special Ordered Set (SOS) of Type I\nSOS2 A Special Ordered Set (SOS) of Type II\nIndicator A set to specify an indicator constraint\nComplements A set to specify a mixed complementarity constraint\nAllDifferent The all_different global constraint\nBinPacking The bin_packing global constraint\nCircuit The circuit global constraint\nCountAtLeast The at_least global constraint\nCountBelongs The nvalue global constraint\nCountDistinct The distinct global constraint\nCountGreaterThan The count_gt global constraint\nCumulative The cumulative global constraint\nPath The path global constraint\nTable The table global constraint","category":"page"},{"location":"moi/reference/variables/","page":"Variables","title":"Variables","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/reference/variables.md\"","category":"page"},{"location":"moi/reference/variables/","page":"Variables","title":"Variables","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"moi/reference/variables/#Functions","page":"Variables","title":"Functions","text":"","category":"section"},{"location":"moi/reference/variables/","page":"Variables","title":"Variables","text":"add_variable\nadd_variables\nadd_constrained_variable\nadd_constrained_variables\nsupports_add_constrained_variable\nsupports_add_constrained_variables\nis_valid(::ModelLike,::VariableIndex)\ndelete(::ModelLike, ::VariableIndex)\ndelete(::ModelLike, ::Vector{VariableIndex})","category":"page"},{"location":"moi/reference/variables/#MathOptInterface.add_variable","page":"Variables","title":"MathOptInterface.add_variable","text":"add_variable(model::ModelLike)::VariableIndex\n\nAdd a scalar variable to the model, returning a variable index.\n\nA AddVariableNotAllowed error is thrown if adding variables cannot be done in the current state of the model model.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.add_variables","page":"Variables","title":"MathOptInterface.add_variables","text":"add_variables(model::ModelLike, n::Int)::Vector{VariableIndex}\n\nAdd n scalar variables to the model, returning a vector of variable indices.\n\nA AddVariableNotAllowed error is thrown if adding variables cannot be done in the current state of the model model.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.add_constrained_variable","page":"Variables","title":"MathOptInterface.add_constrained_variable","text":"add_constrained_variable(\n    model::ModelLike,\n    set::AbstractScalarSet\n)::Tuple{MOI.VariableIndex,\n         MOI.ConstraintIndex{MOI.VariableIndex, typeof(set)}}\n\nAdd to model a scalar variable constrained to belong to set, returning the index of the variable created and the index of the constraint constraining the variable to belong to set.\n\nBy default, this function falls back to creating a free variable with add_variable and then constraining it to belong to set with add_constraint.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.add_constrained_variables","page":"Variables","title":"MathOptInterface.add_constrained_variables","text":"add_constrained_variables(\n    model::ModelLike,\n    sets::AbstractVector{<:AbstractScalarSet}\n)::Tuple{\n    Vector{MOI.VariableIndex},\n    Vector{MOI.ConstraintIndex{MOI.VariableIndex,eltype(sets)}},\n}\n\nAdd to model scalar variables constrained to belong to sets, returning the indices of the variables created and the indices of the constraints constraining the variables to belong to each set in sets. That is, if it returns variables and constraints, constraints[i] is the index of the constraint constraining variable[i] to belong to sets[i].\n\nBy default, this function falls back to calling add_constrained_variable on each set.\n\n\n\n\n\nadd_constrained_variables(\n    model::ModelLike,\n    set::AbstractVectorSet,\n)::Tuple{\n    Vector{MOI.VariableIndex},\n    MOI.ConstraintIndex{MOI.VectorOfVariables,typeof(set)},\n}\n\nAdd to model a vector of variables constrained to belong to set, returning the indices of the variables created and the index of the constraint constraining the vector of variables to belong to set.\n\nBy default, this function falls back to creating free variables with add_variables and then constraining it to belong to set with add_constraint.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.supports_add_constrained_variable","page":"Variables","title":"MathOptInterface.supports_add_constrained_variable","text":"supports_add_constrained_variable(\n    model::ModelLike,\n    S::Type{<:AbstractScalarSet}\n)::Bool\n\nReturn a Bool indicating whether model supports constraining a variable to belong to a set of type S either on creation of the variable with add_constrained_variable or after the variable is created with add_constraint.\n\nBy default, this function falls back to supports_add_constrained_variables(model, Reals) && supports_constraint(model, MOI.VariableIndex, S) which is the correct definition for most models.\n\nExample\n\nSuppose that a solver supports only two kind of variables: binary variables and continuous variables with a lower bound. If the solver decides not to support VariableIndex-in-Binary and VariableIndex-in-GreaterThan constraints, it only has to implement add_constrained_variable for these two sets which prevents the user to add both a binary constraint and a lower bound on the same variable. Moreover, if the user adds a VariableIndex-in-GreaterThan constraint, implementing this interface (that is, supports_add_constrained_variables) enables the constraint to be transparently bridged into a supported constraint.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.supports_add_constrained_variables","page":"Variables","title":"MathOptInterface.supports_add_constrained_variables","text":"supports_add_constrained_variables(\n    model::ModelLike,\n    S::Type{<:AbstractVectorSet}\n)::Bool\n\nReturn a Bool indicating whether model supports constraining a vector of variables to belong to a set of type S either on creation of the vector of variables with add_constrained_variables or after the variable is created with add_constraint.\n\nBy default, if S is Reals then this function returns true and otherwise, it falls back to supports_add_constrained_variables(model, Reals) && supports_constraint(model, MOI.VectorOfVariables, S) which is the correct definition for most models.\n\nExample\n\nIn the standard conic form (see Duality), the variables are grouped into several cones and the constraints are affine equality constraints. If Reals is not one of the cones supported by the solvers then it needs to implement supports_add_constrained_variables(::Optimizer, ::Type{Reals}) = false as free variables are not supported. The solvers should then implement supports_add_constrained_variables(::Optimizer, ::Type{<:SupportedCones}) = true where SupportedCones is the union of all cone types that are supported; it does not have to implement the method supports_constraint(::Type{VectorOfVariables}, Type{<:SupportedCones}) as it should return false and it's the default. This prevents the user to constrain the same variable in two different cones. When a VectorOfVariables-in-S is added, the variables of the vector have already been created so they already belong to given cones. If bridges are enabled, the constraint will therefore be bridged by adding slack variables in S and equality constraints ensuring that the slack variables are equal to the corresponding variables of the given constraint function.\n\nNote that there may also be sets for which !supports_add_constrained_variables(model, S) and supports_constraint(model, MOI.VectorOfVariables, S). For instance, suppose a solver supports positive semidefinite variable constraints and two types of variables: binary variables and nonnegative variables. Then the solver should support adding VectorOfVariables-in-PositiveSemidefiniteConeTriangle constraints, but it should not support creating variables constrained to belong to the PositiveSemidefiniteConeTriangle because the variables in PositiveSemidefiniteConeTriangle should first be created as either binary or non-negative.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/variables/#MathOptInterface.is_valid-Tuple{MathOptInterface.ModelLike, MathOptInterface.VariableIndex}","page":"Variables","title":"MathOptInterface.is_valid","text":"is_valid(model::ModelLike, index::Index)::Bool\n\nReturn a Bool indicating whether this index refers to a valid object in the model model.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/variables/#MathOptInterface.delete-Tuple{MathOptInterface.ModelLike, MathOptInterface.VariableIndex}","page":"Variables","title":"MathOptInterface.delete","text":"delete(model::ModelLike, index::Index)\n\nDelete the referenced object from the model. Throw DeleteNotAllowed if if index cannot be deleted.\n\nThe following modifications also take effect if Index is VariableIndex:\n\nIf index used in the objective function, it is removed from the function, that is, it is substituted for zero.\nFor each func-in-set constraint of the model:\nIf func isa VariableIndex and func == index then the constraint is deleted.\nIf func isa VectorOfVariables and index in func.variables then\nif length(func.variables) == 1 is one, the constraint is deleted;\nif length(func.variables) > 1 and supports_dimension_update(set) then then the variable is removed from func and set is replaced by update_dimension(set, MOI.dimension(set) - 1).\nOtherwise, a DeleteNotAllowed error is thrown.\nOtherwise, the variable is removed from func, that is, it is substituted for zero.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/variables/#MathOptInterface.delete-Tuple{MathOptInterface.ModelLike, Vector{MathOptInterface.VariableIndex}}","page":"Variables","title":"MathOptInterface.delete","text":"delete(model::ModelLike, indices::Vector{R<:Index}) where {R}\n\nDelete the referenced objects in the vector indices from the model. It may be assumed that R is a concrete type. The default fallback sequentially deletes the individual items in indices, although specialized implementations may be more efficient.\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/variables/#Attributes","page":"Variables","title":"Attributes","text":"","category":"section"},{"location":"moi/reference/variables/","page":"Variables","title":"Variables","text":"AbstractVariableAttribute\nVariableName\nVariablePrimalStart\nVariablePrimal\nVariableBasisStatus","category":"page"},{"location":"moi/reference/variables/#MathOptInterface.AbstractVariableAttribute","page":"Variables","title":"MathOptInterface.AbstractVariableAttribute","text":"AbstractVariableAttribute\n\nAbstract supertype for attribute objects that can be used to set or get attributes (properties) of variables in the model.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/variables/#MathOptInterface.VariableName","page":"Variables","title":"MathOptInterface.VariableName","text":"VariableName()\n\nA variable attribute for a string identifying the variable. It is valid for two variables to have the same name; however, variables with duplicate names cannot be looked up using get. It has a default value of \"\" if not set`.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/variables/#MathOptInterface.VariablePrimalStart","page":"Variables","title":"MathOptInterface.VariablePrimalStart","text":"VariablePrimalStart()\n\nA variable attribute for the initial assignment to some primal variable's value that the optimizer may use to warm-start the solve. May be a number or nothing (unset).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/variables/#MathOptInterface.VariablePrimal","page":"Variables","title":"MathOptInterface.VariablePrimal","text":"VariablePrimal(result_index::Int = 1)\n\nA variable attribute for the assignment to some primal variable's value in result result_index. If result_index is omitted, it is 1 by default.\n\nIf the solver does not have a primal value for the variable because the result_index is beyond the available solutions (whose number is indicated by the ResultCount attribute), getting this attribute must throw a ResultIndexBoundsError. Otherwise, if the result is unavailable for another reason (for instance, only a dual solution is available), the result is undefined. Users should first check PrimalStatus before accessing the VariablePrimal attribute.\n\nSee ResultCount for information on how the results are ordered.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/variables/#MathOptInterface.VariableBasisStatus","page":"Variables","title":"MathOptInterface.VariableBasisStatus","text":"VariableBasisStatus(result_index::Int = 1)\n\nA variable attribute for the BasisStatusCode of a variable in result result_index, with respect to an available optimal solution basis.\n\nIf the solver does not have a basis status for the variable because the result_index is beyond the available solutions (whose number is indicated by the ResultCount attribute), getting this attribute must throw a ResultIndexBoundsError. Otherwise, if the result is unavailable for another reason (for instance, only a dual solution is available), the result is undefined. Users should first check PrimalStatus before accessing the VariableBasisStatus attribute.\n\nSee ResultCount for information on how the results are ordered.\n\n\n\n\n\n","category":"type"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"EditURL = \"https://github.com/jump-dev/Ipopt.jl/blob/v1.6.2/README.md\"","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"(Image: )","category":"page"},{"location":"packages/Ipopt/#Ipopt.jl","page":"jump-dev/Ipopt.jl","title":"Ipopt.jl","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"Ipopt.jl is a wrapper for the Ipopt solver.","category":"page"},{"location":"packages/Ipopt/#Affiliation","page":"jump-dev/Ipopt.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"This wrapper is maintained by the JuMP community and is not a COIN-OR project.","category":"page"},{"location":"packages/Ipopt/#License","page":"jump-dev/Ipopt.jl","title":"License","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"Ipopt.jl is licensed under the MIT License.","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"The underlying solver, coin-or/Ipopt, is licensed under the Eclipse public license.","category":"page"},{"location":"packages/Ipopt/#Installation","page":"jump-dev/Ipopt.jl","title":"Installation","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"Install Ipopt.jl using the Julia package manager:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"import Pkg\nPkg.add(\"Ipopt\")","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"In addition to installing the Ipopt.jl package, this will also download and install the Ipopt binaries. You do not need to install Ipopt separately.","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"To use a custom binary, read the Custom solver binaries section of the JuMP documentation.","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"For details on using a different linear solver, see the Linear Solvers section below. You do not need a custom binary to change the linear solver.","category":"page"},{"location":"packages/Ipopt/#Use-with-JuMP","page":"jump-dev/Ipopt.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"You can use Ipopt with JuMP as follows:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"using JuMP, Ipopt\nmodel = Model(Ipopt.Optimizer)\nset_attribute(model, \"max_cpu_time\", 60.0)\nset_attribute(model, \"print_level\", 0)","category":"page"},{"location":"packages/Ipopt/#MathOptInterface-API","page":"jump-dev/Ipopt.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"The Ipopt optimizer supports the following constraints and attributes.","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"List of supported objective functions:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}\nMOI.ObjectiveFunction{MOI.ScalarNonlinearFunction}\nMOI.ObjectiveFunction{MOI.ScalarQuadraticFunction{Float64}}\nMOI.ObjectiveFunction{MOI.VariableIndex}","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"MOI.Reals\nMOI.Parameter{Float64}","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"MOI.ScalarAffineFunction{Float64} in MOI.EqualTo{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.Interval{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.LessThan{Float64}\nMOI.ScalarNonlinearFunction in MOI.EqualTo{Float64}\nMOI.ScalarNonlinearFunction in MOI.GreaterThan{Float64}\nMOI.ScalarNonlinearFunction in MOI.Interval{Float64}\nMOI.ScalarNonlinearFunction in MOI.LessThan{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.EqualTo{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.Interval{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.EqualTo{Float64}\nMOI.VariableIndex in MOI.GreaterThan{Float64}\nMOI.VariableIndex in MOI.Interval{Float64}\nMOI.VariableIndex in MOI.LessThan{Float64}","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"MOI.BarrierIterations\nMOI.NLPBlock\nMOI.NLPBlockDualStart\nMOI.Name\nMOI.ObjectiveSense\nMOI.SolveTimeSec","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"List of supported optimizer attributes:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"MOI.AutomaticDifferentiationBackend","category":"page"},{"location":"packages/Ipopt/#Options","page":"jump-dev/Ipopt.jl","title":"Options","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"Supported options are listed in the Ipopt documentation.","category":"page"},{"location":"packages/Ipopt/#Solver-specific-callbacks","page":"jump-dev/Ipopt.jl","title":"Solver-specific callbacks","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"Ipopt provides a callback that can be used to log the status of the optimization during a solve. It can also be used to terminate the optimization by returning false. Here is an example:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"using JuMP, Ipopt, Test\nmodel = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, x >= 1)\n@objective(model, Min, x + 0.5)\nx_vals = Float64[]\nfunction my_callback(\n   alg_mod::Cint,\n   iter_count::Cint,\n   obj_value::Float64,\n   inf_pr::Float64,\n   inf_du::Float64,\n   mu::Float64,\n   d_norm::Float64,\n   regularization_size::Float64,\n   alpha_du::Float64,\n   alpha_pr::Float64,\n   ls_trials::Cint,\n)\n   push!(x_vals, callback_value(model, x))\n   @test isapprox(obj_value, 1.0 * x_vals[end] + 0.5, atol = 1e-1)\n   # return `true` to keep going, or `false` to terminate the optimization.\n   return iter_count < 1\nend\nMOI.set(model, Ipopt.CallbackFunction(), my_callback)\noptimize!(model)\n@test MOI.get(model, MOI.TerminationStatus()) == MOI.INTERRUPTED\n@test length(x_vals) == 2","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"See the Ipopt documentation for an explanation of the arguments to the callback. They are identical to the output contained in the logging table printed to the screen.","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"To access the current solution and primal, dual, and complementarity violations of each iteration, use Ipopt.GetIpoptCurrentViolations and Ipopt.GetIpoptCurrentIterate. The two functions are identical to the ones in the Ipopt C interface.","category":"page"},{"location":"packages/Ipopt/#C-API","page":"jump-dev/Ipopt.jl","title":"C API","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"Ipopt.jl wraps the Ipopt C interface with minimal modifications.","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"A complete example is available in the test/C_wrapper.jl file.","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"For simplicity, the five callbacks required by Ipopt are slightly different to the C interface. They are as follows:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"\"\"\"\n   eval_f(x::Vector{Float64})::Float64\n\nReturns the objective value `f(x)`.\n\"\"\"\nfunction eval_f end\n\n\"\"\"\n   eval_grad_f(x::Vector{Float64}, grad_f::Vector{Float64})::Nothing\n\nFills `grad_f` in-place with the gradient of the objective function evaluated at\n`x`.\n\"\"\"\nfunction eval_grad_f end\n\n\"\"\"\n   eval_g(x::Vector{Float64}, g::Vector{Float64})::Nothing\n\nFills `g` in-place with the value of the constraints evaluated at `x`.\n\"\"\"\nfunction eval_g end\n\n\"\"\"\n   eval_jac_g(\n      x::Vector{Float64},\n      rows::Vector{Cint},\n      cols::Vector{Cint},\n      values::Union{Nothing,Vector{Float64}},\n   )::Nothing\n\nCompute the Jacobian matrix.\n\n* If `values === nothing`\n   - Fill `rows` and `cols` with the 1-indexed sparsity structure\n* Otherwise:\n   - Fill `values` with the elements of the Jacobian matrix according to the\n     sparsity structure.\n\n!!! warning\n    If `values === nothing`, `x` is an undefined object. Accessing any elements\n    in it will cause Julia to segfault.\n\"\"\"\nfunction eval_jac_g end\n\n\"\"\"\n   eval_h(\n      x::Vector{Float64},\n      rows::Vector{Cint},\n      cols::Vector{Cint},\n      obj_factor::Float64,\n      lambda::Float64,\n      values::Union{Nothing,Vector{Float64}},\n   )::Nothing\n\nCompute the Hessian-of-the-Lagrangian matrix.\n\n* If `values === nothing`\n   - Fill `rows` and `cols` with the 1-indexed sparsity structure\n* Otherwise:\n   - Fill `values` with the Hessian matrix according to the sparsity structure.\n\n!!! warning\n    If `values === nothing`, `x` is an undefined object. Accessing any elements\n    in it will cause Julia to segfault.\n\"\"\"\nfunction eval_h end","category":"page"},{"location":"packages/Ipopt/#INVALID_MODEL-error","page":"jump-dev/Ipopt.jl","title":"INVALID_MODEL error","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"If you get a termination status MOI.INVALID_MODEL, it is probably because you have some undefined value in your model, for example, a division by zero. Fix this by removing the division, or by imposing variable bounds so that you cut off the undefined region.","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"Instead of","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"model = Model(Ipopt.Optimizer)\n@variable(model, x)\n@NLobjective(model, 1 / x)","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"do","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"model = Model(Ipopt.Optimizer)\n@variable(model, x >= 0.0001)\n@NLobjective(model, 1 / x)","category":"page"},{"location":"packages/Ipopt/#Linear-Solvers","page":"jump-dev/Ipopt.jl","title":"Linear Solvers","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"To improve performance, Ipopt supports a number of linear solvers.","category":"page"},{"location":"packages/Ipopt/#HSL","page":"jump-dev/Ipopt.jl","title":"HSL","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"Obtain a license and download HSL_jll.jl from https://licences.stfc.ac.uk/product/libhsl.","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"There are two versions available: LBT and OpenBLAS. LBT is the recommended option for Julia ≥ v1.9.","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"Install this download into your current environment using:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"import Pkg\nPkg.develop(path = \"/full/path/to/HSL_jll.jl\")","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"Then, use a linear solver in HSL by setting the hsllib and linear_solver attributes:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"using JuMP, Ipopt\nimport HSL_jll\nmodel = Model(Ipopt.Optimizer)\nset_attribute(model, \"hsllib\", HSL_jll.libhsl_path)\nset_attribute(model, \"linear_solver\", \"ma86\")","category":"page"},{"location":"packages/Ipopt/#macOS-users","page":"jump-dev/Ipopt.jl","title":"macOS users","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"Due to the security policy of macOS, Mac users may need to delete the quarantine attribute of the ZIP archive before extracting. For example:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"xattr -d com.apple.quarantine lbt_HSL_jll.jl-2023.11.7.zip\nxattr -d com.apple.quarantine openblas_HSL_jll.jl-2023.11.7.zip","category":"page"},{"location":"packages/Ipopt/#Pardiso","page":"jump-dev/Ipopt.jl","title":"Pardiso","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"Download Pardiso from https://www.pardiso-project.org. Save the shared library somewhere, and record the filename.","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"Then, use Pardiso by setting the pardisolib and linear_solver attributes:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"using JuMP, Ipopt\nmodel = Model(Ipopt.Optimizer)\nset_attribute(model, \"pardisolib\", \"/full/path/to/libpardiso\")\nset_attribute(model, \"linear_solver\", \"pardiso\")","category":"page"},{"location":"packages/Ipopt/#SPRAL","page":"jump-dev/Ipopt.jl","title":"SPRAL","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"If you use Ipopt.jl with Julia ≥ v1.9, the linear solver SPRAL is available. You can use it by setting the linear_solver attribute:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"using JuMP, Ipopt\nmodel = Model(Ipopt.Optimizer)\nset_attribute(model, \"linear_solver\", \"spral\")","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"Note that the following environment variables must be set before starting Julia:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"export OMP_CANCELLATION=TRUE\nexport OMP_PROC_BIND=TRUE","category":"page"},{"location":"packages/Ipopt/#BLAS-and-LAPACK","page":"jump-dev/Ipopt.jl","title":"BLAS and LAPACK","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"With Julia v1.9 or later, Ipopt and the linear solvers MUMPS (default), SPRAL, and HSL are compiled with libblastrampoline (LBT), a library that can change between BLAS and LAPACK backends at runtime.","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"The default BLAS and LAPACK backend is OpenBLAS.","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"Using LBT, we can also switch dynamically to other BLAS backends such as Intel MKL and Apple Accelerate. Because Ipopt and the linear solvers heavily rely on BLAS and LAPACK routines, using an optimized backend for a particular platform can improve the performance.","category":"page"},{"location":"packages/Ipopt/#MKL","page":"jump-dev/Ipopt.jl","title":"MKL","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"If you have MKL.jl installed, switch to MKL by adding using MKL to your code:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"using MKL  # Replace OpenBLAS by Intel MKL\nusing Ipopt","category":"page"},{"location":"packages/Ipopt/#AppleAccelerate","page":"jump-dev/Ipopt.jl","title":"AppleAccelerate","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"If you are using macOS ≥ v13.4 and you have AppleAccelerate.jl installed, add using AppleAccelerate to your code:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"using AppleAccelerate  # Replace OpenBLAS by Apple Accelerate\nusing Ipopt","category":"page"},{"location":"packages/Ipopt/#Display-backends","page":"jump-dev/Ipopt.jl","title":"Display backends","text":"","category":"section"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"Check what backends are loaded using:","category":"page"},{"location":"packages/Ipopt/","page":"jump-dev/Ipopt.jl","title":"jump-dev/Ipopt.jl","text":"import LinearAlgebra\nLinearAlgebra.BLAS.lbt_get_config()","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/release_notes.md\"","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"CurrentModule = MathOptInterface","category":"page"},{"location":"moi/release_notes/#Release-notes","page":"Release notes","title":"Release notes","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"moi/release_notes/#[v1.29.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.29.0)-(April-19,-2024)","page":"Release notes","title":"v1.29.0 (April 19, 2024)","text":"","category":"section"},{"location":"moi/release_notes/#Added","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added support for Indicator constraints in FileFormats.LP (#2483)","category":"page"},{"location":"moi/release_notes/#Fixed","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"The CBF writer now attempts to write VectorOfVariables constraints in the VAR section, instead of automatically promoting them to VectorAffineFunction. (#2478) (#2482) (#2486)\nFixed a performance issue adding ScalarAffineFunction and ScalarQuadraticFunctions to Nonlinear.Model (@2487)\nFixed a bug reading MPS files with integer variables and an entry in the BOUNDS section (#2490)\nFixed the MPS writer to use LI and UI instead of LO and UP for integer variables (#2492)","category":"page"},{"location":"moi/release_notes/#Other","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Updated versions in CI (#2484) (#2489)\nFixed duplicate names in tests (#2485)","category":"page"},{"location":"moi/release_notes/#[v1.28.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.28.1)-(April-13,-2024)","page":"Release notes","title":"v1.28.1 (April 13, 2024)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-2","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug reading MPS files with integer variables and no corresponding entry in the BOUNDS section (#2480)","category":"page"},{"location":"moi/release_notes/#[v1.28.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.28.0)-(April-11,-2024)","page":"Release notes","title":"v1.28.0 (April 11, 2024)","text":"","category":"section"},{"location":"moi/release_notes/#Added-2","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added Bridges.Constraint.ComplexNormInfinityToSecondOrderConeBridge (#2451)","category":"page"},{"location":"moi/release_notes/#Fixed-3","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a correctness bug getting the set of a constraint that used both variable and constraint bridges (#2464) (#2472)\nFixed MethodError in some bridges when called with Complex-valued functions (#2468) (#2475)\nFixed reading MPS files that use * as the start of a name and not as a comment (#2470)","category":"page"},{"location":"moi/release_notes/#Other-2","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Updated solver-tests.yml (#2465)\nRemoved two unused methods from MOI.Bridges (#2466)\nDocumentation updates (#2467), (#2473), (#2474)\nSimplify reading CBF files (#2476)","category":"page"},{"location":"moi/release_notes/#[v1.27.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.27.1)-(March-27,-2024)","page":"Release notes","title":"v1.27.1 (March 27, 2024)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-4","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed passing non-IndexMap in Utilities.pass_attributes (#2458)\nFixed getting MOI.ListOfConstraintAttributesSet for VectorOfConstraints (#2459)","category":"page"},{"location":"moi/release_notes/#Other-3","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Updated solver-tests.yml (#2453) (#2455)\nFixed path in error message (#2461)","category":"page"},{"location":"moi/release_notes/#[v1.27.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.27.0)-(February-27,-2024)","page":"Release notes","title":"v1.27.0 (February 27, 2024)","text":"","category":"section"},{"location":"moi/release_notes/#Added-3","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added support for sign(x) in Nonlinear (#2444)","category":"page"},{"location":"moi/release_notes/#Fixed-5","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed copy_to to FileFormats.NL when Name is set (#2446)","category":"page"},{"location":"moi/release_notes/#[v1.26.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.26.0)-(February-22,-2024)","page":"Release notes","title":"v1.26.0 (February 22, 2024)","text":"","category":"section"},{"location":"moi/release_notes/#Added-4","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added .initialize_timer to Nonlinear.Evaluator (#2438)","category":"page"},{"location":"moi/release_notes/#Fixed-6","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed writing binary variables with bounds in FileFormats.MPS (#2431)\nFixed parsing suffixes in FileFormats.NL (#2436)\nFixed writing free constraints in FileFormats.NL (#2437)\nFixed potential for unsafe out-of-bounds write in Hessian evaluation (#2441)","category":"page"},{"location":"moi/release_notes/#Other-4","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed formatting of BasisStatusCode docstring (#2430)\nRefactor test/Fileformats/MPS/MPS.jl (#2433)","category":"page"},{"location":"moi/release_notes/#[v1.25.3](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.25.3)-(February-14,-2024)","page":"Release notes","title":"v1.25.3 (February 14, 2024)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-7","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed number type in get_fallback (#2414)\nFixed error type thrown when a variable bridge cannot un-bridge the function. It used to throw ErrorException. It now throws MOI.GetAttributeNotAllowed{MOI.ConstraintFunction}. This enables Utilities.CachingOptimizer to more uniformly implement fallbacks for common bridges like Bridges.Variable.ZerosBridge. (#2415)\nFixed tests on upcoming Julia v1.11 (#2428)","category":"page"},{"location":"moi/release_notes/#Other-5","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Improved performance of Bridges.Constraint.CountDistinctToMILPBridge (#2416)\nImproved performance of FileFormats.MPS writer (#2421) (#2424) (#2426)\nUpdated solver-tests.yml (#2423)\nFixed typos in src/attributes.jl (#2429)","category":"page"},{"location":"moi/release_notes/#[v1.25.2](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.25.2)-(January-29,-2024)","page":"Release notes","title":"v1.25.2 (January 29, 2024)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-8","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed getting ConstraintPrimal if variable bridges are present (#2396)\nFixed modify_function! for ScalarQuadraticCoefficientChange (#2408)\nFixed writing FileFormats.MOF files if ScalarNonlinearFunction contains ScalarAffineFunction or ScalarQuadraticFunction (#2409)","category":"page"},{"location":"moi/release_notes/#Other-6","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Clarified ordering of nonlinear tape in documentation (#2401)\nUpdated vale.sh (#2403) (#2404)\nTidied `src/Utilities/results.jl (#2411)","category":"page"},{"location":"moi/release_notes/#[v1.25.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.25.1)-(January-11,-2024)","page":"Release notes","title":"v1.25.1 (January 11, 2024)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-9","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed map_indices for AbstractAutomaticDifferentiation (#2394)\nFixed deleting a variable in Bridges.Variable.VectorizeBridge (#2393)\nFixed super type of LowerBoundAlreadySet and UpperBoundAlreadySet (#2397)","category":"page"},{"location":"moi/release_notes/#Other-7","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Removed a duplicated test (#2395)","category":"page"},{"location":"moi/release_notes/#[v1.25.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.25.0)-(January-5,-2024)","page":"Release notes","title":"v1.25.0 (January 5, 2024)","text":"","category":"section"},{"location":"moi/release_notes/#Added-5","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added the AutomaticDifferentiationBackend attribute (#2386)","category":"page"},{"location":"moi/release_notes/#Fixed-10","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed initialize for Nonlinear.ExprGraphOnly (#2387)\nFixed converting 0-valued ScalarAffineFunction and ScalarQuadraticFunction to ScalarNonlinearFunction (#2388)\nFixed reading .nl files with non-empty variable and constraint names (#2390)\nFixed reading .nl files with no objective (#2391)\nFixed reading .nl files with free ranged constraints (#2392)","category":"page"},{"location":"moi/release_notes/#[v1.24.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.24.0)-(January-2,-2024)","page":"Release notes","title":"v1.24.0 (January 2, 2024)","text":"","category":"section"},{"location":"moi/release_notes/#Added-6","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added get_fallback for ConstraintDual of variable bounds (#2373)","category":"page"},{"location":"moi/release_notes/#Fixed-11","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed RSOCtoPSDBridge for dimension 2 (#2359)\nFixed getting ConstraintFunction in conversion bridge (#2360)\nFixed map_indices (#2367)\nFixed SlackBridgePrimalDualStart for non-slack bridges (#2365)\nFixed test_attribute_TimeLimitSec (#2370)\nFixed order of model attributes during copy_to (#2372)\nFixed ConstraintIndex conflicts between variable and constraint bridges (#2362)\nFixed corner-case deletion in bridges (#2377)\nFixed ListOfVariablesWithAttributeSet for variable bridges (#2380)\nFixed SlackBridge if scalar constant is not zero (#2382)\nFixed setting multiple bounds on a bridged variable (#2383)","category":"page"},{"location":"moi/release_notes/#Other-8","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Minor documentation improvements (#2355), (#2374)\nImproved side_dimension_for_vectorized_dimension (#2356)\nAdded DiffOpt and ParametricOptInterface to solver-tests.yml (#2368)\nRefactored SDPAModel into a separate test file and test more widely (#2364), (#2357)","category":"page"},{"location":"moi/release_notes/#[v1.23.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.23.0)-(November-29,-2023)","page":"Release notes","title":"v1.23.0 (November 29, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Added-7","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added ConstraintPrimalStart for Bridges.Constraint.GeoMeanBridge (#2348)\nAdded verbose keyword argument to Test.runtests (#2347)\nAdded Bridges.FirstBridge attribute (#2211)","category":"page"},{"location":"moi/release_notes/#Fixed-12","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed Test.test_model_Name_VariableName_ConstraintName (#2349)\nFixed errors thrown when querying an attribute is not supported, like when Utilities.CachingOptimizer is not attached to an optimizer (#2350)","category":"page"},{"location":"moi/release_notes/#[v1.22.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.22.0)-(November-6,-2023)","page":"Release notes","title":"v1.22.0 (November 6, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Added-8","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added new bridges (#2318)\nBridges.Constraint.SOS1ToMILPBridge\nBridges.Constraint.SOS2ToMILPBridge\nBridges.Constraint.IndicatorToMILPBridge\nAdded starting values for bridges (#2330) (#2337) (#2338) (#2339)\nBridges.Constraint.NumberConversionBridge\nBridges.Constraint.SquareBridge\nBridges.Variable.HermitianToSymmetricPSDBridge\nBridges.Variable.ParameterToEqualToBridge\nBridges.Variable.RSOCtoPSDBridge\nAdded ListOfVariablesWithAttributeSet and ListOfConstraintsWithAttributeSet (#2331) (#2342)\nAdded support for printing ConstraintName when models are printed (#2336)","category":"page"},{"location":"moi/release_notes/#Fixed-13","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"ScalarFunctionConstantNotZero errors are now skipped in Test.runtests (#2325)\nFixed VectorNonlinearFunction support in Bridges.Constraint.NormOneBridge and Bridges.Constraint.NormInfinityBridge (#2324)\nFixed various get for ConstraintFunction to return a copy, and added tests (#2328)\nFixed supports of ConstraintPrimalStart and VariablePrimalStart for some bridges (#2340)","category":"page"},{"location":"moi/release_notes/#Other-9","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed typo in docstring of ScalarAffineFunction (#2326)\nAdded Gurobi to solver-tests.yml (#2332)\nImproved the error message when a bridge does not support an attribute (#2329)\nImproved documentation for implementing a bridge (#2334)\nUpdated [compat] bounds in Project.toml (#2344)","category":"page"},{"location":"moi/release_notes/#[v1.21.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.21.0)-(October-25,-2023)","page":"Release notes","title":"v1.21.0 (October 25, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Added-9","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added SolutionLimit attribute (#2291)\nAdded support for MathOptFormat v1.6 and v1.7 (#2293) (#2298) (#2299) (#2321)\nAdded ScalarQuadraticCoefficientChange (#2296) (#2320) (#2322)\nAdded Utilities.modify_constants (#2300)\nAdded support for is_empty and empty! of Nonlinear.Model (#2305)\nAdded Bridges.Objective.FunctionConversionBridge (#2303)\nAdded Bridges.ModifyBridgeNotAllowed (#2307)\nAdded more sets for Utilities.distance_to_set (#2314)","category":"page"},{"location":"moi/release_notes/#Fixed-14","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed test_attribute_TimeLimitSec (#2256)\nFixed conversion cost in objective bridges (#2309)","category":"page"},{"location":"moi/release_notes/#Other-10","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed flakey link checking in documentation (#2297)\nMinor documentation fixes (#2304) (#2313)\nFixed [compat] section of Project.toml (#2310)\nAdded MultiObjectiveAlgorithms to solver-tests.yml (#2312)","category":"page"},{"location":"moi/release_notes/#[v1.20.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.20.1)-(September-24,-2023)","page":"Release notes","title":"v1.20.1 (September 24, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-15","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Removed incorrect kwargs in some copy_to methods (#2272)\nFixed ConstraintDualStart for Bridges.Constraint.SplitIntervalBridge (#2275)\nFixed MethodError when trying to modify a variable objective (#2278)\nFixed stack-overflow in Utilities.operate(+,...) with many arguments (#2285) (#2290)","category":"page"},{"location":"moi/release_notes/#Other-11","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added MathOptSetDistances to solver-tests.yml (#2265)\nUpdated Documenter (#2266)\nFixed various JET errors (#2267) (#2269) (#2270) (#2271) (#2276) (#2277) (#2289)\nVarious style improvements\nReplaced using Package with import Package where possible (#2274)\nRemoved Utilities.EMPTYSTRING (#2283)\nRemoved unnecessary const acronyms in Utilities (#2280) (#2281)\nRemoved invalid and unused method (#2286)\nRefactored src/Utilities/model.jl (#2287)","category":"page"},{"location":"moi/release_notes/#[v1.20.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.20.0)-(September-7,-2023)","page":"Release notes","title":"v1.20.0 (September 7, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Added-10","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added Scaled set (#2237) (#2263) (#2264)\nAdded ObjectiveLimit attribute (#2257)","category":"page"},{"location":"moi/release_notes/#Other-12","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Updated dependencies (#2258)\nImproved performance of ScalarNonlinearFunction utilities (#2259)\nFixed docstrings (#2261)","category":"page"},{"location":"moi/release_notes/#[v1.19.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.19.0)-(August-15,-2023)","page":"Release notes","title":"v1.19.0 (August 15, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Added-11","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added VectorNonlinearFunction (#2201)\nAdded new bridges\nBridges.Constraint.IntegerToZeroOneBridge (#2205)\nBridges.Constraint.ToScalarQuadraticBridge (#2235)\nBridges.Constraint.ToVectorQuadraticBridge (#2235)\nBridges.Constraint.ToScalarNonlinearBridge (#2233) (#2235)\nBridges.Constraint.FunctionConversionBridge (#2235)\nAdded Bridges.bridging_cost for setting a bridge-specific cost in the bridging graph (#2235)\nAdded Utilities.eval_variables support for ScalarNonlinearFunction (#2218) (#2219)\nAdded support for ScalarNonlinearFunction in FileFormats.NL (#2228) (#2231)\nAdded support for writing non-Float64 functions in FileFormats.MOF\nAdded Utilities.lazy_map (#2254)","category":"page"},{"location":"moi/release_notes/#Fixed-16","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed method ambiguities in operate (#2224)\nFixed reading LP file with a -infinity <= x <= +infinity variable (#2225)\nFixed missing require in Test.test_nonlinear_duals (#2230)\nFixed bug in ConstraintPrimal of Bridges.Constraint.QuadtoSOCBridge (#2240)","category":"page"},{"location":"moi/release_notes/#Other-13","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added extensions to solver-tests.yml (#2229)\nRefactored test/Benchmarks (#2234)\nFixed warnings in tests (#2241) (#2243)\nSmall refactoring of bridges for upcoming VectorNonlinearFunction (#2244) (#2245)\nFixed various typos (#2251) (#2255)\nPartitioned how we run the tests on GitHub actions (#2252) (#2253)","category":"page"},{"location":"moi/release_notes/#[v1.18.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.18.0)-(June-23,-2023)","page":"Release notes","title":"v1.18.0 (June 23, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Added-12","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added Bridges.Objective.SlackBridgePrimalDualStart (#2194)\nAdded constraint_gradient_structure and eval_constraint_gradient (#2200)","category":"page"},{"location":"moi/release_notes/#Fixed-17","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a missing @require in MOI.Test (#2195) (#2196)\nFixed incorrect usage of Utilities.operate! in bridges (#2207) (#2216)\nFixed splatting nonlinear expression with univariate operator (#2221)","category":"page"},{"location":"moi/release_notes/#Other-14","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Removed unused argument names (#2199)\nReduced memory requirement for tests (#2204)\nRefactored Utilities.promote_operation (#2206)\nImproved code style in Utilities/mutable_arithmetics.jl (#2209)\nRefactored various methods in Utilities/functions.jl (#2208) (#2212) (#2213) (#2214) (#2215)","category":"page"},{"location":"moi/release_notes/#[v1.17.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.17.1)-(June-6,-2023)","page":"Release notes","title":"v1.17.1 (June 6, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-18","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed comparison of ScalarFunctionConstantNotZero (#2190)","category":"page"},{"location":"moi/release_notes/#Other-15","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added documentation for enum instances (#2186)\nUpdated chatroom links in documentation (#2188)\nChanged the documentation to build on Julia v1.9 (#2191)","category":"page"},{"location":"moi/release_notes/#[v1.17.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.17.0)-(June-1,-2023)","page":"Release notes","title":"v1.17.0 (June 1, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Added-13","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added ScalarNonlinearFunction (#2059)\nAdded a variety of tests for NormSpectralCone, NormNuclearCone, and HermitianPositiveSemidefiniteConeTriangle (#2174)\nAdded Utilities.value_type for computing the value type of a function (#2176)","category":"page"},{"location":"moi/release_notes/#Fixed-19","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed support for external sets in Utilities.loadfromstring! (#2177)\nFixed promote_operation for ScalarNonlinearFunction (#2179)\nFixed two issues in FileFormats.LP when reading files with quadratic functions (#2182) (#2184)","category":"page"},{"location":"moi/release_notes/#[v1.16.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.16.0)-(May-16,-2023)","page":"Release notes","title":"v1.16.0 (May 16, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Added-14","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added support for MathOptFormat v1.3 and v1.4 (#2158) (#2169)\nAdded new method to the nonlinear API (#2162) (#2164)\neval_hessian_constraint\neval_hessian_objective\nhessian_constraint_structure\nhessian_objective_structure\nAdded new sets\nNormCone (#2119)\nScaledPositiveSemidefiniteConeTriangle (#2154)","category":"page"},{"location":"moi/release_notes/#Fixed-20","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed support for Julia v1.9 to work around a bug in the upstream Julia compiler (#2161) (#2163)\nFixed a correctness bug in Bridges.Constraint.HermitianToSymmetricPSDBridge (#2171)\nFixed convert(::VariableIndex, ::ScalarAffineFunction) when the function has terms with 0coefficients (#2173)","category":"page"},{"location":"moi/release_notes/#Other-16","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed solver-tests.yml (#2157)\nUpdated documentation links to developer chatroom (#2160)\nAdded various tests for bridges (#2156)\nAdded checklists to the developer documentation (#2167) (#2168)","category":"page"},{"location":"moi/release_notes/#[v1.15.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.15.1)-(April-25,-2023)","page":"Release notes","title":"v1.15.1 (April 25, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-21","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed deleting a variable in a bridged objective (#2150)","category":"page"},{"location":"moi/release_notes/#[v1.15.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.15.0)-(April-19,-2023)","page":"Release notes","title":"v1.15.0 (April 19, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Added-15","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added Bridges.Objective.VectorFunctionizeBridge (#2139)","category":"page"},{"location":"moi/release_notes/#Fixed-22","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed support for Rational in Bridges.Constraint.SplitIntervalBridge (#2137)\nFixed printing of LaTeX models (#2141)\nFixed modify in Bridges.Objective.VectorSlackBridge (#2144)\nFixed NAME record with spaces in FileFormats.MPS (#2146)\nFixed deleting a variable in a bridged objective (#2147)","category":"page"},{"location":"moi/release_notes/#Other-17","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Add a test for variables in one-sided open Interval sets (#2133)\nMinor style fixes in the source code (#2148)","category":"page"},{"location":"moi/release_notes/#[v1.14.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.14.1)-(April-6,-2023)","page":"Release notes","title":"v1.14.1 (April 6, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-23","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug in Bridges.print_active_bridges (#2135)","category":"page"},{"location":"moi/release_notes/#Other-18","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added a warning when an ambiguous string is passed to exclude in Test.runtests (#2136)","category":"page"},{"location":"moi/release_notes/#[v1.14.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.14.0)-(April-4,-2023)","page":"Release notes","title":"v1.14.0 (April 4, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Added-16","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added support for starting values in Bridges.Constraint.QuadtoSOCBridge (#2115)\nAdded support for Regex in the include and exclude arguments to Test.runtests (#2129)\nAdded Bridges.print_active_bridges methods for individual objectives and constraints (#2128)","category":"page"},{"location":"moi/release_notes/#Fixed-24","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed ResultCount when parsing .sol files in FileFormats.NL (#2130)","category":"page"},{"location":"moi/release_notes/#[v1.13.2](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.13.2)-(March-21,-2023)","page":"Release notes","title":"v1.13.2 (March 21, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-25","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed splatting of containers in MOI.Nonlinear (#2120)\nFixed a bug reading LP files with default bounds (#2121)\nFixed a bug in which Bridges.Constraint.HermitianToSymmetricPSDBridge was not enabled by default (#2123)","category":"page"},{"location":"moi/release_notes/#Other-19","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed typos in the documentation (#2114)\nFunctions now print to the REPL in algebraic form. This is potentially breaking if you have tests which rely on a specific String form of MOI functions. (#2112) (#2126)","category":"page"},{"location":"moi/release_notes/#[v1.13.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.13.1)-(March-3,-2023)","page":"Release notes","title":"v1.13.1 (March 3, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Other-20","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added the Google style guide to the documentation linter Vale, and fixed the resulting warnings (#2110)\nImproved the docstrings in src/functions.jl (#2108)","category":"page"},{"location":"moi/release_notes/#[v1.13.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.13.0)-(February-28,-2023)","page":"Release notes","title":"v1.13.0 (February 28, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Added-17","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added Bridges.Constraint.NumberConversionBridge (#2091)\nAdded Parameter set (#2095) (#2105) (#2106) (#2109)\nAdded with_cache_type argument to instantiate (#2097)\nAdded support for HermitianPositiveSemidefiniteConeTriangle in Utilities.Model (#2100)","category":"page"},{"location":"moi/release_notes/#Fixed-26","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed bug when Utilities.@product_of_sets is empty (#2101)\nFixed Bridges.print_active_bridges when variable bridge is an AbstractScalarSet (#2107)","category":"page"},{"location":"moi/release_notes/#Other-21","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added tests for vector-valued objective functions in FileFormats.MOF (#2093)\nUsed and documented preference for import MathOptInterface as MOI (#2096)\nFix and test links in the documentation with linkcheck = true (#2098)\nImproved docstrings of sets in src/sets.jl (#2099)\nSkip checking flakey links in documentation with linkcheck_ignore  (#2103)","category":"page"},{"location":"moi/release_notes/#[v1.12.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.12.0)-(February-10,-2023)","page":"Release notes","title":"v1.12.0 (February 10, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Added-18","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added support for vector-valued objective functions (#2070)\nAdded a Utilities.distance_to_set method for SecondOrderCone (#2060)","category":"page"},{"location":"moi/release_notes/#Fixed-27","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a number of constraint bridges so that Bridges.final_touch can be called multiple times without forcing a rebuild of the reformulation (#2089)","category":"page"},{"location":"moi/release_notes/#Other-22","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added new tests that a set ObjectiveFunction appears in ListOfModelAttributesSet (#2085)\nImproved the docstrings of a number of constraint-programming related sets (#2087)","category":"page"},{"location":"moi/release_notes/#[v1.11.5](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.11.5)-(January-24,-2023)","page":"Release notes","title":"v1.11.5 (January 24, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-28","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug writing .lp files with an off-diagonal quadratic objective (#2082)","category":"page"},{"location":"moi/release_notes/#Other-23","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added SnoopPrecompile directives for reduced time-to-first-X in Julia v1.9 (#2080)","category":"page"},{"location":"moi/release_notes/#[v1.11.4](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.11.4)-(January-12,-2023)","page":"Release notes","title":"v1.11.4 (January 12, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-29","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug reading .lp files with an Integer section (#2078)","category":"page"},{"location":"moi/release_notes/#[v1.11.3](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.11.3)-(January-12,-2023)","page":"Release notes","title":"v1.11.3 (January 12, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-30","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a performance bug when deleting a vector of constraints (#2072)\nFixed a bug reading .lp files with terms like x -1 y (#2076)","category":"page"},{"location":"moi/release_notes/#Other-24","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Documented the two-argument method of optimize! (#2074)","category":"page"},{"location":"moi/release_notes/#[v1.11.2](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.11.2)-(January-2,-2023)","page":"Release notes","title":"v1.11.2 (January 2, 2023)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-31","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug reading .mof.json files with ConstraintName set for VariableIndex constraints (#2066)\nFixed a bug reading .mof.json files with nonlinear objectives and no constraints (#2068)","category":"page"},{"location":"moi/release_notes/#[v1.11.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.11.1)-(December-22,-2022)","page":"Release notes","title":"v1.11.1 (December 22, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-32","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug reading .mof.json files with integer coefficients for affine and quadratic functions (#2063)","category":"page"},{"location":"moi/release_notes/#[v1.11.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.11.0)-(December-2,-2022)","page":"Release notes","title":"v1.11.0 (December 2, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Added-19","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added Utilities.PenaltyRelaxation and Utilities.ScalarPenaltyRelaxation (#1995)\nAdded Utilities.distance_to_set (#2048)\nAdded support for ConstraintPrimalStart and ConstraintDualStart in FileFormats.MOF (#2056)","category":"page"},{"location":"moi/release_notes/#Other-25","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Tidied these release notes (#2055)","category":"page"},{"location":"moi/release_notes/#[v1.10.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.10.0)-(November-22,-2022)","page":"Release notes","title":"v1.10.0 (November 22, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Added-20","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added new methods set(::OptimizerWithAttributes, ::RawOptimizerAttribute, value) and get(::OptimizerWithAttributes, ::RawOptimizerAttribute) (#2049)\nAdded new methods Utilities.DoubleDicts.outer_keys and Utilities.DoubleDicts.nonempty_outer_keys (#2052)","category":"page"},{"location":"moi/release_notes/#Fixed-33","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed Bridges.Objective.SlackBridge when the objective function is complex-valued (#2036) (#2038)\nFixed docstring of Test.runtests to clarify the warn_unsupported argument (#2037)\nFixed reading of free variables in FileFormats.LP (#2044)\nFixed numerous edge cases reading files from QPLIB using FileFormats.LP (#2042) (#2044)\nFixed situations in which x^y returns a complex value in Nonlinear (#2050)","category":"page"},{"location":"moi/release_notes/#Other-26","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Improved the error message thrown when a user-defined nonlinear function does not accept splatted input (#2032)\nRemoved specialized iterators for keys and values in Utilities.CleverDicts (#2051)","category":"page"},{"location":"moi/release_notes/#[v1.9.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.9.0)-(October-29,-2022)","page":"Release notes","title":"v1.9.0 (October 29, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Added-21","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added default fallback for getting ListOfConstraintIndices and NumberOfConstraints when the constraint type is unsupported by the model (#2021)\nAdded support for min and max in nonlinear expressions (#2023)\nAdded support for Indicator{EqualTo{T}} constraints in FileFormats.MPS (#2022)\nAdded default fallback for write_to_file and read_from_file (#2029)","category":"page"},{"location":"moi/release_notes/#Fixed-34","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed Constraint.ZeroOneBridge by adding new bounds as affine constraints instead of variable bounds (#1879)\nFixed reading free rows in FileFormats.MPS files (#2009)\nFixed parsing of OBJSENSE blocks in FileFormats.MPS files (#2016) (#2019)\nFixed the parsing of deeply nested nonlinear expressions by removing the use of recursion (#2020)\nFixed the requirements check in Test.test_constraint_get_ConstraintIndex (#2024)","category":"page"},{"location":"moi/release_notes/#[v1.8.2](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.8.2)-(September-20,-2022)","page":"Release notes","title":"v1.8.2 (September 20, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Documentation","page":"Release notes","title":"Documentation","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added vale as a documentation linter (#2002)\nImproved styling of code blocks in the PDF (#1999) (#2000)\nFixed a number of typos in the documentation (#2001) (#2003)","category":"page"},{"location":"moi/release_notes/#[v1.8.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.8.1)-(September-12,-2022)","page":"Release notes","title":"v1.8.1 (September 12, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-35","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug in supports(::AbstractBridgeOptimizer for constraint attributes (#1991) (#1992)","category":"page"},{"location":"moi/release_notes/#[v1.8.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.8.0)-(September-1,-2022)","page":"Release notes","title":"v1.8.0 (September 1, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Added-22","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added new sets\nHyperRectangle (#1961)\nReified (#1955)\nAdded new bridges (#1955)\nBridges.Constraint.ReifiedAllDifferentToCountDistinctBridge\nBridges.Constraint.ReifiedCountDistinctToMILPBridge\nBridges.Constraint.SplitHyperRectangleBridge\nAdded support for atan(y, x) in Nonlinear (#1987)","category":"page"},{"location":"moi/release_notes/#Fixed-36","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Lazily construct expressions in Nonlinear so that expressions are updated when Nonlinear.Parameter values are updated (#1984)\nAllow NORM_LIMIT as a TerminationStatus for unbounded problems in Test (#1990)","category":"page"},{"location":"moi/release_notes/#[v1.7.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.7.0)-(August-16,-2022)","page":"Release notes","title":"v1.7.0 (August 16, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Added-23","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added new sets\nHermitianPositiveSemidefiniteConeTriangle\nAdded new optimizer-independent options\nRelativeGapTolerance\nAbsoluteGapTolerance\nAdded new bridges\nBridges.Constraint.GeoMeanToPowerBridge\nBridges.Constraint.HermitianToSymmetricPSDBridge\nBridges.Constraint.IndicatorGreaterToLessThanBridge\nBridges.Constraint.IndicatorLessToGreaterThanBridge\nBridges.Constraint.SplitComplexZerosBridge\nBridges.Constraint.SplitComplexEqualToBridge\nBridges.Objective.QuadratizeBridge\nAdded support for generic number types in Utilities.loadfromstring!\nUpdated FileFormats.MOF to MathOptFormat v1.1, enabling support for constraint programming sets in the MOF file format\nAdded support in various FileFormats for\nindicator constraints in FileFormats.MPS\nquadratic constraints and an objective in FileFormats.LP\nquadratic constraints and an objective in FileFormats.MPS","category":"page"},{"location":"moi/release_notes/#Fixed-37","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed some missing promotion rules","category":"page"},{"location":"moi/release_notes/#Other-27","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Improved the performance of Jacobian products in Nonlinear\nRemoved an un-needed copy in Utilities.modify_function\nVarious clean-ups in Bridges/bridge_optimizer.jl","category":"page"},{"location":"moi/release_notes/#[v1.6.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.6.1)-(July-23,-2022)","page":"Release notes","title":"v1.6.1 (July 23, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-38","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added support for ExponentialCone in MatrixOfConstraints\nFix PSDSquare_3 test to reflect a previously fixed bug getting the ConstraintDual of a PositiveSemidefiniteConeSquare constraint","category":"page"},{"location":"moi/release_notes/#[v1.6.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.6.0)-(July-2,-2022)","page":"Release notes","title":"v1.6.0 (July 2, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Added-24","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added Bridges.needs_final_touch and Bridges.final_touch\nAdded new bridges from constraint programming sets to mixed-integer linear programs:\nAllDifferentToCountDistinctBridge\nCountAtLeastToCountBelongsBridge\nCountBelongsToMILPBridge\nCountDistinctToMILPBridge\nCountGreaterThanToMILPBridge\nCircuitToMILPBridge","category":"page"},{"location":"moi/release_notes/#Fixed-39","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Relax an instance of ::Vector to ::AbstractVector in MOI.Nonlinear\nFix BinPackingToMILPBridge to respect variable bounds\nFix SemiToBinaryBridge to throw error if other bounds are set","category":"page"},{"location":"moi/release_notes/#[v1.5.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.5.0)-(June-27,-2022)","page":"Release notes","title":"v1.5.0 (June 27, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Added-25","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added GetAttributeNotAllowed for solvers to indicate when getting an attribute encounters an error\nAdded Utilities.get_fallback support for ObjectiveValue and DualObjectiveValue\nAdded new bridges:\nRootDetConeSquare to RootDetConeTriangle\nLogDetConeSquare to LogDetConeTriangle\nBinPacking to a mixed-integer linear program\nTable to a mixed-integer linear program\nAdded Bridges.print_active_bridges to display the current optimal hyper-path in a Bridges.LazyBridgeOptimizer","category":"page"},{"location":"moi/release_notes/#Fixed-40","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed ZeroOne tests with lower and upper bounds\nFixed error in FileFormats.LP when reading a malformed file\nFixed reading of nonlinear programs in FileFormats.MOF\nFixed bug in ConstraintDual when using SquareBridge","category":"page"},{"location":"moi/release_notes/#Other-28","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Improved documentation of nonlinear API\nDocumented duality convention for PositiveSemidefiniteConeSquare sets\nFixed typo in Bridges.Constraint.QuadToSOCBridge docstring","category":"page"},{"location":"moi/release_notes/#[v1.4.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.4.0)-(June-9,-2022)","page":"Release notes","title":"v1.4.0 (June 9, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Added-26","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added a number of sets for constraint programming:\nAllDifferent\nBinPacking\nCircuit\nCountAtLeast\nCountBelongs\nCountDistinct\nCountGreaterThan\nCumulative\nPath\nTable\nAdded support for user-defined hessians in Nonlinear\nAdded Bridges.runtests to simplify the testing of bridge implementations","category":"page"},{"location":"moi/release_notes/#Fixed-41","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug in FileFormats.NL when writing univariate *","category":"page"},{"location":"moi/release_notes/#Other-29","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Began a large refactoring of the Bridges submodule, with greatly improved documentation.","category":"page"},{"location":"moi/release_notes/#[v1.3.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.3.0)-(May-27,-2022)","page":"Release notes","title":"v1.3.0 (May 27, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Added-27","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Add MOI.Nonlinear submodule. This is a large new submodule that has been refactored from code that was in JuMP. For now, it should be considered experimental.\nAdd FileFormats.NL.SolFileResults(::IO, ::Model)\nAdd FileFormats.NL.read!(::IO, ::Model)\nAdd MOI.modify that accepts a vector of modifications","category":"page"},{"location":"moi/release_notes/#Fixed-42","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug in Test which attempted to include non-.jl files\nFixed a bug in FileFormats for models with open interval constraints","category":"page"},{"location":"moi/release_notes/#Other-30","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a performance issue in Utilities.DoubleDict\nVarious minor improvements to the documentation","category":"page"},{"location":"moi/release_notes/#[v1.2.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.2.0)-(April-25,-2022)","page":"Release notes","title":"v1.2.0 (April 25, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Added-28","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Add support for the FORMAT_REW/.rew file format in FileFormats.","category":"page"},{"location":"moi/release_notes/#Fixed-43","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fix bug handling of default variable bounds in FileFormats.LP\nFix FileFormats.MPS to not write OBJSENSE by default since this is only supported by some readers.","category":"page"},{"location":"moi/release_notes/#[v1.1.2](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.1.2)-(March-31,-2022)","page":"Release notes","title":"v1.1.2 (March 31, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-44","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fix a range of bugs in FileFormats.LP\nFix reading of problem dimensions in FileFormats.SDPA","category":"page"},{"location":"moi/release_notes/#[v1.1.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.1.1)-(March-23,-2022)","page":"Release notes","title":"v1.1.1 (March 23, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-45","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fix bug in test_model_UpperBoundAlreadySet\nFix bug in test_infeasible_ tests\nFix bug in test_objective_ObjectiveFunction_blank\nRelax restriction of MOI.AbstractOptimizer to MOI.ModelLike in Utilities.CachingOptimizer and instantiate.","category":"page"},{"location":"moi/release_notes/#New-tests","page":"Release notes","title":"New tests","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Add test_conic_empty_matrix that checks conic solvers support problems with no variables.","category":"page"},{"location":"moi/release_notes/#[v1.1.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.1.0)-(March-2,-2022)","page":"Release notes","title":"v1.1.0 (March 2, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Added-29","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added MOI.Utilities.throw_unsupported(::UniversalFallback) for simplifying solver wrappers which copy from a UniversalFallback.","category":"page"},{"location":"moi/release_notes/#[v1.0.2](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.0.2)-(March-1,-2022)","page":"Release notes","title":"v1.0.2 (March 1, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-46","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug in the test_model_ScalarFunctionConstantNotZero test\nFixed the error type when an AbstractFunctionConversionBridge cannot get or set an attribute\nIdentified a correctness bug in RSOCtoPSDBridge. We now thrown an error instead of returning an incorrect result.","category":"page"},{"location":"moi/release_notes/#[v1.0.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.0.1)-(February-25,-2022)","page":"Release notes","title":"v1.0.1 (February 25, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-47","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug in which OptimizerAttributes were not copied in CachingOptimizer\nFixed a bug in which shift_constant did not promote mixed types of coefficients\nFixed a bug in which deleting a constraint of a bridged variable threw ErrorException instead of MOI.DeleteNotAllowed\nFixed a bug in which add_constraint in MatrixOfConstraints did not canonicalize the function\nFixed a bug when modifying scalar constants of a function containing a bridged variable\nFixed a bug in which final_touch was not always called with a CachingOptimizer","category":"page"},{"location":"moi/release_notes/#[v1.0.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v1.0.0)-(February-17,-2022)","page":"Release notes","title":"v1.0.0 (February 17, 2022)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Although tagged as a breaking release, v1.0.0 is v0.10.9 with deprecations removed, similar to how Julia 1.0 was Julia 0.7 with deprecations removed.","category":"page"},{"location":"moi/release_notes/#Breaking","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Julia 1.6 is now the minimum supported version\nAll deprecations have been removed","category":"page"},{"location":"moi/release_notes/#Troubleshooting-problems-when-updating","page":"Release notes","title":"Troubleshooting problems when updating","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"If you experience problems when updating, you are likely using previously deprecated features. (By default, Julia does not warn when you use deprecated features.)","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"To find the deprecated features you are using, start Julia with --depwarn=yes:","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"$ julia --depwarn=yes","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Then install MathOptInterface v0.10.9:","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"julia> using Pkg\njulia> pkg\"add MathOptInterface@0.10\"","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"And then run your code. Apply any suggestions, or search the release notes below for advice on updating a specific deprecated feature.","category":"page"},{"location":"moi/release_notes/#[v0.10.9](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.10.9)-(February-16,-2022)","page":"Release notes","title":"v0.10.9 (February 16, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Added-30","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added MOI.Utilities.FreeVariables as a new VariablesConstrainer for conic solvers\nAdded MOI.default_cache for specifying the model used in CachingOptimizer","category":"page"},{"location":"moi/release_notes/#Fixed-48","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed LaTeX printing of MOI.Interval sets","category":"page"},{"location":"moi/release_notes/#Other-31","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added Aqua.jl as a CI check, and fixed suggested issues\nThe constructors of GeoMeanBridge, StructOfConstraints, and CachingOptimizer were changed from outer to inner constructors. This change is technically breaking, but does not impact users who followed the documented API.","category":"page"},{"location":"moi/release_notes/#[v0.10.8](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.10.8)-(February-3,-2022)","page":"Release notes","title":"v0.10.8 (February 3, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Added-31","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added a Base.read! for FileFormats.LP.","category":"page"},{"location":"moi/release_notes/#Fixed-49","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a bug in MutableSparseMatrix\nFixed a bug when calling operate!(vcat, ...) with Number arguments\nRemoved unintended export of deprecated symbols\nFixed a bug with PowerCone and DualPowerCone in MatrixOfConstraints.","category":"page"},{"location":"moi/release_notes/#[v0.10.7](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.10.7)-(January-5,-2022)","page":"Release notes","title":"v0.10.7 (January 5, 2022)","text":"","category":"section"},{"location":"moi/release_notes/#Added-32","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added test for modifying the constant vector in a VectorAffineFunction-in-Zeros constraint.","category":"page"},{"location":"moi/release_notes/#Fixed-50","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed the order in which sets are added to a LazyBridgeOptimizer. Compared to v0.10.6, this may result in bridged models being created with a different number (and order) of variables and constraints. However, it was necessary to fix cases which were previously rejected as unsupported, even though there was a valid bridge transformation.\nFixed an error message in FileFormats.CBF\nFixed comparison in test_linear_integration_Interval\nFixed errors for ConstraintPrimal in a CachingOptimizer\nFixed printing of models with non-Float64 coefficients.","category":"page"},{"location":"moi/release_notes/#Other-32","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Various improvements to reduce time-to-first-solve latency\nImproved error message when an optimizer does not support compute_conflict!","category":"page"},{"location":"moi/release_notes/#[v0.10.6](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.10.6)-(November-30,-2021)","page":"Release notes","title":"v0.10.6 (November 30, 2021)","text":"","category":"section"},{"location":"moi/release_notes/#Added-33","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added new documentation and tests for infeasibility certificates\nAdded a version control system for the tests in MOI.Test.runtests. Pass exclude_tests_after = v\"0.10.5\" to run tests added in v0.10.5 and earlier.\nMOI.Test.runtests now supports generic number types. To specify the number type T, pass MOI.Test.Config(T).\nAdded infeasible_status to MOI.Test.Config for solvers which return LOCALLY_INFEASIBLE\nCachingOptimizers now use a fallback for ConstraintPrimal. This should enable solvers using a CachingOptimizer to pass tests requiring ConstraintPrimal.","category":"page"},{"location":"moi/release_notes/#Fixed-51","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed a StackOverflow bug in copy_to\nFixed error thrown when nonconvex quadratic constraints cannot be bridged\nFixed a bug in copy_to for FileFormats.NL.Model\nFixed a bug in FileFormats.NL when printing large integers\nRemove a common test failure for LowerBoundAlreadySet tests\nUtilities.num_rows is now exported\nRemove parts of failing test_model_copy_to_xxx tests due to bridges","category":"page"},{"location":"moi/release_notes/#[v0.10.5](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.10.5)-(November-7,-2021)","page":"Release notes","title":"v0.10.5 (November 7, 2021)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-52","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed getter in UniversalFallback\nFixed test_solve_conflict_zeroone_ii","category":"page"},{"location":"moi/release_notes/#Other-33","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Make normalize_and_add_constraint more flexible\nUpdate paper BibTeX","category":"page"},{"location":"moi/release_notes/#[v0.10.4](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.10.4)-(October-26,-2021)","page":"Release notes","title":"v0.10.4 (October 26, 2021)","text":"","category":"section"},{"location":"moi/release_notes/#Added-34","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Add SolverVersion attribute\nAdd new tests:\ntest_solve_conflict_zeroone_ii\ntest_nonlinear_objective\nUtilities.VariablesContainer now supports ConstraintFunction and ConstraintSet\nThe documentation is now available as a PDF","category":"page"},{"location":"moi/release_notes/#Other-34","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Update to MutableArithmetics 0.3\nVarious improvements to the documentation","category":"page"},{"location":"moi/release_notes/#[v0.10.3](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.10.3)-(September-18,-2021)","page":"Release notes","title":"v0.10.3 (September 18, 2021)","text":"","category":"section"},{"location":"moi/release_notes/#Fixed-53","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed bug which prevented callbacks from working through a CachingOptimizer\nFixed bug in Test submodule","category":"page"},{"location":"moi/release_notes/#[v0.10.2](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.10.2)-(September-16,-2021)","page":"Release notes","title":"v0.10.2 (September 16, 2021)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Updated MathOptFormat to v1.0\nUpdated JSONSchema to v1.0\nAdded Utilities.set_with_dimension\nAdded two-argument optimize!(::AbstractOptimizer, ::ModelLike)\nThe experimental feature copy_to_and_optimize! has been removed\nDet bridges now support getting ConstraintFunction and ConstraintSet\nVarious minor bug fixes identified by improved testing","category":"page"},{"location":"moi/release_notes/#[v0.10.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.10.1)-(September-8,-2021)","page":"Release notes","title":"v0.10.1 (September 8, 2021)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Various fixes to MOI.Test","category":"page"},{"location":"moi/release_notes/#[v0.10.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.10.0)-(September-6,-2021)","page":"Release notes","title":"v0.10.0 (September 6, 2021)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"MOI v0.10 is a significant breaking release. There are a large number of user-visible breaking changes and code refactors, as well as a substantial number of new features.","category":"page"},{"location":"moi/release_notes/#Breaking-in-MOI","page":"Release notes","title":"Breaking in MOI","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"SingleVariable has been removed; use VariableIndex instead\nSingleVariableConstraintNameError has been renamed to VariableIndexConstraintNameError\nSettingSingleVariableFunctionNotAllowed has been renamed to SettingVariableIndexFunctionNotAllowed\nVariableIndex constraints should not support ConstraintName\nVariableIndex constraints should not support ConstraintBasisStatus; implement VariableBasisStatus instead\nListOfConstraints has been renamed to ListOfConstraintTypesPresent\nListOfConstraintTypesPresent should now return Tuple{Type,Type} instead of Tuple{DataType,DataType}\nSolveTime has been renamed to SolveTimeSec\nIndicatorSet has been renamed to Indicator\nRawParameter has been renamed to RawOptimizerAttribute and now takes String instead of Any as the only argument\nThe .N field in result attributes has been renamed to .result_index\nThe .variable_index field in ScalarAffineTerm has been renamed to .variable\nThe .variable_index_1 field in ScalarQuadraticTerm has been renamed to .variable_1\nThe .variable_index_2 field in ScalarQuadraticTerm has been renamed to .variable_2\nThe order of affine_terms and quadratic_terms in ScalarQuadraticFunction and VectorQuadraticFunction have been reversed. Both functions now accept quadratic, affine, and constant terms in that order.\nThe index_value function has been removed. Use .value instead.\nisapprox has been removed for SOS1 and SOS2.\nThe dimension argument to Complements(dimension::Int) should now be the length of the corresponding function, instead of half the length. An ArgumentError is thrown if dimension is not even.\ncopy_to no longer takes keyword arguments:\ncopy_names: now copy names if they are supported by the destination solver\nfilter_constraints: use Utilities.ModelFilter instead\nwarn_attributes: never warn about optimizer attributes","category":"page"},{"location":"moi/release_notes/#Breaking-in-Bridges","page":"Release notes","title":"Breaking in Bridges","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Constraint.RSOCBridge has been renamed to Constraint.RSOCtoSOCBridge\nConstraint.SOCRBridge has been renamed to Constraint.SOCtoRSOCBridge\nBridges now return vectors that can be modified by the user. Previously, some bridges returned views instead of copies.\nBridges.IndexInVector has been unified into a single type. Previously, there was a different type for each submodule within Bridges\nThe signature of indicator bridges has been fixed. Use MOI.Bridges.Constraint.IndicatortoSOS1{Float64}(model).","category":"page"},{"location":"moi/release_notes/#Breaking-in-FileFormats","page":"Release notes","title":"Breaking in FileFormats","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"FileFormats.MOF.Model no longer accepts validate argument. Use the JSONSchema package to validate the MOF file. See the documentation for more information.","category":"page"},{"location":"moi/release_notes/#Breaking-in-Utilities","page":"Release notes","title":"Breaking in Utilities","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"The datastructure of Utilities.Model (and models created with Utilities.@model) has been significantly refactored in a breaking way. This includes the way that objective functions and variable-related information is stored.\nUtilities.supports_default_copy has been renamed to supports_incremental_interface\nUtilities.automatic_copy_to has been renamed to Utilities.default_copy_to\nThe allocate-load API has been removed\nCachingOptimizers are now initialized as EMPTY_OPTIMIZER instead of ATTACHED_OPTIMIZER. If your code relies on the optimizer being attached, call MOIU.attach_optimizer(model) after creation.\nThe field names of Utilities.IndexMap have been renamed to var_map and con_map. Accessing these fields directly is considered a private detail that may change. Use the public getindex and setindex! API instead.\nThe size argument to Utilities.CleverDicts.CleverDict(::Integer) has been removed.\nThe size argument to Utilities.IndexMap(::Integer) has been removed.\nUtilities.DoubleDicts have been significantly refactored. Consult the source code for details.\nUtilities.test_models_equal has been moved to MOI.Test","category":"page"},{"location":"moi/release_notes/#Breaking-in-Test","page":"Release notes","title":"Breaking in Test","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"MOI.Test has been renamed to MOI.DeprecatedTest\nAn entirely new MOI.Test submodule has been written. See the documentation for details. The new MOI.Test submodule may find many bugs in the implementations of existing solvers that were previously untested.","category":"page"},{"location":"moi/release_notes/#Other-changes:","page":"Release notes","title":"Other changes:","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"attribute_value_type has been added\ncopy_to_and_optimize! has been added\nVariableBasisStatus has been added\nprint(model) now prints a human-readable description of the model\nVarious improvements to the FileFormats submodule\nFileFormats.CBF was refactored and received bugfixes\nSupport for MathOptFormat v0.6 was added in FileFormats.MOF\nFileFormats.MPS has had bugfixes and support for more features such as OBJSENSE and objective constants.\nFileFormats.NL has been added to support nonlinear files\nImproved type inference throughout to reduce latency","category":"page"},{"location":"moi/release_notes/#Updating","page":"Release notes","title":"Updating","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"A helpful script when updating is:","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"for (root, dirs, files) in walkdir(\".\")\n    for file in files\n        if !endswith(file, \".jl\")\n            continue\n        end\n        path = joinpath(root, file)\n        s = read(path, String)\n        for pair in [\n            \".variable_index\" => \".variable\",\n            \"RawParameter\" => \"RawOptimizerAttribute\",\n            \"ListOfConstraints\" => \"ListOfConstraintTypesPresent\",\n            \"TestConfig\" => \"Config\",\n            \"attr.N\" => \"attr.result_index\",\n            \"SolveTime\" => \"SolveTimeSec\",\n            \"DataType\" => \"Type\",\n            \"Utilities.supports_default_copy_to\" =>\n                \"supports_incremental_interface\",\n            \"SingleVariableConstraintNameError\" =>\n                \"VariableIndexConstraintNameError\",\n            \"SettingSingleVariableFunctionNotAllowed\" =>\n                \"SettingVariableIndexFunctionNotAllowed\",\n            \"automatic_copy_to\" => \"default_copy_to\",\n        ]\n            s = replace(s, pair)\n        end\n        write(path, s)\n    end\nend","category":"page"},{"location":"moi/release_notes/#[v0.9.22](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.22)-(May-22,-2021)","page":"Release notes","title":"v0.9.22 (May 22, 2021)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"This release contains backports from the ongoing development of the v0.10 release.","category":"page"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Improved type inference in Utilities, Bridges and FileFormats submodules to reduce latency.\nImproved performance of Utilities.is_canonical.\nFixed Utilities.pass_nonvariable_constraints with bridged variables.\nFixed performance regression of Utilities.Model.\nFixed ordering of objective setting in parser.","category":"page"},{"location":"moi/release_notes/#[v0.9.21](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.21)-(April-23,-2021)","page":"Release notes","title":"v0.9.21 (April 23, 2021)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added supports_shift_constant.\nImprove performance of bridging quadratic constraints.\nAdd precompilation statements.\nLarge improvements to the documentation.\nFix a variety of inference issues, benefiting precompilation and reducing initial latency.\nRawParameters are now ignored when resetting a CachingOptimizer. Previously, changing the underlying optimizer after RawParameters were set would throw an error.\nUtilities.AbstractModel is being refactored. This may break users interacting with private fields of a model generated using @model.","category":"page"},{"location":"moi/release_notes/#[v0.9.20](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.20)-(February-20,-2021)","page":"Release notes","title":"v0.9.20 (February 20, 2021)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Improved performance of Utilities.ScalarFunctionIterator\nAdded support for compute_conflict to MOI layers\nAdded test with zero off-diagonal quadratic term in objective\nFixed double deletion of nested bridged SingleVariable/VectorOfVariables constraints\nFixed modification of un-set objective\nFixed function modification with duplicate terms\nMade unit tests abort without failing if the problem class is not supported\nFormatted code with JuliaFormatter\nClarified BasisStatusCode's docstring","category":"page"},{"location":"moi/release_notes/#[v0.9.19](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.19)-(December-1,-2020)","page":"Release notes","title":"v0.9.19 (December 1, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added CallbackNodeStatus attribute\nAdded bridge from GreaterThan or LessThan to Interval\nAdded tests for infeasibility certificates and double optimize\nFixed support for Julia v1.6\nRe-organized MOI docs and added documentation for adding a test","category":"page"},{"location":"moi/release_notes/#[v0.9.18](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.18)-(November-3,-2020)","page":"Release notes","title":"v0.9.18 (November 3, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Various improvements for working with complex numbers\nAdded GeoMeantoRelEntrBridge to bridge a GeometricMeanCone constraint to a relative entropy constraint","category":"page"},{"location":"moi/release_notes/#[v0.9.17](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.17)-(September-21,-2020)","page":"Release notes","title":"v0.9.17 (September 21, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed CleverDict with variable of negative index value\nImplement supports_add_constrained_variable for MockOptimizer","category":"page"},{"location":"moi/release_notes/#[v0.9.16](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.16)-(September-17,-2020)","page":"Release notes","title":"v0.9.16 (September 17, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Various fixes:\n32-bit support\nCleverDict with abstract value type\nChecks in test suite","category":"page"},{"location":"moi/release_notes/#[v0.9.15](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.15)-(September-14,-2020)","page":"Release notes","title":"v0.9.15 (September 14, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Bridges improvements:\n(R)SOCtoNonConvexQuad bridge\nZeroOne bridge\nUse supports_add_constrained_variable in LazyBridgeOptimizer\nExposed VariableBridgeCost and ConstraintBridgeCost attributes\nPrioritize constraining variables on creation according to these costs\nRefactor bridge debugging\nLarge performance improvements across all submodules\nLots of documentation improvements\nFileFormats improvements:\nUpdate MathOptFormat to v0.5\nFix supported objectives in FileFormats\nTesting improvements:\nAdd name option for basic_constraint_test\nBug fixes and missing methods\nAdd length for iterators\nFix bug with duplicate terms\nFix order of LinearOfConstraintIndices","category":"page"},{"location":"moi/release_notes/#[v0.9.14](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.14)-(May-30,-2020)","page":"Release notes","title":"v0.9.14 (May 30, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Add a solver-independent interface for accessing the set of conflicting constraints an Irreducible Inconsistent Subsystem (#1056).\nBump JSONSchema dependency from v0.2 to v0.3 (#1090).\nDocumentation improvements:\nFix typos (#1054, #1060, #1061, #1064, #1069, #1070).\nRemove the outdated recommendation for a package implementing MOI for a solver XXX to be called MathOptInterfaceXXX (#1087).\nUtilities improvements:\nFix is_canonical for quadratic functions (#1081, #1089).\nImplement add_constrained_variable[s] for CachingOptimizer so that it is added as constrained variables to the underlying optimizer (#1084).\nAdd support for custom objective functions for UniversalFallback (#1086).\nDeterministic ordering of constraints in UniversalFallback (#1088).\nTesting improvements:\nAdd NormOneCone/NormInfinityCone tests (#1045).\nBridges improvements:\nAdd bridges from Semiinteger and Semicontinuous (#1059).\nImplement getting ConstraintSet for Variable.FlipSignBridge (#1066).\nFix setting ConstraintFunction for Constraint.ScalarizeBridge (#1093).\nFix NormOne/NormInf bridges with nonzero constants (#1045).\nFix StackOverflow in debug (#1063).\nFileFormats improvements:\n[SDPA] Implement the extension for integer variables (#1079).\n[SDPA] Ignore comments after m and nblocks and detect dat-s extension (#1077).\n[SDPA] No scaling of off-diagonal coefficient (#1076).\n[SDPA] Add missing negation of constant (#1075).","category":"page"},{"location":"moi/release_notes/#[v0.9.13](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.13)-(March-24,-2020)","page":"Release notes","title":"v0.9.13 (March 24, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added tests for Semicontinuous and Semiinteger variables (#1033).\nAdded tests for using ExprGraphs from NLP evaluators (#1043).\nUpdate version compatibilities of dependencies (#1034, #1051, #1052).\nFixed typos in documentation (#1044).","category":"page"},{"location":"moi/release_notes/#[v0.9.12](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.12)-(February-28,-2020)","page":"Release notes","title":"v0.9.12 (February 28, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed writing NLPBlock in MathOptFormat (#1037).\nFixed MockOptimizer for result attributes with non-one result index (#1039).\nUpdated test template with instantiate (#1032).","category":"page"},{"location":"moi/release_notes/#[v0.9.11](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.11)-(February-21,-2020)","page":"Release notes","title":"v0.9.11 (February 21, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Add an option for the model created by Utilities.@model to be a subtype of AbstractOptimizer (#1031).\nDescribed dual cone in docstrings of GeoMeanCone and RelativeEntropyCone (#1018, #1028).\nFixed typos in documentation (#1022, #1024).\nFixed warning of unsupported attribute (#1027).\nAdded more rootdet/logdet conic tests (#1026).\nImplemented ConstraintDual for Constraint.GeoMeanBridge, Constraint.RootDetBridge and Constraint.LogDetBridge and test duals in tests with GeoMeanCone and RootDetConeTriangle and LogDetConeTriangle cones (#1025, #1026).","category":"page"},{"location":"moi/release_notes/#[v0.9.10](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.10)-(January-31,-2020)","page":"Release notes","title":"v0.9.10 (January 31, 2020)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added OptimizerWithAttributes grouping an optimizer constructor and a list of optimizer attributes (#1008).\nAdded RelativeEntropyCone with corresponding bridge into exponential cone constraints (#993).\nAdded NormSpectralCone and NormNuclearCone with corresponding bridges into positive semidefinite constraints (#976).\nAdded supports_constrained_variable(s) (#1004).\nAdded dual_set_type (#1002).\nAdded tests for vector specialized version of delete (#989, #1011).\nAdded PSD3 test (#1007).\nClarified dual solution of Tests.pow1v and Tests.pow1f (#1013).\nAdded support for EqualTo and Zero in Bridges.Constraint.SplitIntervalBridge (#1005).\nFixed Utilities.vectorize for empty vector (#1003).\nFixed free variables in LP writer (#1006).","category":"page"},{"location":"moi/release_notes/#[v0.9.9](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.9)-(December-29,-2019)","page":"Release notes","title":"v0.9.9 (December 29, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Incorporated MathOptFormat.jl as the FileFormats submodule. FileFormats provides readers and writers for a number of standard file formats and MOF, a file format specialized for MOI (#969).\nImproved performance of deletion of vector of variables in MOI.Utilities.Model (#983).\nUpdated to MutableArithmetics v0.2 (#981).\nAdded MutableArithmetics.promote_operation allocation tests (#975).\nFixed inference issue on Julia v1.1 (#982).","category":"page"},{"location":"moi/release_notes/#[v0.9.8](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.8)-(December-19,-2019)","page":"Release notes","title":"v0.9.8 (December 19, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Implemented MutableArithmetics API (#924).\nFixed callbacks with CachingOptimizer (#959).\nFixed MOI.dimension for MOI.Complements (#948).\nAdded fallback for add_variables (#972).\nAdded is_diagonal_vectorized_index utility (#965).\nImproved linear constraints display in manual (#963, #964).\nBridges improvements:\nAdded IndicatorSet to SOS1 bridge (#877).\nAdded support for starting values for Variable.VectorizeBridge (#944).\nFixed MOI.add_constraints with non-bridged variable constraint on bridged variable (#951).\nFixed corner cases and docstring of GeoMeanBridge (#961, #962, #966).\nFixed choice between variable or constraint bridges for constrained variables (#973).\nImprove performance of bridge shortest path (#945, #946, #956).\nAdded docstring for test_delete_bridge (#954).\nAdded Variable bridge tests (#952).","category":"page"},{"location":"moi/release_notes/#[v0.9.7](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.7)-(October-30,-2019)","page":"Release notes","title":"v0.9.7 (October 30, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Implemented _result_index_field for NLPBlockDual (#934).\nFixed copy of model with starting values for vector constraints (#941).\nBridges improvements:\nImproved performance of add_bridge and added has_bridge (#935).\nAdded AbstractSetMapBridge for bridges between sets S1, S2 such that there is a linear map A such that A*S1 = S2 (#933).\nAdded support for starting values for FlipSignBridge, VectorizeBridge, ScalarizeBridge, SlackBridge, SplitIntervalBridge, RSOCBridge, SOCRBridge NormInfinityBridge, SOCtoPSDBridge and RSOCtoPSDBridge (#933, #936, #937, #938, #939).","category":"page"},{"location":"moi/release_notes/#[v0.9.6](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.6)-(October-25,-2019)","page":"Release notes","title":"v0.9.6 (October 25, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added complementarity constraints (#913).\nAllowed ModelLike objects as value of attributes (#928).\nTesting improvements:\nAdded dual_objective_value option to MOI.Test.TestConfig (#922).\nAdded InvalidIndex tests in basic_constraint_tests (#921).\nAdded tests for the constant term in indicator constraint (#929).\nBridges improvements:\nAdded support for starting values for Functionize bridges (#923).\nAdded variable indices context to variable bridges (#920).\nFixed a typo in printing o debug_supports (#927).","category":"page"},{"location":"moi/release_notes/#[v0.9.5](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.5)-(October-9,-2019)","page":"Release notes","title":"v0.9.5 (October 9, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Clarified PrimalStatus/DualStatus to be NO_SOLUTION if result_index is out of bounds (#912).\nAdded tolerance for checks  and use ResultCount + 1 for the result_index in MOI.Test.solve_result_status (#910, #917).\nUse 0.5 instead of 2.0 for power in PowerCone in basic_constraint_test (#916).\nBridges improvements:\nAdded debug utilities for unsupported variable/constraint/objective (#861).\nFixed deletion of variables in bridged VectorOfVariables constraints (#909).\nFixed result_index with objective bridges (#911).","category":"page"},{"location":"moi/release_notes/#[v0.9.4](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.4)-(October-2,-2019)","page":"Release notes","title":"v0.9.4 (October 2, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Added solver-independent MIP callbacks (#782).\nImplements submit for Utilities.CachingOptimizer and Bridges.AbstractBridgeOptimizer (#906).\nAdded tests for result count of solution attributes (#901, #904).\nAdded NumberOfThreads attribute (#892).\nAdded Utilities.get_bounds to get the bounds on a variable (#890).\nAdded a note on duplicate coefficients in documentation (#581).\nAdded result index in ConstraintBasisStatus (#898).\nAdded extension dictionary to Utilities.Model (#884, #895).\nFixed deletion of constrained variables for CachingOptimizer (#905).\nImplemented Utilities.shift_constraint for Test.UnknownScalarSet (#896).\nBridges improvements:\nAdded Variable.RSOCtoSOCBridge (#907).\nImplemented MOI.get for ConstraintFunction/ConstraintSet for Bridges.Constraint.SquareBridge (#899).","category":"page"},{"location":"moi/release_notes/#[v0.9.3](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.3)-(September-20,-2019)","page":"Release notes","title":"v0.9.3 (September 20, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixed ambiguity detected in Julia v1.3 (#891, #893).\nFixed missing sets from ListOfSupportedConstraints (#880).\nFixed copy of VectorOfVariables constraints with duplicate indices (#886).\nAdded extension dictionary to MOIU.Model (#884).\nImplemented MOI.get for function and set for GeoMeanBridge (#888).\nUpdated documentation for SingleVariable indices and bridges (#885).\nTesting improvements:\nAdded more comprehensive tests for names (#882).\nAdded tests for SingleVariable duals (#883).\nAdded tests for DualExponentialCone and DualPowerCone (#873).\nImprovements for arbitrary coefficient type:\nFixed == for sets with mutable fields (#887).\nRemoved some Float64 assumptions in bridges (#878).\nAutomatic selection of Constraint.[Scalar|Vector]FunctionizeBridge (#889).","category":"page"},{"location":"moi/release_notes/#[v0.9.2](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.2)-(September-5,-2019)","page":"Release notes","title":"v0.9.2 (September 5, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Implemented model printing for MOI.ModelLike and specialized it for models defined in MOI (864).\nGeneralized contlinear tests for arbitrary coefficient type (#855).\nFixed supports_constraint for Semiinteger and Semicontinuous and supports for ObjectiveFunction (#859).\nFixed Allocate-Load copy for single variable constraints (#856).\nBridges improvements:\nAdd objective bridges (#789).\nFixed Variable.RSOCtoPSDBridge for dimension 2 (#869).\nAdded Variable.SOCtoRSOCBridge (#865).\nAdded Constraint.SOCRBridge and disable MOI.Bridges.Constraint.SOCtoPSDBridge (#751).\nFixed added_constraint_types for Contraint.LogDetBridge and Constraint.RootDetBridge (#870).","category":"page"},{"location":"moi/release_notes/#[v0.9.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.1)-(August-22,-2019)","page":"Release notes","title":"v0.9.1 (August 22, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fix support for Julia v1.2 (#834).\nL1 and L∞ norm epigraph cones and corresponding bridges to LP were added (#818).\nAdded tests to MOI.Test.nametest (#833).\nFix MOI.Test.soc3test for solvers not supporting infeasibility certificates (#839).\nImplements operate for operators * and / between vector function and constant (#837).\nImplements show for MOI.Utilities.IndexMap (#847).\nFix corner cases for mapping of variables in MOI.Utilities.CachingOptimizer and substitution of variables in MOI.Bridges.AbstractBridgeOptimizer (#848).\nFix transformation of constant terms for MOI.Bridges.Constraint.SOCtoPSDBridge and MOI.Bridges.Constraint.RSOCtoPSDBridge (#840).","category":"page"},{"location":"moi/release_notes/#[v0.9.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.9.0)-(August-13,-2019)","page":"Release notes","title":"v0.9.0 (August 13, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Support for Julia v0.6 and v0.7 was dropped (#714, #717).\nA MOI.Utilities.Model implementation of ModelLike, this should replace most use cases of MOI.Utilities.@model (#781).\nadd_constrained_variable and add_constrained_variables were added (#759).\nSupport for indicator constraints was added (#709, #712).\nDualObjectiveValue attribute was added (#473).\nRawParameter attribute was added (#733).\nA dual_set function was added (#804).\nA Benchmarks submodule was added to facilitate solver benchmarking (#769).\nA submit function was added, this may for instance allow the user to submit solutions or cuts to the solver from a callback (#775).\nThe field of ObjectiveValue was renamed to result_index (#729).\nThe _constant and Utilities.getconstant function were renamed to constant\nREDUCTION_CERTIFICATE result status was added (#734).\nAbstract matrix sets were added (#731).\nTesting improvements:\nThe testing guideline was updated (#728).\nQuadratic tests were added (#697).\nUnit tests for RawStatusString, SolveTime, Silent and SolverName were added (#726, #741).\nA rotated second-order cone test was added (#759).\nA power cone test was added (#768).\nTests for ZeroOne variables with variable bounds were added (#772).\nAn unbounded test was added (#773).\nExisting tests had a few updates (#702, #703, #763).\nDocumentation improvements:\nAdded a section on CachingOptimizer (#777).\nAdded a section on UniversalFallback, Model and @model (#762).\nTransition the knapsack example to a doctest with MockOptimizer (#786).\nUtilities improvements:\nA CleverDict utility was added for a vector that automatically transform into a dictionary once a first index is removed (#767).\nThe Utilities.constant function was renamed to Utilities.constant_vector (#740).\nImplement optimizer attributes for CachingOptimizer (#745).\nRename Utilities.add_scalar_constraint to Utilities.normalize_and_add_constraint (#801).\noperate with vcat, SingleVariable and VectorOfVariables now returns a VectorOfVariables (#616).\nFix a type piracy of operate (#784).\nThe load_constraint fallback signature was fixed (#760).\nThe set_dot function was extended to work with sparse arrays (#805).\nBridges improvements:\nThe bridges no longer store the constraint function and set before it is bridged, the bridges now have to implement ConstraintFunction and ConstraintSet if the user wants to recover them. As a consequence, the @bridge macro was removed (#722).\nBridge are now instantiated with a bridge_constraint function instead of using a constructor (#730).\nFix constraint attributes for bridges (#699).\nConstraint bridges were moved to the Bridges/Constraint submodule so they should now inherit from MOI.Bridges.Constraint.Abstract and should implement MOI.Bridges.Constraint.concrete_bridge_type instead of MOI.Bridges.concrete_bridge_type (#756).\nVariable bridges were added in (#759).\nVarious improvements (#746, #747).","category":"page"},{"location":"moi/release_notes/#[v0.8.4](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.8.4)-(March-13,-2019)","page":"Release notes","title":"v0.8.4 (March 13, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Performance improvement in default_copy_to and bridge optimizer (#696).\nAdd Silent and implement setting optimizer attributes in caching and mock optimizers (#695).\nAdd Functionize bridges (SingleVariable and VectorOfVariables) (#659).\nMinor typo fixes (#694).","category":"page"},{"location":"moi/release_notes/#[v0.8.3](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.8.3)-(March-6,-2019)","page":"Release notes","title":"v0.8.3 (March 6, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Use zero constant in scalar constraint function of MOI.Test.copytest (#691).\nFix variable deletion with SingleVariable objective function (#690).\nFix LazyBridgeOptimizer with bridges that add no constraints (#689).\nError message improvements (#673, #685, #686, #688).\nDocumentation improvements (#682, #683, #687).\nBasis status:\nRemove VariableBasisStatus (#679).\nTest ConstraintBasisStatus and implement it in bridges (#678).\nFix inference of NumberOfVariables and NumberOfConstraints (#677).\nImplement division between a quadratic function and a number (#675).","category":"page"},{"location":"moi/release_notes/#[v0.8.2](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.8.2)-(February-7,-2019)","page":"Release notes","title":"v0.8.2 (February 7, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Add RawStatusString attribute (#629).\nDo not set names to the optimizer but only to the cache in CachingOptimizer (#638).\nMake scalar MOI functions act as scalars in broadcast (#646).\nAdd function utilities:\nImplement Base.zero (#634), Base.iszero (#643), add missing arithmetic operations (#644, #645) and fix division (#648).\nAdd a vectorize function that turns a vector of ScalarAffineFunction into a VectorAffineFunction (#642).\nImprove support for starting values:\nShow a warning in copy when starting values are not supported instead of throwing an error (#630).\nFix UniversalFallback for getting an variable or constraint attribute set to no indices (#623).\nAdd a test in contlineartest with partially set VariablePrimalStart.\nBridges improvements:\nFix StackOverFlow in LazyBridgeOptimizer when there is a cycle in the graph of bridges.\nAdd Slack bridges (#610, #650).\nAdd FlipSign bridges (#658).\nAdd tests with duplicate coefficients in ScalarAffineFunction and VectorAffineFunction (#639).\nUse tolerance to compare VariablePrimal in rotatedsoc1 test (#632).\nUse a zero constant in ScalarAffineFunction of constraints in psdt2 (#622).","category":"page"},{"location":"moi/release_notes/#[v0.8.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.8.1)-(January-7,-2019)","page":"Release notes","title":"v0.8.1 (January 7, 2019)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Adding an NLP objective now overrides any objective set using the ObjectiveFunction attribute (#619).\nRename fullbridgeoptimizer into full_bridge_optimizer (#621).\nAllow custom constraint types with full_bridge_optimizer (#617).\nAdd Vectorize bridge which transforms scalar linear constraints into vector linear constraints (#615).","category":"page"},{"location":"moi/release_notes/#[v0.8.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.8.0)-(December-18,-2018)","page":"Release notes","title":"v0.8.0 (December 18, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Rename all enum values to follow the JuMP naming guidelines for constants, for example, Optimal becomes OPTIMAL, and DualInfeasible becomes DUAL_INFEASIBLE.\nRename CachingOptimizer methods for style compliance.\nAdd an MOI.TerminationStatusCode called ALMOST_DUAL_INFEASIBLE.","category":"page"},{"location":"moi/release_notes/#[v0.7.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.7.0)-(December-13,-2018)","page":"Release notes","title":"v0.7.0 (December 13, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Test that MOI.TerminationStatus is MOI.OptimizeNotCalled before MOI.optimize! is called.\nCheck supports_default_copy_to in tests (#594).\nKey pieces of information like optimality, infeasibility, etc., are now reported through TerminationStatusCode. It is typically no longer necessary to check the result statuses in addition to the termination status.\nAdd perspective dimension to log-det cone (#593).","category":"page"},{"location":"moi/release_notes/#[v0.6.4](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.6.4)-(November-27,-2018)","page":"Release notes","title":"v0.6.4 (November 27, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Add OptimizeNotCalled termination status (#577) and improve documentation of other statuses (#575).\nAdd a solver naming guideline (#578).\nMake FeasibilitySense the default ObjectiveSense (#579).\nFix Utilities.@model and Bridges.@bridge macros for functions and sets defined outside MOI (#582).\nDocument solver-specific attributes (#580) and implement them in Utilities.CachingOptimizer (#565).","category":"page"},{"location":"moi/release_notes/#[v0.6.3](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.6.3)-(November-16,-2018)","page":"Release notes","title":"v0.6.3 (November 16, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Variables and constraints are now allowed to have duplicate names. An error is thrown only on lookup. This change breaks some existing tests. (#549)\nAttributes may now be partially set (some values could be nothing). (#563)\nPerformance improvements in Utilities.Model (#549, #567, #568)\nFix bug in QuadtoSOC (#558).\nNew supports_default_copy_to method that optimizers should implement to control caching behavior.\nDocumentation improvements.","category":"page"},{"location":"moi/release_notes/#[v0.6.2](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.6.2)-(October-26,-2018)","page":"Release notes","title":"v0.6.2 (October 26, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Improve hygiene of @model macro (#544).\nFix bug in copy tests (#543).\nFix bug in UniversalFallback attribute getter (#540).\nAllow all correct solutions for solve_blank_obj unit test (#537).\nAdd errors for Allocate-Load and bad constraints (#534).\n[performance] Add specialized implementation of hash for VariableIndex (#533).\n[performance] Construct the name to object dictionaries lazily in model (#535).\nAdd the QuadtoSOC bridge which transforms ScalarQuadraticFunction constraints into RotatedSecondOrderCone (#483).","category":"page"},{"location":"moi/release_notes/#[v0.6.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.6.1)-(September-22,-2018)","page":"Release notes","title":"v0.6.1 (September 22, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Enable PositiveSemidefiniteConeSquare set and quadratic functions in MOIB.fullbridgeoptimizer (#524).\nAdd warning in the bridge between PositiveSemidefiniteConeSquare and PositiveSemidefiniteConeTriangle when the matrix is almost symmetric (#522).\nModify MOIT.copytest to not add multiples constraints on the same variable (#521).\nAdd missing keyword argument in one of MOIU.add_scalar_constraint methods (#520).","category":"page"},{"location":"moi/release_notes/#[v0.6.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.6.0)-(August-30,-2018)","page":"Release notes","title":"v0.6.0 (August 30, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"The MOIU.@model and MOIB.@bridge macros now support functions and sets defined in external modules. As a consequence, function and set names in the macro arguments need to be prefixed by module name.\nRename functions according to the JuMP style guide:\ncopy! with keyword arguments copynames and warnattributes -> copy_to with keyword arguments copy_names and warn_attributes;\nset! -> set;\naddvariable[s]! -> add_variable[s];\nsupportsconstraint -> supports_constraint;\naddconstraint[s]! -> add_constraint[s];\nisvalid -> is_valid;\nisempty -> is_empty;\nBase.delete! -> delete;\nmodify! -> modify;\ntransform! -> transform;\ninitialize! -> initialize;\nwrite -> write_to_file; and\nread! -> read_from_file.\nRemove free! (use Base.finalize instead).\nAdd the SquarePSD bridge which transforms PositiveSemidefiniteConeTriangle constraints into PositiveSemidefiniteConeTriangle.\nAdd result fallback for ConstraintDual of variable-wise constraint, ConstraintPrimal and ObjectiveValue.\nAdd tests for ObjectiveBound.\nAdd test for empty rows in vector linear constraint.\nRework errors: CannotError has been renamed NotAllowedError and the distinction between UnsupportedError and NotAllowedError is now about whether the element is not supported (for example, it cannot be copied a model containing this element) or the operation is not allowed (either because it is not implemented, because it cannot be performed in the current state of the model, or because it cannot be performed for a specific index)\ncanget is removed. NoSolution is added as a result status to indicate that the solver does not have either a primal or dual solution available (See #479).","category":"page"},{"location":"moi/release_notes/#[v0.5.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.5.0)-(August-5,-2018)","page":"Release notes","title":"v0.5.0 (August 5, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fix names with CachingOptimizer.\nCleanup thanks to @mohamed82008.\nAdded a universal fallback for constraints.\nFast utilities for function canonicalization thanks to @rdeits.\nRenamed dimension field to side_dimension in the context of matrix-like sets.\nNew and improved tests for cases like duplicate terms and ObjectiveBound.\nRemoved cantransform, canaddconstraint, canaddvariable, canset, canmodify, and candelete functions from the API. They are replaced by a new set of errors that are thrown: Subtypes of UnsupportedError indicate unsupported operations, while subtypes of CannotError indicate operations that cannot be performed in the current state.\nThe API for copy! is updated to remove the CopyResult type.\nUpdates for the new JuMP style guide.","category":"page"},{"location":"moi/release_notes/#[v0.4.1](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.4.1)-(June-28,-2018)","page":"Release notes","title":"v0.4.1 (June 28, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Fixes vector function modification on 32 bits.\nFixes Bellman-Ford algorithm for bridges.\nAdded an NLP test with FeasibilitySense.\nUpdate modification documentation.","category":"page"},{"location":"moi/release_notes/#[v0.4.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.4.0)-(June-23,-2018)","page":"Release notes","title":"v0.4.0 (June 23, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Helper constructors for VectorAffineTerm and VectorQuadraticTerm.\nAdded modify_lhs to TestConfig.\nAdditional unit tests for optimizers.\nAdded a type parameter to CachingOptimizer for the optimizer field.\nNew API for problem modification (#388)\nTests pass without deprecation warnings on Julia 0.7.\nSmall fixes and documentation updates.","category":"page"},{"location":"moi/release_notes/#[v0.3.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.3.0)-(May-25,-2018)","page":"Release notes","title":"v0.3.0 (May 25, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Functions have been redefined to use arrays-of-structs instead of structs-of-arrays.\nImprovements to MockOptimizer.\nSignificant changes to Bridges.\nNew and improved unit tests.\nFixes for Julia 0.7.","category":"page"},{"location":"moi/release_notes/#[v0.2.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.2.0)-(April-24,-2018)","page":"Release notes","title":"v0.2.0 (April 24, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Improvements to and better coverage of Tests.\nDocumentation fixes.\nSolverName attribute.\nChanges to the NLP interface (new definition of variable order and arrays of structs for bound pairs and sparsity patterns).\nAddition of NLP tests.\nIntroduction of UniversalFallback.\ncopynames keyword argument to MOI.copy!.\nAdd Bridges submodule.","category":"page"},{"location":"moi/release_notes/#[v0.1.0](https://github.com/jump-dev/MathOptInterface.jl/releases/tag/v0.1.0)-(February-28,-2018)","page":"Release notes","title":"v0.1.0 (February 28, 2018)","text":"","category":"section"},{"location":"moi/release_notes/","page":"Release notes","title":"Release notes","text":"Initial public release.\nThe framework for MOI was developed at the JuMP-dev workshop at MIT in June 2017 as a sorely needed replacement for MathProgBase.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"developers/extensions/#extensions_manual","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"JuMP provides a variety of ways to extend the basic modeling functionality.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"tip: Tip\nThis documentation in this section is still a work-in-progress. The best place to look for ideas and help when writing a new JuMP extension are existing JuMP extensions. Examples include:BilevelJuMP.jl\nColuna.jl\nInfiniteOpt.jl\nPlasmo.jl\nPolyJuMP.jl\nSDDP.jl\nStochasticPrograms.jl\nSumOfSquares.jl\nvOptGeneric.jl","category":"page"},{"location":"developers/extensions/#Compatibility","page":"Extensions","title":"Compatibility","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"When writing JuMP extensions, you should carefully consider the compatibility guarantees that JuMP makes. In particular:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"All functions, structs, and constants which do not begin with an underscore (_) are public. These are always safe to use, and they should all have corresponding documentation.\nAll identifiers beginning with an underscore (_) are private. These are not safe to use, because they may break in any JuMP release, including patch releases.\nUnless explicitly mentioned in the documentation, all fields of a struct are private. These are not safe to use, because they may break in any JuMP release, including patch releases. An example of a field which is safe to use is the model.ext extension dictionary, which is documented in The extension dictionary.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"In general, we strongly encourage you to use only the public API of JuMP. If you are missing a feature, please open a GitHub issue.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"However, if you do use the private API (for example, because your feature request has not been implemented yet), then you must carefully restrict the versions of JuMP that your package is compatible with in the Project.toml file. The easiest way to do this is via the hyphen specifiers. For example, if your package supports all JuMP versions between v1.0.0 and v1.1.1, do:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"JuMP = \"1.0.0 - 1.1.1\"","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Then, whenever JuMP releases a new version, you should check if your package is still compatible and update the bound accordingly.","category":"page"},{"location":"developers/extensions/#Define-a-new-set","page":"Extensions","title":"Define a new set","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"To define a new set for JuMP, subtype MOI.AbstractScalarSet or MOI.AbstractVectorSet and implement Base.copy for the set.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> struct NewMOIVectorSet <: MOI.AbstractVectorSet\n           dimension::Int\n       end\n\njulia> Base.copy(x::NewMOIVectorSet) = x\n\njulia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @constraint(model, x in NewMOIVectorSet(2))\n[x[1], x[2]] ∈ NewMOIVectorSet(2)","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"However, for vector-sets, this requires the user to specify the dimension argument to their set, even though we could infer it from the length of x!","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"You can make a more user-friendly set by subtyping AbstractVectorSet and implementing moi_set.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> struct NewVectorSet <: JuMP.AbstractVectorSet end\n\njulia> JuMP.moi_set(::NewVectorSet, dim::Int) = NewMOIVectorSet(dim)\n\njulia> @constraint(model, x in NewVectorSet())\n[x[1], x[2]] ∈ NewMOIVectorSet(2)","category":"page"},{"location":"developers/extensions/#extend_variable_macro","page":"Extensions","title":"Extend @variable","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Just as Bin and Int create binary and integer variables, you can extend the @variable macro to create new types of variables. Here is an explanation by example, where we create a AddTwice type, that creates a tuple of two JuMP variables instead of a single variable.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"First, create a new struct. This can be anything. Our struct holds a VariableInfo object that stores bound information, and whether the variable is binary or integer.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> struct AddTwice\n           info::JuMP.VariableInfo\n       end","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Second, implement build_variable, which takes ::Type{AddTwice} as an argument, and returns an instance of AddTwice. Note that you can also receive keyword arguments.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> function JuMP.build_variable(\n           _err::Function,\n           info::JuMP.VariableInfo,\n           ::Type{AddTwice};\n           kwargs...\n       )\n           println(\"Can also use $kwargs here.\")\n           return AddTwice(info)\n       end","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Third, implement add_variable, which takes the instance of AddTwice from the previous step, and returns something. Typically, you will want to call add_variable here. For example, our AddTwice call is going to add two JuMP variables.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> function JuMP.add_variable(\n           model::JuMP.Model,\n           duplicate::AddTwice,\n           name::String,\n       )\n           a = JuMP.add_variable(\n               model,\n               JuMP.ScalarVariable(duplicate.info),\n               \"$(name)_a\",\n            )\n           b = JuMP.add_variable(\n               model,\n               JuMP.ScalarVariable(duplicate.info),\n               \"$(name)_b\",\n            )\n           return (a, b)\n       end","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Now AddTwice can be passed to @variable similar to Bin or Int, or through the variable_type keyword. However, now it adds two variables instead of one.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> model = Model();\n\njulia> @variable(model, x[i=1:2], variable_type = AddTwice, kw = i)\nCan also use Base.Pairs(:kw => 1) here.\nCan also use Base.Pairs(:kw => 2) here.\n2-element Vector{Tuple{VariableRef, VariableRef}}:\n (x[1]_a, x[1]_b)\n (x[2]_a, x[2]_b)\n\njulia> num_variables(model)\n4\n\njulia> first(x[1])\nx[1]_a\n\njulia> last(x[2])\nx[2]_b","category":"page"},{"location":"developers/extensions/#Extend-[@constraint](@ref)","page":"Extensions","title":"Extend @constraint","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"The @constraint macro has three steps that can be intercepted and extended: parse time, build time, and add time.","category":"page"},{"location":"developers/extensions/#Parse","page":"Extensions","title":"Parse","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"To extend the @constraint macro at parse time, implement one of the following methods:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"parse_constraint_head\nparse_constraint_call","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"warning: Warning\nExtending the constraint macro at parse time is an advanced operation and has the potential to interfere with existing JuMP syntax. Please discuss with the developer chatroom before publishing any code that implements these methods.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"parse_constraint_head should be implemented to intercept an expression based on the .head field of Base.Expr. For example:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> using JuMP\n\njulia> const MutableArithmetics = JuMP._MA;\n\njulia> model = Model(); @variable(model, x);\n\njulia> function JuMP.parse_constraint_head(\n           error_fn::Function,\n           ::Val{:≔},\n           lhs,\n           rhs,\n       )\n           println(\"Rewriting ≔ as ==\")\n           new_lhs, parse_code = MutableArithmetics.rewrite(lhs)\n           build_code = :(\n               build_constraint($(error_fn), $(new_lhs), MOI.EqualTo($(rhs)))\n           )\n           return false, parse_code, build_code\n       end\n\njulia> @constraint(model, x + x ≔ 1.0)\nRewriting ≔ as ==\n2 x = 1","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"parse_constraint_call should be implemented to intercept an expression of the form Expr(:call, op, args...). For example:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> using JuMP\n\njulia> const MutableArithmetics = JuMP._MA;\n\njulia> model = Model(); @variable(model, x);\n\njulia> function JuMP.parse_constraint_call(\n           error_fn::Function,\n           is_vectorized::Bool,\n           ::Val{:my_equal_to},\n           lhs,\n           rhs,\n       )\n           println(\"Rewriting my_equal_to to ==\")\n           new_lhs, parse_code = MutableArithmetics.rewrite(lhs)\n           build_code = if is_vectorized\n               :(build_constraint($(error_fn), $(new_lhs), MOI.EqualTo($(rhs)))\n           )\n           else\n               :(build_constraint.($(error_fn), $(new_lhs), MOI.EqualTo($(rhs))))\n           end\n           return parse_code, build_code\n       end\n\njulia> @constraint(model, my_equal_to(x + x, 1.0))\nRewriting my_equal_to to ==\n2 x = 1","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"tip: Tip\nWhen parsing a constraint you can recurse into sub-constraint (for example, the {expr} in z --> {x <= 1}) by calling parse_constraint.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"To prevent JuMP from promoting the set to the same value type as the model, use SkipModelConvertScalarSetWrapper.","category":"page"},{"location":"developers/extensions/#Build","page":"Extensions","title":"Build","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"To extend the @constraint macro at build time, implement a new build_constraint method.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"This may mean implementing a method for a specific function or set created at parse time, or it may mean implementing a method which handles additional positional arguments.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"build_constraint must return an AbstractConstraint, which can either be an AbstractConstraint already supported by JuMP, for example, ScalarConstraint or VectorConstraint, or a custom AbstractConstraint with a corresponding add_constraint method (see Add).","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"tip: Tip\nThe easiest way to extend @constraint is via an additional positional argument to build_constraint.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Here is an example of adding extra arguments to build_constraint:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> model = Model(); @variable(model, x);\n\njulia> struct MyConstrType end\n\njulia> function JuMP.build_constraint(\n            error_fn::Function,\n            f::JuMP.GenericAffExpr,\n            set::MOI.EqualTo,\n            extra::Type{MyConstrType};\n            d = 0,\n       )\n            new_set = MOI.LessThan(set.value + d)\n            return JuMP.build_constraint(error_fn, f, new_set)\n       end\n\njulia> @constraint(model, my_con, x == 0, MyConstrType, d = 2)\nmy_con : x ≤ 2","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"note: Note\nOnly a single positional argument can be given to a particular constraint. Extensions that seek to pass multiple arguments (for example, Foo and Bar) should combine them into one argument type (for example, FooBar).","category":"page"},{"location":"developers/extensions/#extension_add_constraint","page":"Extensions","title":"Add","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"build_constraint returns an AbstractConstraint object. To extend @constraint at add time, define a subtype of AbstractConstraint, implement build_constraint to return an instance of the new type, and then implement add_constraint.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Here is an example:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> model = Model(); @variable(model, x);\n\njulia> struct MyTag\n           name::String\n       end\n\njulia> struct MyConstraint{S} <: AbstractConstraint\n           name::String\n           f::AffExpr\n           s::S\n       end\n\njulia> function JuMP.build_constraint(\n            error_fn::Function,\n            f::AffExpr,\n            set::MOI.AbstractScalarSet,\n            extra::MyTag,\n       )\n            return MyConstraint(extra.name, f, set)\n       end\n\njulia> function JuMP.add_constraint(\n            model::Model,\n            con::MyConstraint,\n            name::String,\n       )\n            return add_constraint(\n                model,\n                ScalarConstraint(con.f, con.s),\n                \"$(con.name)[$(name)]\",\n            )\n       end\n\njulia> @constraint(model, my_con, 2x <= 1, MyTag(\"my_prefix\"))\nmy_prefix[my_con] : 2 x - 1 ≤ 0","category":"page"},{"location":"developers/extensions/#The-extension-dictionary","page":"Extensions","title":"The extension dictionary","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Every JuMP model has a field .ext::Dict{Symbol,Any} that can be used by extensions. This is useful if your extensions to @variable and @constraint need to store information between calls.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"The most common way to initialize a model with information in the .ext dictionary is to provide a new constructor:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> function MyModel()\n           model = Model()\n           model.ext[:MyModel] = 1\n           return model\n       end\nMyModel (generic function with 1 method)\n\njulia> model = MyModel()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> model.ext\nDict{Symbol, Any} with 1 entry:\n  :MyModel => 1","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"If you define extension data, implement copy_extension_data to support copy_model.","category":"page"},{"location":"developers/extensions/#Defining-new-JuMP-models","page":"Extensions","title":"Defining new JuMP models","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"If extending individual calls to @variable and @constraint is not sufficient, it is possible to implement a new model via a subtype of AbstractModel. You can also define new AbstractVariableRefs to create different types of JuMP variables.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"warning: Warning\nExtending JuMP in this manner is an advanced operation. We strongly encourage you to consider how you can use the methods mentioned in the previous sections to achieve your aims instead of defining new model and variable types. Consult the developer chatroom before starting work on this.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"If you define new types, you will need to implement a considerable number of methods, and doing so will require a detailed understanding of the JuMP internals. Therefore, the list of methods to implement is currently undocumented.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"The easiest way to extend JuMP by defining a new model type is to follow an existing example. A simple example to follow is the JuMPExtension module in the JuMP test suite. The best example of an external JuMP extension that implements an AbstractModel is InfiniteOpt.jl.","category":"page"},{"location":"developers/extensions/#Testing-JuMP-extensions","page":"Extensions","title":"Testing JuMP extensions","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"The JuMP test suite contains a large number of tests for JuMP extensions. You can run these tests by copying the MIT-licensed Kokako.jl file in the JuMP tests into your /test folder, and then adding this snippet to your /test/runtests.jl file:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"using MyJuMPExtension\nimport JuMP\ninclude(\"Kokako.jl\")\nconst MODULES_TO_TEST = Kokako.include_modules_to_test(JuMP)\nKokako.run_tests(\n    MODULES_TO_TEST,\n    MyJuMPExtension.MyModel,\n    MyJuMPExtension.MyVariableRef;\n    test_prefix = \"test_extension_\",\n)","category":"page"},{"location":"developers/extensions/#Set-an-optimize!-hook","page":"Extensions","title":"Set an optimize! hook","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Some extensions require modification to the problem after the user has finished constructing the problem, but before optimize! is called. For these situations, JuMP provides set_optimize_hook, which lets you intercept the optimize! call.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Here's a simple example of adding an optimize hook that extends optimize! to take a keyword argument silent:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> using JuMP, HiGHS\n\njulia> model = Model(HiGHS.Optimizer);\n\njulia> @variable(model, x >= 1.5, Int);\n\njulia> @objective(model, Min, x);\n\njulia> function silent_hook(model; silent::Bool)\n           if silent\n               set_silent(model)\n           else\n               unset_silent(model)\n           end\n           ## Make sure you set ignore_optimize_hook = true, or we'll\n           ## recursively enter the optimize hook!\n           return optimize!(model; ignore_optimize_hook = true)\n       end\nsilent_hook (generic function with 1 method)\n\njulia> set_optimize_hook(model, silent_hook)\nsilent_hook (generic function with 1 method)\n\njulia> optimize!(model; silent = true)\n\njulia> optimize!(model; silent = false)\nSolution has               num          max          sum\nCol     infeasibilities      0            0            0\nInteger infeasibilities      0            0            0\nRow     infeasibilities      0            0            0\nRow     residuals            0            0            0\nPresolving model\n0 rows, 0 cols, 0 nonzeros\n0 rows, 0 cols, 0 nonzeros\nPresolve: Optimal\n\nSolving report\n  Status            Optimal\n  Primal bound      2\n  Dual bound        2\n  Gap               0% (tolerance: 0.01%)\n  Solution status   feasible\n                    2 (objective)\n                    0 (bound viol.)\n                    0 (int. viol.)\n                    0 (row viol.)\n  Timing            0.00 (total)\n                    0.00 (presolve)\n                    0.00 (postsolve)\n  Nodes             0\n  LP iterations     0 (total)\n                    0 (strong br.)\n                    0 (separation)\n                    0 (heuristics)","category":"page"},{"location":"developers/extensions/#Creating-new-container-types","page":"Extensions","title":"Creating new container types","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"JuMP macros (for example, @variable) accept a container keyword argument to force the type of container that is chosen. By default, JuMP supports container = Array, container = DenseAxisArray, container = SparseAxisArray and container = Auto. You can extend support to user-defined types by implementing Containers.container.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"For example, here is a container that reverses the order of the indices:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> struct Foo end\n\njulia> function Containers.container(f::Function, indices, ::Type{Foo})\n           return reverse([f(i...) for i in indices])\n       end\n\njulia> model = Model();\n\njulia> @variable(model, x[1:3], container = Foo)\n3-element Vector{VariableRef}:\n x[3]\n x[2]\n x[1]\n\njulia> x[1]\nx[3]\n\njulia> @variable(model, y[1:3, 1:2], container = Foo)\n3×2 Matrix{VariableRef}:\n y[3,2]  y[3,1]\n y[2,2]  y[2,1]\n y[1,2]  y[1,1]\n\njulia> y[1, 1]\ny[3,2]\n\njulia> @variable(model, z[i=1:3; isodd(i)], container = Foo)\n2-element Vector{VariableRef}:\n z[3]\n z[1]\n\njulia> z[2]\nz[1]","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"warning: Warning\nIf you are a general user, you should not need to create a new container type. Instead, consider following User-defined containers and create a new container using standard Julia syntax. For example:julia> model = Model();\n\njulia> @variable(model, x[1:3])\n3-element Vector{VariableRef}:\n x[1]\n x[2]\n x[3]\n\njulia> y = reverse(x)\n3-element Vector{VariableRef}:\n x[3]\n x[2]\n x[1]","category":"page"},{"location":"developers/extensions/#Performance-tips-for-extensions","page":"Extensions","title":"Performance tips for extensions","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"The function-in-set design of MathOptInterface causes type stability issues in Julia if you try to iterate over all of the constraints in a model. The easiest way to fix this is to use a function barrier.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"For example, instead of:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"function all_names_slow(model)\n    names = Set{String}()\n    for ci in all_constraints(model)\n        push!(names, name(ci))\n    end\n    return names\nend","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"use:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"function _function_barrier(names, model, ::Type{F}, ::Type{S}) where {F,S}\n    for ci in all_constraints(model, F, S)\n        push!(names, name(ci))\n    end\n    return\nend\n\nfunction all_names_fast(model)\n    names = Set{String}()\n    for (F, S) in list_of_constraint_types(model)\n        _function_barrier(names, model, F, S)\n    end\n    return names\nend","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"note: Note\nIt is important to explicitly type the F and S arguments. If you leave them untyped, for example, function _function_barrier(names, model, F, S), Julia will not specialize the function calls and performance will not be improved.","category":"page"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/changelog.md\"","category":"page"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"CurrentModule = MathOptInterface","category":"page"},{"location":"moi/changelog/#Release-notes","page":"Release notes","title":"Release notes","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"moi/changelog/#v1.29.0-(April-19,-2024)","page":"Release notes","title":"v1.29.0 (April 19, 2024)","text":"","category":"section"},{"location":"moi/changelog/#Added","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added support for Indicator constraints in FileFormats.LP (#2483)","category":"page"},{"location":"moi/changelog/#Fixed","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"The CBF writer now attempts to write VectorOfVariables constraints in the VAR section, instead of automatically promoting them to VectorAffineFunction. (#2478) (#2482) (#2486)\nFixed a performance issue adding ScalarAffineFunction and ScalarQuadraticFunctions to Nonlinear.Model (@2487)\nFixed a bug reading MPS files with integer variables and an entry in the BOUNDS section (#2490)\nFixed the MPS writer to use LI and UI instead of LO and UP for integer variables (#2492)","category":"page"},{"location":"moi/changelog/#Other","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Updated versions in CI (#2484) (#2489)\nFixed duplicate names in tests (#2485)","category":"page"},{"location":"moi/changelog/#v1.28.1-(April-13,-2024)","page":"Release notes","title":"v1.28.1 (April 13, 2024)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-2","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug reading MPS files with integer variables and no corresponding entry in the BOUNDS section (#2480)","category":"page"},{"location":"moi/changelog/#v1.28.0-(April-11,-2024)","page":"Release notes","title":"v1.28.0 (April 11, 2024)","text":"","category":"section"},{"location":"moi/changelog/#Added-2","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added Bridges.Constraint.ComplexNormInfinityToSecondOrderConeBridge (#2451)","category":"page"},{"location":"moi/changelog/#Fixed-3","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a correctness bug getting the set of a constraint that used both variable and constraint bridges (#2464) (#2472)\nFixed MethodError in some bridges when called with Complex-valued functions (#2468) (#2475)\nFixed reading MPS files that use * as the start of a name and not as a comment (#2470)","category":"page"},{"location":"moi/changelog/#Other-2","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Updated solver-tests.yml (#2465)\nRemoved two unused methods from MOI.Bridges (#2466)\nDocumentation updates (#2467), (#2473), (#2474)\nSimplify reading CBF files (#2476)","category":"page"},{"location":"moi/changelog/#v1.27.1-(March-27,-2024)","page":"Release notes","title":"v1.27.1 (March 27, 2024)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-4","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed passing non-IndexMap in Utilities.pass_attributes (#2458)\nFixed getting MOI.ListOfConstraintAttributesSet for VectorOfConstraints (#2459)","category":"page"},{"location":"moi/changelog/#Other-3","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Updated solver-tests.yml (#2453) (#2455)\nFixed path in error message (#2461)","category":"page"},{"location":"moi/changelog/#v1.27.0-(February-27,-2024)","page":"Release notes","title":"v1.27.0 (February 27, 2024)","text":"","category":"section"},{"location":"moi/changelog/#Added-3","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added support for sign(x) in Nonlinear (#2444)","category":"page"},{"location":"moi/changelog/#Fixed-5","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed copy_to to FileFormats.NL when Name is set (#2446)","category":"page"},{"location":"moi/changelog/#v1.26.0-(February-22,-2024)","page":"Release notes","title":"v1.26.0 (February 22, 2024)","text":"","category":"section"},{"location":"moi/changelog/#Added-4","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added .initialize_timer to Nonlinear.Evaluator (#2438)","category":"page"},{"location":"moi/changelog/#Fixed-6","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed writing binary variables with bounds in FileFormats.MPS (#2431)\nFixed parsing suffixes in FileFormats.NL (#2436)\nFixed writing free constraints in FileFormats.NL (#2437)\nFixed potential for unsafe out-of-bounds write in Hessian evaluation (#2441)","category":"page"},{"location":"moi/changelog/#Other-4","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed formatting of BasisStatusCode docstring (#2430)\nRefactor test/Fileformats/MPS/MPS.jl (#2433)","category":"page"},{"location":"moi/changelog/#v1.25.3-(February-14,-2024)","page":"Release notes","title":"v1.25.3 (February 14, 2024)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-7","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed number type in get_fallback (#2414)\nFixed error type thrown when a variable bridge cannot un-bridge the function. It used to throw ErrorException. It now throws MOI.GetAttributeNotAllowed{MOI.ConstraintFunction}. This enables Utilities.CachingOptimizer to more uniformly implement fallbacks for common bridges like Bridges.Variable.ZerosBridge. (#2415)\nFixed tests on upcoming Julia v1.11 (#2428)","category":"page"},{"location":"moi/changelog/#Other-5","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Improved performance of Bridges.Constraint.CountDistinctToMILPBridge (#2416)\nImproved performance of FileFormats.MPS writer (#2421) (#2424) (#2426)\nUpdated solver-tests.yml (#2423)\nFixed typos in src/attributes.jl (#2429)","category":"page"},{"location":"moi/changelog/#v1.25.2-(January-29,-2024)","page":"Release notes","title":"v1.25.2 (January 29, 2024)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-8","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed getting ConstraintPrimal if variable bridges are present (#2396)\nFixed modify_function! for ScalarQuadraticCoefficientChange (#2408)\nFixed writing FileFormats.MOF files if ScalarNonlinearFunction contains ScalarAffineFunction or ScalarQuadraticFunction (#2409)","category":"page"},{"location":"moi/changelog/#Other-6","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Clarified ordering of nonlinear tape in documentation (#2401)\nUpdated vale.sh (#2403) (#2404)\nTidied `src/Utilities/results.jl (#2411)","category":"page"},{"location":"moi/changelog/#v1.25.1-(January-11,-2024)","page":"Release notes","title":"v1.25.1 (January 11, 2024)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-9","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed map_indices for AbstractAutomaticDifferentiation (#2394)\nFixed deleting a variable in Bridges.Variable.VectorizeBridge (#2393)\nFixed super type of LowerBoundAlreadySet and UpperBoundAlreadySet (#2397)","category":"page"},{"location":"moi/changelog/#Other-7","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Removed a duplicated test (#2395)","category":"page"},{"location":"moi/changelog/#v1.25.0-(January-5,-2024)","page":"Release notes","title":"v1.25.0 (January 5, 2024)","text":"","category":"section"},{"location":"moi/changelog/#Added-5","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added the AutomaticDifferentiationBackend attribute (#2386)","category":"page"},{"location":"moi/changelog/#Fixed-10","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed initialize for Nonlinear.ExprGraphOnly (#2387)\nFixed converting 0-valued ScalarAffineFunction and ScalarQuadraticFunction to ScalarNonlinearFunction (#2388)\nFixed reading .nl files with non-empty variable and constraint names (#2390)\nFixed reading .nl files with no objective (#2391)\nFixed reading .nl files with free ranged constraints (#2392)","category":"page"},{"location":"moi/changelog/#v1.24.0-(January-2,-2024)","page":"Release notes","title":"v1.24.0 (January 2, 2024)","text":"","category":"section"},{"location":"moi/changelog/#Added-6","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added get_fallback for ConstraintDual of variable bounds (#2373)","category":"page"},{"location":"moi/changelog/#Fixed-11","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed RSOCtoPSDBridge for dimension 2 (#2359)\nFixed getting ConstraintFunction in conversion bridge (#2360)\nFixed map_indices (#2367)\nFixed SlackBridgePrimalDualStart for non-slack bridges (#2365)\nFixed test_attribute_TimeLimitSec (#2370)\nFixed order of model attributes during copy_to (#2372)\nFixed ConstraintIndex conflicts between variable and constraint bridges (#2362)\nFixed corner-case deletion in bridges (#2377)\nFixed ListOfVariablesWithAttributeSet for variable bridges (#2380)\nFixed SlackBridge if scalar constant is not zero (#2382)\nFixed setting multiple bounds on a bridged variable (#2383)","category":"page"},{"location":"moi/changelog/#Other-8","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Minor documentation improvements (#2355), (#2374)\nImproved side_dimension_for_vectorized_dimension (#2356)\nAdded DiffOpt and ParametricOptInterface to solver-tests.yml (#2368)\nRefactored SDPAModel into a separate test file and test more widely (#2364), (#2357)","category":"page"},{"location":"moi/changelog/#v1.23.0-(November-29,-2023)","page":"Release notes","title":"v1.23.0 (November 29, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Added-7","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added ConstraintPrimalStart for Bridges.Constraint.GeoMeanBridge (#2348)\nAdded verbose keyword argument to Test.runtests (#2347)\nAdded Bridges.FirstBridge attribute (#2211)","category":"page"},{"location":"moi/changelog/#Fixed-12","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed Test.test_model_Name_VariableName_ConstraintName (#2349)\nFixed errors thrown when querying an attribute is not supported, like when Utilities.CachingOptimizer is not attached to an optimizer (#2350)","category":"page"},{"location":"moi/changelog/#v1.22.0-(November-6,-2023)","page":"Release notes","title":"v1.22.0 (November 6, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Added-8","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added new bridges (#2318)\nBridges.Constraint.SOS1ToMILPBridge\nBridges.Constraint.SOS2ToMILPBridge\nBridges.Constraint.IndicatorToMILPBridge\nAdded starting values for bridges (#2330) (#2337) (#2338) (#2339)\nBridges.Constraint.NumberConversionBridge\nBridges.Constraint.SquareBridge\nBridges.Variable.HermitianToSymmetricPSDBridge\nBridges.Variable.ParameterToEqualToBridge\nBridges.Variable.RSOCtoPSDBridge\nAdded ListOfVariablesWithAttributeSet and ListOfConstraintsWithAttributeSet (#2331) (#2342)\nAdded support for printing ConstraintName when models are printed (#2336)","category":"page"},{"location":"moi/changelog/#Fixed-13","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"ScalarFunctionConstantNotZero errors are now skipped in Test.runtests (#2325)\nFixed VectorNonlinearFunction support in Bridges.Constraint.NormOneBridge and Bridges.Constraint.NormInfinityBridge (#2324)\nFixed various get for ConstraintFunction to return a copy, and added tests (#2328)\nFixed supports of ConstraintPrimalStart and VariablePrimalStart for some bridges (#2340)","category":"page"},{"location":"moi/changelog/#Other-9","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed typo in docstring of ScalarAffineFunction (#2326)\nAdded Gurobi to solver-tests.yml (#2332)\nImproved the error message when a bridge does not support an attribute (#2329)\nImproved documentation for implementing a bridge (#2334)\nUpdated [compat] bounds in Project.toml (#2344)","category":"page"},{"location":"moi/changelog/#v1.21.0-(October-25,-2023)","page":"Release notes","title":"v1.21.0 (October 25, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Added-9","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added SolutionLimit attribute (#2291)\nAdded support for MathOptFormat v1.6 and v1.7 (#2293) (#2298) (#2299) (#2321)\nAdded ScalarQuadraticCoefficientChange (#2296) (#2320) (#2322)\nAdded Utilities.modify_constants (#2300)\nAdded support for is_empty and empty! of Nonlinear.Model (#2305)\nAdded Bridges.Objective.FunctionConversionBridge (#2303)\nAdded Bridges.ModifyBridgeNotAllowed (#2307)\nAdded more sets for Utilities.distance_to_set (#2314)","category":"page"},{"location":"moi/changelog/#Fixed-14","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed test_attribute_TimeLimitSec (#2256)\nFixed conversion cost in objective bridges (#2309)","category":"page"},{"location":"moi/changelog/#Other-10","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed flakey link checking in documentation (#2297)\nMinor documentation fixes (#2304) (#2313)\nFixed [compat] section of Project.toml (#2310)\nAdded MultiObjectiveAlgorithms to solver-tests.yml (#2312)","category":"page"},{"location":"moi/changelog/#v1.20.1-(September-24,-2023)","page":"Release notes","title":"v1.20.1 (September 24, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-15","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Removed incorrect kwargs in some copy_to methods (#2272)\nFixed ConstraintDualStart for Bridges.Constraint.SplitIntervalBridge (#2275)\nFixed MethodError when trying to modify a variable objective (#2278)\nFixed stack-overflow in Utilities.operate(+,...) with many arguments (#2285) (#2290)","category":"page"},{"location":"moi/changelog/#Other-11","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added MathOptSetDistances to solver-tests.yml (#2265)\nUpdated Documenter (#2266)\nFixed various JET errors (#2267) (#2269) (#2270) (#2271) (#2276) (#2277) (#2289)\nVarious style improvements\nReplaced using Package with import Package where possible (#2274)\nRemoved Utilities.EMPTYSTRING (#2283)\nRemoved unnecessary const acronyms in Utilities (#2280) (#2281)\nRemoved invalid and unused method (#2286)\nRefactored src/Utilities/model.jl (#2287)","category":"page"},{"location":"moi/changelog/#v1.20.0-(September-7,-2023)","page":"Release notes","title":"v1.20.0 (September 7, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Added-10","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added Scaled set (#2237) (#2263) (#2264)\nAdded ObjectiveLimit attribute (#2257)","category":"page"},{"location":"moi/changelog/#Other-12","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Updated dependencies (#2258)\nImproved performance of ScalarNonlinearFunction utilities (#2259)\nFixed docstrings (#2261)","category":"page"},{"location":"moi/changelog/#v1.19.0-(August-15,-2023)","page":"Release notes","title":"v1.19.0 (August 15, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Added-11","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added VectorNonlinearFunction (#2201)\nAdded new bridges\nBridges.Constraint.IntegerToZeroOneBridge (#2205)\nBridges.Constraint.ToScalarQuadraticBridge (#2235)\nBridges.Constraint.ToVectorQuadraticBridge (#2235)\nBridges.Constraint.ToScalarNonlinearBridge (#2233) (#2235)\nBridges.Constraint.FunctionConversionBridge (#2235)\nAdded Bridges.bridging_cost for setting a bridge-specific cost in the bridging graph (#2235)\nAdded Utilities.eval_variables support for ScalarNonlinearFunction (#2218) (#2219)\nAdded support for ScalarNonlinearFunction in FileFormats.NL (#2228) (#2231)\nAdded support for writing non-Float64 functions in FileFormats.MOF\nAdded Utilities.lazy_map (#2254)","category":"page"},{"location":"moi/changelog/#Fixed-16","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed method ambiguities in operate (#2224)\nFixed reading LP file with a -infinity <= x <= +infinity variable (#2225)\nFixed missing require in Test.test_nonlinear_duals (#2230)\nFixed bug in ConstraintPrimal of Bridges.Constraint.QuadtoSOCBridge (#2240)","category":"page"},{"location":"moi/changelog/#Other-13","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added extensions to solver-tests.yml (#2229)\nRefactored test/Benchmarks (#2234)\nFixed warnings in tests (#2241) (#2243)\nSmall refactoring of bridges for upcoming VectorNonlinearFunction (#2244) (#2245)\nFixed various typos (#2251) (#2255)\nPartitioned how we run the tests on GitHub actions (#2252) (#2253)","category":"page"},{"location":"moi/changelog/#v1.18.0-(June-23,-2023)","page":"Release notes","title":"v1.18.0 (June 23, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Added-12","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added Bridges.Objective.SlackBridgePrimalDualStart (#2194)\nAdded constraint_gradient_structure and eval_constraint_gradient (#2200)","category":"page"},{"location":"moi/changelog/#Fixed-17","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a missing @require in MOI.Test (#2195) (#2196)\nFixed incorrect usage of Utilities.operate! in bridges (#2207) (#2216)\nFixed splatting nonlinear expression with univariate operator (#2221)","category":"page"},{"location":"moi/changelog/#Other-14","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Removed unused argument names (#2199)\nReduced memory requirement for tests (#2204)\nRefactored Utilities.promote_operation (#2206)\nImproved code style in Utilities/mutable_arithmetics.jl (#2209)\nRefactored various methods in Utilities/functions.jl (#2208) (#2212) (#2213) (#2214) (#2215)","category":"page"},{"location":"moi/changelog/#v1.17.1-(June-6,-2023)","page":"Release notes","title":"v1.17.1 (June 6, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-18","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed comparison of ScalarFunctionConstantNotZero (#2190)","category":"page"},{"location":"moi/changelog/#Other-15","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added documentation for enum instances (#2186)\nUpdated chatroom links in documentation (#2188)\nChanged the documentation to build on Julia v1.9 (#2191)","category":"page"},{"location":"moi/changelog/#v1.17.0-(June-1,-2023)","page":"Release notes","title":"v1.17.0 (June 1, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Added-13","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added ScalarNonlinearFunction (#2059)\nAdded a variety of tests for NormSpectralCone, NormNuclearCone, and HermitianPositiveSemidefiniteConeTriangle (#2174)\nAdded Utilities.value_type for computing the value type of a function (#2176)","category":"page"},{"location":"moi/changelog/#Fixed-19","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed support for external sets in Utilities.loadfromstring! (#2177)\nFixed promote_operation for ScalarNonlinearFunction (#2179)\nFixed two issues in FileFormats.LP when reading files with quadratic functions (#2182) (#2184)","category":"page"},{"location":"moi/changelog/#v1.16.0-(May-16,-2023)","page":"Release notes","title":"v1.16.0 (May 16, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Added-14","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added support for MathOptFormat v1.3 and v1.4 (#2158) (#2169)\nAdded new method to the nonlinear API (#2162) (#2164)\neval_hessian_constraint\neval_hessian_objective\nhessian_constraint_structure\nhessian_objective_structure\nAdded new sets\nNormCone (#2119)\nScaledPositiveSemidefiniteConeTriangle (#2154)","category":"page"},{"location":"moi/changelog/#Fixed-20","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed support for Julia v1.9 to work around a bug in the upstream Julia compiler (#2161) (#2163)\nFixed a correctness bug in Bridges.Constraint.HermitianToSymmetricPSDBridge (#2171)\nFixed convert(::VariableIndex, ::ScalarAffineFunction) when the function has terms with 0coefficients (#2173)","category":"page"},{"location":"moi/changelog/#Other-16","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed solver-tests.yml (#2157)\nUpdated documentation links to developer chatroom (#2160)\nAdded various tests for bridges (#2156)\nAdded checklists to the developer documentation (#2167) (#2168)","category":"page"},{"location":"moi/changelog/#v1.15.1-(April-25,-2023)","page":"Release notes","title":"v1.15.1 (April 25, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-21","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed deleting a variable in a bridged objective (#2150)","category":"page"},{"location":"moi/changelog/#v1.15.0-(April-19,-2023)","page":"Release notes","title":"v1.15.0 (April 19, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Added-15","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added Bridges.Objective.VectorFunctionizeBridge (#2139)","category":"page"},{"location":"moi/changelog/#Fixed-22","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed support for Rational in Bridges.Constraint.SplitIntervalBridge (#2137)\nFixed printing of LaTeX models (#2141)\nFixed modify in Bridges.Objective.VectorSlackBridge (#2144)\nFixed NAME record with spaces in FileFormats.MPS (#2146)\nFixed deleting a variable in a bridged objective (#2147)","category":"page"},{"location":"moi/changelog/#Other-17","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Add a test for variables in one-sided open Interval sets (#2133)\nMinor style fixes in the source code (#2148)","category":"page"},{"location":"moi/changelog/#v1.14.1-(April-6,-2023)","page":"Release notes","title":"v1.14.1 (April 6, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-23","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug in Bridges.print_active_bridges (#2135)","category":"page"},{"location":"moi/changelog/#Other-18","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added a warning when an ambiguous string is passed to exclude in Test.runtests (#2136)","category":"page"},{"location":"moi/changelog/#v1.14.0-(April-4,-2023)","page":"Release notes","title":"v1.14.0 (April 4, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Added-16","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added support for starting values in Bridges.Constraint.QuadtoSOCBridge (#2115)\nAdded support for Regex in the include and exclude arguments to Test.runtests (#2129)\nAdded Bridges.print_active_bridges methods for individual objectives and constraints (#2128)","category":"page"},{"location":"moi/changelog/#Fixed-24","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed ResultCount when parsing .sol files in FileFormats.NL (#2130)","category":"page"},{"location":"moi/changelog/#v1.13.2-(March-21,-2023)","page":"Release notes","title":"v1.13.2 (March 21, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-25","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed splatting of containers in MOI.Nonlinear (#2120)\nFixed a bug reading LP files with default bounds (#2121)\nFixed a bug in which Bridges.Constraint.HermitianToSymmetricPSDBridge was not enabled by default (#2123)","category":"page"},{"location":"moi/changelog/#Other-19","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed typos in the documentation (#2114)\nFunctions now print to the REPL in algebraic form. This is potentially breaking if you have tests which rely on a specific String form of MOI functions. (#2112) (#2126)","category":"page"},{"location":"moi/changelog/#v1.13.1-(March-3,-2023)","page":"Release notes","title":"v1.13.1 (March 3, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Other-20","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added the Google style guide to the documentation linter Vale, and fixed the resulting warnings (#2110)\nImproved the docstrings in src/functions.jl (#2108)","category":"page"},{"location":"moi/changelog/#v1.13.0-(February-28,-2023)","page":"Release notes","title":"v1.13.0 (February 28, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Added-17","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added Bridges.Constraint.NumberConversionBridge (#2091)\nAdded Parameter set (#2095) (#2105) (#2106) (#2109)\nAdded with_cache_type argument to instantiate (#2097)\nAdded support for HermitianPositiveSemidefiniteConeTriangle in Utilities.Model (#2100)","category":"page"},{"location":"moi/changelog/#Fixed-26","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed bug when Utilities.@product_of_sets is empty (#2101)\nFixed Bridges.print_active_bridges when variable bridge is an AbstractScalarSet (#2107)","category":"page"},{"location":"moi/changelog/#Other-21","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added tests for vector-valued objective functions in FileFormats.MOF (#2093)\nUsed and documented preference for import MathOptInterface as MOI (#2096)\nFix and test links in the documentation with linkcheck = true (#2098)\nImproved docstrings of sets in src/sets.jl (#2099)\nSkip checking flakey links in documentation with linkcheck_ignore  (#2103)","category":"page"},{"location":"moi/changelog/#v1.12.0-(February-10,-2023)","page":"Release notes","title":"v1.12.0 (February 10, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Added-18","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added support for vector-valued objective functions (#2070)\nAdded a Utilities.distance_to_set method for SecondOrderCone (#2060)","category":"page"},{"location":"moi/changelog/#Fixed-27","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a number of constraint bridges so that Bridges.final_touch can be called multiple times without forcing a rebuild of the reformulation (#2089)","category":"page"},{"location":"moi/changelog/#Other-22","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added new tests that a set ObjectiveFunction appears in ListOfModelAttributesSet (#2085)\nImproved the docstrings of a number of constraint-programming related sets (#2087)","category":"page"},{"location":"moi/changelog/#v1.11.5-(January-24,-2023)","page":"Release notes","title":"v1.11.5 (January 24, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-28","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug writing .lp files with an off-diagonal quadratic objective (#2082)","category":"page"},{"location":"moi/changelog/#Other-23","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added SnoopPrecompile directives for reduced time-to-first-X in Julia v1.9 (#2080)","category":"page"},{"location":"moi/changelog/#v1.11.4-(January-12,-2023)","page":"Release notes","title":"v1.11.4 (January 12, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-29","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug reading .lp files with an Integer section (#2078)","category":"page"},{"location":"moi/changelog/#v1.11.3-(January-12,-2023)","page":"Release notes","title":"v1.11.3 (January 12, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-30","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a performance bug when deleting a vector of constraints (#2072)\nFixed a bug reading .lp files with terms like x -1 y (#2076)","category":"page"},{"location":"moi/changelog/#Other-24","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Documented the two-argument method of optimize! (#2074)","category":"page"},{"location":"moi/changelog/#v1.11.2-(January-2,-2023)","page":"Release notes","title":"v1.11.2 (January 2, 2023)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-31","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug reading .mof.json files with ConstraintName set for VariableIndex constraints (#2066)\nFixed a bug reading .mof.json files with nonlinear objectives and no constraints (#2068)","category":"page"},{"location":"moi/changelog/#v1.11.1-(December-22,-2022)","page":"Release notes","title":"v1.11.1 (December 22, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-32","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug reading .mof.json files with integer coefficients for affine and quadratic functions (#2063)","category":"page"},{"location":"moi/changelog/#v1.11.0-(December-2,-2022)","page":"Release notes","title":"v1.11.0 (December 2, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Added-19","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added Utilities.PenaltyRelaxation and Utilities.ScalarPenaltyRelaxation (#1995)\nAdded Utilities.distance_to_set (#2048)\nAdded support for ConstraintPrimalStart and ConstraintDualStart in FileFormats.MOF (#2056)","category":"page"},{"location":"moi/changelog/#Other-25","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Tidied these release notes (#2055)","category":"page"},{"location":"moi/changelog/#v1.10.0-(November-22,-2022)","page":"Release notes","title":"v1.10.0 (November 22, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Added-20","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added new methods set(::OptimizerWithAttributes, ::RawOptimizerAttribute, value) and get(::OptimizerWithAttributes, ::RawOptimizerAttribute) (#2049)\nAdded new methods Utilities.DoubleDicts.outer_keys and Utilities.DoubleDicts.nonempty_outer_keys (#2052)","category":"page"},{"location":"moi/changelog/#Fixed-33","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed Bridges.Objective.SlackBridge when the objective function is complex-valued (#2036) (#2038)\nFixed docstring of Test.runtests to clarify the warn_unsupported argument (#2037)\nFixed reading of free variables in FileFormats.LP (#2044)\nFixed numerous edge cases reading files from QPLIB using FileFormats.LP (#2042) (#2044)\nFixed situations in which x^y returns a complex value in Nonlinear (#2050)","category":"page"},{"location":"moi/changelog/#Other-26","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Improved the error message thrown when a user-defined nonlinear function does not accept splatted input (#2032)\nRemoved specialized iterators for keys and values in Utilities.CleverDicts (#2051)","category":"page"},{"location":"moi/changelog/#v1.9.0-(October-29,-2022)","page":"Release notes","title":"v1.9.0 (October 29, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Added-21","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added default fallback for getting ListOfConstraintIndices and NumberOfConstraints when the constraint type is unsupported by the model (#2021)\nAdded support for min and max in nonlinear expressions (#2023)\nAdded support for Indicator{EqualTo{T}} constraints in FileFormats.MPS (#2022)\nAdded default fallback for write_to_file and read_from_file (#2029)","category":"page"},{"location":"moi/changelog/#Fixed-34","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed Constraint.ZeroOneBridge by adding new bounds as affine constraints instead of variable bounds (#1879)\nFixed reading free rows in FileFormats.MPS files (#2009)\nFixed parsing of OBJSENSE blocks in FileFormats.MPS files (#2016) (#2019)\nFixed the parsing of deeply nested nonlinear expressions by removing the use of recursion (#2020)\nFixed the requirements check in Test.test_constraint_get_ConstraintIndex (#2024)","category":"page"},{"location":"moi/changelog/#v1.8.2-(September-20,-2022)","page":"Release notes","title":"v1.8.2 (September 20, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Documentation","page":"Release notes","title":"Documentation","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added vale as a documentation linter (#2002)\nImproved styling of code blocks in the PDF (#1999) (#2000)\nFixed a number of typos in the documentation (#2001) (#2003)","category":"page"},{"location":"moi/changelog/#v1.8.1-(September-12,-2022)","page":"Release notes","title":"v1.8.1 (September 12, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-35","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug in supports(::AbstractBridgeOptimizer for constraint attributes (#1991) (#1992)","category":"page"},{"location":"moi/changelog/#v1.8.0-(September-1,-2022)","page":"Release notes","title":"v1.8.0 (September 1, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Added-22","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added new sets\nHyperRectangle (#1961)\nReified (#1955)\nAdded new bridges (#1955)\nBridges.Constraint.ReifiedAllDifferentToCountDistinctBridge\nBridges.Constraint.ReifiedCountDistinctToMILPBridge\nBridges.Constraint.SplitHyperRectangleBridge\nAdded support for atan(y, x) in Nonlinear (#1987)","category":"page"},{"location":"moi/changelog/#Fixed-36","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Lazily construct expressions in Nonlinear so that expressions are updated when Nonlinear.Parameter values are updated (#1984)\nAllow NORM_LIMIT as a TerminationStatus for unbounded problems in Test (#1990)","category":"page"},{"location":"moi/changelog/#v1.7.0-(August-16,-2022)","page":"Release notes","title":"v1.7.0 (August 16, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Added-23","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added new sets\nHermitianPositiveSemidefiniteConeTriangle\nAdded new optimizer-independent options\nRelativeGapTolerance\nAbsoluteGapTolerance\nAdded new bridges\nBridges.Constraint.GeoMeanToPowerBridge\nBridges.Constraint.HermitianToSymmetricPSDBridge\nBridges.Constraint.IndicatorGreaterToLessThanBridge\nBridges.Constraint.IndicatorLessToGreaterThanBridge\nBridges.Constraint.SplitComplexZerosBridge\nBridges.Constraint.SplitComplexEqualToBridge\nBridges.Objective.QuadratizeBridge\nAdded support for generic number types in Utilities.loadfromstring!\nUpdated FileFormats.MOF to MathOptFormat v1.1, enabling support for constraint programming sets in the MOF file format\nAdded support in various FileFormats for\nindicator constraints in FileFormats.MPS\nquadratic constraints and an objective in FileFormats.LP\nquadratic constraints and an objective in FileFormats.MPS","category":"page"},{"location":"moi/changelog/#Fixed-37","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed some missing promotion rules","category":"page"},{"location":"moi/changelog/#Other-27","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Improved the performance of Jacobian products in Nonlinear\nRemoved an un-needed copy in Utilities.modify_function\nVarious clean-ups in Bridges/bridge_optimizer.jl","category":"page"},{"location":"moi/changelog/#v1.6.1-(July-23,-2022)","page":"Release notes","title":"v1.6.1 (July 23, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-38","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added support for ExponentialCone in MatrixOfConstraints\nFix PSDSquare_3 test to reflect a previously fixed bug getting the ConstraintDual of a PositiveSemidefiniteConeSquare constraint","category":"page"},{"location":"moi/changelog/#v1.6.0-(July-2,-2022)","page":"Release notes","title":"v1.6.0 (July 2, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Added-24","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added Bridges.needs_final_touch and Bridges.final_touch\nAdded new bridges from constraint programming sets to mixed-integer linear programs:\nAllDifferentToCountDistinctBridge\nCountAtLeastToCountBelongsBridge\nCountBelongsToMILPBridge\nCountDistinctToMILPBridge\nCountGreaterThanToMILPBridge\nCircuitToMILPBridge","category":"page"},{"location":"moi/changelog/#Fixed-39","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Relax an instance of ::Vector to ::AbstractVector in MOI.Nonlinear\nFix BinPackingToMILPBridge to respect variable bounds\nFix SemiToBinaryBridge to throw error if other bounds are set","category":"page"},{"location":"moi/changelog/#v1.5.0-(June-27,-2022)","page":"Release notes","title":"v1.5.0 (June 27, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Added-25","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added GetAttributeNotAllowed for solvers to indicate when getting an attribute encounters an error\nAdded Utilities.get_fallback support for ObjectiveValue and DualObjectiveValue\nAdded new bridges:\nRootDetConeSquare to RootDetConeTriangle\nLogDetConeSquare to LogDetConeTriangle\nBinPacking to a mixed-integer linear program\nTable to a mixed-integer linear program\nAdded Bridges.print_active_bridges to display the current optimal hyper-path in a Bridges.LazyBridgeOptimizer","category":"page"},{"location":"moi/changelog/#Fixed-40","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed ZeroOne tests with lower and upper bounds\nFixed error in FileFormats.LP when reading a malformed file\nFixed reading of nonlinear programs in FileFormats.MOF\nFixed bug in ConstraintDual when using SquareBridge","category":"page"},{"location":"moi/changelog/#Other-28","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Improved documentation of nonlinear API\nDocumented duality convention for PositiveSemidefiniteConeSquare sets\nFixed typo in Bridges.Constraint.QuadToSOCBridge docstring","category":"page"},{"location":"moi/changelog/#v1.4.0-(June-9,-2022)","page":"Release notes","title":"v1.4.0 (June 9, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Added-26","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added a number of sets for constraint programming:\nAllDifferent\nBinPacking\nCircuit\nCountAtLeast\nCountBelongs\nCountDistinct\nCountGreaterThan\nCumulative\nPath\nTable\nAdded support for user-defined hessians in Nonlinear\nAdded Bridges.runtests to simplify the testing of bridge implementations","category":"page"},{"location":"moi/changelog/#Fixed-41","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug in FileFormats.NL when writing univariate *","category":"page"},{"location":"moi/changelog/#Other-29","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Began a large refactoring of the Bridges submodule, with greatly improved documentation.","category":"page"},{"location":"moi/changelog/#v1.3.0-(May-27,-2022)","page":"Release notes","title":"v1.3.0 (May 27, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Added-27","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Add MOI.Nonlinear submodule. This is a large new submodule that has been refactored from code that was in JuMP. For now, it should be considered experimental.\nAdd FileFormats.NL.SolFileResults(::IO, ::Model)\nAdd FileFormats.NL.read!(::IO, ::Model)\nAdd MOI.modify that accepts a vector of modifications","category":"page"},{"location":"moi/changelog/#Fixed-42","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug in Test which attempted to include non-.jl files\nFixed a bug in FileFormats for models with open interval constraints","category":"page"},{"location":"moi/changelog/#Other-30","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a performance issue in Utilities.DoubleDict\nVarious minor improvements to the documentation","category":"page"},{"location":"moi/changelog/#v1.2.0-(April-25,-2022)","page":"Release notes","title":"v1.2.0 (April 25, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Added-28","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Add support for the FORMAT_REW/.rew file format in FileFormats.","category":"page"},{"location":"moi/changelog/#Fixed-43","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fix bug handling of default variable bounds in FileFormats.LP\nFix FileFormats.MPS to not write OBJSENSE by default since this is only supported by some readers.","category":"page"},{"location":"moi/changelog/#v1.1.2-(March-31,-2022)","page":"Release notes","title":"v1.1.2 (March 31, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-44","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fix a range of bugs in FileFormats.LP\nFix reading of problem dimensions in FileFormats.SDPA","category":"page"},{"location":"moi/changelog/#v1.1.1-(March-23,-2022)","page":"Release notes","title":"v1.1.1 (March 23, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-45","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fix bug in test_model_UpperBoundAlreadySet\nFix bug in test_infeasible_ tests\nFix bug in test_objective_ObjectiveFunction_blank\nRelax restriction of MOI.AbstractOptimizer to MOI.ModelLike in Utilities.CachingOptimizer and instantiate.","category":"page"},{"location":"moi/changelog/#New-tests","page":"Release notes","title":"New tests","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Add test_conic_empty_matrix that checks conic solvers support problems with no variables.","category":"page"},{"location":"moi/changelog/#v1.1.0-(March-2,-2022)","page":"Release notes","title":"v1.1.0 (March 2, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Added-29","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added MOI.Utilities.throw_unsupported(::UniversalFallback) for simplifying solver wrappers which copy from a UniversalFallback.","category":"page"},{"location":"moi/changelog/#v1.0.2-(March-1,-2022)","page":"Release notes","title":"v1.0.2 (March 1, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-46","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug in the test_model_ScalarFunctionConstantNotZero test\nFixed the error type when an AbstractFunctionConversionBridge cannot get or set an attribute\nIdentified a correctness bug in RSOCtoPSDBridge. We now thrown an error instead of returning an incorrect result.","category":"page"},{"location":"moi/changelog/#v1.0.1-(February-25,-2022)","page":"Release notes","title":"v1.0.1 (February 25, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-47","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug in which OptimizerAttributes were not copied in CachingOptimizer\nFixed a bug in which shift_constant did not promote mixed types of coefficients\nFixed a bug in which deleting a constraint of a bridged variable threw ErrorException instead of MOI.DeleteNotAllowed\nFixed a bug in which add_constraint in MatrixOfConstraints did not canonicalize the function\nFixed a bug when modifying scalar constants of a function containing a bridged variable\nFixed a bug in which final_touch was not always called with a CachingOptimizer","category":"page"},{"location":"moi/changelog/#v1.0.0-(February-17,-2022)","page":"Release notes","title":"v1.0.0 (February 17, 2022)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Although tagged as a breaking release, v1.0.0 is v0.10.9 with deprecations removed, similar to how Julia 1.0 was Julia 0.7 with deprecations removed.","category":"page"},{"location":"moi/changelog/#Breaking","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Julia 1.6 is now the minimum supported version\nAll deprecations have been removed","category":"page"},{"location":"moi/changelog/#Troubleshooting-problems-when-updating","page":"Release notes","title":"Troubleshooting problems when updating","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"If you experience problems when updating, you are likely using previously deprecated features. (By default, Julia does not warn when you use deprecated features.)","category":"page"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"To find the deprecated features you are using, start Julia with --depwarn=yes:","category":"page"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"$ julia --depwarn=yes","category":"page"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Then install MathOptInterface v0.10.9:","category":"page"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"julia> using Pkg\njulia> pkg\"add MathOptInterface@0.10\"","category":"page"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"And then run your code. Apply any suggestions, or search the release notes below for advice on updating a specific deprecated feature.","category":"page"},{"location":"moi/changelog/#v0.10.9-(February-16,-2022)","page":"Release notes","title":"v0.10.9 (February 16, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Added-30","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added MOI.Utilities.FreeVariables as a new VariablesConstrainer for conic solvers\nAdded MOI.default_cache for specifying the model used in CachingOptimizer","category":"page"},{"location":"moi/changelog/#Fixed-48","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed LaTeX printing of MOI.Interval sets","category":"page"},{"location":"moi/changelog/#Other-31","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added Aqua.jl as a CI check, and fixed suggested issues\nThe constructors of GeoMeanBridge, StructOfConstraints, and CachingOptimizer were changed from outer to inner constructors. This change is technically breaking, but does not impact users who followed the documented API.","category":"page"},{"location":"moi/changelog/#v0.10.8-(February-3,-2022)","page":"Release notes","title":"v0.10.8 (February 3, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Added-31","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added a Base.read! for FileFormats.LP.","category":"page"},{"location":"moi/changelog/#Fixed-49","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a bug in MutableSparseMatrix\nFixed a bug when calling operate!(vcat, ...) with Number arguments\nRemoved unintended export of deprecated symbols\nFixed a bug with PowerCone and DualPowerCone in MatrixOfConstraints.","category":"page"},{"location":"moi/changelog/#v0.10.7-(January-5,-2022)","page":"Release notes","title":"v0.10.7 (January 5, 2022)","text":"","category":"section"},{"location":"moi/changelog/#Added-32","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added test for modifying the constant vector in a VectorAffineFunction-in-Zeros constraint.","category":"page"},{"location":"moi/changelog/#Fixed-50","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed the order in which sets are added to a LazyBridgeOptimizer. Compared to v0.10.6, this may result in bridged models being created with a different number (and order) of variables and constraints. However, it was necessary to fix cases which were previously rejected as unsupported, even though there was a valid bridge transformation.\nFixed an error message in FileFormats.CBF\nFixed comparison in test_linear_integration_Interval\nFixed errors for ConstraintPrimal in a CachingOptimizer\nFixed printing of models with non-Float64 coefficients.","category":"page"},{"location":"moi/changelog/#Other-32","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Various improvements to reduce time-to-first-solve latency\nImproved error message when an optimizer does not support compute_conflict!","category":"page"},{"location":"moi/changelog/#v0.10.6-(November-30,-2021)","page":"Release notes","title":"v0.10.6 (November 30, 2021)","text":"","category":"section"},{"location":"moi/changelog/#Added-33","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added new documentation and tests for infeasibility certificates\nAdded a version control system for the tests in MOI.Test.runtests. Pass exclude_tests_after = v\"0.10.5\" to run tests added in v0.10.5 and earlier.\nMOI.Test.runtests now supports generic number types. To specify the number type T, pass MOI.Test.Config(T).\nAdded infeasible_status to MOI.Test.Config for solvers which return LOCALLY_INFEASIBLE\nCachingOptimizers now use a fallback for ConstraintPrimal. This should enable solvers using a CachingOptimizer to pass tests requiring ConstraintPrimal.","category":"page"},{"location":"moi/changelog/#Fixed-51","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed a StackOverflow bug in copy_to\nFixed error thrown when nonconvex quadratic constraints cannot be bridged\nFixed a bug in copy_to for FileFormats.NL.Model\nFixed a bug in FileFormats.NL when printing large integers\nRemove a common test failure for LowerBoundAlreadySet tests\nUtilities.num_rows is now exported\nRemove parts of failing test_model_copy_to_xxx tests due to bridges","category":"page"},{"location":"moi/changelog/#v0.10.5-(November-7,-2021)","page":"Release notes","title":"v0.10.5 (November 7, 2021)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-52","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed getter in UniversalFallback\nFixed test_solve_conflict_zeroone_ii","category":"page"},{"location":"moi/changelog/#Other-33","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Make normalize_and_add_constraint more flexible\nUpdate paper BibTeX","category":"page"},{"location":"moi/changelog/#v0.10.4-(October-26,-2021)","page":"Release notes","title":"v0.10.4 (October 26, 2021)","text":"","category":"section"},{"location":"moi/changelog/#Added-34","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Add SolverVersion attribute\nAdd new tests:\ntest_solve_conflict_zeroone_ii\ntest_nonlinear_objective\nUtilities.VariablesContainer now supports ConstraintFunction and ConstraintSet\nThe documentation is now available as a PDF","category":"page"},{"location":"moi/changelog/#Other-34","page":"Release notes","title":"Other","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Update to MutableArithmetics 0.3\nVarious improvements to the documentation","category":"page"},{"location":"moi/changelog/#v0.10.3-(September-18,-2021)","page":"Release notes","title":"v0.10.3 (September 18, 2021)","text":"","category":"section"},{"location":"moi/changelog/#Fixed-53","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed bug which prevented callbacks from working through a CachingOptimizer\nFixed bug in Test submodule","category":"page"},{"location":"moi/changelog/#v0.10.2-(September-16,-2021)","page":"Release notes","title":"v0.10.2 (September 16, 2021)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Updated MathOptFormat to v1.0\nUpdated JSONSchema to v1.0\nAdded Utilities.set_with_dimension\nAdded two-argument optimize!(::AbstractOptimizer, ::ModelLike)\nThe experimental feature copy_to_and_optimize! has been removed\nDet bridges now support getting ConstraintFunction and ConstraintSet\nVarious minor bug fixes identified by improved testing","category":"page"},{"location":"moi/changelog/#v0.10.1-(September-8,-2021)","page":"Release notes","title":"v0.10.1 (September 8, 2021)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Various fixes to MOI.Test","category":"page"},{"location":"moi/changelog/#v0.10.0-(September-6,-2021)","page":"Release notes","title":"v0.10.0 (September 6, 2021)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"MOI v0.10 is a significant breaking release. There are a large number of user-visible breaking changes and code refactors, as well as a substantial number of new features.","category":"page"},{"location":"moi/changelog/#Breaking-in-MOI","page":"Release notes","title":"Breaking in MOI","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"SingleVariable has been removed; use VariableIndex instead\nSingleVariableConstraintNameError has been renamed to VariableIndexConstraintNameError\nSettingSingleVariableFunctionNotAllowed has been renamed to SettingVariableIndexFunctionNotAllowed\nVariableIndex constraints should not support ConstraintName\nVariableIndex constraints should not support ConstraintBasisStatus; implement VariableBasisStatus instead\nListOfConstraints has been renamed to ListOfConstraintTypesPresent\nListOfConstraintTypesPresent should now return Tuple{Type,Type} instead of Tuple{DataType,DataType}\nSolveTime has been renamed to SolveTimeSec\nIndicatorSet has been renamed to Indicator\nRawParameter has been renamed to RawOptimizerAttribute and now takes String instead of Any as the only argument\nThe .N field in result attributes has been renamed to .result_index\nThe .variable_index field in ScalarAffineTerm has been renamed to .variable\nThe .variable_index_1 field in ScalarQuadraticTerm has been renamed to .variable_1\nThe .variable_index_2 field in ScalarQuadraticTerm has been renamed to .variable_2\nThe order of affine_terms and quadratic_terms in ScalarQuadraticFunction and VectorQuadraticFunction have been reversed. Both functions now accept quadratic, affine, and constant terms in that order.\nThe index_value function has been removed. Use .value instead.\nisapprox has been removed for SOS1 and SOS2.\nThe dimension argument to Complements(dimension::Int) should now be the length of the corresponding function, instead of half the length. An ArgumentError is thrown if dimension is not even.\ncopy_to no longer takes keyword arguments:\ncopy_names: now copy names if they are supported by the destination solver\nfilter_constraints: use Utilities.ModelFilter instead\nwarn_attributes: never warn about optimizer attributes","category":"page"},{"location":"moi/changelog/#Breaking-in-Bridges","page":"Release notes","title":"Breaking in Bridges","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Constraint.RSOCBridge has been renamed to Constraint.RSOCtoSOCBridge\nConstraint.SOCRBridge has been renamed to Constraint.SOCtoRSOCBridge\nBridges now return vectors that can be modified by the user. Previously, some bridges returned views instead of copies.\nBridges.IndexInVector has been unified into a single type. Previously, there was a different type for each submodule within Bridges\nThe signature of indicator bridges has been fixed. Use MOI.Bridges.Constraint.IndicatortoSOS1{Float64}(model).","category":"page"},{"location":"moi/changelog/#Breaking-in-FileFormats","page":"Release notes","title":"Breaking in FileFormats","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"FileFormats.MOF.Model no longer accepts validate argument. Use the JSONSchema package to validate the MOF file. See the documentation for more information.","category":"page"},{"location":"moi/changelog/#Breaking-in-Utilities","page":"Release notes","title":"Breaking in Utilities","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"The datastructure of Utilities.Model (and models created with Utilities.@model) has been significantly refactored in a breaking way. This includes the way that objective functions and variable-related information is stored.\nUtilities.supports_default_copy has been renamed to supports_incremental_interface\nUtilities.automatic_copy_to has been renamed to Utilities.default_copy_to\nThe allocate-load API has been removed\nCachingOptimizers are now initialized as EMPTY_OPTIMIZER instead of ATTACHED_OPTIMIZER. If your code relies on the optimizer being attached, call MOIU.attach_optimizer(model) after creation.\nThe field names of Utilities.IndexMap have been renamed to var_map and con_map. Accessing these fields directly is considered a private detail that may change. Use the public getindex and setindex! API instead.\nThe size argument to Utilities.CleverDicts.CleverDict(::Integer) has been removed.\nThe size argument to Utilities.IndexMap(::Integer) has been removed.\nUtilities.DoubleDicts have been significantly refactored. Consult the source code for details.\nUtilities.test_models_equal has been moved to MOI.Test","category":"page"},{"location":"moi/changelog/#Breaking-in-Test","page":"Release notes","title":"Breaking in Test","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"MOI.Test has been renamed to MOI.DeprecatedTest\nAn entirely new MOI.Test submodule has been written. See the documentation for details. The new MOI.Test submodule may find many bugs in the implementations of existing solvers that were previously untested.","category":"page"},{"location":"moi/changelog/#Other-changes:","page":"Release notes","title":"Other changes:","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"attribute_value_type has been added\ncopy_to_and_optimize! has been added\nVariableBasisStatus has been added\nprint(model) now prints a human-readable description of the model\nVarious improvements to the FileFormats submodule\nFileFormats.CBF was refactored and received bugfixes\nSupport for MathOptFormat v0.6 was added in FileFormats.MOF\nFileFormats.MPS has had bugfixes and support for more features such as OBJSENSE and objective constants.\nFileFormats.NL has been added to support nonlinear files\nImproved type inference throughout to reduce latency","category":"page"},{"location":"moi/changelog/#Updating","page":"Release notes","title":"Updating","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"A helpful script when updating is:","category":"page"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"for (root, dirs, files) in walkdir(\".\")\n    for file in files\n        if !endswith(file, \".jl\")\n            continue\n        end\n        path = joinpath(root, file)\n        s = read(path, String)\n        for pair in [\n            \".variable_index\" => \".variable\",\n            \"RawParameter\" => \"RawOptimizerAttribute\",\n            \"ListOfConstraints\" => \"ListOfConstraintTypesPresent\",\n            \"TestConfig\" => \"Config\",\n            \"attr.N\" => \"attr.result_index\",\n            \"SolveTime\" => \"SolveTimeSec\",\n            \"DataType\" => \"Type\",\n            \"Utilities.supports_default_copy_to\" =>\n                \"supports_incremental_interface\",\n            \"SingleVariableConstraintNameError\" =>\n                \"VariableIndexConstraintNameError\",\n            \"SettingSingleVariableFunctionNotAllowed\" =>\n                \"SettingVariableIndexFunctionNotAllowed\",\n            \"automatic_copy_to\" => \"default_copy_to\",\n        ]\n            s = replace(s, pair)\n        end\n        write(path, s)\n    end\nend","category":"page"},{"location":"moi/changelog/#v0.9.22-(May-22,-2021)","page":"Release notes","title":"v0.9.22 (May 22, 2021)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"This release contains backports from the ongoing development of the v0.10 release.","category":"page"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Improved type inference in Utilities, Bridges and FileFormats submodules to reduce latency.\nImproved performance of Utilities.is_canonical.\nFixed Utilities.pass_nonvariable_constraints with bridged variables.\nFixed performance regression of Utilities.Model.\nFixed ordering of objective setting in parser.","category":"page"},{"location":"moi/changelog/#v0.9.21-(April-23,-2021)","page":"Release notes","title":"v0.9.21 (April 23, 2021)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added supports_shift_constant.\nImprove performance of bridging quadratic constraints.\nAdd precompilation statements.\nLarge improvements to the documentation.\nFix a variety of inference issues, benefiting precompilation and reducing initial latency.\nRawParameters are now ignored when resetting a CachingOptimizer. Previously, changing the underlying optimizer after RawParameters were set would throw an error.\nUtilities.AbstractModel is being refactored. This may break users interacting with private fields of a model generated using @model.","category":"page"},{"location":"moi/changelog/#v0.9.20-(February-20,-2021)","page":"Release notes","title":"v0.9.20 (February 20, 2021)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Improved performance of Utilities.ScalarFunctionIterator\nAdded support for compute_conflict to MOI layers\nAdded test with zero off-diagonal quadratic term in objective\nFixed double deletion of nested bridged SingleVariable/VectorOfVariables constraints\nFixed modification of un-set objective\nFixed function modification with duplicate terms\nMade unit tests abort without failing if the problem class is not supported\nFormatted code with JuliaFormatter\nClarified BasisStatusCode's docstring","category":"page"},{"location":"moi/changelog/#v0.9.19-(December-1,-2020)","page":"Release notes","title":"v0.9.19 (December 1, 2020)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added CallbackNodeStatus attribute\nAdded bridge from GreaterThan or LessThan to Interval\nAdded tests for infeasibility certificates and double optimize\nFixed support for Julia v1.6\nRe-organized MOI docs and added documentation for adding a test","category":"page"},{"location":"moi/changelog/#v0.9.18-(November-3,-2020)","page":"Release notes","title":"v0.9.18 (November 3, 2020)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Various improvements for working with complex numbers\nAdded GeoMeantoRelEntrBridge to bridge a GeometricMeanCone constraint to a relative entropy constraint","category":"page"},{"location":"moi/changelog/#v0.9.17-(September-21,-2020)","page":"Release notes","title":"v0.9.17 (September 21, 2020)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed CleverDict with variable of negative index value\nImplement supports_add_constrained_variable for MockOptimizer","category":"page"},{"location":"moi/changelog/#v0.9.16-(September-17,-2020)","page":"Release notes","title":"v0.9.16 (September 17, 2020)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Various fixes:\n32-bit support\nCleverDict with abstract value type\nChecks in test suite","category":"page"},{"location":"moi/changelog/#v0.9.15-(September-14,-2020)","page":"Release notes","title":"v0.9.15 (September 14, 2020)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Bridges improvements:\n(R)SOCtoNonConvexQuad bridge\nZeroOne bridge\nUse supports_add_constrained_variable in LazyBridgeOptimizer\nExposed VariableBridgeCost and ConstraintBridgeCost attributes\nPrioritize constraining variables on creation according to these costs\nRefactor bridge debugging\nLarge performance improvements across all submodules\nLots of documentation improvements\nFileFormats improvements:\nUpdate MathOptFormat to v0.5\nFix supported objectives in FileFormats\nTesting improvements:\nAdd name option for basic_constraint_test\nBug fixes and missing methods\nAdd length for iterators\nFix bug with duplicate terms\nFix order of LinearOfConstraintIndices","category":"page"},{"location":"moi/changelog/#v0.9.14-(May-30,-2020)","page":"Release notes","title":"v0.9.14 (May 30, 2020)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Add a solver-independent interface for accessing the set of conflicting constraints an Irreducible Inconsistent Subsystem (#1056).\nBump JSONSchema dependency from v0.2 to v0.3 (#1090).\nDocumentation improvements:\nFix typos (#1054, #1060, #1061, #1064, #1069, #1070).\nRemove the outdated recommendation for a package implementing MOI for a solver XXX to be called MathOptInterfaceXXX (#1087).\nUtilities improvements:\nFix is_canonical for quadratic functions (#1081, #1089).\nImplement add_constrained_variable[s] for CachingOptimizer so that it is added as constrained variables to the underlying optimizer (#1084).\nAdd support for custom objective functions for UniversalFallback (#1086).\nDeterministic ordering of constraints in UniversalFallback (#1088).\nTesting improvements:\nAdd NormOneCone/NormInfinityCone tests (#1045).\nBridges improvements:\nAdd bridges from Semiinteger and Semicontinuous (#1059).\nImplement getting ConstraintSet for Variable.FlipSignBridge (#1066).\nFix setting ConstraintFunction for Constraint.ScalarizeBridge (#1093).\nFix NormOne/NormInf bridges with nonzero constants (#1045).\nFix StackOverflow in debug (#1063).\nFileFormats improvements:\n[SDPA] Implement the extension for integer variables (#1079).\n[SDPA] Ignore comments after m and nblocks and detect dat-s extension (#1077).\n[SDPA] No scaling of off-diagonal coefficient (#1076).\n[SDPA] Add missing negation of constant (#1075).","category":"page"},{"location":"moi/changelog/#v0.9.13-(March-24,-2020)","page":"Release notes","title":"v0.9.13 (March 24, 2020)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added tests for Semicontinuous and Semiinteger variables (#1033).\nAdded tests for using ExprGraphs from NLP evaluators (#1043).\nUpdate version compatibilities of dependencies (#1034, #1051, #1052).\nFixed typos in documentation (#1044).","category":"page"},{"location":"moi/changelog/#v0.9.12-(February-28,-2020)","page":"Release notes","title":"v0.9.12 (February 28, 2020)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed writing NLPBlock in MathOptFormat (#1037).\nFixed MockOptimizer for result attributes with non-one result index (#1039).\nUpdated test template with instantiate (#1032).","category":"page"},{"location":"moi/changelog/#v0.9.11-(February-21,-2020)","page":"Release notes","title":"v0.9.11 (February 21, 2020)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Add an option for the model created by Utilities.@model to be a subtype of AbstractOptimizer (#1031).\nDescribed dual cone in docstrings of GeoMeanCone and RelativeEntropyCone (#1018, #1028).\nFixed typos in documentation (#1022, #1024).\nFixed warning of unsupported attribute (#1027).\nAdded more rootdet/logdet conic tests (#1026).\nImplemented ConstraintDual for Constraint.GeoMeanBridge, Constraint.RootDetBridge and Constraint.LogDetBridge and test duals in tests with GeoMeanCone and RootDetConeTriangle and LogDetConeTriangle cones (#1025, #1026).","category":"page"},{"location":"moi/changelog/#v0.9.10-(January-31,-2020)","page":"Release notes","title":"v0.9.10 (January 31, 2020)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added OptimizerWithAttributes grouping an optimizer constructor and a list of optimizer attributes (#1008).\nAdded RelativeEntropyCone with corresponding bridge into exponential cone constraints (#993).\nAdded NormSpectralCone and NormNuclearCone with corresponding bridges into positive semidefinite constraints (#976).\nAdded supports_constrained_variable(s) (#1004).\nAdded dual_set_type (#1002).\nAdded tests for vector specialized version of delete (#989, #1011).\nAdded PSD3 test (#1007).\nClarified dual solution of Tests.pow1v and Tests.pow1f (#1013).\nAdded support for EqualTo and Zero in Bridges.Constraint.SplitIntervalBridge (#1005).\nFixed Utilities.vectorize for empty vector (#1003).\nFixed free variables in LP writer (#1006).","category":"page"},{"location":"moi/changelog/#v0.9.9-(December-29,-2019)","page":"Release notes","title":"v0.9.9 (December 29, 2019)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Incorporated MathOptFormat.jl as the FileFormats submodule. FileFormats provides readers and writers for a number of standard file formats and MOF, a file format specialized for MOI (#969).\nImproved performance of deletion of vector of variables in MOI.Utilities.Model (#983).\nUpdated to MutableArithmetics v0.2 (#981).\nAdded MutableArithmetics.promote_operation allocation tests (#975).\nFixed inference issue on Julia v1.1 (#982).","category":"page"},{"location":"moi/changelog/#v0.9.8-(December-19,-2019)","page":"Release notes","title":"v0.9.8 (December 19, 2019)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Implemented MutableArithmetics API (#924).\nFixed callbacks with CachingOptimizer (#959).\nFixed MOI.dimension for MOI.Complements (#948).\nAdded fallback for add_variables (#972).\nAdded is_diagonal_vectorized_index utility (#965).\nImproved linear constraints display in manual (#963, #964).\nBridges improvements:\nAdded IndicatorSet to SOS1 bridge (#877).\nAdded support for starting values for Variable.VectorizeBridge (#944).\nFixed MOI.add_constraints with non-bridged variable constraint on bridged variable (#951).\nFixed corner cases and docstring of GeoMeanBridge (#961, #962, #966).\nFixed choice between variable or constraint bridges for constrained variables (#973).\nImprove performance of bridge shortest path (#945, #946, #956).\nAdded docstring for test_delete_bridge (#954).\nAdded Variable bridge tests (#952).","category":"page"},{"location":"moi/changelog/#v0.9.7-(October-30,-2019)","page":"Release notes","title":"v0.9.7 (October 30, 2019)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Implemented _result_index_field for NLPBlockDual (#934).\nFixed copy of model with starting values for vector constraints (#941).\nBridges improvements:\nImproved performance of add_bridge and added has_bridge (#935).\nAdded AbstractSetMapBridge for bridges between sets S1, S2 such that there is a linear map A such that A*S1 = S2 (#933).\nAdded support for starting values for FlipSignBridge, VectorizeBridge, ScalarizeBridge, SlackBridge, SplitIntervalBridge, RSOCBridge, SOCRBridge NormInfinityBridge, SOCtoPSDBridge and RSOCtoPSDBridge (#933, #936, #937, #938, #939).","category":"page"},{"location":"moi/changelog/#v0.9.6-(October-25,-2019)","page":"Release notes","title":"v0.9.6 (October 25, 2019)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added complementarity constraints (#913).\nAllowed ModelLike objects as value of attributes (#928).\nTesting improvements:\nAdded dual_objective_value option to MOI.Test.TestConfig (#922).\nAdded InvalidIndex tests in basic_constraint_tests (#921).\nAdded tests for the constant term in indicator constraint (#929).\nBridges improvements:\nAdded support for starting values for Functionize bridges (#923).\nAdded variable indices context to variable bridges (#920).\nFixed a typo in printing o debug_supports (#927).","category":"page"},{"location":"moi/changelog/#v0.9.5-(October-9,-2019)","page":"Release notes","title":"v0.9.5 (October 9, 2019)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Clarified PrimalStatus/DualStatus to be NO_SOLUTION if result_index is out of bounds (#912).\nAdded tolerance for checks  and use ResultCount + 1 for the result_index in MOI.Test.solve_result_status (#910, #917).\nUse 0.5 instead of 2.0 for power in PowerCone in basic_constraint_test (#916).\nBridges improvements:\nAdded debug utilities for unsupported variable/constraint/objective (#861).\nFixed deletion of variables in bridged VectorOfVariables constraints (#909).\nFixed result_index with objective bridges (#911).","category":"page"},{"location":"moi/changelog/#v0.9.4-(October-2,-2019)","page":"Release notes","title":"v0.9.4 (October 2, 2019)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Added solver-independent MIP callbacks (#782).\nImplements submit for Utilities.CachingOptimizer and Bridges.AbstractBridgeOptimizer (#906).\nAdded tests for result count of solution attributes (#901, #904).\nAdded NumberOfThreads attribute (#892).\nAdded Utilities.get_bounds to get the bounds on a variable (#890).\nAdded a note on duplicate coefficients in documentation (#581).\nAdded result index in ConstraintBasisStatus (#898).\nAdded extension dictionary to Utilities.Model (#884, #895).\nFixed deletion of constrained variables for CachingOptimizer (#905).\nImplemented Utilities.shift_constraint for Test.UnknownScalarSet (#896).\nBridges improvements:\nAdded Variable.RSOCtoSOCBridge (#907).\nImplemented MOI.get for ConstraintFunction/ConstraintSet for Bridges.Constraint.SquareBridge (#899).","category":"page"},{"location":"moi/changelog/#v0.9.3-(September-20,-2019)","page":"Release notes","title":"v0.9.3 (September 20, 2019)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixed ambiguity detected in Julia v1.3 (#891, #893).\nFixed missing sets from ListOfSupportedConstraints (#880).\nFixed copy of VectorOfVariables constraints with duplicate indices (#886).\nAdded extension dictionary to MOIU.Model (#884).\nImplemented MOI.get for function and set for GeoMeanBridge (#888).\nUpdated documentation for SingleVariable indices and bridges (#885).\nTesting improvements:\nAdded more comprehensive tests for names (#882).\nAdded tests for SingleVariable duals (#883).\nAdded tests for DualExponentialCone and DualPowerCone (#873).\nImprovements for arbitrary coefficient type:\nFixed == for sets with mutable fields (#887).\nRemoved some Float64 assumptions in bridges (#878).\nAutomatic selection of Constraint.[Scalar|Vector]FunctionizeBridge (#889).","category":"page"},{"location":"moi/changelog/#v0.9.2-(September-5,-2019)","page":"Release notes","title":"v0.9.2 (September 5, 2019)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Implemented model printing for MOI.ModelLike and specialized it for models defined in MOI (864).\nGeneralized contlinear tests for arbitrary coefficient type (#855).\nFixed supports_constraint for Semiinteger and Semicontinuous and supports for ObjectiveFunction (#859).\nFixed Allocate-Load copy for single variable constraints (#856).\nBridges improvements:\nAdd objective bridges (#789).\nFixed Variable.RSOCtoPSDBridge for dimension 2 (#869).\nAdded Variable.SOCtoRSOCBridge (#865).\nAdded Constraint.SOCRBridge and disable MOI.Bridges.Constraint.SOCtoPSDBridge (#751).\nFixed added_constraint_types for Contraint.LogDetBridge and Constraint.RootDetBridge (#870).","category":"page"},{"location":"moi/changelog/#v0.9.1-(August-22,-2019)","page":"Release notes","title":"v0.9.1 (August 22, 2019)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fix support for Julia v1.2 (#834).\nL1 and L∞ norm epigraph cones and corresponding bridges to LP were added (#818).\nAdded tests to MOI.Test.nametest (#833).\nFix MOI.Test.soc3test for solvers not supporting infeasibility certificates (#839).\nImplements operate for operators * and / between vector function and constant (#837).\nImplements show for MOI.Utilities.IndexMap (#847).\nFix corner cases for mapping of variables in MOI.Utilities.CachingOptimizer and substitution of variables in MOI.Bridges.AbstractBridgeOptimizer (#848).\nFix transformation of constant terms for MOI.Bridges.Constraint.SOCtoPSDBridge and MOI.Bridges.Constraint.RSOCtoPSDBridge (#840).","category":"page"},{"location":"moi/changelog/#v0.9.0-(August-13,-2019)","page":"Release notes","title":"v0.9.0 (August 13, 2019)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Support for Julia v0.6 and v0.7 was dropped (#714, #717).\nA MOI.Utilities.Model implementation of ModelLike, this should replace most use cases of MOI.Utilities.@model (#781).\nadd_constrained_variable and add_constrained_variables were added (#759).\nSupport for indicator constraints was added (#709, #712).\nDualObjectiveValue attribute was added (#473).\nRawParameter attribute was added (#733).\nA dual_set function was added (#804).\nA Benchmarks submodule was added to facilitate solver benchmarking (#769).\nA submit function was added, this may for instance allow the user to submit solutions or cuts to the solver from a callback (#775).\nThe field of ObjectiveValue was renamed to result_index (#729).\nThe _constant and Utilities.getconstant function were renamed to constant\nREDUCTION_CERTIFICATE result status was added (#734).\nAbstract matrix sets were added (#731).\nTesting improvements:\nThe testing guideline was updated (#728).\nQuadratic tests were added (#697).\nUnit tests for RawStatusString, SolveTime, Silent and SolverName were added (#726, #741).\nA rotated second-order cone test was added (#759).\nA power cone test was added (#768).\nTests for ZeroOne variables with variable bounds were added (#772).\nAn unbounded test was added (#773).\nExisting tests had a few updates (#702, #703, #763).\nDocumentation improvements:\nAdded a section on CachingOptimizer (#777).\nAdded a section on UniversalFallback, Model and @model (#762).\nTransition the knapsack example to a doctest with MockOptimizer (#786).\nUtilities improvements:\nA CleverDict utility was added for a vector that automatically transform into a dictionary once a first index is removed (#767).\nThe Utilities.constant function was renamed to Utilities.constant_vector (#740).\nImplement optimizer attributes for CachingOptimizer (#745).\nRename Utilities.add_scalar_constraint to Utilities.normalize_and_add_constraint (#801).\noperate with vcat, SingleVariable and VectorOfVariables now returns a VectorOfVariables (#616).\nFix a type piracy of operate (#784).\nThe load_constraint fallback signature was fixed (#760).\nThe set_dot function was extended to work with sparse arrays (#805).\nBridges improvements:\nThe bridges no longer store the constraint function and set before it is bridged, the bridges now have to implement ConstraintFunction and ConstraintSet if the user wants to recover them. As a consequence, the @bridge macro was removed (#722).\nBridge are now instantiated with a bridge_constraint function instead of using a constructor (#730).\nFix constraint attributes for bridges (#699).\nConstraint bridges were moved to the Bridges/Constraint submodule so they should now inherit from MOI.Bridges.Constraint.Abstract and should implement MOI.Bridges.Constraint.concrete_bridge_type instead of MOI.Bridges.concrete_bridge_type (#756).\nVariable bridges were added in (#759).\nVarious improvements (#746, #747).","category":"page"},{"location":"moi/changelog/#v0.8.4-(March-13,-2019)","page":"Release notes","title":"v0.8.4 (March 13, 2019)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Performance improvement in default_copy_to and bridge optimizer (#696).\nAdd Silent and implement setting optimizer attributes in caching and mock optimizers (#695).\nAdd Functionize bridges (SingleVariable and VectorOfVariables) (#659).\nMinor typo fixes (#694).","category":"page"},{"location":"moi/changelog/#v0.8.3-(March-6,-2019)","page":"Release notes","title":"v0.8.3 (March 6, 2019)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Use zero constant in scalar constraint function of MOI.Test.copytest (#691).\nFix variable deletion with SingleVariable objective function (#690).\nFix LazyBridgeOptimizer with bridges that add no constraints (#689).\nError message improvements (#673, #685, #686, #688).\nDocumentation improvements (#682, #683, #687).\nBasis status:\nRemove VariableBasisStatus (#679).\nTest ConstraintBasisStatus and implement it in bridges (#678).\nFix inference of NumberOfVariables and NumberOfConstraints (#677).\nImplement division between a quadratic function and a number (#675).","category":"page"},{"location":"moi/changelog/#v0.8.2-(February-7,-2019)","page":"Release notes","title":"v0.8.2 (February 7, 2019)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Add RawStatusString attribute (#629).\nDo not set names to the optimizer but only to the cache in CachingOptimizer (#638).\nMake scalar MOI functions act as scalars in broadcast (#646).\nAdd function utilities:\nImplement Base.zero (#634), Base.iszero (#643), add missing arithmetic operations (#644, #645) and fix division (#648).\nAdd a vectorize function that turns a vector of ScalarAffineFunction into a VectorAffineFunction (#642).\nImprove support for starting values:\nShow a warning in copy when starting values are not supported instead of throwing an error (#630).\nFix UniversalFallback for getting an variable or constraint attribute set to no indices (#623).\nAdd a test in contlineartest with partially set VariablePrimalStart.\nBridges improvements:\nFix StackOverFlow in LazyBridgeOptimizer when there is a cycle in the graph of bridges.\nAdd Slack bridges (#610, #650).\nAdd FlipSign bridges (#658).\nAdd tests with duplicate coefficients in ScalarAffineFunction and VectorAffineFunction (#639).\nUse tolerance to compare VariablePrimal in rotatedsoc1 test (#632).\nUse a zero constant in ScalarAffineFunction of constraints in psdt2 (#622).","category":"page"},{"location":"moi/changelog/#v0.8.1-(January-7,-2019)","page":"Release notes","title":"v0.8.1 (January 7, 2019)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Adding an NLP objective now overrides any objective set using the ObjectiveFunction attribute (#619).\nRename fullbridgeoptimizer into full_bridge_optimizer (#621).\nAllow custom constraint types with full_bridge_optimizer (#617).\nAdd Vectorize bridge which transforms scalar linear constraints into vector linear constraints (#615).","category":"page"},{"location":"moi/changelog/#v0.8.0-(December-18,-2018)","page":"Release notes","title":"v0.8.0 (December 18, 2018)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Rename all enum values to follow the JuMP naming guidelines for constants, for example, Optimal becomes OPTIMAL, and DualInfeasible becomes DUAL_INFEASIBLE.\nRename CachingOptimizer methods for style compliance.\nAdd an MOI.TerminationStatusCode called ALMOST_DUAL_INFEASIBLE.","category":"page"},{"location":"moi/changelog/#v0.7.0-(December-13,-2018)","page":"Release notes","title":"v0.7.0 (December 13, 2018)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Test that MOI.TerminationStatus is MOI.OptimizeNotCalled before MOI.optimize! is called.\nCheck supports_default_copy_to in tests (#594).\nKey pieces of information like optimality, infeasibility, etc., are now reported through TerminationStatusCode. It is typically no longer necessary to check the result statuses in addition to the termination status.\nAdd perspective dimension to log-det cone (#593).","category":"page"},{"location":"moi/changelog/#v0.6.4-(November-27,-2018)","page":"Release notes","title":"v0.6.4 (November 27, 2018)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Add OptimizeNotCalled termination status (#577) and improve documentation of other statuses (#575).\nAdd a solver naming guideline (#578).\nMake FeasibilitySense the default ObjectiveSense (#579).\nFix Utilities.@model and Bridges.@bridge macros for functions and sets defined outside MOI (#582).\nDocument solver-specific attributes (#580) and implement them in Utilities.CachingOptimizer (#565).","category":"page"},{"location":"moi/changelog/#v0.6.3-(November-16,-2018)","page":"Release notes","title":"v0.6.3 (November 16, 2018)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Variables and constraints are now allowed to have duplicate names. An error is thrown only on lookup. This change breaks some existing tests. (#549)\nAttributes may now be partially set (some values could be nothing). (#563)\nPerformance improvements in Utilities.Model (#549, #567, #568)\nFix bug in QuadtoSOC (#558).\nNew supports_default_copy_to method that optimizers should implement to control caching behavior.\nDocumentation improvements.","category":"page"},{"location":"moi/changelog/#v0.6.2-(October-26,-2018)","page":"Release notes","title":"v0.6.2 (October 26, 2018)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Improve hygiene of @model macro (#544).\nFix bug in copy tests (#543).\nFix bug in UniversalFallback attribute getter (#540).\nAllow all correct solutions for solve_blank_obj unit test (#537).\nAdd errors for Allocate-Load and bad constraints (#534).\n[performance] Add specialized implementation of hash for VariableIndex (#533).\n[performance] Construct the name to object dictionaries lazily in model (#535).\nAdd the QuadtoSOC bridge which transforms ScalarQuadraticFunction constraints into RotatedSecondOrderCone (#483).","category":"page"},{"location":"moi/changelog/#v0.6.1-(September-22,-2018)","page":"Release notes","title":"v0.6.1 (September 22, 2018)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Enable PositiveSemidefiniteConeSquare set and quadratic functions in MOIB.fullbridgeoptimizer (#524).\nAdd warning in the bridge between PositiveSemidefiniteConeSquare and PositiveSemidefiniteConeTriangle when the matrix is almost symmetric (#522).\nModify MOIT.copytest to not add multiples constraints on the same variable (#521).\nAdd missing keyword argument in one of MOIU.add_scalar_constraint methods (#520).","category":"page"},{"location":"moi/changelog/#v0.6.0-(August-30,-2018)","page":"Release notes","title":"v0.6.0 (August 30, 2018)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"The MOIU.@model and MOIB.@bridge macros now support functions and sets defined in external modules. As a consequence, function and set names in the macro arguments need to be prefixed by module name.\nRename functions according to the JuMP style guide:\ncopy! with keyword arguments copynames and warnattributes -> copy_to with keyword arguments copy_names and warn_attributes;\nset! -> set;\naddvariable[s]! -> add_variable[s];\nsupportsconstraint -> supports_constraint;\naddconstraint[s]! -> add_constraint[s];\nisvalid -> is_valid;\nisempty -> is_empty;\nBase.delete! -> delete;\nmodify! -> modify;\ntransform! -> transform;\ninitialize! -> initialize;\nwrite -> write_to_file; and\nread! -> read_from_file.\nRemove free! (use Base.finalize instead).\nAdd the SquarePSD bridge which transforms PositiveSemidefiniteConeTriangle constraints into PositiveSemidefiniteConeTriangle.\nAdd result fallback for ConstraintDual of variable-wise constraint, ConstraintPrimal and ObjectiveValue.\nAdd tests for ObjectiveBound.\nAdd test for empty rows in vector linear constraint.\nRework errors: CannotError has been renamed NotAllowedError and the distinction between UnsupportedError and NotAllowedError is now about whether the element is not supported (for example, it cannot be copied a model containing this element) or the operation is not allowed (either because it is not implemented, because it cannot be performed in the current state of the model, or because it cannot be performed for a specific index)\ncanget is removed. NoSolution is added as a result status to indicate that the solver does not have either a primal or dual solution available (See #479).","category":"page"},{"location":"moi/changelog/#v0.5.0-(August-5,-2018)","page":"Release notes","title":"v0.5.0 (August 5, 2018)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fix names with CachingOptimizer.\nCleanup thanks to @mohamed82008.\nAdded a universal fallback for constraints.\nFast utilities for function canonicalization thanks to @rdeits.\nRenamed dimension field to side_dimension in the context of matrix-like sets.\nNew and improved tests for cases like duplicate terms and ObjectiveBound.\nRemoved cantransform, canaddconstraint, canaddvariable, canset, canmodify, and candelete functions from the API. They are replaced by a new set of errors that are thrown: Subtypes of UnsupportedError indicate unsupported operations, while subtypes of CannotError indicate operations that cannot be performed in the current state.\nThe API for copy! is updated to remove the CopyResult type.\nUpdates for the new JuMP style guide.","category":"page"},{"location":"moi/changelog/#v0.4.1-(June-28,-2018)","page":"Release notes","title":"v0.4.1 (June 28, 2018)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Fixes vector function modification on 32 bits.\nFixes Bellman-Ford algorithm for bridges.\nAdded an NLP test with FeasibilitySense.\nUpdate modification documentation.","category":"page"},{"location":"moi/changelog/#v0.4.0-(June-23,-2018)","page":"Release notes","title":"v0.4.0 (June 23, 2018)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Helper constructors for VectorAffineTerm and VectorQuadraticTerm.\nAdded modify_lhs to TestConfig.\nAdditional unit tests for optimizers.\nAdded a type parameter to CachingOptimizer for the optimizer field.\nNew API for problem modification (#388)\nTests pass without deprecation warnings on Julia 0.7.\nSmall fixes and documentation updates.","category":"page"},{"location":"moi/changelog/#v0.3.0-(May-25,-2018)","page":"Release notes","title":"v0.3.0 (May 25, 2018)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Functions have been redefined to use arrays-of-structs instead of structs-of-arrays.\nImprovements to MockOptimizer.\nSignificant changes to Bridges.\nNew and improved unit tests.\nFixes for Julia 0.7.","category":"page"},{"location":"moi/changelog/#v0.2.0-(April-24,-2018)","page":"Release notes","title":"v0.2.0 (April 24, 2018)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Improvements to and better coverage of Tests.\nDocumentation fixes.\nSolverName attribute.\nChanges to the NLP interface (new definition of variable order and arrays of structs for bound pairs and sparsity patterns).\nAddition of NLP tests.\nIntroduction of UniversalFallback.\ncopynames keyword argument to MOI.copy!.\nAdd Bridges submodule.","category":"page"},{"location":"moi/changelog/#v0.1.0-(February-28,-2018)","page":"Release notes","title":"v0.1.0 (February 28, 2018)","text":"","category":"section"},{"location":"moi/changelog/","page":"Release notes","title":"Release notes","text":"Initial public release.\nThe framework for MOI was developed at the JuMP-dev workshop at MIT in June 2017 as a sorely needed replacement for MathProgBase.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/submodules/Bridges/overview.md\"","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Bridges/overview/#The-Bridges-submodule","page":"Overview","title":"The Bridges submodule","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"The Bridges module simplifies the process of converting models between equivalent formulations.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"tip: Tip\nRead our paper for more details on how bridges are implemented.","category":"page"},{"location":"moi/submodules/Bridges/overview/#Why-bridges?","page":"Overview","title":"Why bridges?","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"A constraint can often be written in a number of equivalent formulations. For example, the constraint l le a^top x le u (ScalarAffineFunction-in-Interval) could be re-formulated as two constraints: a^top x ge l (ScalarAffineFunction-in-GreaterThan) and a^top x le u (ScalarAffineFunction-in-LessThan). An alternative re-formulation is to add a dummy variable y with the constraints l le y le u (VariableIndex-in-Interval) and a^top x - y = 0 (ScalarAffineFunction-in-EqualTo).","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"To avoid each solver having to code these transformations manually, MathOptInterface provides bridges.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"A bridge is a small transformation from one constraint type to another (potentially collection of) constraint type.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Because these bridges are included in MathOptInterface, they can be re-used by any optimizer. Some bridges also implement constraint modifications and constraint primal and dual translations.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Several bridges can be used in combination to transform a single constraint into a form that the solver may understand. Choosing the bridges to use takes the form of finding a shortest path in the hyper-graph of bridges. The methodology is detailed in the MOI paper.","category":"page"},{"location":"moi/submodules/Bridges/overview/#The-three-types-of-bridges","page":"Overview","title":"The three types of bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"There are three types of bridges in MathOptInterface:","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Constraint bridges\nVariable bridges\nObjective bridges","category":"page"},{"location":"moi/submodules/Bridges/overview/#Constraint-bridges","page":"Overview","title":"Constraint bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Constraint bridges convert constraints formulated by the user into an equivalent form supported by the solver. Constraint bridges are subtypes of Bridges.Constraint.AbstractBridge.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"The equivalent formulation may add constraints (and possibly also variables) in the underlying model.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"In particular, constraint bridges can focus on rewriting the function of a constraint, and do not change the set. Function bridges are subtypes of Bridges.Constraint.AbstractFunctionConversionBridge.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Read the list of implemented constraint bridges for more details on the types of transformations that are available. Function bridges are Bridges.Constraint.ScalarFunctionizeBridge and Bridges.Constraint.VectorFunctionizeBridge.","category":"page"},{"location":"moi/submodules/Bridges/overview/#variable_bridges","page":"Overview","title":"Variable bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Variable bridges convert variables added by the user, either free with add_variable/add_variables, or constrained with add_constrained_variable/add_constrained_variables, into an equivalent form supported by the solver. Variable bridges are subtypes of Bridges.Variable.AbstractBridge.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"The equivalent formulation may add constraints (and possibly also variables) in the underlying model.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Read the list of implemented variable bridges for more details on the types of transformations that are available.","category":"page"},{"location":"moi/submodules/Bridges/overview/#Objective-bridges","page":"Overview","title":"Objective bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Objective bridges convert the ObjectiveFunction set by the user into an equivalent form supported by the solver. Objective bridges are subtypes of Bridges.Objective.AbstractBridge.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"The equivalent formulation may add constraints (and possibly also variables) in the underlying model.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Read the list of implemented objective bridges for more details on the types of transformations that are available.","category":"page"},{"location":"moi/submodules/Bridges/overview/#Bridges.full_bridge_optimizer","page":"Overview","title":"Bridges.full_bridge_optimizer","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"tip: Tip\nUnless you have an advanced use-case, this is probably the only function you need to care about.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"To enable the full power of MathOptInterface's bridges, wrap an optimizer in a Bridges.full_bridge_optimizer.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"julia> inner_optimizer = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> optimizer = MOI.Bridges.full_bridge_optimizer(inner_optimizer, Float64)\nMOIB.LazyBridgeOptimizer{MOIU.Model{Float64}}\nwith 0 variable bridges\nwith 0 constraint bridges\nwith 0 objective bridges\nwith inner model MOIU.Model{Float64}","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Now, use optimizer as normal, and bridging will happen lazily behind the scenes. By lazily, we mean that bridging will happen if and only if the constraint is not supported by the inner_optimizer.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"info: Info\nMost bridges are added by default in Bridges.full_bridge_optimizer. However, for technical reasons, some bridges are not added by default. Three examples include Bridges.Constraint.SOCtoPSDBridge, Bridges.Constraint.SOCtoNonConvexQuadBridge and Bridges.Constraint.RSOCtoNonConvexQuadBridge. See the docs of those bridges for more information.","category":"page"},{"location":"moi/submodules/Bridges/overview/#Add-a-single-bridge","page":"Overview","title":"Add a single bridge","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"If you don't want to use Bridges.full_bridge_optimizer, you can wrap an optimizer in a single bridge.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"However, this will force the constraint to be bridged, even if the inner_optimizer supports it.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"julia> inner_optimizer = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> optimizer = MOI.Bridges.Constraint.SplitInterval{Float64}(inner_optimizer)\nMOIB.Constraint.SingleBridgeOptimizer{MOIB.Constraint.SplitIntervalBridge{Float64}, MOIU.Model{Float64}}\nwith 0 constraint bridges\nwith inner model MOIU.Model{Float64}\n\njulia> x = MOI.add_variable(optimizer)\nMOI.VariableIndex(1)\n\njulia> MOI.add_constraint(optimizer, x, MOI.Interval(0.0, 1.0))\nMathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64}}(1)\n\njulia> MOI.get(optimizer, MOI.ListOfConstraintTypesPresent())\n1-element Vector{Tuple{Type, Type}}:\n (MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64})\n\njulia> MOI.get(inner_optimizer, MOI.ListOfConstraintTypesPresent())\n2-element Vector{Tuple{Type, Type}}:\n (MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64})\n (MathOptInterface.VariableIndex, MathOptInterface.LessThan{Float64})","category":"page"},{"location":"moi/submodules/Bridges/overview/#Bridges.LazyBridgeOptimizer","page":"Overview","title":"Bridges.LazyBridgeOptimizer","text":"","category":"section"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"If you don't want to use Bridges.full_bridge_optimizer, but you need more than a single bridge (or you want the bridging to happen lazily), you can manually construct a Bridges.LazyBridgeOptimizer.","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"First, wrap an inner optimizer:","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"julia> inner_optimizer = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> optimizer = MOI.Bridges.LazyBridgeOptimizer(inner_optimizer)\nMOIB.LazyBridgeOptimizer{MOIU.Model{Float64}}\nwith 0 variable bridges\nwith 0 constraint bridges\nwith 0 objective bridges\nwith inner model MOIU.Model{Float64}","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Then use Bridges.add_bridge to add individual bridges:","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Bridges.add_bridge(optimizer, MOI.Bridges.Constraint.SplitIntervalBridge{Float64})\n\njulia> MOI.Bridges.add_bridge(optimizer, MOI.Bridges.Objective.FunctionizeBridge{Float64})","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"Now the constraints will be bridged only if needed:","category":"page"},{"location":"moi/submodules/Bridges/overview/","page":"Overview","title":"Overview","text":"julia> x = MOI.add_variable(optimizer)\nMOI.VariableIndex(1)\n\njulia> MOI.add_constraint(optimizer, x, MOI.Interval(0.0, 1.0))\nMathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64}}(1)\n\njulia> MOI.get(optimizer, MOI.ListOfConstraintTypesPresent())\n1-element Vector{Tuple{Type, Type}}:\n (MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64})\n\njulia> MOI.get(inner_optimizer, MOI.ListOfConstraintTypesPresent())\n1-element Vector{Tuple{Type, Type}}:\n (MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64})","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"EditURL = \"getting_started_with_data_and_plotting.jl\"","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Getting-started-with-data-and-plotting","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"In this tutorial we will learn how to read tabular data into Julia, and some of the basics of plotting.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"If you're new to Julia, start by reading Getting started with Julia and Getting started with JuMP first.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"note: Note\nThere are multiple ways to read the same kind of data into Julia. This tutorial focuses on DataFrames.jl because it provides the ecosystem to work with most of the required file types in a straightforward manner.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Before we get started, we need this constant to point to where the data files are.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"import JuMP\nconst DATA_DIR = joinpath(\n    dirname(pathof(JuMP)),\n    joinpath(\"..\", \"docs\", \"src\", \"tutorials\", \"getting_started\", \"data\"),\n);\nnothing #hide","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Where-to-get-help","page":"Getting started with data and plotting","title":"Where to get help","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Read the documentation","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Plots.jl: http://docs.juliaplots.org/latest/\nCSV.jl: http://csv.juliadata.org/stable\nDataFrames.jl: https://dataframes.juliadata.org/stable/","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Preliminaries","page":"Getting started with data and plotting","title":"Preliminaries","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"To get started, we need to install some packages.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#DataFrames.jl","page":"Getting started with data and plotting","title":"DataFrames.jl","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The DataFrames package provides a set of tools for working with tabular data. It is available through the Julia package manager.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"using Pkg\nPkg.add(\"DataFrames\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"import DataFrames","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"info: What is a DataFrame?\nA DataFrame is a data structure like a table or spreadsheet. You can use it for storing and exploring a set of related data values. Think of it as a smarter array for holding tabular data.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Plots.jl","page":"Getting started with data and plotting","title":"Plots.jl","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The Plots package provides a set of tools for plotting. It is available through the Julia package manager.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"using Pkg\nPkg.add(\"Plots\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"import Plots","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#CSV-.jl","page":"Getting started with data and plotting","title":"CSV .jl","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"CSV and other delimited text files can be read by the CSV.jl package.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Pkg.add(\"CSV\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"import CSV","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#DataFrame-basics","page":"Getting started with data and plotting","title":"DataFrame basics","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"To read a CSV file into a DataFrame, we use the CSV.read function.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df = CSV.read(joinpath(DATA_DIR, \"StarWars.csv\"), DataFrames.DataFrame)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Let's try plotting some of this data","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Plots.scatter(\n    csv_df.Weight,\n    csv_df.Height;\n    xlabel = \"Weight\",\n    ylabel = \"Height\",\n)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"That doesn't look right. What happened? If you look at the dataframe above, it read Weight in as a String column because there are \"NA\" fields. Let's correct that, by telling CSV to consider \"NA\" as missing.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df = CSV.read(\n    joinpath(DATA_DIR, \"StarWars.csv\"),\n    DataFrames.DataFrame;\n    missingstring = \"NA\",\n)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Then let's re-plot our data","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Plots.scatter(\n    csv_df.Weight,\n    csv_df.Height;\n    title = \"Height vs Weight of StarWars characters\",\n    xlabel = \"Weight\",\n    ylabel = \"Height\",\n    label = false,\n    ylims = (0, 3),\n)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"That looks better.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"tip: Tip\nRead the CSV documentation for other parsing options.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"DataFrames.jl supports manipulation using functions similar to pandas. For example, split the dataframe into groups based on eye-color:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"by_eyecolor = DataFrames.groupby(csv_df, :Eyecolor)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Then recombine into a single dataframe based on a function operating over the split dataframes:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"eyecolor_count = DataFrames.combine(by_eyecolor) do df\n    return DataFrames.nrow(df)\nend","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"We can rename columns:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"DataFrames.rename!(eyecolor_count, :x1 => :count)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Drop some missing rows:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"DataFrames.dropmissing!(eyecolor_count, :Eyecolor)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Then we can visualize the data:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"sort!(eyecolor_count, :count; rev = true)\nPlots.bar(\n    eyecolor_count.Eyecolor,\n    eyecolor_count.count;\n    xlabel = \"Eye color\",\n    ylabel = \"Number of characters\",\n    label = false,\n)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Other-Delimited-Files","page":"Getting started with data and plotting","title":"Other Delimited Files","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"We can also use the CSV.jl package to read any other delimited text file format.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"By default, CSV.File will try to detect a file's delimiter from the first 10 lines of the file.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Candidate delimiters include ',', '\\t', ' ', '|', ';', and ':'. If it can't auto-detect the delimiter, it will assume ','.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Let's take the example of space separated data.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"ss_df = CSV.read(joinpath(DATA_DIR, \"Cereal.txt\"), DataFrames.DataFrame)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"We can also specify the delimiter as follows:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"delim_df = CSV.read(\n    joinpath(DATA_DIR, \"Soccer.txt\"),\n    DataFrames.DataFrame;\n    delim = \"::\",\n)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Working-with-DataFrames","page":"Getting started with data and plotting","title":"Working with DataFrames","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Now that we have read the required data into a DataFrame, let us look at some basic operations we can perform on it.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Querying-Basic-Information","page":"Getting started with data and plotting","title":"Querying Basic Information","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The size function gets us the dimensions of the DataFrame:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"DataFrames.size(ss_df)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"We can also use the nrow and ncol functions to get the number of rows and columns respectively:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"DataFrames.nrow(ss_df), DataFrames.ncol(ss_df)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The describe function gives basic summary statistics of data in a DataFrame:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"DataFrames.describe(ss_df)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Names of every column can be obtained by the names function:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"DataFrames.names(ss_df)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Corresponding data types are obtained using the broadcasted eltype function:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"eltype.(ss_df)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Accessing-the-Data","page":"Getting started with data and plotting","title":"Accessing the Data","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Similar to regular arrays, we use numerical indexing to access elements of a DataFrame:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df[1, 1]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The following are different ways to access a column:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df[!, 1]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df[!, :Name]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df.Name","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df[:, 1] # Note that this creates a copy.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The following are different ways to access a row:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df[1:1, :]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df[1, :] # This produces a DataFrameRow.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"We can change the values just as we normally assign values.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Assign a range to scalar:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df[1:3, :Height] .= 1.83","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Assign a vector:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df[4:6, :Height] = [1.8, 1.6, 1.8]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"csv_df","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"tip: Tip\nThere are a lot more things which can be done with a DataFrame. Read the docs for more information.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"For information on dplyr-type syntax:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Read the DataFrames.jl documentation\nCheck out DataFramesMeta.jl","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Example:-the-passport-problem","page":"Getting started with data and plotting","title":"Example: the passport problem","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Let's now apply what we have learned to solve a real problem.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Data-manipulation","page":"Getting started with data and plotting","title":"Data manipulation","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The Passport Index Dataset lists travel visa requirements for 199 countries, in .csv format. Our task is to find the minimum number of passports required to visit all countries.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"passport_data = CSV.read(\n    joinpath(DATA_DIR, \"passport-index-matrix.csv\"),\n    DataFrames.DataFrame,\n);\nnothing #hide","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"In this dataset, the first column represents a passport (=from) and each remaining column represents a foreign country (=to).","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The values in each cell are as follows:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"3 = visa-free travel\n2 = eTA is required\n1 = visa can be obtained on arrival\n0 = visa is required\n-1 is for all instances where passport and destination are the same","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Our task is to find out the minimum number of passports needed to visit every country without requiring a visa.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The values we are interested in are -1 and 3. Let's modify the dataframe so that the -1 and 3 are 1 (true), and all others are 0 (false):","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"function modifier(x)\n    if x == -1 || x == 3\n        return 1\n    else\n        return 0\n    end\nend\n\nfor country in passport_data.Passport\n    passport_data[!, country] = modifier.(passport_data[!, country])\nend","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"The values in the cells now represent:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"1 = no visa required for travel\n0 = visa required for travel","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#JuMP-Modeling","page":"Getting started with data and plotting","title":"JuMP Modeling","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"To model the problem as a mixed-integer linear program, we need a binary decision variable x_c for each country c. x_c is 1 if we select passport c and 0 otherwise. Our objective is to minimize the sum sum x_c over all countries.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Since we wish to visit all the countries, for every country, we must own at least one passport that lets us travel to that country visa free. For one destination, this can be mathematically represented as sum_c in C a_cd cdot x_d geq 1, where a is the passport_data dataframe.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Thus, we can represent this problem using the following model:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"beginaligned\nmin  sum_c in C x_c \ntextst  sum_c in C a_cd x_c geq 1  forall d in C \n x_c in 01  forall c in C\nendaligned","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"We'll now solve the problem using JuMP:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"using JuMP\nimport HiGHS","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"First, create the set of countries:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"C = passport_data.Passport","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Then, create the model and initialize the decision variables:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, x[C], Bin)\n@objective(model, Min, sum(x))\n@constraint(model, [d in C], passport_data[!, d]' * x >= 1)\nmodel","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Now optimize:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"optimize!(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"We can use the solution_summary function to get an overview of the solution:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"solution_summary(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Just to be sure, check that the solver found an optimal solution:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"@assert is_solved_and_feasible(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/#Solution","page":"Getting started with data and plotting","title":"Solution","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"Let's  have a look at the solution in more detail:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"println(\"Minimum number of passports needed: \", objective_value(model))","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"println(\"Optimal passports:\")\nfor c in C\n    if value(x[c]) > 0.5\n        println(\" * \", c)\n    end\nend","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"We need some passports, like New Zealand and the United States, which have widespread access to a large number of countries. However, we also need passports like North Korea which only have visa-free access to a very limited number of countries.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_data_and_plotting/","page":"Getting started with data and plotting","title":"Getting started with data and plotting","text":"note: Note\nWe use value(x[c]) > 0.5 rather than value(x[c]) == 1 to avoid excluding solutions like x[c] = 0.99999 that are \"1\" to some tolerance.","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"EditURL = \"piecewise_linear.jl\"","category":"page"},{"location":"tutorials/linear/piecewise_linear/#Approximating-nonlinear-functions","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"","category":"section"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"The purpose of this tutorial is to explain how to approximate nonlinear functions with a mixed-integer linear program.","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"using JuMP\nimport HiGHS\nimport Plots","category":"page"},{"location":"tutorials/linear/piecewise_linear/#Minimizing-a-convex-function-(outer-approximation)","page":"Approximating nonlinear functions","title":"Minimizing a convex function (outer approximation)","text":"","category":"section"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"If the function you are approximating is convex, and you want to minimize \"down\" onto it, then you can use an outer approximation.","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"For example, f(x) = x^2 is a convex function:","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"f(x) = x^2\n∇f(x) = 2 * x\nplot = Plots.plot(f, -2:0.01:2; ylims = (-0.5, 4), label = false, width = 3)","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"Because f is convex, we know that for any x_k, we have: f(x) ge f(x_k) + nabla f(x_k) cdot (x - x_k)","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"for x_k in -2:1:2  ## Tip: try changing the number of points x_k\n    g = x -> f(x_k) + ∇f(x_k) * (x - x_k)\n    Plots.plot!(plot, g, -2:0.01:2; color = :red, label = false, width = 3)\nend\nplot","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"We can use these tangent planes as constraints in our model to create an outer approximation of the function. As we add more planes, the error between the true function and the piecewise linear outer approximation decreases.","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"Here is the model in JuMP:","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"function outer_approximate_x_squared(x̄)\n    f(x) = x^2\n    ∇f(x) = 2x\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    @variable(model, -2 <= x <= 2)\n    @variable(model, y)\n    # Tip: try changing the number of points x_k\n    @constraint(model, [x_k in -2:1:2], y >= f(x_k) + ∇f(x_k) * (x - x_k))\n    @objective(model, Min, y)\n    @constraint(model, x == x̄)  # <-- a trivial constraint just for testing.\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    return value(y)\nend","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"Here are a few values:","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"for x̄ in range(; start = -2, stop = 2, length = 15)\n    ȳ = outer_approximate_x_squared(x̄)\n    Plots.scatter!(plot, [x̄], [ȳ]; label = false, color = :black)\nend\nplot","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"note: Note\nThis formulation does not work if we want to maximize y.","category":"page"},{"location":"tutorials/linear/piecewise_linear/#Maximizing-a-concave-function-(outer-approximation)","page":"Approximating nonlinear functions","title":"Maximizing a concave function (outer approximation)","text":"","category":"section"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"The outer approximation also works if we want to maximize \"up\" into a concave function.","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"f(x) = log(x)\n∇f(x) = 1 / x\nX = 0.1:0.1:1.6\nplot = Plots.plot(\n    f,\n    X;\n    xlims = (0.1, 1.6),\n    ylims = (-3, log(1.6)),\n    label = false,\n    width = 3,\n)\nfor x_k in 0.1:0.5:1.6  ## Tip: try changing the number of points x_k\n    g = x -> f(x_k) + ∇f(x_k) * (x - x_k)\n    Plots.plot!(plot, g, X; color = :red, label = false, width = 3)\nend\nplot","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"Here is the model in JuMP:","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"function outer_approximate_log(x̄)\n    f(x) = log(x)\n    ∇f(x) = 1 / x\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    @variable(model, 0.1 <= x <= 1.6)\n    @variable(model, y)\n    # Tip: try changing the number of points x_k\n    @constraint(model, [x_k in 0.1:0.5:2], y <= f(x_k) + ∇f(x_k) * (x - x_k))\n    @objective(model, Max, y)\n    @constraint(model, x == x̄)  # <-- a trivial constraint just for testing.\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    return value(y)\nend","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"Here are a few values:","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"for x̄ in range(; start = 0.1, stop = 1.6, length = 15)\n    ȳ = outer_approximate_log(x̄)\n    Plots.scatter!(plot, [x̄], [ȳ]; label = false, color = :black)\nend\nplot","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"note: Note\nThis formulation does not work if we want to minimize y.","category":"page"},{"location":"tutorials/linear/piecewise_linear/#Minimizing-a-convex-function-(inner-approximation)","page":"Approximating nonlinear functions","title":"Minimizing a convex function (inner approximation)","text":"","category":"section"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"Instead of creating an outer approximation, we can also create an inner approximation. For example, given f(x) = x^2, we may want to approximate the true function by the red piecewise linear function:","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"f(x) = x^2\nx̂ = -2:0.8:2  ## Tip: try changing the number of points in x̂\nplot = Plots.plot(f, -2:0.01:2; ylims = (-0.5, 4), label = false, linewidth = 3)\nPlots.plot!(plot, f, x̂; label = false, color = :red, linewidth = 3)\nplot","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"To do so, we represent the decision variables (x y) by the convex combination of a set of discrete points x_k y_k_k=1^K:","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"beginaligned\nx = sumlimits_k=1^K lambda_k x_k \ny = sumlimits_k=1^K lambda_k y_k \nsumlimits_k=1^K lambda_k = 1 \nlambda_k ge 0 k=1ldotsk \nendaligned","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"The feasible region of the convex combination actually allows any (x y) point inside this shaded region:","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"I = [1, 2, 3, 4, 5, 6, 1]\nPlots.plot!(x̂[I], f.(x̂[I]); fill = (0, 0, \"#f004\"), width = 0, label = false)\nplot","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"Thus, this formulation does not work if we want to maximize y.","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"Here is the model in JuMP:","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"function inner_approximate_x_squared(x̄)\n    f(x) = x^2\n    ∇f(x) = 2x\n    x̂ = -2:0.8:2  ## Tip: try changing the number of points in x̂\n    ŷ = f.(x̂)\n    n = length(x̂)\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    @variable(model, -2 <= x <= 2)\n    @variable(model, y)\n    @variable(model, 0 <= λ[1:n] <= 1)\n    @constraint(model, x == sum(λ[i] * x̂[i] for i in 1:n))\n    @constraint(model, y == sum(λ[i] * ŷ[i] for i in 1:n))\n    @constraint(model, sum(λ) == 1)\n    @objective(model, Min, y)\n    @constraint(model, x == x̄)  # <-- a trivial constraint just for testing.\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    return value(y)\nend","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"Here are a few values:","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"for x̄ in range(; start = -2, stop = 2, length = 15)\n    ȳ = inner_approximate_x_squared(x̄)\n    Plots.scatter!(plot, [x̄], [ȳ]; label = false, color = :black)\nend\nplot","category":"page"},{"location":"tutorials/linear/piecewise_linear/#Maximizing-a-convex-function-(inner-approximation)","page":"Approximating nonlinear functions","title":"Maximizing a convex function (inner approximation)","text":"","category":"section"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"The inner approximation also works if we want to maximize \"up\" into a concave function.","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"f(x) = log(x)\nx̂ = 0.1:0.5:1.6  ## Tip: try changing the number of points in x̂\nplot = Plots.plot(f, 0.1:0.01:1.6; label = false, linewidth = 3)\nPlots.plot!(x̂, f.(x̂); linewidth = 3, color = :red, label = false)\nI = [1, 2, 3, 4, 1]\nPlots.plot!(x̂[I], f.(x̂[I]); fill = (0, 0, \"#f004\"), width = 0, label = false)\nplot","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"Here is the model in JuMP:","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"function inner_approximate_log(x̄)\n    f(x) = log(x)\n    x̂ = 0.1:0.5:1.6  ## Tip: try changing the number of points in x̂\n    ŷ = f.(x̂)\n    n = length(x̂)\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    @variable(model, 0.1 <= x <= 1.6)\n    @variable(model, y)\n    @variable(model, 0 <= λ[1:n] <= 1)\n    @constraint(model, sum(λ) == 1)\n    @constraint(model, x == sum(λ[i] * x̂[i] for i in 1:n))\n    @constraint(model, y == sum(λ[i] * ŷ[i] for i in 1:n))\n    @objective(model, Max, y)\n    @constraint(model, x == x̄)  # <-- a trivial constraint just for testing.\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    return value(y)\nend","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"Here are a few values:","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"for x̄ in range(; start = 0.1, stop = 1.6, length = 15)\n    ȳ = inner_approximate_log(x̄)\n    Plots.scatter!(plot, [x̄], [ȳ]; label = false, color = :black)\nend\nplot","category":"page"},{"location":"tutorials/linear/piecewise_linear/#Piecewise-linear-approximation","page":"Approximating nonlinear functions","title":"Piecewise linear approximation","text":"","category":"section"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"If the model is non-convex (or non-concave), then we cannot use an outer approximation, and the inner approximation allows a solution far from the true function. For example, for f(x) = sin(x), we have:","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"f(x) = sin(x)\nplot = Plots.plot(f, 0:0.01:2π; label = false)\nx̂ = range(; start = 0, stop = 2π, length = 7)\nPlots.plot!(x̂, f.(x̂); linewidth = 3, color = :red, label = false)\nI = [1, 5, 6, 7, 3, 2, 1]\nPlots.plot!(x̂[I], f.(x̂[I]); fill = (0, 0, \"#f004\"), width = 0, label = false)\nplot","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"We can force the inner approximation to stay on the red line by adding the constraint λ in SOS2(). The SOS2 set is a Special Ordered Set of Type 2, and it ensures that at most two elements of λ can be non-zero, and if they are, that they must be adjacent. This prevents the model from taking a convex combination of points 1 and 5 to end up on the lower boundary of the shaded red area.","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"Here is the model in JuMP:","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"function piecewise_linear_sin(x̄)\n    f(x) = sin(x)\n    # Tip: try changing the number of points in x̂\n    x̂ = range(; start = 0, stop = 2π, length = 7)\n    ŷ = f.(x̂)\n    n = length(x̂)\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    @variable(model, 0 <= x <= 2π)\n    @variable(model, y)\n    @variable(model, 0 <= λ[1:n] <= 1)\n    @constraints(model, begin\n        x == sum(λ[i] * x̂[i] for i in 1:n)\n        y == sum(λ[i] * ŷ[i] for i in 1:n)\n        sum(λ) == 1\n        λ in SOS2()  # <-- this is new\n    end)\n    @constraint(model, x == x̄)  # <-- a trivial constraint just for testing.\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    return value(y)\nend","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"Here are a few values:","category":"page"},{"location":"tutorials/linear/piecewise_linear/","page":"Approximating nonlinear functions","title":"Approximating nonlinear functions","text":"for x̄ in range(; start = 0, stop = 2π, length = 15)\n    ȳ = piecewise_linear_sin(x̄)\n    Plots.scatter!(plot, [x̄], [ȳ]; label = false, color = :black)\nend\nplot","category":"page"},{"location":"developers/roadmap/#Development-roadmap","page":"Roadmap","title":"Development roadmap","text":"","category":"section"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"The JuMP developers have compiled this roadmap document to share their plans and goals with the JuMP community. Contributions to roadmap issues are especially invited.","category":"page"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"Most of these issues will require changes to both JuMP and MathOptInterface, and are non-trivial in their implementation. They are in no particular order, but represent broad themes that we see as areas in which JuMP could be improved.","category":"page"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"Support nonlinear expressions with vector-valued inputs and outputs. There are a few related components:\nRepresenting terms like log(det(X)) as necessary for Convex.jl\nAutomatic differentiation of terms with vector inputs and outputs\nUser-defined functions with vector–as opposed to scalar–inputs, which is particularly useful for optimal control problems\nUser-defined functions with vector outputs, avoiding the need for User-defined operators with vector outputs\nAdd support for modeling with SI units. The UnitJuMP.jl extension is a good proof of concept for what this would look like. We want to make units a first-class concept in JuMP. See #1350 for more details.","category":"page"},{"location":"developers/roadmap/#Completed","page":"Roadmap","title":"Completed","text":"","category":"section"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"Done #3106 Make nonlinear programming a first-class citizen. There have been many issues and discussions about this: currently nonlinear constraints are handled through a MOI.NLPBlock and have various limitations and restrictions.\nhttps://github.com/jump-dev/JuMP.jl/issues/1185\nhttps://github.com/jump-dev/JuMP.jl/issues/1198\nhttps://github.com/jump-dev/JuMP.jl/issues/2788\nhttps://github.com/jump-dev/MathOptInterface.jl/issues/846\nhttps://github.com/jump-dev/MathOptInterface.jl/issues/1397\nDone #3385 Add support for coefficient types other than Float64: https://github.com/jump-dev/JuMP.jl/issues/2025 Since the very beginning, JuMP has hard-coded the coefficient type as Float64. This has made it impossible to support solvers which can use other types such as BigFloat or Rational{BigInt}.\nDone #3385 Add support for constraint programming: https://github.com/jump-dev/JuMP.jl/issues/2227 JuMP has a strong focus on linear, conic and nonlinear optimization problems. We want to add better support for constraint programming.\nDone #3176 Add support for multiobjective problems: https://github.com/jump-dev/JuMP.jl/issues/2099 JuMP is restricted to problems with scalar-valued objectives. We want to extend this to vector-valued problems.\nDone #3629 Refactor the internal code of JuMP's macros. The code in src/macros.jl is some of the oldest part of JuMP and is difficult to read, modify, and extend. We should overhaul the internals of JuMP's macros–-without making user-visible breaking changes–-to improve their long-term maintainability.","category":"page"},{"location":"tutorials/nonlinear/simple_examples/","page":"Simple examples","title":"Simple examples","text":"EditURL = \"simple_examples.jl\"","category":"page"},{"location":"tutorials/nonlinear/simple_examples/#Simple-examples","page":"Simple examples","title":"Simple examples","text":"","category":"section"},{"location":"tutorials/nonlinear/simple_examples/","page":"Simple examples","title":"Simple examples","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/nonlinear/simple_examples/","page":"Simple examples","title":"Simple examples","text":"This tutorial is a collection of examples of small nonlinear programs. It uses the following packages:","category":"page"},{"location":"tutorials/nonlinear/simple_examples/","page":"Simple examples","title":"Simple examples","text":"using JuMP\nimport Ipopt\nimport Random\nimport Statistics\nimport Test","category":"page"},{"location":"tutorials/nonlinear/simple_examples/#The-Rosenbrock-function","page":"Simple examples","title":"The Rosenbrock function","text":"","category":"section"},{"location":"tutorials/nonlinear/simple_examples/","page":"Simple examples","title":"Simple examples","text":"A nonlinear example of the classical Rosenbrock function.","category":"page"},{"location":"tutorials/nonlinear/simple_examples/","page":"Simple examples","title":"Simple examples","text":"function example_rosenbrock()\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, x)\n    @variable(model, y)\n    @objective(model, Min, (1 - x)^2 + 100 * (y - x^2)^2)\n    optimize!(model)\n    Test.@test is_solved_and_feasible(model)\n    Test.@test objective_value(model) ≈ 0.0 atol = 1e-10\n    Test.@test value(x) ≈ 1.0\n    Test.@test value(y) ≈ 1.0\n    return\nend\n\nexample_rosenbrock()","category":"page"},{"location":"tutorials/nonlinear/simple_examples/#The-clnlbeam-problem","page":"Simple examples","title":"The clnlbeam problem","text":"","category":"section"},{"location":"tutorials/nonlinear/simple_examples/","page":"Simple examples","title":"Simple examples","text":"Based on an AMPL model by Hande Y. Benson","category":"page"},{"location":"tutorials/nonlinear/simple_examples/","page":"Simple examples","title":"Simple examples","text":"Copyright (C) 2001 Princeton University All Rights Reserved","category":"page"},{"location":"tutorials/nonlinear/simple_examples/","page":"Simple examples","title":"Simple examples","text":"Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that the copyright notice and this permission notice appear in all supporting documentation.","category":"page"},{"location":"tutorials/nonlinear/simple_examples/","page":"Simple examples","title":"Simple examples","text":"Source:","category":"page"},{"location":"tutorials/nonlinear/simple_examples/","page":"Simple examples","title":"Simple examples","text":"H. Maurer and H.D. Mittelman, \"The non-linear beam via optimal control with bound state variables,\" Optimal Control Applications and Methods 12, pp. 19-31, 1991.","category":"page"},{"location":"tutorials/nonlinear/simple_examples/","page":"Simple examples","title":"Simple examples","text":"function example_clnlbeam()\n    N = 1000\n    h = 1 / N\n    alpha = 350\n    model = Model(Ipopt.Optimizer)\n    @variables(model, begin\n        -1 <= t[1:(N+1)] <= 1\n        -0.05 <= x[1:(N+1)] <= 0.05\n        u[1:(N+1)]\n    end)\n    @objective(\n        model,\n        Min,\n        sum(\n            0.5 * h * (u[i+1]^2 + u[i]^2) +\n            0.5 * alpha * h * (cos(t[i+1]) + cos(t[i])) for i in 1:N\n        ),\n    )\n    @constraint(\n        model,\n        [i = 1:N],\n        x[i+1] - x[i] - 0.5 * h * (sin(t[i+1]) + sin(t[i])) == 0,\n    )\n    @constraint(\n        model,\n        [i = 1:N],\n        t[i+1] - t[i] - 0.5 * h * u[i+1] - 0.5 * h * u[i] == 0,\n    )\n    optimize!(model)\n    println(\"\"\"\n    termination_status = $(termination_status(model))\n    primal_status      = $(primal_status(model))\n    objective_value    = $(objective_value(model))\n    \"\"\")\n    Test.@test is_solved_and_feasible(model)\n    return\nend\n\nexample_clnlbeam()","category":"page"},{"location":"tutorials/nonlinear/simple_examples/#Maximum-likelihood-estimation","page":"Simple examples","title":"Maximum likelihood estimation","text":"","category":"section"},{"location":"tutorials/nonlinear/simple_examples/","page":"Simple examples","title":"Simple examples","text":"This example uses nonlinear optimization to compute the maximum likelihood estimate (MLE) of the parameters of a normal distribution, a.k.a., the sample mean and variance.","category":"page"},{"location":"tutorials/nonlinear/simple_examples/","page":"Simple examples","title":"Simple examples","text":"function example_mle()\n    n = 1_000\n    Random.seed!(1234)\n    data = randn(n)\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, μ, start = 0.0)\n    @variable(model, σ >= 0.0, start = 1.0)\n    @objective(\n        model,\n        Max,\n        n / 2 * log(1 / (2 * π * σ^2)) -\n        sum((data[i] - μ)^2 for i in 1:n) / (2 * σ^2)\n    )\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    println(\"μ             = \", value(μ))\n    println(\"mean(data)    = \", Statistics.mean(data))\n    println(\"σ^2           = \", value(σ)^2)\n    println(\"var(data)     = \", Statistics.var(data))\n    println(\"MLE objective = \", objective_value(model))\n    Test.@test value(μ) ≈ Statistics.mean(data) atol = 1e-3\n    Test.@test value(σ)^2 ≈ Statistics.var(data) atol = 1e-2\n    # You can even do constrained MLE!\n    @constraint(model, μ == σ^2)\n    optimize!(model)\n    @assert is_solved_and_feasible(model)\n    Test.@test value(μ) ≈ value(σ)^2\n    println()\n    println(\"With constraint μ == σ^2:\")\n    println(\"μ                         = \", value(μ))\n    println(\"σ^2                       = \", value(σ)^2)\n    println(\"Constrained MLE objective = \", objective_value(model))\n    return\nend\n\nexample_mle()","category":"page"},{"location":"tutorials/nonlinear/simple_examples/#Quadratically-constrained-programs","page":"Simple examples","title":"Quadratically constrained programs","text":"","category":"section"},{"location":"tutorials/nonlinear/simple_examples/","page":"Simple examples","title":"Simple examples","text":"A simple quadratically constrained program based on an example from Gurobi.","category":"page"},{"location":"tutorials/nonlinear/simple_examples/","page":"Simple examples","title":"Simple examples","text":"function example_qcp()\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, x)\n    @variable(model, y >= 0)\n    @variable(model, z >= 0)\n    @objective(model, Max, x)\n    @constraint(model, x + y + z == 1)\n    @constraint(model, x * x + y * y - z * z <= 0)\n    @constraint(model, x * x - y * z <= 0)\n    optimize!(model)\n    Test.@test is_solved_and_feasible(model)\n    print(model)\n    println(\"Objective value: \", objective_value(model))\n    println(\"x = \", value(x))\n    println(\"y = \", value(y))\n    Test.@test objective_value(model) ≈ 0.32699 atol = 1e-5\n    Test.@test value(x) ≈ 0.32699 atol = 1e-5\n    Test.@test value(y) ≈ 0.25707 atol = 1e-5\n    return\nend\n\nexample_qcp()","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"EditURL = \"https://github.com/jump-dev/GLPK.jl/blob/v1.2.0/README.md\"","category":"page"},{"location":"packages/GLPK/#GLPK.jl","page":"jump-dev/GLPK.jl","title":"GLPK.jl","text":"","category":"section"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"GLPK.jl is a wrapper for the GNU Linear Programming Kit library.","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"The wrapper has two components:","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"a thin wrapper around the complete C API\nan interface to MathOptInterface","category":"page"},{"location":"packages/GLPK/#Affiliation","page":"jump-dev/GLPK.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"This wrapper is maintained by the JuMP community and is not an GNU project.","category":"page"},{"location":"packages/GLPK/#License","page":"jump-dev/GLPK.jl","title":"License","text":"","category":"section"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"GLPK.jl is licensed under the GPL v3 license.","category":"page"},{"location":"packages/GLPK/#Installation","page":"jump-dev/GLPK.jl","title":"Installation","text":"","category":"section"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"Install GLPK using Pkg.add:","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"import Pkg\nPkg.add(\"GLPK\")","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"In addition to installing the GLPK.jl package, this will also download and install the GLPK binaries. You do not need to install GLPK separately.","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"To use a custom binary, read the Custom solver binaries section of the JuMP documentation.","category":"page"},{"location":"packages/GLPK/#Use-with-JuMP","page":"jump-dev/GLPK.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"To use GLPK with JuMP, use GLPK.Optimizer:","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"using JuMP, GLPK\nmodel = Model(GLPK.Optimizer)\nset_attribute(model, \"tm_lim\", 60 * 1_000)\nset_attribute(model, \"msg_lev\", GLPK.GLP_MSG_OFF)","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"If the model is primal or dual infeasible, GLPK will attempt to find a certificate of infeasibility. This can be expensive, particularly if you do not intend to use the certificate. If this is the case, use:","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"model = Model(() -> GLPK.Optimizer(; want_infeasibility_certificates = false))","category":"page"},{"location":"packages/GLPK/#MathOptInterface-API","page":"jump-dev/GLPK.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"The GLPK optimizer supports the following constraints and attributes.","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"List of supported objective functions:","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"MOI.Reals","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"MOI.ScalarAffineFunction{Float64} in MOI.EqualTo{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.EqualTo{Float64}\nMOI.VariableIndex in MOI.GreaterThan{Float64}\nMOI.VariableIndex in MOI.Integer\nMOI.VariableIndex in MOI.Interval{Float64}\nMOI.VariableIndex in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.ZeroOne","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"MOI.HeuristicCallback()\nMOI.LazyConstraintCallback()\nMOI.Name()\nMOI.ObjectiveSense()\nMOI.UserCutCallback()","category":"page"},{"location":"packages/GLPK/#Options","page":"jump-dev/GLPK.jl","title":"Options","text":"","category":"section"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"Options for GLPK are comprehensively documented in the PDF documentation, but they are hard to find.","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"Options when solving a linear program are defined in Section 2.8.1\nOptions when solving a mixed-integer program are defined in Section 2.10.5","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"However, the following options are likely to be the most useful:","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"Parameter Example Explanation\nmsg_lev GLPK.GLP_MSG_ALL Message level for terminal output\npresolve GLPK.GLP_ON Turn presolve on or off\ntol_int 1e-5 Absolute tolerance for integer feasibility\ntol_obj 1e-7 Relative objective tolerance for mixed-integer programs","category":"page"},{"location":"packages/GLPK/#Callbacks","page":"jump-dev/GLPK.jl","title":"Callbacks","text":"","category":"section"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"Here is an example using GLPK's solver-specific callbacks.","category":"page"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"using JuMP, GLPK, Test\n\nmodel = Model(GLPK.Optimizer)\n@variable(model, 0 <= x <= 2.5, Int)\n@variable(model, 0 <= y <= 2.5, Int)\n@objective(model, Max, y)\nreasons = UInt8[]\nfunction my_callback_function(cb_data)\n    reason = GLPK.glp_ios_reason(cb_data.tree)\n    push!(reasons, reason)\n    if reason != GLPK.GLP_IROWGEN\n        return\n    end\n    x_val = callback_value(cb_data, x)\n    y_val = callback_value(cb_data, y)\n    if y_val - x_val > 1 + 1e-6\n        con = @build_constraint(y - x <= 1)\n        MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n    elseif y_val + x_val > 3 + 1e-6\n        con = @build_constraint(y - x <= 1)\n        MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n    end\nend\nMOI.set(model, GLPK.CallbackFunction(), my_callback_function)\noptimize!(model)\n@test termination_status(model) == MOI.OPTIMAL\n@test primal_status(model) == MOI.FEASIBLE_POINT\n@test value(x) == 1\n@test value(y) == 2\n@show reasons","category":"page"},{"location":"packages/GLPK/#C-API","page":"jump-dev/GLPK.jl","title":"C API","text":"","category":"section"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"The C API can be accessed via GLPK.glp_XXX functions, where the names and arguments are identical to the C API. See the /tests folder for inspiration.","category":"page"},{"location":"packages/GLPK/#Thread-safety","page":"jump-dev/GLPK.jl","title":"Thread safety","text":"","category":"section"},{"location":"packages/GLPK/","page":"jump-dev/GLPK.jl","title":"jump-dev/GLPK.jl","text":"GLPK is not thread-safe and should not be used with multithreading.","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"EditURL = \"https://github.com/JuliaManifolds/Manopt.jl/blob/v0.4.58/Readme.md\"","category":"page"},{"location":"packages/Manopt/#Manopt.jl","page":"JuliaManifolds/Manopt.jl","title":"Manopt.jl","text":"","category":"section"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"Optimization Algorithm on Riemannian Manifolds.","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"(Image: ) (Image: Code Style: Blue) (Image: CI) (Image: codecov) (Image: DOI) (Image: DOI)","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"For a function f ℳ  ℝ  that maps from a Riemannian manifold ℳ to the real line, this package aims to solve","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"Find the minimizer p on ℳ, that is, the (or a) point where f attains its minimum.","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"Manopt.jl provides","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"A framework to implement arbitrary optimization algorithms on Riemannian Manifolds\nA library of optimization algorithms on Riemannian manifolds\nan easy-to-use interface for (debug) output and recording values during an algorithm run.\nseveral tools to investigate the algorithms, gradients, and optimality criteria","category":"page"},{"location":"packages/Manopt/#Getting-started","page":"JuliaManifolds/Manopt.jl","title":"Getting started","text":"","category":"section"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"In Julia you can get started by just typing","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"using Pkg; Pkg.add(\"Manopt\");","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"and then checkout the Get started: optimize! tutorial.","category":"page"},{"location":"packages/Manopt/#Related-packages","page":"JuliaManifolds/Manopt.jl","title":"Related packages","text":"","category":"section"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"Manopt.jl is based on ManifoldsBase.jl, hence the algorithms can be used with any manifold following this interface for defining a Riemannian manifold.","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"The following packages are related to Manopt.jl","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"Manifolds.jl: a library of manifolds implemented using ManifoldsBase.jl :octocat: GitHub repository\nManifoldsDiff.jl: a package to use (Euclidean) AD tools on manifolds, that also provides several differentials and gradients. :octocat: GitHub repository\nJuMP.jl: can be used as interface to solve an optimization problem with Manopt. See usage examples. :octocat: GitHub repository","category":"page"},{"location":"packages/Manopt/#Citation","page":"JuliaManifolds/Manopt.jl","title":"Citation","text":"","category":"section"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"If you use Manopt.jl in your work, please cite the following","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"@article{Bergmann2022,\n    Author    = {Ronny Bergmann},\n    Doi       = {10.21105/joss.03866},\n    Journal   = {Journal of Open Source Software},\n    Number    = {70},\n    Pages     = {3866},\n    Publisher = {The Open Journal},\n    Title     = {Manopt.jl: Optimization on Manifolds in {J}ulia},\n    Volume    = {7},\n    Year      = {2022},\n}","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"To refer to a certain version or the source code in general please cite for example","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"@software{manoptjl-zenodo-mostrecent,\n    Author    = {Ronny Bergmann},\n    Copyright = {MIT License},\n    Doi       = {10.5281/zenodo.4290905},\n    Publisher = {Zenodo},\n    Title     = {Manopt.jl},\n    Year      = {2024},\n}","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"for the most recent version or a corresponding version specific DOI, see the list of all versions.","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"If you are also using Manifolds.jl please consider to cite","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"@article{AxenBaranBergmannRzecki:2023,\n    AUTHOR    = {Axen, Seth D. and Baran, Mateusz and Bergmann, Ronny and Rzecki, Krzysztof},\n    ARTICLENO = {33},\n    DOI       = {10.1145/3618296},\n    JOURNAL   = {ACM Transactions on Mathematical Software},\n    MONTH     = {dec},\n    NUMBER    = {4},\n    TITLE     = {Manifolds.jl: An Extensible Julia Framework for Data Analysis on Manifolds},\n    VOLUME    = {49},\n    YEAR      = {2023}\n}","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"as well. Note that all citations are in BibLaTeX format.","category":"page"},{"location":"packages/Manopt/#Further-and-Similar-Packages-and-Links","page":"JuliaManifolds/Manopt.jl","title":"Further and Similar Packages & Links","text":"","category":"section"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"Manopt.jl belongs to the Manopt family:","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"www.manopt.org: the MATLAB version of Manopt, see also their :octocat: GitHub repository\nwww.pymanopt.org: the Python version of Manopt—providing also several AD backends, see also their :octocat: GitHub repository","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"but there are also more packages providing tools on manifolds:","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"Jax Geometry (Python/Jax): differential geometry and stochastic dynamics with deep learning\nGeomstats (Python with several backends): focusing on statistics and machine learning :octocat: GitHub repository\nGeoopt (Python & PyTorch): Riemannian ADAM & SGD. :octocat: GitHub repository\nMcTorch (Python & PyToch): Riemannian SGD, Adagrad, ASA & CG.\nROPTLIB (C++): a Riemannian OPTimization LIBrary :octocat: GitHub repository\nTF Riemopt (Python & TensorFlow): Riemannian optimization using TensorFlow","category":"page"},{"location":"packages/Manopt/","page":"JuliaManifolds/Manopt.jl","title":"JuliaManifolds/Manopt.jl","text":"Did you use Manopt.jl somewhere? Let us know! We'd love to collect those here as well.","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"EditURL = \"callbacks.jl\"","category":"page"},{"location":"tutorials/linear/callbacks/#callbacks_tutorial","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"The purpose of the tutorial is to demonstrate the various solver-independent and solver-dependent callbacks that are supported by JuMP.","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"The tutorial uses the following packages:","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"using JuMP\nimport GLPK\nimport Random\nimport Test","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"info: Info\nThis tutorial uses the MathOptInterface API. By default, JuMP exports the MOI symbol as an alias for the MathOptInterface.jl package. We recommend making this more explicit in your code by adding the following lines:import MathOptInterface as MOI","category":"page"},{"location":"tutorials/linear/callbacks/#Lazy-constraints","page":"Callbacks","title":"Lazy constraints","text":"","category":"section"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using a lazy constraint callback.","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_lazy_constraint()\n    model = Model(GLPK.Optimizer)\n    @variable(model, 0 <= x <= 2.5, Int)\n    @variable(model, 0 <= y <= 2.5, Int)\n    @objective(model, Max, y)\n    lazy_called = false\n    function my_callback_function(cb_data)\n        lazy_called = true\n        x_val = callback_value(cb_data, x)\n        y_val = callback_value(cb_data, y)\n        println(\"Called from (x, y) = ($x_val, $y_val)\")\n        status = callback_node_status(cb_data, model)\n        if status == MOI.CALLBACK_NODE_STATUS_FRACTIONAL\n            println(\" - Solution is integer infeasible!\")\n        elseif status == MOI.CALLBACK_NODE_STATUS_INTEGER\n            println(\" - Solution is integer feasible!\")\n        else\n            @assert status == MOI.CALLBACK_NODE_STATUS_UNKNOWN\n            println(\" - I don't know if the solution is integer feasible :(\")\n        end\n        if y_val - x_val > 1 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        elseif y_val + x_val > 3 + 1e-6\n            con = @build_constraint(y + x <= 3)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        end\n    end\n    set_attribute(model, MOI.LazyConstraintCallback(), my_callback_function)\n    optimize!(model)\n    Test.@test is_solved_and_feasible(model)\n    Test.@test lazy_called\n    Test.@test value(x) == 1\n    Test.@test value(y) == 2\n    println(\"Optimal solution (x, y) = ($(value(x)), $(value(y)))\")\n    return\nend\n\nexample_lazy_constraint()","category":"page"},{"location":"tutorials/linear/callbacks/#User-cuts","page":"Callbacks","title":"User-cuts","text":"","category":"section"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using a user-cut callback.","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_user_cut_constraint()\n    Random.seed!(1)\n    N = 30\n    item_weights, item_values = rand(N), rand(N)\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:N], Bin)\n    @constraint(model, sum(item_weights[i] * x[i] for i in 1:N) <= 10)\n    @objective(model, Max, sum(item_values[i] * x[i] for i in 1:N))\n    callback_called = false\n    function my_callback_function(cb_data)\n        callback_called = true\n        x_vals = callback_value.(Ref(cb_data), x)\n        accumulated = sum(item_weights[i] for i in 1:N if x_vals[i] > 1e-4)\n        println(\"Called with accumulated = $(accumulated)\")\n        n_terms = sum(1 for i in 1:N if x_vals[i] > 1e-4)\n        if accumulated > 10\n            con = @build_constraint(\n                sum(x[i] for i in 1:N if x_vals[i] > 0.5) <= n_terms - 1\n            )\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.UserCut(cb_data), con)\n        end\n    end\n    set_attribute(model, MOI.UserCutCallback(), my_callback_function)\n    optimize!(model)\n    Test.@test is_solved_and_feasible(model)\n    Test.@test callback_called\n    @show callback_called\n    return\nend\n\nexample_user_cut_constraint()","category":"page"},{"location":"tutorials/linear/callbacks/#Heuristic-solutions","page":"Callbacks","title":"Heuristic solutions","text":"","category":"section"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using a heuristic solution callback.","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_heuristic_solution()\n    Random.seed!(1)\n    N = 30\n    item_weights, item_values = rand(N), rand(N)\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:N], Bin)\n    @constraint(model, sum(item_weights[i] * x[i] for i in 1:N) <= 10)\n    @objective(model, Max, sum(item_values[i] * x[i] for i in 1:N))\n    callback_called = false\n    function my_callback_function(cb_data)\n        callback_called = true\n        x_vals = callback_value.(Ref(cb_data), x)\n        ret =\n            MOI.submit(model, MOI.HeuristicSolution(cb_data), x, floor.(x_vals))\n        println(\"Heuristic solution status = $(ret)\")\n        Test.@test ret in (\n            MOI.HEURISTIC_SOLUTION_ACCEPTED,\n            MOI.HEURISTIC_SOLUTION_REJECTED,\n        )\n    end\n    set_attribute(model, MOI.HeuristicCallback(), my_callback_function)\n    optimize!(model)\n    Test.@test is_solved_and_feasible(model)\n    Test.@test callback_called\n    return\nend\n\nexample_heuristic_solution()","category":"page"},{"location":"tutorials/linear/callbacks/#GLPK-solver-dependent-callback","page":"Callbacks","title":"GLPK solver-dependent callback","text":"","category":"section"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using GLPK's solver-dependent callback.","category":"page"},{"location":"tutorials/linear/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_solver_dependent_callback()\n    model = Model(GLPK.Optimizer)\n    @variable(model, 0 <= x <= 2.5, Int)\n    @variable(model, 0 <= y <= 2.5, Int)\n    @objective(model, Max, y)\n    lazy_called = false\n    function my_callback_function(cb_data)\n        lazy_called = true\n        reason = GLPK.glp_ios_reason(cb_data.tree)\n        println(\"Called from reason = $(reason)\")\n        if reason != GLPK.GLP_IROWGEN\n            return\n        end\n        x_val = callback_value(cb_data, x)\n        y_val = callback_value(cb_data, y)\n        if y_val - x_val > 1 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        elseif y_val + x_val > 3 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        end\n    end\n    set_attribute(model, GLPK.CallbackFunction(), my_callback_function)\n    optimize!(model)\n    Test.@test is_solved_and_feasible(model)\n    Test.@test lazy_called\n    Test.@test value(x) == 1\n    Test.@test value(y) == 2\n    return\nend\n\nexample_solver_dependent_callback()","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/nlp/#Nonlinear-Modeling-(Legacy)","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"warning: Warning\nThis page describes the legacy nonlinear interface to JuMP. It has a number of quirks and limitations that prompted the development of a new nonlinear interface. The new interface is documented at Nonlinear Modeling. This legacy interface will remain for all future v1.X releases of JuMP. The two nonlinear interfaces cannot be combined.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"JuMP has support for general smooth nonlinear (convex and nonconvex) optimization problems. JuMP is able to provide exact, sparse second-order derivatives to solvers. This information can improve solver accuracy and performance.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"There are three main changes to solve nonlinear programs in JuMP.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Use @NLobjective instead of @objective\nUse @NLconstraint instead of @constraint\nUse @NLexpression instead of @expression","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"info: Info\nThere are some restrictions on what syntax you can use in the @NLxxx macros. Make sure to read the Syntax notes.","category":"page"},{"location":"manual/nlp/#Set-a-nonlinear-objective","page":"Nonlinear Modeling (Legacy)","title":"Set a nonlinear objective","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Use @NLobjective to set a nonlinear objective.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @NLobjective(model, Min, exp(x[1]) - sqrt(x[2]))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"To modify a nonlinear objective, call @NLobjective again.","category":"page"},{"location":"manual/nlp/#Add-a-nonlinear-constraint","page":"Nonlinear Modeling (Legacy)","title":"Add a nonlinear constraint","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Use @NLconstraint to add a nonlinear constraint.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @NLconstraint(model, exp(x[1]) <= 1)\nexp(x[1]) - 1.0 ≤ 0\n\njulia> @NLconstraint(model, [i = 1:2], x[i]^i >= i)\n2-element Vector{NonlinearConstraintRef{ScalarShape}}:\n x[1] ^ 1.0 - 1.0 ≥ 0\n x[2] ^ 2.0 - 2.0 ≥ 0\n\njulia> @NLconstraint(model, con[i = 1:2], prod(x[j] for j = 1:i) == i)\n2-element Vector{NonlinearConstraintRef{ScalarShape}}:\n (*)(x[1]) - 1.0 = 0\n x[1] * x[2] - 2.0 = 0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"info: Info\nYou can only create nonlinear constraints with <=, >=, and ==. More general Nonlinear-in-Set constraints are not supported.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Delete a nonlinear constraint using delete:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> delete(model, con[1])","category":"page"},{"location":"manual/nlp/#Create-a-nonlinear-expression","page":"Nonlinear Modeling (Legacy)","title":"Create a nonlinear expression","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Use @NLexpression to create nonlinear expression objects. The syntax is identical to @expression, except that the expression can contain nonlinear terms.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> expr = @NLexpression(model, exp(x[1]) + sqrt(x[2]))\nsubexpression[1]: exp(x[1]) + sqrt(x[2])\n\njulia> my_anon_expr = @NLexpression(model, [i = 1:2], sin(x[i]))\n2-element Vector{NonlinearExpression}:\n subexpression[2]: sin(x[1])\n subexpression[3]: sin(x[2])\n\njulia> @NLexpression(model, my_expr[i = 1:2], sin(x[i]))\n2-element Vector{NonlinearExpression}:\n subexpression[4]: sin(x[1])\n subexpression[5]: sin(x[2])","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Nonlinear expression can be used in @NLobjective, @NLconstraint, and even nested in other @NLexpressions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> @NLobjective(model, Min, expr^2 + 1)\n\njulia> @NLconstraint(model, [i = 1:2], my_expr[i] <= i)\n2-element Vector{NonlinearConstraintRef{ScalarShape}}:\n subexpression[4] - 1.0 ≤ 0\n subexpression[5] - 2.0 ≤ 0\n\njulia> @NLexpression(model, nested[i = 1:2], sin(my_expr[i]))\n2-element Vector{NonlinearExpression}:\n subexpression[6]: sin(subexpression[4])\n subexpression[7]: sin(subexpression[5])","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Use value to query the value of a nonlinear expression:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> set_start_value(x[1], 1.0)\n\njulia> value(start_value, nested[1])\n0.7456241416655579\n\njulia> sin(sin(1.0))\n0.7456241416655579","category":"page"},{"location":"manual/nlp/#Create-a-nonlinear-parameter","page":"Nonlinear Modeling (Legacy)","title":"Create a nonlinear parameter","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"For nonlinear models only, JuMP offers a syntax for explicit \"parameter\" objects, which are constants in the model that can be efficiently updated between solves.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Nonlinear parameters are declared by using the @NLparameter macro and may be indexed by arbitrary sets analogously to JuMP variables and expressions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"The initial value of the parameter must be provided on the right-hand side of the == sign.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @NLparameter(model, p[i = 1:2] == i)\n2-element Vector{NonlinearParameter}:\n parameter[1] == 1.0\n parameter[2] == 2.0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Create anonymous parameters using the value keyword:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> anon_parameter = @NLparameter(model, value = 1)\nparameter[3] == 1.0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"info: Info\nA parameter is not an optimization variable. It must be fixed to a value with ==. If you want a parameter that is <= or >=, create a variable instead using @variable.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Use value and set_value to query or update the value of a parameter.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> value.(p)\n2-element Vector{Float64}:\n 1.0\n 2.0\n\njulia> set_value(p[2], 3.0)\n3.0\n\njulia> value.(p)\n2-element Vector{Float64}:\n 1.0\n 3.0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Nonlinear parameters must be used within nonlinear macros only.","category":"page"},{"location":"manual/nlp/#When-to-use-a-parameter","page":"Nonlinear Modeling (Legacy)","title":"When to use a parameter","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Nonlinear parameters are useful when solving nonlinear models in a sequence:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"using JuMP, Ipopt\nmodel = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, z)\n@NLparameter(model, x == 1.0)\n@NLobjective(model, Min, (z - x)^2)\noptimize!(model)\n@show value(z) # Equals 1.0.\n\n# Now, update the value of x to solve a different problem.\nset_value(x, 5.0)\noptimize!(model)\n@show value(z) # Equals 5.0\nnothing #hide","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"info: Info\nUsing nonlinear parameters can be faster than creating a new model from scratch with updated data because JuMP is able to avoid repeating a number of steps in processing the model before handing it off to the solver.","category":"page"},{"location":"manual/nlp/#Syntax-notes","page":"Nonlinear Modeling (Legacy)","title":"Syntax notes","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"The syntax accepted in nonlinear macros is more restricted than the syntax for linear and quadratic macros. We note some important points below.","category":"page"},{"location":"manual/nlp/#Scalar-operations-only","page":"Nonlinear Modeling (Legacy)","title":"Scalar operations only","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Except for the splatting syntax discussed below, all expressions must be simple scalar operations. You cannot use dot, matrix-vector products, vector slices, etc.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @variable(model, y);\n\njulia> c = [1, 2];\n\njulia> @NLobjective(model, Min, c' * x + 3y)\nERROR: Unexpected array [1 2] in nonlinear expression. Nonlinear expressions may contain only scalar expressions.\n[...]","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Translate vector operations into explicit sum() operations:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> @NLobjective(model, Min, sum(c[i] * x[i] for i = 1:2) + 3y)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Or use an @expression:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> @expression(model, expr, c' * x)\nx[1] + 2 x[2]\n\njulia> @NLobjective(model, Min, expr + 3y)\n","category":"page"},{"location":"manual/nlp/#Splatting","page":"Nonlinear Modeling (Legacy)","title":"Splatting","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"The splatting operator   ... is recognized in a very restricted setting for expanding function   arguments. The expression splatted can be only a symbol. More complex   expressions are not recognized.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> model = Model();\n\njulia> @variable(model, x[1:3]);\n\njulia> @NLconstraint(model, *(x...) <= 1.0)\nx[1] * x[2] * x[3] - 1.0 ≤ 0\n\njulia> @NLconstraint(model, *((x / 2)...) <= 0.0)\nERROR: Unsupported use of the splatting operator. JuMP supports splatting only symbols. For example, `x...` is ok, but `(x + 1)...`, `[x; y]...` and `g(f(y)...)` are not.","category":"page"},{"location":"manual/nlp/#User-defined-Functions","page":"Nonlinear Modeling (Legacy)","title":"User-defined Functions","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"JuMP natively supports the set of univariate and multivariate functions recognized by the MOI.Nonlinear submodule. In addition to this list of functions, it is possible to register custom user-defined nonlinear functions. User-defined functions can be used anywhere in @NLobjective, @NLconstraint, and @NLexpression.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"JuMP will attempt to automatically register functions it detects in your nonlinear expressions, which usually means manually registering a function is not needed. Two exceptions are if you want to provide custom derivatives, or if the function is not available in the scope of the nonlinear expression.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"warning: Warning\nUser-defined functions must return a scalar output. For a work-around, see User-defined operators with vector outputs.","category":"page"},{"location":"manual/nlp/#Automatic-differentiation","page":"Nonlinear Modeling (Legacy)","title":"Automatic differentiation","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"JuMP does not support black-box optimization, so all user-defined functions must provide derivatives in some form. Fortunately, JuMP supports automatic differentiation of user-defined functions, a feature to our knowledge not available in any comparable modeling systems.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"info: Info\nAutomatic differentiation is not finite differencing. JuMP's automatically computed derivatives are not subject to approximation error.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"JuMP uses ForwardDiff.jl to perform automatic differentiation; see the ForwardDiff.jl documentation for a description of how to write a function suitable for automatic differentiation.","category":"page"},{"location":"manual/nlp/#Common-mistakes-when-writing-a-user-defined-function","page":"Nonlinear Modeling (Legacy)","title":"Common mistakes when writing a user-defined function","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"warning: Warning\nGet an error like No method matching Float64(::ForwardDiff.Dual)? Read this section, and see the guidelines at ForwardDiff.jl.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"The most common error is that your user-defined function is not generic with respect to the number type, that is, don't assume that the input to the function is Float64.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"f(x::Float64) = 2 * x  # This will not work.\nf(x::Real)    = 2 * x  # This is good.\nf(x)          = 2 * x  # This is also good.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Another reason you may encounter this error is if you create arrays inside your function which are Float64.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"function bad_f(x...)\n    y = zeros(length(x))  # This constructs an array of `Float64`!\n    for i = 1:length(x)\n        y[i] = x[i]^i\n    end\n    return sum(y)\nend\n\nfunction good_f(x::T...) where {T<:Real}\n    y = zeros(T, length(x))  # Construct an array of type `T` instead!\n    for i = 1:length(x)\n        y[i] = x[i]^i\n    end\n    return sum(y)\nend","category":"page"},{"location":"manual/nlp/#Register-a-function","page":"Nonlinear Modeling (Legacy)","title":"Register a function","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"To register a user-defined function with derivatives computed by automatic differentiation, use the register method as in the following example:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"using JuMP #hide\nsquare(x) = x^2\nf(x, y) = (x - 1)^2 + (y - 2)^2\n\nmodel = Model()\n\nregister(model, :square, 1, square; autodiff = true)\nregister(model, :my_f, 2, f; autodiff = true)\n\n@variable(model, x[1:2] >= 0.5)\n@NLobjective(model, Min, my_f(x[1], square(x[2])))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"The above code creates a JuMP model with the objective function (x[1] - 1)^2 + (x[2]^2 - 2)^2. The arguments to register are:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"The model for which the functions are registered.\nA Julia symbol object which serves as the name of the user-defined function in JuMP expressions.\nThe number of input arguments that the function takes.\nThe Julia method which computes the function\nA flag to instruct JuMP to compute exact gradients automatically.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"tip: Tip\nThe symbol :my_f doesn't have to match the name of the function f. However, it's more readable if it does. Make sure you use my_f and not f in the macros.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"warning: Warning\nUser-defined functions cannot be re-registered and will not update if you modify the underlying Julia function. If you want to change a user-defined function between solves, rebuild the model or use a different name. To use a different name programmatically, see Raw expression input.","category":"page"},{"location":"manual/nlp/#Register-a-function-and-gradient","page":"Nonlinear Modeling (Legacy)","title":"Register a function and gradient","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Forward-mode automatic differentiation as implemented by ForwardDiff.jl has a computational cost that scales linearly with the number of input dimensions. As such, it is not the most efficient way to compute gradients of user-defined functions if the number of input arguments is large. In this case, users may want to provide their own routines for evaluating gradients.","category":"page"},{"location":"manual/nlp/#Univariate-functions","page":"Nonlinear Modeling (Legacy)","title":"Univariate functions","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"For univariate functions, the gradient function ∇f returns a number that represents the first-order derivative:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"using JuMP #hide\nf(x) = x^2\n∇f(x) = 2x\nmodel = Model()\nregister(model, :my_square, 1, f, ∇f; autodiff = true)\n@variable(model, x >= 0)\n@NLobjective(model, Min, my_square(x))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"If autodiff = true, JuMP will use automatic differentiation to compute the hessian.","category":"page"},{"location":"manual/nlp/#Multivariate-functions","page":"Nonlinear Modeling (Legacy)","title":"Multivariate functions","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"For multivariate functions, the gradient function ∇f must take a gradient vector as the first argument that is filled in-place:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"using JuMP #hide\nf(x, y) = (x - 1)^2 + (y - 2)^2\nfunction ∇f(g::AbstractVector{T}, x::T, y::T) where {T}\n    g[1] = 2 * (x - 1)\n    g[2] = 2 * (y - 2)\n    return\nend\n\nmodel = Model()\nregister(model, :my_square, 2, f, ∇f)\n@variable(model, x[1:2] >= 0)\n@NLobjective(model, Min, my_square(x[1], x[2]))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"warning: Warning\nMake sure the first argument to ∇f supports an AbstractVector, and do not assume the input is Float64.","category":"page"},{"location":"manual/nlp/#Register-a-function,-gradient,-and-hessian","page":"Nonlinear Modeling (Legacy)","title":"Register a function, gradient, and hessian","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"You can also register a function with the second-order derivative information, which is a scalar for univariate functions, and a symmetric matrix for multivariate functions.","category":"page"},{"location":"manual/nlp/#Univariate-functions-2","page":"Nonlinear Modeling (Legacy)","title":"Univariate functions","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Pass a function which returns a number representing the second-order derivative:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"using JuMP #hide\nf(x) = x^2\n∇f(x) = 2x\n∇²f(x) = 2\nmodel = Model()\nregister(model, :my_square, 1, f, ∇f, ∇²f)\n@variable(model, x >= 0)\n@NLobjective(model, Min, my_square(x))","category":"page"},{"location":"manual/nlp/#Multivariate-functions-2","page":"Nonlinear Modeling (Legacy)","title":"Multivariate functions","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"For multivariate functions, the hessian function ∇²f must take an AbstractMatrix as the first argument, the lower-triangular of which is filled in-place:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"using JuMP #hide\nf(x...) = (1 - x[1])^2 + 100 * (x[2] - x[1]^2)^2\nfunction ∇f(g, x...)\n    g[1] = 400 * x[1]^3 - 400 * x[1] * x[2] + 2 * x[1] - 2\n    g[2] = 200 * (x[2] - x[1]^2)\n    return\nend\nfunction ∇²f(H, x...)\n    H[1, 1] = 1200 * x[1]^2 - 400 * x[2] + 2\n    # H[1, 2] = -400 * x[1]  <-- Not needed. Fill the lower-triangular only.\n    H[2, 1] = -400 * x[1]\n    H[2, 2] = 200.0\n    return\nend\n\nmodel = Model()\nregister(model, :rosenbrock, 2, f, ∇f, ∇²f)\n@variable(model, x[1:2])\n@NLobjective(model, Min, rosenbrock(x[1], x[2]))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"warning: Warning\nYou may assume the Hessian matrix H is initialized with zeros, and because H is symmetric, you need only to fill in the non-zero of the lower-triangular terms. The matrix type passed in as H depends on the automatic differentiation system, so make sure the first argument to the Hessian function supports an AbstractMatrix (it may be something other than Matrix{Float64}). However, you may assume only that H supports size(H) and setindex!. Finally, the matrix is treated as dense, so the performance will be poor on functions with high-dimensional input.","category":"page"},{"location":"manual/nlp/#User-defined-functions-with-vector-inputs","page":"Nonlinear Modeling (Legacy)","title":"User-defined functions with vector inputs","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"User-defined functions which take vectors as input arguments (for example, f(x::Vector)) are not supported. Instead, use Julia's splatting syntax to create a function with scalar arguments. For example, instead of","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"f(x::Vector) = sum(x[i]^i for i in 1:length(x))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"define:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"f(x...) = sum(x[i]^i for i in 1:length(x))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"This function f can be used in a JuMP model as follows:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"using JuMP #hide\nmodel = Model()\n@variable(model, x[1:5] >= 0)\nf(x...) = sum(x[i]^i for i in 1:length(x))\nregister(model, :f, 5, f; autodiff = true)\n@NLobjective(model, Min, f(x...))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"tip: Tip\nMake sure to read the syntax restrictions of Splatting.","category":"page"},{"location":"manual/nlp/#Factors-affecting-solution-time","page":"Nonlinear Modeling (Legacy)","title":"Factors affecting solution time","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"The execution time when solving a nonlinear programming problem can be divided into two parts, the time spent in the optimization algorithm (the solver) and the time spent evaluating the nonlinear functions and corresponding derivatives. Ipopt explicitly displays these two timings in its output, for example:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Total CPU secs in IPOPT (w/o function evaluations)   =      7.412\nTotal CPU secs in NLP function evaluations           =      2.083","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"For Ipopt in particular, one can improve the performance by installing advanced sparse linear algebra packages, see Installation Guide. For other solvers, see their respective documentation for performance tips.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"The function evaluation time, on the other hand, is the responsibility of the modeling language. JuMP computes derivatives by using reverse-mode automatic differentiation with graph coloring methods for exploiting sparsity of the Hessian matrix. As a conservative bound, JuMP's performance here currently may be expected to be within a factor of 5 of AMPL's. Our paper in SIAM Review has more details.","category":"page"},{"location":"manual/nlp/#Querying-derivatives-from-a-JuMP-model","page":"Nonlinear Modeling (Legacy)","title":"Querying derivatives from a JuMP model","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"For some advanced use cases, one may want to directly query the derivatives of a JuMP model instead of handing the problem off to a solver. Internally, JuMP implements the MOI.AbstractNLPEvaluator interface. To obtain an NLP evaluator object from a JuMP model, use NLPEvaluator. index returns the MOI.VariableIndex corresponding to a JuMP variable. MOI.VariableIndex itself is a type-safe wrapper for Int64 (stored in the .value field.)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"For example:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> raw_index(v::MOI.VariableIndex) = v.value\nraw_index (generic function with 1 method)\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @NLobjective(model, Min, sin(x) + sin(y))\n\njulia> values = zeros(2)\n2-element Vector{Float64}:\n 0.0\n 0.0\n\njulia> x_index = raw_index(JuMP.index(x))\n1\n\njulia> y_index = raw_index(JuMP.index(y))\n2\n\njulia> values[x_index] = 2.0\n2.0\n\njulia> values[y_index] = 3.0\n3.0\n\njulia> d = NLPEvaluator(model)\nNonlinear.Evaluator with available features:\n  * :Grad\n  * :Jac\n  * :JacVec\n  * :Hess\n  * :HessVec\n  * :ExprGraph\n\njulia> MOI.initialize(d, [:Grad])\n\njulia> MOI.eval_objective(d, values)\n1.0504174348855488\n\njulia> sin(2.0) + sin(3.0)\n1.0504174348855488\n\njulia> ∇f = zeros(2)\n2-element Vector{Float64}:\n 0.0\n 0.0\n\njulia> MOI.eval_objective_gradient(d, ∇f, values)\n\njulia> ∇f[x_index], ∇f[y_index]\n(-0.4161468365471424, -0.9899924966004454)\n\njulia> cos(2.0), cos(3.0)\n(-0.4161468365471424, -0.9899924966004454)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Only nonlinear constraints (those added with @NLconstraint), and nonlinear objectives (added with @NLobjective) exist in the scope of the NLPEvaluator.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"The NLPEvaluator does not evaluate derivatives of linear or quadratic constraints or objectives.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"The index method applied to a nonlinear constraint reference object returns its index as a MOI.Nonlinear.ConstraintIndex. For example:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @NLconstraint(model, cons1, sin(x) <= 1);\n\njulia> @NLconstraint(model, cons2, x + 5 == 10);\n\njulia> typeof(cons1)\nNonlinearConstraintRef{ScalarShape} (alias for ConstraintRef{GenericModel{Float64}, MathOptInterface.Nonlinear.ConstraintIndex, ScalarShape})\n\njulia> index(cons1)\nMathOptInterface.Nonlinear.ConstraintIndex(1)\n\njulia> index(cons2)\nMathOptInterface.Nonlinear.ConstraintIndex(2)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"# TODO: Provide a link for how to access the linear and quadratic parts of the\n# model.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Note that for one-sided nonlinear constraints, JuMP subtracts any values on the right-hand side when computing expressions. In other words, one-sided nonlinear constraints are always transformed to have a right-hand side of zero.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"This method of querying derivatives directly from a JuMP model is convenient for interacting with the model in a structured way, for example, for accessing derivatives of specific variables. For example, in statistical maximum likelihood estimation problems, one is often interested in the Hessian matrix at the optimal solution, which can be queried using the NLPEvaluator.","category":"page"},{"location":"manual/nlp/#Raw-expression-input","page":"Nonlinear Modeling (Legacy)","title":"Raw expression input","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"warning: Warning\nThis section requires advanced knowledge of Julia's Expr. You should read the Expressions and evaluation section of the Julia documentation first.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"In addition to the @NLexpression, @NLobjective and @NLconstraint macros, it is also possible to provide Julia Expr objects directly by using add_nonlinear_expression, set_nonlinear_objective and add_nonlinear_constraint.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"This input form may be useful if the expressions are generated programmatically, or if you experience compilation issues with the macro input (see Known performance issues for more information).","category":"page"},{"location":"manual/nlp/#Add-a-nonlinear-expression","page":"Nonlinear Modeling (Legacy)","title":"Add a nonlinear expression","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Use add_nonlinear_expression to add a nonlinear expression to the model.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> expr = :($(x) + sin($(x)^2))\n:(x + sin(x ^ 2))\n\njulia> expr_ref = add_nonlinear_expression(model, expr)\nsubexpression[1]: x + sin(x ^ 2.0)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"This is equivalent to","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> expr_ref = @NLexpression(model, x + sin(x^2))\nsubexpression[1]: x + sin(x ^ 2.0)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"note: Note\nYou must interpolate the variables directly into the expression expr.","category":"page"},{"location":"manual/nlp/#Set-the-objective-function","page":"Nonlinear Modeling (Legacy)","title":"Set the objective function","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Use set_nonlinear_objective to set a nonlinear objective.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> expr = :($(x) + $(x)^2)\n:(x + x ^ 2)\n\njulia> set_nonlinear_objective(model, MIN_SENSE, expr)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"This is equivalent to","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @NLobjective(model, Min, x + x^2)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"note: Note\nYou must use MIN_SENSE or MAX_SENSE instead of Min and Max.","category":"page"},{"location":"manual/nlp/#Add-a-constraint","page":"Nonlinear Modeling (Legacy)","title":"Add a constraint","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Use add_nonlinear_constraint to add a nonlinear constraint.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> expr = :($(x) + $(x)^2)\n:(x + x ^ 2)\n\njulia> add_nonlinear_constraint(model, :($(expr) <= 1))\n(x + x ^ 2.0) - 1.0 ≤ 0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"This is equivalent to","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @NLconstraint(model, Min, x + x^2 <= 1)\n(x + x ^ 2.0) - 1.0 ≤ 0","category":"page"},{"location":"manual/nlp/#More-complicated-examples","page":"Nonlinear Modeling (Legacy)","title":"More complicated examples","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"Raw expression input is most useful when the expressions are generated programmatically, often in conjunction with user-defined functions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"As an example, we construct a model with the nonlinear constraints f(x) <= 1, where f(x) = x^2 and f(x) = sin(x)^2:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> function main(functions::Vector{Function})\n           model = Model()\n           @variable(model, x)\n           for (i, f) in enumerate(functions)\n               f_sym = Symbol(\"f_$(i)\")\n               register(model, f_sym, 1, f; autodiff = true)\n               add_nonlinear_constraint(model, :($(f_sym)($(x)) <= 1))\n           end\n           print(model)\n           return\n       end\nmain (generic function with 1 method)\n\njulia> main([x -> x^2, x -> sin(x)^2])\nFeasibility\nSubject to\n f_1(x) - 1.0 ≤ 0\n f_2(x) - 1.0 ≤ 0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"As another example, we construct a model with the constraint x^2 + sin(x)^2 <= 1:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> function main(functions::Vector{Function})\n           model = Model()\n           @variable(model, x)\n           expr = Expr(:call, :+)\n           for (i, f) in enumerate(functions)\n               f_sym = Symbol(\"f_$(i)\")\n               register(model, f_sym, 1, f; autodiff = true)\n               push!(expr.args, :($(f_sym)($(x))))\n           end\n           add_nonlinear_constraint(model, :($(expr) <= 1))\n           print(model)\n           return\n       end\nmain (generic function with 1 method)\n\njulia> main([x -> x^2, x -> sin(x)^2])\nFeasibility\nSubject to\n (f_1(x) + f_2(x)) - 1.0 ≤ 0","category":"page"},{"location":"manual/nlp/#Registered-functions-with-a-variable-number-of-arguments","page":"Nonlinear Modeling (Legacy)","title":"Registered functions with a variable number of arguments","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"User defined functions require a fixed number of input arguments. However, sometimes you will want to use a registered function like:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> f(x...) = sum(exp(x[i]^2) for i in 1:length(x));","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"with different numbers of arguments.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"The solution is to register the same function f for each unique number of input arguments, making sure to use a unique name each time. For example:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"julia> A = [[1], [1, 2], [2, 3, 4], [1, 3, 4, 5]];\n\njulia> model = Model();\n\njulia> @variable(model, x[1:5]);\n\njulia> funcs = Set{Symbol}();\n\njulia> for a in A\n           key = Symbol(\"f$(length(a))\")\n           if !(key in funcs)\n               push!(funcs, key)\n               register(model, key, length(a), f; autodiff = true)\n           end\n           add_nonlinear_constraint(model, :($key($(x[a]...)) <= 1))\n       end\n\njulia> print(model)\nFeasibility\nSubject to\n f1(x[1]) - 1.0 ≤ 0\n f2(x[1], x[2]) - 1.0 ≤ 0\n f3(x[2], x[3], x[4]) - 1.0 ≤ 0\n f4(x[1], x[3], x[4], x[5]) - 1.0 ≤ 0","category":"page"},{"location":"manual/nlp/#Known-performance-issues","page":"Nonlinear Modeling (Legacy)","title":"Known performance issues","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"The macro-based input to JuMP's nonlinear interface can cause a performance issue if you:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"write a macro with a large number (hundreds) of terms\ncall that macro from within a function instead of from the top-level in global scope.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"The first issue does not depend on the number of resulting terms in the mathematical expression, but rather the number of terms in the Julia Expr representation of that expression. For example, the expression sum(x[i] for i in 1:1_000_000) contains one million mathematical terms, but the Expr representation is just a single sum.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"The most common cause, other than a lot of tedious typing, is if you write a program that automatically writes a JuMP model as a text file, which you later execute. One example is MINLPlib.jl which automatically transpiled models in the GAMS scalar format into JuMP examples.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling (Legacy)","title":"Nonlinear Modeling (Legacy)","text":"As a rule of thumb, if you are writing programs to automatically generate expressions for the JuMP macros, you should target the Raw expression input instead. For more information, read MathOptInterface Issue#1997.","category":"page"},{"location":"packages/Dualization/","page":"jump-dev/Dualization.jl","title":"jump-dev/Dualization.jl","text":"EditURL = \"https://github.com/jump-dev/Dualization.jl/blob/v0.5.8/README.md\"","category":"page"},{"location":"packages/Dualization/#Dualization.jl","page":"jump-dev/Dualization.jl","title":"Dualization.jl","text":"","category":"section"},{"location":"packages/Dualization/","page":"jump-dev/Dualization.jl","title":"jump-dev/Dualization.jl","text":"(Image: Build Status) (Image: codecov) (Image: DOI)","category":"page"},{"location":"packages/Dualization/","page":"jump-dev/Dualization.jl","title":"jump-dev/Dualization.jl","text":"Dualization.jl is an extension package for MathOptInterface.jl that formulates the dual of conic optimization problems.","category":"page"},{"location":"packages/Dualization/","page":"jump-dev/Dualization.jl","title":"jump-dev/Dualization.jl","text":"Dualization.jl has two main features:","category":"page"},{"location":"packages/Dualization/","page":"jump-dev/Dualization.jl","title":"jump-dev/Dualization.jl","text":"The Dualization.dualize function that computes the dual formulation of either a MathOptInterface.jl or a JuMP model.\nThe Dualization.dual_optimizer function that creates a MathOptInterface-compatible optimizer that solves the dual of the problem instead of the primal.","category":"page"},{"location":"packages/Dualization/#License","page":"jump-dev/Dualization.jl","title":"License","text":"","category":"section"},{"location":"packages/Dualization/","page":"jump-dev/Dualization.jl","title":"jump-dev/Dualization.jl","text":"Dualization.jl is licensed under the MIT License.","category":"page"},{"location":"packages/Dualization/#Installation","page":"jump-dev/Dualization.jl","title":"Installation","text":"","category":"section"},{"location":"packages/Dualization/","page":"jump-dev/Dualization.jl","title":"jump-dev/Dualization.jl","text":"Install Dualization using Pkg.add:","category":"page"},{"location":"packages/Dualization/","page":"jump-dev/Dualization.jl","title":"jump-dev/Dualization.jl","text":"import Pkg\nPkg.add(\"Dualization\")","category":"page"},{"location":"packages/Dualization/#Use-with-JuMP","page":"jump-dev/Dualization.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/Dualization/","page":"jump-dev/Dualization.jl","title":"jump-dev/Dualization.jl","text":"To compute the dual formulation of a JuMP model, use dualize:","category":"page"},{"location":"packages/Dualization/","page":"jump-dev/Dualization.jl","title":"jump-dev/Dualization.jl","text":"using JuMP, Dualization\nmodel = Model()\n# ... build model ...\ndual_model = dualize(model)","category":"page"},{"location":"packages/Dualization/","page":"jump-dev/Dualization.jl","title":"jump-dev/Dualization.jl","text":"To solve the dual formulation of a JuMP model, create a dual_optimizer:","category":"page"},{"location":"packages/Dualization/","page":"jump-dev/Dualization.jl","title":"jump-dev/Dualization.jl","text":"using JuMP, Dualization, SCS\nmodel = Model(dual_optimizer(SCS.Optimizer))\n# ... build model ...\noptimize!(model)  # Solves the dual instead of the primal","category":"page"},{"location":"packages/Dualization/#Documentation","page":"jump-dev/Dualization.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/Dualization/","page":"jump-dev/Dualization.jl","title":"jump-dev/Dualization.jl","text":"The documentation for Dualization.jl includes a detailed description of the dual reformulation, along with examples and an API reference.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/manual/constraints.md\"","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"moi/manual/constraints/#Add-a-constraint","page":"Constraints","title":"Add a constraint","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Use add_constraint to add a single constraint.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> c = MOI.add_constraint(model, MOI.VectorOfVariables(x), MOI.Nonnegatives(2))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.Nonnegatives}(1)","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"add_constraint returns a ConstraintIndex type, which is used to refer to the added constraint in other calls.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Check if a ConstraintIndex is valid using is_valid.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> MOI.is_valid(model, c)\ntrue","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Use add_constraints to add a number of constraints of the same type.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> c = MOI.add_constraints(\n           model,\n           [x[1], x[2]],\n           [MOI.GreaterThan(0.0), MOI.GreaterThan(1.0)]\n       )\n2-element Vector{MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64}}}:\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64}}(1)\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64}}(2)","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"This time, a vector of ConstraintIndex are returned.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Use supports_constraint to check if the model supports adding a constraint type.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> MOI.supports_constraint(\n           model,\n           MOI.VariableIndex,\n           MOI.GreaterThan{Float64},\n       )\ntrue","category":"page"},{"location":"moi/manual/constraints/#Delete-a-constraint","page":"Constraints","title":"Delete a constraint","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Use delete to delete a constraint.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> MOI.delete(model, c)\n\njulia> MOI.is_valid(model, c)\nfalse","category":"page"},{"location":"moi/manual/constraints/#Constraint-attributes","page":"Constraints","title":"Constraint attributes","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"The following attributes are available for constraints:","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"ConstraintName\nConstraintPrimalStart\nConstraintDualStart\nConstraintPrimal\nConstraintDual\nConstraintBasisStatus\nConstraintFunction\nCanonicalConstraintFunction\nConstraintSet","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Get and set these attributes using get and set.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> MOI.set(model, MOI.ConstraintName(), c, \"con_c\")\n\njulia> MOI.get(model, MOI.ConstraintName(), c)\n\"con_c\"","category":"page"},{"location":"moi/manual/constraints/#Constraints-by-function-set-pairs","page":"Constraints","title":"Constraints by function-set pairs","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Below is a list of common constraint types and how they are represented as function-set pairs in MOI. In the notation below, x is a vector of decision variables, x_i is a scalar decision variable, alpha beta are scalar constants, a b are constant vectors, A is a constant matrix and mathbbR_+ (resp. mathbbR_-) is the set of non-negative (resp. non-positive) real numbers.","category":"page"},{"location":"moi/manual/constraints/#Linear-constraints","page":"Constraints","title":"Linear constraints","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Mathematical Constraint MOI Function MOI Set\na^Tx le beta ScalarAffineFunction LessThan\na^Tx ge alpha ScalarAffineFunction GreaterThan\na^Tx = beta ScalarAffineFunction EqualTo\nalpha le a^Tx le beta ScalarAffineFunction Interval\nx_i le beta VariableIndex LessThan\nx_i ge alpha VariableIndex GreaterThan\nx_i = beta VariableIndex EqualTo\nalpha le x_i le beta VariableIndex Interval\nAx + b in mathbbR_+^n VectorAffineFunction Nonnegatives\nAx + b in mathbbR_-^n VectorAffineFunction Nonpositives\nAx + b = 0 VectorAffineFunction Zeros","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"By convention, solvers are not expected to support nonzero constant terms in the ScalarAffineFunctions the first four rows of the preceding table because they are redundant with the parameters of the sets. For example, encode 2x + 1 le 2 as 2x le 1.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Constraints with VariableIndex in LessThan, GreaterThan, EqualTo, or Interval sets have a natural interpretation as variable bounds. As such, it is typically not natural to impose multiple lower- or upper-bounds on the same variable, and the solver interfaces will throw respectively LowerBoundAlreadySet or UpperBoundAlreadySet.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Moreover, adding two VariableIndex constraints on the same variable with the same set is impossible because they share the same index as it is the index of the variable, see ConstraintIndex.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"It is natural, however, to impose upper- and lower-bounds separately as two different constraints on a single variable. The difference between imposing bounds by using a single Interval constraint and by using separate LessThan and GreaterThan constraints is that the latter will allow the solver to return separate dual multipliers for the two bounds, while the former will allow the solver to return only a single dual for the interval constraint.","category":"page"},{"location":"moi/manual/constraints/#Conic-constraints","page":"Constraints","title":"Conic constraints","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Mathematical Constraint MOI Function MOI Set\nlVert Ax + brVert_2 le c^Tx + d VectorAffineFunction SecondOrderCone\ny ge lVert x rVert_2 VectorOfVariables SecondOrderCone\n2yz ge lVert x rVert_2^2 yz ge 0 VectorOfVariables RotatedSecondOrderCone\n(a_1^Tx + b_1a_2^Tx + b_2a_3^Tx + b_3) in mathcalE VectorAffineFunction ExponentialCone\nA(x) in mathcalS_+ VectorAffineFunction PositiveSemidefiniteConeTriangle\nB(x) in mathcalS_+ VectorAffineFunction PositiveSemidefiniteConeSquare\nx in mathcalS_+ VectorOfVariables PositiveSemidefiniteConeTriangle\nx in mathcalS_+ VectorOfVariables PositiveSemidefiniteConeSquare","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"where mathcalE is the exponential cone (see ExponentialCone), mathcalS_+ is the set of positive semidefinite symmetric matrices, A is an affine map that outputs symmetric matrices and B is an affine map that outputs square matrices.","category":"page"},{"location":"moi/manual/constraints/#Quadratic-constraints","page":"Constraints","title":"Quadratic constraints","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Mathematical Constraint MOI Function MOI Set\nfrac12x^TQx + a^Tx + b ge 0 ScalarQuadraticFunction GreaterThan\nfrac12x^TQx + a^Tx + b le 0 ScalarQuadraticFunction LessThan\nfrac12x^TQx + a^Tx + b = 0 ScalarQuadraticFunction EqualTo\nBilinear matrix inequality VectorQuadraticFunction PositiveSemidefiniteCone...","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nFor more details on the internal format of the quadratic functions see ScalarQuadraticFunction or VectorQuadraticFunction.","category":"page"},{"location":"moi/manual/constraints/#Discrete-and-logical-constraints","page":"Constraints","title":"Discrete and logical constraints","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Mathematical Constraint MOI Function MOI Set\nx_i in mathbbZ VariableIndex Integer\nx_i in 01 VariableIndex ZeroOne\nx_i in 0 cup lu VariableIndex Semicontinuous\nx_i in 0 cup ll+1ldotsu-1u VariableIndex Semiinteger\nAt most one component of x can be nonzero VectorOfVariables SOS1\nAt most two components of x can be nonzero, and if so they must be adjacent components VectorOfVariables SOS2\ny = 1 implies a^T x in S VectorAffineFunction Indicator","category":"page"},{"location":"moi/manual/constraints/#JuMP-mapping","page":"Constraints","title":"JuMP mapping","text":"","category":"section"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"The following bullet points show examples of how JuMP constraints are translated into MOI function-set pairs:","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"@constraint(m, 2x + y <= 10) becomes ScalarAffineFunction-in-LessThan\n@constraint(m, 2x + y >= 10) becomes ScalarAffineFunction-in-GreaterThan\n@constraint(m, 2x + y == 10) becomes ScalarAffineFunction-in-EqualTo\n@constraint(m, 0 <= 2x + y <= 10) becomes ScalarAffineFunction-in-Interval\n@constraint(m, 2x + y in ArbitrarySet()) becomes ScalarAffineFunction-in-ArbitrarySet.","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"Variable bounds are handled in a similar fashion:","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"@variable(m, x <= 1) becomes VariableIndex-in-LessThan\n@variable(m, x >= 1) becomes VariableIndex-in-GreaterThan","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"One notable difference is that a variable with an upper and lower bound is translated into two constraints, rather than an interval, that is:","category":"page"},{"location":"moi/manual/constraints/","page":"Constraints","title":"Constraints","text":"@variable(m, 0 <= x <= 1) becomes VariableIndex-in-LessThan and  VariableIndex-in-GreaterThan.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"EditURL = \"sudoku.jl\"","category":"page"},{"location":"tutorials/linear/sudoku/#Sudoku","page":"Sudoku","title":"Sudoku","text":"","category":"section"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"This tutorial was originally contributed by Iain Dunning.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Sudoku is a popular number puzzle. The goal is to place the digits 1 to 9 on a nine-by-nine grid, with some of the digits already filled in. Your solution must satisfy the following rules:","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"The numbers 1 to 9 must appear in each 3x3 square\nThe numbers 1 to 9 must appear in each row\nThe numbers 1 to 9 must appear in each column","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Here is a partially solved Sudoku problem:","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"(Image: Partially solved Sudoku)","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Solving a Sudoku isn't an optimization problem with an objective; its actually a feasibility problem: we wish to find a feasible solution that satisfies these rules. You can think of it as an optimization problem with an objective of 0.","category":"page"},{"location":"tutorials/linear/sudoku/#Mixed-integer-linear-programming-formulation","page":"Sudoku","title":"Mixed-integer linear programming formulation","text":"","category":"section"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"We can model this problem using 0-1 integer programming: a problem where all the decision variables are binary. We'll use JuMP to create the model, and then we can solve it with any integer programming solver.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"using JuMP\nusing HiGHS","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"We will define a binary variable (a variable that is either 0 or 1) for each possible number in each possible cell. The meaning of each variable is as follows: x[i,j,k] = 1  if and only if cell (i,j) has number k, where i is the row and j is the column.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Create a model","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"sudoku = Model(HiGHS.Optimizer)\nset_silent(sudoku)","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Create our variables","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"@variable(sudoku, x[i = 1:9, j = 1:9, k = 1:9], Bin);\nnothing #hide","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Now we can begin to add our constraints. We'll actually start with something obvious to us as humans, but what we need to enforce: that there can be only one number per cell.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"for i in 1:9  # For each row\n    for j in 1:9  # and each column\n        # Sum across all the possible digits. One and only one of the digits\n        # can be in this cell, so the sum must be equal to one.\n        @constraint(sudoku, sum(x[i, j, k] for k in 1:9) == 1)\n    end\nend","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Next we'll add the constraints for the rows and the columns. These constraints are all very similar, so much so that we can actually add them at the same time.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"for ind in 1:9  # Each row, OR each column\n    for k in 1:9  # Each digit\n        # Sum across columns (j) - row constraint\n        @constraint(sudoku, sum(x[ind, j, k] for j in 1:9) == 1)\n        # Sum across rows (i) - column constraint\n        @constraint(sudoku, sum(x[i, ind, k] for i in 1:9) == 1)\n    end\nend","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Finally, we have the to enforce the constraint that each digit appears once in each of the nine 3x3 sub-grids. Our strategy will be to index over the top-left corners of each 3x3 square with for loops, then sum over the squares.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"for i in 1:3:7\n    for j in 1:3:7\n        for k in 1:9\n            # i is the top left row, j is the top left column.\n            # We'll sum from i to i+2, for example, i=4, r=4, 5, 6.\n            @constraint(\n                sudoku,\n                sum(x[r, c, k] for r in i:(i+2), c in j:(j+2)) == 1\n            )\n        end\n    end\nend","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"The final step is to add the initial solution as a set of constraints. We'll solve the problem that is in the picture at the start of the tutorial. We'll put a 0 if there is no digit in that location.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"The given digits","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"init_sol = [\n    5 3 0 0 7 0 0 0 0\n    6 0 0 1 9 5 0 0 0\n    0 9 8 0 0 0 0 6 0\n    8 0 0 0 6 0 0 0 3\n    4 0 0 8 0 3 0 0 1\n    7 0 0 0 2 0 0 0 6\n    0 6 0 0 0 0 2 8 0\n    0 0 0 4 1 9 0 0 5\n    0 0 0 0 8 0 0 7 9\n]\nfor i in 1:9\n    for j in 1:9\n        # If the space isn't empty\n        if init_sol[i, j] != 0\n            # Then the corresponding variable for that digit and location must\n            # be 1.\n            fix(x[i, j, init_sol[i, j]], 1; force = true)\n        end\n    end\nend","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"solve problem","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"optimize!(sudoku)\n@assert is_solved_and_feasible(sudoku)","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Extract the values of x","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"x_val = value.(x);\nnothing #hide","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Create a matrix to store the solution","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"sol = zeros(Int, 9, 9)  # 9x9 matrix of integers\nfor i in 1:9\n    for j in 1:9\n        for k in 1:9\n            # Integer programs are solved as a series of linear programs so the\n            # values might not be precisely 0 and 1. We can round them to\n            # the nearest integer to make it easier.\n            if round(Int, x_val[i, j, k]) == 1\n                sol[i, j] = k\n            end\n        end\n    end\nend","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Display the solution","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"sol","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Which is the correct solution:","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"(Image: Solved Sudoku)","category":"page"},{"location":"tutorials/linear/sudoku/#Constraint-programming-formulation","page":"Sudoku","title":"Constraint programming formulation","text":"","category":"section"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"We can also model this problem using constraint programming and the all-different constraint, which says that no two elements of a vector can take the same value.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Because of the reformulation system in MathOptInterface, we can still solve this problem using HiGHS.","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)\n# HiGHS v1.2 has a bug in presolve which causes the problem to be classified as\n# infeasible.\nset_attribute(model, \"presolve\", \"off\")","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Instead of the binary variables, we directly define a 9x9 grid of integer values between 1 and 9:","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"@variable(model, 1 <= x[1:9, 1:9] <= 9, Int);\nnothing #hide","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Then, we enforce that the values in each row must be all-different:","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"@constraint(model, [i = 1:9], x[i, :] in MOI.AllDifferent(9));\nnothing #hide","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"That the values in each column must be all-different:","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"@constraint(model, [j = 1:9], x[:, j] in MOI.AllDifferent(9));\nnothing #hide","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"And that the values in each 3x3 sub-grid must be all-different:","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"for i in (0, 3, 6), j in (0, 3, 6)\n    @constraint(model, vec(x[i.+(1:3), j.+(1:3)]) in MOI.AllDifferent(9))\nend","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Finally, as before we set the initial solution and optimize:","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"for i in 1:9, j in 1:9\n    if init_sol[i, j] != 0\n        fix(x[i, j], init_sol[i, j]; force = true)\n    end\nend\n\noptimize!(model)\n@assert is_solved_and_feasible(model)","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Display the solution","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"csp_sol = round.(Int, value.(x))","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"Which is the same as we found before:","category":"page"},{"location":"tutorials/linear/sudoku/","page":"Sudoku","title":"Sudoku","text":"sol == csp_sol","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"EditURL = \"performance_tips.jl\"","category":"page"},{"location":"tutorials/getting_started/performance_tips/#Performance-tips","page":"Performance tips","title":"Performance tips","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"By now you should have read the other \"getting started\" tutorials. You're almost ready to write your own models, but before you do so there are some important things to be aware of.","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"using JuMP\nimport HiGHS","category":"page"},{"location":"tutorials/getting_started/performance_tips/#Read-the-Julia-performance-tips","page":"Performance tips","title":"Read the Julia performance tips","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"The first thing to do is read the Performance tips section of the Julia manual. The most important rule is to avoid global variables. This is particularly important if you're learning JuMP after using a language like MATLAB.","category":"page"},{"location":"tutorials/getting_started/performance_tips/#The-\"time-to-first-solve\"-issue","page":"Performance tips","title":"The \"time-to-first-solve\" issue","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Similar to the infamous time-to-first-plot plotting problem, JuMP suffers from time-to-first-solve latency. This latency occurs because the first time you call JuMP code in each session, Julia needs to compile a lot of code specific to your problem. This issue is actively being worked on, but there are a few things you can do to improve things.","category":"page"},{"location":"tutorials/getting_started/performance_tips/#Suggestion-1:-don't-call-JuMP-from-the-command-line","page":"Performance tips","title":"Suggestion 1: don't call JuMP from the command line","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"In other languages, you might be used to a workflow like:","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"$ julia my_script.jl","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"This doesn't work for JuMP, because we have to pay the compilation latency every time you run the script. Instead, use one of the suggested workflows from the Julia documentation.","category":"page"},{"location":"tutorials/getting_started/performance_tips/#Suggestion-2:-disable-bridges-if-none-are-being-used","page":"Performance tips","title":"Suggestion 2: disable bridges if none are being used","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"At present, the majority of the latency problems are caused by JuMP's bridging mechanism. If you only use constraints that are natively supported by the solver, you can disable bridges by passing add_bridges = false to Model.","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"model = Model(HiGHS.Optimizer; add_bridges = false)","category":"page"},{"location":"tutorials/getting_started/performance_tips/#Suggestion-3:-use-PackageCompiler","page":"Performance tips","title":"Suggestion 3: use PackageCompiler","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"As an example of compilation latency, consider the following linear program with two variables and two constraints:","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"using JuMP, HiGHS\nmodel = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, x >= 0)\n@variable(model, 0 <= y <= 3)\n@objective(model, Min, 12x + 20y)\n@constraint(model, c1, 6x + 8y >= 100)\n@constraint(model, c2, 7x + 12y >= 120)\noptimize!(model)\nopen(\"model.log\", \"w\") do io\n    print(io, solution_summary(model; verbose = true))\n    return\nend","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Saving the problem in model.jl and calling from the command line results in:","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"$ time julia model.jl\n15.78s user 0.48s system 100% cpu 16.173 total","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Clearly, 16 seconds is a large overhead to pay for solving this trivial model. However, the compilation latency is independent on the problem size, and so 16 seconds of additional overhead may be tolerable for larger models that take minutes or hours to solve.","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"In cases where the compilation latency is intolerable, JuMP is compatible with the PackageCompiler.jl package, which makes it easy to generate a custom sysimage (a binary extension to Julia that caches compiled code) that dramatically reduces the compilation latency. A custom image for our problem can be created as follows:","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"using PackageCompiler, Libdl\nPackageCompiler.create_sysimage(\n    [\"JuMP\", \"HiGHS\"],\n    sysimage_path = \"customimage.\" * Libdl.dlext,\n    precompile_execution_file = \"model.jl\",\n)","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"When Julia is run with the custom image, the run time is now 0.7 seconds instead of 16:","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"$ time julia --sysimage customimage model.jl\n0.68s user 0.22s system 153% cpu 0.587 total","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Other performance tweaks, such as disabling bridges or using direct mode can reduce this time further.","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"note: Note\ncreate_sysimage only needs to be run once, and the same sysimage can be used–to a slight detriment of performance–even if we modify model.jl or run a different file.","category":"page"},{"location":"tutorials/getting_started/performance_tips/#Use-macros-to-build-expressions","page":"Performance tips","title":"Use macros to build expressions","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Use JuMP's macros (or add_to_expression!) to build expressions. Avoid constructing expressions outside the macros.","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Constructing an expression outside the macro results in intermediate copies of the expression. For example,","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"x[1] + x[2] + x[3]","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"is equivalent to","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"a = x[1]\nb = a + x[2]\nc = b + x[3]","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Since we only care about c, the a and b expressions are not needed and constructing them slows the program down.","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"JuMP's macros rewrite the expressions to operate in-place and avoid these extra copies. Because they allocate less memory, they are faster, particularly for large expressions.","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Here's an example.","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"model = Model()\n@variable(model, x[1:3])","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Here's what happens if we construct the expression outside the macro:","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"@allocated x[1] + x[2] + x[3]","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"info: Info\nThe @allocated measures how many bytes were allocated during the evaluation of an expression. Fewer is better.","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"If we use the @expression macro, we get many fewer allocations:","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"@allocated @expression(model, x[1] + x[2] + x[3])","category":"page"},{"location":"tutorials/getting_started/performance_tips/#Disable-string-names","page":"Performance tips","title":"Disable string names","text":"","category":"section"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"By default, JuMP creates String names for variables and constraints and passes these to the solver. The benefit of passing names is that it improves the readability of log messages from the solver (for example, \"variable x has invalid bounds\" instead of \"variable v1203 has invalid bounds\"), but for larger models the overhead of passing names can be non-trivial.","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Disable the creation of String names by setting set_string_name = false in the @variable and @constraint macros, or by calling set_string_names_on_creation to disable all names for a particular model:","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"model = Model();\nset_string_names_on_creation(model, false)\n@variable(model, x)\n@constraint(model, c, 2x <= 1)","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Note that this doesn't change how symbolic names and bindings are stored:","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"x\nmodel[:x]\nx === model[:x]","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"But you can no longer look up the variable by the string name:","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"variable_by_name(model, \"x\") === nothing","category":"page"},{"location":"tutorials/getting_started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"info: Info\nFor more information on the difference between string names, symbolic names, and bindings, see String names, symbolic names, and bindings.","category":"page"},{"location":"packages/ParametricOptInterface/","page":"jump-dev/ParametricOptInterface.jl","title":"jump-dev/ParametricOptInterface.jl","text":"EditURL = \"https://github.com/jump-dev/ParametricOptInterface.jl/blob/v0.7.0/README.md\"","category":"page"},{"location":"packages/ParametricOptInterface/#ParametricOptInterface.jl","page":"jump-dev/ParametricOptInterface.jl","title":"ParametricOptInterface.jl","text":"","category":"section"},{"location":"packages/ParametricOptInterface/","page":"jump-dev/ParametricOptInterface.jl","title":"jump-dev/ParametricOptInterface.jl","text":"(Image: stable docs) (Image: development docs) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"packages/ParametricOptInterface/","page":"jump-dev/ParametricOptInterface.jl","title":"jump-dev/ParametricOptInterface.jl","text":"ParametricOptInterface.jl is a package that adds parameters to models in JuMP and MathOptInterface.","category":"page"},{"location":"packages/ParametricOptInterface/#License","page":"jump-dev/ParametricOptInterface.jl","title":"License","text":"","category":"section"},{"location":"packages/ParametricOptInterface/","page":"jump-dev/ParametricOptInterface.jl","title":"jump-dev/ParametricOptInterface.jl","text":"ParametricOptInterface.jl is licensed under the MIT License.","category":"page"},{"location":"packages/ParametricOptInterface/#Installation","page":"jump-dev/ParametricOptInterface.jl","title":"Installation","text":"","category":"section"},{"location":"packages/ParametricOptInterface/","page":"jump-dev/ParametricOptInterface.jl","title":"jump-dev/ParametricOptInterface.jl","text":"Install ParametricOptInterface using Pkg.add:","category":"page"},{"location":"packages/ParametricOptInterface/","page":"jump-dev/ParametricOptInterface.jl","title":"jump-dev/ParametricOptInterface.jl","text":"import Pkg\nPkg.add(\"ParametricOptInterface\")","category":"page"},{"location":"packages/ParametricOptInterface/#Documentation","page":"jump-dev/ParametricOptInterface.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/ParametricOptInterface/","page":"jump-dev/ParametricOptInterface.jl","title":"jump-dev/ParametricOptInterface.jl","text":"The documentation for ParametricOptInterface.jl includes a detailed description of the theory behind the package, along with examples, tutorials, and an API reference.","category":"page"},{"location":"packages/ParametricOptInterface/#Use-with-JuMP","page":"jump-dev/ParametricOptInterface.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/ParametricOptInterface/","page":"jump-dev/ParametricOptInterface.jl","title":"jump-dev/ParametricOptInterface.jl","text":"Use ParametricOptInterface with JuMP by following this brief example:","category":"page"},{"location":"packages/ParametricOptInterface/","page":"jump-dev/ParametricOptInterface.jl","title":"jump-dev/ParametricOptInterface.jl","text":"using JuMP, HiGHS\nimport ParametricOptInterface as POI\nmodel = Model(() -> POI.Optimizer(HiGHS.Optimizer()))\n@variable(model, x)\n@variable(model, p in MOI.Parameter(1.0))\n@constraint(model, cons, x + p >= 3)\n@objective(model, Min, 2x)\noptimize!(model)\nMOI.set(model, POI.ParameterValue(), p, 2.0)\noptimize!(model)","category":"page"},{"location":"packages/ParametricOptInterface/#GSOC2020","page":"jump-dev/ParametricOptInterface.jl","title":"GSOC2020","text":"","category":"section"},{"location":"packages/ParametricOptInterface/","page":"jump-dev/ParametricOptInterface.jl","title":"jump-dev/ParametricOptInterface.jl","text":"ParametricOptInterface began as a NumFOCUS sponsored Google Summer of Code (2020) project.","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"EditURL = \"quantum_discrimination.jl\"","category":"page"},{"location":"tutorials/conic/quantum_discrimination/#Quantum-state-discrimination","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"","category":"section"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"This tutorial solves the problem of quantum state discrimination.","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"The purpose of this tutorial to demonstrate how to solve problems involving complex-valued decision variables and the HermitianPSDCone. See Complex number support for more details.","category":"page"},{"location":"tutorials/conic/quantum_discrimination/#Required-packages","page":"Quantum state discrimination","title":"Required packages","text":"","category":"section"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"This tutorial makes use of the following packages:","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"using JuMP\nimport LinearAlgebra\nimport SCS","category":"page"},{"location":"tutorials/conic/quantum_discrimination/#Formulation","page":"Quantum state discrimination","title":"Formulation","text":"","category":"section"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"A d-dimensional quantum state, rho, can be defined by a complex-valued Hermitian matrix with a trace of 1. Assume we have N d-dimensional quantum states, rho_i_i=1^N, each of which is equally likely.","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"The goal of the quantum state discrimination problem is to choose a positive operator-valued measure (POVM),  E_i _i=1^N, such that if we observe E_i then the most probable state that we are in is rho_i.","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"Each POVM element, E_i, is a complex-valued Hermitian matrix, and there is a requirement that sumlimits_i=1^N E_i = mathbfI.","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"To choose a POVM, we want to maximize the probability that we guess the quantum state correctly. This can be formulated as the following optimization problem:","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"beginaligned\nmaxlimits_E   frac1N sumlimits_i=1^N operatornametr(rho_i  E_i) \ntextst       sumlimits_i=1^N E_i = mathbfI \n                      E_i succeq 0  forall i = 1ldotsN\nendaligned","category":"page"},{"location":"tutorials/conic/quantum_discrimination/#Data","page":"Quantum state discrimination","title":"Data","text":"","category":"section"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"To setup our problem, we need N d-dimensional quantum states. To keep the problem simple, we use N = 2 and d = 2.","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"N, d = 2, 2","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"We then generated N random d-dimensional quantum states:","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"function random_state(d)\n    x = randn(ComplexF64, (d, d))\n    y = x * x'\n    return LinearAlgebra.Hermitian(y / LinearAlgebra.tr(y))\nend\n\nρ = [random_state(d) for i in 1:N]","category":"page"},{"location":"tutorials/conic/quantum_discrimination/#JuMP-formulation","page":"Quantum state discrimination","title":"JuMP formulation","text":"","category":"section"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"To model the problem in JuMP, we need a solver that supports positive semidefinite matrices:","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"model = Model(SCS.Optimizer)\nset_silent(model)","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"Then, we construct our set of E variables:","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"E = [@variable(model, [1:d, 1:d] in HermitianPSDCone()) for i in 1:N]","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"Here we have created a vector of matrices. This is different to other modeling languages such as YALMIP, which allow you to create a multi-dimensional array in which 2-dimensional slices of the array are Hermitian matrices.","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"We also need to enforce the constraint that sumlimits_i=1^N E_i = mathbfI:","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"@constraint(model, sum(E) == LinearAlgebra.I)","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"This constraint is a complex-valued equality constraint. In the solver, it will be decomposed onto two types of equality constraints: one to enforce equality of the real components, and one to enforce equality of the imaginary components.","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"Our objective is to maximize the expected probability of guessing correctly:","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"@objective(\n    model,\n    Max,\n    sum(real(LinearAlgebra.tr(ρ[i] * E[i])) for i in 1:N) / N,\n)","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"Now we optimize:","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"optimize!(model)\n@assert is_solved_and_feasible(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"The probability of guessing correctly is:","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"objective_value(model)","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"When N = 2, there is a known analytical solution of:","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"0.5 + 0.25 * sum(LinearAlgebra.svdvals(ρ[1] - ρ[2]))","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"proving that we found the optimal solution.","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"Finally, the optimal POVM is:","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"solution = [value.(e) for e in E]","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"tip: Tip\nDuality plays a large role in solving conic optimization models. Depending on the solver, it can be more efficient to solve the dual of this problem instead of the primal. If performance is an issue, see the Dualization tutorial for more details.","category":"page"},{"location":"tutorials/conic/quantum_discrimination/#Alternative-formulation","page":"Quantum state discrimination","title":"Alternative formulation","text":"","category":"section"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"The formulation above includes N Hermitian matrices and a set of linear equality constraints. We can simplify the problem by replacing E_N with E_N = I - sumlimits_i=1^N-1 E_i. This results in:","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"model = Model(SCS.Optimizer)\nset_silent(model)\nE = [@variable(model, [1:d, 1:d] in HermitianPSDCone()) for i in 1:N-1]\nE_N = LinearAlgebra.Hermitian(LinearAlgebra.I - sum(E))\n@constraint(model, E_N in HermitianPSDCone())\npush!(E, E_N)","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"The objective can also be simplified, by observing that it is equivalent to:","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"@objective(model, Max, real(LinearAlgebra.dot(ρ, E)) / N)","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"Then we can check that we get the same solution:","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"optimize!(model)\n@assert is_solved_and_feasible(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/conic/quantum_discrimination/","page":"Quantum state discrimination","title":"Quantum state discrimination","text":"objective_value(model)","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/tutorials/implementing.md\"","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/tutorials/implementing/#Implementing-a-solver-interface","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"This guide outlines the basic steps to implement an interface to MathOptInterface for a new solver.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"danger: Danger\nImplementing an interface to MathOptInterface for a new solver is a lot of work. Before starting, we recommend that you join the Developer chatroom and explain a little bit about the solver you are wrapping. If you have questions that are not answered by this guide, please ask them in the Developer chatroom so we can improve this guide.","category":"page"},{"location":"moi/tutorials/implementing/#A-note-on-the-API","page":"Implementing a solver interface","title":"A note on the API","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The API of MathOptInterface is large and varied. In order to support the diversity of solvers and use-cases, we make heavy use of duck-typing. That is, solvers are not expected to implement the full API, nor is there a well-defined minimal subset of what must be implemented. Instead, you should implement the API as necessary to make the solver function as you require.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The main reason for using duck-typing is that solvers work in different ways and target different use-cases.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For example:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Some solvers support incremental problem construction, support modification after a solve, and have native support for things like variable names.\nOther solvers are \"one-shot\" solvers that require all of the problem data to construct and solve the problem in a single function call. They do not support modification or things like variable names.\nOther \"solvers\" are not solvers at all, but things like file readers. These may only support functions like read_from_file, and may not even support the ability to add variables or constraints directly.\nFinally, some \"solvers\" are layers which take a problem as input, transform it according to some rules, and pass the transformed problem to an inner solver.","category":"page"},{"location":"moi/tutorials/implementing/#Preliminaries","page":"Implementing a solver interface","title":"Preliminaries","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Before starting on your wrapper, you should do some background research and make the solver accessible via Julia.","category":"page"},{"location":"moi/tutorials/implementing/#Decide-if-MathOptInterface-is-right-for-you","page":"Implementing a solver interface","title":"Decide if MathOptInterface is right for you","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The first step in writing a wrapper is to decide whether implementing an interface is the right thing to do.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"MathOptInterface is an abstraction layer for unifying constrained mathematical optimization solvers. If your solver doesn't fit in the category, for example, it implements a derivative-free algorithm for unconstrained objective functions, MathOptInterface may not be the right tool for the job.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nIf you're not sure whether you should write an interface, ask in the Developer chatroom.","category":"page"},{"location":"moi/tutorials/implementing/#Find-a-similar-solver-already-wrapped","page":"Implementing a solver interface","title":"Find a similar solver already wrapped","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The next step is to find (if possible) a similar solver that is already wrapped. Although not strictly necessary, this will be a good place to look for inspiration when implementing your wrapper.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The JuMP documentation has a good list of solvers, along with the problem classes they support.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nIf you're not sure which solver is most similar, ask in the Developer chatroom.","category":"page"},{"location":"moi/tutorials/implementing/#Create-a-low-level-interface","page":"Implementing a solver interface","title":"Create a low-level interface","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Before writing a MathOptInterface wrapper, you first need to be able to call the solver from Julia.","category":"page"},{"location":"moi/tutorials/implementing/#Wrapping-solvers-written-in-Julia","page":"Implementing a solver interface","title":"Wrapping solvers written in Julia","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If your solver is written in Julia, there's nothing to do here. Go to the next section.","category":"page"},{"location":"moi/tutorials/implementing/#Wrapping-solvers-written-in-C","page":"Implementing a solver interface","title":"Wrapping solvers written in C","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Julia is well suited to wrapping solvers written in C.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"info: Info\nThis is not true for C++. If you have a solver written in C++, first write a C interface, then wrap the C interface.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Before writing a MathOptInterface wrapper, there are a few extra steps.","category":"page"},{"location":"moi/tutorials/implementing/#Create-a-JLL","page":"Implementing a solver interface","title":"Create a JLL","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If the C code is publicly available under an open source license, create a JLL package via Yggdrasil. The easiest way to do this is to copy an existing solver. Good examples to follow are the COIN-OR solvers.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"warning: Warning\nBuilding the solver via Yggdrasil is non-trivial. Please ask the Developer chatroom for help.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If the code is commercial or not publicly available, the user will need to manually install the solver. See Gurobi.jl or CPLEX.jl for examples of how to structure this.","category":"page"},{"location":"moi/tutorials/implementing/#implement_clang","page":"Implementing a solver interface","title":"Use Clang.jl to wrap the C API","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The next step is to use Clang.jl to automatically wrap the C API. The easiest way to do this is to follow an example. Good examples to follow are Cbc.jl and HiGHS.jl.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Sometimes, you will need to make manual modifications to the resulting files.","category":"page"},{"location":"moi/tutorials/implementing/#Solvers-written-in-other-languages","page":"Implementing a solver interface","title":"Solvers written in other languages","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Ask the Developer chatroom for advice. You may be able to use one of the JuliaInterop packages to call out to the solver.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For example, SeDuMi.jl uses MATLAB.jl to call the SeDuMi solver written in MATLAB.","category":"page"},{"location":"moi/tutorials/implementing/#Structuring-the-package","page":"Implementing a solver interface","title":"Structuring the package","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Structure your wrapper as a Julia package. Consult the Julia documentation if you haven't done this before.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"MOI solver interfaces may be in the same package as the solver itself (either the C wrapper if the solver is accessible through C, or the Julia code if the solver is written in Julia, for example), or in a separate package which depends on the solver package.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"note: Note\nThe JuMP core contributors request that you do not use \"JuMP\" in the name of your package without prior consent.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Your package should have the following structure:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"/.github\n    /workflows\n        ci.yml\n        format_check.yml\n        TagBot.yml\n/gen\n    gen.jl  # Code to wrap the C API\n/src\n    NewSolver.jl\n    /gen\n        libnewsolver_api.jl\n        libnewsolver_common.jl\n    /MOI_wrapper\n        MOI_wrapper.jl\n        other_files.jl\n/test\n    runtests.jl\n    /MOI_wrapper\n        MOI_wrapper.jl\n.gitignore\n.JuliaFormatter.toml\nREADME.md\nLICENSE.md\nProject.toml","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The /.github folder contains the scripts for GitHub actions. The easiest way to write these is to copy the ones from an existing solver.\nThe /gen and /src/gen folders are only needed if you are wrapping a solver written in C.\nThe /src/MOI_wrapper folder contains the Julia code for the MOI wrapper.\nThe /test folder contains code for testing your package. See Setup tests for more information.\nThe .JuliaFormatter.toml and .github/workflows/format_check.yml enforce code formatting using JuliaFormatter.jl. Check existing solvers or JuMP.jl for details.","category":"page"},{"location":"moi/tutorials/implementing/#Documentation","page":"Implementing a solver interface","title":"Documentation","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Your package must include documentation explaining how to use the package. The easiest approach is to include documentation in your README.md. A more involved option is to use Documenter.jl.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Examples of packages with README-based documentation include:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Cbc.jl\nHiGHS.jl\nSCS.jl","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Examples of packages with Documenter-based documentation include:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Alpine.jl\nCOSMO.jl\nJuniper.jl","category":"page"},{"location":"moi/tutorials/implementing/#Setup-tests","page":"Implementing a solver interface","title":"Setup tests","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The best way to implement an interface to MathOptInterface is via test-driven development.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The MOI.Test submodule contains a large test suite to help check that you have implemented things correctly.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Follow the guide How to test a solver to set up the tests for your package.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nRun the tests frequently when developing. However, at the start there is going to be a lot of errors. Start by excluding large classes of tests (for example, exclude = [\"test_basic_\", \"test_model_\"], implement any missing methods until the tests pass, then remove an exclusion and repeat.","category":"page"},{"location":"moi/tutorials/implementing/#Initial-code","page":"Implementing a solver interface","title":"Initial code","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"By this point, you should have a package setup with tests, formatting, and access to the underlying solver. Now it's time to start writing the wrapper.","category":"page"},{"location":"moi/tutorials/implementing/#The-Optimizer-object","page":"Implementing a solver interface","title":"The Optimizer object","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The first object to create is a subtype of AbstractOptimizer. This type is going to store everything related to the problem.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"By convention, these optimizers should not be exported and should be named PackageName.Optimizer.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"import MathOptInterface as MOI\n\nstruct Optimizer <: MOI.AbstractOptimizer\n    # Fields go here\nend","category":"page"},{"location":"moi/tutorials/implementing/#Optimizer-objects-for-C-solvers","page":"Implementing a solver interface","title":"Optimizer objects for C solvers","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"warning: Warning\nThis section is important if you wrap a solver written in C.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Wrapping a solver written in C will require the use of pointers, and for you to manually free the solver's memory when the Optimizer is garbage collected by Julia.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Never pass a pointer directly to a Julia ccall function.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Instead, store the pointer as a field in your Optimizer, and implement Base.cconvert and Base.unsafe_convert. Then you can pass Optimizer to any ccall function that expects the pointer.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"In addition, make sure you implement a finalizer for each model you create.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If newsolver_createProblem() is the low-level function that creates the problem pointer in C, and newsolver_freeProblem(::Ptr{Cvoid}) is the low-level function that frees memory associated with the pointer, your Optimizer() function should look like this:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"struct Optimizer <: MOI.AbstractOptimizer\n    ptr::Ptr{Cvoid}\n\n    function Optimizer()\n        ptr = newsolver_createProblem()\n        model = Optimizer(ptr)\n        finalizer(model) do m\n            newsolver_freeProblem(m)\n            return\n        end\n        return model\n    end\nend\n\nBase.cconvert(::Type{Ptr{Cvoid}}, model::Optimizer) = model\nBase.unsafe_convert(::Type{Ptr{Cvoid}}, model::Optimizer) = model.ptr","category":"page"},{"location":"moi/tutorials/implementing/#Implement-methods-for-Optimizer","page":"Implementing a solver interface","title":"Implement methods for Optimizer","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"All Optimizers must implement the following methods:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"empty!\nis_empty","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Other methods, detailed below, are optional or depend on how you implement the interface.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nFor this and all future methods, read the docstrings to understand what each method does, what it expects as input, and what it produces as output. If it isn't clear, let us know and we will improve the docstrings. It is also very helpful to look at an existing wrapper for a similar solver.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"You should also implement Base.show(::IO, ::Optimizer) to print a nice string when someone prints your model. For example","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"function Base.show(io::IO, model::Optimizer)\n    return print(io, \"NewSolver with the pointer $(model.ptr)\")\nend","category":"page"},{"location":"moi/tutorials/implementing/#Implement-attributes","page":"Implementing a solver interface","title":"Implement attributes","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"MathOptInterface uses attributes to manage different aspects of the problem.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For each attribute","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"get gets the current value of the attribute\nset sets a new value of the attribute. Not all attributes can be set. For example, the user can't modify the SolverName.\nsupports returns a Bool indicating whether the solver supports the attribute.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"info: Info\nUse attribute_value_type to check the value expected by a given attribute. You should make sure that your get function correctly infers to this type (or a subtype of it).","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Each column in the table indicates whether you need to implement the particular method for each attribute.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Attribute get set supports\nSolverName Yes No No\nSolverVersion Yes No No\nRawSolver Yes No No\nName Yes Yes Yes\nSilent Yes Yes Yes\nTimeLimitSec Yes Yes Yes\nObjectiveLimit Yes Yes Yes\nSolutionLimit Yes Yes Yes\nRawOptimizerAttribute Yes Yes Yes\nNumberOfThreads Yes Yes Yes\nAbsoluteGapTolerance Yes Yes Yes\nRelativeGapTolerance Yes Yes Yes","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For example:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"function MOI.get(model::Optimizer, ::MOI.Silent)\n    return # true if MOI.Silent is set\nend\n\nfunction MOI.set(model::Optimizer, ::MOI.Silent, v::Bool)\n    if v\n        # Set a parameter to turn off printing\n    else\n        # Restore the default printing\n    end\n    return\nend\n\nMOI.supports(::Optimizer, ::MOI.Silent) = true","category":"page"},{"location":"moi/tutorials/implementing/#Define-supports_constraint","page":"Implementing a solver interface","title":"Define supports_constraint","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The next step is to define which constraints and objective functions you plan to support.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For each function-set constraint pair, define supports_constraint:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"function MOI.supports_constraint(\n    ::Optimizer,\n    ::Type{MOI.VariableIndex},\n    ::Type{MOI.ZeroOne},\n)\n    return true\nend","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"To make this easier, you may want to use Unions:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"function MOI.supports_constraint(\n    ::Optimizer,\n    ::Type{MOI.VariableIndex},\n    ::Type{<:Union{MOI.LessThan,MOI.GreaterThan,MOI.EqualTo}},\n)\n    return true\nend","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nOnly support a constraint if your solver has native support for it.","category":"page"},{"location":"moi/tutorials/implementing/#The-big-decision:-incremental-modification?","page":"Implementing a solver interface","title":"The big decision: incremental modification?","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Now you need to decide whether to support incremental modification or not.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Incremental modification means that the user can add variables and constraints one-by-one without needing to rebuild the entire problem, and they can modify the problem data after an optimize! call. Supporting incremental modification means implementing functions like add_variable and add_constraint.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"The alternative is to accept the problem data in a single optimize! or copy_to function call. Because these functions see all of the data at once, it can typically call a more efficient function to load data into the underlying solver.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Good examples of solvers supporting incremental modification are MILP solvers like GLPK.jl and Gurobi.jl. Examples of non-incremental solvers are AmplNLWriter.jl and SCS.jl","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"It is possible for a solver to implement both approaches, but you should probably start with one for simplicity.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nOnly support incremental modification if your solver has native support for it.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"In general, supporting incremental modification is more work, and it usually requires some extra book-keeping. However, it provides a more efficient interface to the solver if the problem is going to be resolved multiple times with small modifications. Moreover, once you've implemented incremental modification, it's usually not much extra work to add a copy_to interface. The converse is not true.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nIf this is your first time writing an interface, start with the one-shot optimize!.","category":"page"},{"location":"moi/tutorials/implementing/#The-non-incremental-interface","page":"Implementing a solver interface","title":"The non-incremental interface","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"There are two ways to implement the non-incremental interface. The first uses a two-argument version of optimize!, the second implements copy_to followed by the one-argument version of optimize!.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If your solver does not support modification, and requires all data to solve the problem in a single function call, you should implement the \"one-shot\" optimize!.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"optimize!(::ModelLike, ::ModelLike)","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If your solver separates data loading and the actual optimization into separate steps, implement the copy_to interface.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"copy_to(::ModelLike, ::ModelLike)\noptimize!(::ModelLike)","category":"page"},{"location":"moi/tutorials/implementing/#The-incremental-interface","page":"Implementing a solver interface","title":"The incremental interface","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"warning: Warning\nWriting this interface is a lot of work. The easiest way is to consult the source code of a similar solver.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"To implement the incremental interface, implement the following functions:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"add_variable\nadd_variables\nadd_constraint\nadd_constraints\nis_valid\ndelete\noptimize!(::ModelLike)","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"info: Info\nSolvers do not have to support AbstractScalarFunction in GreaterThan, LessThan, EqualTo, or Interval with a nonzero constant in the function. Throw ScalarFunctionConstantNotZero if the function constant is not zero.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"In addition, you should implement the following model attributes:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Attribute get set supports\nListOfModelAttributesSet Yes No No\nObjectiveFunctionType Yes No No\nObjectiveFunction Yes Yes Yes\nObjectiveSense Yes Yes Yes\nName Yes Yes Yes","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Variable-related attributes:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Attribute get set supports\nListOfVariableAttributesSet Yes No No\nListOfVariablesWithAttributeSet Yes No No\nNumberOfVariables Yes No No\nListOfVariableIndices Yes No No","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Constraint-related attributes:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Attribute get set supports\nListOfConstraintAttributesSet Yes No No\nListOfConstraintsWithAttributeSet Yes No No\nNumberOfConstraints Yes No No\nListOfConstraintTypesPresent Yes No No\nConstraintFunction Yes Yes No\nConstraintSet Yes Yes No","category":"page"},{"location":"moi/tutorials/implementing/#Modifications","page":"Implementing a solver interface","title":"Modifications","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If your solver supports modifying data in-place, implement modify for the following AbstractModifications:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"ScalarConstantChange\nScalarCoefficientChange\nScalarQuadraticCoefficientChange\nVectorConstantChange\nMultirowChange","category":"page"},{"location":"moi/tutorials/implementing/#Variables-constrained-on-creation","page":"Implementing a solver interface","title":"Variables constrained on creation","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Some solvers require variables be associated with a set when they are created. This conflicts with the incremental modification approach, since you cannot first add a free variable and then constrain it to the set.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If this is the case, implement:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"add_constrained_variable\nadd_constrained_variables\nsupports_add_constrained_variables","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"By default, MathOptInterface assumes solvers support free variables. If your solver does not support free variables, define:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"MOI.supports_add_constrained_variables(::Optimizer, ::Type{Reals}) = false","category":"page"},{"location":"moi/tutorials/implementing/#Incremental-and-copy_to","page":"Implementing a solver interface","title":"Incremental and copy_to","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If you implement the incremental interface, you have the option of also implementing copy_to.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If you don't want to implement copy_to, for example, because the solver has no API for building the problem in a single function call, define the following fallback:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"MOI.supports_incremental_interface(::Optimizer) = true\n\nfunction MOI.copy_to(dest::Optimizer, src::MOI.ModelLike)\n    return MOI.Utilities.default_copy_to(dest, src)\nend","category":"page"},{"location":"moi/tutorials/implementing/#implement_names","page":"Implementing a solver interface","title":"Names","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Regardless of which interface you implement, you have the option of implementing the Name attribute for variables and constraints:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Attribute get set supports\nVariableName Yes Yes Yes\nConstraintName Yes Yes Yes","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If you implement names, you must also implement the following three methods:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"function MOI.get(model::Optimizer, ::Type{MOI.VariableIndex}, name::String)\n    return # The variable named `name`.\nend\n\nfunction MOI.get(model::Optimizer, ::Type{MOI.ConstraintIndex}, name::String)\n    return # The constraint any type named `name`.\nend\n\nfunction MOI.get(\n    model::Optimizer,\n    ::Type{MOI.ConstraintIndex{F,S}},\n    name::String,\n) where {F,S}\n    return # The constraint of type F-in-S named `name`.\nend","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"These methods have the following rules:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If there is no variable or constraint with the name, return nothing\nIf there is a single variable or constraint with that name, return the variable or constraint\nIf there are multiple variables or constraints with the name, throw an error.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"warning: Warning\nYou should not implement ConstraintName for VariableIndex constraints. If you implement ConstraintName for other constraints, you can add the following two methods to disable ConstraintName for VariableIndex constraints.function MOI.supports(\n    ::Optimizer,\n    ::MOI.ConstraintName,\n    ::Type{<:MOI.ConstraintIndex{MOI.VariableIndex,<:MOI.AbstractScalarSet}},\n)\n    return throw(MOI.VariableIndexConstraintNameError())\nend\nfunction MOI.set(\n    ::Optimizer,\n    ::MOI.ConstraintName,\n    ::MOI.ConstraintIndex{MOI.VariableIndex,<:MOI.AbstractScalarSet},\n    ::String,\n)\n    return throw(MOI.VariableIndexConstraintNameError())\nend","category":"page"},{"location":"moi/tutorials/implementing/#Solutions","page":"Implementing a solver interface","title":"Solutions","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Implement optimize! to solve the model:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"optimize!","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"All Optimizers must implement the following attributes:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"DualStatus\nPrimalStatus\nRawStatusString\nResultCount\nTerminationStatus","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"info: Info\nYou only need to implement get for solution attributes. Don't implement set or supports.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"note: Note\nSolver wrappers should document how the low-level statuses map to the MOI statuses. Statuses like NEARLY_FEASIBLE_POINT and INFEASIBLE_POINT, are designed to be used when the solver explicitly indicates that relaxed tolerances are satisfied or the returned point is infeasible, respectively.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"You should also implement the following attributes:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"ObjectiveValue\nSolveTimeSec\nVariablePrimal","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"tip: Tip\nAttributes like VariablePrimal and ObjectiveValue are indexed by the result count. Use MOI.check_result_index_bounds(model, attr) to throw an error if the attribute is not available.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If your solver returns dual solutions, implement:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"ConstraintDual\nDualObjectiveValue","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For integer solvers, implement:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"ObjectiveBound\nRelativeGap","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If applicable, implement:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"SimplexIterations\nBarrierIterations\nNodeCount","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If your solver uses the Simplex method, implement:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"ConstraintBasisStatus","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"If your solver accepts primal or dual warm-starts, implement:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"VariablePrimalStart\nConstraintDualStart","category":"page"},{"location":"moi/tutorials/implementing/#Other-tips","page":"Implementing a solver interface","title":"Other tips","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Here are some other points to be aware of when writing your wrapper.","category":"page"},{"location":"moi/tutorials/implementing/#Unsupported-constraints-at-runtime","page":"Implementing a solver interface","title":"Unsupported constraints at runtime","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"In some cases, your solver may support a particular type of constraint (for example, quadratic constraints), but only if the data meets some condition (for example, it is convex).","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"In this case, declare that you support the constraint, and throw AddConstraintNotAllowed.","category":"page"},{"location":"moi/tutorials/implementing/#Dealing-with-multiple-variable-bounds","page":"Implementing a solver interface","title":"Dealing with multiple variable bounds","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"MathOptInterface uses VariableIndex constraints to represent variable bounds. Defining multiple variable bounds on a single variable is not allowed.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Throw LowerBoundAlreadySet or UpperBoundAlreadySet if the user adds a constraint that results in multiple bounds.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Only throw if the constraints conflict. It is okay to add VariableIndex-in-GreaterThan and then VariableIndex-in-LessThan, but not VariableIndex-in-Interval and then VariableIndex-in-LessThan,","category":"page"},{"location":"moi/tutorials/implementing/#Expect-duplicate-coefficients","page":"Implementing a solver interface","title":"Expect duplicate coefficients","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Solvers must expect that functions such as ScalarAffineFunction and VectorQuadraticFunction may contain duplicate coefficients.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For example, ScalarAffineFunction([ScalarAffineTerm(x, 1), ScalarAffineTerm(x, 1)], 0.0).","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Use Utilities.canonical to return a new function with the duplicate coefficients aggregated together.","category":"page"},{"location":"moi/tutorials/implementing/#Don't-modify-user-data","page":"Implementing a solver interface","title":"Don't modify user-data","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"All data passed to the solver must be copied immediately to internal data structures. Solvers may not modify any input vectors and must assume that input vectors will not be modified by users in the future.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"This applies, for example, to the terms vector in ScalarAffineFunction. Vectors returned to the user, for example, via ObjectiveFunction or ConstraintFunction attributes, must not be modified by the solver afterwards. The in-place version of get! can be used by users to avoid extra copies in this case.","category":"page"},{"location":"moi/tutorials/implementing/#Column-Generation","page":"Implementing a solver interface","title":"Column Generation","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"There is no special interface for column generation. If the solver has a special API for setting coefficients in existing constraints when adding a new variable, it is possible to queue modifications and new variables and then call the solver's API once all of the new coefficients are known.","category":"page"},{"location":"moi/tutorials/implementing/#Solver-specific-attributes","page":"Implementing a solver interface","title":"Solver-specific attributes","text":"","category":"section"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"You don't need to restrict yourself to the attributes defined in the MathOptInterface.jl package.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Solver-specific attributes should be specified by creating an appropriate subtype of AbstractModelAttribute, AbstractOptimizerAttribute, AbstractVariableAttribute, or AbstractConstraintAttribute.","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"For example, Gurobi.jl adds attributes for multiobjective optimization by defining:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"struct NumberOfObjectives <: MOI.AbstractModelAttribute end\n\nfunction MOI.set(model::Optimizer, ::NumberOfObjectives, n::Integer)\n    # Code to set NumberOfObjectives\n    return\nend\n\nfunction MOI.get(model::Optimizer, ::NumberOfObjectives)\n    n = # Code to get NumberOfObjectives\n    return n\nend","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"Then, the user can write:","category":"page"},{"location":"moi/tutorials/implementing/","page":"Implementing a solver interface","title":"Implementing a solver interface","text":"model = Gurobi.Optimizer()\nMOI.set(model, Gurobi.NumberofObjectives(), 3)","category":"page"},{"location":"moi/submodules/Benchmarks/reference/","page":"API Reference","title":"API Reference","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/submodules/Benchmarks/reference.md\"","category":"page"},{"location":"moi/submodules/Benchmarks/reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Benchmarks/reference/#Benchmarks","page":"API Reference","title":"Benchmarks","text":"","category":"section"},{"location":"moi/submodules/Benchmarks/reference/","page":"API Reference","title":"API Reference","text":"Functions to help benchmark the performance of solver wrappers. See The Benchmarks submodule for more details.","category":"page"},{"location":"moi/submodules/Benchmarks/reference/","page":"API Reference","title":"API Reference","text":"Benchmarks.suite\nBenchmarks.create_baseline\nBenchmarks.compare_against_baseline","category":"page"},{"location":"moi/submodules/Benchmarks/reference/#MathOptInterface.Benchmarks.suite","page":"API Reference","title":"MathOptInterface.Benchmarks.suite","text":"suite(\n    new_model::Function;\n    exclude::Vector{Regex} = Regex[]\n)\n\nCreate a suite of benchmarks. new_model should be a function that takes no arguments, and returns a new instance of the optimizer you wish to benchmark.\n\nUse exclude to exclude a subset of benchmarks.\n\nExamples\n\nsuite() do\n    GLPK.Optimizer()\nend\nsuite(exclude = [r\"delete\"]) do\n    Gurobi.Optimizer(OutputFlag=0)\nend\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Benchmarks/reference/#MathOptInterface.Benchmarks.create_baseline","page":"API Reference","title":"MathOptInterface.Benchmarks.create_baseline","text":"create_baseline(suite, name::String; directory::String = \"\"; kwargs...)\n\nRun all benchmarks in suite and save to files called name in directory.\n\nExtra kwargs are based to BenchmarkTools.run.\n\nExamples\n\nmy_suite = suite(() -> GLPK.Optimizer())\ncreate_baseline(my_suite, \"glpk_master\"; directory = \"/tmp\", verbose = true)\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Benchmarks/reference/#MathOptInterface.Benchmarks.compare_against_baseline","page":"API Reference","title":"MathOptInterface.Benchmarks.compare_against_baseline","text":"compare_against_baseline(\n    suite, name::String; directory::String = \"\",\n    report_filename::String = \"report.txt\"\n)\n\nRun all benchmarks in suite and compare against files called name in directory that were created by a call to create_baseline.\n\nA report summarizing the comparison is written to report_filename in directory.\n\nExtra kwargs are based to BenchmarkTools.run.\n\nExamples\n\nmy_suite = suite(() -> GLPK.Optimizer())\ncompare_against_baseline(\n    my_suite, \"glpk_master\"; directory = \"/tmp\", verbose = true\n)\n\n\n\n\n\n","category":"function"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/tutorials/bridging_constraint.md\"","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/tutorials/bridging_constraint/#Implementing-a-constraint-bridge","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"This guide outlines the basic steps to create a new bridge from a constraint expressed in the formalism Function-in-Set.","category":"page"},{"location":"moi/tutorials/bridging_constraint/#Preliminaries","page":"Implementing a constraint bridge","title":"Preliminaries","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"First, decide on the set you want to bridge. Then, study its properties: the most important one is whether the set is scalar or vector, which impacts the dimensionality of the functions that can be used with the set.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"A scalar function only has one dimension. MOI defines three types of scalar functions: a variable (VariableIndex), an affine function (ScalarAffineFunction), or a quadratic function (ScalarQuadraticFunction).\nA vector function has several dimensions (at least one). MOI defines three types of vector functions: several variables (VectorOfVariables), an affine function (VectorAffineFunction), or a quadratic function (VectorQuadraticFunction). The main difference with scalar functions is that the order of dimensions can be very important: for instance, in an indicator constraint (Indicator), the first dimension indicates whether the constraint about the second dimension is active.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"To explain how to implement a bridge, we present the example of Bridges.Constraint.FlipSignBridge. This bridge maps <= (LessThan) constraints to >= (GreaterThan) constraints. This corresponds to reversing the sign of the inequality. We focus on scalar affine functions (we disregard the cases of a single variable or of quadratic functions). This example is a simplified version of the code included in MOI.","category":"page"},{"location":"moi/tutorials/bridging_constraint/#Four-mandatory-parts-in-a-constraint-bridge","page":"Implementing a constraint bridge","title":"Four mandatory parts in a constraint bridge","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"The first part of a constraint bridge is a new concrete subtype of Bridges.Constraint.AbstractBridge. This type must have fields to store all the new variables and constraints that the bridge will add. Typically, these types are parametrized by the type of the coefficients in the model.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"Then, three sets of functions must be defined:","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"Bridges.Constraint.bridge_constraint: this function implements the bridge and creates the required variables and constraints.\nsupports_constraint: these functions must return true when the combination of function and set is supported by the bridge. By default, the base implementation always returns false and the bridge does not have to provide this implementation.\nBridges.added_constrained_variable_types and Bridges.added_constraint_types: these functions return the types of variables and constraints that this bridge adds. They are used to compute the set of other bridges that are required to use the one you are defining, if need be.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"More functions can be implemented, for instance to retrieve properties from the bridge or deleting a bridged constraint.","category":"page"},{"location":"moi/tutorials/bridging_constraint/#1.-Structure-for-the-bridge","page":"Implementing a constraint bridge","title":"1. Structure for the bridge","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"A typical struct behind a bridge depends on the type of the coefficients that are used for the model (typically Float64, but coefficients might also be integers or complex numbers).","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"This structure must hold a reference to all the variables and the constraints that are created as part of the bridge.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"The type of this structure is used throughout MOI as an identifier for the bridge. It is passed as argument to most functions related to bridges.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"The best practice is to have the name of this type end with Bridge.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"In our example, the bridge maps any ScalarAffineFunction{T}-in-LessThan{T} constraint to a single ScalarAffineFunction{T}-in-GreaterThan{T} constraint. The affine function has coefficients of type T. The bridge is parametrized with T, so that the constraint that the bridge creates also has coefficients of type T.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"struct SignBridge{T<:Number} <: Bridges.Constraint.AbstractBridge\n    constraint::ConstraintIndex{ScalarAffineFunction{T}, GreaterThan{T}}\nend","category":"page"},{"location":"moi/tutorials/bridging_constraint/#2.-Bridge-creation","page":"Implementing a constraint bridge","title":"2. Bridge creation","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"The function Bridges.Constraint.bridge_constraint is called whenever the bridge is instantiated for a specific model, with the given function and set. The arguments to bridge_constraint are similar to add_constraint, with the exception of the first argument: it is the Type of the struct defined in the first step (for our example, Type{SignBridge{T}}).","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"bridge_constraint returns an instance of the struct defined in the first step. the first step.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"In our example, the bridge constraint could be defined as:","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"function Bridges.Constraint.bridge_constraint(\n    ::Type{SignBridge{T}}, # Bridge to use.\n    model::ModelLike, # Model to which the constraint is being added.\n    f::ScalarAffineFunction{T}, # Function to rewrite.\n    s::LessThan{T}, # Set to rewrite.\n) where {T}\n    # Create the variables and constraints required for the bridge.\n    con = add_constraint(model, -f, GreaterThan(-s.upper))\n\n    # Return an instance of the bridge type with a reference to all the\n    # variables and constraints that were created in this function.\n    return SignBridge(con)\nend","category":"page"},{"location":"moi/tutorials/bridging_constraint/#3.-Supported-constraint-types","page":"Implementing a constraint bridge","title":"3. Supported constraint types","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"The function supports_constraint determines whether the bridge type supports a given combination of function and set.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"This function must closely match bridge_constraint, because it will not be called if supports_constraint returns false.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"function supports_constraint(\n    ::Type{SignBridge{T}}, # Bridge to use.\n    ::Type{ScalarAffineFunction{T}}, # Function to rewrite.\n    ::Type{LessThan{T}}, # Set to rewrite.\n) where {T}\n    # Do some computation to ensure that the constraint is supported.\n    # Typically, you can directly return true.\n    return true\nend","category":"page"},{"location":"moi/tutorials/bridging_constraint/#4.-Metadata-about-the-bridge","page":"Implementing a constraint bridge","title":"4. Metadata about the bridge","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"To determine whether a bridge can be used, MOI uses a shortest-path algorithm that uses the variable types and the constraints that the bridge can create. This information is communicated from the bridge to MOI using the functions Bridges.added_constrained_variable_types and Bridges.added_constraint_types. Both return lists of tuples: either a list of 1-tuples containing the variable types (typically, ZeroOne or Integer) or a list of 2-tuples contained the functions and sets (like ScalarAffineFunction{T}-GreaterThan).","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"For our example, the bridge does not create any constrained variables, and only ScalarAffineFunction{T}-in-GreaterThan{T} constraints:","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"function Bridges.added_constrained_variable_types(::Type{SignBridge{T}}) where {T}\n    # The bridge does not create variables, return an empty list of tuples:\n    return Tuple{Type}[]\nend\n\nfunction Bridges.added_constraint_types(::Type{SignBridge{T}}) where {T}\n    return Tuple{Type,Type}[\n        # One element per F-in-S the bridge creates.\n        (ScalarAffineFunction{T}, GreaterThan{T}),\n    ]\nend","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"A bridge that creates binary variables would rather have this definition of added_constrained_variable_types:","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"function Bridges.added_constrained_variable_types(::Type{SomeBridge{T}}) where {T}\n    # The bridge only creates binary variables:\n    return Tuple{Type}[(ZeroOne,)]\nend","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"warning: Warning\nIf you declare the creation of constrained variables in added_constrained_variable_types, the corresponding constraint type VariableIndex must not be indicated in added_constraint_types. This would restrict the use of the bridge to solvers that can add such a constraint after the variable is created.More concretely, if you declare in added_constrained_variable_types that your bridge creates binary variables (ZeroOne), and if you never add such a constraint afterward (you do not call add_constraint(model, var, ZeroOne())), then you must not list (VariableIndex, ZeroOne) in added_constraint_types.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"Typically, the function Bridges.Constraint.concrete_bridge_type does not have to be defined for most bridges.","category":"page"},{"location":"moi/tutorials/bridging_constraint/#Bridge-registration","page":"Implementing a constraint bridge","title":"Bridge registration","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"For a bridge to be used by MOI, it must be known by MOI.","category":"page"},{"location":"moi/tutorials/bridging_constraint/#SingleBridgeOptimizer","page":"Implementing a constraint bridge","title":"SingleBridgeOptimizer","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"The first way to do so is to create a single-bridge optimizer. This type of optimizer wraps another optimizer and adds the possibility to use only one bridge. It is especially useful when unit testing bridges.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"It is common practice to use the same name as the type defined for the bridge (SignBridge, in our example) without the suffix Bridge.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"const Sign{T,OT<: ModelLike} =\n    SingleBridgeOptimizer{SignBridge{T}, OT}","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"In the context of unit tests, this bridge is used in conjunction with a Utilities.MockOptimizer:","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"mock = Utilities.MockOptimizer(\n    Utilities.UniversalFallback(Utilities.Model{Float64}()),\n)\nbridged_mock = Sign{Float64}(mock)","category":"page"},{"location":"moi/tutorials/bridging_constraint/#New-bridge-for-a-LazyBridgeOptimizer","page":"Implementing a constraint bridge","title":"New bridge for a LazyBridgeOptimizer","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"Typical user-facing models for MOI are based on Bridges.LazyBridgeOptimizer. For instance, this type of model is returned by Bridges.full_bridge_optimizer. These models can be added more bridges by using Bridges.add_bridge:","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"inner_optimizer = Utilities.Model{Float64}()\noptimizer = Bridges.full_bridge_optimizer(inner_optimizer, Float64)\nBridges.add_bridge(optimizer, SignBridge{Float64})","category":"page"},{"location":"moi/tutorials/bridging_constraint/#Bridge-improvements","page":"Implementing a constraint bridge","title":"Bridge improvements","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/#Attribute-retrieval","page":"Implementing a constraint bridge","title":"Attribute retrieval","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"Like models, bridges have attributes that can be retrieved using get and set. The most important ones are the number of variables and constraints, but also the lists of variables and constraints.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"In our example, we only have one constraint and only have to implement the NumberOfConstraints and ListOfConstraintIndices attributes:","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"function get(\n    ::SignBridge{T},\n    ::NumberOfConstraints{\n        ScalarAffineFunction{T},\n        GreaterThan{T},\n    },\n) where {T}\n    return 1\nend\n\nfunction get(\n    bridge::SignBridge{T},\n    ::ListOfConstraintIndices{\n        ScalarAffineFunction{T},\n        GreaterThan{T},\n    },\n) where {T}\n    return [bridge.constraint]\nend","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"You must implement one such pair of functions for each type of constraint the bridge adds to the model.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"warning: Warning\nAvoid returning a list from the bridge object without copying it. Users must be able to change the contents of the returned list without altering the bridge object.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"For variables, the situation is simpler. If your bridge creates new variables, you must implement the NumberOfVariables and ListOfVariableIndices attributes. However, these attributes do not have parameters, unlike their constraint counterparts. Only two functions suffice:","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"function get(\n    ::SignBridge{T},\n    ::NumberOfVariables,\n) where {T}\n    return 0\nend\n\nfunction get(\n    ::SignBridge{T},\n    ::ListOfVariableIndices,\n) where {T}\n    return VariableIndex[]\nend","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"In order for the user to be able to access the function and set of the original constraint, the bridge needs to implement getters for the ConstraintFunction and ConstraintSet attributes:","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"function get(\n    model::MOI.ModelLike,\n    attr::MOI.ConstraintFunction,\n    bridge::SignBridge,\n)\n    return -MOI.get(model, attr, bridge.constraint)\nend\n\nfunction get(\n    model::MOI.ModelLike,\n    attr::MOI.ConstraintSet,\n    bridge::SignBridge,\n)\n    set = MOI.get(model, attr, bridge.constraint)\n    return MOI.LessThan(-set.lower)\nend","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"warning: Warning\nAlternatively, one could store the original function and set in SignBridge during Bridges.Constraint.bridge_constraint to make these getters simpler and more efficient. On the other hand, this will increase the memory footprint of the bridges as the garbage collector won't be able to delete that object. The convention is to not store the function in the bridge and not care too much about the efficiency of these getters. If the user needs efficient getters for ConstraintFunction then they should use a Utilities.CachingOptimizer.","category":"page"},{"location":"moi/tutorials/bridging_constraint/#Model-modifications","page":"Implementing a constraint bridge","title":"Model modifications","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"To avoid copying the model when the user request to change a constraint, MOI provides modify. Bridges can also implement this API to allow certain changes, such as coefficient changes.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"In our case, a modification of a coefficient in the original constraint (for example, replacing the value of the coefficient of a variable in the affine function) must be transmitted to the constraint created by the bridge, but with a sign change.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"function modify(\n    model::ModelLike,\n    bridge::SignBridge,\n    change::ScalarCoefficientChange,\n)\n    modify(\n        model,\n        bridge.constraint,\n        ScalarCoefficientChange(change.variable, -change.new_coefficient),\n    )\n    return\nend","category":"page"},{"location":"moi/tutorials/bridging_constraint/#Bridge-deletion","page":"Implementing a constraint bridge","title":"Bridge deletion","text":"","category":"section"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"When a bridge is deleted, the constraints it added must be deleted too.","category":"page"},{"location":"moi/tutorials/bridging_constraint/","page":"Implementing a constraint bridge","title":"Implementing a constraint bridge","text":"function delete(model::ModelLike, bridge::SignBridge)\n    delete(model, bridge.constraint)\n    return\nend","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"EditURL = \"experiment_design.jl\"","category":"page"},{"location":"tutorials/conic/experiment_design/#Experiment-design","page":"Experiment design","title":"Experiment design","text":"","category":"section"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"This tutorial was originally contributed by Arpit Bhatia and Chris Coey.","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"This tutorial covers experiment design examples (D-optimal, A-optimal, and E-optimal) from section 7.5 of (Boyd and Vandenberghe, 2004).","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"The tutorial uses the following packages","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"using JuMP\nimport SCS\nimport LinearAlgebra\nimport Random","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"info: Info\nThis tutorial uses sets from MathOptInterface. By default, JuMP exports the MOI symbol as an alias for the MathOptInterface.jl package. We recommend making this more explicit in your code by adding the following lines:import MathOptInterface as MOI","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"We set a seed so the random numbers are repeatable:","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"Random.seed!(1234)","category":"page"},{"location":"tutorials/conic/experiment_design/#The-relaxed-experiment-design-problem","page":"Experiment design","title":"The relaxed experiment design problem","text":"","category":"section"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"The basic experiment design problem is as follows.","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"Given the menu of possible choices for experiments, v_1 ldots v_p, and the total number m of experiments to be carried out, choose the numbers of each type of experiment, that is, m_1 ldots m_p to make the error covariance E small (in  some sense).","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"The variables m_1 ldots m_p must, of course, be integers and sum to m the given total number of experiments. This leads to the optimization problem:","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"beginaligned\nminleft(mathrmwrt mathbfS_+^nright)  E=left(sum_j=1^p m_j v_j v_j^Tright)^-1 \ntextsubject to  m_i geq 0 \n sumlimits_i=1^p m_i = m \n m_i in mathbbZquad i=1ldotsp\nendaligned","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"The basic experiment design problem can be a hard combinatorial problem when m, the total number of experiments, is comparable to n, since in this case the m_i are all small integers.","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"In the case when m is large compared to n, however, a good approximate solution can be found by ignoring, or relaxing, the constraint that the m_i are integers.","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"Let lambda_i=m_i  m which is the fraction of the total number of experiments for which a_j=v_i or the relative frequency of experiment i. We can express the error covariance in terms of lambda_i as:","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"E=frac1mleft(sum_i=1^p lambda_i v_i v_i^Tright)^-1","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"The vector lambda in mathbfR^p satisfies lambda succeq 0 mathbf1^T lambda=1 and also, each lambda_i is an integer multiple of 1  m. By ignoring this last constraint, we arrive at the problem:","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"beginaligned\nminleft(mathrmwrt mathbfS_+^nright)  E=(1  m)left(sum_i=1^p lambda_i v_i v_i^Tright)^-1 \ntextsubject toquad  lambda succeq 0 \n mathbf1^T lambda=1\nendaligned","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"Several scalarizations have been proposed for the experiment design problem, which is a vector optimization problem over the positive semidefinite cone.","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"q = 4 # dimension of estimate space\np = 8 # number of experimental vectors\nn_max = 3 # upper bound on lambda\nn = 12\n\nV = randn(q, p)\n\neye = Matrix{Float64}(LinearAlgebra.I, q, q);\nnothing #hide","category":"page"},{"location":"tutorials/conic/experiment_design/#A-optimal-design","page":"Experiment design","title":"A-optimal design","text":"","category":"section"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"In A-optimal experiment design, we minimize tr E, the trace of the covariance matrix. This objective is simply the mean of the norm of the error squared:","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"mathbfEe_2^2=mathbfE operatornametrleft(e e^Tright)=operatornametr E","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"The A-optimal experiment design problem in SDP form is","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"beginaligned\nmin  mathbf1^T u \ntextsubject to  leftbeginalignedsum_i=1^p lambda_i v_i v_i^T  e_k  e_k^T  u_kendalignedright succeq 0 quad k=1 ldots n \n lambda succeq 0 \n  mathbf1^T lambda=1\nendaligned","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"aOpt = Model(SCS.Optimizer)\nset_silent(aOpt)\n@variable(aOpt, np[1:p], lower_bound = 0, upper_bound = n_max)\n@variable(aOpt, u[1:q], lower_bound = 0)\n@constraint(aOpt, sum(np) <= n)\nfor i in 1:q\n    matrix = [\n        V*LinearAlgebra.diagm(0 => np ./ n)*V' eye[:, i]\n        eye[i, :]' u[i]\n    ]\n    @constraint(aOpt, matrix >= 0, PSDCone())\nend\n@objective(aOpt, Min, sum(u))\noptimize!(aOpt)\n@assert is_solved_and_feasible(aOpt)\nobjective_value(aOpt)","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"value.(np)","category":"page"},{"location":"tutorials/conic/experiment_design/#E-optimal-design","page":"Experiment design","title":"E-optimal design","text":"","category":"section"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"In E -optimal design, we minimize the norm of the error covariance matrix, that is, the maximum eigenvalue of E.","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"Since the diameter (twice the longest semi-axis) of the confidence ellipsoid mathcalE is proportional to E_2^1  2, minimizing E_2 can be interpreted geometrically as minimizing the diameter of the confidence ellipsoid.","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"E-optimal design can also be interpreted as minimizing the maximum variance of q^T e, over all q with q_2=1. The E-optimal experiment design problem in SDP form is:","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"beginaligned\nmin  t \ntextsubject to  sum_i=1^p lambda_i v_i v_i^T succeq t I \n lambda succeq 0 \n mathbf1^T lambda=1\nendaligned","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"eOpt = Model(SCS.Optimizer)\nset_silent(eOpt)\n@variable(eOpt, 0 <= np[1:p] <= n_max)\n@variable(eOpt, t)\n@constraint(\n    eOpt,\n    V * LinearAlgebra.diagm(0 => np ./ n) * V' - (t .* eye) >= 0,\n    PSDCone(),\n)\n@constraint(eOpt, sum(np) <= n)\n@objective(eOpt, Max, t)\noptimize!(eOpt)\n@assert is_solved_and_feasible(eOpt)\nobjective_value(eOpt)","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"value.(np)","category":"page"},{"location":"tutorials/conic/experiment_design/#D-optimal-design","page":"Experiment design","title":"D-optimal design","text":"","category":"section"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"The most widely used scalarization is called D -optimal design, in which we minimize the determinant of the error covariance matrix E. This corresponds to designing the experiment to minimize the volume of the resulting confidence ellipsoid (for a fixed confidence level). Ignoring the constant factor 1  m in E, and taking the logarithm of the objective, we can pose this problem as convex optimization problem:","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"beginaligned\nmin  log operatornamedetleft(sum_i=1^p lambda_i v_i v_i^Tright)^-1 \ntextsubject to  lambda succeq 0 \n mathbf1^T lambda=1\nendaligned","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"dOpt = Model(SCS.Optimizer)\nset_silent(dOpt)\n@variable(dOpt, np[1:p], lower_bound = 0, upper_bound = n_max)\n@variable(dOpt, t)\n@objective(dOpt, Max, t)\n@constraint(dOpt, sum(np) <= n)\nE = V * LinearAlgebra.diagm(0 => np ./ n) * V'\n@constraint(dOpt, [t; 1; triangle_vec(E)] in MOI.LogDetConeTriangle(q))\noptimize!(dOpt)\n@assert is_solved_and_feasible(dOpt)\nobjective_value(dOpt)","category":"page"},{"location":"tutorials/conic/experiment_design/","page":"Experiment design","title":"Experiment design","text":"value.(np)","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/nonlinear/#Nonlinear-Modeling","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP has support for nonlinear (convex and nonconvex) optimization problems. JuMP is able to automatically provide exact, sparse second-order derivatives to solvers. This information can improve solver accuracy and performance.","category":"page"},{"location":"manual/nonlinear/#Set-a-nonlinear-objective","page":"Nonlinear Modeling","title":"Set a nonlinear objective","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use @objective to set a nonlinear objective.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @objective(model, Min, exp(x[1]) - sqrt(x[2]))\nexp(x[1]) - sqrt(x[2])","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"To modify a nonlinear objective, call @objective again.","category":"page"},{"location":"manual/nonlinear/#Add-a-nonlinear-constraint","page":"Nonlinear Modeling","title":"Add a nonlinear constraint","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use @constraint to add a nonlinear constraint.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> @constraint(model, exp(x[1]) <= 1)\nexp(x[1]) - 1.0 ≤ 0\n\njulia> @constraint(model, con[i = 1:2], 2^x[i] >= i)\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarNonlinearFunction, MathOptInterface.GreaterThan{Float64}}, ScalarShape}}:\n con[1] : (2.0 ^ x[1]) - 1.0 ≥ 0\n con[2] : (2.0 ^ x[2]) - 2.0 ≥ 0","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Delete a nonlinear constraint using delete:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> delete(model, con[1])","category":"page"},{"location":"manual/nonlinear/#Add-a-parameter","page":"Nonlinear Modeling","title":"Add a parameter","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Some solvers have explicit support for parameters, which are constants in the model that can be efficiently updated between solves.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP implements parameters by a decision variable constrained on creation to the Parameter set.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @variable(model, p[i = 1:2] in Parameter(i))\n2-element Vector{VariableRef}:\n p[1]\n p[2]\n\njulia> parameter_value(p[1])\n1.0\n\njulia> set_parameter_value(p[1], 3.5)\n\njulia> @objective(model, Max, log(p[1] * x + p[2]))\nlog(p[1]*x + p[2])","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"See Parameters for more information on how to create and manage parameters.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Parameters are most useful when solving nonlinear models in a sequence:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP, Ipopt\nmodel = Model(Ipopt.Optimizer);\nset_silent(model)\n@variable(model, x)\n@variable(model, p in Parameter(1.0))\n@objective(model, Min, (x - p)^2)\noptimize!(model)\nvalue(x)\nset_parameter_value(p, 5.0)\noptimize!(model)\nvalue(x)","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Using parameters can be faster than creating a new model from scratch with updated data because JuMP is able to avoid repeating a number of steps in processing the model before handing it off to the solver.","category":"page"},{"location":"manual/nonlinear/#Create-a-nonlinear-expression","page":"Nonlinear Modeling","title":"Create a nonlinear expression","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use @expression to create nonlinear expression objects:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> expr = @expression(model, exp(x[1]) + sqrt(x[2]))\nexp(x[1]) + sqrt(x[2])\n\njulia> my_anon_expr = @expression(model, [i = 1:2], sin(x[i]))\n2-element Vector{NonlinearExpr}:\n sin(x[1])\n sin(x[2])\n\njulia> @expression(model, my_expr[i = 1:2], sin(x[i]))\n2-element Vector{NonlinearExpr}:\n sin(x[1])\n sin(x[2])","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"A NonlinearExpr can be used in @objective, @constraint, and even nested in other @expressions.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @objective(model, Min, expr^2 + 1)\n((exp(x[1]) + sqrt(x[2])) ^ 2.0) + 1.0\n\njulia> @constraint(model, [i = 1:2], my_expr[i] <= i)\n2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarNonlinearFunction, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n sin(x[1]) - 1.0 ≤ 0\n sin(x[2]) - 2.0 ≤ 0\n\njulia> @expression(model, nested[i = 1:2], sin(my_expr[i]))\n2-element Vector{NonlinearExpr}:\n sin(sin(x[1]))\n sin(sin(x[2]))","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use value to query the value of a nonlinear expression:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> set_start_value(x[1], 1.0)\n\njulia> value(start_value, nested[1])\n0.7456241416655579\n\njulia> sin(sin(1.0))\n0.7456241416655579","category":"page"},{"location":"manual/nonlinear/#Automatic-differentiation","page":"Nonlinear Modeling","title":"Automatic differentiation","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP computes first- and second-order derivatives using sparse reverse-mode automatic differentiation. For details, see ReverseAD.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For a tutorial on how to construct and query the derivatives, see Computing Hessians","category":"page"},{"location":"manual/nonlinear/#Nonlinear-expressions-in-detail","page":"Nonlinear Modeling","title":"Nonlinear expressions in detail","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear expressions in JuMP are represented by a NonlinearExpr object.","category":"page"},{"location":"manual/nonlinear/#Constructors","page":"Nonlinear Modeling","title":"Constructors","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear expressions can be created using the NonlinearExpr constructors:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> expr = NonlinearExpr(:sin, Any[x])\nsin(x)","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"or via operator overloading:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> expr = sin(x)\nsin(x)","category":"page"},{"location":"manual/nonlinear/#Supported-arguments","page":"Nonlinear Modeling","title":"Supported arguments","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear expressions can contain a mix of numbers, AffExpr, QuadExpr, and other NonlinearExpr:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> aff = x + 1;\n\njulia> quad = x^2 + x;\n\njulia> expr = cos(x) * sin(quad) + aff\n(cos(x) * sin(x² + x)) + (x + 1)","category":"page"},{"location":"manual/nonlinear/#Supported-operators","page":"Nonlinear Modeling","title":"Supported operators","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The list of supported operators may vary between solvers. Given an optimizer, query the list of supported operators using MOI.ListOfSupportedNonlinearOperators:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> import Ipopt\n\njulia> import MathOptInterface as MOI\n\njulia> MOI.get(Ipopt.Optimizer(), MOI.ListOfSupportedNonlinearOperators())\n85-element Vector{Symbol}:\n :+\n :-\n :abs\n :sqrt\n :cbrt\n :abs2\n :inv\n :log\n :log10\n :log2\n ⋮\n :min\n :max\n :&&\n :||\n :<=\n :(==)\n :>=\n :<\n :>","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"In some univariate cases, the operator is defined in SpecialFunctions.jl. To use these functions, you must explicitly import SpecialFunctions.jl","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> import Ipopt\n\njulia> op = MOI.get(Ipopt.Optimizer(), MOI.ListOfSupportedNonlinearOperators());\n\njulia> :erfcx in op\ntrue\n\njulia> :dawson in op\ntrue\n\njulia> import SpecialFunctions\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @expression(model, SpecialFunctions.erfcx(x))\nerfcx(x)\n\njulia> @expression(model, SpecialFunctions.dawson(x))\ndawson(x)","category":"page"},{"location":"manual/nonlinear/#Limitations","page":"Nonlinear Modeling","title":"Limitations","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Some nonlinear expressions cannot be created via operator overloading. For example, to minimize the likelihood of bugs in user-code, we have not overloaded comparisons such as < and >= between JuMP objects:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> x < 1\nERROR: Cannot evaluate `<` between a variable and a number.\n[...]","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Instead, wrap the expression in the @expression macro:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> expr = @expression(model, x < 1)\nx < 1","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For technical reasons, other operators that are not overloaded include ||, &&, and ifelse.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> expr = @expression(model, ifelse(x < -1 || x >= 1, x^2, 0.0))\nifelse((x < -1) || (x >= 1), x², 0.0)","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"As an alternative, use the JuMP.op_ functions, which fallback to the various comparison and logical operators:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> expr = op_ifelse(\n           op_or(op_strictly_less_than(x, -1), op_greater_than_or_equal_to(x, 1)),\n           x^2,\n           0.0,\n       )\nifelse((x < -1) || (x >= 1), x², 0.0)","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The available functions are:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP function Julia function\nop_ifelse ifelse\nop_and &&\nop_or ||\nop_greater_than_or_equal_to >=\nop_less_than_or_equal_to <=\nop_equal_to ==\nop_strictly_greater_than >\nop_strictly_less_than <","category":"page"},{"location":"manual/nonlinear/#Fields","page":"Nonlinear Modeling","title":"Fields","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Each NonlinearExpr has two fields.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The .head field is a Symbol that represents the operator being called:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> expr.head\n:sin","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The .args field is a Vector{Any} containing the arguments to the operator:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> expr.args\n1-element Vector{Any}:\n x","category":"page"},{"location":"manual/nonlinear/#Forcing-nonlinear-expressions","page":"Nonlinear Modeling","title":"Forcing nonlinear expressions","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The JuMP macros and operator overloading will preferentially build affine (GenericAffExpr) and quadratic (GenericQuadExpr) expressions instead of GenericNonlinearExpr. For example:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> f = (x - 0.1)^2\nx² - 0.2 x + 0.010000000000000002\n\njulia> typeof(f)\nQuadExpr (alias for GenericQuadExpr{Float64, GenericVariableRef{Float64}})","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"To override this behavior, use the @force_nonlinear macro:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> g = @force_nonlinear((x - 0.1)^2)\n(x - 0.1) ^ 2\n\njulia> typeof(g)\nNonlinearExpr (alias for GenericNonlinearExpr{GenericVariableRef{Float64}})","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nUse this macro only if necessary. See the docstring of @force_nonlinear for more details on when you should use it.","category":"page"},{"location":"manual/nonlinear/#Function-tracing","page":"Nonlinear Modeling","title":"Function tracing","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear expressions can be constructed using function tracing. Function tracing is when you call a regular Julia function with JuMP variables as arguments and the function builds a nonlinear expression via operator overloading. For example:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP\nmodel = Model();\n@variable(model, x[1:2]);\nf(x::Vector{VariableRef}) = 2 * sin(x[1]^2) + sqrt(x[2])\ny = f(x)\ntypeof(y)\n@objective(model, Max, f(x))","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Function tracing supports functions which return vectors or arrays of NonlinearExpr:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP\nmodel = Model();\n@variable(model, x[1:2]);\nf(x::Vector{VariableRef}) = sqrt.(x)\ny = f(x)\ntypeof(y)\n@constraint(model, f(x) .<= 2)\n@objective(model, Max, sum(f(x)))","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Because function tracing uses operator overloading, there are many functions for which it will not work. For example:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> using JuMP\n\njulia> model = Model();\n\njulia> @variable(model, x[1:2]);\n\njulia> f(x::Vector{VariableRef}) = x[1] > 1 ? 0 : x[2]\nf (generic function with 1 method)\n\njulia> f(x)\nERROR: Cannot evaluate `>` between a variable and a number.\n[...]","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"In these cases, you should define a User-defined operator using the @operator macro.","category":"page"},{"location":"manual/nonlinear/#jump_user_defined_operators","page":"Nonlinear Modeling","title":"User-defined operators","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"In addition to a standard list of univariate and multivariate operators recognized by the MOI.Nonlinear submodule, JuMP supports user-defined operators, which let you represent nonlinear functions that cannot (or should not) be traced, for example, because they rely on non-Julia subroutines.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nUser-defined operators must return a scalar output. For a work-around, see User-defined operators with vector outputs.","category":"page"},{"location":"manual/nonlinear/#Add-an-operator","page":"Nonlinear Modeling","title":"Add an operator","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Add a user-defined operator using the @operator macro:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP\nsquare(x) = x^2\nf(x, y) = (x - 1)^2 + (y - 2)^2\nmodel = Model();\n@operator(model, op_square, 1, square)\n@operator(model, op_f, 2, f)\n@variable(model, x[1:2]);\n@objective(model, Min, op_f(x[1], op_square(x[2])))","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The arguments to @operator are:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The model to which the operator is added.\nA Julia symbol object which serves as the name of the user-defined operator in JuMP expressions. This name must not be the same as that of the function.\nThe number of scalar input arguments that the function takes.\nA Julia method which computes the function.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nUser-defined operators cannot be deleted.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"You can obtain a reference to the operator using the model[:key] syntax:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP\nsquare(x) = x^2\nmodel = Model();\n@operator(model, op_square, 1, square)\nop_square_2 = model[:op_square]","category":"page"},{"location":"manual/nonlinear/#Automatic-differentiation-2","page":"Nonlinear Modeling","title":"Automatic differentiation","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP computes first- and second-order derivatives of expressions using ReverseAD, which implements sparse reverse-mode automatic differentiation. However, because ReverseAD requires the algebraic expression as input, JuMP cannot use ReverseAD to differentiate user-defined operators.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Instead, unless Gradients and Hessians are explicitly provided, user-defined operators must support automatic differentiation by ForwardDiff.jl.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The use of FowardDiff.jl has two important implications:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"ForwardDiff.jl supports only a limited subset of Julia. If you encounter an error adding the operator, see Common mistakes when writing a user-defined operator.\nDifferentiating operators with many arguments is slow. In general, you should try to keep the number of arguments to less than 100, and ideally, to less than 10.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Because of the use of ForwardDiff, in most cases, you should prefer to use function tracing instead of defining a user-defined operator.","category":"page"},{"location":"manual/nonlinear/#Add-an-operator-without-macros","page":"Nonlinear Modeling","title":"Add an operator without macros","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The @operator macro is syntactic sugar for add_nonlinear_operator. Thus, the non-macro version of the preceding example is:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP\nsquare(x) = x^2\nf(x, y) = (x - 1)^2 + (y - 2)^2\nmodel = Model();\nop_square = add_nonlinear_operator(model, 1, square; name = :op_square)\nmodel[:op_square] = op_square\nop_f = add_nonlinear_operator(model, 2, f; name = :op_f)\nmodel[:op_f] = op_f\n@variable(model, x[1:2]);\n@objective(model, Min, op_f(x[1], op_square(x[2])))","category":"page"},{"location":"manual/nonlinear/#Operators-with-the-same-name-as-an-existing-function","page":"Nonlinear Modeling","title":"Operators with the same name as an existing function","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"A common error encountered is the following:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> using JuMP\n\njulia> model = Model();\n\njulia> f(x) = x^2\nf (generic function with 1 method)\n\njulia> @operator(model, f, 1, f)\nERROR: Unable to add the nonlinear operator `:f` with the same name as\nan existing function.\n[...]","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This error occurs because @operator(model, f, 1, f) is equivalent to:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> f = add_nonlinear_operator(model, 1, f; name = :f)","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"but f already exists as a Julia function.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"If you evaluate the function without adding it as an operator, JuMP will trace the function using operator overloading:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @variable(model, x);\n\njulia> f(x)\nx²","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"To force JuMP to treat f as a user-defined operator and not trace it, add the operator using add_nonlinear_operator and define a new method which manually creates a NonlinearExpr:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> _ = add_nonlinear_operator(model, 1, f; name = :f)\nNonlinearOperator(f, :f)\n\njulia> f(x::AbstractJuMPScalar) = NonlinearExpr(:f, Any[x])\nf (generic function with 2 methods)\n\njulia> @expression(model, log(f(x)))\nlog(f(x))","category":"page"},{"location":"manual/nonlinear/#Gradients-and-Hessians","page":"Nonlinear Modeling","title":"Gradients and Hessians","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"By default, JuMP will use automatic differentiation to compute the gradient and Hessian of user-defined operators. If your function is not amenable to the default automatic differentiation, or you can compute analytic derivatives, you may pass additional arguments to @operator to compute the first- and second-derivatives.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"tip: Tip\nThe tutorial Automatic differentiation of user-defined operators has examples of how to use third-party Julia packages to compute automatic derivatives.","category":"page"},{"location":"manual/nonlinear/#Univariate-functions","page":"Nonlinear Modeling","title":"Univariate functions","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For univariate functions, a gradient function ∇f returns a number that represents the first-order derivative. You may, in addition, pass a third function which returns a number representing the second-order derivative:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP\nf(x) = x^2\n∇f(x) = 2x\n∇²f(x) = 2\nmodel = Model();\n@operator(model, op_f, 1, f, ∇f, ∇²f)  # Providing ∇²f is optional\n@variable(model, x)\n@objective(model, Min, op_f(x))","category":"page"},{"location":"manual/nonlinear/#Multivariate-functions","page":"Nonlinear Modeling","title":"Multivariate functions","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For multivariate functions, the gradient function ∇f must take an AbstractVector as the first argument that is filled in-place. The Hessian function, ∇²f, must take an AbstractMatrix as the first argument, the lower-triangular of which is filled in-place:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP\nf(x...) = (1 - x[1])^2 + 100 * (x[2] - x[1]^2)^2\nfunction ∇f(g::AbstractVector{T}, x::T...) where {T}\n    g[1] = 400 * x[1]^3 - 400 * x[1] * x[2] + 2 * x[1] - 2\n    g[2] = 200 * (x[2] - x[1]^2)\n    return\nend\nfunction ∇²f(H::AbstractMatrix{T}, x::T...) where {T}\n    H[1, 1] = 1200 * x[1]^2 - 400 * x[2] + 2\n    # H[1, 2] = -400 * x[1]  <-- Not needed. Fill the lower-triangular only.\n    H[2, 1] = -400 * x[1]\n    H[2, 2] = 200.0\n    return\nend\nmodel = Model();\n@operator(model, rosenbrock, 2, f, ∇f, ∇²f)  # Providing ∇²f is optional\n@variable(model, x[1:2])\n@objective(model, Min, rosenbrock(x[1], x[2]))","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"You may assume the Hessian matrix H is initialized with zeros, and because H is symmetric, you need only to fill in the non-zero lower-triangular terms. The matrix type passed in as H depends on the automatic differentiation system, so make sure the first argument to the Hessian function supports an AbstractMatrix (it may be something other than Matrix{Float64}). Moreover, you may assume only that H supports size(H) and setindex!. Finally, the matrix is treated as dense, so the performance will be poor on functions with high-dimensional input.","category":"page"},{"location":"manual/nonlinear/#User-defined-operators-with-vector-inputs","page":"Nonlinear Modeling","title":"User-defined operators with vector inputs","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"User-defined operators which take vectors as input arguments (for example, f(x::Vector)) are not supported. Instead, use Julia's splatting syntax to create a function with scalar arguments. For example, instead of:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"f(x::Vector) = sum(x[i]^i for i in 1:length(x))","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"define:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"f(x...) = sum(x[i]^i for i in 1:length(x))","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Another approach is to define the splatted function as an anonymous function:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP\nmodel = Model();\n@variable(model, x[1:5])\nf(x::Vector) = sum(x[i]^i for i in 1:length(x))\n@operator(model, op_f, 5, (x...) -> f(collect(x)))\n@objective(model, Min, op_f(x...))","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"If the operator takes several vector inputs, write a function that takes the splatted arguments and reconstructs the required vector inputs:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP\nmodel = Model();\n@variable(model, x[1:2]);\n@variable(model, y[1:2]);\n@variable(model, z);\nf(x::Vector, y::Vector, z) = sum((x[i] * y[i])^z for i in 1:2)\nf(x, y, z)\nf_splat(args...) = f(collect(args[1:2]), collect(args[3:4]), args[5])\nf_splat(x..., y..., z)\n@operator(model, op_f, 5, f_splat)\n@objective(model, Min, op_f(x..., y..., z))","category":"page"},{"location":"manual/nonlinear/#Common-mistakes-when-writing-a-user-defined-operator","page":"Nonlinear Modeling","title":"Common mistakes when writing a user-defined operator","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP uses ForwardDiff.jl to compute the first-order derivatives of user-defined operators. ForwardDiff has a number of limitations that you should be aware of when writing user-defined operators.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The rest of this section provides debugging advice and explains some common mistakes.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nGet an error like No method matching Float64(::ForwardDiff.Dual)? Read this section.","category":"page"},{"location":"manual/nonlinear/#Debugging","page":"Nonlinear Modeling","title":"Debugging","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"If you add an operator that does not support ForwardDiff, a long error message will be printed. You can review the stacktrace for more information, but it can often be hard to understand why and where your function is failing.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"It may be helpful to debug the operator outside of JuMP as follows.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"If the operator is univariate, do:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> import ForwardDiff\n\njulia> my_operator(a) = a^2\nmy_operator (generic function with 1 method)\n\njulia> ForwardDiff.derivative(my_operator, 1.0)\n2.0","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"If the operator is multivariate, do:","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> import ForwardDiff\n\njulia> my_operator(a, b) = a^2 + b^2\nmy_operator (generic function with 1 method)\n\njulia> ForwardDiff.gradient(x -> my_operator(x...), [1.0, 2.0])\n2-element Vector{Float64}:\n 2.0\n 4.0","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Note that even though the operator takes the splatted arguments, ForwardDiff.gradient requires a vector as input.","category":"page"},{"location":"manual/nonlinear/#Operator-calls-something-unsupported-by-ForwardDiff","page":"Nonlinear Modeling","title":"Operator calls something unsupported by ForwardDiff","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"ForwardDiff works by overloading many Julia functions for a special type ForwardDiff.Dual <: Real. If your operator attempts to call a function for which an overload has not been defined, a MethodError will be thrown.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For example, your operator cannot call external C functions, or be the optimal objective value of a JuMP model.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> import ForwardDiff\n\njulia> my_operator_bad(x) = @ccall sqrt(x::Cdouble)::Cdouble\nmy_operator_bad (generic function with 1 method)\n\njulia> ForwardDiff.derivative(my_operator_bad, 1.0)\nERROR: MethodError: no method matching Float64(::ForwardDiff.Dual{ForwardDiff.Tag{typeof(my_operator_bad), Float64}, Float64, 1})\n[...]","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Unfortunately, the list of calls supported by ForwardDiff is too large to enumerate what is an isn't allowed, so the best advice is to try and see if it works.","category":"page"},{"location":"manual/nonlinear/#Operator-does-not-accept-splatted-input","page":"Nonlinear Modeling","title":"Operator does not accept splatted input","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The operator takes f(x::Vector) as input, instead of the splatted f(x...).","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> import ForwardDiff\n\njulia> my_operator_bad(x::Vector) = sum(x[i]^2 for i in eachindex(x))\nmy_operator_bad (generic function with 1 method)\n\njulia> my_operator_good(x...) = sum(x[i]^2 for i in eachindex(x))\nmy_operator_good (generic function with 1 method)\n\njulia> ForwardDiff.gradient(x -> my_operator_bad(x...), [1.0, 2.0])\nERROR: MethodError: no method matching my_operator_bad(::ForwardDiff.Dual{ForwardDiff.Tag{var\"#5#6\", Float64}, Float64, 2}, ::ForwardDiff.Dual{ForwardDiff.Tag{var\"#5#6\", Float64}, Float64, 2})\n[...]\n\njulia> ForwardDiff.gradient(x -> my_operator_good(x...), [1.0, 2.0])\n2-element Vector{Float64}:\n 2.0\n 4.0","category":"page"},{"location":"manual/nonlinear/#Operator-assumes-Float64-as-input","page":"Nonlinear Modeling","title":"Operator assumes Float64 as input","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The operator assumes Float64 will be passed as input, but it must work for any generic Real type.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> import ForwardDiff\n\njulia> my_operator_bad(x::Float64...) = sum(x[i]^2 for i in eachindex(x))\nmy_operator_bad (generic function with 1 method)\n\njulia> my_operator_good(x::Real...) = sum(x[i]^2 for i in eachindex(x))\nmy_operator_good (generic function with 1 method)\n\njulia> ForwardDiff.gradient(x -> my_operator_bad(x...), [1.0, 2.0])\nERROR: MethodError: no method matching my_operator_bad(::ForwardDiff.Dual{ForwardDiff.Tag{var\"#5#6\", Float64}, Float64, 2}, ::ForwardDiff.Dual{ForwardDiff.Tag{var\"#5#6\", Float64}, Float64, 2})\n[...]\n\njulia> ForwardDiff.gradient(x -> my_operator_good(x...), [1.0, 2.0])\n2-element Vector{Float64}:\n 2.0\n 4.0","category":"page"},{"location":"manual/nonlinear/#Operator-allocates-Float64-storage","page":"Nonlinear Modeling","title":"Operator allocates Float64 storage","text":"","category":"section"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The operator allocates temporary storage using zeros(3) or similar. This defaults to Float64, so use zeros(T, 3) instead.","category":"page"},{"location":"manual/nonlinear/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> import ForwardDiff\n\njulia> function my_operator_bad(x::Real...)\n           # This line is problematic. zeros(n) is short for zeros(Float64, n)\n           y = zeros(length(x))\n           for i in eachindex(x)\n               y[i] = x[i]^2\n           end\n           return sum(y)\n       end\nmy_operator_bad (generic function with 1 method)\n\njulia> function my_operator_good(x::T...) where {T<:Real}\n           y = zeros(T, length(x))\n           for i in eachindex(x)\n               y[i] = x[i]^2\n           end\n           return sum(y)\n       end\nmy_operator_good (generic function with 1 method)\n\njulia> ForwardDiff.gradient(x -> my_operator_bad(x...), [1.0, 2.0])\nERROR: MethodError: no method matching Float64(::ForwardDiff.Dual{ForwardDiff.Tag{var\"#1#2\", Float64}, Float64, 2})\n[...]\n\njulia> ForwardDiff.gradient(x -> my_operator_good(x...), [1.0, 2.0])\n2-element Vector{Float64}:\n 2.0\n 4.0","category":"page"},{"location":"moi/background/naming_conventions/","page":"Naming conventions","title":"Naming conventions","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/background/naming_conventions.md\"","category":"page"},{"location":"moi/background/naming_conventions/","page":"Naming conventions","title":"Naming conventions","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/background/naming_conventions/#Naming-conventions","page":"Naming conventions","title":"Naming conventions","text":"","category":"section"},{"location":"moi/background/naming_conventions/","page":"Naming conventions","title":"Naming conventions","text":"MOI follows several conventions for naming functions and structures. These should also be followed by packages extending MOI.","category":"page"},{"location":"moi/background/naming_conventions/#Sets","page":"Naming conventions","title":"Sets","text":"","category":"section"},{"location":"moi/background/naming_conventions/","page":"Naming conventions","title":"Naming conventions","text":"Sets encode the structure of constraints. Their names should follow the following conventions:","category":"page"},{"location":"moi/background/naming_conventions/","page":"Naming conventions","title":"Naming conventions","text":"Abstract types in the set hierarchy should begin with Abstract and end in Set, for example, AbstractScalarSet, AbstractVectorSet.\nVector-valued conic sets should end with Cone, for example, NormInfinityCone, SecondOrderCone.\nVector-valued Cartesian products should be plural and not end in Cone, for example, Nonnegatives, not NonnegativeCone.\nMatrix-valued conic sets should provide two representations: ConeSquare and ConeTriangle, for example, RootDetConeTriangle and RootDetConeSquare. See Matrix cones for more details.\nScalar sets should be singular, not plural, for example, Integer, not Integers.\nAs much as possible, the names should follow established conventions in the domain where this set is used: for instance, convex sets should have names close to those of CVX, and constraint-programming sets should follow MiniZinc's constraints.","category":"page"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"EditURL = \"https://github.com/oxfordcontrol/CDCS.jl/blob/6d165e8e8f59b14e36e99c8efb19f0e775bbd292/README.md\"","category":"page"},{"location":"packages/CDCS/#CDCS.jl","page":"oxfordcontrol/CDCS.jl","title":"CDCS.jl","text":"","category":"section"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"CDCS.jl is a wrapper for the CDCS solver. ","category":"page"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"The wrapper has two components:","category":"page"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"an exported cdcs function that is a thin wrapper on top of the cdcs MATLAB function\nan interface to MathOptInterface","category":"page"},{"location":"packages/CDCS/#License","page":"oxfordcontrol/CDCS.jl","title":"License","text":"","category":"section"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"CDCS.jl is licensed under the MIT license.","category":"page"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"The underlying solver oxfordcontrol/CDCS is licensed under the LGPL v3 license.","category":"page"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"In addition, CDCS requires an installation of MATLAB, which is a closed-source commercial product for which you must obtain a license.","category":"page"},{"location":"packages/CDCS/#Installation","page":"oxfordcontrol/CDCS.jl","title":"Installation","text":"","category":"section"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"First, make sure that you satisfy the requirements of the MATLAB.jl Julia package and that the CDCS software is installed in your MATLAB™ installation.","category":"page"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"Then, install CDCS.jl using Pkg.add:","category":"page"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"import Pkg\nPkg.add(\"CDCS\")","category":"page"},{"location":"packages/CDCS/#Use-with-JuMP","page":"oxfordcontrol/CDCS.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"To use CDCS with JuMP, do:","category":"page"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"using JuMP, CDCS\nmodel = Model(CDCS.Optimizer)\nset_attribute(model, \"verbose\", 0)","category":"page"},{"location":"packages/CDCS/#Troubleshooting","page":"oxfordcontrol/CDCS.jl","title":"Troubleshooting","text":"","category":"section"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"If you get the error:","category":"page"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"Undefined function or variable 'cdcs'.\n\nError using save\nVariable 'jx_cdcs_arg_out_1' not found.\n\nLinear Programming example: Error During Test at /home/blegat/.julia/dev/CDCS/test/lp.jl:5\n  Got exception outside of a @test\n  MATLAB.MEngineError(\"failed to get variable jx_cdcs_arg_out_1 from MATLAB session\")\n  Stacktrace:\n    [1] get_mvariable(session::MATLAB.MSession, name::Symbol)\n      @ MATLAB ~/.julia/packages/MATLAB/SVjnA/src/engine.jl:164\n    [2] mxcall(::MATLAB.MSession, ::Symbol, ::Int64, ::Matrix{Float64}, ::Vararg{Any})\n      @ MATLAB ~/.julia/packages/MATLAB/SVjnA/src/engine.jl:297\n    [3] mxcall\n      @ ~/.julia/packages/MATLAB/SVjnA/src/engine.jl:317 [inlined]\n    [4] cdcs(A::Matrix{Float64}, b::Vector{Float64}, c::Vector{Float64}, K::CDCS.Cone; kws::Base.Pairs{Symbol, Int64, Tuple{Symbol}, NamedTuple{(:verbose,), Tuple{Int64}}})","category":"page"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"The error means that we could not find the cdcs function with one output argument using the MATLAB C API.","category":"page"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"This most likely means that you did not add CDCS to the MATLAB's path (that is, the toolbox/local/pathdef.m file).","category":"page"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"If modifying toolbox/local/pathdef.m does not work, the following should work where /path/to/CDCS/ is the directory where the CDCS folder is located:","category":"page"},{"location":"packages/CDCS/","page":"oxfordcontrol/CDCS.jl","title":"oxfordcontrol/CDCS.jl","text":"julia> using MATLAB\n\njulia> cd(\"/path/to/CDCS/\") do\n           mat\"cdcsInstall\"\n       end\n\njulia> mat\"savepath\"","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"EditURL = \"https://github.com/jump-dev/MultiObjectiveAlgorithms.jl/blob/v1.3.2/README.md\"","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"<img src=\"https://raw.githubusercontent.com/jump-dev/MultiObjectiveAlgorithms.jl/master/moa.png?raw=true\" alt=\"An image of the Moa bird. Licensed into the Public Domain by https://freesvg.org/moa\" width=\"100px\"/>","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/#MultiObjectiveAlgorithms.jl","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"MultiObjectiveAlgorithms.jl","text":"","category":"section"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"MultiObjectiveAlgorithms.jl (MOA) is a collection of algorithms for multi-objective optimization.","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/#License","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"License","text":"","category":"section"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"MultiObjectiveAlgorithms.jl is licensed under the MPL 2.0 License.","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/#Installation","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"Installation","text":"","category":"section"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"Install MOA using Pkg.add:","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"import Pkg\nPkg.add(\"MultiObjectiveAlgorithms\")","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/#Use-with-JuMP","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"Use MultiObjectiveAlgorithms with JuMP as follows:","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"using JuMP\nimport HiGHS\nimport MultiObjectiveAlgorithms as MOA\nmodel = JuMP.Model(() -> MOA.Optimizer(HiGHS.Optimizer))\nset_attribute(model, MOA.Algorithm(), MOA.Dichotomy())\nset_attribute(model, MOA.SolutionLimit(), 4)","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"Replace HiGHS.Optimizer with an optimizer capable of solving a single-objective instance of your optimization problem.","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"You may set additional optimizer attributes, the supported attributes depend on the choice of solution algorithm.","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/#Algorithm","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"Algorithm","text":"","category":"section"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"Set the algorithm using the MOA.Algorithm() attribute.","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"The value must be one of the algorithms supported by MOA:","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"MOA.Chalmet()\nMOA.Dichotomy()\nMOA.DominguezRios()\nMOA.EpsilonConstraint()\nMOA.Hierarchical()\nMOA.KirlikSayin()\nMOA.Lexicographic() [default]\nMOA.TambyVanderpooten()","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"Consult their docstrings for details.","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/#Other-optimizer-attributes","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"Other optimizer attributes","text":"","category":"section"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"There are a number of optimizer attributes supported by the algorithms in MOA.","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"Each algorithm supports only a subset of the attributes. Consult the algorithm's docstring for details on which attributes it supports, and how it uses them in the solution process.","category":"page"},{"location":"packages/MultiObjectiveAlgorithms/","page":"jump-dev/MultiObjectiveAlgorithms.jl","title":"jump-dev/MultiObjectiveAlgorithms.jl","text":"MOA.EpsilonConstraintStep()\nMOA.LexicographicAllPermutations()\nMOA.ObjectiveAbsoluteTolerance(index::Int)\nMOA.ObjectivePriority(index::Int)\nMOA.ObjectiveRelativeTolerance(index::Int)\nMOA.ObjectiveWeight(index::Int)\nMOA.SolutionLimit()\nMOI.TimeLimitSec()","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"EditURL = \"multi_commodity_network.jl\"","category":"page"},{"location":"tutorials/linear/multi_commodity_network/#The-network-multi-commodity-flow-problem","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"","category":"section"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"This tutorial is a variation of The multi-commodity flow problem where the graph is a network instead of a bipartite graph.","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"The purpose of this tutorial is to demonstrate a style of modeling that uses relational algebra.","category":"page"},{"location":"tutorials/linear/multi_commodity_network/#Required-packages","page":"The network multi-commodity flow problem","title":"Required packages","text":"","category":"section"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"using JuMP\nimport DataFrames\nimport HiGHS\nimport SQLite\nimport SQLite.DBInterface\nimport Test","category":"page"},{"location":"tutorials/linear/multi_commodity_network/#Formulation","page":"The network multi-commodity flow problem","title":"Formulation","text":"","category":"section"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"The network multi-commondity flow problem is an extension of the The multi-commodity flow problem, where instead of having a bipartite graph of supply and demand nodes, the graph can contains a set of nodes, i in mathcalN , which each have a (potentially zero) supply capacity, u^s_ip, and (potentially zero) a demand, d_ip for each commodity p in P. The nodes are connected by a set of edges (i j) in mathcalE, which have a shipment cost c^x_ijp and a total flow capacity of u^x_ij.","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"Our take is to choose an optimal supply for each node s_ip, as well as the optimal transshipment x_ijp that minimizes the total cost.","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"The mathematical formulation is:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"beginaligned\nmin   sum_(ij)inmathcalE p in P c^x_ijp x_ijp + sum_iinmathcalN p in P c^s_ip s_ip \nst   s_ip + sum_(j i) in mathcalE x_jip - sum_(ij) in mathcalE x_ijp = d_ip  forall i in mathcalN p in P \n           x_ijp ge 0            forall (i j) in mathcalE p in P \n           sum_p in P x_ijp le u^x_ij            forall (i j) in mathcalE \n           0 le s_ip le u^s_ip  forall i in mathcalN p in P\nendaligned","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"The purpose of this tutorial is to demonstrate how this model can be built using relational algebra instead of a direct math-to-code translation of the summations.","category":"page"},{"location":"tutorials/linear/multi_commodity_network/#Data","page":"The network multi-commodity flow problem","title":"Data","text":"","category":"section"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"For the purpose of this tutorial, the JuMP repository contains an example database called commodity_nz.db:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"filename = joinpath(@__DIR__, \"commodity_nz.db\");\nnothing #hide","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"To run locally, download commodity_nz.db and update filename appropriately.","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"Load the database using SQLite.DB:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"db = SQLite.DB(filename)","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"A quick way to see the schema of the database is via SQLite.tables:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"SQLite.tables(db)","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"We interact with the database by executing queries and then loading the results into a DataFrame:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"function get_table(db, table)\n    query = DBInterface.execute(db, \"SELECT * FROM $table\")\n    return DataFrames.DataFrame(query)\nend","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"The shipping table contains the set of arcs and their distances:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"df_shipping = get_table(db, \"shipping\")","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"The products table contains the shipping cost per kilometer of each product:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"df_products = get_table(db, \"products\")","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"The supply table contains the supply capacity of each node, as well as the cost:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"df_supply = get_table(db, \"supply\")","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"The demand table contains the demand of each node:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"df_demand = get_table(db, \"demand\")","category":"page"},{"location":"tutorials/linear/multi_commodity_network/#JuMP-formulation","page":"The network multi-commodity flow problem","title":"JuMP formulation","text":"","category":"section"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"We start by creating a model and our decision variables:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"For the shipping decisions, we create a new column in df_shipping called x_flow, which has one non-negative decision variable for each row:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"df_shipping.x_flow = @variable(model, x[1:size(df_shipping, 1)] >= 0)\ndf_shipping","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"For the supply, we add a variable to each row, and then set the upper bound to the capacity of each supply node:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"df_supply.x_supply = @variable(model, s[1:size(df_supply, 1)] >= 0)\nset_upper_bound.(df_supply.x_supply, df_supply.capacity)\ndf_supply","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"Our objective is to minimize the shipping cost plus the supply cost. To compute the flow cost, we need to join the shipping table, which contains distance_km with the products table, which contains cost_per_km:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"df_cost = DataFrames.leftjoin(df_shipping, df_products; on = [:product])\ndf_cost.flow_cost = df_cost.cost_per_km .* df_cost.distance_km\ndf_cost","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"Then we can use linear algebra to compute the inner product between two columns:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"@objective(\n    model,\n    Min,\n    df_cost.flow_cost' * df_shipping.x_flow +\n    df_supply.cost' * df_supply.x_supply\n);\nnothing #hide","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"For the flow capacities on each arc, we use DataFrames.groupby to partition the flow variables based on :origin and :destination, and then we constrain their sum to be less than a fixed capacity.","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"capacity = 30\nfor df in DataFrames.groupby(df_shipping, [:origin, :destination])\n    @constraint(model, sum(df.x_flow) <= capacity)\nend","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"For each node in the graph, we need to compute a mass balance constraint which says that for each product, the supply, plus the flow into the node, and less the flow out of the node is equal to the demand.","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"We can compute an expression for the flow out of each node using DataFrames.groupby on the origin and product columns of the df_shipping table:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"df_flow_out = DataFrames.DataFrame(\n    (node = i.origin, product = i.product, x_flow_out = sum(df.x_flow)) for\n    (i, df) in pairs(DataFrames.groupby(df_shipping, [:origin, :product]))\n)","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"We can compute an expression for the flow into each node using DataFrames.groupby on the destination and product columns of the df_shipping table:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"df_flow_in = DataFrames.DataFrame(\n    (node = i.destination, product = i.product, x_flow_in = sum(df.x_flow))\n    for (i, df) in\n    pairs(DataFrames.groupby(df_shipping, [:destination, :product]))\n)","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"We can join the two tables together using DataFrames.outerjoin. We need to use outerjoin here because there might be missing rows.","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"df = DataFrames.outerjoin(df_flow_in, df_flow_out; on = [:node, :product])","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"Next, we need to join the supply column:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"df = DataFrames.leftjoin(\n    df,\n    DataFrames.select(df_supply, [:origin, :product, :x_supply]);\n    on = [:node => :origin, :product],\n)","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"and then the demand column","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"df = DataFrames.leftjoin(\n    df,\n    DataFrames.select(df_demand, [:destination, :product, :demand]);\n    on = [:node => :destination, :product],\n)","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"Now we're ready to add our mass balance constraint. Because some rows contain missing values, we need to use coalesce to convert any missing into a numeric value:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"@constraint(\n    model,\n    [r in eachrow(df)],\n    coalesce(r.x_supply, 0.0) + coalesce(r.x_flow_in, 0.0) -\n    coalesce(r.x_flow_out, 0.0) == coalesce(r.demand, 0.0),\n);\nnothing #hide","category":"page"},{"location":"tutorials/linear/multi_commodity_network/#Solution","page":"The network multi-commodity flow problem","title":"Solution","text":"","category":"section"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"Finally, we can optimize the model:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"optimize!(model)\nTest.@test is_solved_and_feasible(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"update the solution in the DataFrames:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"df_shipping.x_flow = value.(df_shipping.x_flow)\ndf_supply.x_supply = value.(df_supply.x_supply);\nnothing #hide","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"and display the optimal solution for flows:","category":"page"},{"location":"tutorials/linear/multi_commodity_network/","page":"The network multi-commodity flow problem","title":"The network multi-commodity flow problem","text":"DataFrames.select(\n    filter!(row -> row.x_flow > 0.0, df_shipping),\n    [:origin, :destination, :product, :x_flow],\n)","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/reference/standard_form.md\"","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/standard_form/#Standard-form","page":"Standard form","title":"Standard form","text":"","category":"section"},{"location":"moi/reference/standard_form/#Functions","page":"Standard form","title":"Functions","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"AbstractFunction\noutput_dimension\nconstant","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractFunction","page":"Standard form","title":"MathOptInterface.AbstractFunction","text":"AbstractFunction\n\nAbstract supertype for function objects.\n\nRequired methods\n\nAll functions must implement:\n\nBase.copy\nBase.isapprox\nconstant\n\nAbstract subtypes of AbstractFunction may require additional methods to be implemented.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.output_dimension","page":"Standard form","title":"MathOptInterface.output_dimension","text":"output_dimension(f::AbstractFunction)\n\nReturn 1 if f is an AbstractScalarFunction, or the number of output components if f is an AbstractVectorFunction.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.constant","page":"Standard form","title":"MathOptInterface.constant","text":"constant(f::AbstractFunction[, ::Type{T}]) where {T}\n\nReturns the constant term of a scalar-valued function, or the constant vector of a vector-valued function.\n\nIf f is untyped and T is provided, returns zero(T).\n\n\n\n\n\nconstant(set::Union{EqualTo,GreaterThan,LessThan,Parameter})\n\nReturns the constant term of the set set.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> MOI.constant(MOI.GreaterThan(1.0))\n1.0\n\njulia> MOI.constant(MOI.LessThan(2.5))\n2.5\n\njulia> MOI.constant(MOI.EqualTo(3))\n3\n\njulia> MOI.constant(MOI.Parameter(4.5))\n4.5\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#Scalar-functions","page":"Standard form","title":"Scalar functions","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"AbstractScalarFunction\nVariableIndex\nScalarAffineTerm\nScalarAffineFunction\nScalarQuadraticTerm\nScalarQuadraticFunction\nScalarNonlinearFunction","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractScalarFunction","page":"Standard form","title":"MathOptInterface.AbstractScalarFunction","text":"abstract type AbstractScalarFunction <: AbstractFunction\n\nAbstract supertype for scalar-valued AbstractFunctions.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VariableIndex","page":"Standard form","title":"MathOptInterface.VariableIndex","text":"VariableIndex\n\nA type-safe wrapper for Int64 for use in referencing variables in a model. To allow for deletion, indices need not be consecutive.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ScalarAffineTerm","page":"Standard form","title":"MathOptInterface.ScalarAffineTerm","text":"ScalarAffineTerm{T}(coefficient::T, variable::VariableIndex) where {T}\n\nRepresents the scalar-valued term coefficient * variable.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> x = MOI.VariableIndex(1)\nMOI.VariableIndex(1)\n\njulia> MOI.ScalarAffineTerm(2.0, x)\nMathOptInterface.ScalarAffineTerm{Float64}(2.0, MOI.VariableIndex(1))\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ScalarAffineFunction","page":"Standard form","title":"MathOptInterface.ScalarAffineFunction","text":"ScalarAffineFunction{T}(\n    terms::Vector{ScalarAffineTerm{T}},\n    constant::T,\n) where {T}\n\nRepresents the scalar-valued affine function a^top x + b, where:\n\na^top x is represented by the vector of ScalarAffineTerms\nb is a scalar constant::T\n\nDuplicates\n\nDuplicate variable indices in terms are accepted, and the corresponding coefficients are summed together.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> x = MOI.VariableIndex(1)\nMOI.VariableIndex(1)\n\njulia> terms = [MOI.ScalarAffineTerm(2.0, x), MOI.ScalarAffineTerm(3.0, x)]\n2-element Vector{MathOptInterface.ScalarAffineTerm{Float64}}:\n MathOptInterface.ScalarAffineTerm{Float64}(2.0, MOI.VariableIndex(1))\n MathOptInterface.ScalarAffineTerm{Float64}(3.0, MOI.VariableIndex(1))\n\njulia> f = MOI.ScalarAffineFunction(terms, 4.0)\n4.0 + 2.0 MOI.VariableIndex(1) + 3.0 MOI.VariableIndex(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ScalarQuadraticTerm","page":"Standard form","title":"MathOptInterface.ScalarQuadraticTerm","text":"ScalarQuadraticTerm{T}(\n    coefficient::T,\n    variable_1::VariableIndex,\n    variable_2::VariableIndex,\n) where {T}\n\nRepresents the scalar-valued term c x_i x_j where c is coefficient, x_i is variable_1 and x_j is variable_2.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> x = MOI.VariableIndex(1)\nMOI.VariableIndex(1)\n\njulia> MOI.ScalarQuadraticTerm(2.0, x, x)\nMathOptInterface.ScalarQuadraticTerm{Float64}(2.0, MOI.VariableIndex(1), MOI.VariableIndex(1))\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ScalarQuadraticFunction","page":"Standard form","title":"MathOptInterface.ScalarQuadraticFunction","text":"ScalarQuadraticFunction{T}(\n    quadratic_terms::Vector{ScalarQuadraticTerm{T}},\n    affine_terms::Vector{ScalarAffineTerm{T}},\n    constant::T,\n) wher {T}\n\nThe scalar-valued quadratic function frac12x^top Q x + a^top x + b, where:\n\nQ is the symmetric matrix given by the vector of ScalarQuadraticTerms\na^top x is a sparse vector given by the vector of ScalarAffineTerms\nb is the scalar constant::T.\n\nDuplicates\n\nDuplicate indices in quadratic_terms or affine_terms are accepted, and the corresponding coefficients are summed together.\n\nIn quadratic_terms, \"mirrored\" indices, (q, r) and (r, q) where r and q are VariableIndexes, are considered duplicates; only one needs to be specified.\n\nThe 0.5 factor\n\nCoupled with the interpretation of mirrored indices, the 0.5 factor in front of the Q matrix is a common source of bugs.\n\nAs a rule, to represent a * x^2 + b * x * y:\n\nThe coefficient a in front of squared variables (diagonal elements in Q) must be doubled when creating a ScalarQuadraticTerm\nThe coefficient b in front of off-diagonal elements in Q should be left as b, be cause the mirrored index b * y * x will be implicitly added.\n\nExample\n\nTo represent the function f(x y) = 2 * x^2 + 3 * x * y + 4 * x + 5, do:\n\njulia> import MathOptInterface as MOI\n\njulia> x = MOI.VariableIndex(1);\n\njulia> y = MOI.VariableIndex(2);\n\njulia> constant = 5.0;\n\njulia> affine_terms = [MOI.ScalarAffineTerm(4.0, x)];\n\njulia> quadratic_terms = [\n           MOI.ScalarQuadraticTerm(4.0, x, x),  # Note the changed coefficient\n           MOI.ScalarQuadraticTerm(3.0, x, y),\n       ]\n2-element Vector{MathOptInterface.ScalarQuadraticTerm{Float64}}:\n MathOptInterface.ScalarQuadraticTerm{Float64}(4.0, MOI.VariableIndex(1), MOI.VariableIndex(1))\n MathOptInterface.ScalarQuadraticTerm{Float64}(3.0, MOI.VariableIndex(1), MOI.VariableIndex(2))\n\njulia> f = MOI.ScalarQuadraticFunction(quadratic_terms, affine_terms, constant)\n5.0 + 4.0 MOI.VariableIndex(1) + 2.0 MOI.VariableIndex(1)² + 3.0 MOI.VariableIndex(1)*MOI.VariableIndex(2)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ScalarNonlinearFunction","page":"Standard form","title":"MathOptInterface.ScalarNonlinearFunction","text":"ScalarNonlinearFunction(head::Symbol, args::Vector{Any})\n\nThe scalar-valued nonlinear function head(args...), represented as a symbolic expression tree, with the call operator head and ordered arguments in args.\n\nhead\n\nThe head::Symbol must be an operator supported by the model.\n\nThe default list of supported univariate operators is given by:\n\nNonlinear.DEFAULT_UNIVARIATE_OPERATORS\n\nand the default list of supported multivariate operators is given by:\n\nNonlinear.DEFAULT_MULTIVARIATE_OPERATORS\n\nAdditional operators can be registered by setting a UserDefinedFunction attribute.\n\nSee the full list of operators supported by a ModelLike by querying ListOfSupportedNonlinearOperators.\n\nargs\n\nThe vector args contains the arguments to the nonlinear function. If the operator is univariate, it must contain one element. Otherwise, it may contain multiple elements.\n\nEach element must be one of the following:\n\nA constant value of type T<:Real\nA VariableIndex\nA ScalarAffineFunction\nA ScalarQuadraticFunction\nA ScalarNonlinearFunction\n\nUnsupported operators\n\nIf the optimizer does not support head, an UnsupportedNonlinearOperator error will be thrown.\n\nThere is no guarantee about when this error will be thrown; it may be thrown when the function is first added to the model, or it may be thrown when optimize! is called.\n\nExample\n\nTo represent the function f(x) = sin(x)^2, do:\n\njulia> import MathOptInterface as MOI\n\njulia> x = MOI.VariableIndex(1)\nMOI.VariableIndex(1)\n\njulia> MOI.ScalarNonlinearFunction(\n           :^,\n           Any[MOI.ScalarNonlinearFunction(:sin, Any[x]), 2],\n       )\n^(sin(MOI.VariableIndex(1)), (2))\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#Vector-functions","page":"Standard form","title":"Vector functions","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"AbstractVectorFunction\nVectorOfVariables\nVectorAffineTerm\nVectorAffineFunction\nVectorQuadraticTerm\nVectorQuadraticFunction\nVectorNonlinearFunction","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractVectorFunction","page":"Standard form","title":"MathOptInterface.AbstractVectorFunction","text":"abstract type AbstractVectorFunction <: AbstractFunction\n\nAbstract supertype for vector-valued AbstractFunctions.\n\nRequired methods\n\nAll subtypes of AbstractVectorFunction must implement:\n\noutput_dimension\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VectorOfVariables","page":"Standard form","title":"MathOptInterface.VectorOfVariables","text":"VectorOfVariables(variables::Vector{VariableIndex}) <: AbstractVectorFunction\n\nThe vector-valued function f(x) = variables, where variables is a subset of VariableIndexes in the model.\n\nThe list of variables may contain duplicates.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> x = MOI.VariableIndex.(1:2)\n2-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(1)\n MOI.VariableIndex(2)\n\njulia> f = MOI.VectorOfVariables([x[1], x[2], x[1]])\n┌                    ┐\n│MOI.VariableIndex(1)│\n│MOI.VariableIndex(2)│\n│MOI.VariableIndex(1)│\n└                    ┘\n\njulia> MOI.output_dimension(f)\n3\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VectorAffineTerm","page":"Standard form","title":"MathOptInterface.VectorAffineTerm","text":"VectorAffineTerm{T}(\n    output_index::Int64,\n    scalar_term::ScalarAffineTerm{T},\n) where {T}\n\nA VectorAffineTerm is a scalar_term that appears in the output_index row of the vector-valued VectorAffineFunction or VectorQuadraticFunction.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> x = MOI.VariableIndex(1);\n\njulia> MOI.VectorAffineTerm(Int64(2), MOI.ScalarAffineTerm(3.0, x))\nMathOptInterface.VectorAffineTerm{Float64}(2, MathOptInterface.ScalarAffineTerm{Float64}(3.0, MOI.VariableIndex(1)))\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VectorAffineFunction","page":"Standard form","title":"MathOptInterface.VectorAffineFunction","text":"VectorAffineFunction{T}(\n    terms::Vector{VectorAffineTerm{T}},\n    constants::Vector{T},\n) where {T}\n\nThe vector-valued affine function A x + b, where:\n\nA x is the sparse matrix given by the vector of VectorAffineTerms\nb is the vector constants\n\nDuplicates\n\nDuplicate indices in the A are accepted, and the corresponding coefficients are summed together.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> x = MOI.VariableIndex(1);\n\njulia> terms = [\n           MOI.VectorAffineTerm(Int64(1), MOI.ScalarAffineTerm(2.0, x)),\n           MOI.VectorAffineTerm(Int64(2), MOI.ScalarAffineTerm(3.0, x)),\n       ];\n\njulia> f = MOI.VectorAffineFunction(terms, [4.0, 5.0])\n┌                              ┐\n│4.0 + 2.0 MOI.VariableIndex(1)│\n│5.0 + 3.0 MOI.VariableIndex(1)│\n└                              ┘\n\njulia> MOI.output_dimension(f)\n2\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VectorQuadraticTerm","page":"Standard form","title":"MathOptInterface.VectorQuadraticTerm","text":"VectorQuadraticTerm{T}(\n    output_index::Int64,\n    scalar_term::ScalarQuadraticTerm{T},\n) where {T}\n\nA VectorQuadraticTerm is a ScalarQuadraticTerm scalar_term that appears in the output_index row of the vector-valued VectorQuadraticFunction.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> x = MOI.VariableIndex(1);\n\njulia> MOI.VectorQuadraticTerm(Int64(2), MOI.ScalarQuadraticTerm(3.0, x, x))\nMathOptInterface.VectorQuadraticTerm{Float64}(2, MathOptInterface.ScalarQuadraticTerm{Float64}(3.0, MOI.VariableIndex(1), MOI.VariableIndex(1)))\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VectorQuadraticFunction","page":"Standard form","title":"MathOptInterface.VectorQuadraticFunction","text":"VectorQuadraticFunction{T}(\n    quadratic_terms::Vector{VectorQuadraticTerm{T}},\n    affine_terms::Vector{VectorAffineTerm{T}},\n    constants::Vector{T},\n) where {T}\n\nThe vector-valued quadratic function with ith component (\"output index\") defined as frac12x^top Q_i x + a_i^top x + b_i, where:\n\nfrac12x^top Q_i x is the symmetric matrix given by the VectorQuadraticTerm elements in quadratic_terms with output_index == i\na_i^top x is the sparse vector given by the VectorAffineTerm elements in affine_terms with output_index == i\nb_i is a scalar given by constants[i]\n\nDuplicates\n\nDuplicate indices in quadratic_terms and affine_terms with the same output_index are handled in the same manner as duplicates in ScalarQuadraticFunction.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> x = MOI.VariableIndex(1);\n\njulia> y = MOI.VariableIndex(2);\n\njulia> constants = [4.0, 5.0];\n\njulia> affine_terms = [\n           MOI.VectorAffineTerm(Int64(1), MOI.ScalarAffineTerm(2.0, x)),\n           MOI.VectorAffineTerm(Int64(2), MOI.ScalarAffineTerm(3.0, x)),\n       ];\n\njulia> quad_terms = [\n        MOI.VectorQuadraticTerm(Int64(1), MOI.ScalarQuadraticTerm(2.0, x, x)),\n        MOI.VectorQuadraticTerm(Int64(2), MOI.ScalarQuadraticTerm(3.0, x, y)),\n           ];\n\njulia> f = MOI.VectorQuadraticFunction(quad_terms, affine_terms, constants)\n┌                                                                              ┐\n│4.0 + 2.0 MOI.VariableIndex(1) + 1.0 MOI.VariableIndex(1)²                    │\n│5.0 + 3.0 MOI.VariableIndex(1) + 3.0 MOI.VariableIndex(1)*MOI.VariableIndex(2)│\n└                                                                              ┘\n\njulia> MOI.output_dimension(f)\n2\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.VectorNonlinearFunction","page":"Standard form","title":"MathOptInterface.VectorNonlinearFunction","text":"VectorNonlinearFunction(args::Vector{ScalarNonlinearFunction})\n\nThe vector-valued nonlinear function composed of a vector of ScalarNonlinearFunction.\n\nargs\n\nThe vector args contains the scalar elements of the nonlinear function. Each element must be a ScalarNonlinearFunction, but if you pass a Vector{Any}, the elements can be automatically converted from one of the following:\n\nA constant value of type T<:Real\nA VariableIndex\nA ScalarAffineFunction\nA ScalarQuadraticFunction\nA ScalarNonlinearFunction\n\nExample\n\nTo represent the function f(x) = sin(x)^2 x, do:\n\njulia> import MathOptInterface as MOI\n\njulia> x = MOI.VariableIndex(1)\nMOI.VariableIndex(1)\n\njulia> g = MOI.ScalarNonlinearFunction(\n           :^,\n           Any[MOI.ScalarNonlinearFunction(:sin, Any[x]), 2.0],\n       )\n^(sin(MOI.VariableIndex(1)), 2.0)\n\njulia> MOI.VectorNonlinearFunction([g, x])\n┌                                 ┐\n│^(sin(MOI.VariableIndex(1)), 2.0)│\n│+(MOI.VariableIndex(1))          │\n└                                 ┘\n\nNote the automatic conversion from x to +(x).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#Sets","page":"Standard form","title":"Sets","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"AbstractSet\nAbstractScalarSet\nAbstractVectorSet","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractSet","page":"Standard form","title":"MathOptInterface.AbstractSet","text":"AbstractSet\n\nAbstract supertype for set objects used to encode constraints.\n\nRequired methods\n\nFor sets of type S with isbitstype(S) == false, you must implement:\n\nBase.copy(set::S)\nBase.:(==)(x::S, y::S)\n\nSubtypes of AbstractSet such as AbstractScalarSet and AbstractVectorSet may prescribe additional required methods.\n\nOptional methods\n\nYou may optionally implement:\n\ndual_set\ndual_set_type\n\nNote for developers\n\nWhen creating a new set, the set struct must not contain any VariableIndex or ConstraintIndex objects.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractScalarSet","page":"Standard form","title":"MathOptInterface.AbstractScalarSet","text":"AbstractScalarSet\n\nAbstract supertype for subsets of mathbbR.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractVectorSet","page":"Standard form","title":"MathOptInterface.AbstractVectorSet","text":"AbstractVectorSet\n\nAbstract supertype for subsets of mathbbR^n for some n.\n\nRequired methods\n\nAll AbstractVectorSets of type S must implement:\n\ndimension, unless the dimension is stored in the set.dimension field\nUtilities.set_dot, unless the dot product between two vectors in the set is equivalent to LinearAlgebra.dot.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#Utilities","page":"Standard form","title":"Utilities","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"dimension\ndual_set\ndual_set_type\nconstant(s::EqualTo)\nsupports_dimension_update\nupdate_dimension","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.dimension","page":"Standard form","title":"MathOptInterface.dimension","text":"dimension(set::AbstractSet)\n\nReturn the output_dimension that an AbstractFunction should have to be used with the set set.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> MOI.dimension(MOI.Reals(4))\n4\n\njulia> MOI.dimension(MOI.LessThan(3.0))\n1\n\njulia> MOI.dimension(MOI.PositiveSemidefiniteConeTriangle(2))\n3\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.dual_set","page":"Standard form","title":"MathOptInterface.dual_set","text":"dual_set(set::AbstractSet)\n\nReturn the dual set of set, that is the dual cone of the set. This follows the definition of duality discussed in Duality.\n\nSee Dual cone for more information.\n\nIf the dual cone is not defined it returns an error.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> MOI.dual_set(MOI.Reals(4))\nMathOptInterface.Zeros(4)\n\njulia> MOI.dual_set(MOI.SecondOrderCone(5))\nMathOptInterface.SecondOrderCone(5)\n\njulia> MOI.dual_set(MOI.ExponentialCone())\nMathOptInterface.DualExponentialCone()\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.dual_set_type","page":"Standard form","title":"MathOptInterface.dual_set_type","text":"dual_set_type(S::Type{<:AbstractSet})\n\nReturn the type of dual set of sets of type S, as returned by dual_set. If the dual cone is not defined it returns an error.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> MOI.dual_set_type(MOI.Reals)\nMathOptInterface.Zeros\n\njulia> MOI.dual_set_type(MOI.SecondOrderCone)\nMathOptInterface.SecondOrderCone\n\njulia> MOI.dual_set_type(MOI.ExponentialCone)\nMathOptInterface.DualExponentialCone\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.constant-Tuple{MathOptInterface.EqualTo}","page":"Standard form","title":"MathOptInterface.constant","text":"constant(set::Union{EqualTo,GreaterThan,LessThan,Parameter})\n\nReturns the constant term of the set set.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> MOI.constant(MOI.GreaterThan(1.0))\n1.0\n\njulia> MOI.constant(MOI.LessThan(2.5))\n2.5\n\njulia> MOI.constant(MOI.EqualTo(3))\n3\n\njulia> MOI.constant(MOI.Parameter(4.5))\n4.5\n\n\n\n\n\n","category":"method"},{"location":"moi/reference/standard_form/#MathOptInterface.supports_dimension_update","page":"Standard form","title":"MathOptInterface.supports_dimension_update","text":"supports_dimension_update(S::Type{<:MOI.AbstractVectorSet})\n\nReturn a Bool indicating whether the elimination of any dimension of n-dimensional sets of type S give an n-1-dimensional set S. By default, this function returns false so it should only be implemented for sets that supports dimension update.\n\nFor instance, supports_dimension_update(MOI.Nonnegatives) is true because the elimination of any dimension of the n-dimensional nonnegative orthant gives the n-1-dimensional nonnegative orthant. However supports_dimension_update(MOI.ExponentialCone) is false.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.update_dimension","page":"Standard form","title":"MathOptInterface.update_dimension","text":"update_dimension(s::AbstractVectorSet, new_dim::Int)\n\nReturns a set with the dimension modified to new_dim.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#Scalar-sets","page":"Standard form","title":"Scalar sets","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"List of recognized scalar sets.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"GreaterThan\nLessThan\nEqualTo\nInterval\nInteger\nZeroOne\nSemicontinuous\nSemiinteger\nParameter","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.GreaterThan","page":"Standard form","title":"MathOptInterface.GreaterThan","text":"GreaterThan{T<:Real}(lower::T)\n\nThe set lower infty) subseteq mathbbR.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> MOI.add_constraint(model, x, MOI.GreaterThan(0.0))\nMathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64}}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.LessThan","page":"Standard form","title":"MathOptInterface.LessThan","text":"LessThan{T<:Real}(upper::T)\n\nThe set (-infty upper subseteq mathbbR.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> MOI.add_constraint(model, x, MOI.LessThan(2.0))\nMathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.LessThan{Float64}}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.EqualTo","page":"Standard form","title":"MathOptInterface.EqualTo","text":"EqualTo{T<:Number}(value::T)\n\nThe set containing the single point value subseteq mathbbR.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> MOI.add_constraint(model, x, MOI.EqualTo(2.0))\nMathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.EqualTo{Float64}}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Interval","page":"Standard form","title":"MathOptInterface.Interval","text":"Interval{T<:Real}(lower::T, upper::T)\n\nThe interval lower upper subseteq mathbbR cup -infty +infty.\n\nIf lower or upper is -Inf or Inf, respectively, the set is interpreted as a one-sided interval.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> MOI.add_constraint(model, x, MOI.Interval(1.0, 2.0))\nMathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64}}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Integer","page":"Standard form","title":"MathOptInterface.Integer","text":"Integer()\n\nThe set of integers, mathbbZ.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> MOI.add_constraint(model, x, MOI.Integer())\nMathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ZeroOne","page":"Standard form","title":"MathOptInterface.ZeroOne","text":"ZeroOne()\n\nThe set 0 1.\n\nVariables belonging to the ZeroOne set are also known as \"binary\" variables.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> MOI.add_constraint(model, x, MOI.ZeroOne())\nMathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Semicontinuous","page":"Standard form","title":"MathOptInterface.Semicontinuous","text":"Semicontinuous{T<:Real}(lower::T, upper::T)\n\nThe set 0 cup lower upper.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> MOI.add_constraint(model, x, MOI.Semicontinuous(2.0, 3.0))\nMathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Semicontinuous{Float64}}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Semiinteger","page":"Standard form","title":"MathOptInterface.Semiinteger","text":"Semiinteger{T<:Real}(lower::T, upper::T)\n\nThe set 0 cup lower lower+1 ldots upper-1 upper.\n\nNote that if lower and upper are not equivalent to an integer, then the solver may throw an error, or it may round up lower and round down upper to the nearest integers.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> MOI.add_constraint(model, x, MOI.Semiinteger(2.0, 3.0))\nMathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Semiinteger{Float64}}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Parameter","page":"Standard form","title":"MathOptInterface.Parameter","text":"Parameter{T<:Number}(value::T)\n\nThe set containing the single point value subseteq mathbbR.\n\nThe Parameter set is conceptually similar to the EqualTo set, except that a variable constrained to the Parameter set cannot have other constraints added to it, and the Parameter set can never be deleted. Thus, solvers are free to treat the variable as a constant, and they need not add it as a decision variable to the model.\n\nBecause of this behavior, you must add parameters using add_constrained_variable, and solvers should declare supports_add_constrained_variable and not supports_constraint for the Parameter set.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> p, ci = MOI.add_constrained_variable(model, MOI.Parameter(2.5))\n(MOI.VariableIndex(1), MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Parameter{Float64}}(1))\n\njulia> MOI.set(model, MOI.ConstraintSet(), ci, MOI.Parameter(3.0))\n\njulia> MOI.get(model, MOI.ConstraintSet(), ci)\nMathOptInterface.Parameter{Float64}(3.0)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#Vector-sets","page":"Standard form","title":"Vector sets","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"List of recognized vector sets.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"Reals\nZeros\nNonnegatives\nNonpositives\nNormInfinityCone\nNormOneCone\nNormCone\nSecondOrderCone\nRotatedSecondOrderCone\nGeometricMeanCone\nExponentialCone\nDualExponentialCone\nPowerCone\nDualPowerCone\nRelativeEntropyCone\nNormSpectralCone\nNormNuclearCone\nSOS1\nSOS2\nIndicator\nComplements\nHyperRectangle\nScaled","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.Reals","page":"Standard form","title":"MathOptInterface.Reals","text":"Reals(dimension::Int)\n\nThe set mathbbR^dimension (containing all points) of non-negative dimension dimension.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables(x), MOI.Reals(3))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.Reals}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Zeros","page":"Standard form","title":"MathOptInterface.Zeros","text":"Zeros(dimension::Int)\n\nThe set  0 ^dimension (containing only the origin) of non-negative dimension dimension.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables(x), MOI.Zeros(3))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.Zeros}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Nonnegatives","page":"Standard form","title":"MathOptInterface.Nonnegatives","text":"Nonnegatives(dimension::Int)\n\nThe nonnegative orthant  x in mathbbR^dimension  x ge 0  of non-negative dimension dimension.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables(x), MOI.Nonnegatives(3))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.Nonnegatives}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Nonpositives","page":"Standard form","title":"MathOptInterface.Nonpositives","text":"Nonpositives(dimension::Int)\n\nThe nonpositive orthant  x in mathbbR^dimension  x le 0  of non-negative dimension dimension.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables(x), MOI.Nonpositives(3))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.Nonpositives}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.NormInfinityCone","page":"Standard form","title":"MathOptInterface.NormInfinityCone","text":"NormInfinityCone(dimension::Int)\n\nThe ell_infty-norm cone  (tx) in mathbbR^dimension  t ge lVert x rVert_infty = max_i lvert x_i rvert  of dimension dimension.\n\nThe dimension must be at least 1.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> t = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> x = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables([t; x]), MOI.NormInfinityCone(4))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.NormInfinityCone}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.NormOneCone","page":"Standard form","title":"MathOptInterface.NormOneCone","text":"NormOneCone(dimension::Int)\n\nThe ell_1-norm cone  (tx) in mathbbR^dimension  t ge lVert x rVert_1 = sum_i lvert x_i rvert  of dimension dimension.\n\nThe dimension must be at least 1.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> t = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> x = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables([t; x]), MOI.NormOneCone(4))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.NormOneCone}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.NormCone","page":"Standard form","title":"MathOptInterface.NormCone","text":"NormCone(p::Float64, dimension::Int)\n\nThe ell_p-norm cone  (tx) in mathbbR^dimension  t ge left(sumlimits_i x_i^pright)^frac1p  of dimension dimension.\n\nThe dimension must be at least 1.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> t = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> x = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables([t; x]), MOI.NormCone(3, 4))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.NormCone}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.SecondOrderCone","page":"Standard form","title":"MathOptInterface.SecondOrderCone","text":"SecondOrderCone(dimension::Int)\n\nThe second-order cone (or Lorenz cone or ell_2-norm cone)  (tx) in mathbbR^dimension  t ge lVert x rVert_2  of dimension dimension.\n\nThe dimension must be at least 1.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> t = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> x = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables([t; x]), MOI.SecondOrderCone(4))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.SecondOrderCone}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.RotatedSecondOrderCone","page":"Standard form","title":"MathOptInterface.RotatedSecondOrderCone","text":"RotatedSecondOrderCone(dimension::Int)\n\nThe rotated second-order cone  (tux) in mathbbR^dimension  2tu ge lVert x rVert_2^2 tu ge 0  of dimension dimension.\n\nThe dimension must be at least 2.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> t = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> u = MOI.add_variable(model)\nMOI.VariableIndex(2)\n\njulia> x = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(\n           model,\n           MOI.VectorOfVariables([t; u; x]),\n           MOI.RotatedSecondOrderCone(5),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.RotatedSecondOrderCone}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.GeometricMeanCone","page":"Standard form","title":"MathOptInterface.GeometricMeanCone","text":"GeometricMeanCone(dimension::Int)\n\nThe geometric mean cone  (tx) in mathbbR^n+1  x ge 0 t le sqrtnx_1 x_2 cdots x_n , where dimension = n + 1 >= 2.\n\nDuality note\n\nThe dual of the geometric mean cone is  (u v) in mathbbR^n+1  u le 0 v ge 0 -u le n sqrtnprod_i v_i , where dimension = n + 1 >= 2.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> t = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> x = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(\n           model,\n           MOI.VectorOfVariables([t; x]),\n           MOI.GeometricMeanCone(4),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.GeometricMeanCone}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.ExponentialCone","page":"Standard form","title":"MathOptInterface.ExponentialCone","text":"ExponentialCone()\n\nThe 3-dimensional exponential cone  (xyz) in mathbbR^3  y exp (xy) le z y  0 .\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables(x), MOI.ExponentialCone())\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.ExponentialCone}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.DualExponentialCone","page":"Standard form","title":"MathOptInterface.DualExponentialCone","text":"DualExponentialCone()\n\nThe 3-dimensional dual exponential cone  (uvw) in mathbbR^3  -u exp (vu) le exp(1) w u  0 .\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables(x), MOI.DualExponentialCone())\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.DualExponentialCone}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.PowerCone","page":"Standard form","title":"MathOptInterface.PowerCone","text":"PowerCone{T<:Real}(exponent::T)\n\nThe 3-dimensional power cone  (xyz) in mathbbR^3  x^exponent y^1-exponent ge z x ge 0 y ge 0  with parameter exponent.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables(x), MOI.PowerCone(0.5))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.PowerCone{Float64}}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.DualPowerCone","page":"Standard form","title":"MathOptInterface.DualPowerCone","text":"DualPowerCone{T<:Real}(exponent::T)\n\nThe 3-dimensional power cone  (uvw) in mathbbR^3  (fracuexponent)^exponent (fracv1-exponent)^1-exponent ge w u ge 0 v ge 0  with parameter exponent.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables(x), MOI.DualPowerCone(0.5))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.DualPowerCone{Float64}}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.RelativeEntropyCone","page":"Standard form","title":"MathOptInterface.RelativeEntropyCone","text":"RelativeEntropyCone(dimension::Int)\n\nThe relative entropy cone  (u v w) in mathbbR^1+2n  u ge sum_i=1^n w_i log(fracw_iv_i) v_i ge 0 w_i ge 0 , where dimension = 2n + 1 >= 1.\n\nDuality note\n\nThe dual of the relative entropy cone is  (u v w) in mathbbR^1+2n  forall i w_i ge u (log (fracuv_i) - 1) v_i ge 0 u  0  of dimension dimension=2n+1.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> u = MOI.add_variable(model);\n\njulia> v = MOI.add_variables(model, 3);\n\njulia> w = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(\n           model,\n           MOI.VectorOfVariables([u; v; w]),\n           MOI.RelativeEntropyCone(7),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.RelativeEntropyCone}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.NormSpectralCone","page":"Standard form","title":"MathOptInterface.NormSpectralCone","text":"NormSpectralCone(row_dim::Int, column_dim::Int)\n\nThe epigraph of the matrix spectral norm (maximum singular value function)  (t X) in mathbbR^1 + row_dim times column_dim  t ge sigma_1(X) , where sigma_i is the ith singular value of the matrix X of non-negative row dimension row_dim and column dimension column_dim.\n\nThe matrix X is vectorized by stacking the columns, matching the behavior of Julia's vec function.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> t = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> X = reshape(MOI.add_variables(model, 6), 2, 3)\n2×3 Matrix{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(2)  MOI.VariableIndex(4)  MOI.VariableIndex(6)\n MOI.VariableIndex(3)  MOI.VariableIndex(5)  MOI.VariableIndex(7)\n\njulia> MOI.add_constraint(\n           model,\n           MOI.VectorOfVariables([t; vec(X)]),\n           MOI.NormSpectralCone(2, 3),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.NormSpectralCone}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.NormNuclearCone","page":"Standard form","title":"MathOptInterface.NormNuclearCone","text":"NormNuclearCone(row_dim::Int, column_dim::Int)\n\nThe epigraph of the matrix nuclear norm (sum of singular values function)  (t X) in mathbbR^1 + row_dim times column_dim  t ge sum_i sigma_i(X) , where sigma_i is the ith singular value of the matrix X of non-negative row dimension row_dim and column dimension column_dim.\n\nThe matrix X is vectorized by stacking the columns, matching the behavior of Julia's vec function.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> t = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> X = reshape(MOI.add_variables(model, 6), 2, 3)\n2×3 Matrix{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(2)  MOI.VariableIndex(4)  MOI.VariableIndex(6)\n MOI.VariableIndex(3)  MOI.VariableIndex(5)  MOI.VariableIndex(7)\n\njulia> MOI.add_constraint(\n           model,\n           MOI.VectorOfVariables([t; vec(X)]),\n           MOI.NormNuclearCone(2, 3),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.NormNuclearCone}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.SOS1","page":"Standard form","title":"MathOptInterface.SOS1","text":"SOS1{T<:Real}(weights::Vector{T})\n\nThe set corresponding to the Special Ordered Set (SOS) constraint of Type I.\n\nOf the variables in the set, at most one can be nonzero.\n\nThe weights induce an ordering of the variables such that the kth element in the set corresponds to the kth weight in weights. Solvers may use these weights to improve the efficiency of the solution process, but the ordering does not change the set of feasible solutions.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(\n           model,\n           MOI.VectorOfVariables(x),\n           MOI.SOS1([1.0, 3.0, 2.5]),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.SOS1{Float64}}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.SOS2","page":"Standard form","title":"MathOptInterface.SOS2","text":"SOS2{T<:Real}(weights::Vector{T})\n\nThe set corresponding to the Special Ordered Set (SOS) constraint of Type II.\n\nThe weights induce an ordering of the variables such that the kth element in the set corresponds to the kth weight in weights. Therefore, the weights must be unique.\n\nOf the variables in the set, at most two can be nonzero, and if two are nonzero, they must be adjacent in the ordering of the set.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(\n           model,\n           MOI.VectorOfVariables(x),\n           MOI.SOS2([1.0, 3.0, 2.5]),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.SOS2{Float64}}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Indicator","page":"Standard form","title":"MathOptInterface.Indicator","text":"Indicator{A<:ActivationCondition,S<:AbstractScalarSet}(set::S)\n\nThe set corresponding to an indicator constraint.\n\nWhen A is ACTIVATE_ON_ZERO, this means: (y x) in 0 1 times mathbbR^n  y = 0 implies x in set\n\nWhen A is ACTIVATE_ON_ONE, this means: (y x) in 0 1 times mathbbR^n  y = 1 implies x in set\n\nNotes\n\nMost solvers expect that the first row of the function is interpretable as a variable index x_i (for example, 1.0 * x + 0.0). An error will be thrown if this is not the case.\n\nExample\n\nThe constraint (y x) in 0 1 times mathbbR^2  y = 1 implies x_1 + x_2 leq 9  is defined as\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variables(model, 2)\n2-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(1)\n MOI.VariableIndex(2)\n\njulia> y, _ = MOI.add_constrained_variable(model, MOI.ZeroOne())\n(MOI.VariableIndex(3), MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}(3))\n\njulia> f = MOI.VectorAffineFunction(\n           [\n               MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(1.0, y)),\n               MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(1.0, x[1])),\n               MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(1.0, x[2])),\n           ],\n           [0.0, 0.0],\n       )\n┌                                                         ┐\n│0.0 + 1.0 MOI.VariableIndex(3)                           │\n│0.0 + 1.0 MOI.VariableIndex(1) + 1.0 MOI.VariableIndex(2)│\n└                                                         ┘\n\njulia> s = MOI.Indicator{MOI.ACTIVATE_ON_ONE}(MOI.LessThan(9.0))\nMathOptInterface.Indicator{MathOptInterface.ACTIVATE_ON_ONE, MathOptInterface.LessThan{Float64}}(MathOptInterface.LessThan{Float64}(9.0))\n\njulia> MOI.add_constraint(model, f, s)\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Indicator{MathOptInterface.ACTIVATE_ON_ONE, MathOptInterface.LessThan{Float64}}}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Complements","page":"Standard form","title":"MathOptInterface.Complements","text":"Complements(dimension::Base.Integer)\n\nThe set corresponding to a mixed complementarity constraint.\n\nComplementarity constraints should be specified with an AbstractVectorFunction-in-Complements(dimension) constraint.\n\nThe dimension of the vector-valued function F must be dimension. This defines a complementarity constraint between the scalar function F[i] and the variable in F[i + dimension/2]. Thus, F[i + dimension/2] must be interpretable as a single variable x_i (for example, 1.0 * x + 0.0), and dimension must be even.\n\nThe mixed complementarity problem consists of finding x_i in the interval [lb, ub] (that is, in the set Interval(lb, ub)), such that the following holds:\n\nF_i(x) == 0 if lb_i < x_i < ub_i\nF_i(x) >= 0 if lb_i == x_i\nF_i(x) <= 0 if x_i == ub_i\n\nClassically, the bounding set for x_i is Interval(0, Inf), which recovers: 0 <= F_i(x) ⟂ x_i >= 0, where the ⟂ operator implies F_i(x) * x_i = 0.\n\nExample\n\nThe problem:\n\nx -in- Interval(-1, 1)\n[-4 * x - 3, x] -in- Complements(2)\n\ndefines the mixed complementarity problem where the following holds:\n\n-4 * x - 3 == 0 if -1 < x < 1\n-4 * x - 3 >= 0 if x == -1\n-4 * x - 3 <= 0 if x == 1\n\nThere are three solutions:\n\nx = -3/4 with F(x) = 0\nx = -1 with F(x) = 1\nx = 1 with F(x) = -7\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x, _ = MOI.add_constrained_variable(model, MOI.Interval(-1.0, 1.0));\n\njulia> MOI.add_constraint(\n            model,\n            MOI.Utilities.vectorize([-4.0 * x - 3.0, x]),\n            MOI.Complements(2),\n        )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Complements}(1)\n\nThe function F can also be defined in terms of single variables. For example, the problem:\n\n[x_3, x_4] -in- Nonnegatives(2)\n[x_1, x_2, x_3, x_4] -in- Complements(4)\n\ndefines the complementarity problem where 0 <= x_1 ⟂ x_3 >= 0 and 0 <= x_2 ⟂ x_4 >= 0.\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variables(model, 4);\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables(x[3:4]), MOI.Nonnegatives(2))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.Nonnegatives}(1)\n\njulia> MOI.add_constraint(\n            model,\n            MOI.VectorOfVariables(x),\n            MOI.Complements(4),\n        )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.Complements}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.HyperRectangle","page":"Standard form","title":"MathOptInterface.HyperRectangle","text":"HyperRectangle(lower::Vector{T}, upper::Vector{T}) where {T}\n\nThe set x in barmathbbR^d x_i in lower_i upper_i forall i=1ldotsd.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variables(model, 3)\n3-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(1)\n MOI.VariableIndex(2)\n MOI.VariableIndex(3)\n\njulia> MOI.add_constraint(\n           model,\n           MOI.VectorOfVariables(x),\n           MOI.HyperRectangle(zeros(3), ones(3)),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.HyperRectangle{Float64}}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Scaled","page":"Standard form","title":"MathOptInterface.Scaled","text":"struct Scaled{S<:AbstractVectorSet} <: AbstractVectorSet\n    set::S\nend\n\nGiven a vector a in mathbbR^d and a set representing the set mathcalS in mathbbR^d such that Utilities.set_dot for x in mathcalS and y in mathcalS^* is\n\nsum_i=1^d a_i x_i y_i\n\nthe set Scaled(set) is defined as\n\n (sqrta_1 x_1 sqrta_2 x_2 ldots sqrta_d x_d)  x in S \n\nExample\n\nThis can be used to scale a vector of numbers\n\njulia> import MathOptInterface as MOI\n\njulia> set = MOI.PositiveSemidefiniteConeTriangle(2)\nMathOptInterface.PositiveSemidefiniteConeTriangle(2)\n\njulia> a = MOI.Utilities.SetDotScalingVector{Float64}(set)\n3-element MathOptInterface.Utilities.SetDotScalingVector{Float64, MathOptInterface.PositiveSemidefiniteConeTriangle}:\n 1.0\n 1.4142135623730951\n 1.0\n\njulia> using LinearAlgebra\n\njulia> MOI.Utilities.operate(*, Float64, Diagonal(a), ones(3))\n3-element Vector{Float64}:\n 1.0\n 1.4142135623730951\n 1.0\n\nIt can be also used to scale a vector of function\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variables(model, 3);\n\njulia> func = MOI.VectorOfVariables(x)\n┌                    ┐\n│MOI.VariableIndex(1)│\n│MOI.VariableIndex(2)│\n│MOI.VariableIndex(3)│\n└                    ┘\n\njulia> set = MOI.PositiveSemidefiniteConeTriangle(2)\nMathOptInterface.PositiveSemidefiniteConeTriangle(2)\n\njulia> MOI.Utilities.operate(*, Float64, Diagonal(a), func)\n┌                                             ┐\n│0.0 + 1.0 MOI.VariableIndex(1)               │\n│0.0 + 1.4142135623730951 MOI.VariableIndex(2)│\n│0.0 + 1.0 MOI.VariableIndex(3)               │\n└                                             ┘\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#Constraint-programming-sets","page":"Standard form","title":"Constraint programming sets","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"AllDifferent\nBinPacking\nCircuit\nCountAtLeast\nCountBelongs\nCountDistinct\nCountGreaterThan\nCumulative\nPath\nReified\nTable","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.AllDifferent","page":"Standard form","title":"MathOptInterface.AllDifferent","text":"AllDifferent(dimension::Int)\n\nThe set x in mathbbZ^d such that no two elements in x take the same value and dimension = d.\n\nAlso known as\n\nThis constraint is called all_different in MiniZinc, and is sometimes also called distinct.\n\nExample\n\nTo enforce x[1] != x[2] AND x[1] != x[3] AND x[2] != x[3]:\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = [MOI.add_constrained_variable(model, MOI.Integer())[1] for _ in 1:3]\n3-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(1)\n MOI.VariableIndex(2)\n MOI.VariableIndex(3)\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables(x), MOI.AllDifferent(3))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.AllDifferent}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.BinPacking","page":"Standard form","title":"MathOptInterface.BinPacking","text":"BinPacking(c::T, w::Vector{T}) where {T}\n\nThe set x in mathbbZ^d where d = length(w), such that each item i in 1:d of weight w[i] is put into bin x[i], and the total weight of each bin does not exceed c.\n\nThere are additional assumptions that the capacity, c, and the weights, w, must all be non-negative.\n\nThe bin numbers depend on the bounds of x, so they may be something other than the integers 1:d.\n\nAlso known as\n\nThis constraint is called bin_packing in MiniZinc.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> bins = MOI.add_variables(model, 5)\n5-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(1)\n MOI.VariableIndex(2)\n MOI.VariableIndex(3)\n MOI.VariableIndex(4)\n MOI.VariableIndex(5)\n\njulia> weights = Float64[1, 1, 2, 2, 3]\n5-element Vector{Float64}:\n 1.0\n 1.0\n 2.0\n 2.0\n 3.0\n\njulia> MOI.add_constraint.(model, bins, MOI.Integer())\n5-element Vector{MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}}:\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}(1)\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}(2)\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}(3)\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}(4)\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}(5)\n\njulia> MOI.add_constraint.(model, bins, MOI.Interval(4.0, 6.0))\n5-element Vector{MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64}}}:\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64}}(1)\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64}}(2)\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64}}(3)\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64}}(4)\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64}}(5)\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables(bins), MOI.BinPacking(3.0, weights))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.BinPacking{Float64}}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Circuit","page":"Standard form","title":"MathOptInterface.Circuit","text":"Circuit(dimension::Int)\n\nThe set x in 1d^d that constraints x to be a circuit, such that x_i = j means that j is the successor of i, and dimension = d.\n\nGraphs with multiple independent circuits, such as [2, 1, 3] and [2, 1, 4, 3], are not valid.\n\nAlso known as\n\nThis constraint is called circuit in MiniZinc, and it is equivalent to forming a (potentially sub-optimal) tour in the travelling salesperson problem.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = [MOI.add_constrained_variable(model, MOI.Integer())[1] for _ in 1:3]\n3-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(1)\n MOI.VariableIndex(2)\n MOI.VariableIndex(3)\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables(x), MOI.Circuit(3))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.Circuit}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.CountAtLeast","page":"Standard form","title":"MathOptInterface.CountAtLeast","text":"CountAtLeast(n::Int, d::Vector{Int}, set::Set{Int})\n\nThe set x in mathbbZ^d_1 + d_2 + ldots d_N, where x is partitioned into N subsets (x_1  ldots x_d_1, x_d_1 + 1  ldots x_d_1 + d_2 and so on), and at least n elements of each subset take one of the values in set.\n\nAlso known as\n\nThis constraint is called at_least in MiniZinc.\n\nExample\n\nTo ensure that 3 appears at least once in each of the subsets {a, b} and {b, c}:\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> a, _ = MOI.add_constrained_variable(model, MOI.Integer())\n(MOI.VariableIndex(1), MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}(1))\n\njulia> b, _ = MOI.add_constrained_variable(model, MOI.Integer())\n(MOI.VariableIndex(2), MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}(2))\n\njulia> c, _ = MOI.add_constrained_variable(model, MOI.Integer())\n(MOI.VariableIndex(3), MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}(3))\n\njulia> x, d, set = [a, b, b, c], [2, 2], [3]\n(MathOptInterface.VariableIndex[MOI.VariableIndex(1), MOI.VariableIndex(2), MOI.VariableIndex(2), MOI.VariableIndex(3)], [2, 2], [3])\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables(x), MOI.CountAtLeast(1, d, Set(set)))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.CountAtLeast}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.CountBelongs","page":"Standard form","title":"MathOptInterface.CountBelongs","text":"CountBelongs(dimenson::Int, set::Set{Int})\n\nThe set (n x) in mathbbZ^1+d, such that n elements of the vector x take on of the values in set and dimension = 1 + d.\n\nAlso known as\n\nThis constraint is called among by MiniZinc.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> n, _ = MOI.add_constrained_variable(model, MOI.Integer())\n(MOI.VariableIndex(1), MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}(1))\n\njulia> x = [MOI.add_constrained_variable(model, MOI.Integer())[1] for _ in 1:3]\n3-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(2)\n MOI.VariableIndex(3)\n MOI.VariableIndex(4)\n\njulia> set = Set([3, 4, 5])\nSet{Int64} with 3 elements:\n  5\n  4\n  3\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables([n; x]), MOI.CountBelongs(4, set))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.CountBelongs}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.CountDistinct","page":"Standard form","title":"MathOptInterface.CountDistinct","text":"CountDistinct(dimension::Int)\n\nThe set (n x) in mathbbZ^1+d, such that the number of distinct values in x is n and dimension = 1 + d.\n\nAlso known as\n\nThis constraint is called nvalues in MiniZinc.\n\nExample\n\nTo model:\n\nif n == 1`, thenx[1] == x[2] == x[3]`\nif n == 2, then\nx[1] == x[2] != x[3] or\nx[1] != x[2] == x[3] or\nx[1] == x[3] != x[2]\nif n == 3, then x[1] != x[2], x[2] != x[3] and x[3] != x[1]\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> n, _ = MOI.add_constrained_variable(model, MOI.Integer())\n(MOI.VariableIndex(1), MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}(1))\n\njulia> x = [MOI.add_constrained_variable(model, MOI.Integer())[1] for _ in 1:3]\n3-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(2)\n MOI.VariableIndex(3)\n MOI.VariableIndex(4)\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables(vcat(n, x)), MOI.CountDistinct(4))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.CountDistinct}(1)\n\nRelationship to AllDifferent\n\nWhen the first element is d, CountDistinct is equivalent to an AllDifferent constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.CountGreaterThan","page":"Standard form","title":"MathOptInterface.CountGreaterThan","text":"CountGreaterThan(dimension::Int)\n\nThe set (c y x) in mathbbZ^1+1+d, such that c is strictly greater than the number of occurences of y in x and dimension = 1 + 1 + d.\n\nAlso known as\n\nThis constraint is called count_gt in MiniZinc.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> c, _ = MOI.add_constrained_variable(model, MOI.Integer())\n(MOI.VariableIndex(1), MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}(1))\n\njulia> y, _ = MOI.add_constrained_variable(model, MOI.Integer())\n(MOI.VariableIndex(2), MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}(2))\n\njulia> x = [MOI.add_constrained_variable(model, MOI.Integer())[1] for _ in 1:3]\n3-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(3)\n MOI.VariableIndex(4)\n MOI.VariableIndex(5)\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables([c; y; x]), MOI.CountGreaterThan(5))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.CountGreaterThan}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Cumulative","page":"Standard form","title":"MathOptInterface.Cumulative","text":"Cumulative(dimension::Int)\n\nThe set (s d r b) in mathbbZ^3n+1, representing the cumulative global constraint, where n == length(s) == length(r) == length(b) and dimension = 3n + 1.\n\nCumulative requires that a set of tasks given by start times s, durations d, and resource requirements r, never requires more than the global resource bound b at any one time.\n\nAlso known as\n\nThis constraint is called cumulative in MiniZinc.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> s = [MOI.add_constrained_variable(model, MOI.Integer())[1] for _ in 1:3]\n3-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(1)\n MOI.VariableIndex(2)\n MOI.VariableIndex(3)\n\njulia> d = [MOI.add_constrained_variable(model, MOI.Integer())[1] for _ in 1:3]\n3-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(4)\n MOI.VariableIndex(5)\n MOI.VariableIndex(6)\n\njulia> r = [MOI.add_constrained_variable(model, MOI.Integer())[1] for _ in 1:3]\n3-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(7)\n MOI.VariableIndex(8)\n MOI.VariableIndex(9)\n\njulia> b, _ = MOI.add_constrained_variable(model, MOI.Integer())\n(MOI.VariableIndex(10), MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}(10))\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables([s; d; r; b]), MOI.Cumulative(10))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.Cumulative}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Path","page":"Standard form","title":"MathOptInterface.Path","text":"Path(from::Vector{Int}, to::Vector{Int})\n\nGiven a graph comprised of a set of nodes 1..N and a set of arcs 1..E represented by an edge from node from[i] to node to[i], Path constrains the set (s t ns es) in (1N)times(1E)times01^Ntimes01^E, to form subgraph that is a path from node s to node t, where node n is in the path if ns[n] is 1, and edge e is in the path if es[e] is 1.\n\nThe path must be acyclic, and it must traverse all nodes n for which ns[n] is 1, and all edges e for which es[e] is 1.\n\nAlso known as\n\nThis constraint is called path in MiniZinc.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> N, E = 4, 5\n(4, 5)\n\njulia> from = [1, 1, 2, 2, 3]\n5-element Vector{Int64}:\n 1\n 1\n 2\n 2\n 3\n\njulia> to = [2, 3, 3, 4, 4]\n5-element Vector{Int64}:\n 2\n 3\n 3\n 4\n 4\n\njulia> s, _ = MOI.add_constrained_variable(model, MOI.Integer())\n(MOI.VariableIndex(1), MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}(1))\n\njulia> t, _ = MOI.add_constrained_variable(model, MOI.Integer())\n(MOI.VariableIndex(2), MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}(2))\n\njulia> ns = MOI.add_variables(model, N)\n4-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(3)\n MOI.VariableIndex(4)\n MOI.VariableIndex(5)\n MOI.VariableIndex(6)\n\njulia> MOI.add_constraint.(model, ns, MOI.ZeroOne())\n4-element Vector{MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}}:\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}(3)\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}(4)\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}(5)\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}(6)\n\njulia> es = MOI.add_variables(model, E)\n5-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(7)\n MOI.VariableIndex(8)\n MOI.VariableIndex(9)\n MOI.VariableIndex(10)\n MOI.VariableIndex(11)\n\njulia> MOI.add_constraint.(model, es, MOI.ZeroOne())\n5-element Vector{MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}}:\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}(7)\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}(8)\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}(9)\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}(10)\n MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}(11)\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables([s; t; ns; es]), MOI.Path(from, to))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.Path}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Reified","page":"Standard form","title":"MathOptInterface.Reified","text":"Reified(set::AbstractSet)\n\nThe constraint z f(x) in Reified(S) ensures that f(x) in S if and only if z == 1, where z in 0 1.\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.UniversalFallback(MOI.Utilities.Model{Float64}())\nMOIU.UniversalFallback{MOIU.Model{Float64}}\nfallback for MOIU.Model{Float64}\n\njulia> z, _ = MOI.add_constrained_variable(model, MOI.ZeroOne())\n(MOI.VariableIndex(1), MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}(1))\n\njulia> x = MOI.add_variable(model)\nMOI.VariableIndex(2)\n\njulia> MOI.add_constraint(\n           model,\n           MOI.Utilities.vectorize([z, 2.0 * x]),\n           MOI.Reified(MOI.GreaterThan(1.0)),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Reified{MathOptInterface.GreaterThan{Float64}}}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.Table","page":"Standard form","title":"MathOptInterface.Table","text":"Table(table::Matrix{T}) where {T}\n\nThe set x in mathbbR^d where d = size(table, 2), such that x belongs to one row of table. That is, there exists some j in 1:size(table, 1), such that x[i] = table[j, i] for all i=1:size(table, 2).\n\nAlso known as\n\nThis constraint is called table in MiniZinc.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> x = MOI.add_variables(model, 3)\n3-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(1)\n MOI.VariableIndex(2)\n MOI.VariableIndex(3)\n\njulia> table = Float64[1 1 0; 0 1 1; 1 0 1; 1 1 1]\n4×3 Matrix{Float64}:\n 1.0  1.0  0.0\n 0.0  1.0  1.0\n 1.0  0.0  1.0\n 1.0  1.0  1.0\n\njulia> MOI.add_constraint(model, MOI.VectorOfVariables(x), MOI.Table(table))\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.Table{Float64}}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#Matrix-sets","page":"Standard form","title":"Matrix sets","text":"","category":"section"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"Matrix sets are vectorized to be subtypes of AbstractVectorSet.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"For sets of symmetric matrices, storing both the (i, j) and (j, i) elements is redundant. Use the AbstractSymmetricMatrixSetTriangle set to represent only the vectorization of the upper triangular part of the matrix.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"When the matrix of expressions constrained to be in the set is not symmetric, and hence additional constraints are needed to force the equality of the (i, j) and (j, i) elements, use the AbstractSymmetricMatrixSetSquare set.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"The Bridges.Constraint.SquareBridge can transform a set from the square form to the triangular_form by adding appropriate constraints if the (i, j) and (j, i) expressions are different.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"AbstractSymmetricMatrixSetTriangle\nAbstractSymmetricMatrixSetSquare\nside_dimension\ntriangular_form","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractSymmetricMatrixSetTriangle","page":"Standard form","title":"MathOptInterface.AbstractSymmetricMatrixSetTriangle","text":"abstract type AbstractSymmetricMatrixSetTriangle <: AbstractVectorSet end\n\nAbstract supertype for subsets of the (vectorized) cone of symmetric matrices, with side_dimension rows and columns. The entries of the upper-right triangular part of the matrix are given column by column (or equivalently, the entries of the lower-left triangular part are given row by row). A vectorized cone of dimension n corresponds to a square matrix with side dimension sqrt14 + 2 n - 12. (Because a d times d matrix has d(d + 1)  2 elements in the upper or lower triangle.)\n\nExample\n\nThe matrix\n\nbeginbmatrix\n  1  2  4\n  2  3  5\n  4  5  6\nendbmatrix\n\nhas side_dimension 3 and vectorization (1 2 3 4 5 6).\n\nNote\n\nTwo packed storage formats exist for symmetric matrices, the respective orders of the entries are:\n\nupper triangular column by column (or lower triangular row by row);\nlower triangular column by column (or upper triangular row by row).\n\nThe advantage of the first format is the mapping between the (i, j) matrix indices and the k index of the vectorized form. It is simpler and does not depend on the side dimension of the matrix. Indeed,\n\nthe entry of matrix indices (i, j) has vectorized index k = div((j - 1) * j, 2) + i if i leq j and k = div((i - 1) * i, 2) + j if j leq i;\nand the entry with vectorized index k has matrix indices i = div(1 + isqrt(8k - 7), 2) and j = k - div((i - 1) * i, 2) or j = div(1 + isqrt(8k - 7), 2) and i = k - div((j - 1) * j, 2).\n\nDuality note\n\nThe scalar product for the symmetric matrix in its vectorized form is the sum of the pairwise product of the diagonal entries plus twice the sum of the pairwise product of the upper diagonal entries; see [p. 634, 1]. This has important consequence for duality.\n\nConsider for example the following problem (PositiveSemidefiniteConeTriangle is a subtype of AbstractSymmetricMatrixSetTriangle)\n\nbeginalign*\n     max_x in mathbbR  x\n    \n     textst \n    (1 -x 1)  in textPositiveSemidefiniteConeTriangle(2)\nendalign*\n\nThe dual is the following problem\n\nbeginalign*\n     min_x in mathbbR^3  y_1 + y_3\n    \n     textst  2y_2  = 1\n      y  in textPositiveSemidefiniteConeTriangle(2)\nendalign*\n\nWhy do we use 2y_2 in the dual constraint instead of y_2 ? The reason is that 2y_2 is the scalar product between y and the symmetric matrix whose vectorized form is (0 1 0). Indeed, with our modified scalar products we have\n\nlangle\n(0 1 0)\n(y_1 y_2 y_3)\nrangle\n=\nmathrmtrace\nbeginpmatrix\n  0  1\n  1  0\nendpmatrix\nbeginpmatrix\n  y_1  y_2\n  y_2  y_3\nendpmatrix\n= 2y_2\n\nReferences\n\n[1] Boyd, S. and Vandenberghe, L.. Convex optimization. Cambridge university     press, 2004.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.AbstractSymmetricMatrixSetSquare","page":"Standard form","title":"MathOptInterface.AbstractSymmetricMatrixSetSquare","text":"abstract type AbstractSymmetricMatrixSetSquare <: AbstractVectorSet end\n\nAbstract supertype for subsets of the (vectorized) cone of symmetric matrices, with side_dimension rows and columns. The entries of the matrix are given column by column (or equivalently, row by row). The matrix is both constrained to be symmetric and to have its triangular_form belong to the corresponding set. That is, if the functions in entries (i j) and (j i) are different, then a constraint will be added to make sure that the entries are equal.\n\nExample\n\nPositiveSemidefiniteConeSquare is a subtype of AbstractSymmetricMatrixSetSquare and constraining the matrix\n\nbeginbmatrix\n  1  -y\n  -z  0\nendbmatrix\n\nto be symmetric positive semidefinite can be achieved by constraining the vector (1 -z -y 0) (or (1 -y -z 0)) to belong to the PositiveSemidefiniteConeSquare(2). It both constrains y = z and (1 -y 0) (or (1 -z 0)) to be in PositiveSemidefiniteConeTriangle(2), since triangular_form(PositiveSemidefiniteConeSquare) is PositiveSemidefiniteConeTriangle.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.side_dimension","page":"Standard form","title":"MathOptInterface.side_dimension","text":"side_dimension(\n    set::Union{\n        AbstractSymmetricMatrixSetTriangle,\n        AbstractSymmetricMatrixSetSquare,\n        HermitianPositiveSemidefiniteConeTriangle,\n    },\n)\n\nSide dimension of the matrices in set.\n\nConvention\n\nBy convention, the side dimension should be stored in the side_dimension field. If this is not the case for a subtype of AbstractSymmetricMatrixSetTriangle, or AbstractSymmetricMatrixSetSquare you must implement this method.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/#MathOptInterface.triangular_form","page":"Standard form","title":"MathOptInterface.triangular_form","text":"triangular_form(S::Type{<:AbstractSymmetricMatrixSetSquare})\ntriangular_form(set::AbstractSymmetricMatrixSetSquare)\n\nReturn the AbstractSymmetricMatrixSetTriangle corresponding to the vectorization of the upper triangular part of matrices in the AbstractSymmetricMatrixSetSquare set.\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"List of recognized matrix sets.","category":"page"},{"location":"moi/reference/standard_form/","page":"Standard form","title":"Standard form","text":"PositiveSemidefiniteConeTriangle\nPositiveSemidefiniteConeSquare\nHermitianPositiveSemidefiniteConeTriangle\nLogDetConeTriangle\nLogDetConeSquare\nRootDetConeTriangle\nRootDetConeSquare","category":"page"},{"location":"moi/reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeTriangle","page":"Standard form","title":"MathOptInterface.PositiveSemidefiniteConeTriangle","text":"PositiveSemidefiniteConeTriangle(side_dimension::Int) <: AbstractSymmetricMatrixSetTriangle\n\nThe (vectorized) cone of symmetric positive semidefinite matrices, with non-negative side_dimension rows and columns.\n\nSee AbstractSymmetricMatrixSetTriangle for more details on the vectorized form.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeSquare","page":"Standard form","title":"MathOptInterface.PositiveSemidefiniteConeSquare","text":"PositiveSemidefiniteConeSquare(side_dimension::Int) <: AbstractSymmetricMatrixSetSquare\n\nThe cone of symmetric positive semidefinite matrices, with non-negative side length side_dimension.\n\nSee AbstractSymmetricMatrixSetSquare for more details on the vectorized form.\n\nThe entries of the matrix are given column by column (or equivalently, row by row).\n\nThe matrix is both constrained to be symmetric and to be positive semidefinite. That is, if the functions in entries (i j) and (j i) are different, then a constraint will be added to make sure that the entries are equal.\n\nExample\n\nConstraining the matrix\n\nbeginbmatrix\n  1  -y\n  -z  0\nendbmatrix\n\nto be symmetric positive semidefinite can be achieved by constraining the vector (1 -z -y 0) (or (1 -y -z 0)) to belong to the PositiveSemidefiniteConeSquare(2).\n\nIt both constrains y = z and (1 -y 0) (or (1 -z 0)) to be in PositiveSemidefiniteConeTriangle(2).\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.HermitianPositiveSemidefiniteConeTriangle","page":"Standard form","title":"MathOptInterface.HermitianPositiveSemidefiniteConeTriangle","text":"HermitianPositiveSemidefiniteConeTriangle(side_dimension::Int) <: AbstractVectorSet\n\nThe (vectorized) cone of Hermitian positive semidefinite matrices, with non-negative side_dimension rows and columns.\n\nBecaue the matrix is Hermitian, the diagonal elements are real, and the complex-valued lower triangular entries are obtained as the conjugate of corresponding upper triangular entries.\n\nVectorization format\n\nThe vectorized form starts with real part of the entries of the upper triangular part of the matrix, given column by column as explained in AbstractSymmetricMatrixSetSquare.\n\nIt is then followed by the imaginary part of the off-diagonal entries of the upper triangular part, also given column by column.\n\nFor example, the matrix\n\nbeginbmatrix\n  1  2 + 7im  4 + 8im\n  2 - 7im  3  5 + 9im\n  4 - 8im  5 - 9im  6\nendbmatrix\n\nhas side_dimension 3 and is represented as the vector 1 2 3 4 5 6 7 8 9.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.LogDetConeTriangle","page":"Standard form","title":"MathOptInterface.LogDetConeTriangle","text":"LogDetConeTriangle(side_dimension::Int)\n\nThe log-determinant cone  (t u X) in mathbbR^2 + d(d+1)2  t le u log(det(Xu)) u  0 , where the matrix X is represented in the same symmetric packed format as in the PositiveSemidefiniteConeTriangle.\n\nThe non-negative argument side_dimension is the side dimension of the matrix X, that is, its number of rows or columns.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> t = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> X = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(\n           model,\n           MOI.VectorOfVariables([t; X]),\n           MOI.LogDetConeTriangle(2),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.LogDetConeTriangle}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.LogDetConeSquare","page":"Standard form","title":"MathOptInterface.LogDetConeSquare","text":"LogDetConeSquare(side_dimension::Int)\n\nThe log-determinant cone  (t u X) in mathbbR^2 + d^2  t le u log(det(Xu)) X text symmetric u  0 , where the matrix X is represented in the same format as in the PositiveSemidefiniteConeSquare.\n\nSimilarly to PositiveSemidefiniteConeSquare, constraints are added to ensure that X is symmetric.\n\nThe non-negative argument side_dimension is the side dimension of the matrix X, that is, its number of rows or columns.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> t = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> X = reshape(MOI.add_variables(model, 4), 2, 2)\n2×2 Matrix{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(2)  MOI.VariableIndex(4)\n MOI.VariableIndex(3)  MOI.VariableIndex(5)\n\njulia> MOI.add_constraint(\n           model,\n           MOI.VectorOfVariables([t; vec(X)]),\n           MOI.LogDetConeSquare(2),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.LogDetConeSquare}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.RootDetConeTriangle","page":"Standard form","title":"MathOptInterface.RootDetConeTriangle","text":"RootDetConeTriangle(side_dimension::Int)\n\nThe root-determinant cone  (t X) in mathbbR^1 + d(d+1)2  t le det(X)^1d , where the matrix X is represented in the same symmetric packed format as in the PositiveSemidefiniteConeTriangle.\n\nThe non-negative argument side_dimension is the side dimension of the matrix X, that is, its number of rows or columns.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> t = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> X = MOI.add_variables(model, 3);\n\njulia> MOI.add_constraint(\n           model,\n           MOI.VectorOfVariables([t; X]),\n           MOI.RootDetConeTriangle(2),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.RootDetConeTriangle}(1)\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/standard_form/#MathOptInterface.RootDetConeSquare","page":"Standard form","title":"MathOptInterface.RootDetConeSquare","text":"RootDetConeSquare(side_dimension::Int)\n\nThe root-determinant cone  (t X) in mathbbR^1 + d^2  t le det(X)^1d X text symmetric , where the matrix X is represented in the same format as PositiveSemidefiniteConeSquare.\n\nSimilarly to PositiveSemidefiniteConeSquare, constraints are added to ensure that X is symmetric.\n\nThe non-negative argument side_dimension is the side dimension of the matrix X, that is, its number of rows or columns.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> t = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> X = reshape(MOI.add_variables(model, 4), 2, 2)\n2×2 Matrix{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(2)  MOI.VariableIndex(4)\n MOI.VariableIndex(3)  MOI.VariableIndex(5)\n\njulia> MOI.add_constraint(\n           model,\n           MOI.VectorOfVariables([t; vec(X)]),\n           MOI.RootDetConeSquare(2),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.RootDetConeSquare}(1)\n\n\n\n\n\n","category":"type"},{"location":"packages/DAQP/","page":"darnstrom/DAQP.jl","title":"darnstrom/DAQP.jl","text":"EditURL = \"https://github.com/darnstrom/DAQP.jl/blob/v0.5.2/README.md\"","category":"page"},{"location":"packages/DAQP/#DAQP.jl","page":"darnstrom/DAQP.jl","title":"DAQP.jl","text":"","category":"section"},{"location":"packages/DAQP/","page":"darnstrom/DAQP.jl","title":"darnstrom/DAQP.jl","text":"(Image: ) (Image: )","category":"page"},{"location":"packages/DAQP/","page":"darnstrom/DAQP.jl","title":"darnstrom/DAQP.jl","text":"DAQP.jl is a Julia wrapper for the Quadratic Programming solver DAQP.","category":"page"},{"location":"packages/DAQP/#License","page":"darnstrom/DAQP.jl","title":"License","text":"","category":"section"},{"location":"packages/DAQP/","page":"darnstrom/DAQP.jl","title":"darnstrom/DAQP.jl","text":"DAQP.jl is licensed under the MIT license.","category":"page"},{"location":"packages/DAQP/","page":"darnstrom/DAQP.jl","title":"darnstrom/DAQP.jl","text":"The underlying solver, darnstrom/daqp is licensed under the MIT license.","category":"page"},{"location":"packages/DAQP/#Installation","page":"darnstrom/DAQP.jl","title":"Installation","text":"","category":"section"},{"location":"packages/DAQP/","page":"darnstrom/DAQP.jl","title":"darnstrom/DAQP.jl","text":"Install DAQP.jl using the Julia package manager:","category":"page"},{"location":"packages/DAQP/","page":"darnstrom/DAQP.jl","title":"darnstrom/DAQP.jl","text":"import Pkg\nPkg.add(\"DAQP\")","category":"page"},{"location":"packages/DAQP/#Use-with-JuMP","page":"darnstrom/DAQP.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/DAQP/","page":"darnstrom/DAQP.jl","title":"darnstrom/DAQP.jl","text":"To use DAQP with JuMP, do:","category":"page"},{"location":"packages/DAQP/","page":"darnstrom/DAQP.jl","title":"darnstrom/DAQP.jl","text":"using JuMP, DAQP\nmodel = Model(DAQP.Optimizer)","category":"page"},{"location":"packages/DAQP/#Documentation","page":"darnstrom/DAQP.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/DAQP/","page":"darnstrom/DAQP.jl","title":"darnstrom/DAQP.jl","text":"General information about the solver is available at https://darnstrom.github.io/daqp/, and specifics for the Julia interface are available at https://darnstrom.github.io/daqp/start/julia.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"EditURL = \"portfolio.jl\"","category":"page"},{"location":"tutorials/nonlinear/portfolio/#Portfolio-optimization","page":"Portfolio optimization","title":"Portfolio optimization","text":"","category":"section"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"This tutorial was originally contributed by Arpit Bhatia.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"Optimization models play an increasingly important role in financial decisions. Many computational finance problems can be solved efficiently using modern optimization techniques.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"This tutorial solves the famous Markowitz Portfolio Optimization problem with data from lecture notes from a course taught at Georgia Tech by Shabbir Ahmed.","category":"page"},{"location":"tutorials/nonlinear/portfolio/#Required-packages","page":"Portfolio optimization","title":"Required packages","text":"","category":"section"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"This tutorial uses the following packages","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"using JuMP\nimport DataFrames\nimport Ipopt\nimport MultiObjectiveAlgorithms as MOA\nimport Plots\nimport Statistics\nimport StatsPlots","category":"page"},{"location":"tutorials/nonlinear/portfolio/#Formulation","page":"Portfolio optimization","title":"Formulation","text":"","category":"section"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"Suppose we are considering investing 1000 dollars in three non-dividend paying stocks, IBM (IBM), Walmart (WMT), and Southern Electric (SEHI), for a one-month period.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"We will use the initial money to buy shares of the three stocks at the current market prices, hold these for one month, and sell the shares off at the prevailing market prices at the end of the month.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"As a rational investor, we hope to make some profit out of this endeavor, that is, the return on our investment should be positive.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"Suppose we bought a stock at p dollars per share in the beginning of the month, and sold it off at s dollars per share at the end of the month. Then the one-month return on a share of the stock is fracs-pp.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"Since the stock prices are quite uncertain, so is the end-of-month return on our investment. Our goal is to invest in such a way that the expected end-of-month return is at least $50 or 5%. Furthermore, we want to make sure that the “risk” of not achieving our desired return is minimum.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"Note that we are solving the problem under the following assumptions:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"We can trade any continuum of shares.\nNo short-selling is allowed.\nThere are no transaction costs.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"We model this problem by taking decision variables x_i i=123 denoting the dollars invested in each of the 3 stocks.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"Let us denote by tilder_i the random variable corresponding to the monthly return (increase in the stock price) per dollar for stock i.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"Then, the return (or profit) on x_i dollars invested in stock i is tilder_i x_i and the total (random) return on our investment is sum_i=1^3 tilder_i x_i The expected return on our investment is then mathbbEleftsum_i=1^3 tilder_i x_iright=sum_i=1^3 overliner_i x_i where overliner_i is the expected value of the tilder_i","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"Now we need to quantify the notion of “risk” in our investment.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"Markowitz, in his Nobel prize winning work, showed that a rational investor’s notion of minimizing risk can be closely approximated by minimizing the variance of the return of the investment portfolio. This variance is given by:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"operatornameVarleftsum_i=1^3 tilder_i x_iright = sum_i=1^3 sum_j=1^3 x_i x_j sigma_i j","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"where sigma_i j is the covariance of the return of stock i with stock j.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"Note that the right hand side of the equation is the most reduced form of the expression and we have not shown the intermediate steps involved in getting to this form. We can also write this equation as:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"operatornameVarleftsum_i=1^3 tilder_i x_iright =x^top Q x","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"Where Q is the covariance matrix for the random vector tilder.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"Finally, we can write the model as:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"beginaligned\nmin x^top Q x \ntext  st  sum_i=1^3 x_i leq 1000 \noverliner^top x geq 50 \nx geq 0\nendaligned","category":"page"},{"location":"tutorials/nonlinear/portfolio/#Data","page":"Portfolio optimization","title":"Data","text":"","category":"section"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"For the data in our problem, we use the stock prices given below, in monthly values from November 2000, through November 2001.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"df = DataFrames.DataFrame(\n    [\n        93.043 51.826 1.063\n        84.585 52.823 0.938\n        111.453 56.477 1.000\n        99.525 49.805 0.938\n        95.819 50.287 1.438\n        114.708 51.521 1.700\n        111.515 51.531 2.540\n        113.211 48.664 2.390\n        104.942 55.744 3.120\n        99.827 47.916 2.980\n        91.607 49.438 1.900\n        107.937 51.336 1.750\n        115.590 55.081 1.800\n    ],\n    [:IBM, :WMT, :SEHI],\n)","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"Next, we compute the percentage return for the stock in each month:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"returns = diff(Matrix(df); dims = 1) ./ Matrix(df[1:end-1, :])","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"The expected monthly return is:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"r = vec(Statistics.mean(returns; dims = 1))","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"and the covariance matrix is:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"Q = Statistics.cov(returns)","category":"page"},{"location":"tutorials/nonlinear/portfolio/#JuMP-formulation","page":"Portfolio optimization","title":"JuMP formulation","text":"","category":"section"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"model = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, x[1:3] >= 0)\n@objective(model, Min, x' * Q * x)\n@constraint(model, sum(x) <= 1000)\n@constraint(model, r' * x >= 50)\noptimize!(model)\n@assert is_solved_and_feasible(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"The optimal allocation of our assets is:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"value.(x)","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"So we spend $497 on IBM, and $503 on SEHI. This results in a variance of:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"scalar_variance = value(x' * Q * x)","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"and an expected return of:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"scalar_return = value(r' * x)","category":"page"},{"location":"tutorials/nonlinear/portfolio/#Multi-objective-portfolio-optimization","page":"Portfolio optimization","title":"Multi-objective portfolio optimization","text":"","category":"section"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"The previous model returned a single solution that minimized the variance, ensuring that our expected return was at least $50. In practice, we might be willing to accept a slightly higher variance if it meant a much increased expected return. To explore this problem space, we can instead formulate our portfolio optimization problem with two objectives:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"to minimize the variance\nto maximize the expected return","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"The solution to this bi-objective problem is the efficient frontier of modern portfolio theory, and each point in the solution is a point with the best return for a fixed level of risk.","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"model = Model(() -> MOA.Optimizer(Ipopt.Optimizer))\nset_silent(model)","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"We also need to choose a solution algorithm for MOA. For our problem, the efficient frontier will have an infinite number of solutions. Since we cannot find all of the solutions, we choose an approximation algorithm and limit the number of solution points that are returned:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"set_optimizer_attribute(model, MOA.Algorithm(), MOA.EpsilonConstraint())\nset_optimizer_attribute(model, MOA.SolutionLimit(), 50)","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"Now we can define the rest of the model:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"@variable(model, x[1:3] >= 0)\n@constraint(model, sum(x) <= 1000)\n@expression(model, variance, x' * Q * x)\n@expression(model, expected_return, r' * x)\n# We want to minimize variance and maximize expected return, but we must pick\n# a single objective sense `Min`, and negate any `Max` objectives:\n@objective(model, Min, [variance, -expected_return])\noptimize!(model)\n@assert termination_status(model) == OPTIMAL\nsolution_summary(model)","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"The algorithm found 50 different solutions. Let's plot them to see how they differ:","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"objective_space = Plots.hline(\n    [scalar_return];\n    label = \"Single-objective solution\",\n    linecolor = :red,\n)\nPlots.vline!(objective_space, [scalar_variance]; label = \"\", linecolor = :red)\nPlots.scatter!(\n    objective_space,\n    [value(variance; result = i) for i in 1:result_count(model)],\n    [value(expected_return; result = i) for i in 1:result_count(model)];\n    xlabel = \"Variance\",\n    ylabel = \"Expected Return\",\n    label = \"\",\n    title = \"Objective space\",\n    markercolor = \"white\",\n    markersize = 5,\n    legend = :bottomright,\n)\nfor i in 1:result_count(model)\n    y = objective_value(model; result = i)\n    Plots.annotate!(objective_space, y[1], -y[2], (i, 3))\nend\n\ndecision_space = StatsPlots.groupedbar(\n    vcat([value.(x; result = i)' for i in 1:result_count(model)]...);\n    bar_position = :stack,\n    label = [\"IBM\" \"WMT\" \"SEHI\"],\n    xlabel = \"Solution #\",\n    ylabel = \"Investment (\\$)\",\n    title = \"Decision space\",\n)\nPlots.plot(objective_space, decision_space; layout = (2, 1), size = (600, 600))","category":"page"},{"location":"tutorials/nonlinear/portfolio/","page":"Portfolio optimization","title":"Portfolio optimization","text":"Perhaps our trade-off wasn't so bad after all. Our original solution corresponded to picking a solution #17. If we buy more SEHI, we can increase the return, but the variance also increases. If we buy less SEHI, such as a solution like #5 or #6, then we can achieve the corresponding return without deploying all of our capital. We should also note that at no point should we buy WMT.","category":"page"},{"location":"packages/BilevelJuMP/","page":"joaquimg/BilevelJuMP.jl","title":"joaquimg/BilevelJuMP.jl","text":"EditURL = \"https://github.com/joaquimg/BilevelJuMP.jl/blob/v0.6.2/README.md\"","category":"page"},{"location":"packages/BilevelJuMP/#BilevelJuMP.jl","page":"joaquimg/BilevelJuMP.jl","title":"BilevelJuMP.jl","text":"","category":"section"},{"location":"packages/BilevelJuMP/","page":"joaquimg/BilevelJuMP.jl","title":"joaquimg/BilevelJuMP.jl","text":"(Image: Build Status) (Image: Codecov branch) (Image: Docs dev) (Image: Docs stable)","category":"page"},{"location":"packages/BilevelJuMP/","page":"joaquimg/BilevelJuMP.jl","title":"joaquimg/BilevelJuMP.jl","text":"BilevelJuMP.jl is a JuMP extension for modeling and solving bilevel optimization problems.","category":"page"},{"location":"packages/BilevelJuMP/#License","page":"joaquimg/BilevelJuMP.jl","title":"License","text":"","category":"section"},{"location":"packages/BilevelJuMP/","page":"joaquimg/BilevelJuMP.jl","title":"joaquimg/BilevelJuMP.jl","text":"BilevelJuMP.jl is licensed under the MIT license.","category":"page"},{"location":"packages/BilevelJuMP/#Documentation","page":"joaquimg/BilevelJuMP.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/BilevelJuMP/","page":"joaquimg/BilevelJuMP.jl","title":"joaquimg/BilevelJuMP.jl","text":"You can find the documentation at https://joaquimg.github.io/BilevelJuMP.jl/stable/.","category":"page"},{"location":"packages/BilevelJuMP/#Help","page":"joaquimg/BilevelJuMP.jl","title":"Help","text":"","category":"section"},{"location":"packages/BilevelJuMP/","page":"joaquimg/BilevelJuMP.jl","title":"joaquimg/BilevelJuMP.jl","text":"If you need help, please open a GitHub issue.","category":"page"},{"location":"packages/BilevelJuMP/#Example","page":"joaquimg/BilevelJuMP.jl","title":"Example","text":"","category":"section"},{"location":"packages/BilevelJuMP/#Install","page":"joaquimg/BilevelJuMP.jl","title":"Install","text":"","category":"section"},{"location":"packages/BilevelJuMP/","page":"joaquimg/BilevelJuMP.jl","title":"joaquimg/BilevelJuMP.jl","text":"import Pkg\nPkg.add(\"BilevelJuMP\")\nPkg.add(\"HiGHS\")","category":"page"},{"location":"packages/BilevelJuMP/#Run","page":"joaquimg/BilevelJuMP.jl","title":"Run","text":"","category":"section"},{"location":"packages/BilevelJuMP/","page":"joaquimg/BilevelJuMP.jl","title":"joaquimg/BilevelJuMP.jl","text":"using BilevelJuMP, HiGHS\n\nmodel = BilevelModel(\n    HiGHS.Optimizer,\n    mode = BilevelJuMP.FortunyAmatMcCarlMode(primal_big_M = 100, dual_big_M = 100)\n)\n\n@variable(Lower(model), x)\n@variable(Upper(model), y)\n\n@objective(Upper(model), Min, 3x + y)\n@constraints(Upper(model), begin\n    x <= 5\n    y <= 8\n    y >= 0\nend)\n\n@objective(Lower(model), Min, -x)\n@constraints(Lower(model), begin\n     x +  y <= 8\n    4x +  y >= 8\n    2x +  y <= 13\n    2x - 7y <= 0\nend)\n\noptimize!(model)\n\nobjective_value(model) # = 3 * (3.5 * 8/15) + 8/15 # = 6.13...\nvalue(x) # = 3.5 * 8/15 # = 1.86...\nvalue(y) # = 8/15 # = 0.53...","category":"page"},{"location":"packages/Clarabel/","page":"oxfordcontrol/Clarabel.jl","title":"oxfordcontrol/Clarabel.jl","text":"EditURL = \"https://github.com/oxfordcontrol/Clarabel.jl/blob/v0.7.1/README.md\"","category":"page"},{"location":"packages/Clarabel/","page":"oxfordcontrol/Clarabel.jl","title":"oxfordcontrol/Clarabel.jl","text":"<p align=\"center\">\n<picture>\n  <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://github.com/oxfordcontrol/ClarabelDocs/blob/main/docs/src/assets/logo-banner-dark-jl.png?raw=true\" width=60%>\n  <source media=\"(prefers-color-scheme: light)\" srcset=\"https://github.com/oxfordcontrol/ClarabelDocs/blob/main/docs/src/assets/logo-banner-light-jl.png?raw=true\" width=60%>\n  <img alt=\"Clarabel.jl logo\" src=\"https://github.com/oxfordcontrol/ClarabelDocs/blob/main/docs/src/assets/logo-banner-light-jl.png?raw=true\" height=\"25\">\n</picture>\n<h1 align=\"center\" margin=0px>\nInterior Point Conic Optimization for Julia\n</h1>\n   <a href=\"https://github.com/oxfordcontrol/Clarabel.jl/actions\"><img src=\"https://github.com/oxfordcontrol/Clarabel.jl/workflows/ci/badge.svg?branch=main\"></a>\n  <a href=\"https://codecov.io/gh/oxfordcontrol/Clarabel.jl\"><img src=\"https://codecov.io/gh/oxfordcontrol/Clarabel.jl/branch/main/graph/badge.svg?raw=true\"></a>\n  <a href=\"https://oxfordcontrol.github.io/ClarabelDocs/stable\"><img src=\"https://img.shields.io/badge/Documentation-stable-purple.svg?raw=true\"></a>\n  <a href=\"https://opensource.org/licenses/Apache-2.0\"><img src=\"https://img.shields.io/badge/License-Apache%202.0-blue.svg?raw=true\"></a>\n  <a href=\"https://github.com/oxfordcontrol/Clarabel.jl/releases\"><img src=\"https://img.shields.io/badge/Release-v0.7.1-blue.svg?raw=true\"></a>\n</p>","category":"page"},{"location":"packages/Clarabel/","page":"oxfordcontrol/Clarabel.jl","title":"oxfordcontrol/Clarabel.jl","text":"<p align=\"center\">\n  <a href=\"#features\">Features</a> •\n  <a href=\"#installation\">Installation</a> •\n  <a href=\"#license-\">License</a> •\n  <a href=\"https://oxfordcontrol.github.io/ClarabelDocs/stable\">Documentation</a>\n</p>","category":"page"},{"location":"packages/Clarabel/","page":"oxfordcontrol/Clarabel.jl","title":"oxfordcontrol/Clarabel.jl","text":"Clarabel.jl is a Julia implementation of an interior point numerical solver for convex optimization problems using a novel homogeneous embedding.  Clarabel.jl solves the following problem:","category":"page"},{"location":"packages/Clarabel/","page":"oxfordcontrol/Clarabel.jl","title":"oxfordcontrol/Clarabel.jl","text":"beginarrayr\ntextminimize  frac12x^T P x + q^T x2ex\ntextsubject to  Ax + s = b 1ex\n         s in mathcalK\nendarray","category":"page"},{"location":"packages/Clarabel/","page":"oxfordcontrol/Clarabel.jl","title":"oxfordcontrol/Clarabel.jl","text":"with decision variables x in mathbbR^n, s in mathbbR^m and data matrices P=P^top succeq 0, q in mathbbR^n, A in mathbbR^m times n, and b in mathbbR^m. The convex set mathcalK is a composition of convex cones.","category":"page"},{"location":"packages/Clarabel/","page":"oxfordcontrol/Clarabel.jl","title":"oxfordcontrol/Clarabel.jl","text":"For more information see the Clarabel Documentation (stable |  dev).","category":"page"},{"location":"packages/Clarabel/","page":"oxfordcontrol/Clarabel.jl","title":"oxfordcontrol/Clarabel.jl","text":"Clarabel is also available in a Rust implementation with additional language interfaces.  See here.","category":"page"},{"location":"packages/Clarabel/#Features","page":"oxfordcontrol/Clarabel.jl","title":"Features","text":"","category":"section"},{"location":"packages/Clarabel/","page":"oxfordcontrol/Clarabel.jl","title":"oxfordcontrol/Clarabel.jl","text":"Versatile: Clarabel.jl solves linear programs (LPs), quadratic programs (QPs), second-order cone programs (SOCPs) and semidefinite programs (SDPs). It also solves problems with exponential, power cone and generalized power cone constraints.\nQuadratic objectives: Unlike interior point solvers based on the standard homogeneous self-dual embedding (HSDE), Clarabel.jl handles quadratic objectives without requiring any epigraphical reformulation of the objective.   It can therefore be significantly faster than other HSDE-based solvers for problems with quadratic objective functions.\nInfeasibility detection: Infeasible problems are detected using a homogeneous embedding technique.\nJuMP / Convex.jl support: We provide an interface to MathOptInterface (MOI), which allows you to describe your problem in JuMP and Convex.jl.\nArbitrary precision types: You can solve problems with any floating point precision, for example, Float32 or Julia's BigFloat type, using either the native interface, or via MathOptInterface / Convex.jl.\nOpen Source: Our code is available on GitHub and distributed under the Apache 2.0 License","category":"page"},{"location":"packages/Clarabel/#Installation","page":"oxfordcontrol/Clarabel.jl","title":"Installation","text":"","category":"section"},{"location":"packages/Clarabel/","page":"oxfordcontrol/Clarabel.jl","title":"oxfordcontrol/Clarabel.jl","text":"Clarabel.jl can be added via the Julia package manager (type ]): pkg> add Clarabel","category":"page"},{"location":"packages/Clarabel/#License","page":"oxfordcontrol/Clarabel.jl","title":"License 🔍","text":"","category":"section"},{"location":"packages/Clarabel/","page":"oxfordcontrol/Clarabel.jl","title":"oxfordcontrol/Clarabel.jl","text":"This project is licensed under the Apache License  2.0 - see the LICENSE.md file for details.","category":"page"},{"location":"moi/reference/modification/","page":"Modifications","title":"Modifications","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/reference/modification.md\"","category":"page"},{"location":"moi/reference/modification/","page":"Modifications","title":"Modifications","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/reference/modification/#Modifications","page":"Modifications","title":"Modifications","text":"","category":"section"},{"location":"moi/reference/modification/","page":"Modifications","title":"Modifications","text":"modify\nAbstractFunctionModification\nScalarConstantChange\nVectorConstantChange\nScalarCoefficientChange\nScalarQuadraticCoefficientChange\nMultirowChange","category":"page"},{"location":"moi/reference/modification/#MathOptInterface.modify","page":"Modifications","title":"MathOptInterface.modify","text":"Constraint Function\n\nmodify(model::ModelLike, ci::ConstraintIndex, change::AbstractFunctionModification)\n\nApply the modification specified by change to the function of constraint ci.\n\nAn ModifyConstraintNotAllowed error is thrown if modifying constraints is not supported by the model model.\n\nExamples\n\nmodify(model, ci, ScalarConstantChange(10.0))\n\nObjective Function\n\nmodify(model::ModelLike, ::ObjectiveFunction, change::AbstractFunctionModification)\n\nApply the modification specified by change to the objective function of model. To change the function completely, call set instead.\n\nAn ModifyObjectiveNotAllowed error is thrown if modifying objectives is not supported by the model model.\n\nExamples\n\nmodify(model, ObjectiveFunction{ScalarAffineFunction{Float64}}(), ScalarConstantChange(10.0))\n\nMultiple modifications in Constraint Functions\n\nmodify(\n    model::ModelLike,\n    cis::AbstractVector{<:ConstraintIndex},\n    changes::AbstractVector{<:AbstractFunctionModification},\n)\n\nApply multiple modifications specified by changes to the functions of constraints cis.\n\nA ModifyConstraintNotAllowed error is thrown if modifying constraints is not supported by model.\n\nExamples\n\nmodify(\n    model,\n    [ci, ci],\n    [\n        ScalarCoefficientChange{Float64}(VariableIndex(1), 1.0),\n        ScalarCoefficientChange{Float64}(VariableIndex(2), 0.5),\n    ],\n)\n\nMultiple modifications in the Objective Function\n\nmodify(\n    model::ModelLike,\n    attr::ObjectiveFunction,\n    changes::AbstractVector{<:AbstractFunctionModification},\n)\n\nApply multiple modifications specified by changes to the functions of constraints cis.\n\nA ModifyObjectiveNotAllowed error is thrown if modifying objective coefficients is not supported by model.\n\nExamples\n\nmodify(\n    model,\n    ObjectiveFunction{ScalarAffineFunction{Float64}}(),\n    [\n        ScalarCoefficientChange{Float64}(VariableIndex(1), 1.0),\n        ScalarCoefficientChange{Float64}(VariableIndex(2), 0.5),\n    ],\n)\n\n\n\n\n\n","category":"function"},{"location":"moi/reference/modification/#MathOptInterface.AbstractFunctionModification","page":"Modifications","title":"MathOptInterface.AbstractFunctionModification","text":"AbstractFunctionModification\n\nAn abstract supertype for structs which specify partial modifications to functions, to be used for making small modifications instead of replacing the functions entirely.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/modification/#MathOptInterface.ScalarConstantChange","page":"Modifications","title":"MathOptInterface.ScalarConstantChange","text":"ScalarConstantChange{T}(new_constant::T)\n\nA struct used to request a change in the constant term of a scalar-valued function.\n\nApplicable to ScalarAffineFunction and ScalarQuadraticFunction.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/modification/#MathOptInterface.VectorConstantChange","page":"Modifications","title":"MathOptInterface.VectorConstantChange","text":"VectorConstantChange{T}(new_constant::Vector{T})\n\nA struct used to request a change in the constant vector of a vector-valued function.\n\nApplicable to VectorAffineFunction and VectorQuadraticFunction.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/modification/#MathOptInterface.ScalarCoefficientChange","page":"Modifications","title":"MathOptInterface.ScalarCoefficientChange","text":"ScalarCoefficientChange{T}(variable::VariableIndex, new_coefficient::T)\n\nA struct used to request a change in the linear coefficient of a single variable in a scalar-valued function.\n\nApplicable to ScalarAffineFunction and ScalarQuadraticFunction.\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/modification/#MathOptInterface.ScalarQuadraticCoefficientChange","page":"Modifications","title":"MathOptInterface.ScalarQuadraticCoefficientChange","text":"ScalarQuadraticCoefficientChange{T}(\n    variable_1::VariableIndex,\n    variable_2::VariableIndex,\n    new_coefficient::T,\n)\n\nA struct used to request a change in the quadratic coefficient of a ScalarQuadraticFunction.\n\nScaling factors\n\nA ScalarQuadraticFunction has an implicit 0.5 scaling factor in front of the Q matrix. This modification applies to terms in the Q matrix.\n\nIf variable_1 == variable_2, this modification sets the corresponding diagonal element of the Q matrix to new_coefficient.\n\nIf variable_1 != variable_2, this modification is equivalent to setting both the corresponding upper- and lower-triangular elements of the Q matrix to new_coefficient.\n\nAs a consequence:\n\nto modify the term x^2 to become 2x^2, new_coefficient must be 4\nto modify the term xy to become 2xy, new_coefficient must be 2\n\n\n\n\n\n","category":"type"},{"location":"moi/reference/modification/#MathOptInterface.MultirowChange","page":"Modifications","title":"MathOptInterface.MultirowChange","text":"MultirowChange{T}(\n    variable::VariableIndex,\n    new_coefficients::Vector{Tuple{Int64,T}},\n) where {T}\n\nA struct used to request a change in the linear coefficients of a single variable in a vector-valued function.\n\nNew coefficients are specified by (output_index, coefficient) tuples.\n\nApplicable to VectorAffineFunction and VectorQuadraticFunction.\n\n\n\n\n\n","category":"type"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"EditURL = \"https://github.com/mariohsouto/ProxSDP.jl/blob/de648be90e63a69b8d8e4f82371760065d242fe9/README.md\"","category":"page"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"<img src=\"https://raw.githubusercontent.com/mariohsouto/ProxSDP_aux/19f261a912e29c77cb68ee2957a5b41128824f22/logo_proxSDP.png?raw=true\" alt=\"logo\"/>","category":"page"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"ProxSDP is an open-source semidefinite programming (SDP) solver based on the paper \"Exploiting Low-Rank Structure in Semidefinite Programming by Approximate Operator Splitting\".","category":"page"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"The main advantage of ProxSDP over other state-of-the-art solvers is the ability to exploit the low-rank structure inherent to several SDP problems.","category":"page"},{"location":"packages/ProxSDP/#Overview-of-problems-ProxSDP-can-solve","page":"mariohsouto/ProxSDP.jl","title":"Overview of problems ProxSDP can solve","text":"","category":"section"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"General conic convex optimization problems with the presence of the positive semidefinite cone, second-order cone and positive orthant;\nSemidefinite relaxation of nonconvex problems, for example, max-cut, binary MIMO, optimal power flow, sensor localization, sum-of-squares;\nControl theory problems with LMI constraints;\nNuclear norm minimization problems, for example, matrix completion;","category":"page"},{"location":"packages/ProxSDP/#License","page":"mariohsouto/ProxSDP.jl","title":"License","text":"","category":"section"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"ProxSDP is licensed under the MIT License.","category":"page"},{"location":"packages/ProxSDP/#Installation","page":"mariohsouto/ProxSDP.jl","title":"Installation","text":"","category":"section"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"Install ProxSDP using Julia package manager:","category":"page"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"import Pkg\nPkg.add(\"ProxSDP\")","category":"page"},{"location":"packages/ProxSDP/#Documentation","page":"mariohsouto/ProxSDP.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"The online documentation is available at https://mariohsouto.github.io/ProxSDP.jl/latest/.","category":"page"},{"location":"packages/ProxSDP/#Usage","page":"mariohsouto/ProxSDP.jl","title":"Usage","text":"","category":"section"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"Consider the semidefinite programming relaxation of the max-cut problem, as in:","category":"page"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"max   0.25 * W•X\ns.t.  diag(X) = 1,\n      X ≽ 0,","category":"page"},{"location":"packages/ProxSDP/#JuMP","page":"mariohsouto/ProxSDP.jl","title":"JuMP","text":"","category":"section"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"This problem can be solved by the following code using ProxSDP and JuMP.","category":"page"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"# Load packages\nusing ProxSDP, JuMP, LinearAlgebra\n# Number of vertices\nn = 4\n# Graph weights\nW = [\n    18.0  -5.0  -7.0  -6.0\n    -5.0   6.0   0.0  -1.0\n    -7.0   0.0   8.0  -1.0\n    -6.0  -1.0  -1.0   8.0\n]\n# Build Max-Cut SDP relaxation via JuMP\nmodel = Model(ProxSDP.Optimizer)\nset_optimizer_attribute(model, \"log_verbose\", true)\nset_optimizer_attribute(model, \"tol_gap\", 1e-4)\nset_optimizer_attribute(model, \"tol_feasibility\", 1e-4)\n@variable(model, X[1:n, 1:n], PSD)\n@objective(model, Max, 0.25 * LinearAlgebra.dot(W, X))\n@constraint(model, LinearAlgebra.diag(X) .== 1)\n# Solve optimization problem with ProxSDP\noptimize!(model)\n# Retrieve solution\nXsol = value.(X)","category":"page"},{"location":"packages/ProxSDP/#Convex.jl","page":"mariohsouto/ProxSDP.jl","title":"Convex.jl","text":"","category":"section"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"Another alternative is to use ProxSDP via Convex.jl:","category":"page"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"# Load packages\nusing Convex, ProxSDP\n# Number of vertices\nn = 4\n# Graph weights\nW = [\n    18.0  -5.0  -7.0  -6.0\n    -5.0   6.0   0.0  -1.0\n    -7.0   0.0   8.0  -1.0\n    -6.0  -1.0  -1.0   8.0\n]\n# Define optimization problem\nX = Semidefinite(n)\nproblem = maximize(0.25 * dot(W, X), diag(X) == 1)\n# Solve optimization problem with ProxSDP\nsolve!(problem, ProxSDP.Optimizer(log_verbose=true, tol_gap=1e-4, tol_feasibility=1e-4))\n# Get the objective value\nproblem.optval\n# Retrieve solution\nevaluate(X)","category":"page"},{"location":"packages/ProxSDP/#Citing-this-package","page":"mariohsouto/ProxSDP.jl","title":"Citing this package","text":"","category":"section"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"The published version of the paper can be found here and the arXiv version here.","category":"page"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"We kindly request that you cite the paper as:","category":"page"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"@article{souto2020exploiting,\n  author = {Mario Souto and Joaquim D. Garcia and \\'Alvaro Veiga},\n  title = {Exploiting low-rank structure in semidefinite programming by approximate operator splitting},\n  journal = {Optimization},\n  pages = {1-28},\n  year  = {2020},\n  publisher = {Taylor & Francis},\n  doi = {10.1080/02331934.2020.1823387},\n  URL = {https://doi.org/10.1080/02331934.2020.1823387}\n}","category":"page"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"The preprint version of the paper can be found here.","category":"page"},{"location":"packages/ProxSDP/#Disclaimer","page":"mariohsouto/ProxSDP.jl","title":"Disclaimer","text":"","category":"section"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"ProxSDP is a research software, therefore it should not be used in production.\nPlease open an issue if you find any problems, developers will try to fix and find alternatives.\nThere is no continuous development for 32-bit systems, the package should work, but might reach some issues.\nProxSDP assumes primal and dual feasibility.","category":"page"},{"location":"packages/ProxSDP/#ROAD-MAP","page":"mariohsouto/ProxSDP.jl","title":"ROAD MAP","text":"","category":"section"},{"location":"packages/ProxSDP/","page":"mariohsouto/ProxSDP.jl","title":"mariohsouto/ProxSDP.jl","text":"Support for exponential and power cones\nWarm start","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"EditURL = \"https://github.com/jump-dev/HiGHS.jl/blob/v1.9.0/README.md\"","category":"page"},{"location":"packages/HiGHS/#HiGHS.jl","page":"jump-dev/HiGHS.jl","title":"HiGHS.jl","text":"","category":"section"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"HiGHS.jl is a wrapper for the HiGHS solver.","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"It has two components:","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"a thin wrapper around the complete C API\nan interface to MathOptInterface","category":"page"},{"location":"packages/HiGHS/#Affiliation","page":"jump-dev/HiGHS.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"This wrapper is maintained by the JuMP community and is not an official project of the HiGHS developers.","category":"page"},{"location":"packages/HiGHS/#License","page":"jump-dev/HiGHS.jl","title":"License","text":"","category":"section"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"HiGHS.jl is licensed under the MIT License.","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"The underlying solver, ERGO-Code/HiGHS, is licensed under the MIT license.","category":"page"},{"location":"packages/HiGHS/#Installation","page":"jump-dev/HiGHS.jl","title":"Installation","text":"","category":"section"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"Install HiGHS as follows:","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"import Pkg\nPkg.add(\"HiGHS\")","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"In addition to installing the HiGHS.jl package, this will also download and install the HiGHS binaries. You do not need to install HiGHS separately.","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"To use a custom binary, read the Custom solver binaries section of the JuMP documentation.","category":"page"},{"location":"packages/HiGHS/#Use-with-JuMP","page":"jump-dev/HiGHS.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"To use HiGHS with JuMP, use HiGHS.Optimizer:","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"using JuMP, HiGHS\nmodel = Model(HiGHS.Optimizer)\nset_attribute(model, \"presolve\", \"on\")\nset_attribute(model, \"time_limit\", 60.0)","category":"page"},{"location":"packages/HiGHS/#MathOptInterface-API","page":"jump-dev/HiGHS.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"The HiGHS optimizer supports the following constraints and attributes.","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"List of supported objective functions:","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}\nMOI.ObjectiveFunction{MOI.ScalarQuadraticFunction{Float64}}","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"MOI.Reals","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"MOI.ScalarAffineFunction{Float64} in MOI.EqualTo{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.Interval{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.EqualTo{Float64}\nMOI.VariableIndex in MOI.GreaterThan{Float64}\nMOI.VariableIndex in MOI.Integer\nMOI.VariableIndex in MOI.Interval{Float64}\nMOI.VariableIndex in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.Semicontinuous{Float64}\nMOI.VariableIndex in MOI.Semiinteger{Float64}\nMOI.VariableIndex in MOI.ZeroOne","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"MOI.Name()\nMOI.ObjectiveSense()","category":"page"},{"location":"packages/HiGHS/#Options","page":"jump-dev/HiGHS.jl","title":"Options","text":"","category":"section"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"See the HiGHS documentation for a full list of the available options.","category":"page"},{"location":"packages/HiGHS/#C-API","page":"jump-dev/HiGHS.jl","title":"C API","text":"","category":"section"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"The C API can be accessed via HiGHS.Highs_xxx functions, where the names and arguments are identical to the C API.","category":"page"},{"location":"packages/HiGHS/#Threads","page":"jump-dev/HiGHS.jl","title":"Threads","text":"","category":"section"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"HiGHS uses a global scheduler that is shared between threads.","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"Before changing the number of threads using MOI.Threads(), you must call Highs_resetGlobalScheduler(1):","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"using JuMP, HiGHS\nmodel = Model(HiGHS.Optimizer)\nHighs_resetGlobalScheduler(1)\nset_attribute(model, MOI.NumberOfThreads(), 1)","category":"page"},{"location":"packages/HiGHS/","page":"jump-dev/HiGHS.jl","title":"jump-dev/HiGHS.jl","text":"If modifying the number of HiGHS threads across different Julia threads, be sure to read the docstring of Highs_resetGlobalScheduler. In particular, resetting the scheduler is not thread-safe.","category":"page"},{"location":"moi/submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/submodules/FileFormats/reference.md\"","category":"page"},{"location":"moi/submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/FileFormats/reference/#File-Formats","page":"API Reference","title":"File Formats","text":"","category":"section"},{"location":"moi/submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"Functions to help read and write MOI models to/from various file formats. See The FileFormats submodule for more details.","category":"page"},{"location":"moi/submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"FileFormats.Model\nFileFormats.FileFormat\nFileFormats.CBF.Model\nFileFormats.LP.Model\nFileFormats.MOF.Model\nFileFormats.MPS.Model\nFileFormats.NL.Model\nFileFormats.SDPA.Model","category":"page"},{"location":"moi/submodules/FileFormats/reference/#MathOptInterface.FileFormats.Model","page":"API Reference","title":"MathOptInterface.FileFormats.Model","text":"Model(\n    ;\n    format::FileFormat = FORMAT_AUTOMATIC,\n    filename::Union{Nothing, String} = nothing,\n    kwargs...\n)\n\nReturn model corresponding to the FileFormat format, or, if format == FORMAT_AUTOMATIC, guess the format from filename.\n\nThe filename argument is only needed if format == FORMAT_AUTOMATIC.\n\nkwargs are passed to the underlying model constructor.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/FileFormats/reference/#MathOptInterface.FileFormats.FileFormat","page":"API Reference","title":"MathOptInterface.FileFormats.FileFormat","text":"FileFormat\n\nList of accepted export formats.\n\nFORMAT_AUTOMATIC: try to detect the file format based on the file name\nFORMAT_CBF: the Conic Benchmark format\nFORMAT_LP: the LP file format\nFORMAT_MOF: the MathOptFormat file format\nFORMAT_MPS: the MPS file format\nFORMAT_NL: the AMPL .nl file format\nFORMAT_REW: the .rew file format, which is MPS with generic names\nFORMAT_SDPA: the SemiDefinite Programming Algorithm format\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/FileFormats/reference/#MathOptInterface.FileFormats.CBF.Model","page":"API Reference","title":"MathOptInterface.FileFormats.CBF.Model","text":"Model()\n\nCreate an empty instance of FileFormats.CBF.Model.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/FileFormats/reference/#MathOptInterface.FileFormats.LP.Model","page":"API Reference","title":"MathOptInterface.FileFormats.LP.Model","text":"Model(; kwargs...)\n\nCreate an empty instance of FileFormats.LP.Model.\n\nKeyword arguments are:\n\nmaximum_length::Int=255: the maximum length for the name of a variable. lp_solve 5.0 allows only 16 characters, while CPLEX 12.5+ allow 255.\nwarn::Bool=false: print a warning when variables or constraints are renamed.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/FileFormats/reference/#MathOptInterface.FileFormats.MOF.Model","page":"API Reference","title":"MathOptInterface.FileFormats.MOF.Model","text":"Model(; kwargs...)\n\nCreate an empty instance of FileFormats.MOF.Model.\n\nKeyword arguments are:\n\nprint_compact::Bool=false: print the JSON file in a compact format without spaces or newlines.\nwarn::Bool=false: print a warning when variables or constraints are renamed\ndifferentiation_backend::MOI.Nonlinear.AbstractAutomaticDifferentiation = MOI.Nonlinear.SparseReverseMode(): automatic differentiation backend to use when reading models with nonlinear constraints and objectives.\nuse_nlp_block::Bool=true: if true parse \"ScalarNonlinearFunction\" into an MOI.NLPBlock. If false, \"ScalarNonlinearFunction\" are parsed as MOI.ScalarNonlinearFunction functions.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/FileFormats/reference/#MathOptInterface.FileFormats.MPS.Model","page":"API Reference","title":"MathOptInterface.FileFormats.MPS.Model","text":"Model(; kwargs...)\n\nCreate an empty instance of FileFormats.MPS.Model.\n\nKeyword arguments are:\n\nwarn::Bool=false: print a warning when variables or constraints are renamed.\nprint_objsense::Bool=false: print the OBJSENSE section when writing\ngeneric_names::Bool=false: strip all names in the model and replace them with the generic names C$i and R$i for the i'th column and row respectively.\nquadratic_format::QuadraticFormat = kQuadraticFormatGurobi: specify the solver-specific extension used when writing the quadratic components of the model. Options are kQuadraticFormatGurobi, kQuadraticFormatCPLEX, and kQuadraticFormatMosek.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/FileFormats/reference/#MathOptInterface.FileFormats.NL.Model","page":"API Reference","title":"MathOptInterface.FileFormats.NL.Model","text":"Model(; use_nlp_block::Bool = true)\n\nCreate a new Optimizer object.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/FileFormats/reference/#MathOptInterface.FileFormats.SDPA.Model","page":"API Reference","title":"MathOptInterface.FileFormats.SDPA.Model","text":"Model(; number_type::Type = Float64)\n\nCreate an empty instance of FileFormats.SDPA.Model{number_type}.\n\nIt is important to be aware that the SDPA file format is interpreted in geometric form and not standard conic form. The standard conic form and geometric conic form are two dual standard forms for semidefinite programs (SDPs). The geometric conic form of an SDP is as follows:\n\nbeginalign\n min_y in mathbbR^m  b^T y\n\n textst  sum_i=1^m A_i y_i - C  in mathbbK\nendalign\n\nwhere mathcalK is a cartesian product of nonnegative orthant and positive semidefinite matrices that align with a block diagonal structure shared with the matrices A_i and C.\n\nIn other words, the geometric conic form contains free variables and affine constraints in either the nonnegative orthant or the positive semidefinite cone. That is, in the MathOptInterface's terminology, MOI.VectorAffineFunction-in-MOI.Nonnegatives and MOI.VectorAffineFunction-in-MOI.PositiveSemidefiniteConeTriangle constraints.\n\nThe corresponding standard conic form of the dual SDP is as follows:\n\nbeginalign\n max_X in mathbbK  texttr(CX)\n\n textst  texttr(A_iX)  = b_i  i = 1 ldots m\nendalign\n\nIn other words, the standard conic form contains nonnegative and positive semidefinite variables with equality constraints. That is, in the MathOptInterface's terminology, MOI.VectorOfVariables-in-MOI.Nonnegatives, MOI.VectorOfVariables-in-MOI.PositiveSemidefiniteConeTriangle and MOI.ScalarAffineFunction-in-MOI.EqualTo constraints.\n\nIf a model is in standard conic form, use Dualization.jl to transform it into the geometric conic form before writting it. Otherwise, the nonnegative (resp. positive semidefinite) variables will be bridged into free variables with affine constraints constraining them to belong to the nonnegative orthant (resp. positive semidefinite cone) by the MOI.Bridges.Constraint.VectorFunctionizeBridge. Moreover, equality constraints will be bridged into pairs of affine constraints in the nonnegative orthant by the MOI.Bridges.Constraint.SplitIntervalBridge and then the MOI.Bridges.Constraint.VectorizeBridge.\n\nIf a solver is in standard conic form, use Dualization.jl to transform the model read into standard conic form before copying it to the solver. Otherwise, the free variables will be bridged into pairs of variables in the nonnegative orthant by the MOI.Bridges.Variable.FreeBridge and affine constraints will be bridged into equality constraints by creating a slack variable by the MOI.Bridges.Constraint.VectorSlackBridge.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/FileFormats/reference/#Other-helpers","page":"API Reference","title":"Other helpers","text":"","category":"section"},{"location":"moi/submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"FileFormats.NL.SolFileResults","category":"page"},{"location":"moi/submodules/FileFormats/reference/#MathOptInterface.FileFormats.NL.SolFileResults","page":"API Reference","title":"MathOptInterface.FileFormats.NL.SolFileResults","text":"SolFileResults(filename::String, model::Model)\n\nParse the .sol file filename created by solving model and return a SolFileResults struct.\n\nThe returned struct supports the MOI.get API for querying result attributes such as MOI.TerminationStatus, MOI.VariablePrimal, and MOI.ConstraintDual.\n\n\n\n\n\nSolFileResults(\n    raw_status::String,\n    termination_status::MOI.TerminationStatusCode,\n)\n\nReturn a SolFileResults struct with MOI.RawStatusString set to raw_status, MOI.TerminationStatus set to termination_status, and MOI.PrimalStatus and MOI.DualStatus set to NO_SOLUTION.\n\nAll other attributes are un-set.\n\n\n\n\n\n","category":"type"},{"location":"packages/COPT/","page":"COPT-Public/COPT.jl","title":"COPT-Public/COPT.jl","text":"EditURL = \"https://github.com/COPT-Public/COPT.jl/blob/v1.1.16/README.md\"","category":"page"},{"location":"packages/COPT/#COPT.jl","page":"COPT-Public/COPT.jl","title":"COPT.jl","text":"","category":"section"},{"location":"packages/COPT/","page":"COPT-Public/COPT.jl","title":"COPT-Public/COPT.jl","text":"COPT.jl is a wrapper for the COPT (Cardinal Optimizer), a mathematical optimization solver for large-scale optimization problems.","category":"page"},{"location":"packages/COPT/","page":"COPT-Public/COPT.jl","title":"COPT-Public/COPT.jl","text":"COPT includes high-performance solvers for LP, MIP, SOCP, convex QP/QCP and SDP.","category":"page"},{"location":"packages/COPT/#License","page":"COPT-Public/COPT.jl","title":"License","text":"","category":"section"},{"location":"packages/COPT/","page":"COPT-Public/COPT.jl","title":"COPT-Public/COPT.jl","text":"COPT.jl is licensed under the MIT license.","category":"page"},{"location":"packages/COPT/","page":"COPT-Public/COPT.jl","title":"COPT-Public/COPT.jl","text":"The underlying solver is a closed-source commercial product for which you must obtain a license.","category":"page"},{"location":"packages/COPT/#Note","page":"COPT-Public/COPT.jl","title":"Note","text":"","category":"section"},{"location":"packages/COPT/","page":"COPT-Public/COPT.jl","title":"COPT-Public/COPT.jl","text":"When COPT is upgraded to a newer version, you may see an error message such as ERROR: COPT error 4: Unable to create COPT environment, which indicates that you will need to reapply and upgrade your COPT license files as well.","category":"page"},{"location":"packages/COPT/#Installation","page":"COPT-Public/COPT.jl","title":"Installation","text":"","category":"section"},{"location":"packages/COPT/","page":"COPT-Public/COPT.jl","title":"COPT-Public/COPT.jl","text":"Install COPT using the Julia package manager","category":"page"},{"location":"packages/COPT/","page":"COPT-Public/COPT.jl","title":"COPT-Public/COPT.jl","text":"import Pkg\nPkg.add(\"COPT\")","category":"page"},{"location":"packages/COPT/","page":"COPT-Public/COPT.jl","title":"COPT-Public/COPT.jl","text":"When there is no local version of COPT installed, installing COPT.jl will automatically download the necessary solver binaries.","category":"page"},{"location":"packages/COPT/","page":"COPT-Public/COPT.jl","title":"COPT-Public/COPT.jl","text":"Without a license, you can solve small models for non-commercial purpose. We strongly recommend that you apply for a license by following the link above.","category":"page"},{"location":"packages/COPT/#Note-2","page":"COPT-Public/COPT.jl","title":"Note","text":"","category":"section"},{"location":"packages/COPT/","page":"COPT-Public/COPT.jl","title":"COPT-Public/COPT.jl","text":"MacOS Apple M1/ARM: on MacOS with Apple M1 chips, Intel based programs can run via Rosetta. When you installed the COPT binaries manually, then please make sure that the COPT build matches the Julia build. We recommend the Intel based COPT and Julia build, as the Apple M1/ARM build of Julia is experimental.","category":"page"},{"location":"packages/COPT/#Use-with-JuMP","page":"COPT-Public/COPT.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/COPT/","page":"COPT-Public/COPT.jl","title":"COPT-Public/COPT.jl","text":"To use COPT with JuMP, use COPT.Optimizer:","category":"page"},{"location":"packages/COPT/","page":"COPT-Public/COPT.jl","title":"COPT-Public/COPT.jl","text":"using JuMP\nusing COPT\nmodel = Model(COPT.Optimizer)\n@variable(model, x >= 0)\n@variable(model, 0 <= y <= 3)\n@objective(model, Min, 12x + 20y)\n@constraint(model, c1, 6x + 8y >= 100)\n@constraint(model, c2, 7x + 12y >= 120)\nprint(model)\noptimize!(model)\n@show termination_status(model)\n@show primal_status(model)\n@show dual_status(model)\n@show objective_value(model)\n@show value(x)\n@show value(y)\n@show shadow_price(c1)\n@show shadow_price(c2)","category":"page"},{"location":"packages/COPT/","page":"COPT-Public/COPT.jl","title":"COPT-Public/COPT.jl","text":"To use the semidefinite programming solver in COPT with JuMP, use COPT.ConeOptimizer:","category":"page"},{"location":"packages/COPT/","page":"COPT-Public/COPT.jl","title":"COPT-Public/COPT.jl","text":"using JuMP\nusing COPT\nusing LinearAlgebra\nmodel = Model(COPT.ConeOptimizer)\nC = [1.0 -1.0; -1.0 2.0]\n@variable(model, X[1:2, 1:2], PSD)\n@variable(model, z[1:2] >= 0)\n@objective(model, Min, C ⋅ X)\n@constraint(model, c1, X[1, 1] - z[1] == 1)\n@constraint(model, c2, X[2, 2] - z[2] == 1)\noptimize!(model)\n@show termination_status(model)\n@show primal_status(model)\n@show dual_status(model)\n@show objective_value(model)\n@show value.(X)\n@show value.(z)\n@show shadow_price(c1)\n@show shadow_price(c2)","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"EditURL = \"cannery.jl\"","category":"page"},{"location":"tutorials/linear/cannery/#The-cannery-problem","page":"The cannery problem","title":"The cannery problem","text":"","category":"section"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"This tutorial was originally contributed by Louis Luangkesorn.","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"This tutorial solves the cannery problem from Dantzig, Linear Programming and Extensions, Princeton University Press, Princeton, NJ, 1963. This class of problem is known as a transshipment problem.","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"The purpose of this tutorial is to demonstrate how to use JSON data in the formulation of a JuMP model.","category":"page"},{"location":"tutorials/linear/cannery/#Required-packages","page":"The cannery problem","title":"Required packages","text":"","category":"section"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"This tutorial requires the following packages:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"using JuMP\nimport HiGHS\nimport JSON\nimport Test","category":"page"},{"location":"tutorials/linear/cannery/#Formulation","page":"The cannery problem","title":"Formulation","text":"","category":"section"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"The cannery problem assumes we are optimizing the shipment of cases of cans from production plants p in P to markets m in M.","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Each production plant p has a capacity c_p, and each market m has a demand d_m. The shipping cost per case of cans from plant p to market m is d_pm.","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"We wish to find the distribution plan x_pm, the number of cases of cans to ship from plant p to market m, for p in P and m in M that minimizes the shipping costs. We can formulate our problem as the following linear program:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"beginaligned\nmin  sumlimits_p in Psumlimits_m in M d_pm x_pm \ntextst  sumlimits_m in M x_pm le c_p  forall p in P \n             sumlimits_p in P x_pm ge d_m  forall m in M \n             x_pm ge 0  forall p in P m in M\nendaligned","category":"page"},{"location":"tutorials/linear/cannery/#Data","page":"The cannery problem","title":"Data","text":"","category":"section"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"A key feature of the tutorial is to demonstrate how to load data from JSON.","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"For simplicity, we've hard-coded it below. But if the data was available as a .json file, we could use data = JSON.parsefile(filename) to read in the data.","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"data = JSON.parse(\"\"\"\n{\n    \"plants\": {\n        \"Seattle\": {\"capacity\": 350},\n        \"San-Diego\": {\"capacity\": 600}\n    },\n    \"markets\": {\n        \"New-York\": {\"demand\": 300},\n        \"Chicago\": {\"demand\": 300},\n        \"Topeka\": {\"demand\": 300}\n    },\n    \"distances\": {\n        \"Seattle => New-York\": 2.5,\n        \"Seattle => Chicago\": 1.7,\n        \"Seattle => Topeka\": 1.8,\n        \"San-Diego => New-York\": 2.5,\n        \"San-Diego => Chicago\": 1.8,\n        \"San-Diego => Topeka\": 1.4\n    }\n}\n\"\"\")","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Create the set of plants:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"P = keys(data[\"plants\"])","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Create the set of markets:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"M = keys(data[\"markets\"])","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"We also need a function to compute the distance from plant to market:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"distance(p::String, m::String) = data[\"distances\"][\"$(p) => $(m)\"]","category":"page"},{"location":"tutorials/linear/cannery/#JuMP-formulation","page":"The cannery problem","title":"JuMP formulation","text":"","category":"section"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Now we're ready to convert our mathematical formulation into a JuMP model.","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"First, create a new JuMP model. Since we have a linear program, we'll use HiGHS as our optimizer:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"model = Model(HiGHS.Optimizer)","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Our decision variables are indexed over the set of plants and markets:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"@variable(model, x[P, M] >= 0)","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"We need a constraint that each plant can ship no more than its capacity:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"@constraint(model, [p in P], sum(x[p, :]) <= data[\"plants\"][p][\"capacity\"])","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"and each market must receive at least its demand:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"@constraint(model, [m in M], sum(x[:, m]) >= data[\"markets\"][m][\"demand\"])","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Finally, our objective is to minimize the transportation distance:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"@objective(model, Min, sum(distance(p, m) * x[p, m] for p in P, m in M));\nnothing #hide","category":"page"},{"location":"tutorials/linear/cannery/#Solution","page":"The cannery problem","title":"Solution","text":"","category":"section"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Let's optimize and look at the solution:","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"optimize!(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"What's the optimal shipment?","category":"page"},{"location":"tutorials/linear/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Test.@test is_solved_and_feasible(model)\nfor p in P, m in M\n    println(p, \" => \", m, \": \", value(x[p, m]))\nend","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/submodules/Utilities/overview.md\"","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Utilities/overview/#The-Utilities-submodule","page":"Overview","title":"The Utilities submodule","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The Utilities submodule provides a variety of functions and datastructures for managing MOI.ModelLike objects.","category":"page"},{"location":"moi/submodules/Utilities/overview/#Utilities.Model","page":"Overview","title":"Utilities.Model","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Utilities.Model provides an implementation of a ModelLike that efficiently supports all functions and sets defined within MOI. However, given the extensibility of MOI, this might not cover all use cases.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Create a model as follows:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}","category":"page"},{"location":"moi/submodules/Utilities/overview/#Utilities.UniversalFallback","page":"Overview","title":"Utilities.UniversalFallback","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Utilities.UniversalFallback is a layer that sits on top of any ModelLike and provides non-specialized (slower) fallbacks for constraints and attributes that the underlying ModelLike does not support.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"For example, Utilities.Model doesn't support some variable attributes like VariablePrimalStart, so JuMP uses a combination of Universal fallback and Utilities.Model as a generic problem cache:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.Utilities.UniversalFallback(MOI.Utilities.Model{Float64}())\nMOIU.UniversalFallback{MOIU.Model{Float64}}\nfallback for MOIU.Model{Float64}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"warning: Warning\nAdding a UniversalFallback means that your model will now support all constraints, even if the inner-model does not. This can lead to unexpected behavior.","category":"page"},{"location":"moi/submodules/Utilities/overview/#Utilities.@model","page":"Overview","title":"Utilities.@model","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"For advanced use cases that need efficient support for functions and sets defined outside of MOI (but still known at compile time), we provide the Utilities.@model macro.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The @model macro takes a name (for a new type, which must not exist yet), eight tuples specifying the types of constraints that are supported, and then a Bool indicating the type is a subtype of MOI.AbstractOptimizer (if true) or MOI.ModelLike (if false).","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The eight tuples are in the following order:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Un-typed scalar sets, for example, Integer\nTyped scalar sets, for example, LessThan\nUn-typed vector sets, for example, Nonnegatives\nTyped vector sets, for example, PowerCone\nUn-typed scalar functions, for example, VariableIndex\nTyped scalar functions, for example, ScalarAffineFunction\nUn-typed vector functions, for example, VectorOfVariables\nTyped vector functions, for example, VectorAffineFunction","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The tuples can contain more than one element. Typed-sets must be specified without their type parameter, for example, MOI.LessThan, not MOI.LessThan{Float64}.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Here is an example:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.@model(\n           MyNewModel,\n           (MOI.Integer,),                  # Un-typed scalar sets\n           (MOI.GreaterThan,),              # Typed scalar sets\n           (MOI.Nonnegatives,),             # Un-typed vector sets\n           (MOI.PowerCone,),                # Typed vector sets\n           (MOI.VariableIndex,),            # Un-typed scalar functions\n           (MOI.ScalarAffineFunction,),     # Typed scalar functions\n           (MOI.VectorOfVariables,),        # Un-typed vector functions\n           (MOI.VectorAffineFunction,),     # Typed vector functions\n           true,                            # <:MOI.AbstractOptimizer?\n       )\nMathOptInterface.Utilities.GenericOptimizer{T, MathOptInterface.Utilities.ObjectiveContainer{T}, MathOptInterface.Utilities.VariablesContainer{T}, MyNewModelFunctionConstraints{T}} where T\n\njulia> model = MyNewModel{Float64}()\nMOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MyNewModelFunctionConstraints{Float64}}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"warning: Warning\nMyNewModel supports every VariableIndex-in-Set constraint, as well as VariableIndex, ScalarAffineFunction, and ScalarQuadraticFunction objective functions. Implement MOI.supports as needed to forbid constraint and objective function combinations.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"As another example, PATHSolver, which only supports VectorAffineFunction-in-Complements defines its optimizer as:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.@model(\n           PathOptimizer,\n           (),  # Scalar sets\n           (),  # Typed scalar sets\n           (MOI.Complements,),  # Vector sets\n           (),  # Typed vector sets\n           (),  # Scalar functions\n           (),  # Typed scalar functions\n           (),  # Vector functions\n           (MOI.VectorAffineFunction,),  # Typed vector functions\n           true,  # is_optimizer\n       )\nMathOptInterface.Utilities.GenericOptimizer{T, MathOptInterface.Utilities.ObjectiveContainer{T}, MathOptInterface.Utilities.VariablesContainer{T}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{T}, MathOptInterface.Complements}} where T","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"However, PathOptimizer does not support some VariableIndex-in-Set constraints, so we must explicitly define:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> function MOI.supports_constraint(\n           ::PathOptimizer,\n           ::Type{MOI.VariableIndex},\n           ::Type{Union{<:MOI.Semiinteger,MOI.Semicontinuous,MOI.ZeroOne,MOI.Integer}}\n       )\n           return false\n       end","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Finally, PATH doesn't support an objective function, so we need to add:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.supports(::PathOptimizer, ::MOI.ObjectiveFunction) = false","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"warning: Warning\nThis macro creates a new type, so it must be called from the top-level of a module, for example, it cannot be called from inside a function.","category":"page"},{"location":"moi/submodules/Utilities/overview/#Utilities.CachingOptimizer","page":"Overview","title":"Utilities.CachingOptimizer","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"A [Utilities.CachingOptimizer] is an MOI layer that abstracts the difference between solvers that support incremental modification (for example, they support adding variables one-by-one), and solvers that require the entire problem in a single API call (for example, they only accept the A, b and c matrices of a linear program).","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"It has two parts:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"A cache, where the model can be built and modified incrementally\nAn optimizer, which is used to solve the problem","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.Utilities.CachingOptimizer(\n           MOI.Utilities.Model{Float64}(),\n           PathOptimizer{Float64}(),\n       )\nMOIU.CachingOptimizer{MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}, MOIU.Model{Float64}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.Model{Float64}\nwith optimizer MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"A Utilities.CachingOptimizer may be in one of three possible states:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"NO_OPTIMIZER: The CachingOptimizer does not have any optimizer.\nEMPTY_OPTIMIZER: The CachingOptimizer has an empty optimizer, and it is not synchronized with the cached model. Modifications are forwarded to the cache, but not to the optimizer.\nATTACHED_OPTIMIZER: The CachingOptimizer has an optimizer, and it is synchronized with the cached model. Modifications are forwarded to the optimizer. If the optimizer does not support modifications, and error will be thrown.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Use Utilities.attach_optimizer to go from EMPTY_OPTIMIZER to ATTACHED_OPTIMIZER:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.attach_optimizer(model)\n\njulia> model\nMOIU.CachingOptimizer{MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}, MOIU.Model{Float64}}\nin state ATTACHED_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.Model{Float64}\nwith optimizer MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"info: Info\nYou must be in ATTACHED_OPTIMIZER to use optimize!.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Use Utilities.reset_optimizer to go from ATTACHED_OPTIMIZER to EMPTY_OPTIMIZER:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.reset_optimizer(model)\n\njulia> model\nMOIU.CachingOptimizer{MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}, MOIU.Model{Float64}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.Model{Float64}\nwith optimizer MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"info: Info\nCalling MOI.empty!(model) also resets the state to EMPTY_OPTIMIZER. So after emptying a model, the modification will only be applied to the cache.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Use Utilities.drop_optimizer to go from any state to NO_OPTIMIZER:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.drop_optimizer(model)\n\njulia> model\nMOIU.CachingOptimizer{MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}, MOIU.Model{Float64}}\nin state NO_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.Model{Float64}\nwith optimizer nothing","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Pass an empty optimizer to Utilities.reset_optimizer to go from NO_OPTIMIZER to EMPTY_OPTIMIZER:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.reset_optimizer(model, PathOptimizer{Float64}())\n\njulia> model\nMOIU.CachingOptimizer{MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}, MOIU.Model{Float64}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.Model{Float64}\nwith optimizer MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Deciding when to attach and reset the optimizer is tedious, and you will often write code like this:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"try\n    # modification\ncatch\n    MOI.Utilities.reset_optimizer(model)\n    # Re-try modification\nend","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"To make this easier, Utilities.CachingOptimizer has two modes of operation:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"AUTOMATIC: The CachingOptimizer changes its state when necessary. Attempting to add a constraint or perform a modification not supported by the optimizer results in a drop to EMPTY_OPTIMIZER mode.\nMANUAL: The user must change the state of the CachingOptimizer. Attempting to perform an operation in the incorrect state results in an error.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"By default, AUTOMATIC mode is chosen. However, you can create a CachingOptimizer in MANUAL mode as follows:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.Utilities.CachingOptimizer(\n           MOI.Utilities.Model{Float64}(),\n           MOI.Utilities.MANUAL,\n       )\nMOIU.CachingOptimizer{MOI.AbstractOptimizer, MOIU.Model{Float64}}\nin state NO_OPTIMIZER\nin mode MANUAL\nwith model cache MOIU.Model{Float64}\nwith optimizer nothing\n\njulia> MOI.Utilities.reset_optimizer(model, PathOptimizer{Float64}())\n\njulia> model\nMOIU.CachingOptimizer{MOI.AbstractOptimizer, MOIU.Model{Float64}}\nin state EMPTY_OPTIMIZER\nin mode MANUAL\nwith model cache MOIU.Model{Float64}\nwith optimizer MOIU.GenericOptimizer{Float64, MOIU.ObjectiveContainer{Float64}, MOIU.VariablesContainer{Float64}, MOIU.VectorOfConstraints{MOI.VectorAffineFunction{Float64}, MOI.Complements}}","category":"page"},{"location":"moi/submodules/Utilities/overview/#Printing","page":"Overview","title":"Printing","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Use print to print the formulation of the model.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.Utilities.Model{Float64}();\n\njulia> x = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> MOI.set(model, MOI.VariableName(), x, \"x_var\")\n\njulia> MOI.add_constraint(model, x, MOI.ZeroOne())\nMathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}(1)\n\njulia> MOI.set(model, MOI.ObjectiveFunction{typeof(x)}(), x)\n\njulia> MOI.set(model, MOI.ObjectiveSense(), MOI.MAX_SENSE)\n\njulia> print(model)\nMaximize VariableIndex:\n x_var\n\nSubject to:\n\nVariableIndex-in-ZeroOne\n x_var ∈ {0, 1}","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Use Utilities.latex_formulation to display the model in LaTeX form:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.latex_formulation(model)\n$$ \\begin{aligned}\n\\max\\quad & x\\_var \\\\\n\\text{Subject to}\\\\\n & \\text{VariableIndex-in-ZeroOne} \\\\\n & x\\_var \\in \\{0, 1\\} \\\\\n\\end{aligned} $$","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"tip: Tip\nIn IJulia, calling print or ending a cell with Utilities.latex_formulation will render the model in LaTeX.","category":"page"},{"location":"moi/submodules/Utilities/overview/#Utilities.PenaltyRelaxation","page":"Overview","title":"Utilities.PenaltyRelaxation","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Pass Utilities.PenaltyRelaxation to modify to relax the problem by adding penalized slack variables to the constraints. This is helpful when debugging sources of infeasible models.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.Utilities.Model{Float64}();\n\njulia> x = MOI.add_variable(model);\n\njulia> MOI.set(model, MOI.VariableName(), x, \"x\")\n\njulia> c = MOI.add_constraint(model, 1.0 * x, MOI.LessThan(2.0));\n\njulia> map = MOI.modify(model, MOI.Utilities.PenaltyRelaxation(Dict(c => 2.0)));\n\njulia> print(model)\nMinimize ScalarAffineFunction{Float64}:\n 0.0 + 2.0 v[2]\n\nSubject to:\n\nScalarAffineFunction{Float64}-in-LessThan{Float64}\n 0.0 + 1.0 x - 1.0 v[2] <= 2.0\n\nVariableIndex-in-GreaterThan{Float64}\n v[2] >= 0.0\n\njulia> map[c]\n0.0 + 1.0 MOI.VariableIndex(2)","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"You can also modify a single constraint using Utilities.ScalarPenaltyRelaxation:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.Utilities.Model{Float64}();\n\njulia> x = MOI.add_variable(model);\n\njulia> MOI.set(model, MOI.VariableName(), x, \"x\")\n\njulia> c = MOI.add_constraint(model, 1.0 * x, MOI.LessThan(2.0));\n\njulia> f = MOI.modify(model, c, MOI.Utilities.ScalarPenaltyRelaxation(2.0));\n\njulia> print(model)\nMinimize ScalarAffineFunction{Float64}:\n 0.0 + 2.0 v[2]\n\nSubject to:\n\nScalarAffineFunction{Float64}-in-LessThan{Float64}\n 0.0 + 1.0 x - 1.0 v[2] <= 2.0\n\nVariableIndex-in-GreaterThan{Float64}\n v[2] >= 0.0\n\njulia> f\n0.0 + 1.0 MOI.VariableIndex(2)","category":"page"},{"location":"moi/submodules/Utilities/overview/#Utilities.MatrixOfConstraints","page":"Overview","title":"Utilities.MatrixOfConstraints","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The constraints of Utilities.Model are stored as a vector of tuples of function and set in a Utilities.VectorOfConstraints.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Other representations can be used by parameterizing the type Utilities.GenericModel (resp. Utilities.GenericOptimizer).","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"For example, if all non-VariableIndex constraints are affine, the coefficients of all the constraints can be stored in a single sparse matrix using Utilities.MatrixOfConstraints.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The constraints storage can even be customized up to a point where it exactly matches the storage of the solver of interest, in which case copy_to can be implemented for the solver by calling copy_to to this custom model.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"For example, Clp.jl defines the following model:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.Utilities.@product_of_sets(\n           SupportedSets,\n           MOI.EqualTo{T},\n           MOI.LessThan{T},\n           MOI.GreaterThan{T},\n           MOI.Interval{T},\n       );\n\njulia> const OptimizerCache = MOI.Utilities.GenericModel{\n           Float64,\n           MOI.Utilities.ObjectiveContainer{Float64},\n           MOI.Utilities.VariablesContainer{Float64},\n           MOI.Utilities.MatrixOfConstraints{\n               Float64,\n               MOI.Utilities.MutableSparseMatrixCSC{\n                   # The data type of the coefficients\n                   Float64,\n                   # The data type of the variable indices\n                   Cint,\n                   # Can also be MOI.Utilities.OneBasedIndexing\n                   MOI.Utilities.ZeroBasedIndexing,\n               },\n               MOI.Utilities.Hyperrectangle{Float64},\n               SupportedSets{Float64},\n           },\n       };","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Given the input model:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> src = MOI.Utilities.Model{Float64}();\n\njulia> MOI.Utilities.loadfromstring!(\n           src,\n           \"\"\"\n           variables: x, y, z\n           maxobjective: x + 2.0 * y + -3.1 * z\n           x + y <= 1.0\n           2.0 * y >= 3.0\n           -4.0 * x + z == 5.0\n           x in Interval(0.0, 1.0)\n           y <= 10.0\n           z == 5.0\n           \"\"\",\n       )","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"We can construct a new cached model and copy src to it:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> dest = OptimizerCache();\n\njulia> index_map = MOI.copy_to(dest, src);","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"From dest, we can access the A matrix in sparse matrix form:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> A = dest.constraints.coefficients;\n\njulia> A.n\n3\n\njulia> A.m\n3\n\njulia> A.colptr\n4-element Vector{Int32}:\n 0\n 1\n 3\n 5\n\njulia> A.rowval\n5-element Vector{Int32}:\n 0\n 1\n 2\n 0\n 1\n\njulia> A.nzval\n5-element Vector{Float64}:\n  1.0\n  1.0\n  2.0\n -4.0\n  1.0","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The lower and upper row bounds:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> row_bounds = dest.constraints.constants;\n\njulia> row_bounds.lower\n3-element Vector{Float64}:\n   5.0\n -Inf\n   3.0\n\njulia> row_bounds.upper\n3-element Vector{Float64}:\n  5.0\n  1.0\n Inf","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The lower and upper variable bounds:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> dest.variables.lower\n3-element Vector{Float64}:\n   5.0\n -Inf\n   0.0\n\njulia> dest.variables.upper\n3-element Vector{Float64}:\n  5.0\n 10.0\n  1.0","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Because of larger variations between solvers, the objective can be queried using the standard MOI methods:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"julia> MOI.get(dest, MOI.ObjectiveSense())\nMAX_SENSE::OptimizationSense = 1\n\njulia> F = MOI.get(dest, MOI.ObjectiveFunctionType())\nMathOptInterface.ScalarAffineFunction{Float64}\n\njulia> F = MOI.get(dest, MOI.ObjectiveFunction{F}())\n0.0 + 1.0 MOI.VariableIndex(3) + 2.0 MOI.VariableIndex(2) - 3.1 MOI.VariableIndex(1)","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Thus, Clp.jl implements copy_to methods similar to the following:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"# This method copies from the cache to the `Clp.Optimizer` object.\nfunction MOI.copy_to(dest::Optimizer, src::OptimizerCache)\n    @assert MOI.is_empty(dest)\n    A = src.constraints.coefficients\n    row_bounds = src.constraints.constants\n    Clp_loadProblem(\n        dest,\n        A.n,\n        A.m,\n        A.colptr,\n        A.rowval,\n        A.nzval,\n        src.lower_bound,\n        src.upper_bound,\n        # (...) objective vector (omitted),\n        row_bounds.lower,\n        row_bounds.upper,\n    )\n    return MOI.Utilities.identity_index_map(src)\nend\n\n# This method copies from an arbitrary model to the optimizer, by the\n# intermediate `OptimizerCache` representation.\nfunction MOI.copy_to(dest::Optimizer, src::MOI.ModelLike)\n    cache = OptimizerCache()\n    index_map = MOI.copy_to(cache, src)\n    MOI.copy_to(dest, cache)\n    return index_map\nend\n\n# This is a special method that gets called in some cases when `OptimizerCache`\n# is used as the backing data structure in a `MOI.Utilities.CachingOptimizer`.\n# It is needed for performance, but not correctness.\nfunction MOI.copy_to(\n    dest::Optimizer,\n    src::MOI.Utilities.UniversalFallback{OptimizerCache},\n)\n    MOI.Utilities.throw_unsupported(src)\n    return MOI.copy_to(dest, src.model)\nend","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"tip: Tip\nFor other examples of Utilities.MatrixOfConstraints, see:Cbc.jl\nECOS.jl\nSCS.jl","category":"page"},{"location":"moi/submodules/Utilities/overview/#ModelFilter","page":"Overview","title":"ModelFilter","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"Utilities provides Utilities.ModelFilter as a useful tool to copy a subset of a model. For example, given an infeasible model, we can copy the irreducible infeasible subsystem (for models implementing ConstraintConflictStatus) as follows:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"my_filter(::Any) = true\nfunction my_filter(ci::MOI.ConstraintIndex)\n    status = MOI.get(dest, MOI.ConstraintConflictStatus(), ci)\n    return status != MOI.NOT_IN_CONFLICT\nend\nfiltered_src = MOI.Utilities.ModelFilter(my_filter, src)\nindex_map = MOI.copy_to(dest, filtered_src)","category":"page"},{"location":"moi/submodules/Utilities/overview/#Fallbacks","page":"Overview","title":"Fallbacks","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The value of some attributes can be inferred from the value of other attributes.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"For example, the value of ObjectiveValue can be computed using ObjectiveFunction and VariablePrimal.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"When a solver gives direct access to an attribute, it is better to return this value. However, if this is not the case, Utilities.get_fallback can be used instead. For example:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"function MOI.get(model::Optimizer, attr::MOI.ObjectiveFunction)\n    return MOI.Utilities.get_fallback(model, attr)\nend","category":"page"},{"location":"moi/submodules/Utilities/overview/#DoubleDicts","page":"Overview","title":"DoubleDicts","text":"","category":"section"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"When writing MOI interfaces, we often need to handle situations in which we map ConstraintIndexs to different values. For example, to a string for ConstraintName.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"One option is to use a dictionary like Dict{MOI.ConstraintIndex,String}. However, this incurs a performance cost because the key is not a concrete type.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The DoubleDicts submodule helps this situation by providing two types main types Utilities.DoubleDicts.DoubleDict and Utilities.DoubleDicts.IndexDoubleDict. These types act like normal dictionaries, but internally they use more efficient dictionaries specialized to the type of the function-set pair.","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"The most common usage of a DoubleDict is in the index_map returned by copy_to. Performance can be improved, by using a function barrier. That is, instead of code like:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"index_map = MOI.copy_to(dest, src)\nfor (F, S) in MOI.get(src, MOI.ListOfConstraintTypesPresent())\n    for ci in MOI.get(src, MOI.ListOfConstraintIndices{F,S}())\n        dest_ci = index_map[ci]\n        # ...\n    end\nend","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"use instead:","category":"page"},{"location":"moi/submodules/Utilities/overview/","page":"Overview","title":"Overview","text":"function function_barrier(\n    dest,\n    src,\n    index_map::MOI.Utilities.DoubleDicts.IndexDoubleDictInner{F,S},\n) where {F,S}\n    for ci in MOI.get(src, MOI.ListOfConstraintIndices{F,S}())\n        dest_ci = index_map[ci]\n        # ...\n    end\n    return\nend\n\nindex_map = MOI.copy_to(dest, src)\nfor (F, S) in MOI.get(src, MOI.ListOfConstraintTypesPresent())\n    function_barrier(dest, src, index_map[F, S])\nend","category":"page"},{"location":"moi/submodules/Test/reference/","page":"API Reference","title":"API Reference","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/submodules/Test/reference.md\"","category":"page"},{"location":"moi/submodules/Test/reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Test/reference/#test_reference","page":"API Reference","title":"The Test submodule","text":"","category":"section"},{"location":"moi/submodules/Test/reference/","page":"API Reference","title":"API Reference","text":"Functions to help test implementations of MOI. See The Test submodule for more details.","category":"page"},{"location":"moi/submodules/Test/reference/","page":"API Reference","title":"API Reference","text":"Test.Config\nTest.runtests\nTest.setup_test\nTest.version_added\nTest.@requires\nTest.RequirementUnmet","category":"page"},{"location":"moi/submodules/Test/reference/#MathOptInterface.Test.Config","page":"API Reference","title":"MathOptInterface.Test.Config","text":"Config(\n    ::Type{T} = Float64;\n    atol::Real = Base.rtoldefault(T),\n    rtol::Real = Base.rtoldefault(T),\n    optimal_status::MOI.TerminationStatusCode = MOI.OPTIMAL,\n    infeasible_status::MOI.TerminationStatusCode = MOI.INFEASIBLE,\n    exclude::Vector{Any} = Any[],\n) where {T}\n\nReturn an object that is used to configure various tests.\n\nConfiguration arguments\n\natol::Real = Base.rtoldefault(T): Control the absolute tolerance used when comparing solutions.\nrtol::Real = Base.rtoldefault(T): Control the relative tolerance used when comparing solutions.\noptimal_status = MOI.OPTIMAL: Set to MOI.LOCALLY_SOLVED if the solver cannot prove global optimality.\ninfeasible_status = MOI.INFEASIBLE: Set to MOI.LOCALLY_INFEASIBLE if the solver cannot prove global infeasibility.\nexclude = Vector{Any}: Pass attributes or functions to exclude to skip parts of tests that require certain functionality. Common arguments include:\nMOI.delete to skip deletion-related tests\nMOI.optimize! to skip optimize-related tests\nMOI.ConstraintDual to skip dual-related tests\nMOI.VariableName to skip setting variable names\nMOI.ConstraintName to skip setting constraint names\n\nExamples\n\nFor a nonlinear solver that finds local optima and does not support finding dual variables or constraint names:\n\nConfig(\n    Float64;\n    optimal_status = MOI.LOCALLY_SOLVED,\n    exclude = Any[\n        MOI.ConstraintDual,\n        MOI.VariableName,\n        MOI.ConstraintName,\n        MOI.delete,\n    ],\n)\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Test/reference/#MathOptInterface.Test.runtests","page":"API Reference","title":"MathOptInterface.Test.runtests","text":"runtests(\n    model::MOI.ModelLike,\n    config::Config;\n    include::Vector{Union{String,Regex}} = String[],\n    exclude::Vector{Union{String,Regex}} = String[],\n    warn_unsupported::Bool = false,\n    exclude_tests_after::VersionNumber = v\"999.0.0\",\n    verbose::Bool = false,\n)\n\nRun all tests in MathOptInterface.Test on model.\n\nConfiguration arguments\n\nconfig is a Test.Config object that can be used to modify the behavior of tests.\nIf include is not empty, only run tests if an element from include occursin the name of the test.\nIf exclude is not empty, skip tests if an element from exclude occursin the name of the test.\nexclude takes priority over include.\nIf warn_unsupported is false, runtests will silently skip tests that fail with a MOI.NotAllowedError, MOI.UnsupportedError, or RequirementUnmet error. (The latter is thrown when an @requires statement returns false.) When warn_unsupported is true, a warning will be printed. For most cases the default behavior, false, is what you want, since these tests likely test functionality that is not supported by model. However, it can be useful to run  warn_unsupported = true to check you are not skipping tests due to a missing supports_constraint method or equivalent.\nexclude_tests_after is a version number that excludes any tests to MOI added after that version number. This is useful for solvers who can declare a fixed set of tests, and not cause their tests to break if a new patch of MOI is released with a new test.\nverbose is a Bool that controls whether the name of the test is printed before executing it. This can be helpful when debugging.\n\nSee also: setup_test.\n\nExample\n\nconfig = MathOptInterface.Test.Config()\nMathOptInterface.Test.runtests(\n    model,\n    config;\n    include = [\"test_linear_\", r\"^test_model_Name$\"],\n    exclude = [\"VariablePrimalStart\"],\n    warn_unsupported = true,\n    verbose = true,\n    exclude_tests_after = v\"0.10.5\",\n)\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Test/reference/#MathOptInterface.Test.setup_test","page":"API Reference","title":"MathOptInterface.Test.setup_test","text":"setup_test(::typeof(f), model::MOI.ModelLike, config::Config)\n\nOverload this method to modify model before running the test function f on model with config. You can also modify the fields in config (for example, to loosen the default tolerances).\n\nThis function should either return nothing, or return a function which, when called with zero arguments, undoes the setup to return the model to its previous state. You do not need to undo any modifications to config.\n\nThis function is most useful when writing new tests of the tests for MOI, but it can also be used to set test-specific tolerances, etc.\n\nSee also: runtests\n\nExample\n\nfunction MOI.Test.setup_test(\n    ::typeof(MOI.Test.test_linear_VariablePrimalStart_partial),\n    mock::MOIU.MockOptimizer,\n    ::MOI.Test.Config,\n)\n    MOIU.set_mock_optimize!(\n        mock,\n        (mock::MOIU.MockOptimizer) -> MOIU.mock_optimize!(mock, [1.0, 0.0]),\n    )\n    mock.eval_variable_constraint_dual = false\n\n    function reset_function()\n        mock.eval_variable_constraint_dual = true\n        return\n    end\n    return reset_function\nend\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Test/reference/#MathOptInterface.Test.version_added","page":"API Reference","title":"MathOptInterface.Test.version_added","text":"version_added(::typeof(function_name))\n\nReturns the version of MOI in which the test function_name was added.\n\nThis method should be implemented for all new tests.\n\nSee the exclude_tests_after keyword of runtests for more details.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Test/reference/#MathOptInterface.Test.@requires","page":"API Reference","title":"MathOptInterface.Test.@requires","text":"@requires(x)\n\nCheck that the condition x is true. Otherwise, throw an RequirementUnmet error to indicate that the model does not support something required by the test function.\n\nExamples\n\n@requires MOI.supports(model, MOI.Silent())\n@test MOI.get(model, MOI.Silent())\n\n\n\n\n\n","category":"macro"},{"location":"moi/submodules/Test/reference/#MathOptInterface.Test.RequirementUnmet","page":"API Reference","title":"MathOptInterface.Test.RequirementUnmet","text":"RequirementUnmet(msg::String) <: Exception\n\nAn error for throwing in tests to indicate that the model does not support some requirement expected by the test function.\n\n\n\n\n\n","category":"type"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"EditURL = \"https://github.com/MadNLP/MadNLP.jl/blob/389561354a774441cd5e6b3aa5fffee102ed222e/README.md\"","category":"page"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"<img src=\"https://github.com/MadNLP/MadNLP.jl/blob/master/logo-full.svg?raw=true\"/>","category":"page"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"Documentation Build Status Coverage DOI\n(Image: doc) (Image: build) (Image: codecov) (Image: DOI)","category":"page"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"MadNLP is a nonlinear programming (NLP) solver, purely implemented in Julia. MadNLP implements a filter line-search algorithm, as that used in Ipopt. MadNLP seeks to streamline the development of modeling and algorithmic paradigms in order to exploit structures and to make efficient use of high-performance computers.","category":"page"},{"location":"packages/MadNLP/#License","page":"MadNLP/MadNLP.jl","title":"License","text":"","category":"section"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"MadNLP is available under the MIT license.","category":"page"},{"location":"packages/MadNLP/#Installation","page":"MadNLP/MadNLP.jl","title":"Installation","text":"","category":"section"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"pkg> add MadNLP","category":"page"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"Optionally, various extension packages can be installed together:","category":"page"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"pkg> add MadNLPHSL, MadNLPPardiso, MadNLPMumps, MadNLPGPU, MadNLPGraph, MadNLPKrylov","category":"page"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"These packages are stored in the lib subdirectory within the main MadNLP repository. Some extension packages may require additional dependencies or specific hardware. For the instructions for the build procedure, see the following links:","category":"page"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"MadNLPHSL\nMadNLPPardiso\nMadNLPGPU","category":"page"},{"location":"packages/MadNLP/#Usage","page":"MadNLP/MadNLP.jl","title":"Usage","text":"","category":"section"},{"location":"packages/MadNLP/#Interfaces","page":"MadNLP/MadNLP.jl","title":"Interfaces","text":"","category":"section"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"MadNLP is interfaced with modeling packages:","category":"page"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"JuMP\nPlasmo\nNLPModels.","category":"page"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"Users can pass various options to MadNLP also through the modeling packages. The interface-specific syntax are shown below. To see the list of MadNLP solver options, check the OPTIONS.md file.","category":"page"},{"location":"packages/MadNLP/#JuMP-interface","page":"MadNLP/MadNLP.jl","title":"JuMP interface","text":"","category":"section"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"using MadNLP, JuMP\nmodel = Model(()->MadNLP.Optimizer(print_level=MadNLP.INFO, max_iter=100))\n@variable(model, x, start = 0.0)\n@variable(model, y, start = 0.0)\n@NLobjective(model, Min, (1 - x)^2 + 100 * (y - x^2)^2)\noptimize!(model)","category":"page"},{"location":"packages/MadNLP/#NLPModels-interface","page":"MadNLP/MadNLP.jl","title":"NLPModels interface","text":"","category":"section"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"using MadNLP, CUTEst\nmodel = CUTEstModel(\"PRIMALC1\")\nmadnlp(model, print_level=MadNLP.WARN, max_wall_time=3600)","category":"page"},{"location":"packages/MadNLP/#Plasmo-interface-(requires-extension-MadNLPGraph)","page":"MadNLP/MadNLP.jl","title":"Plasmo interface (requires extension MadNLPGraph)","text":"","category":"section"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"using MadNLP, MadNLPGraph, Plasmo\ngraph = OptiGraph()\n@optinode(graph,n1)\n@optinode(graph,n2)\n@variable(n1,0 <= x <= 2)\n@variable(n1,0 <= y <= 3)\n@constraint(n1,x+y <= 4)\n@objective(n1,Min,x)\n@variable(n2,x)\n@NLnodeconstraint(n2,exp(x) >= 2)\n@linkconstraint(graph,n1[:x] == n2[:x])\nMadNLP.optimize!(graph; print_level=MadNLP.DEBUG, max_iter=100)","category":"page"},{"location":"packages/MadNLP/#Linear-Solvers","page":"MadNLP/MadNLP.jl","title":"Linear Solvers","text":"","category":"section"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"MadNLP is interfaced with non-Julia sparse/dense linear solvers:","category":"page"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"Umfpack\nMKL-Pardiso\nMKL-Lapack\nHSL solvers (requires extension)\nPardiso (requires extension)\nMumps  (requires extension)\ncuSOLVER (requires extension)","category":"page"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"Each linear solver in MadNLP is a Julia type, and the linear_solver option should be specified by the actual type. Note that the linear solvers are always exported to Main.","category":"page"},{"location":"packages/MadNLP/#Built-in-Solvers:-Umfpack,-PardisoMKL,-LapackCPU","page":"MadNLP/MadNLP.jl","title":"Built-in Solvers: Umfpack, PardisoMKL, LapackCPU","text":"","category":"section"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"using MadNLP, JuMP\n# ...\nmodel = Model(()->MadNLP.Optimizer(linear_solver=UmfpackSolver)) # default\nmodel = Model(()->MadNLP.Optimizer(linear_solver=LapackCPUSolver))","category":"page"},{"location":"packages/MadNLP/#HSL-(requires-extension-MadNLPHSL)","page":"MadNLP/MadNLP.jl","title":"HSL (requires extension MadNLPHSL)","text":"","category":"section"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"using MadNLP, MadNLPHSL, JuMP\n# ...\nmodel = Model(()->MadNLP.Optimizer(linear_solver=Ma27Solver))\nmodel = Model(()->MadNLP.Optimizer(linear_solver=Ma57Solver))\nmodel = Model(()->MadNLP.Optimizer(linear_solver=Ma77Solver))\nmodel = Model(()->MadNLP.Optimizer(linear_solver=Ma86Solver))\nmodel = Model(()->MadNLP.Optimizer(linear_solver=Ma97Solver))","category":"page"},{"location":"packages/MadNLP/#Mumps-(requires-extension-MadNLPMumps)","page":"MadNLP/MadNLP.jl","title":"Mumps (requires extension MadNLPMumps)","text":"","category":"section"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"using MadNLP, MadNLPMumps, JuMP\n# ...\nmodel = Model(()->MadNLP.Optimizer(linear_solver=MumpsSolver))","category":"page"},{"location":"packages/MadNLP/#Pardiso-(requires-extension-MadNLPPardiso)","page":"MadNLP/MadNLP.jl","title":"Pardiso (requires extension MadNLPPardiso)","text":"","category":"section"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"using MadNLP, MadNLPPardiso, JuMP\n# ...\nmodel = Model(()->MadNLP.Optimizer(linear_solver=PardisoSolver))\nmodel = Model(()->MadNLP.Optimizer(linear_solver=PardisoMKLSolver))","category":"page"},{"location":"packages/MadNLP/#LapackGPU-(requires-extension-MadNLPGPU)","page":"MadNLP/MadNLP.jl","title":"LapackGPU (requires extension MadNLPGPU)","text":"","category":"section"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"using MadNLP, MadNLPGPU, JuMP\n# ...\nmodel = Model(()->MadNLP.Optimizer(linear_solver=LapackGPUSolver))","category":"page"},{"location":"packages/MadNLP/#Schur-and-Schwarz-(requires-extension-MadNLPGraph)","page":"MadNLP/MadNLP.jl","title":"Schur and Schwarz (requires extension MadNLPGraph)","text":"","category":"section"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"using MadNLP, MadNLPGraph, JuMP\n# ...\nmodel = Model(()->MadNLP.Optimizer(linear_solver=MadNLPSchwarz))\nmodel = Model(()->MadNLP.Optimizer(linear_solver=MadNLPSchur))","category":"page"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"The solvers in MadNLPGraph (Schur and Schwarz) use multi-thread parallelism; thus, Julia session should be started with -t flag.","category":"page"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"julia -t 16 # to use 16 threads","category":"page"},{"location":"packages/MadNLP/#Citing-MadNLP.jl","page":"MadNLP/MadNLP.jl","title":"Citing MadNLP.jl","text":"","category":"section"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"If you use MadNLP.jl in your research, we would greatly appreciate your citing it.","category":"page"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"@article{shin2020graph,\n  title={Graph-Based Modeling and Decomposition of Energy Infrastructures},\n  author={Shin, Sungho and Coffrin, Carleton and Sundar, Kaarthik and Zavala, Victor M},\n  journal={arXiv preprint arXiv:2010.02404},\n  year={2020}\n}","category":"page"},{"location":"packages/MadNLP/#Bug-reports-and-support","page":"MadNLP/MadNLP.jl","title":"Bug reports and support","text":"","category":"section"},{"location":"packages/MadNLP/","page":"MadNLP/MadNLP.jl","title":"MadNLP/MadNLP.jl","text":"Please report issues and feature requests via the GitHub issue tracker.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"manual/variables/#jump_variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The term variable in mathematical optimization has many meanings. For example, optimization variables (also called decision variables) are the unknowns x that we are solving for in the problem:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"beginalign\n     min_x in mathbbR^n  f_0(x)\n    \n     textst  f_i(x)  in mathcalS_i  i = 1 ldots m\nendalign","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"To complicate things, Julia uses variable to mean a binding between a name and a value. For example, in the statement:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x = 1\n1","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"x is a variable that stores the value 1.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP uses variable in a third way, to mean an instance of the VariableRef struct. JuMP variables are the link between Julia and the optimization variables inside a JuMP model.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"This page explains how to create and manage JuMP variables in a variety of contexts.","category":"page"},{"location":"manual/variables/#Create-a-variable","page":"Variables","title":"Create a variable","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Create variables using the @variable macro:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> typeof(x)\nVariableRef (alias for GenericVariableRef{Float64})\n\njulia> num_variables(model)\n1","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Here x is a Julia variable that is bound to a VariableRef object, and we have added 1 decision variable to our model.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"To make the binding more explicit, we could have written:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> x = @variable(model, x)\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"but there is no need to in general; the macro does it for us.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"When creating a variable, you can also specify variable bounds:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x_free)\nx_free\n\njulia> @variable(model, x_lower >= 0)\nx_lower\n\njulia> @variable(model, x_upper <= 1)\nx_upper\n\njulia> @variable(model, 2 <= x_interval <= 3)\nx_interval\n\njulia> @variable(model, x_fixed == 4)\nx_fixed\n\njulia> print(model)\nFeasibility\nSubject to\n x_fixed = 4\n x_lower ≥ 0\n x_interval ≥ 2\n x_upper ≤ 1\n x_interval ≤ 3","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"warning: Warning\nWhen creating a variable with a single lower- or upper-bound, and the value of the bound is not a numeric literal (for example, 1 or 1.0), the name of the variable must appear on the left-hand side. Putting the name on the right-hand side is an error. For example, to create a variable x:a = 1\n@variable(model, x >= 1)      # ✓ Okay\n@variable(model, 1.0 <= x)    # ✓ Okay\n@variable(model, x >= a)      # ✓ Okay\n@variable(model, a <= x)      # × Not okay\n@variable(model, x >= 1 / 2)  # ✓ Okay\n@variable(model, 1 / 2 <= x)  # × Not okay","category":"page"},{"location":"manual/variables/#Containers-of-variables","page":"Variables","title":"Containers of variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The @variable macro also supports creating collections of JuMP variables. We'll cover some brief syntax here; read the Variable containers section for more details.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"You can create arrays of JuMP variables:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2, 1:2])\n2×2 Matrix{VariableRef}:\n x[1,1]  x[1,2]\n x[2,1]  x[2,2]\n\njulia> x[1, 2]\nx[1,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Index sets can be named, and bounds can depend on those names:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, sqrt(i) <= x[i = 1:3] <= i^2)\n3-element Vector{VariableRef}:\n x[1]\n x[2]\n x[3]\n\njulia> x[2]\nx[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Sets can be any Julia type that supports iteration:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x[i = 2:3, j = 1:2:3, [\"red\", \"blue\"]] >= 0)\n3-dimensional DenseAxisArray{VariableRef,3,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, 1:2:3\n    Dimension 3, [\"red\", \"blue\"]\nAnd data, a 2×2×2 Array{VariableRef, 3}:\n[:, :, \"red\"] =\n x[2,1,red]  x[2,3,red]\n x[3,1,red]  x[3,3,red]\n\n[:, :, \"blue\"] =\n x[2,1,blue]  x[2,3,blue]\n x[3,1,blue]  x[3,3,blue]\n\njulia> x[2, 1, \"red\"]\nx[2,1,red]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Sets can depend upon previous indices:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, u[i = 1:2, j = i:3])\nJuMP.Containers.SparseAxisArray{VariableRef, 2, Tuple{Int64, Int64}} with 5 entries:\n  [1, 1]  =  u[1,1]\n  [1, 2]  =  u[1,2]\n  [1, 3]  =  u[1,3]\n  [2, 2]  =  u[2,2]\n  [2, 3]  =  u[2,3]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"and we can filter elements in the sets using the ; syntax:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, v[i = 1:9; mod(i, 3) == 0])\nJuMP.Containers.SparseAxisArray{VariableRef, 1, Tuple{Int64}} with 3 entries:\n  [3]  =  v[3]\n  [6]  =  v[6]\n  [9]  =  v[9]","category":"page"},{"location":"manual/variables/#Registered-variables","page":"Variables","title":"Registered variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"When you create variables, JuMP registers them inside the model using their corresponding symbol. Get a registered name using model[:key]:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> model\nA JuMP Model\nFeasibility problem with:\nVariable: 1\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: x\n\njulia> model[:x] === x\ntrue","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Registered names are most useful when you start to write larger models and want to break up the model construction into functions:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> function set_objective(model::Model)\n           @objective(model, Min, 2 * model[:my_x] + 1)\n           return\n       end\nset_objective (generic function with 1 method)\n\njulia> model = Model();\n\njulia> @variable(model, my_x);\n\njulia> set_objective(model)\n\njulia> print(model)\nMin 2 my_x + 1\nSubject to","category":"page"},{"location":"manual/variables/#anonymous_variables","page":"Variables","title":"Anonymous variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"To reduce the likelihood of accidental bugs, and because JuMP registers variables inside a model, creating two variables with the same name is an error:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, x)\nERROR: An object of name x is already attached to this model. If this\n    is intended, consider using the anonymous construction syntax, for example,\n    `x = @variable(model, [1:N], ...)` where the name of the object does\n    not appear inside the macro.\n\n    Alternatively, use `unregister(model, :x)` to first unregister\n    the existing name from the model. Note that this will not delete the\n    object; it will just remove the reference at `model[:x]`.\n[...]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"A common reason for encountering this error is adding variables in a loop.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"As a work-around, JuMP provides anonymous variables. Create a scalar valued anonymous variable by omitting the name argument:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> x = @variable(model)\n_[1]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Anonymous variables get printed as an underscore followed by a unique index of the variable.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"warning: Warning\nThe index of the variable may not correspond to the column of the variable in the solver.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Create a container of anonymous JuMP variables by dropping the name in front of the [:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> y = @variable(model, [1:2])\n2-element Vector{VariableRef}:\n _[1]\n _[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The <= and >= short-hand cannot be used to set bounds on scalar-valued anonymous JuMP variables. Instead, use the lower_bound and upper_bound keywords:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> x_lower = @variable(model, lower_bound = 1.0)\n_[1]\n\njulia> x_upper = @variable(model, upper_bound = 2.0)\n_[2]\n\njulia> x_interval = @variable(model, lower_bound = 3.0, upper_bound = 4.0)\n_[3]","category":"page"},{"location":"manual/variables/#Variable-names","page":"Variables","title":"Variable names","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"In addition to the symbol that variables are registered with, JuMP variables have a String name that is used for printing and writing to file formats.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Get and set the name of a variable using name and set_name:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> name(x)\n\"x\"\n\njulia> set_name(x, \"my_x_name\")\n\njulia> x\nmy_x_name","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Override the default choice of name using the base_name keyword:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x[i=1:2], base_name = \"my_var\")\n2-element Vector{VariableRef}:\n my_var[1]\n my_var[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Note that names apply to each element of the container, not to the container of variables:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> name(x[1])\n\"my_var[1]\"\n\njulia> set_name(x[1], \"my_x\")\n\njulia> x\n2-element Vector{VariableRef}:\n my_x\n my_var[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"tip: Tip\nFor some models, setting the string name of each variable can take a non-trivial portion of the total time required to build the model. Turn off String names by passing set_string_name = false to @variable:julia> model = Model();\n\njulia> @variable(model, x, set_string_name = false)\n_[1]See Disable string names for more information.","category":"page"},{"location":"manual/variables/#Retrieve-a-variable-by-name","page":"Variables","title":"Retrieve a variable by name","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Retrieve a variable from a model using variable_by_name:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> variable_by_name(model, \"my_x\")\nmy_x","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"If the name is not present, nothing will be returned:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> variable_by_name(model, \"bad_name\")","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"You can only look up individual variables using variable_by_name. Something like this will not work:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, [i = 1:2], base_name = \"my_var\")\n2-element Vector{VariableRef}:\n my_var[1]\n my_var[2]\n\njulia> variable_by_name(model, \"my_var\")","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"To look up a collection of variables, do not use variable_by_name. Instead, register them using the model[:key] = value syntax:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> model[:x] = @variable(model, [i = 1:2], base_name = \"my_var\")\n2-element Vector{VariableRef}:\n my_var[1]\n my_var[2]\n\njulia> model[:x]\n2-element Vector{VariableRef}:\n my_var[1]\n my_var[2]","category":"page"},{"location":"manual/variables/#variable_names_and_bindings","page":"Variables","title":"String names, symbolic names, and bindings","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"It's common for new users to experience confusion relating to JuMP variables. Part of the problem is the overloaded use of \"variable\" in mathematical optimization, along with the difference between the name that a variable is registered under and the String name used for printing.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Here's a summary of the differences:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP variables are created using @variable.\nJuMP variables can be named or anonymous.\nNamed JuMP variables have the form @variable(model, x). For named variables:\nThe String name of the variable is set to \"x\".\nA Julia variable x is created that binds x to  the JuMP variable.\nThe name :x is registered as a key in the model with the value x.\nAnonymous JuMP variables have the form x = @variable(model). For anonymous variables:\nThe String name of the variable is set to \"\". When printed, this is replaced with \"_[i]\" where i is the index of the variable.\nYou control the name of the Julia variable used as the binding.\nNo name is registered as a key in the model.\nThe base_name keyword can override the String name of the variable.\nYou can manually register names in the model via model[:key] = value","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Here's an example that should make things clearer:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> x_binding = @variable(model, base_name = \"x\")\nx\n\njulia> model\nA JuMP Model\nFeasibility problem with:\nVariable: 1\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> x\nERROR: UndefVarError: `x` not defined\n\njulia> x_binding\nx\n\njulia> name(x_binding)\n\"x\"\n\njulia> model[:x_register] = x_binding\nx\n\njulia> model\nA JuMP Model\nFeasibility problem with:\nVariable: 1\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: x_register\n\njulia> model[:x_register]\nx\n\njulia> model[:x_register] === x_binding\ntrue\n\njulia> x\nERROR: UndefVarError: `x` not defined","category":"page"},{"location":"manual/variables/#Create,-delete,-and-modify-variable-bounds","page":"Variables","title":"Create, delete, and modify variable bounds","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Query whether a variable has a bound using has_lower_bound, has_upper_bound, and is_fixed:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> has_lower_bound(x_free)\nfalse\n\njulia> has_upper_bound(x_upper)\ntrue\n\njulia> is_fixed(x_fixed)\ntrue","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"If a variable has a particular bound, query the value of it using lower_bound, upper_bound, and fix_value:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> lower_bound(x_interval)\n2.0\n\njulia> upper_bound(x_interval)\n3.0\n\njulia> fix_value(x_fixed)\n4.0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Querying the value of a bound that does not exist will result in an error.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Delete variable bounds using delete_lower_bound, delete_upper_bound, and unfix:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> delete_lower_bound(x_lower)\n\njulia> has_lower_bound(x_lower)\nfalse\n\njulia> delete_upper_bound(x_upper)\n\njulia> has_upper_bound(x_upper)\nfalse\n\njulia> unfix(x_fixed)\n\njulia> is_fixed(x_fixed)\nfalse","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Set or update variable bounds using set_lower_bound, set_upper_bound, and fix:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> set_lower_bound(x_lower, 1.1)\n\njulia> set_upper_bound(x_upper, 2.1)\n\njulia> fix(x_fixed, 4.1)","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Fixing a variable with existing bounds will throw an error. To delete the bounds prior to fixing, use fix(variable, value; force = true).","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x >= 1)\nx\n\njulia> fix(x, 2)\nERROR: Unable to fix x to 2 because it has existing variable bounds. Consider calling `JuMP.fix(variable, value; force=true)` which will delete existing bounds before fixing the variable.\n\njulia> fix(x, 2; force = true)\n\n\njulia> fix_value(x)\n2.0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"tip: Tip\nUse fix instead of @constraint(model, x == 2). The former modifies variable bounds, while the latter adds a new linear constraint to the problem.","category":"page"},{"location":"manual/variables/#Binary-variables","page":"Variables","title":"Binary variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Binary variables are constrained to the set x in 0 1.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Create a binary variable by passing Bin as an optional positional argument:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x, Bin)\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Check if a variable is binary using is_binary:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> is_binary(x)\ntrue","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Delete a binary constraint using unset_binary:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> unset_binary(x)\n\njulia> is_binary(x)\nfalse","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Binary variables can also be created by setting the binary keyword to true:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x, binary=true)\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"or by using set_binary:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> set_binary(x)","category":"page"},{"location":"manual/variables/#Integer-variables","page":"Variables","title":"Integer variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Integer variables are constrained to the set x in mathbbZ.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Create an integer variable by passing Int as an optional positional argument:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x, Int)\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Check if a variable is integer using is_integer:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> is_integer(x)\ntrue","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Delete an integer constraint using unset_integer.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> unset_integer(x)\n\njulia> is_integer(x)\nfalse","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Integer variables can also be created by setting the integer keyword to true:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x, integer=true)\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"or by using set_integer:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> set_integer(x)","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"tip: Tip\nThe relax_integrality function relaxes all integrality constraints in the model, returning a function that can be called to undo the operation later on.","category":"page"},{"location":"manual/variables/#Semi-integer-and-semi-continuous-variables","page":"Variables","title":"Semi-integer and semi-continuous variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Semi-continuous variables are constrained to the set x in 0 cup l u.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Create a semi-continuous variable using the Semicontinuous set:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x in Semicontinuous(1.5, 3.5))\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Semi-integer variables  are constrained to the set x in 0 cup l l+1 dots u.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Create a semi-integer variable using the Semiinteger set:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x in Semiinteger(1.0, 3.0))\nx","category":"page"},{"location":"manual/variables/#Start-values","page":"Variables","title":"Start values","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"There are two ways to provide a primal starting solution (also called MIP-start or a warmstart) for each variable:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"using the start keyword in the @variable macro\nusing set_start_value","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The starting value of a variable can be queried using start_value. If no start value has been set, start_value will return nothing.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> start_value(x)\n\njulia> @variable(model, y, start = 1)\ny\n\njulia> start_value(y)\n1.0\n\njulia> set_start_value(y, 2)\n\njulia> start_value(y)\n2.0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The start keyword argument can depend on the indices of a variable container:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, z[i = 1:2], start = i^2)\n2-element Vector{VariableRef}:\n z[1]\n z[2]\n\njulia> start_value.(z)\n2-element Vector{Float64}:\n 1.0\n 4.0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"warning: Warning\nSome solvers do not support start values. If a solver does not support start values, an MathOptInterface.UnsupportedAttribute{MathOptInterface.VariablePrimalStart} error will be thrown.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"tip: Tip\nTo set the optimal solution from a previous solve as a new starting value, use all_variables to get a vector of all the variables in the model, then run:x = all_variables(model)\nx_solution = value.(x)\nset_start_value.(x, x_solution)Alternatively, use set_start_values.","category":"page"},{"location":"manual/variables/#delete_a_variable","page":"Variables","title":"Delete a variable","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Use delete to delete a variable from a model. Use is_valid to check if a variable belongs to a model and has not been deleted.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> is_valid(model, x)\ntrue\n\njulia> delete(model, x)\n\njulia> is_valid(model, x)\nfalse","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Deleting a variable does not unregister the corresponding name from the model. Therefore, creating a new variable of the same name will throw an error:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x)\nERROR: An object of name x is already attached to this model. If this\n    is intended, consider using the anonymous construction syntax, for example,\n    `x = @variable(model, [1:N], ...)` where the name of the object does\n    not appear inside the macro.\n\n    Alternatively, use `unregister(model, :x)` to first unregister\n    the existing name from the model. Note that this will not delete the\n    object; it will just remove the reference at `model[:x]`.\n[...]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"After calling delete, call unregister to remove the symbolic reference:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> unregister(model, :x)\n\njulia> @variable(model, x)\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"info: Info\ndelete does not automatically unregister because we do not distinguish between names that are automatically registered by JuMP macros and names that are manually registered by the user by setting values in object_dictionary. In addition, deleting a variable and then adding a new variable of the same name is an easy way to introduce bugs into your code.","category":"page"},{"location":"manual/variables/#Variable-containers","page":"Variables","title":"Variable containers","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP provides a mechanism for creating collections of variables in three types of data structures, which we refer to as containers.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The three types are Arrays, DenseAxisArrays, and SparseAxisArrays. We explain each of these in the following.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"tip: Tip\nYou can read more about containers in the Containers section.","category":"page"},{"location":"manual/variables/#Arrays","page":"Variables","title":"Arrays","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We have already seen the creation of an array of JuMP variables with the x[1:2] syntax. This can be extended to create multi-dimensional arrays of JuMP variables. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2, 1:2])\n2×2 Matrix{VariableRef}:\n x[1,1]  x[1,2]\n x[2,1]  x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Arrays of JuMP variables can be indexed and sliced as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x[1, 2]\nx[1,2]\n\njulia> x[2, :]\n2-element Vector{VariableRef}:\n x[2,1]\n x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Variable bounds can depend upon the indices:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x[i=1:2, j=1:2] >= 2i + j)\n2×2 Matrix{VariableRef}:\n x[1,1]  x[1,2]\n x[2,1]  x[2,2]\n\njulia> lower_bound.(x)\n2×2 Matrix{Float64}:\n 3.0  4.0\n 5.0  6.0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP will form an Array of JuMP variables when it can determine at compile time that the indices are one-based integer ranges. Therefore x[1:b] will create an Array of JuMP variables, but x[a:b] will not. If JuMP cannot determine that the indices are one-based integer ranges (for example, in the case of x[a:b]), JuMP will create a DenseAxisArray instead.","category":"page"},{"location":"manual/variables/#variable_jump_arrays","page":"Variables","title":"DenseAxisArrays","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We often want to create arrays where the indices are not one-based integer ranges. For example, we may want to create a variable indexed by the name of a product or a location. The syntax is the same as that above, except with an arbitrary vector as an index as opposed to a one-based range. The biggest difference is that instead of returning an Array of JuMP variables, JuMP will return a DenseAxisArray. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2, [:A,:B]])\n2-dimensional DenseAxisArray{VariableRef,2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, [:A, :B]\nAnd data, a 2×2 Matrix{VariableRef}:\n x[1,A]  x[1,B]\n x[2,A]  x[2,B]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"DenseAxisArrays can be indexed and sliced as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x[1, :A]\nx[1,A]\n\njulia> x[2, :]\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, [:A, :B]\nAnd data, a 2-element Vector{VariableRef}:\n x[2,A]\n x[2,B]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Bounds can depend upon indices:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x[i=2:3, j=1:2:3] >= 0.5i + j)\n2-dimensional DenseAxisArray{VariableRef,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, 1:2:3\nAnd data, a 2×2 Matrix{VariableRef}:\n x[2,1]  x[2,3]\n x[3,1]  x[3,3]\n\njulia> lower_bound.(x)\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, 1:2:3\nAnd data, a 2×2 Matrix{Float64}:\n 2.0  4.0\n 2.5  4.5","category":"page"},{"location":"manual/variables/#variable_sparseaxisarrays","page":"Variables","title":"SparseAxisArrays","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The third container type that JuMP natively supports is SparseAxisArray. These arrays are created when the indices do not form a rectangular set. For example, this applies when indices have a dependence upon previous indices (called triangular indexing). JuMP supports this as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x[i=1:2, j=i:2])\nJuMP.Containers.SparseAxisArray{VariableRef, 2, Tuple{Int64, Int64}} with 3 entries:\n  [1, 1]  =  x[1,1]\n  [1, 2]  =  x[1,2]\n  [2, 2]  =  x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We can also conditionally create variables via a JuMP-specific syntax. This syntax appends a comparison check that depends upon the named indices and is separated from the indices by a semi-colon (;). For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x[i=1:4; mod(i, 2)==0])\nJuMP.Containers.SparseAxisArray{VariableRef, 1, Tuple{Int64}} with 2 entries:\n  [2]  =  x[2]\n  [4]  =  x[4]","category":"page"},{"location":"manual/variables/#Performance-considerations","page":"Variables","title":"Performance considerations","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"When using the semi-colon as a filter, JuMP iterates over all indices and evaluates the conditional for each combination. If there are many index dimensions and a large amount of sparsity, this can be inefficient.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> N = 10\n10\n\njulia> S = [(1, 1, 1), (N, N, N)]\n2-element Vector{Tuple{Int64, Int64, Int64}}:\n (1, 1, 1)\n (10, 10, 10)\n\njulia> @time @variable(model, x1[i=1:N, j=1:N, k=1:N; (i, j, k) in S])\n  0.203861 seconds (392.22 k allocations: 23.977 MiB, 99.10% compilation time)\nJuMP.Containers.SparseAxisArray{VariableRef, 3, Tuple{Int64, Int64, Int64}} with 2 entries:\n  [1, 1, 1   ]  =  x1[1,1,1]\n  [10, 10, 10]  =  x1[10,10,10]\n\njulia> @time @variable(model, x2[S])\n  0.045407 seconds (65.24 k allocations: 3.771 MiB, 99.15% compilation time)\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, [(1, 1, 1), (10, 10, 10)]\nAnd data, a 2-element Vector{VariableRef}:\n x2[(1, 1, 1)]\n x2[(10, 10, 10)]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The first option is slower because it is equivalent to:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> x1 = Dict{NTuple{3,Int},VariableRef}()\nDict{Tuple{Int64, Int64, Int64}, VariableRef}()\n\njulia> for i in 1:N\n           for j in 1:N\n               for k in 1:N\n                   if (i, j, k) in S\n                       x1[i, j, k] = @variable(model, base_name = \"x1[$i,$j,$k]\")\n                   end\n               end\n           end\n       end\n\njulia> x1\nDict{Tuple{Int64, Int64, Int64}, VariableRef} with 2 entries:\n  (1, 1, 1)    => x1[1,1,1]\n  (10, 10, 10) => x1[10,10,10]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"If performance is a concern, explicitly construct the set of indices instead of using the filtering syntax.","category":"page"},{"location":"manual/variables/#variable_forcing","page":"Variables","title":"Forcing the container type","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"When creating a container of JuMP variables, JuMP will attempt to choose the tightest container type that can store the JuMP variables. Thus, it will prefer to create an Array before a DenseAxisArray and a DenseAxisArray before a SparseAxisArray. However, because this happens at compile time, JuMP does not always make the best choice. To illustrate this, consider the following example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> A = 1:2\n1:2\n\njulia> @variable(model, x[A])\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, 1:2\nAnd data, a 2-element Vector{VariableRef}:\n x[1]\n x[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Since the value (and type) of A is unknown at parsing time, JuMP is unable to infer that A is a one-based integer range. Therefore, JuMP creates a DenseAxisArray, even though it could store these two variables in a standard one-dimensional Array.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We can share our knowledge that it is possible to store these JuMP variables as an array by setting the container keyword:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, y[A], container=Array)\n2-element Vector{VariableRef}:\n y[1]\n y[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP now creates a vector of JuMP variables instead of a DenseAxisArray. Choosing an invalid container type will throw an error.","category":"page"},{"location":"manual/variables/#User-defined-containers","page":"Variables","title":"User-defined containers","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"In addition to the built-in container types, you can create your own collections of JuMP variables.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"tip: Tip\nThis is a point that users often overlook: you are not restricted to the built-in container types in JuMP.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For example, the following code creates a dictionary with symmetric matrices as the values:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> variables = Dict{Symbol,Array{VariableRef,2}}(\n           key => @variable(model, [1:2, 1:2], Symmetric, base_name = \"$(key)\")\n           for key in [:A, :B]\n       )\nDict{Symbol, Matrix{VariableRef}} with 2 entries:\n  :A => [A[1,1] A[1,2]; A[1,2] A[2,2]]\n  :B => [B[1,1] B[1,2]; B[1,2] B[2,2]]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Another common scenario is a request to add variables to existing containers, for example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"using JuMP\nmodel = Model()\n@variable(model, x[1:2] >= 0)\n# Later I want to add\n@variable(model, x[3:4] >= 0)","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"This is not possible with the built-in JuMP container types. However, you can use regular Julia types instead:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> x = model[:x] = @variable(model, [1:2], lower_bound = 0, base_name = \"x\")\n2-element Vector{VariableRef}:\n x[1]\n x[2]\n\njulia> append!(x, @variable(model, [1:2], lower_bound = 0, base_name = \"y\"));\n\njulia> model[:x]\n4-element Vector{VariableRef}:\n x[1]\n x[2]\n y[1]\n y[2]","category":"page"},{"location":"manual/variables/#Semidefinite-variables","page":"Variables","title":"Semidefinite variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Declare a square matrix of JuMP variables to be positive semidefinite by passing PSD as an optional positional argument:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2, 1:2], PSD)\n2×2 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"This will ensure that x is symmetric, and that all of its eigenvalues are nonnegative.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"note: Note\nx must be a square 2-dimensional Array of JuMP variables; it cannot be a DenseAxisArray or a SparseAxisArray.","category":"page"},{"location":"manual/variables/#Symmetric-variables","page":"Variables","title":"Symmetric variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Declare a square matrix of JuMP variables to be symmetric (but not necessarily positive semidefinite) by passing Symmetric  as an optional positional argument:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2, 1:2], Symmetric)\n2×2 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"manual/variables/#variables","page":"Variables","title":"The @variables macro","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"If you have many @variable calls, JuMP provides the macro @variables that can improve readability:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variables(model, begin\n           x\n           y[i=1:2] >= i, (start = i, base_name = \"Y_$i\")\n           z, Bin\n       end)\n(x, VariableRef[Y_1[1], Y_2[2]], z)\n\njulia> print(model)\nFeasibility\nSubject to\n Y_1[1] ≥ 1\n Y_2[2] ≥ 2\n z binary","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The @variables macro returns a tuple of the variables that were defined.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"note: Note\nKeyword arguments must be contained within parentheses.","category":"page"},{"location":"manual/variables/#jump_variables_on_creation","page":"Variables","title":"Variables constrained on creation","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"All uses of the @variable macro documented so far translate into separate calls for variable creation and the adding of any bound or integrality constraints.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For example, @variable(model, x >= 0, Int), is equivalent to:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> set_lower_bound(x, 0.0)\n\njulia> set_integer(x)","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Importantly, the bound and integrality constraints are added after the variable has been created.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"However, some solvers require a set specifying the variable domain to be given when the variable is first created. We say that these variables are constrained on creation.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Use in within @variable to access the special syntax for constraining variables on creation.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For example, the following creates a vector of variables that belong to the SecondOrderCone:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, y[1:3] in SecondOrderCone())\n3-element Vector{VariableRef}:\n y[1]\n y[2]\n y[3]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For contrast, the standard syntax is as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:3])\n3-element Vector{VariableRef}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in SecondOrderCone())\n[x[1], x[2], x[3]] ∈ MathOptInterface.SecondOrderCone(3)","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"An alternate syntax to x in Set is to use the set keyword of @variable. This is most useful when creating anonymous variables:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> x = @variable(model, [1:3], set = SecondOrderCone())\n3-element Vector{VariableRef}:\n _[1]\n _[2]\n _[3]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"note: Note\nYou cannot delete the constraint associated with a variable constrained on creation.","category":"page"},{"location":"manual/variables/#Example:-positive-semidefinite-variables","page":"Variables","title":"Example: positive semidefinite variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"An alternative to the syntax in Semidefinite variables, declare a matrix of JuMP variables to be positive semidefinite using PSDCone:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2, 1:2] in PSDCone())\n2×2 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"manual/variables/#Example:-symmetric-variables","page":"Variables","title":"Example: symmetric variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"As an alternative to the syntax in Symmetric variables, declare a matrix of JuMP variables to be symmetric using SymmetricMatrixSpace:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2, 1:2] in SymmetricMatrixSpace())\n2×2 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"manual/variables/#Example:-skew-symmetric-variables","page":"Variables","title":"Example: skew-symmetric variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Declare a matrix of JuMP variables to be skew-symmetric using SkewSymmetricMatrixSpace:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2, 1:2] in SkewSymmetricMatrixSpace())\n2×2 Matrix{AffExpr}:\n 0        x[1,2]\n -x[1,2]  0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"note: Note\nEven though x is a 2 by 2 matrix, only one decision variable is added to model; the remaining elements in x are linear transformations of the single variable.","category":"page"},{"location":"manual/variables/#Example:-Hermitian-positive-semidefinite-variables","page":"Variables","title":"Example: Hermitian positive semidefinite variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Declare a matrix of JuMP variables to be Hermitian positive semidefinite using HermitianPSDCone:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, H[1:2, 1:2] in HermitianPSDCone())\n2×2 LinearAlgebra.Hermitian{GenericAffExpr{ComplexF64, VariableRef}, Matrix{GenericAffExpr{ComplexF64, VariableRef}}}:\n real(H[1,1])                    real(H[1,2]) + imag(H[1,2]) im\n real(H[1,2]) - imag(H[1,2]) im  real(H[2,2])","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"This adds 4 real variables in the MOI.HermitianPositiveSemidefiniteConeTriangle:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> first(all_constraints(model, Vector{VariableRef}, MOI.HermitianPositiveSemidefiniteConeTriangle))\n[real(H[1,1]), real(H[1,2]), real(H[2,2]), imag(H[1,2])] ∈ MathOptInterface.HermitianPositiveSemidefiniteConeTriangle(2)","category":"page"},{"location":"manual/variables/#Example:-Hermitian-variables","page":"Variables","title":"Example: Hermitian variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Declare a matrix of JuMP variables to be Hermitian using the Hermitian tag:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2, 1:2], Hermitian)\n2×2 LinearAlgebra.Hermitian{GenericAffExpr{ComplexF64, VariableRef}, Matrix{GenericAffExpr{ComplexF64, VariableRef}}}:\n real(x[1,1])                    real(x[1,2]) + imag(x[1,2]) im\n real(x[1,2]) - imag(x[1,2]) im  real(x[2,2])","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"This is equivalent to declaring the variable in HermitianMatrixSpace:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2, 1:2] in HermitianMatrixSpace())\n2×2 LinearAlgebra.Hermitian{GenericAffExpr{ComplexF64, VariableRef}, Matrix{GenericAffExpr{ComplexF64, VariableRef}}}:\n real(x[1,1])                    real(x[1,2]) + imag(x[1,2]) im\n real(x[1,2]) - imag(x[1,2]) im  real(x[2,2])","category":"page"},{"location":"manual/variables/#Why-use-variables-constrained-on-creation?","page":"Variables","title":"Why use variables constrained on creation?","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For most users, it does not matter if you use the constrained on creation syntax. Therefore, use whatever syntax you find most convenient.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"However, if you use direct_model, you may be forced to use the constrained on creation syntax.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The technical difference between variables constrained on creation and the standard JuMP syntax is that variables constrained on creation calls MOI.add_constrained_variables, while the standard JuMP syntax calls MOI.add_variables and then MOI.add_constraint.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Consult the implementation of solver package you are using to see if your solver requires MOI.add_constrained_variables.","category":"page"},{"location":"manual/variables/#variables_parameters","page":"Variables","title":"Parameters","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Some solvers have explicit support for parameters, which are constants in the model that can be efficiently updated between solves.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP implements parameters by a decision variable constrained on creation to the Parameter set.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @variable(model, p[i = 1:2] in Parameter(i))\n2-element Vector{VariableRef}:\n p[1]\n p[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Create anonymous parameters using the set keyword:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> anon_parameter = @variable(model, set = Parameter(1.0))\n_[4]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Use parameter_value and set_parameter_value to query or update the value of a parameter.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> parameter_value.(p)\n2-element Vector{Float64}:\n 1.0\n 2.0\n\njulia> set_parameter_value(p[2], 3.0)\n\njulia> parameter_value.(p)\n2-element Vector{Float64}:\n 1.0\n 3.0","category":"page"},{"location":"manual/variables/#Limitations","page":"Variables","title":"Limitations","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Parameters are implemented as decision variables belonging to the Parameter set. If the solver supports the MOI.Parameter set, it may decide to replace all instances of the parameter variable by the associated constant. If the solver does not support parameters, it will add the parameter as a decision variable with fixed bounds.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The most important implication of this design is that JuMP treats a parameter multiplied by a decision variable as a quadratic expression, even though it is equivalent to a linear expression.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @variable(model, p in Parameter(2));\n\njulia> px = @expression(model, p * x)\np*x\n\njulia> typeof(px)\nQuadExpr (alias for GenericQuadExpr{Float64, GenericVariableRef{Float64}})","category":"page"},{"location":"manual/variables/#When-to-use-a-parameter","page":"Variables","title":"When to use a parameter","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Parameters are most useful when solving nonlinear models in a sequence:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"using JuMP, Ipopt\nmodel = Model(Ipopt.Optimizer);\nset_silent(model)\n@variable(model, x)\n@variable(model, p in Parameter(1.0))\n@objective(model, Min, (x - p)^2)\noptimize!(model)\nvalue(x)\nset_parameter_value(p, 5.0)\noptimize!(model)\nvalue(x)","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Using parameters can be faster than creating a new model from scratch with updated data because JuMP is able to avoid repeating a number of steps in processing the model before handing it off to the solver.","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/submodules/FileFormats/overview.md\"","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/FileFormats/overview/#The-FileFormats-submodule","page":"Overview","title":"The FileFormats submodule","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The FileFormats module provides functions for reading and writing MOI models using write_to_file and read_from_file.","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Supported-file-types","page":"Overview","title":"Supported file types","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"You must read and write files to a FileFormats.Model object. Specific the file-type by passing a FileFormats.FileFormat enum. For example:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The Conic Benchmark Format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_CBF)\nA Conic Benchmark Format (CBF) model","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The LP file format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_LP)\nA .LP-file model","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The MathOptFormat file format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MOF)\nA MathOptFormat Model","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The MPS file format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MPS)\nA Mathematical Programming System (MPS) model","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The NL file format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_NL)\nAn AMPL (.nl) model","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The REW file format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_REW)\nA Mathematical Programming System (MPS) model","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"Note that the REW format is identical to the MPS file format, except that all names are replaced with generic identifiers.","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"The SDPA file format","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_SDPA)\nA SemiDefinite Programming Algorithm Format (SDPA) model","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Write-to-file","page":"Overview","title":"Write to file","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"To write a model src to a MathOptFormat file, use:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> src = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> MOI.add_variable(src)\nMOI.VariableIndex(1)\n\njulia> dest = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MOF)\nA MathOptFormat Model\n\njulia> MOI.copy_to(dest, src)\nMathOptInterface.Utilities.IndexMap with 1 entry:\n  MOI.VariableIndex(1) => MOI.VariableIndex(1)\n\njulia> MOI.write_to_file(dest, \"file.mof.json\")\n\njulia> print(read(\"file.mof.json\", String))\n{\n  \"name\": \"MathOptFormat Model\",\n  \"version\": {\n    \"major\": 1,\n    \"minor\": 7\n  },\n  \"variables\": [\n    {\n      \"name\": \"x1\"\n    }\n  ],\n  \"objective\": {\n    \"sense\": \"feasibility\"\n  },\n  \"constraints\": []\n}","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Read-from-file","page":"Overview","title":"Read from file","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"To read a MathOptFormat file, use:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> dest = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MOF)\nA MathOptFormat Model\n\njulia> MOI.read_from_file(dest, \"file.mof.json\")\n\njulia> MOI.get(dest, MOI.ListOfVariableIndices())\n1-element Vector{MathOptInterface.VariableIndex}:\n MOI.VariableIndex(1)\n\njulia> rm(\"file.mof.json\")  # Clean up after ourselves.","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Detecting-the-file-type-automatically","page":"Overview","title":"Detecting the file-type automatically","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"Instead of the format keyword, you can also use the filename keyword argument to FileFormats.Model. This will attempt to automatically guess the format from the file extension. For example:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> src = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> dest = MOI.FileFormats.Model(filename = \"file.cbf.gz\")\nA Conic Benchmark Format (CBF) model\n\njulia> MOI.copy_to(dest, src)\nMathOptInterface.Utilities.IndexMap()\n\njulia> MOI.write_to_file(dest, \"file.cbf.gz\")\n\njulia> src_2 = MOI.FileFormats.Model(filename = \"file.cbf.gz\")\nA Conic Benchmark Format (CBF) model\n\njulia> src = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> dest = MOI.FileFormats.Model(filename = \"file.cbf.gz\")\nA Conic Benchmark Format (CBF) model\n\njulia> MOI.copy_to(dest, src)\nMathOptInterface.Utilities.IndexMap()\n\njulia> MOI.write_to_file(dest, \"file.cbf.gz\")\n\njulia> src_2 = MOI.FileFormats.Model(filename = \"file.cbf.gz\")\nA Conic Benchmark Format (CBF) model\n\njulia> MOI.read_from_file(src_2, \"file.cbf.gz\")\n\njulia> rm(\"file.cbf.gz\")  # Clean up after ourselves.","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"Note how the compression format (GZip) is also automatically detected from the filename.","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Unsupported-constraints","page":"Overview","title":"Unsupported constraints","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"In some cases src may contain constraints that are not supported by the file format (for example, the CBF format supports integer variables but not binary). If so, copy src to a bridged model using Bridges.full_bridge_optimizer:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"src = MOI.Utilities.Model{Float64}()\nx = MOI.add_variable(model)\nMOI.add_constraint(model, x, MOI.ZeroOne())\ndest = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_CBF)\nbridged = MOI.Bridges.full_bridge_optimizer(dest, Float64)\nMOI.copy_to(bridged, src)\nMOI.write_to_file(dest, \"my_model.cbf\")","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"note: Note\nEven after bridging, it may still not be possible to write the model to file because of unsupported constraints (for example, PSD variables in the LP file format).","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Read-and-write-to-io","page":"Overview","title":"Read and write to io","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"In addition to write_to_file and read_from_file, you can read and write directly from IO streams using Base.write and Base.read!:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> src = MOI.Utilities.Model{Float64}()\nMOIU.Model{Float64}\n\njulia> dest = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MPS)\nA Mathematical Programming System (MPS) model\n\njulia> MOI.copy_to(dest, src)\nMathOptInterface.Utilities.IndexMap()\n\njulia> io = IOBuffer();\n\njulia> write(io, dest)\n\njulia> seekstart(io);\n\njulia> src_2 = MOI.FileFormats.Model(format = MOI.FileFormats.FORMAT_MPS)\nA Mathematical Programming System (MPS) model\n\njulia> read!(io, src_2);","category":"page"},{"location":"moi/submodules/FileFormats/overview/#ScalarNonlinearFunction","page":"Overview","title":"ScalarNonlinearFunction","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"By default, reading a .nl or .mof.json that contains nonlinear expressions will create an NLPBlock.","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"To instead read nonlinear expressions as ScalarNonlinearFunction, pass the use_nlp_block = false keyword argument to the Model constructor:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> model = MOI.FileFormats.Model(;\n           format = MOI.FileFormats.FORMAT_MOF,\n           use_nlp_block = false,\n       )\nA MathOptFormat Model\n\njulia> model = MOI.FileFormats.Model(;\n           format = MOI.FileFormats.FORMAT_NL,\n           use_nlp_block = false,\n       )\nAn AMPL (.nl) model","category":"page"},{"location":"moi/submodules/FileFormats/overview/#Validating-MOF-files","page":"Overview","title":"Validating MOF files","text":"","category":"section"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"MathOptFormat files are governed by a schema. Use JSONSchema.jl to check if a .mof.json file satisfies the schema.","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"First, construct the schema object as follows:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> import JSON, JSONSchema\n\njulia> schema = JSONSchema.Schema(JSON.parsefile(MOI.FileFormats.MOF.SCHEMA_PATH))\nA JSONSchema","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"Then, check if a model file is valid using isvalid:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> good_model = JSON.parse(\"\"\"\n       {\n         \"version\": {\n           \"major\": 1,\n           \"minor\": 5\n         },\n         \"variables\": [{\"name\": \"x\"}],\n         \"objective\": {\"sense\": \"feasibility\"},\n         \"constraints\": []\n       }\n       \"\"\");\n\njulia> isvalid(schema, good_model)\ntrue","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"If we construct an invalid file, for example by mis-typing name as NaMe, the validation fails:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> bad_model = JSON.parse(\"\"\"\n       {\n         \"version\": {\n           \"major\": 1,\n           \"minor\": 5\n         },\n         \"variables\": [{\"NaMe\": \"x\"}],\n         \"objective\": {\"sense\": \"feasibility\"},\n         \"constraints\": []\n       }\n       \"\"\");\n\njulia> isvalid(schema, bad_model)\nfalse","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"Use JSONSchema.validate to obtain more insight into why the validation failed:","category":"page"},{"location":"moi/submodules/FileFormats/overview/","page":"Overview","title":"Overview","text":"julia> JSONSchema.validate(schema, bad_model)\nValidation failed:\npath:         [variables][1]\ninstance:     Dict{String, Any}(\"NaMe\" => \"x\")\nschema key:   required\nschema value: Any[\"name\"]","category":"page"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"EditURL = \"https://github.com/lanl-ansi/Alpine.jl/blob/v0.5.6/README.md\"","category":"page"},{"location":"packages/Alpine/#Alpine,-a-global-solver-for-non-convex-MINLPs","page":"lanl-ansi/Alpine.jl","title":"Alpine, a global solver for non-convex MINLPs","text":"","category":"section"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"(Image: CI) (Image: codecov) (Image: Documentation)  (Image: version)","category":"page"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"ALPINE (glob(AL) o(P)timization for mixed-(I)nteger programs with (N)onlinear (E)quations), is a novel global optimization solver that uses an adaptive, piecewise convexification scheme and constraint programming methods to solve non-convex Mixed-Integer Non-Linear Programs (MINLPs) efficiently. MINLPs are typically \"hard\" optimization problems which appear in numerous applications (see MINLPLib.jl). ","category":"page"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"Alpine is entirely built upon JuMP and MathOptInterface in Julia, which provides incredible flexibility for usage and further development.","category":"page"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"Alpine globally solves a given MINLP by:","category":"page"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"Analyzing the problem's expressions (objective & constraints) and applies appropriate convex relaxations and polyhedral outer-approximations\nPerforming sequential optimization-based bound tightening (OBBT) and an iterative MIP-based adaptive partitioning scheme via piecewise polyhedral relaxations with a guarantee of global convergence","category":"page"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"Upon Alpine's convergence, for a given relative gap tolerance ε, the user is guaranteed that the global optimal solution is in the ε-neighborhood of the solution found by the solver.","category":"page"},{"location":"packages/Alpine/#Installation","page":"lanl-ansi/Alpine.jl","title":"Installation","text":"","category":"section"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"Install Alpine using the Julia package manager:","category":"page"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"import Pkg\nPkg.add(\"Alpine\")","category":"page"},{"location":"packages/Alpine/#Usage-with-JuMP","page":"lanl-ansi/Alpine.jl","title":"Usage with JuMP","text":"","category":"section"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"Use Alpine with JuMP as follows:","category":"page"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"using JuMP, Alpine, Ipopt, HiGHS\nipopt = optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0)\nhighs = optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => false)\nmodel = Model(\n    optimizer_with_attributes(\n        Alpine.Optimizer,\n        \"nlp_solver\" => ipopt,\n        \"mip_solver\" => highs,\n    ),\n)","category":"page"},{"location":"packages/Alpine/#Documentation","page":"lanl-ansi/Alpine.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"For more details, see the online documentation.","category":"page"},{"location":"packages/Alpine/#Support-problem-types","page":"lanl-ansi/Alpine.jl","title":"Support problem types","text":"","category":"section"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"Alpine can currently handle MINLPs with polynomials in constraints and/or in the objective. Currently, there is no support for exponential cones and Positive Semi-Definite (PSD) cones in MINLPs. Alpine is also a good fit for subsets of the MINLP family, for example, Mixed-Integer Quadratically Constrained Quadratic Programs (MIQCQPs), Non-Linear Programs (NLPs), etc.","category":"page"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"For more details, check out this video on Alpine.jl at JuMP-dev 2018.","category":"page"},{"location":"packages/Alpine/#Underlying-solvers","page":"lanl-ansi/Alpine.jl","title":"Underlying solvers","text":"","category":"section"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"Though an MIP-based bounding algorithm implemented in Alpine is quite involved, most of the computational bottleneck arises in the underlying MIP solvers. Since every iteration of Alpine solves an MIP sub-problem, which is typically a convex MILP/MIQCQP, Alpine's run time heavily depends on the run-time of these solvers. For the best performance of Alpine, we recommend using the commercial solver Gurobi, which is available free for academic purposes. However, due to the flexibility offered by JuMP, the following MIP and NLP solvers are supported in Alpine: ","category":"page"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"Solver Julia Package\nGurobi Gurobi.jl\nCPLEX CPLEX.jl\nHiGHS HiGHS.jl\nCbc Cbc.jl\nIpopt Ipopt.jl\nBonmin Bonmin.jl\nArtelys KNITRO KNITRO.jl\nXpress Xpress.jl","category":"page"},{"location":"packages/Alpine/#Bug-reports-and-support","page":"lanl-ansi/Alpine.jl","title":"Bug reports and support","text":"","category":"section"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"Please report any issues via the GitHub issue tracker. All types of issues are welcome and encouraged; this includes bug reports, documentation typos, feature requests, etc. ","category":"page"},{"location":"packages/Alpine/#Challenging-Problems","page":"lanl-ansi/Alpine.jl","title":"Challenging Problems","text":"","category":"section"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"We are seeking out hard benchmark instances for MINLPs. Please get in touch either by opening an issue or privately if you would like to share any hard instances.","category":"page"},{"location":"packages/Alpine/#Citing-Alpine","page":"lanl-ansi/Alpine.jl","title":"Citing Alpine","text":"","category":"section"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"If you find Alpine useful in your work, we kindly request that you cite the following papers (PDF, PDF)","category":"page"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"@article{alpine_JOGO2019,\n  title = {An adaptive, multivariate partitioning algorithm for global optimization of nonconvex programs},\n  author = {Nagarajan, Harsha and Lu, Mowen and Wang, Site and Bent, Russell and Sundar, Kaarthik},\n  journal = {Journal of Global Optimization},\n  year = {2019},\n  issn = {1573-2916},\n  doi = {10.1007/s10898-018-00734-1},\n}\n\n@inproceedings{alpine_CP2016,\n  title = {Tightening {McCormick} relaxations for nonlinear programs via dynamic multivariate partitioning},\n  author = {Nagarajan, Harsha and Lu, Mowen and Yamangil, Emre and Bent, Russell},\n  booktitle = {International Conference on Principles and Practice of Constraint Programming},\n  pages = {369--387},\n  year = {2016},\n  organization = {Springer},\n  doi = {10.1007/978-3-319-44953-1_24},\n}","category":"page"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"If you find the underlying piecewise polyhedral formulations implemented in Alpine useful in your work, we kindly request that you cite the following papers (link-1, link-2): ","category":"page"},{"location":"packages/Alpine/","page":"lanl-ansi/Alpine.jl","title":"lanl-ansi/Alpine.jl","text":"@article{alpine_ORL2021,\n  title = {Piecewise polyhedral formulations for a multilinear term},\n  author = {Sundar, Kaarthik and Nagarajan, Harsha and Linderoth, Jeff and Wang, Site and Bent, Russell},\n  journal = {Operations Research Letters},\n  volume = {49},\n  number = {1},\n  pages = {144--149},\n  year = {2021},\n  publisher = {Elsevier}\n}\n\n@article{alpine_OptOnline2022,\n  title={Piecewise Polyhedral Relaxations of Multilinear Optimization},\n  author={Kim, Jongeun and Richard, Jean-Philippe P. and Tawarmalani, Mohit},\n  eprinttype={Optimization Online},\n  date={2022}\n}","category":"page"},{"location":"packages/NEOSServer/","page":"odow/NEOSServer.jl","title":"odow/NEOSServer.jl","text":"EditURL = \"https://github.com/odow/NEOSServer.jl/blob/v1.1.0/README.md\"","category":"page"},{"location":"packages/NEOSServer/#NEOSServer.jl","page":"odow/NEOSServer.jl","title":"NEOSServer.jl","text":"","category":"section"},{"location":"packages/NEOSServer/","page":"odow/NEOSServer.jl","title":"odow/NEOSServer.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/NEOSServer/","page":"odow/NEOSServer.jl","title":"odow/NEOSServer.jl","text":"NEOSServer.jl is a wrapper for the NEOS Server, a free internet-based service for solving numerical optimization problems.","category":"page"},{"location":"packages/NEOSServer/","page":"odow/NEOSServer.jl","title":"odow/NEOSServer.jl","text":"See here for the full list of solvers and input formats that NEOS supports.","category":"page"},{"location":"packages/NEOSServer/#License","page":"odow/NEOSServer.jl","title":"License","text":"","category":"section"},{"location":"packages/NEOSServer/","page":"odow/NEOSServer.jl","title":"odow/NEOSServer.jl","text":"NEOSServer.jl is licensed under the MIT License.","category":"page"},{"location":"packages/NEOSServer/","page":"odow/NEOSServer.jl","title":"odow/NEOSServer.jl","text":"However, use of the NEOS Server requires you to comply with NEOS Server terms of use. In particular, the commercial solvers are to be used solely for academic, non-commercial research purposes.","category":"page"},{"location":"packages/NEOSServer/#Installation","page":"odow/NEOSServer.jl","title":"Installation","text":"","category":"section"},{"location":"packages/NEOSServer/","page":"odow/NEOSServer.jl","title":"odow/NEOSServer.jl","text":"Install NEOSServer.jl using the package manager:","category":"page"},{"location":"packages/NEOSServer/","page":"odow/NEOSServer.jl","title":"odow/NEOSServer.jl","text":"import Pkg\nPkg.add(\"NEOSServer\")","category":"page"},{"location":"packages/NEOSServer/#The-NEOS-API","page":"odow/NEOSServer.jl","title":"The NEOS API","text":"","category":"section"},{"location":"packages/NEOSServer/","page":"odow/NEOSServer.jl","title":"odow/NEOSServer.jl","text":"This package contains an interface for the NEOS XML-RPC API.","category":"page"},{"location":"packages/NEOSServer/","page":"odow/NEOSServer.jl","title":"odow/NEOSServer.jl","text":"The following example shows how you can interact with the API. Wrapped XML-RPC functions begin with neos_ and are exported.","category":"page"},{"location":"packages/NEOSServer/","page":"odow/NEOSServer.jl","title":"odow/NEOSServer.jl","text":"using NEOSServer\n\n# Create a server. You must supply a valid email:\nserver = NEOSServer.Server(\"me@mydomain.com\")\n\n# Print the NEOS welcome message:\nprintln(neos_welcome(server))\n\n# Get an XML template:\nxml_string = neos_getSolverTemplate(server, \"milp\", \"Cbc\", \"AMPL\")\n\n# Modify template with problem data...\n\n# Submit the XML job to NEOS:\njob = neos_submitJob(server, xml_string)\n\n# Get the status of the Job from NEOS:\nstatus = neos_getJobStatus(server, job)\n\n# Get the final results:\nresults = neos_getFinalResults(server, job)","category":"page"},{"location":"packages/NEOSServer/#Use-with-JuMP","page":"odow/NEOSServer.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/NEOSServer/","page":"odow/NEOSServer.jl","title":"odow/NEOSServer.jl","text":"Use NEOSServer.jl with JuMP as follows:","category":"page"},{"location":"packages/NEOSServer/","page":"odow/NEOSServer.jl","title":"odow/NEOSServer.jl","text":"using JuMP, NEOSServer\n\nmodel = Model() do\n    NEOSServer.Optimizer(email=\"me@mydomain.com\", solver=\"Ipopt\")\nend","category":"page"},{"location":"packages/NEOSServer/","page":"odow/NEOSServer.jl","title":"odow/NEOSServer.jl","text":"Note: NEOSServer.Optimizer is limited to the following solvers:","category":"page"},{"location":"packages/NEOSServer/","page":"odow/NEOSServer.jl","title":"odow/NEOSServer.jl","text":"\"CPLEX\"\n\"FICO-Xpress\"\n\"Ipopt\"\n\"Knitro\"\n\"MOSEK\"\n\"OCTERACT\"\n\"SNOPT\"","category":"page"},{"location":"packages/NEOSServer/#NEOS-Limits","page":"odow/NEOSServer.jl","title":"NEOS Limits","text":"","category":"section"},{"location":"packages/NEOSServer/","page":"odow/NEOSServer.jl","title":"odow/NEOSServer.jl","text":"NEOS currently limits jobs to an 8 hour time limit, 3 GB of memory, and a 16 MB submission file. If your model exceeds these limits, NEOSServer.jl may be unable to return useful information to the user.","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"EditURL = \"https://github.com/jump-dev/SDPA.jl/blob/v0.5.1/README.md\"","category":"page"},{"location":"packages/SDPA/#SDPA.jl","page":"jump-dev/SDPA.jl","title":"SDPA.jl","text":"","category":"section"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"SDPA.jl is a wrapper for the SDPA semidefinite programming solver in double precision floating point arithmetic.","category":"page"},{"location":"packages/SDPA/#Affiliation","page":"jump-dev/SDPA.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"This wrapper is maintained by the JuMP community and is not a product of the SDPA developers.","category":"page"},{"location":"packages/SDPA/#License","page":"jump-dev/SDPA.jl","title":"License","text":"","category":"section"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"SDPA.jl is licensed under the MIT License.","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"The underlying solver, SDPA is licensed under the GPL v2 license.","category":"page"},{"location":"packages/SDPA/#Installation","page":"jump-dev/SDPA.jl","title":"Installation","text":"","category":"section"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"Install SDPA using Pkg.add:","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"import Pkg\nPkg.add(\"SDPA\")","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"In addition to installing the SDPA.jl package, this will also download and install the SDPA binaries. (You do not need to install SDPA separately.)","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"If you see an error similar to:","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"INFO: Precompiling module GZip.\nERROR: LoadError: LoadError: error compiling anonymous: could not load library \"libz\"","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"please see GZip.jl#54 or Flux.jl#343. In particular, in Ubuntu this issue may be resolved by running","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"sudo apt-get install zlib1g-dev","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"See SDPAFamily for the other solvers, SDPA-GMP, SDPA-DD, and SDPA-QD of the family.","category":"page"},{"location":"packages/SDPA/#Use-with-JuMP","page":"jump-dev/SDPA.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"using JuMP, SDPA\nmodel = Model(SDPA.Optimizer)\nset_attribute(model, \"Mode\", SDPA.PARAMETER_DEFAULT)","category":"page"},{"location":"packages/SDPA/#MathOptInterface-API","page":"jump-dev/SDPA.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"The SDPA optimizer supports the following constraints and attributes.","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"List of supported objective functions:","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"MOI.Nonnegatives\nMOI.PositiveSemidefiniteConeTriangle","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"MOI.ScalarAffineFunction{Float64} in MOI.EqualTo{Float64}","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"MOI.ObjectiveSense()","category":"page"},{"location":"packages/SDPA/#Options","page":"jump-dev/SDPA.jl","title":"Options","text":"","category":"section"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"SDPA has three modes that give default value to all ten parameters.","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"The following table gives the default values for each parameter and mode.","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"Parameter PARAMETER_DEFAULT PARAMETER_UNSTABLE_BUT_FAST PARAMETER_STABLE_BUT_SLOW\nMaxIteration 100 100 1000\nEpsilonStar 1.0e-7 1.0e-7 1.0e-7\nLambdaStar 1.0e+2 1.0e+2 1.0e+4\nOmegaStar 2.0 2.0 2.0\nLowerBound 1.0e+5 1.0e+5 1.0e+5\nUpperBound 1.0e+5 1.0e+5 1.0e+5\nBetaStar 0.1 0.01 0.1\nBetaBar 0.2 0.02 0.3\nGammaStar 0.9 0.95 0.8\nEpsilonDash 1.0e-7 1.0e-7 1.0e-7","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"By default, we put SDPA in the SDPA.PARAMETER_DEFAULT mode.","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"Change the mode using the \"Mode\" option:","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"using JuMP, SDPA\nmodel = Model(SDPA.Optimizer)\nset_attribute(model, \"Mode\", SDPA.PARAMETER_STABLE_BUT_SLOW)","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"Note that the parameters are set in the order they are given, so you can set a mode and then modify parameters from this mode.","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"using JuMP, SDPA\nmodel = Model(SDPA.Optimizer)\nset_attribute(model, \"Mode\", SDPA.PARAMETER_STABLE_BUT_SLOW)\nset_attribute(model, \"MaxIteration\", 100)","category":"page"},{"location":"packages/SDPA/","page":"jump-dev/SDPA.jl","title":"jump-dev/SDPA.jl","text":"The choice of parameter mode has a large impact on the performance and stability of SDPA, and not necessarily in the way implied by the names of the modes; for example, PARAMETER_UNSTABLE_BUT_FAST can be more stable than the other modes for some problems. You should try each mode to see how it performs on your specific problem. See SDPA.jl#17 for more details.","category":"page"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/tutorials/mathprogbase.md\"","category":"page"},{"location":"moi/tutorials/mathprogbase/#Transitioning-from-MathProgBase","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"","category":"section"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"MathOptInterface is a replacement for MathProgBase.jl. However, it is not a direct replacement.","category":"page"},{"location":"moi/tutorials/mathprogbase/#Transitioning-a-solver-interface","page":"Transitioning from MathProgBase","title":"Transitioning a solver interface","text":"","category":"section"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"MathOptInterface is more extensive than MathProgBase which may make its implementation seem daunting at first. There are however numerous utilities in MathOptInterface that the simplify implementation process.","category":"page"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"For more information, read Implementing a solver interface.","category":"page"},{"location":"moi/tutorials/mathprogbase/#Transitioning-the-high-level-functions","page":"Transitioning from MathProgBase","title":"Transitioning the high-level functions","text":"","category":"section"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"MathOptInterface doesn't provide replacements for the high-level interfaces in MathProgBase. We recommend you use JuMP as a modeling interface instead.","category":"page"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"tip: Tip\nIf you haven't used JuMP before, start with the tutorial Getting started with JuMP","category":"page"},{"location":"moi/tutorials/mathprogbase/#linprog","page":"Transitioning from MathProgBase","title":"linprog","text":"","category":"section"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"Here is one way of transitioning from linprog:","category":"page"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"using JuMP\n\nfunction linprog(c, A, sense, b, l, u, solver)\n    N = length(c)\n    model = Model(solver)\n    @variable(model, l[i] <= x[i=1:N] <= u[i])\n    @objective(model, Min, c' * x)\n    eq_rows, ge_rows, le_rows = sense .== '=', sense .== '>', sense .== '<'\n    @constraint(model, A[eq_rows, :] * x .== b[eq_rows])\n    @constraint(model, A[ge_rows, :] * x .>= b[ge_rows])\n    @constraint(model, A[le_rows, :] * x .<= b[le_rows])\n    optimize!(model)\n    return (\n        status = termination_status(model),\n        objval = objective_value(model),\n        sol = value.(x)\n    )\nend","category":"page"},{"location":"moi/tutorials/mathprogbase/#mixintprog","page":"Transitioning from MathProgBase","title":"mixintprog","text":"","category":"section"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"Here is one way of transitioning from mixintprog:","category":"page"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"using JuMP\n\nfunction mixintprog(c, A, rowlb, rowub, vartypes, lb, ub, solver)\n    N = length(c)\n    model = Model(solver)\n    @variable(model, lb[i] <= x[i=1:N] <= ub[i])\n    for i in 1:N\n        if vartypes[i] == :Bin\n            set_binary(x[i])\n        elseif vartypes[i] == :Int\n            set_integer(x[i])\n        end\n    end\n    @objective(model, Min, c' * x)\n    @constraint(model, rowlb .<= A * x .<= rowub)\n    optimize!(model)\n    return (\n        status = termination_status(model),\n        objval = objective_value(model),\n        sol = value.(x)\n    )\nend","category":"page"},{"location":"moi/tutorials/mathprogbase/#quadprog","page":"Transitioning from MathProgBase","title":"quadprog","text":"","category":"section"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"Here is one way of transitioning from quadprog:","category":"page"},{"location":"moi/tutorials/mathprogbase/","page":"Transitioning from MathProgBase","title":"Transitioning from MathProgBase","text":"using JuMP\n\nfunction quadprog(c, Q, A, rowlb, rowub, lb, ub, solver)\n    N = length(c)\n    model = Model(solver)\n    @variable(model, lb[i] <= x[i=1:N] <= ub[i])\n    @objective(model, Min, c' * x + 0.5 * x' * Q * x)\n    @constraint(model, rowlb .<= A * x .<= rowub)\n    optimize!(model)\n    return (\n        status = termination_status(model),\n        objval = objective_value(model),\n        sol = value.(x)\n    )\nend","category":"page"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/submodules/Bridges/reference.md\"","category":"page"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Bridges/reference/#Bridges","page":"API Reference","title":"Bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/#AbstractBridge-API","page":"API Reference","title":"AbstractBridge API","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.AbstractBridge\nBridges.added_constrained_variable_types\nBridges.added_constraint_types\nget(::Bridges.AbstractBridge, ::NumberOfVariables)\nget(::Bridges.AbstractBridge, ::ListOfVariableIndices)\nget(::Bridges.AbstractBridge, ::NumberOfConstraints)\nget(::Bridges.AbstractBridge, ::ListOfConstraintIndices)\nBridges.needs_final_touch\nBridges.final_touch\nBridges.bridging_cost\nBridges.runtests","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.AbstractBridge","page":"API Reference","title":"MathOptInterface.Bridges.AbstractBridge","text":"abstract type AbstractBridge end\n\nAn abstract type representing a bridged constraint or variable in a MOI.Bridges.AbstractBridgeOptimizer.\n\nAll bridges must implement:\n\nadded_constrained_variable_types\nadded_constraint_types\nMOI.get(::AbstractBridge, ::MOI.NumberOfVariables)\nMOI.get(::AbstractBridge, ::MOI.ListOfVariableIndices)\nMOI.get(::AbstractBridge, ::MOI.NumberOfConstraints)\nMOI.get(::AbstractBridge, ::MOI.ListOfConstraintIndices)\n\nSubtypes of AbstractBridge may have additional requirements. Consult their docstrings for details.\n\nIn addition, all subtypes may optionally implement the following constraint attributes with the bridge in place of the constraint index:\n\nMOI.ConstraintDual\nMOI.ConstraintPrimal\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.added_constrained_variable_types","page":"API Reference","title":"MathOptInterface.Bridges.added_constrained_variable_types","text":"added_constrained_variable_types(\n    BT::Type{<:AbstractBridge},\n)::Vector{Tuple{Type}}\n\nReturn a list of the types of constrained variables that bridges of concrete type BT add.\n\nImplementation notes\n\nThis method depends only on the type of the bridge, not the runtime value. If the bridge may add a constrained variable, the type must be included in the return vector.\nIf the bridge adds a free variable via MOI.add_variable or MOI.add_variables, the return vector must include (MOI.Reals,).\n\nExample\n\njulia> MOI.Bridges.added_constrained_variable_types(\n           MOI.Bridges.Variable.NonposToNonnegBridge{Float64},\n       )\n1-element Vector{Tuple{Type}}:\n (MathOptInterface.Nonnegatives,)\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.added_constraint_types","page":"API Reference","title":"MathOptInterface.Bridges.added_constraint_types","text":"added_constraint_types(\n    BT::Type{<:AbstractBridge},\n)::Vector{Tuple{Type,Type}}\n\nReturn a list of the types of constraints that bridges of concrete type BT add.\n\nImplementation notes\n\nThis method depends only on the type of the bridge, not the runtime value. If the bridge may add a constraint, the type must be included in the return vector.\n\nExample\n\njulia> MOI.Bridges.added_constraint_types(\n           MOI.Bridges.Constraint.ZeroOneBridge{Float64},\n       )\n2-element Vector{Tuple{Type, Type}}:\n (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.Interval{Float64})\n (MathOptInterface.VariableIndex, MathOptInterface.Integer)\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.get-Tuple{MathOptInterface.Bridges.AbstractBridge, MathOptInterface.NumberOfVariables}","page":"API Reference","title":"MathOptInterface.get","text":"MOI.get(b::AbstractBridge, ::MOI.NumberOfVariables)::Int64\n\nReturn the number of variables created by the bridge b in the model.\n\nSee also MOI.NumberOfConstraints.\n\nImplementation notes\n\nThere is a default fallback, so you need only implement this if the bridge adds new variables.\n\n\n\n\n\n","category":"method"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.get-Tuple{MathOptInterface.Bridges.AbstractBridge, MathOptInterface.ListOfVariableIndices}","page":"API Reference","title":"MathOptInterface.get","text":"MOI.get(b::AbstractBridge, ::MOI.ListOfVariableIndices)\n\nReturn the list of variables created by the bridge b.\n\nSee also MOI.ListOfVariableIndices.\n\nImplementation notes\n\nThere is a default fallback, so you need only implement this if the bridge adds new variables.\n\n\n\n\n\n","category":"method"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.get-Tuple{MathOptInterface.Bridges.AbstractBridge, MathOptInterface.NumberOfConstraints}","page":"API Reference","title":"MathOptInterface.get","text":"MOI.get(b::AbstractBridge, ::MOI.NumberOfConstraints{F,S})::Int64 where {F,S}\n\nReturn the number of constraints of the type F-in-S created by the bridge b.\n\nSee also MOI.NumberOfConstraints.\n\nImplementation notes\n\nThere is a default fallback, so you need only implement this for the constraint types returned by added_constraint_types.\n\n\n\n\n\n","category":"method"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.get-Tuple{MathOptInterface.Bridges.AbstractBridge, MathOptInterface.ListOfConstraintIndices}","page":"API Reference","title":"MathOptInterface.get","text":"MOI.get(b::AbstractBridge, ::MOI.ListOfConstraintIndices{F,S}) where {F,S}\n\nReturn a  Vector{ConstraintIndex{F,S}} with indices of all constraints of type F-in-S created by the bride b.\n\nSee also MOI.ListOfConstraintIndices.\n\nImplementation notes\n\nThere is a default fallback, so you need only implement this for the constraint types returned by added_constraint_types.\n\n\n\n\n\n","category":"method"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.needs_final_touch","page":"API Reference","title":"MathOptInterface.Bridges.needs_final_touch","text":"needs_final_touch(bridge::AbstractBridge)::Bool\n\nReturn whether final_touch is implemented by bridge.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.final_touch","page":"API Reference","title":"MathOptInterface.Bridges.final_touch","text":"final_touch(bridge::AbstractBridge, model::MOI.ModelLike)::Nothing\n\nA function that is called immediately prior to MOI.optimize! to allow bridges to modify their reformulations with respect to other variables and constraints in model.\n\nFor example, if the correctness of bridge depends on the bounds of a variable or the fact that variables are integer, then the bridge can implement final_touch to check assumptions immediately before a call to MOI.optimize!.\n\nIf you implement this method, you must also implement needs_final_touch.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.bridging_cost","page":"API Reference","title":"MathOptInterface.Bridges.bridging_cost","text":"bridging_cost(b::AbstractBridgeOptimizer, S::Type{<:MOI.AbstractSet}})\n\nReturn the cost of bridging variables constrained in S on creation, is_bridged(b, S) is assumed to be true.\n\nbridging_cost(\n    b::AbstractBridgeOptimizer,\n    F::Type{<:MOI.AbstractFunction},\n    S::Type{<:MOI.AbstractSet},\n)\n\nReturn the cost of bridging F-in-S constraints.\n\nis_bridged(b, S) is assumed to be true.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.runtests","page":"API Reference","title":"MathOptInterface.Bridges.runtests","text":"runtests(\n    Bridge::Type{<:AbstractBridge},\n    input::String,\n    output::String;\n    variable_start = 1.2,\n    constraint_start = 1.2,\n    eltype = Float64,\n)\n\nRun a series of tests that check the correctness of Bridge.\n\ninput and output are models in the style of MOI.Utilities.loadfromstring!.\n\nExample\n\njulia> MOI.Bridges.runtests(\n           MOI.Bridges.Constraint.ZeroOneBridge,\n           \"\"\"\n           variables: x\n           x in ZeroOne()\n           \"\"\",\n           \"\"\"\n           variables: x\n           x in Integer()\n           1.0 * x in Interval(0.0, 1.0)\n           \"\"\",\n       )\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#Constraint-bridge-API","page":"API Reference","title":"Constraint bridge API","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.Constraint.AbstractBridge\nBridges.Constraint.SingleBridgeOptimizer\nsupports_constraint(::Type{<:Bridges.Constraint.AbstractBridge}, ::Type{<:AbstractFunction}, ::Type{<:AbstractSet})\nBridges.Constraint.concrete_bridge_type\nBridges.Constraint.bridge_constraint\nBridges.Constraint.add_all_bridges\nBridges.Constraint.conversion_cost","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.AbstractBridge","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.AbstractBridge","text":"abstract type AbstractBridge <: MOI.Bridges.AbstractType\n\nSubtype of MOI.Bridges.AbstractBridge for constraint bridges.\n\nIn addition to the required implementation described in MOI.Bridges.AbstractBridge, subtypes of AbstractBridge must additionally implement:\n\nMOI.supports_constraint(::Type{<:AbstractBridge}, ::Type{<:MOI.AbstractFunction}, ::Type{<:MOI.AbstractSet})\nconcrete_bridge_type\nbridge_constraint\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer","text":"SingleBridgeOptimizer{BT<:AbstractBridge}(model::MOI.ModelLike)\n\nReturn AbstractBridgeOptimizer that always bridges any objective function supported by the bridge BT.\n\nThis is in contrast with the MOI.Bridges.LazyBridgeOptimizer, which only bridges the objective function if it is supported by the bridge BT and unsupported by model.\n\nExample\n\njulia> struct MyNewBridge{T} <: MOI.Bridges.Constraint.AbstractBridge end\n\njulia> bridge = MOI.Bridges.Constraint.SingleBridgeOptimizer{MyNewBridge{Float64}}(\n           MOI.Utilities.Model{Float64}(),\n       )\nMOIB.Constraint.SingleBridgeOptimizer{MyNewBridge{Float64}, MOIU.Model{Float64}}\nwith 0 constraint bridges\nwith inner model MOIU.Model{Float64}\n\nImplementation notes\n\nAll bridges should simplify the creation of SingleBridgeOptimizers by defining a constant that wraps the bridge in a SingleBridgeOptimizer.\n\njulia> const MyNewBridgeModel{T,OT<:MOI.ModelLike} =\n           MOI.Bridges.Constraint.SingleBridgeOptimizer{MyNewBridge{T},OT};\n\nThis enables users to create bridged models as follows:\n\njulia> MyNewBridgeModel{Float64}(MOI.Utilities.Model{Float64}())\nMOIB.Constraint.SingleBridgeOptimizer{MyNewBridge{Float64}, MOIU.Model{Float64}}\nwith 0 constraint bridges\nwith inner model MOIU.Model{Float64}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.supports_constraint-Tuple{Type{<:MathOptInterface.Bridges.Constraint.AbstractBridge}, Type{<:MathOptInterface.AbstractFunction}, Type{<:MathOptInterface.AbstractSet}}","page":"API Reference","title":"MathOptInterface.supports_constraint","text":"MOI.supports_constraint(\n    BT::Type{<:AbstractBridge},\n    F::Type{<:MOI.AbstractFunction},\n    S::Type{<:MOI.AbstractSet},\n)::Bool\n\nReturn a Bool indicating whether the bridges of type BT support bridging F-in-S constraints.\n\nImplementation notes\n\nThis method depends only on the type of the inputs, not the runtime values.\nThere is a default fallback, so you need only implement this method for constraint types that the bridge implements.\n\n\n\n\n\n","category":"method"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.concrete_bridge_type","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.concrete_bridge_type","text":"concrete_bridge_type(\n    BT::Type{<:AbstractBridge},\n    F::Type{<:MOI.AbstractFunction},\n    S::Type{<:MOI.AbstractSet}\n)::Type\n\nReturn the concrete type of the bridge supporting F-in-S constraints.\n\nThis function can only be called if MOI.supports_constraint(BT, F, S) is true.\n\nExample\n\nThe SplitIntervalBridge bridges a MOI.VariableIndex-in-MOI.Interval constraint into a MOI.VariableIndex-in-MOI.GreaterThan and a MOI.VariableIndex-in-MOI.LessThan constraint.\n\njulia> MOI.Bridges.Constraint.concrete_bridge_type(\n           MOI.Bridges.Constraint.SplitIntervalBridge{Float64},\n           MOI.VariableIndex,\n           MOI.Interval{Float64},\n       )\nMathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64, MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64}, MathOptInterface.GreaterThan{Float64}, MathOptInterface.LessThan{Float64}}\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.bridge_constraint","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.bridge_constraint","text":"bridge_constraint(\n    BT::Type{<:AbstractBridge},\n    model::MOI.ModelLike,\n    func::AbstractFunction,\n    set::MOI.AbstractSet,\n)::BT\n\nBridge the constraint func-in-set using bridge BT to model and returns a bridge object of type BT.\n\nImplementation notes\n\nThe bridge type BT should be a concrete type, that is, all the type parameters of the bridge must be set.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.add_all_bridges","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.add_all_bridges","text":"add_all_bridges(bridged_model, ::Type{T}) where {T}\n\nAdd all bridges defined in the Bridges.Constraint submodule to bridged_model. The coefficient type used is T.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Constraint.conversion_cost","page":"API Reference","title":"MathOptInterface.Bridges.Constraint.conversion_cost","text":"conversion_cost(\n    F::Type{<:MOI.AbstractFunction},\n    G::Type{<:MOI.AbstractFunction},\n)::Float64\n\nReturn a Float64 returning the cost of converting any function of type G to a function of type F with convert.\n\nThis cost is used to compute MOI.Bridges.bridging_cost.\n\nThe default cost is Inf, which means that MOI.Bridges.Constraint.FunctionConversionBridge should not attempt the conversion.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#Objective-bridge-API","page":"API Reference","title":"Objective bridge API","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.Objective.AbstractBridge\nBridges.Objective.SingleBridgeOptimizer\nBridges.Objective.supports_objective_function\nBridges.set_objective_function_type\nBridges.Objective.concrete_bridge_type\nBridges.Objective.bridge_objective\nBridges.Objective.add_all_bridges","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Objective.AbstractBridge","page":"API Reference","title":"MathOptInterface.Bridges.Objective.AbstractBridge","text":"abstract type AbstractBridge <: MOI.Bridges.AbstractBridge end\n\nSubtype of MOI.Bridges.AbstractBridge for objective bridges.\n\nIn addition to the required implementation described in MOI.Bridges.AbstractBridge, subtypes of AbstractBridge must additionally implement:\n\nsupports_objective_function\nconcrete_bridge_type\nbridge_objective\nMOI.Bridges.set_objective_function_type\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Objective.SingleBridgeOptimizer","page":"API Reference","title":"MathOptInterface.Bridges.Objective.SingleBridgeOptimizer","text":"SingleBridgeOptimizer{BT<:AbstractBridge}(model::MOI.ModelLike)\n\nReturn AbstractBridgeOptimizer that always bridges any objective function supported by the bridge BT.\n\nThis is in contrast with the MOI.Bridges.LazyBridgeOptimizer, which only bridges the objective function if it is supported by the bridge BT and unsupported by model.\n\nExample\n\njulia> struct MyNewBridge{T} <: MOI.Bridges.Objective.AbstractBridge end\n\njulia> bridge = MOI.Bridges.Objective.SingleBridgeOptimizer{MyNewBridge{Float64}}(\n           MOI.Utilities.Model{Float64}(),\n       )\nMOIB.Objective.SingleBridgeOptimizer{MyNewBridge{Float64}, MOIU.Model{Float64}}\nwith 0 objective bridges\nwith inner model MOIU.Model{Float64}\n\nImplementation notes\n\nAll bridges should simplify the creation of SingleBridgeOptimizers by defining a constant that wraps the bridge in a SingleBridgeOptimizer.\n\njulia> const MyNewBridgeModel{T,OT<:MOI.ModelLike} =\n           MOI.Bridges.Objective.SingleBridgeOptimizer{MyNewBridge{T},OT};\n\nThis enables users to create bridged models as follows:\n\njulia> MyNewBridgeModel{Float64}(MOI.Utilities.Model{Float64}())\nMOIB.Objective.SingleBridgeOptimizer{MyNewBridge{Float64}, MOIU.Model{Float64}}\nwith 0 objective bridges\nwith inner model MOIU.Model{Float64}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Objective.supports_objective_function","page":"API Reference","title":"MathOptInterface.Bridges.Objective.supports_objective_function","text":"supports_objective_function(\n    BT::Type{<:MOI.Bridges.Objective.AbstractBridge},\n    F::Type{<:MOI.AbstractFunction},\n)::Bool\n\nReturn a Bool indicating whether the bridges of type BT support bridging objective functions of type F.\n\nImplementation notes\n\nThis method depends only on the type of the inputs, not the runtime values.\nThere is a default fallback, so you need only implement this method For objective functions that the bridge implements.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.set_objective_function_type","page":"API Reference","title":"MathOptInterface.Bridges.set_objective_function_type","text":"set_objective_function_type(\n    BT::Type{<:Objective.AbstractBridge},\n)::Type{<:MOI.AbstractFunction}\n\nReturn the type of objective function that bridges of concrete type BT set.\n\nImplementation notes\n\nThis method depends only on the type of the bridge, not the runtime value.\n\nExample\n\njulia> MOI.Bridges.set_objective_function_type(\n           MOI.Bridges.Objective.FunctionizeBridge{Float64},\n       )\nMathOptInterface.ScalarAffineFunction{Float64}\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Objective.concrete_bridge_type","page":"API Reference","title":"MathOptInterface.Bridges.Objective.concrete_bridge_type","text":"concrete_bridge_type(\n    BT::Type{<:MOI.Bridges.Objective.AbstractBridge},\n    F::Type{<:MOI.AbstractFunction},\n)::Type\n\nReturn the concrete type of the bridge supporting objective functions of type F.\n\nThis function can only be called if MOI.supports_objective_function(BT, F) is true.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Objective.bridge_objective","page":"API Reference","title":"MathOptInterface.Bridges.Objective.bridge_objective","text":"bridge_objective(\n    BT::Type{<:MOI.Bridges.Objective.AbstractBridge},\n    model::MOI.ModelLike,\n    func::MOI.AbstractFunction,\n)::BT\n\nBridge the objective function func using bridge BT to model and returns a bridge object of type BT.\n\nImplementation notes\n\nThe bridge type BT must be a concrete type, that is, all the type parameters of the bridge must be set.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Objective.add_all_bridges","page":"API Reference","title":"MathOptInterface.Bridges.Objective.add_all_bridges","text":"add_all_bridges(model, ::Type{T}) where {T}\n\nAdd all bridges defined in the Bridges.Objective submodule to model.\n\nThe coefficient type used is T.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#ref_variable_bridges","page":"API Reference","title":"Variable bridge API","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.Variable.AbstractBridge\nBridges.Variable.SingleBridgeOptimizer\nBridges.Variable.supports_constrained_variable\nBridges.Variable.concrete_bridge_type\nBridges.Variable.bridge_constrained_variable\nBridges.Variable.add_all_bridges\nBridges.Variable.unbridged_map","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.AbstractBridge","page":"API Reference","title":"MathOptInterface.Bridges.Variable.AbstractBridge","text":"abstract type AbstractBridge <: MOI.Bridges.AbstractBridge end\n\nSubtype of MOI.Bridges.AbstractBridge for variable bridges.\n\nIn addition to the required implementation described in MOI.Bridges.AbstractBridge, subtypes of AbstractBridge must additionally implement:\n\nsupports_constrained_variable\nconcrete_bridge_type\nbridge_constrained_variable\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.SingleBridgeOptimizer","page":"API Reference","title":"MathOptInterface.Bridges.Variable.SingleBridgeOptimizer","text":"SingleBridgeOptimizer{BT<:AbstractBridge}(model::MOI.ModelLike)\n\nReturn MOI.Bridges.AbstractBridgeOptimizer that always bridges any variables constrained on creation supported by the bridge BT.\n\nThis is in contrast with the MOI.Bridges.LazyBridgeOptimizer, which only bridges the variables constrained on creation if they are supported by the bridge BT and unsupported by model.\n\nwarning: Warning\nTwo SingleBridgeOptimizers cannot be used together as both of them assume that the underlying model only returns variable indices with nonnegative values. Use MOI.Bridges.LazyBridgeOptimizer instead.\n\nExample\n\njulia> struct MyNewBridge{T} <: MOI.Bridges.Variable.AbstractBridge end\n\njulia> bridge = MOI.Bridges.Variable.SingleBridgeOptimizer{MyNewBridge{Float64}}(\n           MOI.Utilities.Model{Float64}(),\n       )\nMOIB.Variable.SingleBridgeOptimizer{MyNewBridge{Float64}, MOIU.Model{Float64}}\nwith 0 variable bridges\nwith inner model MOIU.Model{Float64}\n\nImplementation notes\n\nAll bridges should simplify the creation of SingleBridgeOptimizers by defining a constant that wraps the bridge in a SingleBridgeOptimizer.\n\njulia> const MyNewBridgeModel{T,OT<:MOI.ModelLike} =\n           MOI.Bridges.Variable.SingleBridgeOptimizer{MyNewBridge{T},OT};\n\nThis enables users to create bridged models as follows:\n\njulia> MyNewBridgeModel{Float64}(MOI.Utilities.Model{Float64}())\nMOIB.Variable.SingleBridgeOptimizer{MyNewBridge{Float64}, MOIU.Model{Float64}}\nwith 0 variable bridges\nwith inner model MOIU.Model{Float64}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.supports_constrained_variable","page":"API Reference","title":"MathOptInterface.Bridges.Variable.supports_constrained_variable","text":"supports_constrained_variable(\n    BT::Type{<:AbstractBridge},\n    S::Type{<:MOI.AbstractSet},\n)::Bool\n\nReturn a Bool indicating whether the bridges of type BT support bridging constrained variables in S. That is, it returns true if the bridge of type BT converts constrained variables of type S into a form supported by the solver.\n\nImplementation notes\n\nThis method depends only on the type of the bridge and set, not the runtime values.\nThere is a default fallback, so you need only implement this method for sets that the bridge implements.\n\nExample\n\njulia> MOI.Bridges.Variable.supports_constrained_variable(\n           MOI.Bridges.Variable.NonposToNonnegBridge{Float64},\n           MOI.Nonpositives,\n       )\ntrue\n\njulia> MOI.Bridges.Variable.supports_constrained_variable(\n           MOI.Bridges.Variable.NonposToNonnegBridge{Float64},\n           MOI.Nonnegatives,\n       )\nfalse\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.concrete_bridge_type","page":"API Reference","title":"MathOptInterface.Bridges.Variable.concrete_bridge_type","text":"concrete_bridge_type(\n    BT::Type{<:AbstractBridge},\n    S::Type{<:MOI.AbstractSet},\n)::Type\n\nReturn the concrete type of the bridge supporting variables in S constraints.\n\nThis function can only be called if MOI.supports_constrained_variable(BT, S) is true.\n\nExamples\n\nAs a variable in MOI.GreaterThan is bridged into variables in MOI.Nonnegatives by the VectorizeBridge:\n\njulia> MOI.Bridges.Variable.concrete_bridge_type(\n           MOI.Bridges.Variable.VectorizeBridge{Float64},\n           MOI.GreaterThan{Float64},\n       )\nMathOptInterface.Bridges.Variable.VectorizeBridge{Float64, MathOptInterface.Nonnegatives}\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.bridge_constrained_variable","page":"API Reference","title":"MathOptInterface.Bridges.Variable.bridge_constrained_variable","text":"bridge_constrained_variable(\n    BT::Type{<:AbstractBridge},\n    model::MOI.ModelLike,\n    set::MOI.AbstractSet,\n)::BT\n\nBridge the constrained variable in set using bridge BT to model and returns a bridge object of type BT.\n\nImplementation notes\n\nThe bridge type BT must be a concrete type, that is, all the type parameters of the bridge must be set.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.add_all_bridges","page":"API Reference","title":"MathOptInterface.Bridges.Variable.add_all_bridges","text":"add_all_bridges(model, ::Type{T}) where {T}\n\nAdd all bridges defined in the Bridges.Variable submodule to model.\n\nThe coefficient type used is T.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Variable.unbridged_map","page":"API Reference","title":"MathOptInterface.Bridges.Variable.unbridged_map","text":"unbridged_map(\n   bridge::MOI.Bridges.Variable.AbstractBridge,\n    vi::MOI.VariableIndex,\n)\n\nFor a bridged variable in a scalar set, return a tuple of pairs mapping the variables created by the bridge to an affine expression in terms of the bridged variable vi.\n\nunbridged_map(\n    bridge::MOI.Bridges.Variable.AbstractBridge,\n    vis::Vector{MOI.VariableIndex},\n)\n\nFor a bridged variable in a vector set, return a tuple of pairs mapping the variables created by the bridge to an affine expression in terms of the bridged variable vis. If this method is not implemented, it falls back to calling the following method for every variable of vis.\n\nunbridged_map(\n    bridge::MOI.Bridges.Variable.AbstractBridge,\n    vi::MOI.VariableIndex,\n    i::MOI.Bridges.IndexInVector,\n)\n\nFor a bridged variable in a vector set, return a tuple of pairs mapping the variables created by the bridge to an affine expression in terms of the bridged variable vi corresponding to the ith variable of the vector.\n\nIf there is no way to recover the expression in terms of the bridged variable(s) vi(s), return nothing. See ZerosBridge for an example of bridge returning nothing.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#AbstractBridgeOptimizer-API","page":"API Reference","title":"AbstractBridgeOptimizer API","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.AbstractBridgeOptimizer\nBridges.bridged_variable_function\nBridges.unbridged_variable_function\nBridges.bridged_function\nBridges.supports_constraint_bridges\nBridges.recursive_model\nBridges.FirstBridge","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.AbstractBridgeOptimizer","page":"API Reference","title":"MathOptInterface.Bridges.AbstractBridgeOptimizer","text":"abstract type AbstractBridgeOptimizer <: MOI.AbstractOptimizer end\n\nAn abstract type that implements generic functions for bridges.\n\nImplementation notes\n\nBy convention, the inner optimizer should be stored in a model field. If not, the optimizer must implement MOI.optimize!.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.bridged_variable_function","page":"API Reference","title":"MathOptInterface.Bridges.bridged_variable_function","text":"bridged_variable_function(\n    b::AbstractBridgeOptimizer,\n    vi::MOI.VariableIndex,\n)\n\nReturn a MOI.AbstractScalarFunction of variables of b.model that equals vi. That is, if the variable vi is bridged, it returns its expression in terms of the variables of b.model. Otherwise, it returns vi.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.unbridged_variable_function","page":"API Reference","title":"MathOptInterface.Bridges.unbridged_variable_function","text":"unbridged_variable_function(\n    b::AbstractBridgeOptimizer,\n    vi::MOI.VariableIndex,\n)\n\nReturn a MOI.AbstractScalarFunction of variables of b that equals vi. That is, if the variable vi is an internal variable of b.model created by a bridge but not visible to the user, it returns its expression in terms of the variables of bridged variables. Otherwise, it returns vi.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.bridged_function","page":"API Reference","title":"MathOptInterface.Bridges.bridged_function","text":"bridged_function(b::AbstractBridgeOptimizer, value)::typeof(value)\n\nSubstitute any bridged MOI.VariableIndex in value by an equivalent expression in terms of variables of b.model.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.supports_constraint_bridges","page":"API Reference","title":"MathOptInterface.Bridges.supports_constraint_bridges","text":"supports_constraint_bridges(b::AbstractBridgeOptimizer)::Bool\n\nReturn a Bool indicating if b supports MOI.Bridges.Constraint.AbstractBridge.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.recursive_model","page":"API Reference","title":"MathOptInterface.Bridges.recursive_model","text":"recursive_model(b::AbstractBridgeOptimizer)\n\nIf a variable, constraint, or objective is bridged, return the context of the inner variables. For most optimizers, this should be b.model.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.FirstBridge","page":"API Reference","title":"MathOptInterface.Bridges.FirstBridge","text":"struct FirstBridge <: MOI.AbstractConstraintAttribute end\n\nReturns the first bridge used to bridge the constraint.\n\nwarning: Warning\nThe indices of the bridge correspond to internal indices and may not correspond to indices of the model this attribute is got from.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#LazyBridgeOptimizer-API","page":"API Reference","title":"LazyBridgeOptimizer API","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.LazyBridgeOptimizer\nBridges.full_bridge_optimizer\nBridges.ListOfNonstandardBridges\nBridges.add_bridge\nBridges.remove_bridge\nBridges.has_bridge\nBridges.print_active_bridges\nBridges.print_graph\nBridges.debug_supports_constraint\nBridges.debug_supports","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.LazyBridgeOptimizer","page":"API Reference","title":"MathOptInterface.Bridges.LazyBridgeOptimizer","text":"LazyBridgeOptimizer(model::MOI.ModelLike)\n\nThe LazyBridgeOptimizer is a bridge optimizer that supports multiple bridges, and only bridges things which are not supported by the internal model.\n\nInternally, the LazyBridgeOptimizer solves a shortest hyper-path problem to determine which bridges to use.\n\nIn general, you should use full_bridge_optimizer instead of this constructor because full_bridge_optimizer automatically adds a large number of supported bridges.\n\nSee also: add_bridge, remove_bridge, has_bridge and full_bridge_optimizer.\n\nExample\n\njulia> model = MOI.Bridges.LazyBridgeOptimizer(MOI.Utilities.Model{Float64}())\nMOIB.LazyBridgeOptimizer{MOIU.Model{Float64}}\nwith 0 variable bridges\nwith 0 constraint bridges\nwith 0 objective bridges\nwith inner model MOIU.Model{Float64}\n\njulia> MOI.Bridges.add_bridge(model, MOI.Bridges.Variable.FreeBridge{Float64})\n\njulia> MOI.Bridges.has_bridge(model, MOI.Bridges.Variable.FreeBridge{Float64})\ntrue\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.full_bridge_optimizer","page":"API Reference","title":"MathOptInterface.Bridges.full_bridge_optimizer","text":"full_bridge_optimizer(model::MOI.ModelLike, ::Type{T}) where {T}\n\nReturns a LazyBridgeOptimizer bridging model for every bridge defined in this package (see below for the few exceptions) and for the coefficient type T, as well as the bridges in the list returned by the ListOfNonstandardBridges attribute.\n\nExample\n\njulia> model = MOI.Utilities.Model{Float64}();\n\njulia> bridged_model = MOI.Bridges.full_bridge_optimizer(model, Float64);\n\nExceptions\n\nThe following bridges are not added by full_bridge_optimizer, except if they are in the list returned by the ListOfNonstandardBridges attribute:\n\nConstraint.SOCtoNonConvexQuadBridge\nConstraint.RSOCtoNonConvexQuadBridge](@ref)\nConstraint.SOCtoPSDBridge\nIf T is not a subtype of AbstractFloat, subtypes of Constraint.AbstractToIntervalBridge\nConstraint.GreaterToIntervalBridge\nConstraint.LessToIntervalBridge)\n\nSee the docstring of the each bridge for the reason they are not added.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.ListOfNonstandardBridges","page":"API Reference","title":"MathOptInterface.Bridges.ListOfNonstandardBridges","text":"ListOfNonstandardBridges{T}() <: MOI.AbstractOptimizerAttribute\n\nAny optimizer can be wrapped in a LazyBridgeOptimizer using full_bridge_optimizer. However, by default LazyBridgeOptimizer uses a limited set of bridges that are:\n\nimplemented in MOI.Bridges\ngenerally applicable for all optimizers.\n\nFor some optimizers however, it is useful to add additional bridges, such as those that are implemented in external packages (for example, within the solver package itself) or only apply in certain circumstances (for example, Constraint.SOCtoNonConvexQuadBridge).\n\nSuch optimizers should implement the ListOfNonstandardBridges attribute to return a vector of bridge types that are added by full_bridge_optimizer in addition to the list of default bridges.\n\nNote that optimizers implementing ListOfNonstandardBridges may require package-specific functions or sets to be used if the non-standard bridges are not added. Therefore, you are recommended to use model = MOI.instantiate(Package.Optimizer; with_bridge_type = T) instead of model = MOI.instantiate(Package.Optimizer). See MOI.instantiate.\n\nExamples\n\nAn optimizer using a non-default bridge in MOI.Bridges\n\nSolvers supporting MOI.ScalarQuadraticFunction can support MOI.SecondOrderCone and MOI.RotatedSecondOrderCone by defining:\n\nfunction MOI.get(::MyQuadraticOptimizer, ::ListOfNonstandardBridges{Float64})\n    return Type[\n        MOI.Bridges.Constraint.SOCtoNonConvexQuadBridge{Float64},\n        MOI.Bridges.Constraint.RSOCtoNonConvexQuadBridge{Float64},\n    ]\nend\n\nAn optimizer defining an internal bridge\n\nSuppose an optimizer can exploit specific structure of a constraint, for example, it can exploit the structure of the matrix A in the linear system of equations A * x = b.\n\nThe optimizer can define the function:\n\nstruct MatrixAffineFunction{T} <: MOI.AbstractVectorFunction\n    A::SomeStructuredMatrixType{T}\n    b::Vector{T}\nend\n\nand then a bridge\n\nstruct MatrixAffineFunctionBridge{T} <: MOI.Constraint.AbstractBridge\n    # ...\nend\n# ...\n\nfrom VectorAffineFunction{T} to the MatrixAffineFunction. Finally, it defines:\n\nfunction MOI.get(::Optimizer{T}, ::ListOfNonstandardBridges{T}) where {T}\n    return Type[MatrixAffineFunctionBridge{T}]\nend\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.add_bridge","page":"API Reference","title":"MathOptInterface.Bridges.add_bridge","text":"add_bridge(b::LazyBridgeOptimizer, BT::Type{<:AbstractBridge})\n\nEnable the use of the bridges of type BT by b.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.remove_bridge","page":"API Reference","title":"MathOptInterface.Bridges.remove_bridge","text":"remove_bridge(b::LazyBridgeOptimizer, BT::Type{<:AbstractBridge})\n\nDisable the use of the bridges of type BT by b.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.has_bridge","page":"API Reference","title":"MathOptInterface.Bridges.has_bridge","text":"has_bridge(b::LazyBridgeOptimizer, BT::Type{<:AbstractBridge})\n\nReturn a Bool indicating whether the bridges of type BT are used by b.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.print_active_bridges","page":"API Reference","title":"MathOptInterface.Bridges.print_active_bridges","text":"print_active_bridges([io::IO=stdout,] b::MOI.Bridges.LazyBridgeOptimizer)\n\nPrint the set of bridges that are active in the model b.\n\n\n\n\n\nprint_active_bridges(\n    [io::IO=stdout,]\n    b::MOI.Bridges.LazyBridgeOptimizer,\n    F::Type{<:MOI.AbstractFunction}\n)\n\nPrint the set of bridges required for an objective function of type F.\n\n\n\n\n\nprint_active_bridges(\n    [io::IO=stdout,]\n    b::MOI.Bridges.LazyBridgeOptimizer,\n    F::Type{<:MOI.AbstractFunction},\n    S::Type{<:MOI.AbstractSet},\n)\n\nPrint the set of bridges required for a constraint of type F-in-S.\n\n\n\n\n\nprint_active_bridges(\n    [io::IO=stdout,]\n    b::MOI.Bridges.LazyBridgeOptimizer,\n    S::Type{<:MOI.AbstractSet}\n)\n\nPrint the set of bridges required for a variable constrained to set S.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.print_graph","page":"API Reference","title":"MathOptInterface.Bridges.print_graph","text":"print_graph([io::IO = stdout,] b::LazyBridgeOptimizer)\n\nPrint the hyper-graph containing all variable, constraint, and objective types that could be obtained by bridging the variables, constraints, and objectives that are present in the model by all the bridges added to b.\n\nEach node in the hyper-graph corresponds to a variable, constraint, or objective type.\n\nVariable nodes are indicated by [ ]\nConstraint nodes are indicated by ( )\nObjective nodes are indicated by | |\n\nThe number inside each pair of brackets is an index of the node in the hyper-graph.\n\nNote that this hyper-graph is the full list of possible transformations. When the bridged model is created, we select the shortest hyper-path from this graph, so many nodes may be un-used.\n\nTo see which nodes are used, call print_active_bridges.\n\nFor more information, see Legat, B., Dowson, O., Garcia, J., and Lubin, M. (2020).  \"MathOptInterface: a data structure for mathematical optimization problems.\" URL\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.debug_supports_constraint","page":"API Reference","title":"MathOptInterface.Bridges.debug_supports_constraint","text":"debug_supports_constraint(\n    b::LazyBridgeOptimizer,\n    F::Type{<:MOI.AbstractFunction},\n    S::Type{<:MOI.AbstractSet};\n    io::IO = Base.stdout,\n)\n\nPrints to io explanations for the value of MOI.supports_constraint with the same arguments.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.debug_supports","page":"API Reference","title":"MathOptInterface.Bridges.debug_supports","text":"debug_supports(\n    b::LazyBridgeOptimizer,\n    ::MOI.ObjectiveFunction{F};\n    io::IO = Base.stdout,\n) where F\n\nPrints to io explanations for the value of MOI.supports with the same arguments.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#constraint_set_map","page":"API Reference","title":"SetMap API","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.map_set\nBridges.inverse_map_set\nBridges.map_function\nBridges.inverse_map_function\nBridges.adjoint_map_function\nBridges.inverse_adjoint_map_function","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.map_set","page":"API Reference","title":"MathOptInterface.Bridges.map_set","text":"map_set(::Type{BT}, set) where {BT}\n\nReturn the image of set through the linear map A defined in Variable.SetMapBridge and Constraint.SetMapBridge. This is used for bridging the constraint and setting the MOI.ConstraintSet.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.inverse_map_set","page":"API Reference","title":"MathOptInterface.Bridges.inverse_map_set","text":"inverse_map_set(::Type{BT}, set) where {BT}\n\nReturn the preimage of set through the linear map A defined in Variable.SetMapBridge and Constraint.SetMapBridge. This is used for getting the MOI.ConstraintSet.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.map_function","page":"API Reference","title":"MathOptInterface.Bridges.map_function","text":"map_function(::Type{BT}, func) where {BT}\n\nReturn the image of func through the linear map A defined in Variable.SetMapBridge and Constraint.SetMapBridge. This is used for getting the MOI.ConstraintPrimal of variable bridges. For constraint bridges, this is used for bridging the constraint, setting the MOI.ConstraintFunction and MOI.ConstraintPrimalStart and modifying the function with MOI.modify.\n\nmap_function(::Type{BT}, func, i::IndexInVector) where {BT}\n\nReturn the scalar function at the ith index of the vector function that would be returned by map_function(BT, func) except that it may compute the ith element. This is used by bridged_function and for getting the MOI.VariablePrimal and MOI.VariablePrimalStart of variable bridges.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.inverse_map_function","page":"API Reference","title":"MathOptInterface.Bridges.inverse_map_function","text":"inverse_map_function(::Type{BT}, func) where {BT}\n\nReturn the image of func through the inverse of the linear map A defined in Variable.SetMapBridge and Constraint.SetMapBridge. This is used by Variable.unbridged_map and for setting the MOI.VariablePrimalStart of variable bridges and for getting the MOI.ConstraintFunction, the MOI.ConstraintPrimal and the MOI.ConstraintPrimalStart of constraint bridges.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.adjoint_map_function","page":"API Reference","title":"MathOptInterface.Bridges.adjoint_map_function","text":"adjoint_map_function(::Type{BT}, func) where {BT}\n\nReturn the image of func through the adjoint of the linear map A defined in Variable.SetMapBridge and Constraint.SetMapBridge. This is used for getting the MOI.ConstraintDual and MOI.ConstraintDualStart of constraint bridges.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.inverse_adjoint_map_function","page":"API Reference","title":"MathOptInterface.Bridges.inverse_adjoint_map_function","text":"inverse_adjoint_map_function(::Type{BT}, func) where {BT}\n\nReturn the image of func through the inverse of the adjoint of the linear map A defined in Variable.SetMapBridge and Constraint.SetMapBridge. This is used for getting the MOI.ConstraintDual of variable bridges and setting the MOI.ConstraintDualStart of constraint bridges.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#Bridging-graph-API","page":"API Reference","title":"Bridging graph API","text":"","category":"section"},{"location":"moi/submodules/Bridges/reference/","page":"API Reference","title":"API Reference","text":"Bridges.Graph\nBridges.VariableNode\nBridges.ConstraintNode\nBridges.ObjectiveNode\nBridges.Edge\nBridges.ObjectiveEdge\nBridges.add_node\nBridges.add_edge\nBridges.set_variable_constraint_node\nBridges.bridge_index\nBridges.is_variable_edge_best","category":"page"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Graph","page":"API Reference","title":"MathOptInterface.Bridges.Graph","text":"Graph()\n\nA type-stable datastructure for computing the shortest hyperpath problem.\n\nNodes\n\nThere are three types of nodes in the graph:\n\nVariableNode\nConstraintNode\nObjectiveNode\n\nAdd nodes to the graph using add_node.\n\nEdges\n\nThere are two types of edges in the graph:\n\nEdge\nObjectiveEdge\n\nAdd edges to the graph using add_edge.\n\nFor the ability to add a variable constrained  on creation as a free variable followed by a constraint, use set_variable_constraint_node.\n\nOptimal hyper-edges\n\nUse bridge_index to compute the minimum-cost bridge leaving a node.\n\nNote that bridge_index lazy runs a Bellman-Ford algorithm to compute the set of minimum cost edges. Thus, the first call to bridge_index after adding new nodes or edges will take longer than subsequent calls.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.VariableNode","page":"API Reference","title":"MathOptInterface.Bridges.VariableNode","text":"VariableNode(index::Int)\n\nA node in Graph representing a variable constrained on creation.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.ConstraintNode","page":"API Reference","title":"MathOptInterface.Bridges.ConstraintNode","text":"ConstraintNode(index::Int)\n\nA node in Graph representing a constraint.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.ObjectiveNode","page":"API Reference","title":"MathOptInterface.Bridges.ObjectiveNode","text":"ObjectiveNode(index::Int)\n\nA node in Graph representing an objective function.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.Edge","page":"API Reference","title":"MathOptInterface.Bridges.Edge","text":"Edge(\n    bridge_index::Int,\n    added_variables::Vector{VariableNode},\n    added_constraints::Vector{ConstraintNode},\n    cost::Float64 = 1.0,\n)\n\nReturn a new datastructure representing an edge in Graph that starts at a VariableNode or a ConstraintNode.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.ObjectiveEdge","page":"API Reference","title":"MathOptInterface.Bridges.ObjectiveEdge","text":"ObjectiveEdge(\n    bridge_index::Int,\n    added_variables::Vector{VariableNode},\n    added_constraints::Vector{ConstraintNode},\n)\n\nReturn a new datastructure representing an edge in Graph that starts at an ObjectiveNode.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.add_node","page":"API Reference","title":"MathOptInterface.Bridges.add_node","text":"add_node(graph::Graph, ::Type{VariableNode})::VariableNode\nadd_node(graph::Graph, ::Type{ConstraintNode})::ConstraintNode\nadd_node(graph::Graph, ::Type{ObjectiveNode})::ObjectiveNode\n\nAdd a new node to graph.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.add_edge","page":"API Reference","title":"MathOptInterface.Bridges.add_edge","text":"add_edge(graph::Graph, node::VariableNode, edge::Edge)::Nothing\nadd_edge(graph::Graph, node::ConstraintNode, edge::Edge)::Nothing\nadd_edge(graph::Graph, node::ObjectiveNode, edge::ObjectiveEdge)::Nothing\n\nAdd edge to graph, where edge starts at node and connects to the nodes defined in edge.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.set_variable_constraint_node","page":"API Reference","title":"MathOptInterface.Bridges.set_variable_constraint_node","text":"set_variable_constraint_node(\n    graph::Graph,\n    variable_node::VariableNode,\n    constraint_node::ConstraintNode,\n    cost::Int,\n)\n\nAs an alternative to variable_node, add a virtual edge to graph that represents adding a free variable, followed by a constraint of type constraint_node, with bridging cost cost.\n\nWhy is this needed?\n\nVariables can either be added as a variable constrained on creation, or as a free variable which then has a constraint added to it.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.bridge_index","page":"API Reference","title":"MathOptInterface.Bridges.bridge_index","text":"bridge_index(graph::Graph, node::VariableNode)::Int\nbridge_index(graph::Graph, node::ConstraintNode)::Int\nbridge_index(graph::Graph, node::ObjectiveNode)::Int\n\nReturn the optimal index of the bridge to chose from node.\n\n\n\n\n\n","category":"function"},{"location":"moi/submodules/Bridges/reference/#MathOptInterface.Bridges.is_variable_edge_best","page":"API Reference","title":"MathOptInterface.Bridges.is_variable_edge_best","text":"is_variable_edge_best(graph::Graph, node::VariableNode)::Bool\n\nReturn a Bool indicating whether node should be added as a variable constrained on creation, or as a free variable followed by a constraint.\n\n\n\n\n\n","category":"function"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"EditURL = \"https://github.com/kocvara/Loraine.jl/blob/v0.1.2/README.md\"","category":"page"},{"location":"packages/Loraine/#Loraine.jl","page":"kocvara/Loraine.jl","title":"Loraine.jl","text":"","category":"section"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"Sweet Lor(r)aine, let the party carry on[1]...","category":"page"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"[1]: https://www.youtube.com/watch?v=0D2wNf1lVrI","category":"page"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"Loraine.jl is a Julia implementation of an interior point method algorithm for linear semidefinite optimization problems. ","category":"page"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"The special feature of Loraine is the iterative solver for linear systems. This is to be used for problems with (very) low rank solution matrix.","category":"page"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"Standard (non-low-rank) problems and linear programs can be solved using the direct solver; then the user gets a standard IP method akin SDPT3.","category":"page"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"There is also a MATLAB version of the code at kocvara/Loraine.m.","category":"page"},{"location":"packages/Loraine/#License-and-Original-Contributors","page":"kocvara/Loraine.jl","title":"License and Original Contributors","text":"","category":"section"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"Loraine is licensed under the MIT License.","category":"page"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"Loraine was developed by Soodeh Habibi and Michal Kočvara, University of Birmingham, and Michael Stingl, University of Erlangen, for H2020 ITN POEMA. ","category":"page"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"The JuMP interface was provided by Benoît Legat. His help is greatly acknowledged.","category":"page"},{"location":"packages/Loraine/#Installation","page":"kocvara/Loraine.jl","title":"Installation","text":"","category":"section"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"Install Loraine using Pkg.add:","category":"page"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"import Pkg\nPkg.add(\"Loraine\")","category":"page"},{"location":"packages/Loraine/#Use-with-JuMP","page":"kocvara/Loraine.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"To use Loraine with JuMP, use Loraine.Optimizer:","category":"page"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"using JuMP, Loraine\nmodel = Model(Loraine.Optimizer)\nset_attribute(model, \"maxit\", 100)","category":"page"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"To solve an SDP problem stored in SDPA format, do","category":"page"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"using JuMP, Loraine\nmodel = read_from_file(\"examples/data/theta1.dat-s\")\nset_optimizer(model, Loraine.Optimizer)\noptimize!(model)","category":"page"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"For more examples, the folder examples includes a few examples of how to use Loraine via JuMP; in particular, solve_sdpa.jl reads an SDP in the SDPA input format and solves it by Loraine. A few sample problems can be found in folder examples/data.","category":"page"},{"location":"packages/Loraine/#Rank-one-data","page":"kocvara/Loraine.jl","title":"Rank-one data","text":"","category":"section"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"If the solution does not have low rank, it is recommended to use a direct  solver kit = 0. However, if you know that your data matrices are all rank-one,  use the option datarank = -1 to get a significant reduction in the complexity  (and CPU time). Examples of such problems are maxG11 and thetaG11 from the  SDPLIB collection.","category":"page"},{"location":"packages/Loraine/#Options","page":"kocvara/Loraine.jl","title":"Options","text":"","category":"section"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"The list of options:","category":"page"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"kit             # kit = 0 for direct solver; kit = 1 for CG [0]\ntol_cg          # tolerance for CG solver [1.0e-2]\ntol_cg_up       # tolerance update [0.5]\ntol_cg_min      # minimal tolerance for CG solver [1.0e-6]\neDIMACS         # epsilon for DIMACS error stopping criterion [1.0e-5]\npreconditioner  # 0...no; 1...H_alpha; 2...H_beta; 4...hybrid [1]\nerank           # estimated rank [1]\naamat           # 0..A^TA; 1..diag(A^TA); 2..identity [2]\nverb            # 2..full output; 1..short output; 0..no output [1]\ndatarank        # 0..full rank matrices expected [0]\n                # -1..rank-1 matrices expected, converted to vectors, if possible\n                # (TBD) 1..vectors expected for low-rank data matrices\ninitpoint       # 0..Loraine heuristics, 1..SDPT3-like heuristics [0]\ntiming          # 1..yes, 0..no\nmaxit           # maximal number of global iterations [200]","category":"page"},{"location":"packages/Loraine/#Citing","page":"kocvara/Loraine.jl","title":"Citing","text":"","category":"section"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"If you find Loraine useful, please cite the following paper:","category":"page"},{"location":"packages/Loraine/","page":"kocvara/Loraine.jl","title":"kocvara/Loraine.jl","text":"@article{loraine2023,\n  title={Loraine-An interior-point solver for low-rank semidefinite programming},\n  author={Habibi, Soodeh and Ko{\\v{c}}vara, Michal and Stingl, Michael},\n  www={https://hal.science/hal-04076509/}\n  note={Preprint hal-04076509}\n  year={2023}\n}","category":"page"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"EditURL = nothing","category":"page"},{"location":"api/JuMP.Containers/#DocumenterReference_JuMP.Containers","page":"JuMP.Containers","title":"JuMP.Containers","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"This page lists the public API of JuMP.Containers.","category":"page"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"info: Info\nThis page is an unstructured list of the JuMP.Containers API. For a more structured overview, read the Manual or Tutorial parts of this documentation.","category":"page"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"Load all of the public the API into the current scope with:","category":"page"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"using JuMP.Containers","category":"page"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"Alternatively, load only the module with:","category":"page"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"import JuMP.Containers","category":"page"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"and then prefix all calls with JuMP.Containers. to create JuMP.Containers.<NAME>.","category":"page"},{"location":"api/JuMP.Containers/#DenseAxisArray","page":"JuMP.Containers","title":"DenseAxisArray","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"JuMP.Containers.DenseAxisArray","category":"page"},{"location":"api/JuMP.Containers/#JuMP.Containers.DenseAxisArray","page":"JuMP.Containers","title":"JuMP.Containers.DenseAxisArray","text":"DenseAxisArray(data::Array{T, N}, axes...) where {T, N}\n\nConstruct a JuMP array with the underlying data specified by the data array and the given axes. Exactly N axes must be provided, and their lengths must match size(data) in the corresponding dimensions.\n\nExample\n\njulia> array = Containers.DenseAxisArray([1 2; 3 4], [:a, :b], 2:3)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, [:a, :b]\n    Dimension 2, 2:3\nAnd data, a 2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> array[:b, 3]\n4\n\n\n\n\n\nDenseAxisArray{T}(undef, axes...) where T\n\nConstruct an uninitialized DenseAxisArray with element-type T indexed over the given axes.\n\nExample\n\njulia> array = Containers.DenseAxisArray{Float64}(undef, [:a, :b], 1:2);\n\njulia> fill!(array, 1.0)\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, [:a, :b]\n    Dimension 2, 1:2\nAnd data, a 2×2 Matrix{Float64}:\n 1.0  1.0\n 1.0  1.0\n\njulia> array[:a, 2] = 5.0\n5.0\n\njulia> array[:a, 2]\n5.0\n\njulia> array\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, [:a, :b]\n    Dimension 2, 1:2\nAnd data, a 2×2 Matrix{Float64}:\n 1.0  5.0\n 1.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP.Containers/#SparseAxisArray","page":"JuMP.Containers","title":"SparseAxisArray","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"JuMP.Containers.SparseAxisArray","category":"page"},{"location":"api/JuMP.Containers/#JuMP.Containers.SparseAxisArray","page":"JuMP.Containers","title":"JuMP.Containers.SparseAxisArray","text":"struct SparseAxisArray{T,N,K<:NTuple{N, Any}} <: AbstractArray{T,N}\n    data::OrderedCollections.OrderedDict{K,T}\nend\n\nN-dimensional array with elements of type T where only a subset of the entries are defined. The entries with indices idx = (i1, i2, ..., iN) in keys(data) has value data[idx].\n\nNote that, as opposed to SparseArrays.AbstractSparseArray, the missing entries are not assumed to be zero(T), they are simply not part of the array. This means that the result of map(f, sa::SparseAxisArray) or f.(sa::SparseAxisArray) has the same sparsity structure as sa, even if f(zero(T)) is not zero.\n\nExample\n\njulia> using OrderedCollections: OrderedDict\n\njulia> dict = OrderedDict((:a, 2) => 1.0, (:a, 3) => 2.0, (:b, 3) => 3.0)\nOrderedDict{Tuple{Symbol, Int64}, Float64} with 3 entries:\n  (:a, 2) => 1.0\n  (:a, 3) => 2.0\n  (:b, 3) => 3.0\n\njulia> array = Containers.SparseAxisArray(dict)\nSparseAxisArray{Float64, 2, Tuple{Symbol, Int64}} with 3 entries:\n  [a, 2]  =  1.0\n  [a, 3]  =  2.0\n  [b, 3]  =  3.0\n\njulia> array[:b, 3]\n3.0\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP.Containers/#Containers.@container","page":"JuMP.Containers","title":"Containers.@container","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"JuMP.Containers.Containers.@container","category":"page"},{"location":"api/JuMP.Containers/#JuMP.Containers.@container","page":"JuMP.Containers","title":"JuMP.Containers.@container","text":"@container([i=..., j=..., ...], expr[, container = :Auto])\n\nCreate a container with indices i, j, ... and values given by expr that may depend on the value of the indices.\n\n@container(ref[i=..., j=..., ...], expr[, container = :Auto])\n\nSame as above but the container is assigned to the variable of name ref.\n\nThe type of container can be controlled by the container keyword.\n\nnote: Note\nWhen the index set is explicitly given as 1:n for any expression n, it is transformed to Base.OneTo(n) before being given to container.\n\nExample\n\njulia> Containers.@container([i = 1:3, j = 1:3], i + j)\n3×3 Matrix{Int64}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> I = 1:3\n1:3\n\njulia> Containers.@container(x[i = I, j = I], i + j);\n\njulia> x\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, 1:3\nAnd data, a 3×3 Matrix{Int64}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.@container([i = 2:3, j = 1:3], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, Base.OneTo(3)\nAnd data, a 2×3 Matrix{Int64}:\n 3  4  5\n 4  5  6\n\njulia> Containers.@container([i = 1:3, j = 1:3; i <= j], i + j)\nSparseAxisArray{Int64, 2, Tuple{Int64, Int64}} with 6 entries:\n  [1, 1]  =  2\n  [1, 2]  =  3\n  [1, 3]  =  4\n  [2, 2]  =  4\n  [2, 3]  =  5\n  [3, 3]  =  6\n\n\n\n\n\n","category":"macro"},{"location":"api/JuMP.Containers/#Containers.container","page":"JuMP.Containers","title":"Containers.container","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"JuMP.Containers.Containers.container","category":"page"},{"location":"api/JuMP.Containers/#JuMP.Containers.container","page":"JuMP.Containers","title":"JuMP.Containers.container","text":"container(f::Function, indices[[, ::Type{C} = AutoContainerType], names])\n\nCreate a container of type C with index names names, indices indices and values at given indices given by f.\n\nIf the method with names is not specialized on Type{C}, it falls back to calling  container(f, indices, c) for backwards compatibility with containers not supporting index names.\n\nExample\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(Base.OneTo(3), Base.OneTo(3)))\n3×3 Matrix{Int64}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(1:3, 1:3))\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, 1:3\nAnd data, a 3×3 Matrix{Int64}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(2:3, Base.OneTo(3)))\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, Base.OneTo(3)\nAnd data, a 2×3 Matrix{Int64}:\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.nested(() -> 1:3, i -> i:3, condition = (i, j) -> isodd(i) || isodd(j)))\nSparseAxisArray{Int64, 2, Tuple{Int64, Int64}} with 5 entries:\n  [1, 1]  =  2\n  [1, 2]  =  3\n  [1, 3]  =  4\n  [2, 3]  =  5\n  [3, 3]  =  6\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP.Containers/#Containers.rowtable","page":"JuMP.Containers","title":"Containers.rowtable","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"JuMP.Containers.Containers.rowtable","category":"page"},{"location":"api/JuMP.Containers/#JuMP.Containers.rowtable","page":"JuMP.Containers","title":"JuMP.Containers.rowtable","text":"rowtable([f::Function=identity,] x; [header::Vector{Symbol} = Symbol[]])\n\nApplies the function f to all elements of the variable container x, returning the result as a Vector of NamedTuples, where header is a vector containing the corresponding axis names.\n\nIf x is an N-dimensional array, there must be N+1 names, so that the last name corresponds to the result of f(x[i]).\n\nIf header is left empty, then the default header is [:x1, :x2, ..., :xN, :y].\n\ninfo: Info\nA Vector of NamedTuples implements the Tables.jl interface, and so the result can be used as input for any function that consumes a 'Tables.jl' compatible source.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x[i=1:2, j=i:2] >= 0, start = i+j);\n\njulia> Containers.rowtable(start_value, x; header = [:i, :j, :start])\n3-element Vector{@NamedTuple{i::Int64, j::Int64, start::Float64}}:\n (i = 1, j = 1, start = 2.0)\n (i = 1, j = 2, start = 3.0)\n (i = 2, j = 2, start = 4.0)\n\njulia> Containers.rowtable(x)\n3-element Vector{@NamedTuple{x1::Int64, x2::Int64, y::VariableRef}}:\n (x1 = 1, x2 = 1, y = x[1,1])\n (x1 = 1, x2 = 2, y = x[1,2])\n (x1 = 2, x2 = 2, y = x[2,2])\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP.Containers/#Containers.default_container","page":"JuMP.Containers","title":"Containers.default_container","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"JuMP.Containers.Containers.default_container","category":"page"},{"location":"api/JuMP.Containers/#JuMP.Containers.default_container","page":"JuMP.Containers","title":"JuMP.Containers.default_container","text":"default_container(indices)\n\nIf indices is a NestedIterator, return a SparseAxisArray. Otherwise, indices should be a VectorizedProductIterator and the function returns Array if all iterators of the product are Base.OneTo and returns DenseAxisArray otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP.Containers/#Containers.nested","page":"JuMP.Containers","title":"Containers.nested","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"JuMP.Containers.Containers.nested","category":"page"},{"location":"api/JuMP.Containers/#JuMP.Containers.nested","page":"JuMP.Containers","title":"JuMP.Containers.nested","text":"nested(iterators...; condition = (args...) -> true)\n\nCreate a NestedIterator.\n\nExample\n\njulia> iterator = Containers.nested(\n           () -> 1:2,\n           (i,) -> [\"A\", \"B\"];\n           condition = (i, j) -> isodd(i) || j == \"B\",\n       );\n\njulia> collect(iterator)\n3-element Vector{Tuple{Int64, String}}:\n (1, \"A\")\n (1, \"B\")\n (2, \"B\")\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP.Containers/#Containers.vectorized_product","page":"JuMP.Containers","title":"Containers.vectorized_product","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"JuMP.Containers.Containers.vectorized_product","category":"page"},{"location":"api/JuMP.Containers/#JuMP.Containers.vectorized_product","page":"JuMP.Containers","title":"JuMP.Containers.vectorized_product","text":"vectorized_product(iterators...)\n\nCreated a VectorizedProductIterator.\n\nExample\n\njulia> iterator = Containers.vectorized_product(1:2, [\"A\", \"B\"]);\n\njulia> collect(iterator)\n2×2 Matrix{Tuple{Int64, String}}:\n (1, \"A\")  (1, \"B\")\n (2, \"A\")  (2, \"B\")\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP.Containers/#Containers.build_error_fn","page":"JuMP.Containers","title":"Containers.build_error_fn","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"JuMP.Containers.Containers.build_error_fn","category":"page"},{"location":"api/JuMP.Containers/#JuMP.Containers.build_error_fn","page":"JuMP.Containers","title":"JuMP.Containers.build_error_fn","text":"build_error_fn(macro_name, args, source)\n\nReturn a function that can be used in place of Base.error, but which additionally prints the macro from which it was called.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP.Containers/#Containers.parse_macro_arguments","page":"JuMP.Containers","title":"Containers.parse_macro_arguments","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"JuMP.Containers.Containers.parse_macro_arguments","category":"page"},{"location":"api/JuMP.Containers/#JuMP.Containers.parse_macro_arguments","page":"JuMP.Containers","title":"JuMP.Containers.parse_macro_arguments","text":"parse_macro_arguments(\n    error_fn::Function,\n    args;\n    valid_kwargs::Union{Nothing,Vector{Symbol}} = nothing,\n    num_positional_args::Union{Nothing,Int,UnitRange{Int}} = nothing,\n)\n\nReturns a Tuple{Vector{Any},Dict{Symbol,Any}} containing the ordered positional arguments and a dictionary mapping the keyword arguments.\n\nThis specially handles the distinction of @foo(key = value) and @foo(; key = value) in macros.\n\nAn error is thrown if multiple keyword arguments are passed with the same key.\n\nIf valid_kwargs is a Vector{Symbol}, an error is thrown if a keyword is not in valid_kwargs.\n\nIf num_positional_args is not nothing, an error is thrown if the number of positional arguments is not in num_positional_args.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP.Containers/#Containers.parse_ref_sets","page":"JuMP.Containers","title":"Containers.parse_ref_sets","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"JuMP.Containers.Containers.parse_ref_sets","category":"page"},{"location":"api/JuMP.Containers/#JuMP.Containers.parse_ref_sets","page":"JuMP.Containers","title":"JuMP.Containers.parse_ref_sets","text":"parse_ref_sets(\n    error_fn::Function,\n    expr;\n    invalid_index_variables::Vector{Symbol} = Symbol[],\n)\n\nHelper function for macros to construct container objects.\n\nwarning: Warning\nThis function is for advanced users implementing JuMP extensions. See container_code for more details.\n\nArguments\n\nerror_fn: a function that takes a String and throws an error, potentially annotating the input string with extra information such as from which macro it was thrown from. Use error if you do not want a modified error message.\nexpr: an Expr that specifies the container, for example, :(x[i = 1:3, [:red, :blue], k = S; i + k <= 6])\n\nReturns\n\nname: the name of the container, if given, otherwise nothing\nindex_vars: a Vector{Any} of names for the index variables, for example, [:i, gensym(), :k]. These may also be expressions, like :((i, j)) from a call like :(x[(i, j) in S]).\nindices: an iterator over the indices, for example, Containers.NestedIterator\n\nExample\n\nSee container_code for a worked example.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP.Containers/#Containers.build_name_expr","page":"JuMP.Containers","title":"Containers.build_name_expr","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"JuMP.Containers.Containers.build_name_expr","category":"page"},{"location":"api/JuMP.Containers/#JuMP.Containers.build_name_expr","page":"JuMP.Containers","title":"JuMP.Containers.build_name_expr","text":"build_name_expr(\n    name::Union{Symbol,Nothing},\n    index_vars::Vector,\n    kwargs::Dict{Symbol,Any},\n)\n\nReturns an expression for the name of a container element, where name and index_vars are the values returned by parse_ref_sets and kwargs is the dictionary returned by parse_macro_arguments.\n\nThis assumes that the key in kwargs used to over-ride the name choice is :base_name.\n\nExample\n\njulia> Containers.build_name_expr(:x, [:i, :j], Dict{Symbol,Any}())\n:(string(\"x\", \"[\", string($(Expr(:escape, :i))), \",\", string($(Expr(:escape, :j))), \"]\"))\n\njulia> Containers.build_name_expr(nothing, [:i, :j], Dict{Symbol,Any}())\n\"\"\n\njulia> Containers.build_name_expr(:y, [:i, :j], Dict{Symbol,Any}(:base_name => \"y\"))\n:(string(\"y\", \"[\", string($(Expr(:escape, :i))), \",\", string($(Expr(:escape, :j))), \"]\"))\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP.Containers/#Containers.add_additional_args","page":"JuMP.Containers","title":"Containers.add_additional_args","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"JuMP.Containers.Containers.add_additional_args","category":"page"},{"location":"api/JuMP.Containers/#JuMP.Containers.add_additional_args","page":"JuMP.Containers","title":"JuMP.Containers.add_additional_args","text":"add_additional_args(\n    call::Expr,\n    args::Vector,\n    kwargs::Dict{Symbol,Any};\n    kwarg_exclude::Vector{Symbol} = Symbol[],\n)\n\nAdd the positional arguments args to the function call expression call, escaping each argument expression.\n\nThis function is able to incorporate additional positional arguments to calls that already have keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP.Containers/#Containers.container_code","page":"JuMP.Containers","title":"Containers.container_code","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"JuMP.Containers.Containers.container_code","category":"page"},{"location":"api/JuMP.Containers/#JuMP.Containers.container_code","page":"JuMP.Containers","title":"JuMP.Containers.container_code","text":"container_code(\n    index_vars::Vector{Any},\n    indices::Expr,\n    code,\n    requested_container::Union{Symbol,Expr,Dict{Symbol,Any}},\n)\n\nUsed in macros to construct a call to container. This should be used in conjunction with parse_ref_sets.\n\nArguments\n\nindex_vars::Vector{Any}: a vector of names for the indices of the container. These may also be expressions, like :((i, j)) from a call like :(x[(i, j) in S]).\nindices::Expr: an expression that evaluates to an iterator of the indices.\ncode: an expression or literal constant for the value to be stored in the container as a function of the named index_vars.\nrequested_container: passed to the third argument of container. For built-in JuMP types, choose one of :Array, :DenseAxisArray, :SparseAxisArray, or :Auto. For a user-defined container, this expression must evaluate to the correct type. You may also pass the kwargs dictionary from parse_macro_arguments.\n\nwarning: Warning\nIn most cases, you should esc(code) before passing it to container_code.\n\nExample\n\njulia> macro foo(ref_sets, code)\n           name, index_vars, indices =\n               Containers.parse_ref_sets(error, ref_sets)\n           @assert name !== nothing  # Anonymous container not supported\n           container =\n               Containers.container_code(index_vars, indices, esc(code), :Auto)\n           return quote\n               $(esc(name)) = $container\n           end\n       end\n@foo (macro with 1 method)\n\njulia> @foo(x[i=1:2, j=[\"A\", \"B\"]], j^i);\n\njulia> x\n2-dimensional DenseAxisArray{String,2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, [\"A\", \"B\"]\nAnd data, a 2×2 Matrix{String}:\n \"A\"   \"B\"\n \"AA\"  \"BB\"\n\n\n\n\n\n","category":"function"},{"location":"api/JuMP.Containers/#Containers.AutoContainerType","page":"JuMP.Containers","title":"Containers.AutoContainerType","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"JuMP.Containers.Containers.AutoContainerType","category":"page"},{"location":"api/JuMP.Containers/#JuMP.Containers.AutoContainerType","page":"JuMP.Containers","title":"JuMP.Containers.AutoContainerType","text":"AutoContainerType\n\nPass AutoContainerType to container to let the container type be chosen based on the type of the indices using default_container.\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP.Containers/#Containers.NestedIterator","page":"JuMP.Containers","title":"Containers.NestedIterator","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"JuMP.Containers.Containers.NestedIterator","category":"page"},{"location":"api/JuMP.Containers/#JuMP.Containers.NestedIterator","page":"JuMP.Containers","title":"JuMP.Containers.NestedIterator","text":"struct NestedIterator{T}\n    iterators::T # Tuple of functions\n    condition::Function\nend\n\nIterators over the tuples that are produced by a nested for loop.\n\nConstruct a NestedIterator using nested.\n\nExample\n\njulia> iterators = (() -> 1:2, (i,) -> [\"A\", \"B\"]);\n\njulia> condition = (i, j) -> isodd(i) || j == \"B\";\n\njulia> x = Containers.NestedIterator(iterators, condition);\n\njulia> for (i, j) in x\n           println((i, j))\n       end\n(1, \"A\")\n(1, \"B\")\n(2, \"B\")\n\nis the same as\n\njulia> for i in iterators[1]()\n           for j in iterators[2](i)\n               if condition(i, j)\n                   println((i, j))\n               end\n           end\n       end\n(1, \"A\")\n(1, \"B\")\n(2, \"B\")\n\n\n\n\n\n","category":"type"},{"location":"api/JuMP.Containers/#Containers.VectorizedProductIterator","page":"JuMP.Containers","title":"Containers.VectorizedProductIterator","text":"","category":"section"},{"location":"api/JuMP.Containers/","page":"JuMP.Containers","title":"JuMP.Containers","text":"JuMP.Containers.Containers.VectorizedProductIterator","category":"page"},{"location":"api/JuMP.Containers/#JuMP.Containers.VectorizedProductIterator","page":"JuMP.Containers","title":"JuMP.Containers.VectorizedProductIterator","text":"struct VectorizedProductIterator{T}\n    prod::Iterators.ProductIterator{T}\nend\n\nA wrapper type for Iterators.ProuctIterator that discards shape information and returns a Vector.\n\nConstruct a VectorizedProductIterator using vectorized_product.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"EditURL = \"multi_objective_knapsack.jl\"","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/#Multi-objective-knapsack","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"","category":"section"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"The purpose of this tutorial is to demonstrate how to create and solve a multi-objective linear program. In addition, it demonstrates how to work with solvers which return multiple solutions.","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/#Required-packages","page":"Multi-objective knapsack","title":"Required packages","text":"","category":"section"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"This tutorial requires the following packages:","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"using JuMP\nimport HiGHS\nimport MultiObjectiveAlgorithms as MOA\nimport Plots\nimport Test  #hide","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"MultiObjectiveAlgorithms.jl is a package which implements a variety of algorithms for solving multi-objective optimization problems. Because it is a long package name, we import it instead as MOA.","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/#Formulation","page":"Multi-objective knapsack","title":"Formulation","text":"","category":"section"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"The knapsack problem is a classic problem in mixed-integer programming. Given a collection of items i in I, each of which has an associated weight, w_i, and profit, p_i, the knapsack problem determines which profit-maximizing subset of items to pack into a knapsack such that the total weight is less than a capacity c. The mathematical formulation is:","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"beginaligned\nmax  sumlimits_i in I p_i x_i \ntextst   sumlimits_i in I w_i x_i le c\n x_i in 0 1  forall i in I\nendaligned","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"where x_i is 1 if we pack item i into the knapsack and 0 otherwise.","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"For this tutorial, we extend the single-objective knapsack problem by adding another objective: given a desirability rating, r_i, we wish to maximize the total desirability of the items in our knapsack. Thus, our mathematical formulation is now:","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"beginaligned\nmax  sumlimits_i in I p_i x_i \n      sumlimits_i in I r_i x_i \ntextst   sumlimits_i in I w_i x_i le c\n x_i in 0 1  forall i in I\nendaligned","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/#Data","page":"Multi-objective knapsack","title":"Data","text":"","category":"section"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"The data for this example was taken from vOptGeneric, and the original author was @xgandibleux.","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"profit = [77, 94, 71, 63, 96, 82, 85, 75, 72, 91, 99, 63, 84, 87, 79, 94, 90]\ndesire = [65, 90, 90, 77, 95, 84, 70, 94, 66, 92, 74, 97, 60, 60, 65, 97, 93]\nweight = [80, 87, 68, 72, 66, 77, 99, 85, 70, 93, 98, 72, 100, 89, 67, 86, 91]\ncapacity = 900\nN = length(profit)","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"Comparing the capacity to the total weight of all the items:","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"capacity / sum(weight)","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"shows that we can take approximately 64% of the items.","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"Plotting the items, we see that there are a range of items with different profits and desirability. Some items have a high profit and a high desirability, others have a low profit and a high desirability (and vice versa).","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"Plots.scatter(\n    profit,\n    desire;\n    xlabel = \"Profit\",\n    ylabel = \"Desire\",\n    legend = false,\n)","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"The goal of the bi-objective knapsack problem is to choose a subset which maximizes both objectives.","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/#JuMP-formulation","page":"Multi-objective knapsack","title":"JuMP formulation","text":"","category":"section"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"Our JuMP formulation is a direct translation of the mathematical formulation:","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"model = Model()\n@variable(model, x[1:N], Bin)\n@constraint(model, sum(weight[i] * x[i] for i in 1:N) <= capacity)\n@expression(model, profit_expr, sum(profit[i] * x[i] for i in 1:N))\n@expression(model, desire_expr, sum(desire[i] * x[i] for i in 1:N))\n@objective(model, Max, [profit_expr, desire_expr])","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"Note how we form a multi-objective program by passing a vector of scalar objective functions.","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/#Solution","page":"Multi-objective knapsack","title":"Solution","text":"","category":"section"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"To solve our model, we need an optimizer which supports multi-objective linear programs. One option is to use the MultiObjectiveAlgorithms.jl package.","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"set_optimizer(model, () -> MOA.Optimizer(HiGHS.Optimizer))\nset_silent(model)","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"MultiObjectiveAlgorithms.jl supports many different algorithms for solving multiobjective optimization problems. One option is the epsilon-constraint method:","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"set_attribute(model, MOA.Algorithm(), MOA.EpsilonConstraint())","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"Let's solve the problem and see the solution","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"optimize!(model)\n@assert termination_status(model) == OPTIMAL\nsolution_summary(model)","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"There are 9 solutions available. We can also use result_count to see how many solutions are available:","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"result_count(model)","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/#Accessing-multiple-solutions","page":"Multi-objective knapsack","title":"Accessing multiple solutions","text":"","category":"section"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"Access the nine different solutions in the model using the result keyword to solution_summary, value, and objective_value:","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"solution_summary(model; result = 5)","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"@assert primal_status(model; result = 5) == FEASIBLE_POINT","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"@assert is_solved_and_feasible(model; result = 5)","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"objective_value(model; result = 5)","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"Note that because we set a vector of two objective functions, the objective value is a vector with two elements. We can also query the value of each objective separately:","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"value(profit_expr; result = 5)","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/#Visualizing-objective-space","page":"Multi-objective knapsack","title":"Visualizing objective space","text":"","category":"section"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"Unlike single-objective optimization problems, multi-objective optimization problems do not have a single optimal solution. Instead, the solutions returned represent possible trade-offs that the decision maker can choose between the two objectives. A common way to visualize this is by plotting the objective values of each of the solutions:","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"plot = Plots.scatter(\n    [value(profit_expr; result = i) for i in 1:result_count(model)],\n    [value(desire_expr; result = i) for i in 1:result_count(model)];\n    xlabel = \"Profit\",\n    ylabel = \"Desire\",\n    title = \"Objective space\",\n    label = \"\",\n    xlims = (915, 960),\n)\nfor i in 1:result_count(model)\n    y = objective_value(model; result = i)\n    Plots.annotate!(y[1] - 1, y[2], (i, 10))\nend\nideal_point = objective_bound(model)\nPlots.scatter!([ideal_point[1]], [ideal_point[2]]; label = \"Ideal point\")","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"Visualizing the objective space lets the decision maker choose a solution that suits their personal preferences. For example, result #7 is close to the maximum value of profit, but offers significantly higher desirability compared with solutions #8 and #9.","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"The set of items that are chosen in solution #7 are:","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"items_chosen = [i for i in 1:N if value(x[i]; result = 7) > 0.9]","category":"page"},{"location":"tutorials/linear/multi_objective_knapsack/#Next-steps","page":"Multi-objective knapsack","title":"Next steps","text":"","category":"section"},{"location":"tutorials/linear/multi_objective_knapsack/","page":"Multi-objective knapsack","title":"Multi-objective knapsack","text":"MultiObjectiveAlgorithms.jl implements a number of different algorithms. Try solving the same problem using MOA.Dichotomy(). Does it find the same solution?","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"EditURL = \"https://github.com/chkwon/PATHSolver.jl/blob/v1.7.5/README.md\"","category":"page"},{"location":"packages/PATHSolver/#PATHSolver.jl","page":"chkwon/PATHSolver.jl","title":"PATHSolver.jl","text":"","category":"section"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"PATHSolver.jl is a wrapper for the PATH solver.","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"The wrapper has two components:","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"a thin wrapper around the C API\nan interface to MathOptInterface","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"You can solve any complementarity problem using the wrapper around the C API, although you must manually provide the callback functions, including the Jacobian.","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"The MathOptInterface wrapper is more limited, supporting only linear complementarity problems, but it enables PATHSolver to be used with JuMP.","category":"page"},{"location":"packages/PATHSolver/#Affiliation","page":"chkwon/PATHSolver.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"This wrapper is maintained by the JuMP community and is not an official wrapper of PATH. However, we are in close contact with the PATH developers, and they have given us permission to re-distribute the PATH binaries for automatic installation.","category":"page"},{"location":"packages/PATHSolver/#License","page":"chkwon/PATHSolver.jl","title":"License","text":"","category":"section"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"PATHSolver.jl is licensed under the MIT License.","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"The underlying solver, path is closed source and requires a license.","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"Without a license, the PATH Solver can solve problem instances up to with up to 300 variables and 2000 non-zeros. For larger problems, this web page provides a temporary license that is valid for a year.","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"You can either store the license in the PATH_LICENSE_STRING environment variable, or you can use the PATHSolver.c_api_License_SetString function immediately after importing the PATHSolver package:","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"import PATHSolver\nPATHSolver.c_api_License_SetString(\"<LICENSE STRING>\")","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"where <LICENSE STRING> is replaced by the current license string.","category":"page"},{"location":"packages/PATHSolver/#Installation","page":"chkwon/PATHSolver.jl","title":"Installation","text":"","category":"section"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"Install PATHSolver.jl as follows:","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"import Pkg\nPkg.add(\"PATHSolver\")","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"By default, PATHSolver.jl will download a copy of the underlying PATH solver. To use a different version of PATH, see the Manual Installation section below.","category":"page"},{"location":"packages/PATHSolver/#Use-with-JuMP","page":"chkwon/PATHSolver.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"julia> using JuMP, PATHSolver\n\njulia> M = [\n           0  0 -1 -1\n           0  0  1 -2\n           1 -1  2 -2\n           1  2 -2  4\n       ]\n4×4 Array{Int64,2}:\n 0   0  -1  -1\n 0   0   1  -2\n 1  -1   2  -2\n 1   2  -2   4\n\njulia> q = [2, 2, -2, -6]\n4-element Array{Int64,1}:\n  2\n  2\n -2\n -6\n\njulia> model = Model(PATHSolver.Optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: Path 5.0.00\n\njulia> set_optimizer_attribute(model, \"output\", \"no\")\n\njulia> @variable(model, x[1:4] >= 0)\n4-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n x[4]\n\njulia> @constraint(model, M * x .+ q ⟂ x)\n[-x[3] - x[4] + 2, x[3] - 2 x[4] + 2, x[1] - x[2] + 2 x[3] - 2 x[4] - 2, x[1] + 2 x[2] - 2 x[3] + 4 x[4] - 6, x[1], x[2], x[3], x[4]] ∈ MOI.Complements(4)\n\njulia> optimize!(model)\nReading options file /var/folders/bg/dzq_hhvx1dxgy6gb5510pxj80000gn/T/tmpiSsCRO\nRead of options file complete.\n\nPath 5.0.00 (Mon Aug 19 10:57:18 2019)\nWritten by Todd Munson, Steven Dirkse, Youngdae Kim, and Michael Ferris\n\njulia> value.(x)\n4-element Array{Float64,1}:\n 2.8\n 0.0\n 0.7999999999999998\n 1.2\n\njulia> termination_status(model)\nLOCALLY_SOLVED::TerminationStatusCode = 4","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"Note that options are set using JuMP.set_optimizer_attribute.","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"The list of options supported by PATH can be found here: https://pages.cs.wisc.edu/~ferris/path/options.pdf","category":"page"},{"location":"packages/PATHSolver/#MathOptInterface-API","page":"chkwon/PATHSolver.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"The Path 5.0.03 optimizer supports the following constraints and attributes.","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"MOI.Reals","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"MOI.VariableIndex in MOI.EqualTo{Float64}\nMOI.VariableIndex in MOI.GreaterThan{Float64}\nMOI.VariableIndex in MOI.Interval{Float64}\nMOI.VariableIndex in MOI.LessThan{Float64}\nMOI.VectorOfVariables in MOI.Complements\nMOI.VectorAffineFunction{Float64} in MOI.Complements\nMOI.VectorQuadraticFunction{Float64} in MOI.Complements\nMOI.VectorNonlinearFunction in MOI.Complements","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"MOI.Name()","category":"page"},{"location":"packages/PATHSolver/#Use-with-the-C-API","page":"chkwon/PATHSolver.jl","title":"Use with the C API","text":"","category":"section"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"PATHSolver.jl wraps the PATH C API using PATHSolver.c_api_XXX for the C method XXX. However, using the C API directly from Julia can be challenging, particularly with respect to avoiding issues with Julia's garbage collector.","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"Instead, we recommend that you use the PATHSolver.solve_mcp function, which wrappers the C API into a single call. See the docstring of PATHSolver.solve_mcp for a detailed description of the arguments.","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"Here is the same example using PATHSolver.solve_mcp. Note that you must manually construct the sparse Jacobian callback.","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"julia> import PATHSolver\n\njulia> M = [\n           0  0 -1 -1\n           0  0  1 -2\n           1 -1  2 -2\n           1  2 -2  4\n       ]\n4×4 Matrix{Int64}:\n 0   0  -1  -1\n 0   0   1  -2\n 1  -1   2  -2\n 1   2  -2   4\n\njulia> q = [2, 2, -2, -6]\n4-element Vector{Int64}:\n  2\n  2\n -2\n -6\n\njulia> function F(n::Cint, x::Vector{Cdouble}, f::Vector{Cdouble})\n           @assert n == length(x) == length(f)\n           f .= M * x .+ q\n           return Cint(0)\n       end\nF (generic function with 1 method)\n\njulia> function J(\n           n::Cint,\n           nnz::Cint,\n           x::Vector{Cdouble},\n           col::Vector{Cint},\n           len::Vector{Cint},\n           row::Vector{Cint},\n           data::Vector{Cdouble},\n       )\n           @assert n == length(x) == length(col) == length(len) == 4\n           @assert nnz == length(row) == length(data)\n           i = 1\n           for c in 1:n\n               col[c], len[c] = i, 0\n               for r in 1:n\n                   if !iszero(M[r, c])\n                       row[i], data[i] = r, M[r, c]\n                       len[c] += 1\n                       i += 1\n                   end\n               end\n           end\n           return Cint(0)\n       end\nJ (generic function with 1 method)\n\njulia> status, z, info = PATHSolver.solve_mcp(\n           F,\n           J,\n           fill(0.0, 4),  # Lower bounds\n           fill(Inf, 4),  # Upper bounds\n           fill(0.0, 4);  # Starting point\n           nnz = 12,      # Number of nonzeros in the Jacobian\n           output = \"yes\",\n       )\nReading options file /var/folders/bg/dzq_hhvx1dxgy6gb5510pxj80000gn/T/jl_iftYBS\n > output yes\nRead of options file complete.\n\nPath 5.0.03 (Fri Jun 26 09:58:07 2020)\nWritten by Todd Munson, Steven Dirkse, Youngdae Kim, and Michael Ferris\n\nCrash Log\nmajor  func  diff  size  residual    step       prox   (label)\n    0     0             1.2649e+01             0.0e+00 (f[    4])\n    1     2     4     2 1.0535e+01  8.0e-01    0.0e+00 (f[    1])\n    2     3     2     4 8.4815e-01  1.0e+00    0.0e+00 (f[    4])\n    3     4     0     3 4.4409e-16  1.0e+00    0.0e+00 (f[    3])\npn_search terminated: no basis change.\n\nMajor Iteration Log\nmajor minor  func  grad  residual    step  type prox    inorm  (label)\n    0     0     5     4 4.4409e-16           I 0.0e+00 4.4e-16 (f[    3])\n\nMajor Iterations. . . . 0\nMinor Iterations. . . . 0\nRestarts. . . . . . . . 0\nCrash Iterations. . . . 3\nGradient Steps. . . . . 0\nFunction Evaluations. . 5\nGradient Evaluations. . 4\nBasis Time. . . . . . . 0.000016\nTotal Time. . . . . . . 0.044383\nResidual. . . . . . . . 4.440892e-16\n(PATHSolver.MCP_Solved, [2.8, 0.0, 0.8, 1.2], PATHSolver.Information(4.4408920985006247e-16, 0.0, 0.0, 0.044383, 1.6e-5, 0.0, 0, 0, 3, 5, 4, 0, 0, 0, 0, false, false, false, true, false, false, false))\n\njulia> status\nMCP_Solved::MCP_Termination = 1\n\njulia> z\n4-element Vector{Float64}:\n 2.8\n 0.0\n 0.8\n 1.2","category":"page"},{"location":"packages/PATHSolver/#Thread-safety","page":"chkwon/PATHSolver.jl","title":"Thread safety","text":"","category":"section"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"PATH is not thread-safe and there are no known work-arounds. Do not run it in parallel using Threads.@threads. See issue #62 for more details.","category":"page"},{"location":"packages/PATHSolver/#Factorization-methods","page":"chkwon/PATHSolver.jl","title":"Factorization methods","text":"","category":"section"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"By default, PATHSolver.jl will download the LUSOL shared library. To use LUSOL, set the following options:","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"model = Model(PATHSolver.Optimizer)\nset_optimizer_attribute(model, \"factorization_method\", \"blu_lusol\")\nset_optimizer_attribute(model, \"factorization_library_name\", PATHSolver.LUSOL_LIBRARY_PATH)","category":"page"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"To use factorization_method umfpack you will need the umfpack shared library that is available directly from the developers of that code for academic use.","category":"page"},{"location":"packages/PATHSolver/#Manual-installation","page":"chkwon/PATHSolver.jl","title":"Manual installation","text":"","category":"section"},{"location":"packages/PATHSolver/","page":"chkwon/PATHSolver.jl","title":"chkwon/PATHSolver.jl","text":"By default PATHSolver.jl will download a copy of the libpath library. If you already have one installed and want to use that, set the PATH_JL_LOCATION environment variable to point to the libpath50.xx library.","category":"page"},{"location":"tutorials/linear/multi_objective_examples/","page":"Simple multi-objective examples","title":"Simple multi-objective examples","text":"EditURL = \"multi_objective_examples.jl\"","category":"page"},{"location":"tutorials/linear/multi_objective_examples/#Simple-multi-objective-examples","page":"Simple multi-objective examples","title":"Simple multi-objective examples","text":"","category":"section"},{"location":"tutorials/linear/multi_objective_examples/","page":"Simple multi-objective examples","title":"Simple multi-objective examples","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/multi_objective_examples/","page":"Simple multi-objective examples","title":"Simple multi-objective examples","text":"This tutorial contains a number of examples of multi-objective programs from the literature.","category":"page"},{"location":"tutorials/linear/multi_objective_examples/#Required-packages","page":"Simple multi-objective examples","title":"Required packages","text":"","category":"section"},{"location":"tutorials/linear/multi_objective_examples/","page":"Simple multi-objective examples","title":"Simple multi-objective examples","text":"This tutorial requires the following packages:","category":"page"},{"location":"tutorials/linear/multi_objective_examples/","page":"Simple multi-objective examples","title":"Simple multi-objective examples","text":"using JuMP\nimport HiGHS\nimport MultiObjectiveAlgorithms as MOA","category":"page"},{"location":"tutorials/linear/multi_objective_examples/#Bi-objective-linear-problem","page":"Simple multi-objective examples","title":"Bi-objective linear problem","text":"","category":"section"},{"location":"tutorials/linear/multi_objective_examples/","page":"Simple multi-objective examples","title":"Simple multi-objective examples","text":"This example is taken from Example 6.3 (from Steuer, 1985), page 154 of Ehrgott, M. (2005). Multicriteria Optimization. Springer, Berlin. The code was adapted from an example in vOptGeneric by @xgandibleux.","category":"page"},{"location":"tutorials/linear/multi_objective_examples/","page":"Simple multi-objective examples","title":"Simple multi-objective examples","text":"model = Model()\nset_silent(model)\n@variable(model, x1 >= 0)\n@variable(model, 0 <= x2 <= 3)\n@objective(model, Min, [3x1 + x2, -x1 - 2x2])\n@constraint(model, 3x1 - x2 <= 6)\nset_optimizer(model, () -> MOA.Optimizer(HiGHS.Optimizer))\nset_attribute(model, MOA.Algorithm(), MOA.Lexicographic())\noptimize!(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/linear/multi_objective_examples/","page":"Simple multi-objective examples","title":"Simple multi-objective examples","text":"for i in 1:result_count(model)\n    @assert is_solved_and_feasible(model; result = i)\n    print(i, \": z = \", round.(Int, objective_value(model; result = i)), \" | \")\n    println(\"x = \", value.([x1, x2]; result = i))\nend","category":"page"},{"location":"tutorials/linear/multi_objective_examples/#Bi-objective-linear-assignment-problem","page":"Simple multi-objective examples","title":"Bi-objective linear assignment problem","text":"","category":"section"},{"location":"tutorials/linear/multi_objective_examples/","page":"Simple multi-objective examples","title":"Simple multi-objective examples","text":"This example is taken from Example 9.38 (from Ulungu and Teghem, 1994), page 255 of Ehrgott, M. (2005). Multicriteria Optimization. Springer, Berlin. The code was adapted from an example in vOptGeneric by @xgandibleux.","category":"page"},{"location":"tutorials/linear/multi_objective_examples/","page":"Simple multi-objective examples","title":"Simple multi-objective examples","text":"C1 = [5 1 4 7; 6 2 2 6; 2 8 4 4; 3 5 7 1]\nC2 = [3 6 4 2; 1 3 8 3; 5 2 2 3; 4 2 3 5]\nn = size(C2, 1)\nmodel = Model()\nset_silent(model)\n@variable(model, x[1:n, 1:n], Bin)\n@objective(model, Min, [sum(C1 .* x), sum(C2 .* x)])\n@constraint(model, [i = 1:n], sum(x[i, :]) == 1)\n@constraint(model, [j = 1:n], sum(x[:, j]) == 1)\nset_optimizer(model, () -> MOA.Optimizer(HiGHS.Optimizer))\nset_attribute(model, MOA.Algorithm(), MOA.EpsilonConstraint())\noptimize!(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/linear/multi_objective_examples/","page":"Simple multi-objective examples","title":"Simple multi-objective examples","text":"for i in 1:result_count(model)\n    @assert is_solved_and_feasible(model; result = i)\n    print(i, \": z = \", round.(Int, objective_value(model; result = i)), \" | \")\n    println(\"x = \", round.(Int, value.(x; result = i)))\nend","category":"page"},{"location":"tutorials/linear/multi_objective_examples/#Bi-objective-shortest-path-problem","page":"Simple multi-objective examples","title":"Bi-objective shortest path problem","text":"","category":"section"},{"location":"tutorials/linear/multi_objective_examples/","page":"Simple multi-objective examples","title":"Simple multi-objective examples","text":"This example is taken from Exercise 9.5 page 269 of Ehrgott, M. (2005). Multicriteria Optimization. Springer, Berlin. The code was adapted from an example in vOptGeneric by @xgandibleux.","category":"page"},{"location":"tutorials/linear/multi_objective_examples/","page":"Simple multi-objective examples","title":"Simple multi-objective examples","text":"M = 50\nC1 = [\n    M 4 5 M M M\n    M M 2 1 2 7\n    M M M 5 2 M\n    M M 5 M M 3\n    M M M M M 4\n    M M M M M M\n]\nC2 = [\n    M 3 1 M M M\n    M M 1 4 2 2\n    M M M 1 7 M\n    M M 1 M M 2\n    M M M M M 2\n    M M M M M M\n]\nn = size(C2, 1)\nmodel = Model()\nset_silent(model)\n@variable(model, x[1:n, 1:n], Bin)\n@objective(model, Min, [sum(C1 .* x), sum(C2 .* x)])\n@constraint(model, sum(x[1, :]) == 1)\n@constraint(model, sum(x[:, n]) == 1)\n@constraint(model, [i = 2:n-1], sum(x[i, :]) - sum(x[:, i]) == 0)\nset_optimizer(model, () -> MOA.Optimizer(HiGHS.Optimizer))\nset_attribute(model, MOA.Algorithm(), MOA.EpsilonConstraint())\noptimize!(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/linear/multi_objective_examples/","page":"Simple multi-objective examples","title":"Simple multi-objective examples","text":"for i in 1:result_count(model)\n    @assert is_solved_and_feasible(model; result = i)\n    print(i, \": z = \", round.(Int, objective_value(model; result = i)), \" | \")\n    X = round.(Int, value.(x; result = i))\n    print(\"Path:\")\n    for ind in findall(val -> val ≈ 1, X)\n        i, j = ind.I\n        print(\" $i->$j\")\n    end\n    println()\nend","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"EditURL = \"network_flows.jl\"","category":"page"},{"location":"tutorials/linear/network_flows/#Network-flow-problems","page":"Network flow problems","title":"Network flow problems","text":"","category":"section"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"This tutorial was originally contributed by Arpit Bhatia.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"In graph theory, a flow network (also known as a transportation network) is a directed graph where each edge has a capacity and each edge receives a flow. The amount of flow on an edge cannot exceed the capacity of the edge.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"Often in operations research, a directed graph is called a network, the vertices are called nodes and the edges are called arcs.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"A flow must satisfy the restriction that the amount of flow into a node equals the amount of flow out of it,  unless it is a source, which has only outgoing flow, or sink, which has only incoming flow.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"A network can be used to model traffic in a computer network, circulation with demands, fluids in pipes,  currents in an electrical circuit, or anything similar in which something travels through a network of nodes.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"This tutorial requires the following packages:","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"using JuMP\nimport HiGHS","category":"page"},{"location":"tutorials/linear/network_flows/#The-shortest-path-problem","page":"Network flow problems","title":"The shortest path problem","text":"","category":"section"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"Suppose that each arc (i j) of a graph is assigned a scalar cost a_ij, and suppose that we define the cost of a forward path to be the sum of the costs of its arcs.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"Given a pair of nodes, the shortest path problem is to find a forward path that connects these nodes and has minimum cost.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"beginaligned\nmin  sum_forall e(ij) in E a_ij times x_ij \nst  sum_j x_ij - sum_k x_ki = b_i  forall i\n x_e in 01  forall e in E\nendaligned","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"where b_i is 1 if i is the starting node, -1 if i is the ending node, and 0 otherwise.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"G = [\n    0 100 30 0 0\n    0 0 20 0 0\n    0 0 0 10 60\n    0 15 0 0 50\n    0 0 0 0 0\n]\nn = size(G)[1]\nb = [1, -1, 0, 0, 0]\nshortest_path = Model(HiGHS.Optimizer)\nset_silent(shortest_path)\n@variable(shortest_path, x[1:n, 1:n], Bin)\n# Arcs with zero cost are not a part of the path as they do no exist\n@constraint(shortest_path, [i = 1:n, j = 1:n; G[i, j] == 0], x[i, j] == 0)\n# Flow conservation constraint\n@constraint(shortest_path, [i = 1:n], sum(x[i, :]) - sum(x[:, i]) == b[i],)\n@objective(shortest_path, Min, sum(G .* x))\noptimize!(shortest_path)\n@assert is_solved_and_feasible(shortest_path)\nobjective_value(shortest_path)","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"value.(x)","category":"page"},{"location":"tutorials/linear/network_flows/#The-assignment-problem","page":"Network flow problems","title":"The assignment problem","text":"","category":"section"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"Suppose that there are n persons and n objects that we have to match on a one-to-one basis. There is a benefit or value a_ij for matching person i with object j, and we want to assign persons to objects so as to maximize the total benefit.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"There is also a restriction that person i can be assigned to object j only if (i j) belongs to a given set of pairs A.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"Mathematically, we want to find a set of person-object pairs (1 j_1) (n j_n) from A such that the objects j_1j_n are all distinct, and the total benefit sum_i=1^y a_ij_i is maximized.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"beginaligned\nmax  sum_(ij) in A a_ij times y_ij \nst  sum_j(ij) in A y_ij = 1  forall i = 12n \n sum_i(ij) in A y_ij = 1  forall j = 12n \n y_ij in 01  forall (ij) in 12k\nendaligned","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"G = [\n    6 4 5 0\n    0 3 6 0\n    5 0 4 3\n    7 5 5 5\n]\nn = size(G)[1]\nassignment = Model(HiGHS.Optimizer)\nset_silent(assignment)\n@variable(assignment, y[1:n, 1:n], Bin)\n# One person can only be assigned to one object\n@constraint(assignment, [i = 1:n], sum(y[:, i]) == 1)\n# One object can only be assigned to one person\n@constraint(assignment, [j = 1:n], sum(y[j, :]) == 1)\n@objective(assignment, Max, sum(G .* y))\noptimize!(assignment)\n@assert is_solved_and_feasible(assignment)\nobjective_value(assignment)","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"value.(y)","category":"page"},{"location":"tutorials/linear/network_flows/#The-max-flow-problem","page":"Network flow problems","title":"The max-flow problem","text":"","category":"section"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"In the max-flow problem, we have a graph with two special nodes: the source, denoted by s, and the sink, denoted by t.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"The objective is to move as much flow as possible from s into t while observing the capacity constraints.","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"beginaligned\nmax  sum_v(sv) in E f(sv) \nst  sum_u(uv) in E f(uv)  = sum_w(vw) in E f(vw)  forall v in V - st \n f(uv) leq c(uv)  forall (uv) in E \n f(uv) geq 0  forall (uv) in E\nendaligned","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"G = [\n    0 3 2 2 0 0 0 0\n    0 0 0 0 5 1 0 0\n    0 0 0 0 1 3 1 0\n    0 0 0 0 0 1 0 0\n    0 0 0 0 0 0 0 4\n    0 0 0 0 0 0 0 2\n    0 0 0 0 0 0 0 4\n    0 0 0 0 0 0 0 0\n]\nn = size(G)[1]\nmax_flow = Model(HiGHS.Optimizer)\n@variable(max_flow, f[1:n, 1:n] >= 0)\n# Capacity constraints\n@constraint(max_flow, [i = 1:n, j = 1:n], f[i, j] <= G[i, j])\n# Flow conservation constraints\n@constraint(max_flow, [i = 1:n; i != 1 && i != 8], sum(f[i, :]) == sum(f[:, i]))\n@objective(max_flow, Max, sum(f[1, :]))\noptimize!(max_flow)\n@assert is_solved_and_feasible(max_flow)\nobjective_value(max_flow)","category":"page"},{"location":"tutorials/linear/network_flows/","page":"Network flow problems","title":"Network flow problems","text":"value.(f)","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"EditURL = \"basis.jl\"","category":"page"},{"location":"tutorials/linear/basis/#Basis-matrices","page":"Basis matrices","title":"Basis matrices","text":"","category":"section"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"This tutorial explains how to query the basis of a linear program.","category":"page"},{"location":"tutorials/linear/basis/#Setup","page":"Basis matrices","title":"Setup","text":"","category":"section"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"using JuMP\nimport HiGHS","category":"page"},{"location":"tutorials/linear/basis/#Standard-form-example","page":"Basis matrices","title":"Standard form example","text":"","category":"section"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"Consider the following example, which is from the Wikipedia article on Basic feasible solutions:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"beginaligned\nmax       0 \ntextst  1x_1 + 5x_2 + 3x_3 + 4x_4 + 6x_5 = 14 \n             0x_1 + 1x_2 + 3x_3 + 5x_4 + 6x_5 = 7 \n             x_i ge 0 forall i = 1ldots5\nendaligned","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"The A matrix is:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"A = [1 5 3 4 6; 0 1 3 5 6]","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"and the right-hand side b vector is:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"b = [14, 7]","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"We can create and optimize the problem in the standard form:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"n = size(A, 2)\nmodel = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, x[1:n] >= 0)\n@constraint(model, A * x == b)\noptimize!(model)\n@assert is_solved_and_feasible(model)","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"This has a solution:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"value.(x)","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"Query the basis status of a variable using MOI.VariableBasisStatus:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"get_attribute(x[1], MOI.VariableBasisStatus())","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"the result is a MOI.BasisStatusCode. Query all of the basis statuses with the broadcast get_attribute.(:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"get_attribute.(x, MOI.VariableBasisStatus())","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"For this problem, the values are either MOI.NONBASIC_AT_LOWER or MOI.BASIC. All of the MOI.NONBASIC_AT_LOWER variables have a value at their lower bound. The MOI.BASIC variables correspond to the columns of the optimal basis.","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"Get the columns using:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"indices = get_attribute.(x, MOI.VariableBasisStatus()) .== MOI.BASIC","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"Filter the basis matrix from A:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"B = A[:, indices]","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"Since the basis matrix is non-singular, solving the system Bx = b must yield the optimal primal solution of the basic variables:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"B \\ b","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"value.(x[indices])","category":"page"},{"location":"tutorials/linear/basis/#A-more-complicated-example","page":"Basis matrices","title":"A more complicated example","text":"","category":"section"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"Often, you may want to work with the basis of a model that is not in a nice standard form. For example:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, x >= 0)\n@variable(model, 0 <= y <= 3)\n@variable(model, z <= 1)\n@objective(model, Min, 12x + 20y - z)\n@constraint(model, c1, 6x + 8y >= 100)\n@constraint(model, c2, 7x + 12y >= 120)\n@constraint(model, c3, x + y <= 20)\noptimize!(model)\n@assert is_solved_and_feasible(model)","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"A common way to query the basis status of every variable is:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"v_basis = Dict(\n    xi => get_attribute(xi, MOI.VariableBasisStatus()) for\n    xi in all_variables(model)\n)","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"Despite the model having three constraints, there are only two basic variables. Since the basis matrix must be square, where is the other basic variable?","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"The answer is that solvers will reformulate inequality constraints:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"A x le b","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"into the system:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"A x + Is = b","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"Thus, for every inequality constraint there is a slack variable s.","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"Query the basis status of the slack variables associated with a constraint using MOI.ConstraintBasisStatus:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"c_basis = Dict(\n    ci => get_attribute(ci, MOI.ConstraintBasisStatus()) for ci in\n    all_constraints(model; include_variable_in_set_constraints = false)\n)","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"Thus, the basis is formed by x, y, and the slack associated with c3.","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"A simple way to get the A matrix of an unstructured linear program is with lp_matrix_data:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"matrix = lp_matrix_data(model)\nmatrix.A","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"You can check the permutation of the rows and columns using","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"matrix.variables","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"and","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"matrix.affine_constraints","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"We can construct the slack column associated with c3 as:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"s_column = zeros(size(matrix.A, 1))\ns_column[3] = 1.0","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"The full basis matrix is therefore:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"B = hcat(matrix.A[:, [1, 2]], s_column)","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"lp_matrix_data returns separate vectors for the lower and upper row bounds. Convert to a single right-hand side vector by taking the finite elements:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"b = ifelse.(isfinite.(matrix.b_lower), matrix.b_lower, matrix.b_upper)","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"Solving the Basis system as before yields:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"B \\ b","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"which is the value of x, y, and the slack associated with c3.","category":"page"},{"location":"tutorials/linear/basis/#Identifying-degenerate-variables","page":"Basis matrices","title":"Identifying degenerate variables","text":"","category":"section"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"Another common task is identifying degenerate variables. A degenerate variable is a basic variable that has an optimal value at its lower or upper bound.","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"Here is a function that computes whether a variable is degenerate:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"function is_degenerate(x)\n    if get_attribute(x, MOI.VariableBasisStatus()) == MOI.BASIC\n        return (has_lower_bound(x) && ≈(value(x), lower_bound(x))) ||\n               (has_upper_bound(x) && ≈(value(x), upper_bound(x)))\n    end\n    return false\nend","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"A simple example of a linear program with a degenerate solution is:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"A, b, c = [1 1; 0 1], [1, 1], [1, 1]\nmodel = Model(HiGHS.Optimizer);\nset_silent(model)\n@variable(model, x[1:2] >= 0)\n@objective(model, Min, c' * x)\n@constraint(model, A * x == b)\noptimize!(model)\ndegenerate_variables = filter(is_degenerate, all_variables(model))","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"The solution is degenerate because:","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"value(x[1])","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"and","category":"page"},{"location":"tutorials/linear/basis/","page":"Basis matrices","title":"Basis matrices","text":"get_attribute(x[1], MOI.VariableBasisStatus())","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"EditURL = \"optimal_power_flow.jl\"","category":"page"},{"location":"tutorials/applications/optimal_power_flow/#Optimal-power-flow","page":"Optimal power flow","title":"Optimal power flow","text":"","category":"section"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"This tutorial was originally contributed by James Foster (@jd-foster).","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"This tutorial formulates and solves an alternating current optimal power flow (AC-OPF) problem, a much-studied nonlinear problem from the field of electrical engineering.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Once we've formulated and solved the nonlinear problem, we will turn our focus to obtaining a good estimate of the objective value at the global optimum through the use of semidefinite programming.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"One main purpose of this tutorial is to highlight JuMP's ability to directly formulate problems involving complex-valued decision variables and complex matrix cones such as the  HermitianPSDCone object.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"For another example of modeling with complex decision variables, see the Quantum state discrimination tutorial, and see the Complex number support section of the manual for more details.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"This tutorial takes a matrix-oriented approach focused on network nodes that simplifies the construction of semidefinite programs. Another approach is to formulate the problem focusing on network lines where it is easier to work with flow constraints. A general approach is provided by the Julia/JuMP package PowerModels.jl, an open-source framework to a broad range of power flow model formulations along with utilities for working with detailed network data.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/#Required-packages","page":"Optimal power flow","title":"Required packages","text":"","category":"section"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"This tutorial requires the following packages:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"using JuMP\nimport Clarabel\nimport DataFrames\nimport Ipopt\nimport LinearAlgebra\nimport SparseArrays\nimport Test","category":"page"},{"location":"tutorials/applications/optimal_power_flow/#Initial-formulation","page":"Optimal power flow","title":"Initial formulation","text":"","category":"section"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Optimal power flow problems for electrical transmission typically pose the following question: what is the most cost-effective operation of electricity generators while meeting constraints on the safe limits of network components?","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"We'll use the 9-node network test case case9mod to explore this problem.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"The graph of the network, shown here, has three nodes (or buses) each for the different purposes of generation G (nodes 1, 2, and 3), trans-shipment (nodes 4, 6, and 8), and demand D (nodes 5, 7, and 9).","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"(Image: Nine Nodes)","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"This example is a modified version of the MATPOWER ((Zimmerman et al., 2011)) test case case9 (archive) created by (Bukhsh et al., 2013) for their test case archive of optimal power flow problems with local optima. This test case is also extensively evaluated in (Krasko and Rebennack, 2017).","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Here bus and network node are taken as analogous terms, as are branch and transmission line.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"For future reference, let's name the number of nodes in the network:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"N = 9;\nnothing #hide","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"The network data can be summarised using a small number of arrays. Using the sparsevec function from the SparseArrays standard library package, we can give the indices and values of the non-zero data points:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"# Real generation: lower (`lb`) and upper (`ub`) bounds\nP_Gen_lb = SparseArrays.sparsevec([1, 2, 3], [10, 10, 10], N)\nP_Gen_ub = SparseArrays.sparsevec([1, 2, 3], [250, 300, 270], N)\n# Reactive generation: lower (`lb`) and upper (`ub`) bounds\nQ_Gen_lb = SparseArrays.sparsevec([1, 2, 3], [-5, -5, -5], N)\nQ_Gen_ub = SparseArrays.sparsevec([1, 2, 3], [300, 300, 300], N)\n# Power demand levels (real, reactive, and complex form)\nP_Demand = SparseArrays.sparsevec([5, 7, 9], [54, 60, 75], N)\nQ_Demand = SparseArrays.sparsevec([5, 7, 9], [18, 21, 30], N)\nS_Demand = P_Demand + im * Q_Demand","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"The key decision variables are the real power injections P^G and reactive power injections Q^Gover the allowed range of the generators. All other buses must restrict their generation variables to 0. On the other hand, these non-generator nodes have a fixed  real and reactive power demand, denoted P^D and Q^D respectively (these are fixed at 0 in the case of trans-shipment and generator nodes).","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"The cost of operating each generator is modeled as a quadratic function of its real power output; in our specific test case, the objective function to minimize is:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"beginalign\n    min          011  (P^G_1)^2 +   5 P^G_1 + 150  \n               +  0085  (P^G_2)^2 + 12 P^G_2 + 600  \n               + 01225   (P^G_3)^2 +     P^G_3 + 335 \nendalign","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Let's create an initial JuMP model with some of this data:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"model = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, P_Gen_lb[i] <= P_G[i in 1:N] <= P_Gen_ub[i])\n@objective(\n    model,\n    Min,\n    (0.11 * P_G[1]^2 + 5 * P_G[1] + 150) +\n    (0.085 * P_G[2]^2 + 1.2 * P_G[2] + 600) +\n    (0.1225 * P_G[3]^2 + P_G[3] + 335),\n);\nnothing #hide","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Even before solving an optimization problem, we can estimate a lower bound on the best objective value by substituting the lower bound on each generator's real power range (all 10, as it turns out in this case):","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"basic_lower_bound = value(lower_bound, objective_function(model));\nprintln(\"Objective value (basic lower bound) : $basic_lower_bound\")","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"to see that we can do no better than an objective cost of 1188.75.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"(Direct substitution works because a quadratic function of a single variable x with positive coefficients is strictly increasing for all x geq 0.)","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"In fact, we can get a quick but even better estimate from the direct observation that the real power generated must meet or exceed the real power demand:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"@constraint(model, sum(P_G) >= sum(P_Demand))\noptimize!(model)\n@assert is_solved_and_feasible(model)\nbetter_lower_bound = round(objective_value(model); digits = 2)\nprintln(\"Objective value (better lower bound): $better_lower_bound\")","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"However, there are additional power flow constraints that must be satisfied.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Power must flow from one or more generation nodes through the transmission lines and end up at a demand node. The state variables of our steady-state alternating current (AC) electrical network are complex-valued voltage variables V_1 ldots V_N. Voltages capture both a magnitude and phase of the node's electrical state in relation to the rest of the system. An AC power system also extends the notion of resistance in wires found in a direct current (DC) circuit to a  complex quantity, known as the impedance, of each transmission line. The reciprocal of impedance is known as admittance. Together, these complex quantities are used to express a complex version of Ohm's law: current flow through a line is proportional to the difference in voltages on each end of the line, multiplied by the admittance.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/#Network-data","page":"Optimal power flow","title":"Network data","text":"","category":"section"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Let's assemble the data we need for writing the complex power flow constraints. The data for the problem consists of a list of the real and imaginary parts of the line impedance. We obtain the following data table from the branch data section of the case9mod MATPOWER format file:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"branch_data = DataFrames.DataFrame([\n    (1, 4, 0.0, 0.0576, 0.0),\n    (4, 5, 0.017, 0.092, 0.158),\n    (6, 5, 0.039, 0.17, 0.358),\n    (3, 6, 0.0, 0.0586, 0.0),\n    (6, 7, 0.0119, 0.1008, 0.209),\n    (8, 7, 0.0085, 0.072, 0.149),\n    (2, 8, 0.0, 0.0625, 0.0),\n    (8, 9, 0.032, 0.161, 0.306),\n    (4, 9, 0.01, 0.085, 0.176),\n]);\nDataFrames.rename!(branch_data, [:F_BUS, :T_BUS, :BR_R, :BR_X, :BR_Bc])","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"The first two columns describe the network, supplying the from and to connection points of the lines. The last three columns give the branch resistance, branch reactance and line-charging susceptance.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"We will also need to reference the base_MVA number (used for re-scaling):","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"base_MVA = 100;\nnothing #hide","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"and the number of lines:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"M = size(branch_data, 1)","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"From the first two columns of the branch data table, we can create a sparse incidence matrix that simplifies handling of the network layout:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"A =\n    SparseArrays.sparse(branch_data.F_BUS, 1:M, 1, N, M) +\n    SparseArrays.sparse(branch_data.T_BUS, 1:M, -1, N, M)","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"We form the network impedance vector from the next two columns","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"z = (branch_data.BR_R .+ im * branch_data.BR_X) / base_MVA;\nnothing #hide","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"and calculate it's corresponding bus admittance matrix as","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Y_0 = A * SparseArrays.spdiagm(1 ./ z) * A';\nnothing #hide","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"while the last column gives the branch line-charging susceptance","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"y_sh = 1 / 2 * (im * branch_data.BR_Bc) * base_MVA;\nnothing #hide","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"and leads to the shunt admittance matrix","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Y_sh = SparseArrays.spdiagm(\n    LinearAlgebra.diag(A * SparseArrays.spdiagm(y_sh) * A'),\n);\nnothing #hide","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"(The construction of the shunt admittance matrix Y_sh looks somewhat more complicated than Y_0 because we only want to add the diagonal elements in the calculation; the line-charging is used only in the nodal voltage terms and not the line voltage terms.)","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"The full bus admittance matrix Y is then defined as","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Y = Y_0 + Y_sh;\nnothing #hide","category":"page"},{"location":"tutorials/applications/optimal_power_flow/#JuMP-model","page":"Optimal power flow","title":"JuMP model","text":"","category":"section"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Now we're ready to write the complex power flow constraints we need to more accurately model the electricity system.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"We'll introduce a number of constraints that model both the physics and operational requirements.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Let's start by initializing a new model:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"model = Model(Ipopt.Optimizer)\nset_silent(model)","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Then we'll create the nodal power generation variables:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"@variable(\n    model,\n    S_G[i in 1:N] in ComplexPlane(),\n    lower_bound = P_Gen_lb[i] + Q_Gen_lb[i] * im,\n    upper_bound = P_Gen_ub[i] + Q_Gen_ub[i] * im,\n)","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"We need complex nodal voltages (the system state variables):","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"@variable(model, V[1:N] in ComplexPlane(), start = 1.0 + 0.0im)","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"and operational constraints for maintaining voltage magnitude levels:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"@constraint(model, [i in 1:N], 0.9^2 <= real(V[i])^2 + imag(V[i])^2 <= 1.1^2)","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"We also need to fix an origin or reference angle from which all other complex voltage angles (arguments) are determined. Here we will use node 1 as the nominated reference bus. Fixing the imaginary component of a reference bus to zero sets its complex voltage angle to 0, while constraining the real part to be non-negative disallows equivalent solutions that are just a reflection by 180 degrees:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"@constraint(model, imag(V[1]) == 0);\n@constraint(model, real(V[1]) >= 0);\nnothing #hide","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"The power flow equations express a conservation of energy (power) principle, where power generated less the power consumed must balance the power exchanged with the network:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"@constraint(model, S_G - S_Demand .== V .* conj(Y * V))","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"As above, the objective function is a quadratic cost of real power:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"P_G = real(S_G)\n@objective(\n    model,\n    Min,\n    (0.11 * P_G[1]^2 + 5 * P_G[1] + 150) +\n    (0.085 * P_G[2]^2 + 1.2 * P_G[2] + 600) +\n    (0.1225 * P_G[3]^2 + P_G[3] + 335),\n);\nnothing #hide","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"We're finally ready to solve our nonlinear AC-OPF problem:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"optimize!(model)\n@assert is_solved_and_feasible(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"objval_solution = round(objective_value(model); digits = 2)\nprintln(\"Objective value (feasible solution) : $(objval_solution)\")","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"The solution's power generation (in rectangular form) and complex voltage values (in polar form using degrees) are:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"DataFrames.DataFrame(;\n    Bus = 1:N,\n    ComplexPowerGen = round.(value.(S_G); digits = 2),\n    VoltageMagnitude = round.(abs.(value.(V)); digits = 2),\n    VoltageAngle_Deg = round.(rad2deg.(angle.(value.(V))); digits = 2),\n)","category":"page"},{"location":"tutorials/applications/optimal_power_flow/#Relaxations-and-better-objective-bounds","page":"Optimal power flow","title":"Relaxations and better objective bounds","text":"","category":"section"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"The Ipopt solver uses an interior-point algorithm. It has local optimality guarantees, but is unable to certify whether the solution is globally optimal. The solution we found is indeed globally optimal. The work to verify this has been done in (Bukhsh et al., 2013) and (Krasko and Rebennack, 2017), and different solvers (such as Gurobi, SCIP and GLOMIQO) are also able to verify this.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"The techniques of convex relaxations can also be used to improve on our current best lower bound:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"better_lower_bound","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"To this end, observe that the nonlinear constraints in the AC-OPF formulation are quadratic equalities for power flow along with quadratic voltage inequalities.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Let's linearize these constraints by first making the substitution W = V V^*, where:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"W = V V^* quad iff  quad W_ii =  V_i ^2 quad W_ik = V_i  overlineV_k quad forall i  k in  1 ldots N ","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"and where V^* is the conjugate transpose of V.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"On the face of it, this turns a quadratic voltage bound constraint like:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"v_L leq V_i ^2  leq v_U quad i  in  1 ldots N ","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"for some real v_L and v_U into a simple two-sided bound:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"v_L leq W_ii  leq v_U","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"while each quadratic expression for the nodal power term:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"    S^Node_i = V_i overline(YV)_i","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"becomes the linear combination:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"    S^Node_i = (E_ii Y^T) bullet W","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Here A bullet B = operatornametr(A^* B) is the Frobenius inner product of two complex matrices, while E_kn denotes the matrix unit with a single nonzero entry of 1 in row k and column n.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"E(k, n) = SparseArrays.sparse([k], [n], 1, N, N);\nnothing #hide","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Of course, we've shifted the nonlinearity into the equality constraint W = V V^*: it is this constraint we will now relax using a semidefinite programming approach.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"We will make use of complex voltages and relax W = V V^* to;","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"W succeq V V^*","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"where the relation succeq is the ordering in the Hermitian positive semidefinite cone.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"The above constraint is equivalent to:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"beginbmatrix 1  V^*  V  W  endbmatrix succeq 0","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"by the theory of the Schur complement. This matrix inequality implies a number of second-order cone constraints by taking certain 2 times 2 minors of the matrix for each i  in  1 ldots N :","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"beginbmatrix 1  V_i^*  V_i  W_ii  endbmatrix succeq 0","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"which is equivalent to the real second-order cone inequality:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"operatornamereal(W_ii) geq operatornamereal(V_i)^2 + operatornameimag(V_i)^2","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"We include these implied constraints as well for demonstration purposes.","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Putting it all together we get the following semidefinite relaxation of the AC-OPF problem:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"model = Model(Clarabel.Optimizer)\nset_attribute(model, \"tol_gap_rel\", 1e-3)\nset_attribute(model, \"tol_feas\", 1e-3)\nset_attribute(model, \"tol_ktratio\", 1e-3)\n@variable(\n    model,\n    S_G[i in 1:N] in ComplexPlane(),\n    lower_bound = P_Gen_lb[i] + Q_Gen_lb[i] * im,\n    upper_bound = P_Gen_ub[i] + Q_Gen_ub[i] * im,\n)\n@variable(model, W[1:N, 1:N] in HermitianPSDCone())\n@variable(model, V[1:N] in ComplexPlane(), start = 1.0 + 0.0im)\n@constraint(model, [i in 1:N], 0.9^2 <= real(W[i, i]) <= 1.1^2)\n@constraint(model, real(V[1]) >= 0)\n@constraint(model, imag(V[1]) == 0)\n@constraint(model, 0.9 <= real(V[1]) <= 1.1)\n@constraint(model, LinearAlgebra.Hermitian([1 V'; V W]) in HermitianPSDCone())\n# 2 x 2 minor inequalities:\n@constraint(\n    model,\n    [i in 1:N],\n    [0.5, real(W[i, i]), real(V[i]), imag(V[i])] in RotatedSecondOrderCone()\n)\n@constraint(\n    model,\n    [i in 1:N],\n    S_G[i] - S_Demand[i] == LinearAlgebra.tr((conj(Y) * E(i, i)) * W),\n)\nP_G = real(S_G)\n@objective(\n    model,\n    Min,\n    (0.11 * P_G[1]^2 + 5 * P_G[1] + 150) +\n    (0.085 * P_G[2]^2 + 1.2 * P_G[2] + 600) +\n    (0.1225 * P_G[3]^2 + P_G[3] + 335),\n)\noptimize!(model)","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"Test.@test is_solved_and_feasible(model; allow_almost = true)\nsdp_relaxation_lower_bound = round(objective_value(model); digits = 2)\nprintln(\n    \"Objective value (W & V relax. lower bound): $sdp_relaxation_lower_bound\",\n)","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"We can more easily see solution values by rounding out noisy data:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"W_1 = SparseArrays.sparse(round.(value.(W); digits = 2))","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"and recover an approximation to the voltage variables as:","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"DataFrames.DataFrame(;\n    Bus = 1:N,\n    Magnitude = round.(abs.(value.(V)); digits = 2),\n    AngleDeg = round.(rad2deg.(angle.(value.(V))); digits = 2),\n)","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"For further information on exploiting sparsity see (Jabr, 2012).","category":"page"},{"location":"tutorials/applications/optimal_power_flow/","page":"Optimal power flow","title":"Optimal power flow","text":"This relaxation has the advantage that we can work directly with complex voltages to extend the formulation, strengthen the relaxation and gain additional approximate information about the voltage variables.","category":"page"},{"location":"moi/submodules/Bridges/list_of_bridges/","page":"List of bridges","title":"List of bridges","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/submodules/Bridges/list_of_bridges.md\"","category":"page"},{"location":"moi/submodules/Bridges/list_of_bridges/","page":"List of bridges","title":"List of bridges","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Bridges/list_of_bridges/#List-of-bridges","page":"List of bridges","title":"List of bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/list_of_bridges/","page":"List of bridges","title":"List of bridges","text":"This section describes the Bridges.AbstractBridges that are implemented in MathOptInterface.","category":"page"},{"location":"moi/submodules/Bridges/list_of_bridges/#constraint_bridges_ref","page":"List of bridges","title":"Constraint bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/list_of_bridges/","page":"List of bridges","title":"List of bridges","text":"These bridges are subtypes of Bridges.Constraint.AbstractBridge.","category":"page"},{"location":"moi/submodules/Bridges/list_of_bridges/","page":"List of bridges","title":"List of bridges","text":"Modules = [Bridges.Constraint]\nFilter = t -> begin\n    M = MathOptInterface.Bridges.Constraint\n    return t isa Type && t != M.AbstractBridge && t <: M.AbstractBridge\nend","category":"page"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.AbstractFunctionConversionBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.AbstractFunctionConversionBridge","text":"abstract type AbstractFunctionConversionBridge{F,S} <: AbstractBridge end\n\nAbstract type to support writing bridges in which the function changes but the set does not.\n\nBy convention, the transformed function is stored in the .constraint field.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.AbstractToIntervalBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.AbstractToIntervalBridge","text":"AbstractToIntervalBridge{T<:AbstractFloat,S,F}\n\nAn abstract type that simplifies the creation of other bridges.\n\nwarning: Warning\nT must be a AbstractFloat type because otherwise typemin and typemax would either be not implemented (for example, BigInt), or would not give infinite value (for example, Int). For this reason, this bridge is only added to MOI.Bridges.full_bridge_optimizer when T is a subtype of AbstractFloat.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.AllDifferentToCountDistinctBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.AllDifferentToCountDistinctBridge","text":"AllDifferentToCountDistinctBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nAllDifferentToCountDistinctBridge implements the following reformulations:\n\nx in textsfAllDifferent(d) to (n x) in textsfCountDistinct(1+d) and n = d\nf(x) in textsfAllDifferent(d) to (d f(x)) in textsfCountDistinct(1+d)\n\nSource node\n\nAllDifferentToCountDistinctBridge supports:\n\nF in MOI.AllDifferent\n\nwhere F is MOI.VectorOfVariables or MOI.VectorAffineFunction{T}.\n\nTarget nodes\n\nAllDifferentToCountDistinctBridge creates:\n\nF in MOI.CountDistinct\nMOI.VariableIndex in MOI.EqualTo{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.BinPackingToMILPBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.BinPackingToMILPBridge","text":"BinPackingToMILPBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nBinPackingToMILPBridge implements the following reformulation:\n\nx in BinPacking(c w) into a mixed-integer linear program.\n\nReformulation\n\nThe reformulation is non-trivial, and it depends on the finite domain of each variable x_i, which we as define S_i = l_ildotsu_i.\n\nFirst, we introduce new binary variables z_ij, which are 1 if variable x_i takes the value j in the optimal solution and 0 otherwise:\n\nbeginaligned\nz_ij in 0 1                                forall i in 1ldots d j in S_i  \nx_i - sumlimits_jin S_i j cdot z_ij = 0   forall i in 1ldots d              \nsumlimits_jin S_i z_ij = 1                  forall i in 1ldots d              \nendaligned\n\nThen, we add the capacity constraint for all possible bins j:\n\nsumlimits_i w_i z_ij le c forall j in bigcup_i=1ldotsd S_i\n\nSource node\n\nBinPackingToMILPBridge supports:\n\nF in MOI.BinPacking{T}\n\nTarget nodes\n\nBinPackingToMILPBridge creates:\n\nMOI.VariableIndex in MOI.ZeroOne\nMOI.ScalarAffineFunction{T} in MOI.EqualTo{T}\nMOI.ScalarAffineFunction{T} in MOI.LessThan{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.CircuitToMILPBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.CircuitToMILPBridge","text":"CircuitToMILPBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nCircuitToMILPBridge implements the following reformulation:\n\nx in textsfCircuit(d) to the Miller-Tucker-Zemlin formulation of the Traveling Salesperson Problem.\n\nSource node\n\nCircuitToMILPBridge supports:\n\nF in MOI.Circuit\n\nwhere F is MOI.VectorOfVariables or MOI.VectorAffineFunction{T}.\n\nTarget nodes\n\nCircuitToMILPBridge creates:\n\nMOI.VariableIndex in MOI.ZeroOne\nMOI.VariableIndex in MOI.Integer\nMOI.VariableIndex in MOI.Interval{T}\nMOI.ScalarAffineFunction{T} in MOI.EqualTo{T}\nMOI.ScalarAffineFunction{T} in MOI.LessThan{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.ComplexNormInfinityToSecondOrderConeBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.ComplexNormInfinityToSecondOrderConeBridge","text":"ComplexNormInfinityToSecondOrderConeBridge{T} <: Bridges.Constraint.AbstractBridge\n\nComplexNormInfinityToSecondOrderConeBridge implements the following reformulation:\n\n(t x) in NormInfinity(1+d) into (t real(x_i) imag(x_i)) in SecondOrderCone() for all i.\n\nSource node\n\nComplexNormInfinityToSecondOrderConeBridge supports:\n\nMOI.VectorAffineFunction{Complex{T}} in MOI.NormInfinityCone\n\nTarget nodes\n\nComplexNormInfinityToSecondOrderConeBridge creates:\n\nMOI.VectorAffineFunction{T} in MOI.SecondOrderCone\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.CountAtLeastToCountBelongsBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.CountAtLeastToCountBelongsBridge","text":"CountAtLeastToCountBelongsBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nCountAtLeastToCountBelongsBridge implements the following reformulation:\n\nx in textsfCountAtLeast(n d mathcalS) to (n_i x_d_i) in textsfCountBelongs(1+d mathcalS) and n_i ge n for all i.\n\nSource node\n\nCountAtLeastToCountBelongsBridge supports:\n\nF in MOI.CountAtLeast\n\nwhere F is MOI.VectorOfVariables or MOI.VectorAffineFunction{T}.\n\nTarget nodes\n\nCountAtLeastToCountBelongsBridge creates:\n\nF in MOI.CountBelongs\nMOI.VariableIndex in MOI.GreaterThan{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.CountBelongsToMILPBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.CountBelongsToMILPBridge","text":"CountBelongsToMILPBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nCountBelongsToMILPBridge implements the following reformulation:\n\n(n x) in textsfCountBelongs(1+d mathcalS) into a mixed-integer linear program.\n\nReformulation\n\nThe reformulation is non-trivial, and it depends on the finite domain of each variable x_i, which we as define S_i = l_ildotsu_i.\n\nFirst, we introduce new binary variables z_ij, which are 1 if variable x_i takes the value j in the optimal solution and 0 otherwise:\n\nbeginaligned\nz_ij in 0 1                                forall i in 1ldots d j in S_i  \nx_i - sumlimits_jin S_i j cdot z_ij = 0   forall i in 1ldots d              \nsumlimits_jin S_i z_ij = 1                  forall i in 1ldots d              \nendaligned\n\nFinally, n is constrained to be the number of z_ij elements that are in mathcalS:\n\nn - sumlimits_iin 1ldots d j in mathcalS z_ij = 0\n\nSource node\n\nCountBelongsToMILPBridge supports:\n\nF in MOI.CountBelongs\n\nwhere F is MOI.VectorOfVariables or MOI.VectorAffineFunction{T}.\n\nTarget nodes\n\nCountBelongsToMILPBridge creates:\n\nMOI.VariableIndex in MOI.ZeroOne\nMOI.ScalarAffineFunction{T} in MOI.EqualTo{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.CountDistinctToMILPBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.CountDistinctToMILPBridge","text":"CountDistinctToMILPBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nCountDistinctToMILPBridge implements the following reformulation:\n\n(n x) in textsfCountDistinct(1+d) into a mixed-integer linear program.\n\nReformulation\n\nThe reformulation is non-trivial, and it depends on the finite domain of each variable x_i, which we as define S_i = l_ildotsu_i.\n\nFirst, we introduce new binary variables z_ij, which are 1 if variable x_i takes the value j in the optimal solution and 0 otherwise:\n\nbeginaligned\nz_ij in 0 1                                forall i in 1ldots d j in S_i  \nx_i - sumlimits_jin S_i j cdot z_ij = 0   forall i in 1ldots d              \nsumlimits_jin S_i z_ij = 1                  forall i in 1ldots d              \nendaligned\n\nThen, we introduce new binary variables y_j, which are 1 if a variable takes the value j in the optimal solution and 0 otherwise.\n\nbeginaligned\ny_j in 0 1                          forall j in bigcup_i=1ldotsd S_i \ny_j le sumlimits_i in 1ldots d j in S_i z_ij le M y_j   forall j in bigcup_i=1ldotsd S_i\nendaligned\n\nFinally, n is constrained to be the number of y_j elements that are non-zero:\n\nn - sumlimits_j in bigcup_i=1ldotsd S_i y_j = 0\n\nFormulation (special case)\n\nIn the special case that the constraint is [2, x, y] in CountDistinct(3), then the constraint is equivalent to [x, y] in AllDifferent(2), which is equivalent to x != y.\n\n(x - y = -1) vee (y - x = -1)\n\nwhich is equivalent to (for suitable M):\n\nbeginaligned\nz in 0 1 \nx - y - M * z = -1 \ny - x - M * (1 - z) = -1\nendaligned\n\nSource node\n\nCountDistinctToMILPBridge supports:\n\nF in MOI.CountDistinct\n\nwhere F is MOI.VectorOfVariables or MOI.VectorAffineFunction{T}.\n\nTarget nodes\n\nCountDistinctToMILPBridge creates:\n\nMOI.VariableIndex in MOI.ZeroOne\nMOI.ScalarAffineFunction{T} in MOI.EqualTo{T}\nMOI.ScalarAffineFunction{T} in MOI.LessThan{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.CountGreaterThanToMILPBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.CountGreaterThanToMILPBridge","text":"CountGreaterThanToMILPBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nCountGreaterThanToMILPBridge implements the following reformulation:\n\n(c y x) in CountGreaterThan() into a mixed-integer linear program.\n\nSource node\n\nCountGreaterThanToMILPBridge supports:\n\nF in MOI.CountGreaterThan\n\nTarget nodes\n\nCountGreaterThanToMILPBridge creates:\n\nMOI.VariableIndex in MOI.ZeroOne\nMOI.ScalarAffineFunction{T} in MOI.EqualTo{T}\nMOI.ScalarAffineFunction{T} in MOI.GreaterThan{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.FlipSignBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.FlipSignBridge","text":"FlipSignBridge{T,S1,S2,F,G}\n\nAn abstract type that simplifies the creation of other bridges.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.FunctionConversionBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.FunctionConversionBridge","text":"FunctionConversionBridge{T,F,G,S} <: AbstractFunctionConversionBridge{G,S}\n\nFunctionConversionBridge implements the following reformulations:\n\ng(x) in S into f(x) in S\n\nfor these pairs of functions:\n\nMOI.ScalarAffineFunctionto [MOI.ScalarQuadraticFunction`](@ref)\nMOI.ScalarQuadraticFunction  to MOI.ScalarNonlinearFunction\nMOI.VectorAffineFunction to MOI.VectorQuadraticFunction\n\nSource node\n\nFunctionConversionBridge supports:\n\nG in S\n\nTarget nodes\n\nFunctionConversionBridge creates:\n\nF in S\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.GeoMeanBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.GeoMeanBridge","text":"GeoMeanBridge{T,F,G,H} <: Bridges.Constraint.AbstractBridge\n\nGeoMeanBridge implements a reformulation from MOI.GeometricMeanCone into MOI.RotatedSecondOrderCone.\n\nThe reformulation is best described in an example.\n\nConsider the cone of dimension 4:\n\nt le sqrt3x_1 x_2 x_3\n\nThis can be rewritten as exists y ge 0 such that:\n\nbeginalign*\n  t  le y\n  y^4  le x_1 x_2 x_3 y\nendalign*\n\nNote that we need to create y and not use t^4 directly because t is not allowed to be negative.\n\nThis is equivalent to:\n\nbeginalign*\n    t  le fracy_1sqrt4\n    y_1^2  le 2y_2 y_3\n    y_2^2  le 2x_1 x_2 \n    y_3^2  le 2x_3(y_1sqrt4) \n    y      ge 0\nendalign*\n\nMore generally, you can show how the geometric mean code is recursively expanded into a set of new variables y in MOI.Nonnegatives, a set of MOI.RotatedSecondOrderCone constraints, and a MOI.LessThan constraint between t and y_1.\n\nSource node\n\nGeoMeanBridge supports:\n\nH in MOI.GeometricMeanCone\n\nTarget nodes\n\nGeoMeanBridge creates:\n\nF in MOI.LessThan{T}\nG in MOI.RotatedSecondOrderCone\nG in MOI.Nonnegatives\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.GeoMeanToPowerBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.GeoMeanToPowerBridge","text":"GeoMeanToPowerBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nGeoMeanToPowerBridge implements the following reformulation:\n\n(y x) in GeometricMeanCone(1+d) into (x_1 t y) in PowerCone(1d) and (t x_2  x_d) in GeometricMeanCone(d), which is then recursively expanded into more PowerCone constraints.\n\nSource node\n\nGeoMeanToPowerBridge supports:\n\nF in MOI.GeometricMeanCone\n\nTarget nodes\n\nGeoMeanToPowerBridge creates:\n\nF in MOI.PowerCone{T}\nMOI.VectorOfVariables in MOI.Nonnegatives\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge","text":"GeoMeantoRelEntrBridge{T,F,G,H} <: Bridges.Constraint.AbstractBridge\n\nGeoMeantoRelEntrBridge implements the following reformulation:\n\n(u w) in GeometricMeanCone into (0 w (u + y)mathbf1)in RelativeEntropyCone and y ge 0\n\nSource node\n\nGeoMeantoRelEntrBridge supports:\n\nH in MOI.GeometricMeanCone\n\nTarget nodes\n\nGeoMeantoRelEntrBridge creates:\n\nG in MOI.RelativeEntropyCone\nF in MOI.Nonnegatives\n\nDerivation\n\nThe derivation of the bridge is as follows:\n\nbeginaligned\n(u w) in GeometricMeanCone iff  u le left(prod_i=1^n w_iright)^1n \niff  0 le u + y le left(prod_i=1^n w_iright)^1n y ge 0 \niff  1 le fracleft(prod_i=1^n w_iright)^1nu + y y ge 0 \niff  1 le left(prod_i=1^n fracw_iu + yright)^1n y ge 0 \niff  0 le sum_i=1^n logleft(fracw_iu + yright) y ge 0 \niff  0 ge sum_i=1^n logleft(fracu + yw_iright) y ge 0 \niff  0 ge sum_i=1^n (u + y) logleft(fracu + yw_iright) y ge 0 \niff  (0 w (u + y)mathbf1) in RelativeEntropyCone y ge 0 \nendaligned\n\nThis derivation assumes that u + y  0, which is enforced by the relative entropy cone.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge","text":"GreaterToIntervalBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nGreaterToIntervalBridge implements the following reformulations:\n\nf(x) ge l into f(x) in l infty)\n\nSource node\n\nGreaterToIntervalBridge supports:\n\nF in MOI.GreaterThan{T}\n\nTarget nodes\n\nGreaterToIntervalBridge creates:\n\nF in MOI.Interval{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.GreaterToLessBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.GreaterToLessBridge","text":"GreaterToLessBridge{T,F,G} <: Bridges.Constraint.AbstractBridge\n\nGreaterToLessBridge implements the following reformulation:\n\nf(x) ge l into -f(x) le -l\n\nSource node\n\nGreaterToLessBridge supports:\n\nG in MOI.GreaterThan{T}\n\nTarget nodes\n\nGreaterToLessBridge creates:\n\nF in MOI.LessThan{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.HermitianToSymmetricPSDBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.HermitianToSymmetricPSDBridge","text":"HermitianToSymmetricPSDBridge{T,F,G} <: Bridges.Constraint.AbstractBridge\n\nHermitianToSymmetricPSDBridge implements the following reformulation:\n\nHermitian positive semidefinite n x n complex matrix to a symmetric positive semidefinite 2n x 2n real matrix.\n\nSee also MOI.Bridges.Variable.HermitianToSymmetricPSDBridge.\n\nSource node\n\nHermitianToSymmetricPSDBridge supports:\n\nG in MOI.HermitianPositiveSemidefiniteConeTriangle\n\nTarget node\n\nHermitianToSymmetricPSDBridge creates:\n\nF in MOI.PositiveSemidefiniteConeTriangle\n\nReformulation\n\nThe reformulation is best described by example.\n\nThe Hermitian matrix:\n\nbeginbmatrix\n  x_11             x_12 + y_12im  x_13 + y_13im\n  x_12 - y_12im  x_22             x_23 + y_23im\n  x_13 - y_13im  x_23 - y_23im  x_33\nendbmatrix\n\nis positive semidefinite if and only if the symmetric matrix:\n\nbeginbmatrix\n    x_11  x_12  x_13  0        y_12   y_13 \n            x_22  x_23  -y_12  0        y_23 \n                    x_33  -y_13  -y_23  0      \n                            x_11   x_12   x_13 \n                                     x_22   x_23 \n                                              x_33\nendbmatrix\n\nis positive semidefinite.\n\nThe bridge achieves this reformulation by constraining the above matrix to belong to the MOI.PositiveSemidefiniteConeTriangle(6).\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge","text":"IndicatorActiveOnFalseBridge{T,F,S} <: Bridges.Constraint.AbstractBridge\n\nIndicatorActiveOnFalseBridge implements the following reformulation:\n\nneg z implies f(x) in S into y implies f(x) in S, z + y = 1, and y in 0 1\n\nSource node\n\nIndicatorActiveOnFalseBridge supports:\n\nMOI.VectorAffineFunction{T} in MOI.Indicator{MOI.ACTIVATE_ON_ZERO,S}\n\nTarget nodes\n\nIndicatorActiveOnFalseBridge creates:\n\nMOI.VectorAffineFunction{T} in MOI.Indicator{MOI.ACTIVATE_ON_ONE,S}\nMOI.ScalarAffineFunction{T} in MOI.EqualTo\nMOI.VariableIndex in MOI.ZeroOne\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.IndicatorGreaterToLessThanBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.IndicatorGreaterToLessThanBridge","text":"IndicatorGreaterToLessThanBridge{T,A} <: Bridges.Constraint.AbstractBridge\n\nIndicatorGreaterToLessThanBridge implements the following reformulation:\n\nz implies f(x) ge l into z implies -f(x) le -l\n\nSource node\n\nIndicatorGreaterToLessThanBridge supports:\n\nMOI.VectorAffineFunction{T} in MOI.Indicator{A,MOI.GreaterThan{T}}\n\nTarget nodes\n\nIndicatorGreaterToLessThanBridge creates:\n\nMOI.VectorAffineFunction{T} in MOI.Indicator{A,MOI.LessThan{T}}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.IndicatorLessToGreaterThanBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.IndicatorLessToGreaterThanBridge","text":"IndicatorLessToGreaterThanBridge{T,A} <: Bridges.Constraint.AbstractBridge\n\nIndicatorLessToGreaterThanBridge implements the following reformulations:\n\nz implies f(x) le u into z implies -f(x) ge -u\n\nSource node\n\nIndicatorLessToGreaterThanBridge supports:\n\nMOI.VectorAffineFunction{T} in MOI.Indicator{A,MOI.LessThan{T}}\n\nTarget nodes\n\nIndicatorLessToGreaterThanBridge creates:\n\nMOI.VectorAffineFunction{T} in MOI.Indicator{A,MOI.GreaterThan{T}}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge","text":"IndicatorSOS1Bridge{T,S} <: Bridges.Constraint.AbstractBridge\n\nIndicatorSOS1Bridge implements the following reformulation:\n\nz implies f(x) in S into f(x) + y in S, SOS1(y z)\n\nwarning: Warning\nThis bridge assumes that the solver supports MOI.SOS1{T} constraints in which one of the variables (y) is continuous.\n\nSource node\n\nIndicatorSOS1Bridge supports:\n\nMOI.VectorAffineFunction{T} in MOI.Indicator{MOI.ACTIVATE_ON_ONE,S}\n\nTarget nodes\n\nIndicatorSOS1Bridge creates:\n\nMOI.ScalarAffineFunction{T} in S\nMOI.VectorOfVariables in MOI.SOS1{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge","text":"IndicatorSetMapBridge{T,A,S1,S2} <: Bridges.Constraint.AbstractBridge\n\nIndicatorSetMapBridge implements the following reformulations:\n\nz implies f(x) ge l into z implies -f(x) le -l\nz implies f(x) le u into z implies -f(x) ge -u\n\nSource node\n\nIndicatorSetMapBridge supports:\n\nMOI.VectorAffineFunction{T} in MOI.Indicator{A,S1}\n\nTarget nodes\n\nIndicatorSetMapBridge creates:\n\nMOI.VectorAffineFunction{T} in MOI.Indicator{A,S2}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.IndicatorToMILPBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.IndicatorToMILPBridge","text":"IndicatorToMILPBridge{T,F,A,S} <: Bridges.Constraint.AbstractBridge\n\nIndicatorToMILPBridge implements the following reformulation:\n\nx in textsfIndicator(s) into a mixed-integer linear program.\n\nSource node\n\nIndicatorToMILPBridge supports:\n\nF in MOI.Indicator{A,S}\n\nwhere F is MOI.VectorOfVariables or MOI.VectorAffineFunction{T}.\n\nTarget nodes\n\nIndicatorToMILPBridge creates:\n\nMOI.VariableIndex in MOI.ZeroOne\nMOI.ScalarAffineFunction{T} in S\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.IntegerToZeroOneBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.IntegerToZeroOneBridge","text":"IntegerToZeroOneBridge{T} <: Bridges.Constraint.AbstractBridge\n\nIntegerToZeroOneBridge implements the following reformulation:\n\nx in mathbfZ into y_i in 0 1, x == lb + sum 2^i-1 y_i.\n\nSource node\n\nIntegerToZeroOneBridge supports:\n\nVariableIndex in MOI.Integer\n\nTarget nodes\n\nIntegerToZeroOneBridge creates:\n\nMOI.VariableIndex in MOI.ZeroOne\nMOI.ScalarAffineFunction{T} in MOI.EqualTo{T}\n\nDeveloper note\n\nThis bridge is implemented as a constraint bridge instead of a variable bridge because we don't want to substitute the linear combination of y for every instance of x. Doing so would be expensive and greatly reduce the sparsity of the constraints.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.LessToGreaterBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.LessToGreaterBridge","text":"LessToGreaterBridge{T,F,G} <: Bridges.Constraint.AbstractBridge\n\nLessToGreaterBridge implements the following reformulation:\n\nf(x) le u into -f(x) ge -u\n\nSource node\n\nLessToGreaterBridge supports:\n\nG in MOI.LessThan{T}\n\nTarget nodes\n\nLessToGreaterBridge creates:\n\nF in MOI.GreaterThan{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.LessToIntervalBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.LessToIntervalBridge","text":"LessToIntervalBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nLessToIntervalBridge implements the following reformulations:\n\nf(x) le u into f(x) in (-infty u\n\nSource node\n\nLessToIntervalBridge supports:\n\nF in MOI.LessThan{T}\n\nTarget nodes\n\nLessToIntervalBridge creates:\n\nF in MOI.Interval{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.LogDetBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.LogDetBridge","text":"LogDetBridge{T,F,G,H,I} <: Bridges.Constraint.AbstractBridge\n\nThe MOI.LogDetConeTriangle is representable by MOI.PositiveSemidefiniteConeTriangle and MOI.ExponentialCone constraints.\n\nIndeed, logdet(X) = sumlimits_i=1^n log(delta_i) where delta_i are the eigenvalues of X.\n\nAdapting the method from [1, p. 149], we see that t le u log(det(Xu)) for u  0 if and only if there exists a lower triangular matrix Δ such that\n\nbeginalign*\n  beginpmatrix\n    X  Δ\n    Δ^top  mathrmDiag(Δ)\n  endpmatrix  succeq 0\n  t - sum_i=1^n u logleft(fracΔ_iiuright)  le 0\nendalign*\n\nWhich we reformulate further into\n\nbeginalign*\n  beginpmatrix\n    X  Δ\n    Δ^top  mathrmDiag(Δ)\n  endpmatrix  succeq 0\n  (l_i u  Δ_ii)  in ExponentialConequad forall i \n  t - sum_i=1^n l_i  le 0\nendalign*\n\nSource node\n\nLogDetBridge supports:\n\nI in MOI.LogDetConeTriangle\n\nTarget nodes\n\nLogDetBridge creates:\n\nF in MOI.PositiveSemidefiniteConeTriangle\nG in MOI.ExponentialCone\nH in MOI.LessThan{T}\n\n[1] Ben-Tal, Aharon, and Arkadi Nemirovski. Lectures on modern convex     optimization: analysis, algorithms, and engineering applications. Society     for Industrial and Applied Mathematics, 2001.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.MultiSetMapBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.MultiSetMapBridge","text":"abstract type MultiSetMapBridge{T,S1,G} <: AbstractBridge end\n\nSame as SetMapBridge but the output constraint type does not only depend on the input constraint type.\n\nWhen subtyping MultiSetMapBridge, added_constraint_types and supports should additionally be implemented by the bridge.\n\nFor example, if a bridge BridgeType may create either a constraint of type F2-in-S2 or F3-in-S3, these methods should be implemented as follows:\n\nfunction MOI.Bridges.added_constraint_types(\n    ::Type{<:BridgeType{T,F2,F3}},\n) where {T,F2,F3}\n    return Tuple{Type,Type}[(F2, S2), (F3, S3)]\nend\n\nfunction MOI.supports(\n    model::MOI.ModelLike,\n    attr::Union{MOI.ConstraintPrimalStart,MOI.ConstraintDualStart},\n    ::Type{<:BridgeType{T,F2,F3}},\n) where {T,F2,F3}\n    return MOI.supports(model, attr, MOI.ConstraintIndex{F2,S2}) ||\n           MOI.supports(model, attr, MOI.ConstraintIndex{F3,S3})\nend\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.NonnegToNonposBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.NonnegToNonposBridge","text":"NonnegToNonposBridge{T,F,G} <: Bridges.Constraint.AbstractBridge\n\nNonnegToNonposBridge implements the following reformulation:\n\nf(x) in mathbbR_+ into -f(x) in mathbbR_-\n\nSource node\n\nNonnegToNonposBridge supports:\n\nG in MOI.Nonnegatives\n\nTarget nodes\n\nNonnegToNonposBridge creates:\n\nF in MOI.Nonpositives\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.NonposToNonnegBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.NonposToNonnegBridge","text":"NonposToNonnegBridge{T,F,G} <: Bridges.Constraint.AbstractBridge\n\nNonposToNonnegBridge implements the following reformulation:\n\nf(x) in mathbbR_- into -f(x) in mathbbR_+\n\nSource node\n\nNonposToNonnegBridge supports:\n\nG in MOI.Nonpositives\n\nTarget nodes\n\nNonposToNonnegBridge creates:\n\nF in MOI.Nonnegatives\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.NormInfinityBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.NormInfinityBridge","text":"NormInfinityBridge{T,F,G} <: Bridges.Constraint.AbstractBridge\n\nNormInfinityBridge implements the following reformulation:\n\nx_infty le t into t - x_i t + x_i in mathbbR_+.\n\nSource node\n\nNormInfinityBridge supports:\n\nG in MOI.NormInfinityCone{T}\n\nTarget nodes\n\nNormInfinityBridge creates:\n\nF in MOI.Nonnegatives\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.NormInfinityConeToNormConeBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.NormInfinityConeToNormConeBridge","text":"NormInfinityConeToNormConeBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nNormInfinityConeToNormConeBridge implements the following reformulations:\n\n(t x) in NormInfinityCone(d) into (t x) in NormCone(Inf d)\n\nSource node\n\nNormInfinityConeToNormConeBridge supports:\n\nF in MOI.NormInfinityCone\n\nTarget nodes\n\nNormInfinityConeToNormConeBridge creates:\n\nF in MOI.NormCone\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.NormNuclearBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.NormNuclearBridge","text":"NormNuclearBridge{T,F,G,H} <: Bridges.Constraint.AbstractBridge\n\nNormNuclearBridge implements the following reformulation:\n\nt ge sum_i sigma_i (X) into leftbeginarrayc cU  X^top  X  Vendarrayright succeq 0 and 2t ge tr(U) + tr(V).\n\nSource node\n\nNormNuclearBridge supports:\n\nH in MOI.NormNuclearCone\n\nTarget nodes\n\nNormNuclearBridge creates:\n\nF in MOI.GreaterThan{T}\nG in MOI.PositiveSemidefiniteConeTriangle\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.NormOneBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.NormOneBridge","text":"NormOneBridge{T,F,G} <: Bridges.Constraint.AbstractBridge\n\nNormOneBridge implements the following reformulation:\n\nsum x_i le t into t - sum y_i y_i - x_i y_i + x_i in mathbbR_+.\n\nSource node\n\nNormOneBridge supports:\n\nG in MOI.NormOneCone{T}\n\nTarget nodes\n\nNormOneBridge creates:\n\nF in MOI.Nonnegatives\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.NormOneConeToNormConeBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.NormOneConeToNormConeBridge","text":"NormOneConeToNormConeBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nNormOneConeToNormConeBridge implements the following reformulations:\n\n(t x) in NormOneCone(d) into (t x) in NormCone(1 d)\n\nSource node\n\nNormOneConeToNormConeBridge supports:\n\nF in MOI.NormOneCone\n\nTarget nodes\n\nNormOneConeToNormConeBridge creates:\n\nF in MOI.NormCone\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.NormSpectralBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.NormSpectralBridge","text":"NormSpectralBridge{T,F,G} <: Bridges.Constraint.AbstractBridge\n\nNormSpectralBridge implements the following reformulation:\n\nt ge sigma_1(X) into leftbeginarrayc ctmathbfI  X^top  X  t mathbfIendarrayright succeq 0\n\nSource node\n\nNormSpectralBridge supports:\n\nG in MOI.NormSpectralCone\n\nTarget nodes\n\nNormSpectralBridge creates:\n\nF in MOI.PositiveSemidefiniteConeTriangle\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.NormToPowerBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.NormToPowerBridge","text":"NormToPowerBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nNormToPowerBridge implements the following reformulation:\n\n(t x) in NormCone(p 1+d) into (r_i t x_i) in PowerCone(1  p) for all i, and sumlimits_i r_i == t.\n\nFor details, see Alizadeh, F., and Goldfarb, D. (2001). \"Second-order cone programming.\" Mathematical Programming, Series B, 95:3-51.\n\nSource node\n\nNormToPowerBridge supports:\n\nF in MOI.NormCone\n\nTarget nodes\n\nNormToPowerBridge creates:\n\nF in MOI.PowerCone{T}\nMOI.ScalarAffineFunction in MOI.EqualTo\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.NumberConversionBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.NumberConversionBridge","text":"NumberConversionBridge{T,F1,S1,F2,S2} <: Bridges.Constraint.AbstractBridge\n\nNumberConversionBridge implements the following reformulation:\n\nf1(x) in S1 to f2(x) in S2\n\nwhere f and S are the same functional form, but differ in their coefficient type.\n\nSource node\n\nNumberConversionBridge supports:\n\nF1 in S1\n\nTarget node\n\nNumberConversionBridge creates:\n\nF2 in S2\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.QuadtoSOCBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.QuadtoSOCBridge","text":"QuadtoSOCBridge{T} <: Bridges.Constraint.AbstractBridge\n\nQuadtoSOCBridge converts quadratic inequalities\n\nfrac12x^T Q x + a^T x le ub\n\ninto MOI.RotatedSecondOrderCone constraints, but it only applies when Q is positive definite.\n\nThis is because, if Q is positive definite, there exists U such that Q = U^T U, and so the inequality can then be rewritten as;\n\nU x_2^2 le 2 (-a^T x + ub)\n\nTherefore, QuadtoSOCBridge implements the following reformulations:\n\nfrac12x^T Q x + a^T x le ub into (1 -a^T x + ub Ux) in RotatedSecondOrderCone where Q = U^T U\nfrac12x^T Q x + a^T x ge lb into (1 a^T x - lb Ux) in RotatedSecondOrderCone where -Q = U^T U\n\nSource node\n\nQuadtoSOCBridge supports:\n\nMOI.ScalarAffineFunction{T} in MOI.LessThan{T}\nMOI.ScalarAffineFunction{T} in MOI.GreaterThan{T}\n\nTarget nodes\n\nRelativeEntropyBridge creates:\n\nMOI.VectorAffineFunction{T} in MOI.RotatedSecondOrderCone\n\nErrors\n\nThis bridge errors if Q is not positive definite.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.RSOCtoNonConvexQuadBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.RSOCtoNonConvexQuadBridge","text":"RSOCtoNonConvexQuadBridge{T} <: Bridges.Constraint.AbstractBridge\n\nRSOCtoNonConvexQuadBridge implements the following reformulations:\n\nx_2^2 le 2tu into sum x^2 - 2tu le 0, 1t + 0 ge 0, and 1u + 0 ge 0.\n\nThe MOI.ScalarAffineFunctions 1t + 0 and 1u + 0 are used in case the variables have other bound constraints.\n\nwarning: Warning\nThis transformation starts from a convex constraint and creates a non-convex constraint. Unless the solver has explicit support for detecting rotated second-order cones in quadratic form, this may (wrongly) be interpreted by the solver as being non-convex. Therefore, this bridge is not added automatically by MOI.Bridges.full_bridge_optimizer. Care is recommended when adding this bridge to a optimizer.\n\nSource node\n\nRSOCtoNonConvexQuadBridge supports:\n\nMOI.VectorOfVariables in MOI.RotatedSecondOrderCone\n\nTarget nodes\n\nRSOCtoNonConvexQuadBridge creates:\n\nMOI.ScalarQuadraticFunction{T} in MOI.LessThan{T}\nMOI.ScalarAffineFunction{T} in MOI.GreaterThan{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge","text":"RSOCtoPSDBridge{T,F,G} <: Bridges.Constraint.AbstractBridge\n\nRSOCtoPSDBridge implements the following reformulation:\n\nx_2^2 le 2tcdot u into leftbeginarrayc ct  x^top  x  2tu mathbfIendarrayrightsucceq 0\n\nSource node\n\nRSOCtoPSDBridge supports:\n\nG in MOI.RotatedSecondOrderCone\n\nTarget nodes\n\nRSOCtoPSDBridge creates:\n\nF in MOI.PositiveSemidefiniteConeTriangle\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge","text":"RSOCtoSOCBridge{T,F,G} <: Bridges.Constraint.AbstractBridge\n\nRSOCtoSOCBridge implements the following reformulation:\n\nx_2^2 le 2tu into fract - usqrt 2 x_2 le  fract + usqrt 2\n\nSource node\n\nRSOCtoSOCBridge supports:\n\nG in MOI.RotatedSecondOrderCone\n\nTarget node\n\nRSOCtoSOCBridge creates:\n\nF in MOI.SecondOrderCone\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.ReifiedAllDifferentToCountDistinctBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.ReifiedAllDifferentToCountDistinctBridge","text":"ReifiedAllDifferentToCountDistinctBridge{T,F} <:\nBridges.Constraint.AbstractBridge\n\nReifiedAllDifferentToCountDistinctBridge implements the following reformulations:\n\nr iff x in textsfAllDifferent(d) to r iff (n x) in textsfCountDistinct(1+d) and n = d\nr iff f(x) in textsfAllDifferent(d) to r iff (d f(x)) in textsfCountDistinct(1+d)\n\nSource node\n\nReifiedAllDifferentToCountDistinctBridge supports:\n\nF in MOI.Reified{MOI.AllDifferent}\n\nwhere F is MOI.VectorOfVariables or MOI.VectorAffineFunction{T}.\n\nTarget nodes\n\nReifiedAllDifferentToCountDistinctBridge creates:\n\nF in MOI.Reified{MOI.CountDistinct}\nMOI.VariableIndex in MOI.EqualTo{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.ReifiedCountDistinctToMILPBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.ReifiedCountDistinctToMILPBridge","text":"ReifiedCountDistinctToMILPBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nReifiedCountDistinctToMILPBridge implements the following reformulation:\n\nr iff (n x) in textsfCountDistinct(1+d) into a mixed-integer linear program.\n\nReformulation\n\nThe reformulation is non-trivial, and it depends on the finite domain of each variable x_i, which we as define S_i = l_ildotsu_i.\n\nFirst, we introduce new binary variables z_ij, which are 1 if variable x_i takes the value j in the optimal solution and 0 otherwise:\n\nbeginaligned\nz_ij in 0 1                                forall i in 1ldots d j in S_i  \nx_i - sumlimits_jin S_i j cdot z_ij = 0   forall i in 1ldots d              \nsumlimits_jin S_i z_ij = 1                  forall i in 1ldots d              \nendaligned\n\nThen, we introduce new binary variables y_j, which are 1 if a variable takes the value j in the optimal solution and 0 otherwise.\n\nbeginaligned\ny_j in 0 1                          forall j in bigcup_i=1ldotsd S_i \ny_j le sumlimits_i in 1ldots d j in S_i z_ij le M y_j   forall j in bigcup_i=1ldotsd S_i\nendaligned\n\nFinally, n is constrained to be the number of y_j elements that are non-zero, with some slack:\n\nn - sumlimits_j in bigcup_i=1ldotsd S_i y_j = delta^+ - delta^-\n\nAnd then the slack is constrained to respect the reif variable r:\n\nbeginaligned\nd_1 le delta^+ le M d_1 \nd_2 le delta^- le M d_s \nd_1 + d_2 + r = 1             \nd_1 d_2 in 0 1\nendaligned\n\nSource node\n\nReifiedCountDistinctToMILPBridge supports:\n\nF in MOI.Reified{MOI.CountDistinct}\n\nwhere F is MOI.VectorOfVariables or MOI.VectorAffineFunction{T}.\n\nTarget nodes\n\nReifiedCountDistinctToMILPBridge creates:\n\nMOI.VariableIndex in MOI.ZeroOne\nMOI.ScalarAffineFunction{T} in MOI.EqualTo{T}\nMOI.ScalarAffineFunction{T} in MOI.LessThan{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.RelativeEntropyBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.RelativeEntropyBridge","text":"RelativeEntropyBridge{T,F,G,H} <: Bridges.Constraint.AbstractBridge\n\nRelativeEntropyBridge implements the following reformulation that converts a MOI.RelativeEntropyCone into an MOI.ExponentialCone:\n\nu ge sum_i=1^n w_i log left(fracw_iv_iright) into y_i ge 0, u ge sum_i=1^n y_i, and (-y_i w_i v_i) in ExponentialCone.\n\nSource node\n\nRelativeEntropyBridge supports:\n\nH in MOI.RelativeEntropyCone\n\nTarget nodes\n\nRelativeEntropyBridge creates:\n\nF in MOI.GreaterThan{T}\nG in MOI.ExponentialCone\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.RootDetBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.RootDetBridge","text":"RootDetBridge{T,F,G,H} <: Bridges.Constraint.AbstractBridge\n\nThe MOI.RootDetConeTriangle is representable by MOI.PositiveSemidefiniteConeTriangle and MOI.GeometricMeanCone constraints, see [1, p. 149].\n\nIndeed, t le det(X)^1n if and only if there exists a lower triangular matrix Δ such that:\n\nbeginalign*\n  beginpmatrix\n    X  Δ\n    Δ^top  mathrmDiag(Δ)\n  endpmatrix  succeq 0\n  (t mathrmDiag(Δ))  in GeometricMeanCone\nendalign*\n\nSource node\n\nRootDetBridge supports:\n\nI in MOI.RootDetConeTriangle\n\nTarget nodes\n\nRootDetBridge creates:\n\nF in MOI.PositiveSemidefiniteConeTriangle\nG in MOI.GeometricMeanCone\n\n[1] Ben-Tal, Aharon, and Arkadi Nemirovski. Lectures on modern convex     optimization: analysis, algorithms, and engineering applications. Society     for Industrial and Applied Mathematics, 2001.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge","text":"SOCtoNonConvexQuadBridge{T} <: Bridges.Constraint.AbstractBridge\n\nSOCtoNonConvexQuadBridge implements the following reformulations:\n\nx_2 le t into sum x^2 - t^2 le 0 and 1t + 0 ge 0\n\nThe MOI.ScalarAffineFunction 1t + 0 is used in case the variable has other bound constraints.\n\nwarning: Warning\nThis transformation starts from a convex constraint and creates a non-convex constraint. Unless the solver has explicit support for detecting second-order cones in quadratic form, this may (wrongly) be interpreted by the solver as being non-convex. Therefore, this bridge is not added automatically by MOI.Bridges.full_bridge_optimizer. Care is recommended when adding this bridge to a optimizer.\n\nSource node\n\nSOCtoNonConvexQuadBridge supports:\n\nMOI.VectorOfVariables in MOI.SecondOrderCone\n\nTarget nodes\n\nSOCtoNonConvexQuadBridge creates:\n\nMOI.ScalarQuadraticFunction{T} in MOI.LessThan{T}\nMOI.ScalarAffineFunction{T} in MOI.GreaterThan{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.SOCtoPSDBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.SOCtoPSDBridge","text":"SOCtoPSDBridge{T,F,G} <: Bridges.Constraint.AbstractBridge\n\nSOCtoPSDBridge implements the following reformulation:\n\nx_2 le t into leftbeginarrayc ct  x^top  x  t mathbfIendarrayrightsucceq 0\n\nwarning: Warning\nThis bridge is not added by default by MOI.Bridges.full_bridge_optimizer because bridging second order cone constraints to semidefinite constraints can be achieved by the SOCtoRSOCBridge followed by the RSOCtoPSDBridge, while creating a smaller semidefinite constraint.\n\nSource node\n\nSOCtoPSDBridge supports:\n\nG in MOI.SecondOrderCone\n\nTarget nodes\n\nSOCtoPSDBridge creates:\n\nF in MOI.PositiveSemidefiniteConeTriangle\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge","text":"SOCtoRSOCBridge{T,F,G} <: Bridges.Constraint.AbstractBridge\n\nSOCtoRSOCBridge implements the following reformulation:\n\nx_2 le t into (t+x_1)(t-x_1)ge (x_2ldotsx_N)_2^2\n\nAssumptions\n\nSOCtoRSOCBridge assumes that the length of x is at least one.\n\nSource node\n\nSOCtoRSOCBridge supports:\n\nG in MOI.SecondOrderCone\n\nTarget node\n\nSOCtoRSOCBridge creates:\n\nF in MOI.RotatedSecondOrderCone\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.SOS1ToMILPBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.SOS1ToMILPBridge","text":"SOS1ToMILPBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nSOS1ToMILPBridge implements the following reformulation:\n\nx in textsfSOS1(d) into a mixed-integer linear program.\n\nSource node\n\nSOS1ToMILPBridge supports:\n\nF in MOI.SOS1\n\nwhere F is MOI.VectorOfVariables or MOI.VectorAffineFunction{T}.\n\nTarget nodes\n\nSOS1ToMILPBridge creates:\n\nMOI.VariableIndex in MOI.ZeroOne\nMOI.ScalarAffineFunction{T} in MOI.EqualTo{T}\nMOI.ScalarAffineFunction{T} in MOI.LessThan{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.SOS2ToMILPBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.SOS2ToMILPBridge","text":"SOS2ToMILPBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nSOS2ToMILPBridge implements the following reformulation:\n\nx in textsfSOS2(d) into a mixed-integer linear program.\n\nSource node\n\nSOS2ToMILPBridge supports:\n\nF in MOI.SOS2\n\nwhere F is MOI.VectorOfVariables or MOI.VectorAffineFunction{T}.\n\nTarget nodes\n\nSOS2ToMILPBridge creates:\n\nMOI.VariableIndex in MOI.ZeroOne\nMOI.ScalarAffineFunction{T} in MOI.EqualTo{T}\nMOI.ScalarAffineFunction{T} in MOI.LessThan{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge","text":"ScalarFunctionizeBridge{T,S} = FunctionConversionBridge{T,MOI.ScalarAffineFunction{T},MOI.VariableIndex,S}\n\nScalarFunctionizeBridge implements the following reformulations:\n\nx in S into 1x + 0 in S\n\nSource node\n\nScalarFunctionizeBridge supports:\n\nMOI.VariableIndex in S\n\nTarget nodes\n\nScalarFunctionizeBridge creates:\n\nMOI.ScalarAffineFunction{T} in S\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.ScalarSlackBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.ScalarSlackBridge","text":"ScalarSlackBridge{T,F,S} <: Bridges.Constraint.AbstractBridge\n\nScalarSlackBridge implements the following reformulation:\n\nf(x) in S into f(x) - y == 0 and y in S\n\nSource node\n\nScalarSlackBridge supports:\n\nG in S, where G is not MOI.VariableIndex and S is not MOI.EqualTo\n\nTarget nodes\n\nScalarSlackBridge creates:\n\nF in MOI.EqualTo{T}\nMOI.VariableIndex in S\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.ScalarizeBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.ScalarizeBridge","text":"ScalarizeBridge{T,F,S}\n\nScalarizeBridge implements the following reformulations:\n\nf(x) - a in mathbbR_+ into f_i(x) ge a_i for all i\nf(x) - a in mathbbR_- into f_i(x) le a_i for all i\nf(x) - a in 0 into f_i(x) == a_i for all i\n\nSource node\n\nScalarizeBridge supports:\n\nG in MOI.Nonnegatives{T}\nG in MOI.Nonpositives{T}\nG in MOI.Zeros{T}\n\nTarget nodes\n\nScalarizeBridge creates:\n\nF in S, where S is one of MOI.GreaterThan{T}, MOI.LessThan{T}, and MOI.EqualTo{T}, depending on the type of the input set.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.SecondOrderConeToNormConeBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.SecondOrderConeToNormConeBridge","text":"SecondOrderConeToNormConeBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nSecondOrderConeToNormConeBridge implements the following reformulations:\n\n(t x) in SecondOrderCone(d) into (t x) in NormCone(2 d)\n\nSource node\n\nSecondOrderConeToNormConeBridge supports:\n\nF in MOI.SecondOrderCone\n\nTarget nodes\n\nSecondOrderConeToNormConeBridge creates:\n\nF in MOI.NormCone\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.SemiToBinaryBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.SemiToBinaryBridge","text":"SemiToBinaryBridge{T,S} <: Bridges.Constraint.AbstractBridge\n\nSemiToBinaryBridge implements the following reformulations:\n\nx in 0 cup l u into\nbeginaligned\nx leq z u \nx geq z l \nz in 0 1\nendaligned\nx in 0 cup l ldots u into\nbeginaligned\nx leq z u \nx geq z l \nz in 0 1 \nx in mathbbZ\nendaligned\n\nSource node\n\nSemiToBinaryBridge supports:\n\nMOI.VariableIndex in MOI.Semicontinuous{T}\nMOI.VariableIndex in MOI.Semiinteger{T}\n\nTarget nodes\n\nSemiToBinaryBridge creates:\n\nMOI.VariableIndex in MOI.ZeroOne\nMOI.ScalarAffineFunction{T} in MOI.LessThan{T}\nMOI.ScalarAffineFunction{T} in MOI.GreaterThan{T}\nMOI.VariableIndex{T} in MOI.Integer (if S is MOI.Semiinteger{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.SetDotInverseScalingBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.SetDotInverseScalingBridge","text":"SetDotInverseScalingBridge{T,S,F,G} <: Bridges.Constraint.AbstractBridge\n\nSetDotInverseScalingBridge implements the reformulation from constraints in the MOI.Scaled{S} to constraints in the S.\n\nSource node\n\nSetDotInverseScalingBridge supports:\n\nG in MOI.Scaled{S}\n\nTarget node\n\nSetDotInverseScalingBridge creates:\n\nF in S\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.SetDotScalingBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.SetDotScalingBridge","text":"SetDotScalingBridge{T,S,F,G} <: Bridges.Constraint.AbstractBridge\n\nSetDotScalingBridge implements the reformulation from constraints in S to constraints in MOI.Scaled{S}.\n\nSource node\n\nSetDotScalingBridge supports:\n\nG in S\n\nTarget node\n\nSetDotScalingBridge creates:\n\nF in MOI.Scaled{S}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.SetMapBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.SetMapBridge","text":"abstract type SetMapBridge{T,S2,S1,F,G} <: MultiSetMapBridge{T,S1,G} end\n\nConsider two type of sets, S1 and S2, and a linear mapping A such that the image of a set of type S1 under A is a set of type S2.\n\nA SetMapBridge{T,S2,S1,F,G} is a bridge that maps G-in-S1 constraints into F-in-S2 by mapping the function through A.\n\nThe linear map A is described by;\n\nMOI.Bridges.map_set\nMOI.Bridges.map_function.\n\nImplementing a method for these two functions is sufficient to bridge constraints. However, in order for the getters and setters of attributes such as dual solutions and starting values to work as well, a method for the following functions must be implemented:\n\nMOI.Bridges.inverse_map_set\nMOI.Bridges.inverse_map_function\nMOI.Bridges.adjoint_map_function\nMOI.Bridges.inverse_adjoint_map_function\n\nSee the docstrings of each function to see which feature would be missing if it was not implemented for a given bridge.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.SplitComplexEqualToBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.SplitComplexEqualToBridge","text":"SplitComplexEqualToBridge{T,F,G} <: Bridges.Constraint.AbstractBridge\n\nSplitComplexEqualToBridge implements the following reformulation:\n\nf(x) + g(x) * im = a + b * im into f(x) = a and g(x) = b\n\nSource node\n\nSplitComplexEqualToBridge supports:\n\nG in MOI.EqualTo{Complex{T}}\n\nwhere G is a function with Complex coefficients.\n\nTarget nodes\n\nSplitComplexEqualToBridge creates:\n\nF in MOI.EqualTo{T}\n\nwhere F is the type of the real/imaginary part of G.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.SplitComplexZerosBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.SplitComplexZerosBridge","text":"SplitComplexZerosBridge{T,F,G} <: Bridges.Constraint.AbstractBridge\n\nSplitComplexZerosBridge implements the following reformulation:\n\nf(x) in 0^n into textRe(f(x)) in 0^n and textIm(f(x)) in 0^n\n\nSource node\n\nSplitComplexZerosBridge supports:\n\nG in MOI.Zeros\n\nwhere G is a function with Complex coefficients.\n\nTarget nodes\n\nSplitComplexZerosBridge creates:\n\nF in MOI.Zeros\n\nwhere F is the type of the real/imaginary part of G.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.SplitHyperRectangleBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.SplitHyperRectangleBridge","text":"SplitHyperRectangleBridge{T,G,F} <: Bridges.Constraint.AbstractBridge\n\nSplitHyperRectangleBridge implements the following reformulation:\n\nf(x) in textsfHyperRectangle(l u) to f(x) - l u - f(x) in mathbbR_+.\n\nSource node\n\nSplitHyperRectangleBridge supports:\n\nF in MOI.HyperRectangle\n\nTarget nodes\n\nSplitHyperRectangleBridge creates:\n\nG in MOI.Nonnegatives\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.SplitIntervalBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.SplitIntervalBridge","text":"SplitIntervalBridge{T,F,S,LS,US} <: Bridges.Constraint.AbstractBridge\n\nSplitIntervalBridge implements the following reformulations:\n\nl le f(x) le u into f(x) ge l and f(x) le u\nf(x) = b into f(x) ge b and f(x) le b\nf(x) in 0 into f(x) in mathbbR_+ and f(x) in mathbbR_-\n\nSource node\n\nSplitIntervalBridge supports:\n\nF in MOI.Interval{T}\nF in MOI.EqualTo{T}\nF in MOI.Zeros\n\nTarget nodes\n\nSplitIntervalBridge creates:\n\nF in MOI.LessThan{T}\nF in MOI.GreaterThan{T}\n\nor\n\nF in MOI.Nonnegatives\nF in MOI.Nonpositives\n\nnote: Note\nIf T<:AbstractFloat and S is MOI.Interval{T} then no lower (resp. upper) bound constraint is created if the lower (resp. upper) bound is typemin(T) (resp. typemax(T)). Similarly, when MOI.ConstraintSet is set, a lower or upper bound constraint may be deleted or created accordingly.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.SquareBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.SquareBridge","text":"SquareBridge{T,F,G,TT,ST} <: Bridges.Constraint.AbstractBridge\n\nSquareBridge implements the following reformulations:\n\n(t u X) in LogDetConeSquare into (t u Y) in LogDetConeTriangle\n(t X) in RootDetConeSquare into (t Y) in RootDetConeTriangle\nX in AbstractSymmetricMatrixSetSquare into Y in AbstractSymmetricMatrixSetTriangle\n\nwhere Y is the upper triangluar component of X.\n\nIn addition, constraints are added as necessary to constrain the matrix X to be symmetric. For example, the constraint for the matrix:\n\nbeginpmatrix\n  1       1 + x  2 - 3x\n  1 +  x  2 + x  3 -  x\n  2 - 3x  2 + x      2x\nendpmatrix\n\ncan be broken down to the constraint of the symmetric matrix\n\nbeginpmatrix\n  1       1 + x  2 - 3x\n  cdot  2 + x  3 -  x\n  cdot  cdot     2x\nendpmatrix\n\nand the equality constraint between the off-diagonal entries (2, 3) and (3, 2) 3 - x == 2 + x. Note that no symmetrization constraint needs to be added between the off-diagonal entries (1, 2) and (2, 1) or between (1, 3) and (3, 1) because the expressions are the same.\n\nSource node\n\nSquareBridge supports:\n\nF in ST\n\nTarget nodes\n\nSquareBridge creates:\n\nG in TT\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.TableToMILPBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.TableToMILPBridge","text":"TableToMILPBridge{T,F} <: Bridges.Constraint.AbstractBridge\n\nTableToMILPBridge implements the following reformulation:\n\nx in Table(t) into\nbeginaligned\nz_j in 0 1                      quad forall i j \nsumlimits_j=1^n z_j = 1                           \nsumlimits_j=1^n t_ij z_j = x_i  quad forall i\nendaligned\n\nSource node\n\nTableToMILPBridge supports:\n\nF in MOI.Table{T}\n\nTarget nodes\n\nTableToMILPBridge creates:\n\nMOI.VariableIndex in MOI.ZeroOne\nMOI.ScalarAffineFunction{T} in MOI.EqualTo{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.ToScalarNonlinearBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.ToScalarNonlinearBridge","text":"ToScalarNonlinearBridge{T,G,S} <: AbstractFunctionConversionBridge{G,S}\n\nToScalarNonlinearBridge implements the following reformulation:\n\ng(x) in S into f(x) in S\n\nwhere g is an abstract scalar function and f is a MOI.ScalarNonlinearFunction.\n\nSource node\n\nToScalarNonlinearBridge supports:\n\nG<:AbstractScalarFunction in S\n\nTarget nodes\n\nToScalarNonlinearBridge creates:\n\nMOI.ScalarNonlinearFunction in S\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.ToScalarQuadraticBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.ToScalarQuadraticBridge","text":"ToScalarQuadraticBridge{T,G,S} <: AbstractFunctionConversionBridge{G,S}\n\nToScalarQuadraticBridge implements the following reformulation:\n\ng(x) in S into f(x) in S\n\nwhere g is an abstract scalar function and f is a MOI.ScalarQuadraticFunction.\n\nSource node\n\nToScalarQuadraticBridge supports:\n\nG<:AbstractScalarFunction in S\n\nTarget nodes\n\nToScalarQuadraticBridge creates:\n\nMOI.ScalarQuadraticFunction in S\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.ToVectorQuadraticBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.ToVectorQuadraticBridge","text":"ToVectorQuadraticBridge{T,G,S} <: AbstractFunctionConversionBridge{G,S}\n\nToVectorQuadraticBridge implements the following reformulation:\n\ng(x) in S into f(x) in S\n\nwhere g is an abstract vector function and f is a MOI.VectorQuadraticFunction.\n\nSource node\n\nToVectorQuadraticBridge supports:\n\nG<:AbstractVectorFunction in S\n\nTarget nodes\n\nToVectorQuadraticBridge creates:\n\nMOI.VectorQuadraticFunction in S\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge","text":"VectorFunctionizeBridge{T,S} = FunctionConversionBridge{T,MOI.VectorAffineFunction{T},S}\n\nVectorFunctionizeBridge implements the following reformulations:\n\nx in S into Ix + 0 in S\n\nSource node\n\nVectorFunctionizeBridge supports:\n\nMOI.VectorOfVariables in S\n\nTarget nodes\n\nVectorFunctionizeBridge creates:\n\nMOI.VectorAffineFunction{T} in S\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.VectorSlackBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.VectorSlackBridge","text":"VectorSlackBridge{T,F,S} <: Bridges.Constraint.AbstractBridge\n\nVectorSlackBridge implements the following reformulation:\n\nf(x) in S into f(x) - y in 0 and y in S\n\nSource node\n\nVectorSlackBridge supports:\n\nG in S, where G is not MOI.VectorOfVariables and S is not MOI.Zeros\n\nTarget nodes\n\nVectorSlackBridge creates:\n\nF in MOI.Zeros\nMOI.VectorOfVariables in S\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.VectorizeBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.VectorizeBridge","text":"VectorizeBridge{T,F,S,G} <: Bridges.Constraint.AbstractBridge\n\nVectorizeBridge implements the following reformulations:\n\ng(x) ge a into g(x) - a in mathbbR_+\ng(x) le a into g(x) - a in mathbbR_-\ng(x) == a into g(x) - a in 0\n\nwhere T is the coefficient type of g(x) - a.\n\nSource node\n\nVectorizeBridge supports:\n\nG in MOI.GreaterThan{T}\nG in MOI.LessThan{T}\nG in MOI.EqualTo{T}\n\nTarget nodes\n\nVectorizeBridge creates:\n\nF in S, where S is one of MOI.Nonnegatives, MOI.Nonpositives, MOI.Zeros depending on the type of the input set.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Constraint.ZeroOneBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Constraint.ZeroOneBridge","text":"ZeroOneBridge{T} <: Bridges.Constraint.AbstractBridge\n\nZeroOneBridge implements the following reformulation:\n\nx in 0 1 into x in mathbbZ, 1x in 0 1.\n\nnote: Note\nZeroOneBridge adds a linear constraint instead of adding variable bounds to avoid conflicting with bounds set by the user.\n\nSource node\n\nZeroOneBridge supports:\n\nMOI.VariableIndex in MOI.ZeroOne\n\nTarget nodes\n\nZeroOneBridge creates:\n\nMOI.VariableIndex in MOI.Integer\nMOI.ScalarAffineFunction{T} in MOI.Interval{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#objective_bridges_ref","page":"List of bridges","title":"Objective bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/list_of_bridges/","page":"List of bridges","title":"List of bridges","text":"These bridges are subtypes of Bridges.Objective.AbstractBridge.","category":"page"},{"location":"moi/submodules/Bridges/list_of_bridges/","page":"List of bridges","title":"List of bridges","text":"Modules = [Bridges.Objective]\nFilter = t -> begin\n    M = MathOptInterface.Bridges.Objective\n    return t isa Type && t != M.AbstractBridge && t <: M.AbstractBridge\nend","category":"page"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Objective.FunctionConversionBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Objective.FunctionConversionBridge","text":"FunctionConversionBridge{T,F,G} <: AbstractBridge\n\nFunctionConversionBridge implements the following reformulations:\n\nmin g(x) into minf(x)\nmax g(x) into maxf(x)\n\nfor these pairs of functions:\n\nMOI.ScalarAffineFunctionto [MOI.ScalarQuadraticFunction`](@ref)\nMOI.ScalarQuadraticFunction  to MOI.ScalarNonlinearFunction\nMOI.VectorAffineFunction to MOI.VectorQuadraticFunction\n\nSource node\n\nFunctionConversionBridge supports:\n\nMOI.ObjectiveFunction{G}\n\nTarget nodes\n\nFunctionConversionBridge creates:\n\nOne objective node: MOI.ObjectiveFunction{F}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Objective.FunctionizeBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Objective.FunctionizeBridge","text":"FunctionizeBridge{T,G} <: FunctionConversionBridge{T,MOI.ScalarAffineFunction{T},G}\n\nFunctionizeBridge implements the following reformulations:\n\nmin x into min1x + 0\nmax x into max1x + 0\n\nwhere T is the coefficient type of 1 and 0.\n\nSource node\n\nFunctionizeBridge supports:\n\nMOI.ObjectiveFunction{G}\n\nTarget nodes\n\nFunctionizeBridge creates:\n\nOne objective node: MOI.ObjectiveFunction{MOI.ScalarAffineFunction{T}}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Objective.QuadratizeBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Objective.QuadratizeBridge","text":"QuadratizeBridge{T,G} <: FunctionConversionBridge{T,MOI.ScalarQuadraticFunction{T},G}\n\nQuadratizeBridge implements the following reformulations:\n\nmin a^top x + b into minx^top mathbf0 x + a^top x + b\nmax a^top x + b into maxx^top mathbf0 x + a^top x + b\n\nwhere T is the coefficient type of 0.\n\nSource node\n\nQuadratizeBridge supports:\n\nMOI.ObjectiveFunction{G}\n\nTarget nodes\n\nQuadratizeBridge creates:\n\nOne objective node: MOI.ObjectiveFunction{MOI.ScalarQuadraticFunction{T}}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Objective.SlackBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Objective.SlackBridge","text":"SlackBridge{T,F,G}\n\nSlackBridge implements the following reformulations:\n\nminf(x) into miny f(x) - y le 0\nmaxf(x) into maxy f(x) - y ge 0\n\nwhere F is the type of f(x) - y, G is the type of f(x), and T is the coefficient type of f(x).\n\nSource node\n\nSlackBridge supports:\n\nMOI.ObjectiveFunction{G}\n\nTarget nodes\n\nSlackBridge creates:\n\nOne variable node: MOI.VariableIndex in MOI.Reals\nOne objective node: MOI.ObjectiveFunction{MOI.VariableIndex}\nOne constraint node, that depends on the MOI.ObjectiveSense:\nF-in-MOI.LessThan if MIN_SENSE\nF-in-MOI.GreaterThan if MAX_SENSE\n\nwarning: Warning\nWhen using this bridge, changing the optimization sense is not supported. Set the sense to MOI.FEASIBILITY_SENSE first to delete the bridge, then set MOI.ObjectiveSense and re-add the objective.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Objective.VectorFunctionizeBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Objective.VectorFunctionizeBridge","text":"VectorFunctionizeBridge{T,G} <: FunctionConversionBridge{T,MOI.VectorAffineFunction{T},G}\n\nVectorFunctionizeBridge implements the following reformulations:\n\nmin x into min1x + 0\nmax x into max1x + 0\n\nwhere T is the coefficient type of 1 and 0.\n\nSource node\n\nVectorFunctionizeBridge supports:\n\nMOI.ObjectiveFunction{G}\n\nTarget nodes\n\nVectorFunctionizeBridge creates:\n\nOne objective node: MOI.ObjectiveFunction{MOI.VectorAffineFunction{T}}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Objective.VectorSlackBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Objective.VectorSlackBridge","text":"VectorSlackBridge{T,F,G}\n\nVectorSlackBridge implements the following reformulations:\n\nminf(x) into miny y - f(x) in mathbbR_+ \nmaxf(x) into maxy f(x) - y in mathbbR_+ \n\nwhere F is the type of f(x) - y, G is the type of f(x), and T is the coefficient type of f(x).\n\nSource node\n\nVectorSlackBridge supports:\n\nMOI.ObjectiveFunction{G}\n\nTarget nodes\n\nVectorSlackBridge creates:\n\nOne variable node: MOI.VectorOfVariables in MOI.Reals\nOne objective node: MOI.ObjectiveFunction{MOI.VectorOfVariables}\nOne constraint node: F-in-MOI.Nonnegatives\n\nwarning: Warning\nWhen using this bridge, changing the optimization sense is not supported. Set the sense to MOI.FEASIBILITY_SENSE first to delete the bridge, then set MOI.ObjectiveSense and re-add the objective.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#variable_bridges_ref","page":"List of bridges","title":"Variable bridges","text":"","category":"section"},{"location":"moi/submodules/Bridges/list_of_bridges/","page":"List of bridges","title":"List of bridges","text":"These bridges are subtypes of Bridges.Variable.AbstractBridge.","category":"page"},{"location":"moi/submodules/Bridges/list_of_bridges/","page":"List of bridges","title":"List of bridges","text":"Modules = [Bridges.Variable]\nFilter = t -> begin\n    M = MathOptInterface.Bridges.Variable\n    return t isa Type && t != M.AbstractBridge && t <: M.AbstractBridge\nend","category":"page"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Variable.FlipSignBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Variable.FlipSignBridge","text":"abstract type FlipSignBridge{T,S1,S2} <: SetMapBridge{T,S2,S1} end\n\nAn abstract type that simplifies the creation of other bridges.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Variable.FreeBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Variable.FreeBridge","text":"FreeBridge{T} <: Bridges.Variable.AbstractBridge\n\nFreeBridge implements the following reformulation:\n\nx in mathbbR into y z ge 0 with the substitution rule x = y - z,\n\nwhere T is the coefficient type of y - z.\n\nSource node\n\nFreeBridge supports:\n\nMOI.VectorOfVariables in MOI.Reals\n\nTarget nodes\n\nFreeBridge creates:\n\nOne variable node: MOI.VectorOfVariables in MOI.Nonnegatives\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Variable.HermitianToSymmetricPSDBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Variable.HermitianToSymmetricPSDBridge","text":"HermitianToSymmetricPSDBridge{T} <: Bridges.Variable.AbstractBridge\n\nHermitianToSymmetricPSDBridge implements the following reformulation:\n\nHermitian positive semidefinite n x n complex matrix to a symmetric positive semidefinite 2n x 2n real matrix satisfying equality constraints described below.\n\nSource node\n\nHermitianToSymmetricPSDBridge supports:\n\nMOI.VectorOfVariables in MOI.HermitianPositiveSemidefiniteConeTriangle\n\nTarget node\n\nHermitianToSymmetricPSDBridge creates:\n\nMOI.VectorOfVariables in MOI.PositiveSemidefiniteConeTriangle\nMOI.ScalarAffineFunction{T} in MOI.EqualTo{T}\n\nReformulation\n\nThe reformulation is best described by example.\n\nThe Hermitian matrix:\n\nbeginbmatrix\n  x_11             x_12 + y_12im  x_13 + y_13im\n  x_12 - y_12im  x_22             x_23 + y_23im\n  x_13 - y_13im  x_23 - y_23im  x_33\nendbmatrix\n\nis positive semidefinite if and only if the symmetric matrix:\n\nbeginbmatrix\n    x_11  x_12  x_13  0        y_12   y_13 \n            x_22  x_23  -y_12  0        y_23 \n                    x_33  -y_13  -y_23  0      \n                            x_11   x_12   x_13 \n                                     x_22   x_23 \n                                              x_33\nendbmatrix\n\nis positive semidefinite.\n\nThe bridge achieves this reformulation by adding a new set of variables in MOI.PositiveSemidefiniteConeTriangle(6), and then adding three groups of equality constraints to:\n\nconstrain the two x blocks to be equal\nforce the diagonal of the y blocks to be 0\nforce the lower triangular of the y block to be the negative of the upper triangle.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Variable.NonposToNonnegBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Variable.NonposToNonnegBridge","text":"NonposToNonnegBridge{T} <: Bridges.Variable.AbstractBridge\n\nNonposToNonnegBridge implements the following reformulation:\n\nx in mathbbR_- into y in mathbbR_+ with the substitution rule x = -y,\n\nwhere T is the coefficient type of -y.\n\nSource node\n\nNonposToNonnegBridge supports:\n\nMOI.VectorOfVariables in MOI.Nonpositives\n\nTarget nodes\n\nNonposToNonnegBridge creates:\n\nOne variable node: MOI.VectorOfVariables in MOI.Nonnegatives,\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Variable.ParameterToEqualToBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Variable.ParameterToEqualToBridge","text":"ParameterToEqualToBridge{T} <: Bridges.Variable.AbstractBridge\n\nParameterToEqualToBridge implements the following reformulation:\n\nx in Parameter(v) into x == v\n\nSource node\n\nParameterToEqualToBridge supports:\n\nMOI.VariableIndex in MOI.Parameter\n\nTarget nodes\n\nParameterToEqualToBridge creates:\n\nOne variable node: MOI.VariableIndex in MOI.EqualTo{T}\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Variable.RSOCtoPSDBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Variable.RSOCtoPSDBridge","text":"RSOCtoPSDBridge{T} <: Bridges.Variable.AbstractBridge\n\nRSOCtoPSDBridge implements the following reformulation:\n\nx_2^2 le 2tu where t u ge 0 into Y succeq 0, with the substitution rule: Y = leftbeginarrayc ct  x^top  x  2u mathbfIendarrayright\n\nAdditional bounds are added to ensure the off-diagonals of the 2uI submatrix are 0, and linear constraints are added to ensure the diagonal of 2uI takes the same values.\n\nAs a special case, if x = 0, then RSOCtoPSDBridge reformulates into (t u) in mathbbR_+.\n\nSource node\n\nRSOCtoPSDBridge supports:\n\nMOI.VectorOfVariables in MOI.RotatedSecondOrderCone\n\nTarget nodes\n\nRSOCtoPSDBridge creates:\n\nOne variable node that depends on the input dimension:\nMOI.VectorOfVariables in MOI.Nonnegatives if dimension is 1 or 2\nMOI.VectorOfVariables in\nMOI.PositiveSemidefiniteConeTriangle otherwise\nThe constraint node MOI.VariableIndex in MOI.EqualTo\nThe constant node MOI.ScalarAffineFunction in MOI.EqualTo\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Variable.RSOCtoSOCBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Variable.RSOCtoSOCBridge","text":"RSOCtoSOCBridge{T} <: Bridges.Variable.AbstractBridge\n\nRSOCtoSOCBridge implements the following reformulation:\n\nx_2^2 le 2tu into v_2 le w, with the substitution rules t = fracwsqrt 2 + fracv_1sqrt 2, u = fracwsqrt 2 - fracv_1sqrt 2, and x = (v_2ldotsv_N).\n\nSource node\n\nRSOCtoSOCBridge supports:\n\nMOI.VectorOfVariables in MOI.RotatedSecondOrderCone\n\nTarget node\n\nRSOCtoSOCBridge creates:\n\nMOI.VectorOfVariables in MOI.SecondOrderCone\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Variable.SOCtoRSOCBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Variable.SOCtoRSOCBridge","text":"SOCtoRSOCBridge{T} <: Bridges.Variable.AbstractBridge\n\nSOCtoRSOCBridge implements the following reformulation:\n\nx_2 le t into 2uv ge w_2^2, with the substitution rules t = fracusqrt 2 + fracvsqrt 2, x = (fracusqrt 2 - fracvsqrt 2 w).\n\nAssumptions\n\nSOCtoRSOCBridge assumes that x ge 1.\n\nSource node\n\nSOCtoRSOCBridge supports:\n\nMOI.VectorOfVariables in MOI.SecondOrderCone\n\nTarget node\n\nSOCtoRSOCBridge creates:\n\nMOI.VectorOfVariables in MOI.RotatedSecondOrderCone\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Variable.SetMapBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Variable.SetMapBridge","text":"abstract type SetMapBridge{T,S1,S2} <: AbstractBridge end\n\nConsider two type of sets, S1 and S2, and a linear mapping A such that the image of a set of type S1 under A is a set of type S2.\n\nA SetMapBridge{T,S1,S2} is a bridge that substitutes constrained variables in S2 into the image through A of constrained variables in S1.\n\nThe linear map A is described by:\n\nMOI.Bridges.map_set\nMOI.Bridges.map_function\n\nImplementing a method for these two functions is sufficient to bridge constrained variables. However, in order for the getters and setters of attributes such as dual solutions and starting values to work as well, a method for the following functions must be implemented:\n\nMOI.Bridges.inverse_map_set\nMOI.Bridges.inverse_map_function\nMOI.Bridges.adjoint_map_function\nMOI.Bridges.inverse_adjoint_map_function.\n\nSee the docstrings of each function to see which feature would be missing if it was not implemented for a given bridge.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Variable.VectorizeBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Variable.VectorizeBridge","text":"VectorizeBridge{T,S} <: Bridges.Variable.AbstractBridge\n\nVectorizeBridge implements the following reformulations:\n\nx ge a into y in mathbbR_+ with the substitution rule x = a + y\nx le a into y in mathbbR_- with the substitution rule x = a + y\nx == a into y in 0 with the substitution rule x = a + y\n\nwhere T is the coefficient type of a + y.\n\nSource node\n\nVectorizeBridge supports:\n\nMOI.VariableIndex in MOI.GreaterThan{T}\nMOI.VariableIndex in MOI.LessThan{T}\nMOI.VariableIndex in MOI.EqualTo{T}\n\nTarget nodes\n\nVectorizeBridge creates:\n\nOne variable node: MOI.VectorOfVariables in S, where S is one of MOI.Nonnegatives, MOI.Nonpositives, MOI.Zeros depending on the type of S.\n\n\n\n\n\n","category":"type"},{"location":"moi/submodules/Bridges/list_of_bridges/#MathOptInterface.Bridges.Variable.ZerosBridge","page":"List of bridges","title":"MathOptInterface.Bridges.Variable.ZerosBridge","text":"ZerosBridge{T} <: Bridges.Variable.AbstractBridge\n\nZerosBridge implements the following reformulation:\n\nx in 0 into the substitution rule x = 0,\n\nwhere T is the coefficient type of 0.\n\nSource node\n\nZerosBridge supports:\n\nMOI.VectorOfVariables in MOI.Zeros\n\nTarget nodes\n\nZerosBridge does not create target nodes. It replaces all instances of x with 0 via substitution. This means that no variables are created in the underlying model.\n\nCaveats\n\nThe bridged variables are similar to parameters with zero values. Parameters with non-zero values can be created with constrained variables in MOI.EqualTo by combining a VectorizeBridge and this bridge.\n\nHowever, functions modified by ZerosBridge cannot be unbridged. That is, for a given function, we cannot determine if the bridged variables were used.\n\nA related implication is that this bridge does not support MOI.ConstraintDual. However, if a MOI.Utilities.CachingOptimizer is used, the dual can be determined by the bridged optimizer using MOI.Utilities.get_fallback because the caching optimizer records the unbridged function.\n\n\n\n\n\n","category":"type"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"EditURL = \"https://github.com/jump-dev/SeDuMi.jl/blob/v0.4.2/README.md\"","category":"page"},{"location":"packages/SeDuMi/#SeDuMi.jl","page":"jump-dev/SeDuMi.jl","title":"SeDuMi.jl","text":"","category":"section"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"SeDuMi.jl is wrapper for the SeDuMi solver.","category":"page"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"The wrapper has two components:","category":"page"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"an exported sedumi function that is a thin wrapper on top of the sedumi MATLAB function\nan interface to MathOptInterface","category":"page"},{"location":"packages/SeDuMi/#Affiliation","page":"jump-dev/SeDuMi.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"This wrapper is maintained by the JuMP community and is not an official wrapper of SeDuMi.","category":"page"},{"location":"packages/SeDuMi/#License","page":"jump-dev/SeDuMi.jl","title":"License","text":"","category":"section"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"SeDuMi.jl is licensed under the MIT License.","category":"page"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"The underlying solver, sqlp/sedumi is licensed under the GPL v2 license.","category":"page"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"In addition, SeDuMi requires an installation of MATLAB, which is a closed-source commercial product for which you must obtain a license.","category":"page"},{"location":"packages/SeDuMi/#Use-with-JuMP","page":"jump-dev/SeDuMi.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"To use SeDuMi with JuMP, do:","category":"page"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"using JuMP, SeDuMi\nmodel = Model(SeDuMi.Optimizer)\nset_attribute(model, \"fid\", 0)","category":"page"},{"location":"packages/SeDuMi/#Installation","page":"jump-dev/SeDuMi.jl","title":"Installation","text":"","category":"section"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"First, make sure that you satisfy the requirements of the MATLAB.jl Julia package, and that the SeDuMi software is installed in your MATLAB™ installation.","category":"page"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"Then, install SeDuMi.jl using Pkg.add:","category":"page"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"import Pkg\nPkg.add(\"SeDuMi\")","category":"page"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"If you get the error:","category":"page"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"Undefined function or variable 'sedumi'.\n\nError using save\nVariable 'jx_sedumi_arg_out_1' not found.\n\nERROR: LoadError: MATLAB.MEngineError(\"failed to get variable jx_sedumi_arg_out_1 from MATLAB session\")","category":"page"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"The error means that we couldn't find the sedumi function with one output argument using the MATLAB C API.","category":"page"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"This most likely means that you did not add SeDuMi to the MATLAB's path, that is, the toolbox/local/pathdef.m file.","category":"page"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"If modifying toolbox/local/pathdef.m does not work, the following should work, where /path/to/sedumi/ is the directory where the sedumi folder is located:","category":"page"},{"location":"packages/SeDuMi/","page":"jump-dev/SeDuMi.jl","title":"jump-dev/SeDuMi.jl","text":"julia> import MATLAB\n\njulia> cd(\"/path/to/sedumi/\") do\n           MATLAB.mat\"install_sedumi\"\n       end\n\njulia> MATLAB.mat\"savepath\"","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"EditURL = \"space_shuttle_reentry_trajectory.jl\"","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/#Optimal-control-for-a-Space-Shuttle-reentry-trajectory","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"","category":"section"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"This tutorial was originally contributed by Henrique Ferrolho.","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"This tutorial demonstrates how to compute a reentry trajectory for the Space Shuttle, by formulating and solving a nonlinear programming problem. The problem was drawn from Chapter 6 of (Betts, 2010).","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"info: Info\nThe JuMP extension InfiniteOpt.jl can also be used to model and solve optimal control problems.","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"tip: Tip\nThis tutorial is a more-complicated version of the Rocket Control example. If you are new to solving nonlinear programs in JuMP, you may want to start there instead.","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"The motion of the vehicle is defined by the following set of DAEs:","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"beginaligned\ndoth  = v sin gamma  \ndotphi  = fracvr cos gamma sin psi  cos theta  \ndottheta  = fracvr cos gamma cos psi  \ndotv  = -fracDm - g sin gamma  \ndotgamma  = fracLm v cos(beta) + cos gamma left ( fracvr - fracgv right )  \ndotpsi  = frac1m v cos gamma L sin(beta) + fracvr cos theta cos gamma sin psi sin theta  \nq  le q_U  \nendaligned","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"where the aerodynamic heating on the vehicle wing leading edge is q = q_a q_r and the dynamic variables are","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"beginaligned\n     h  quad textaltitude (ft)     qquad   gamma quad textflight path angle (rad) \n  phi  quad textlongitude (rad)   qquad   psi   quad textazimuth (rad)           \ntheta  quad textlatitude (rad)    qquad   alpha quad textangle of attack (rad)   \n     v  quad textvelocity (ftsec) qquad   beta  quad textbank angle (rad)\nendaligned","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"The aerodynamic and atmospheric forces on the vehicle are specified by the following quantities (English units):","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"beginaligned\n           D  = frac12 c_D S rho v^2                  qquad  a_0  = -020704 \n           L  = frac12 c_L S rho v^2                  qquad  a_1  =  0029244 \n           g  = mu  r^2                                   qquad  mu  =  014076539 times 10^17 \n           r  = R_e + h                                     qquad  b_0  =  007854 \n        rho  = rho_0 exp-hh_r                         qquad  b_1  = -061592  times 10^-2 \n      rho_0  = 0002378                                    qquad  b_2  =  0621408 times 10^-3 \n         h_r  = 23800                                       qquad  q_r  =  17700 sqrtrho (00001 v)^307 \n         c_L  = a_0 + a_1 hatalpha                      qquad  q_a  =  c_0 + c_1 hatalpha + c_2 hatalpha^2 + c_3 hatalpha^3 \n         c_D  = b_0 + b_1 hatalpha + b_2 hatalpha^2 qquad  c_0  =  10672181 \nhatalpha  = 180 alpha  pi                            qquad  c_1  = -019213774 times 10^-1 \n         R_e  = 20902900                                    qquad  c_2  =  021286289 times 10^-3 \n           S  = 2690                                        qquad  c_3  = -010117249 times 10^-5\nendaligned","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"The reentry trajectory begins at an altitude where the aerodynamic forces are quite small with a weight of w = 203000 (lb) and mass m = w  g_0 (slug), where g_0 = 32174 (ft/sec^2). The initial conditions are as follows:","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"beginaligned\n     h  = 260000 text ft  qquad  v       = 25600 text ftsec \n  phi  = 0      text deg qquad  gamma  = -1    text deg    \ntheta  = 0      text deg qquad  psi    = 90    text deg\nendaligned","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"The final point on the reentry trajectory occurs at the unknown (free) time t_F, at the so-called terminal area energy management (TAEM) interface, which is defined by the conditions","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"h = 80000 text ft qquad v = 2500 text ftsec qquad gamma = -5 text deg","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"As explained in the book, our goal is to maximize the final cross-range, which is equivalent to maximizing the final latitude of the vehicle, that is, J = theta(t_F).","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"(Image: Max cross-range shuttle reentry)","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/#Approach","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Approach","text":"","category":"section"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"We will use a discretized model of time, with a fixed number of discretized points, n. The decision variables at each point are going to be the state of the vehicle and the controls commanded to it. In addition, we will also make each time step size Delta t a decision variable; that way, we can either fix the time step size easily, or allow the solver to fine-tune the duration between each adjacent pair of points. Finally, in order to approximate the derivatives of the problem dynamics, we will use either rectangular or trapezoidal integration.","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"warning: Warning\nDo not try to actually land a Space Shuttle using this notebook. There's no mesh refinement going on, which can lead to unrealistic trajectories having position and velocity errors with orders of magnitude 10^4 ft and 10^2 ft/sec, respectively.","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"using JuMP\nimport Interpolations\nimport Ipopt\n\n# Global variables\nconst w = 203000.0  # weight (lb)\nconst g₀ = 32.174    # acceleration (ft/sec^2)\nconst m = w / g₀    # mass (slug)\n\n# Aerodynamic and atmospheric forces on the vehicle\nconst ρ₀ = 0.002378\nconst hᵣ = 23800.0\nconst Rₑ = 20902900.0\nconst μ = 0.14076539e17\nconst S = 2690.0\nconst a₀ = -0.20704\nconst a₁ = 0.029244\nconst b₀ = 0.07854\nconst b₁ = -0.61592e-2\nconst b₂ = 0.621408e-3\nconst c₀ = 1.0672181\nconst c₁ = -0.19213774e-1\nconst c₂ = 0.21286289e-3\nconst c₃ = -0.10117249e-5\n\n# Initial conditions\nconst h_s = 2.6          # altitude (ft) / 1e5\nconst ϕ_s = deg2rad(0)   # longitude (rad)\nconst θ_s = deg2rad(0)   # latitude (rad)\nconst v_s = 2.56         # velocity (ft/sec) / 1e4\nconst γ_s = deg2rad(-1)  # flight path angle (rad)\nconst ψ_s = deg2rad(90)  # azimuth (rad)\nconst α_s = deg2rad(0)   # angle of attack (rad)\nconst β_s = deg2rad(0)   # bank angle (rad)\nconst t_s = 1.00         # time step (sec)\n\n# Final conditions, the so-called Terminal Area Energy Management (TAEM)\nconst h_t = 0.8          # altitude (ft) / 1e5\nconst v_t = 0.25         # velocity (ft/sec) / 1e4\nconst γ_t = deg2rad(-5)  # flight path angle (rad)\n\n# Number of mesh points (knots) to be used\nconst n = 503\n\n# Integration scheme to be used for the dynamics\nconst integration_rule = \"rectangular\"\nnothing #hide","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"tip: Choose a good linear solver\nPicking a good linear solver is extremely important to maximize the performance of nonlinear solvers. For the best results, it is advised to experiment different linear solvers.For example, the linear solver MA27 is outdated and can be quite slow. MA57 is a much better alternative, especially for highly sparse problems (such as trajectory optimization problems).","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"# Uncomment the lines below to pass user options to the solver\nuser_options = (\n# \"mu_strategy\" => \"monotone\",\n# \"linear_solver\" => \"ma27\",\n)\n\n# Create JuMP model, using Ipopt as the solver\nmodel = Model(optimizer_with_attributes(Ipopt.Optimizer, user_options...))\n\n@variables(model, begin\n    0 ≤ scaled_h[1:n]                # altitude (ft) / 1e5\n    ϕ[1:n]                # longitude (rad)\n    deg2rad(-89) ≤ θ[1:n] ≤ deg2rad(89)  # latitude (rad)\n    1e-4 ≤ scaled_v[1:n]                # velocity (ft/sec) / 1e4\n    deg2rad(-89) ≤ γ[1:n] ≤ deg2rad(89)  # flight path angle (rad)\n    ψ[1:n]                # azimuth (rad)\n    deg2rad(-90) ≤ α[1:n] ≤ deg2rad(90)  # angle of attack (rad)\n    deg2rad(-89) ≤ β[1:n] ≤ deg2rad(1)  # bank angle (rad)\n    #        3.5 ≤       Δt[1:n] ≤ 4.5          # time step (sec)\n    Δt[1:n] == 4.0         # time step (sec)\nend);\nnothing #hide","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"info: Info\nAbove you can find two alternatives for the Δt variables.The first one, 3.5 ≤ Δt[1:n] ≤ 4.5 (currently commented), allows some wiggle room for the solver to adjust the time step size between pairs of mesh points. This is neat because it allows the solver to figure out which parts of the flight require more dense discretization than others. (Remember, the number of discretized points is fixed, and this example does not implement mesh refinement.) However, this makes the problem more complex to solve, and therefore leads to a longer computation time.The second line, Δt[1:n] == 4.0, fixes the duration of every time step to exactly 4.0 seconds. This allows the problem to be solved faster. However, to do this we need to know beforehand that the close-to-optimal total duration of the flight is ~2009 seconds. Therefore, if we split the total duration in slices of 4.0 seconds, we know that we require n = 503 knots to discretize the whole trajectory.","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"# Fix initial conditions\nfix(scaled_h[1], h_s; force = true)\nfix(ϕ[1], ϕ_s; force = true)\nfix(θ[1], θ_s; force = true)\nfix(scaled_v[1], v_s; force = true)\nfix(γ[1], γ_s; force = true)\nfix(ψ[1], ψ_s; force = true)\n\n# Fix final conditions\nfix(scaled_h[n], h_t; force = true)\nfix(scaled_v[n], v_t; force = true)\nfix(γ[n], γ_t; force = true)\n\n# Initial guess: linear interpolation between boundary conditions\nx_s = [h_s, ϕ_s, θ_s, v_s, γ_s, ψ_s, α_s, β_s, t_s]\nx_t = [h_t, ϕ_s, θ_s, v_t, γ_t, ψ_s, α_s, β_s, t_s]\ninterp_linear = Interpolations.LinearInterpolation([1, n], [x_s, x_t])\ninitial_guess = mapreduce(transpose, vcat, interp_linear.(1:n))\nset_start_value.(all_variables(model), vec(initial_guess))\n\n# Functions to restore `h` and `v` to their true scale\n@expression(model, h[j = 1:n], scaled_h[j] * 1e5)\n@expression(model, v[j = 1:n], scaled_v[j] * 1e4)\n\n# Helper functions\n@expression(model, c_L[j = 1:n], a₀ + a₁ * rad2deg(α[j]))\n@expression(model, c_D[j = 1:n], b₀ + b₁ * rad2deg(α[j]) + b₂ * rad2deg(α[j])^2)\n@expression(model, ρ[j = 1:n], ρ₀ * exp(-h[j] / hᵣ))\n@expression(model, D[j = 1:n], 0.5 * c_D[j] * S * ρ[j] * v[j]^2)\n@expression(model, L[j = 1:n], 0.5 * c_L[j] * S * ρ[j] * v[j]^2)\n@expression(model, r[j = 1:n], Rₑ + h[j])\n@expression(model, g[j = 1:n], μ / r[j]^2)\n\n# Motion of the vehicle as a differential-algebraic system of equations (DAEs)\n@expression(model, δh[j = 1:n], v[j] * sin(γ[j]))\n@expression(\n    model,\n    δϕ[j = 1:n],\n    (v[j] / r[j]) * cos(γ[j]) * sin(ψ[j]) / cos(θ[j])\n)\n@expression(model, δθ[j = 1:n], (v[j] / r[j]) * cos(γ[j]) * cos(ψ[j]))\n@expression(model, δv[j = 1:n], -(D[j] / m) - g[j] * sin(γ[j]))\n@expression(\n    model,\n    δγ[j = 1:n],\n    (L[j] / (m * v[j])) * cos(β[j]) +\n    cos(γ[j]) * ((v[j] / r[j]) - (g[j] / v[j]))\n)\n@expression(\n    model,\n    δψ[j = 1:n],\n    (1 / (m * v[j] * cos(γ[j]))) * L[j] * sin(β[j]) +\n    (v[j] / (r[j] * cos(θ[j]))) * cos(γ[j]) * sin(ψ[j]) * sin(θ[j])\n)\n\n# System dynamics\nfor j in 2:n\n    i = j - 1  # index of previous knot\n\n    if integration_rule == \"rectangular\"\n        # Rectangular integration\n        @constraint(model, h[j] == h[i] + Δt[i] * δh[i])\n        @constraint(model, ϕ[j] == ϕ[i] + Δt[i] * δϕ[i])\n        @constraint(model, θ[j] == θ[i] + Δt[i] * δθ[i])\n        @constraint(model, v[j] == v[i] + Δt[i] * δv[i])\n        @constraint(model, γ[j] == γ[i] + Δt[i] * δγ[i])\n        @constraint(model, ψ[j] == ψ[i] + Δt[i] * δψ[i])\n    elseif integration_rule == \"trapezoidal\"\n        # Trapezoidal integration\n        @constraint(model, h[j] == h[i] + 0.5 * Δt[i] * (δh[j] + δh[i]))\n        @constraint(model, ϕ[j] == ϕ[i] + 0.5 * Δt[i] * (δϕ[j] + δϕ[i]))\n        @constraint(model, θ[j] == θ[i] + 0.5 * Δt[i] * (δθ[j] + δθ[i]))\n        @constraint(model, v[j] == v[i] + 0.5 * Δt[i] * (δv[j] + δv[i]))\n        @constraint(model, γ[j] == γ[i] + 0.5 * Δt[i] * (δγ[j] + δγ[i]))\n        @constraint(model, ψ[j] == ψ[i] + 0.5 * Δt[i] * (δψ[j] + δψ[i]))\n    else\n        @error \"Unexpected integration rule '$(integration_rule)'\"\n    end\nend\n\n# Objective: Maximize cross-range\n@objective(model, Max, θ[n])\n\nset_silent(model)  # Hide solver's verbose output\noptimize!(model)  # Solve for the control and state\n@assert is_solved_and_feasible(model)\n\n# Show final cross-range of the solution\nprintln(\n    \"Final latitude θ = \",\n    round(objective_value(model) |> rad2deg; digits = 2),\n    \"°\",\n)","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/#Plotting-the-results","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Plotting the results","text":"","category":"section"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"Let's plot the results to visualize the optimal trajectory:","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"using Plots\nts = cumsum([0; value.(Δt)])[1:end-1]\nplt_altitude = plot(\n    ts,\n    value.(scaled_h);\n    legend = nothing,\n    title = \"Altitude (100,000 ft)\",\n)\nplt_longitude =\n    plot(ts, rad2deg.(value.(ϕ)); legend = nothing, title = \"Longitude (deg)\")\nplt_latitude =\n    plot(ts, rad2deg.(value.(θ)); legend = nothing, title = \"Latitude (deg)\")\nplt_velocity = plot(\n    ts,\n    value.(scaled_v);\n    legend = nothing,\n    title = \"Velocity (1000 ft/sec)\",\n)\nplt_flight_path =\n    plot(ts, rad2deg.(value.(γ)); legend = nothing, title = \"Flight Path (deg)\")\nplt_azimuth =\n    plot(ts, rad2deg.(value.(ψ)); legend = nothing, title = \"Azimuth (deg)\")\n\nplot(\n    plt_altitude,\n    plt_velocity,\n    plt_longitude,\n    plt_flight_path,\n    plt_latitude,\n    plt_azimuth;\n    layout = grid(3, 2),\n    linewidth = 2,\n    size = (700, 700),\n)","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"function q(h, v, a)\n    ρ(h) = ρ₀ * exp(-h / hᵣ)\n    qᵣ(h, v) = 17700 * √ρ(h) * (0.0001 * v)^3.07\n    qₐ(a) = c₀ + c₁ * rad2deg(a) + c₂ * rad2deg(a)^2 + c₃ * rad2deg(a)^3\n    # Aerodynamic heating on the vehicle wing leading edge\n    return qₐ(a) * qᵣ(h, v)\nend\n\nplt_attack_angle = plot(\n    ts[1:end-1],\n    rad2deg.(value.(α)[1:end-1]);\n    legend = nothing,\n    title = \"Angle of Attack (deg)\",\n)\nplt_bank_angle = plot(\n    ts[1:end-1],\n    rad2deg.(value.(β)[1:end-1]);\n    legend = nothing,\n    title = \"Bank Angle (deg)\",\n)\nplt_heating = plot(\n    ts,\n    q.(value.(scaled_h) * 1e5, value.(scaled_v) * 1e4, value.(α));\n    legend = nothing,\n    title = \"Heating (BTU/ft/ft/sec)\",\n)\n\nplot(\n    plt_attack_angle,\n    plt_bank_angle,\n    plt_heating;\n    layout = grid(3, 1),\n    linewidth = 2,\n    size = (700, 700),\n)","category":"page"},{"location":"tutorials/nonlinear/space_shuttle_reentry_trajectory/","page":"Optimal control for a Space Shuttle reentry trajectory","title":"Optimal control for a Space Shuttle reentry trajectory","text":"plot(\n    rad2deg.(value.(ϕ)),\n    rad2deg.(value.(θ)),\n    value.(scaled_h);\n    linewidth = 2,\n    legend = nothing,\n    title = \"Space Shuttle Reentry Trajectory\",\n    xlabel = \"Longitude (deg)\",\n    ylabel = \"Latitude (deg)\",\n    zlabel = \"Altitude (100,000 ft)\",\n)","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP, HiGHS\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"background/algebraic_modeling_languages/#algebraic-modeling-language","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"JuMP is an algebraic modeling language for mathematical optimization written in the Julia language. In this page, we explain what an algebraic modeling language actually is.","category":"page"},{"location":"background/algebraic_modeling_languages/#What-is-an-algebraic-modeling-language?","page":"Algebraic modeling languages","title":"What is an algebraic modeling language?","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"If you have taken a class in mixed-integer linear programming, you will have seen a formulation like:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"beginaligned\nmin       c^top x \ntextst  A x = b  \n             x ge 0  \n             x_i in mathbbZ quad forall i in mathcalI\nendaligned","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"where c, A, and b are appropriately sized vectors and matrices of data, and mathcalI denotes the set of variables that are integer.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Solvers expect problems in a standard form like this because it limits the types of constraints that they need to consider. This makes writing a solver much easier.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"info: What is a solver?\nA solver is a software package that computes solutions to one or more classes of problems.For example, HiGHS is a solver for linear programming (LP) and mixed integer programming (MIP) problems. It incorporates algorithms such as the simplex method and the interior-point method.JuMP currently supports a number of open-source and commercial solvers, which can be viewed in the Supported-solvers table.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Despite the textbook view of a linear program, you probably formulated problems algebraically like so:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"beginaligned\nmax       sumlimits_i = 1^n c_i x_i                   \ntextst  sumlimits_i = 1^n w_i x_i le b             \n             x_i ge 0 quad forall i = 1ldotsn          \n             x_i in mathbbZ quad forall i = 1ldotsn\nendaligned","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"info: Info\nDo you recognize this formulation? It's the knapsack problem.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Users prefer to write problems in algebraic form because it is more convenient. For example, we used le b, even though the standard form only supported constraints of the form Ax = b.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"We could convert our knapsack problem into the standard form by adding a new slack variable x_0:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"beginaligned\nmax       sumlimits_i = 1^n c_i x_i            \ntextst  x_0 + sumlimits_i = 1^n w_i x_i = b  \n             x_i ge 0 quad forall i = 0ldotsn   \n             x_i in mathbbZ quad forall i = 1ldotsn\nendaligned","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"However, as models get more complicated, this manual conversion becomes more and more error-prone.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"An algebraic modeling language is a tool that simplifies the translation between the algebraic form of the modeler, and the standard form of the solver.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Each algebraic modeling language has two main parts:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"A domain specific language for the user to write down problems in algebraic form.\nA converter from the algebraic form into a standard form supported by the solver (and back again).","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Part 2 is less trivial than it might seem, because each solver has a unique application programming interface (API) and data structure for representing optimization models and obtaining results.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"JuMP uses the MathOptInterface.jl package to abstract these differences between solvers.","category":"page"},{"location":"background/algebraic_modeling_languages/#What-is-MathOptInterface?","page":"Algebraic modeling languages","title":"What is MathOptInterface?","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"MathOptInterface (MOI) is an abstraction layer designed to provide an interface to mathematical optimization solvers so that users do not need to understand multiple solver-specific APIs. MOI can be used directly, or through a higher-level modeling interface like JuMP.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"There are three main parts to MathOptInterface:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"A solver-independent API that abstracts concepts such as adding and deleting variables and constraints, setting and getting parameters, and querying results. For more information on the MathOptInterface API, read the documentation.\nAn automatic rewriting system based on equivalent formulations of a constraint. For more information on this rewriting system, read the LazyBridgeOptimizer section of the manual, and our paper on arXiv.\nUtilities for managing how and when models are copied to solvers. For more information on this, read the CachingOptimizer section of the manual.","category":"page"},{"location":"background/algebraic_modeling_languages/#From-user-to-solver","page":"Algebraic modeling languages","title":"From user to solver","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"This section provides a brief summary of the steps that happen in order to translate the model that the user writes into a model that the solver understands.","category":"page"},{"location":"background/algebraic_modeling_languages/#Step-I:-writing-in-algebraic-form","page":"Algebraic modeling languages","title":"Step I: writing in algebraic form","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"JuMP provides the first part of an algebraic modeling language using the @variable, @objective, and @constraint macros.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"For example, here's how we write the knapsack problem in JuMP:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"julia> using JuMP, HiGHS\n\njulia> function algebraic_knapsack(c, w, b)\n           n = length(c)\n           model = Model(HiGHS.Optimizer)\n           set_silent(model)\n           @variable(model, x[1:n] >= 0, Int)\n           @objective(model, Max, sum(c[i] * x[i] for i = 1:n))\n           @constraint(model, sum(w[i] * x[i] for i = 1:n) <= b)\n           optimize!(model)\n           if termination_status(model) != OPTIMAL\n               error(\"Not solved correctly\")\n           end\n           return value.(x)\n       end\nalgebraic_knapsack (generic function with 1 method)\n\njulia> algebraic_knapsack([1, 2], [0.5, 0.5], 1.25)\n2-element Vector{Float64}:\n 0.0\n 2.0","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"This formulation is compact, and it closely matches the algebraic formulation of the model we wrote out above.","category":"page"},{"location":"background/algebraic_modeling_languages/#Step-II:-algebraic-to-functional","page":"Algebraic modeling languages","title":"Step II: algebraic to functional","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"For the next step, JuMP's macros re-write the variables and constraints into a functional form. Here's what the JuMP code looks like after this step:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"julia> using JuMP, HiGHS\n\njulia> function nonalgebraic_knapsack(c, w, b)\n           n = length(c)\n           model = Model(HiGHS.Optimizer)\n           set_silent(model)\n           x = [VariableRef(model) for i = 1:n]\n           for i = 1:n\n               set_lower_bound(x[i], 0)\n               set_integer(x[i])\n               set_name(x[i], \"x[$i]\")\n           end\n           obj = AffExpr(0.0)\n           for i = 1:n\n               add_to_expression!(obj, c[i], x[i])\n           end\n           set_objective(model, MAX_SENSE, obj)\n           lhs = AffExpr(0.0)\n           for i = 1:n\n               add_to_expression!(lhs, w[i], x[i])\n           end\n           con = build_constraint(error, lhs, MOI.LessThan(b))\n           add_constraint(model, con)\n           optimize!(model)\n           if termination_status(model) != OPTIMAL\n               error(\"Not solved correctly\")\n           end\n           return value.(x)\n       end\nnonalgebraic_knapsack (generic function with 1 method)\n\njulia> nonalgebraic_knapsack([1, 2], [0.5, 0.5], 1.25)\n2-element Vector{Float64}:\n 0.0\n 2.0","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Hopefully you agree that the macro version is much easier to read.","category":"page"},{"location":"background/algebraic_modeling_languages/#Part-III:-JuMP-to-MathOptInterface","page":"Algebraic modeling languages","title":"Part III: JuMP to MathOptInterface","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"In the third step, JuMP converts the functional form of the problem, that is, nonalgebraic_knapsack, into the MathOptInterface API:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"julia> import MathOptInterface as MOI\n\njulia> import HiGHS\n\njulia> function mathoptinterface_knapsack(optimizer, c, w, b)\n           n = length(c)\n           model = MOI.instantiate(optimizer)\n           MOI.set(model, MOI.Silent(), true)\n           x = MOI.add_variables(model, n)\n           for i in 1:n\n               MOI.add_constraint(model, x[i], MOI.GreaterThan(0.0))\n               MOI.add_constraint(model, x[i], MOI.Integer())\n               MOI.set(model, MOI.VariableName(), x[i], \"x[$i]\")\n           end\n           MOI.set(model, MOI.ObjectiveSense(), MOI.MAX_SENSE)\n           obj = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(c, x), 0.0)\n           MOI.set(model, MOI.ObjectiveFunction{typeof(obj)}(), obj)\n           MOI.add_constraint(\n               model,\n               MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(w, x), 0.0),\n               MOI.LessThan(b),\n           )\n           MOI.optimize!(model)\n           if MOI.get(model, MOI.TerminationStatus()) != MOI.OPTIMAL\n               error(\"Not solved correctly\")\n           end\n           return MOI.get.(model, MOI.VariablePrimal(), x)\n       end\nmathoptinterface_knapsack (generic function with 1 method)\n\njulia> mathoptinterface_knapsack(HiGHS.Optimizer, [1.0, 2.0], [0.5, 0.5], 1.25)\n2-element Vector{Float64}:\n 0.0\n 2.0","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"The code is becoming more verbose and looking less like the mathematical formulation that we started with.","category":"page"},{"location":"background/algebraic_modeling_languages/#Step-IV:-MathOptInterface-to-HiGHS","page":"Algebraic modeling languages","title":"Step IV: MathOptInterface to HiGHS","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"As a final step, the HiGHS.jl package converts the MathOptInterface form, that is, mathoptinterface_knapsack, into a HiGHS-specific API:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"julia> using HiGHS\n\njulia> function highs_knapsack(c, w, b)\n           n = length(c)\n           model = Highs_create()\n           Highs_setBoolOptionValue(model, \"output_flag\", false)\n           for i in 1:n\n               Highs_addCol(model, c[i], 0.0, Inf, 0, C_NULL, C_NULL)\n               Highs_changeColIntegrality(model, i-1, 1)\n           end\n           Highs_changeObjectiveSense(model, -1)\n           Highs_addRow(\n               model,\n               -Inf,\n               b,\n               Cint(length(w)),\n               collect(Cint(0):Cint(n-1)),\n               w,\n           )\n           Highs_run(model)\n           if Highs_getModelStatus(model) != kHighsModelStatusOptimal\n               error(\"Not solved correctly\")\n           end\n           x = fill(NaN, 2)\n           Highs_getSolution(model, x, C_NULL, C_NULL, C_NULL)\n           Highs_destroy(model)\n           return x\n       end\nhighs_knapsack (generic function with 1 method)\n\njulia> highs_knapsack([1.0, 2.0], [0.5, 0.5], 1.25)\n2-element Vector{Float64}:\n 0.0\n 2.0","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"We've now gone from a algebraic model that looked identical to the mathematical model we started with, to a verbose function that uses HiGHS-specific functionality.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"The difference between algebraic_knapsack and highs_knapsack highlights the benefit that algebraic modeling languages provide to users. Moreover, if we used a different solver, the solver-specific function would be entirely different. A key benefit of an algebraic modeling language is that you can change the solver without needing to rewrite the model.","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"EditURL = \"https://github.com/jump-dev/AmplNLWriter.jl/blob/v1.2.1/README.md\"","category":"page"},{"location":"packages/AmplNLWriter/#AmplNLWriter.jl","page":"jump-dev/AmplNLWriter.jl","title":"AmplNLWriter.jl","text":"","category":"section"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"(Image: Build Status) (Image: MINLPTests) (Image: codecov)","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"AmplNLWriter.jl is an interface between MathOptInterface.jl and AMPL-enabled solvers.","category":"page"},{"location":"packages/AmplNLWriter/#Affiliation","page":"jump-dev/AmplNLWriter.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"This wrapper is maintained by the JuMP community and has no official connection with the AMPL modeling language or AMPL Optimization Inc.","category":"page"},{"location":"packages/AmplNLWriter/#Installation","page":"jump-dev/AmplNLWriter.jl","title":"Installation","text":"","category":"section"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"Install AmplNLWriter using Pkg.add:","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"import Pkg\nPkg.add(\"AmplNLWriter\")","category":"page"},{"location":"packages/AmplNLWriter/#Use-with-JuMP","page":"jump-dev/AmplNLWriter.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"AmplNLWriter requires an AMPL compatible solver binary to function.","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"Pass a string pointing to any AMPL-compatible solver binary as the first positional argument to AmplNLWriter.","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"For example, if the bonmin executable is on the system path, use:","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"using JuMP, AmplNLWriter\nmodel = Model(() -> AmplNLWriter.Optimizer(\"bonmin\"))","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"If the solver is not on the system path, pass the full path to the solver:","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"using JuMP, AmplNLWriter\nmodel = Model(() -> AmplNLWriter.Optimizer(\"/Users/Oscar/ampl.macos64/bonmin\"))","category":"page"},{"location":"packages/AmplNLWriter/#Precompiled-binaries","page":"jump-dev/AmplNLWriter.jl","title":"Precompiled binaries","text":"","category":"section"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"To simplify the process of installing solver binaries, a number of Julia packages provide precompiled binaries that are compatible with AmplNLWriter. These are generally the name of the solver, followed by _jll. For example, bomin is provided by the Bonmin_jll package.","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"To call Bonmin via AmplNLWriter.jl, install the Bonmin_jll package, then run:","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"using JuMP, AmplNLWriter, Bonmin_jll\nmodel = Model(() -> AmplNLWriter.Optimizer(Bonmin_jll.amplexe))","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"Supported packages include:","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"Solver Julia Package Executable\nBonmin Bonmin_jll.jl Bomin_jll.amplexe\nCouenne Couenne_jll.jl Couenne_jll.amplexe\nIpopt Ipopt_jll.jl Ipopt_jll.amplexe\nSHOT SHOT_jll.jl SHOT_jll.amplexe\nKNITRO KNITRO.jl KNITRO.amplexe","category":"page"},{"location":"packages/AmplNLWriter/#MathOptInterface-API","page":"jump-dev/AmplNLWriter.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"The AmplNLWriter optimizer supports the following constraints and attributes.","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"List of supported objective functions:","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}\nMOI.ObjectiveFunction{MOI.ScalarNonlinearFunction}\nMOI.ObjectiveFunction{MOI.ScalarQuadraticFunction{Float64}}\nMOI.ObjectiveFunction{MOI.VariableIndex}","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"MOI.Reals","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"MOI.ScalarAffineFunction{Float64} in MOI.EqualTo{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.Interval{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.LessThan{Float64}\nMOI.ScalarNonlinearFunction in MOI.EqualTo{Float64}\nMOI.ScalarNonlinearFunction in MOI.GreaterThan{Float64}\nMOI.ScalarNonlinearFunction in MOI.Interval{Float64}\nMOI.ScalarNonlinearFunction in MOI.LessThan{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.EqualTo{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.Interval{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.EqualTo{Float64}\nMOI.VariableIndex in MOI.GreaterThan{Float64}\nMOI.VariableIndex in MOI.Integer\nMOI.VariableIndex in MOI.Interval{Float64}\nMOI.VariableIndex in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.ZeroOne","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"MOI.NLPBlock()\nMOI.Name()\nMOI.ObjectiveSense()","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"Note that some solver executables may not support the full list of constraint types. For example, Ipopt_jll does not support MOI.Integer or MOI.ZeroOne constraints.","category":"page"},{"location":"packages/AmplNLWriter/#Options","page":"jump-dev/AmplNLWriter.jl","title":"Options","text":"","category":"section"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"A list of available options for each solver can be found here:","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"Bonmin (plus Ipopt options)\nCouenne (plus Ipopt and Bonmin options)\nIpopt\nSHOT","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"Set an option using set_attribute. For example, to set the \"bonmin.nlp_log_level\" option to 0 in Bonmin, use:","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"using JuMP\nimport AmplNLWriter\nimport Bonmin_jll\nmodel = Model(() -> AmplNLWriter.Optimizer(Bonmin_jll.amplexe))\nset_attribute(model, \"bonmin.nlp_log_level\", 0)","category":"page"},{"location":"packages/AmplNLWriter/#opt-files","page":"jump-dev/AmplNLWriter.jl","title":"opt files","text":"","category":"section"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"Some options need to be specified via an .opt file.","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"This file must be located in the current working directory whenever the model is solved.","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"The .opt file must be named after the name of the solver, for example, bonmin.opt, and each line must contain an option name and the desired value, separated by a space.","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"For example, to set the absolute and relative tolerances in Couenne to 1 and 0.05 respectively, the couenne.opt file should contain:","category":"page"},{"location":"packages/AmplNLWriter/","page":"jump-dev/AmplNLWriter.jl","title":"jump-dev/AmplNLWriter.jl","text":"allowable_gap 1\nallowable_fraction_gap 0.05","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<img class=\"display-light-only\" src=\"assets/logo-with-text.svg\" alt=\"JuMP logo\"/>\n<img class=\"display-dark-only\" src=\"assets/logo-dark-with-text.svg\" alt=\"JuMP logo\"/>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"# These comments do not display in the HTML output.\n# See https://github.com/JuliaDocs/Documenter.jl/issues/674.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"\\begin{figure}[h]\n  \\includegraphics[width=0.5\\textwidth]{assets/logo-with-text.pdf}\n\\end{figure}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the documentation for JuMP.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nThis documentation is also available in PDF format: JuMP.pdf.","category":"page"},{"location":"#What-is-JuMP?","page":"Introduction","title":"What is JuMP?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP is a domain-specific modeling language for mathematical optimization embedded in Julia. It currently supports a number of open-source and commercial solvers for a variety of problem classes, including linear, mixed-integer, second-order conic, semidefinite, and nonlinear programming.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Tip\nIf you aren't sure if you should use JuMP, read Should you use JuMP?.","category":"page"},{"location":"#Resources-for-getting-started","page":"Introduction","title":"Resources for getting started","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There are a few ways to get started with JuMP:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Read the Installation Guide.\nRead the introductory tutorials Getting started with Julia and Getting started with JuMP.\nBrowse some of our modeling tutorials, including classics such as The diet problem, or the Maximum likelihood estimation problem using nonlinear programming.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Tip\nNeed help? Join the community forum to search for answers to commonly asked questions.Before asking a question, make sure to read the post make it easier to help you, which contains a number of tips on how to ask a good question.","category":"page"},{"location":"#How-the-documentation-is-structured","page":"Introduction","title":"How the documentation is structured","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Having a high-level overview of how this documentation is structured will help you know where to look for certain things.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Tutorials contain worked examples of solving problems with JuMP. Start here if you are new to JuMP, or you have a particular problem class you want to model.\nThe Manual contains short code-snippets that explain how to achieve specific tasks in JuMP. Look here if you want to know how to achieve a particular task, such as how to Delete a variable or how to Modify an objective coefficient.\nThe API Reference contains a complete list of the functions you can use in JuMP. Look here if you want to know how to use a particular function.\nThe Background information section contains background reading material to provide context to JuMP. Look here if you want an understanding of what JuMP is and why we created it, rather than how to use it.\nThe Developer docs section contains information for people contributing to JuMP development or writing JuMP extensions. Don't worry about this section if you are using JuMP to formulate and solve problems as a user.\nThe MathOptInterface section is a self-contained copy of the documentation for MathOptInterface. Look here for functions and constants beginning with MOI., as well as for general information on how MathOptInterface works.","category":"page"},{"location":"#Citing-JuMP","page":"Introduction","title":"Citing JuMP","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you find JuMP useful in your work, we kindly request that you cite the following paper (preprint):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@article{Lubin2023,\n    author = {Miles Lubin and Oscar Dowson and Joaquim {Dias Garcia} and Joey Huchette and Beno{\\^i}t Legat and Juan Pablo Vielma},\n    title = {{JuMP} 1.0: {R}ecent improvements to a modeling language for mathematical optimization},\n    journal = {Mathematical Programming Computation},\n    year = {2023},\n    doi = {10.1007/s12532-023-00239-3}\n}","category":"page"},{"location":"#NumFOCUS","page":"Introduction","title":"NumFOCUS","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: NumFOCUS logo)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP is a Sponsored Project of NumFOCUS, a 501(c)(3) nonprofit charity in the United States. NumFOCUS provides JuMP with fiscal, legal, and administrative support to help ensure the health and sustainability of the project. Visit numfocus.org for more information.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can support JuMP by donating.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Donations to JuMP are managed by NumFOCUS. For donors in the United States, your gift is tax-deductible to the extent provided by law. As with any donation, you should consult with your tax adviser about your particular tax situation.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP's largest expense is the annual JuMP-dev workshop. Donations will help us provide travel support for JuMP-dev attendees and take advantage of other opportunities that arise to support JuMP development.","category":"page"},{"location":"#License","page":"Introduction","title":"License","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP is licensed under the MPL-2.0 software license. Consult the license and the Mozilla FAQ for more information. In addition, JuMP is typically used in conjunction with solver packages and extensions which have their own licences. Consult their package repositories for the specific licenses that apply.","category":"page"},{"location":"packages/InfiniteOpt/","page":"infiniteopt/InfiniteOpt.jl","title":"infiniteopt/InfiniteOpt.jl","text":"EditURL = \"https://github.com/infiniteopt/InfiniteOpt.jl/blob/v0.5.9/docs/jump/README.md\"","category":"page"},{"location":"packages/InfiniteOpt/","page":"infiniteopt/InfiniteOpt.jl","title":"infiniteopt/InfiniteOpt.jl","text":"(Image: Logo)","category":"page"},{"location":"packages/InfiniteOpt/","page":"infiniteopt/InfiniteOpt.jl","title":"infiniteopt/InfiniteOpt.jl","text":"InfiniteOpt.jl is a JuMP extension for expressing and solving infinite-dimensional optimization problems. Such areas include stochastic programming, dynamic programming, space-time optimization, and more. InfiniteOpt serves as an easy-to-use modeling interface for these advanced problem types that can be used by those with little background in these areas. It also it contains a wealth of capabilities making it a powerful and convenient tool for advanced users.  ","category":"page"},{"location":"packages/InfiniteOpt/","page":"infiniteopt/InfiniteOpt.jl","title":"infiniteopt/InfiniteOpt.jl","text":"Current Version Documentation Build Status Citation\n(Image: ) (Image: ) (Image: Build Status) (Image: codecov.io) (Image: DOI)","category":"page"},{"location":"packages/InfiniteOpt/","page":"infiniteopt/InfiniteOpt.jl","title":"infiniteopt/InfiniteOpt.jl","text":"InfiniteOpt builds upon JuMP to add support for many complex modeling objects which  include:","category":"page"},{"location":"packages/InfiniteOpt/","page":"infiniteopt/InfiniteOpt.jl","title":"infiniteopt/InfiniteOpt.jl","text":"Infinite parameters (for example, time, space, and/or uncertainty)\nFinite parameters (similar to ParameterJuMP)\nInfinite variables (decision functions) (for example, y(t x))\nDerivatives (for example, fracpartial y(t x)partial t)\nMeasures (for example, int_t in Ty(t x)dt and mathbbEy(xi))\nFirst class nonlinear modeling","category":"page"},{"location":"packages/InfiniteOpt/","page":"infiniteopt/InfiniteOpt.jl","title":"infiniteopt/InfiniteOpt.jl","text":"The unifying modeling abstraction behind InfiniteOpt captures a wide spectrum  of disciplines which include dynamic, PDE, stochastic, and semi-infinite  optimization. Moreover, we facilitate transferring techniques between these  to synthesize new optimization paradigms.","category":"page"},{"location":"packages/InfiniteOpt/#License","page":"infiniteopt/InfiniteOpt.jl","title":"License","text":"","category":"section"},{"location":"packages/InfiniteOpt/","page":"infiniteopt/InfiniteOpt.jl","title":"infiniteopt/InfiniteOpt.jl","text":"InfiniteOpt is licensed under the MIT \"Expat\" license.","category":"page"},{"location":"packages/InfiniteOpt/#Installation","page":"infiniteopt/InfiniteOpt.jl","title":"Installation","text":"","category":"section"},{"location":"packages/InfiniteOpt/","page":"infiniteopt/InfiniteOpt.jl","title":"infiniteopt/InfiniteOpt.jl","text":"InfiniteOpt.jl is a registered Julia package and  can be installed by entering the following in the REPL.","category":"page"},{"location":"packages/InfiniteOpt/","page":"infiniteopt/InfiniteOpt.jl","title":"infiniteopt/InfiniteOpt.jl","text":"julia> import Pkg; Pkg.add(\"InfiniteOpt\")","category":"page"},{"location":"packages/InfiniteOpt/#Documentation","page":"infiniteopt/InfiniteOpt.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/InfiniteOpt/","page":"infiniteopt/InfiniteOpt.jl","title":"infiniteopt/InfiniteOpt.jl","text":"Please visit our documentation pages  to learn more. These pages are quite extensive and feature overviews, guides, manuals, tutorials, examples, and more.","category":"page"},{"location":"packages/InfiniteOpt/#Questions","page":"infiniteopt/InfiniteOpt.jl","title":"Questions","text":"","category":"section"},{"location":"packages/InfiniteOpt/","page":"infiniteopt/InfiniteOpt.jl","title":"infiniteopt/InfiniteOpt.jl","text":"For additional help please visit and post in our  discussion forum.","category":"page"},{"location":"packages/InfiniteOpt/#Citing","page":"infiniteopt/InfiniteOpt.jl","title":"Citing","text":"","category":"section"},{"location":"packages/InfiniteOpt/","page":"infiniteopt/InfiniteOpt.jl","title":"infiniteopt/InfiniteOpt.jl","text":"(Image: DOI)  (Image: DOI)","category":"page"},{"location":"packages/InfiniteOpt/","page":"infiniteopt/InfiniteOpt.jl","title":"infiniteopt/InfiniteOpt.jl","text":"If you use InfiniteOpt.jl in your research, we would greatly appreciate your  citing it.","category":"page"},{"location":"packages/InfiniteOpt/","page":"infiniteopt/InfiniteOpt.jl","title":"infiniteopt/InfiniteOpt.jl","text":"@article{pulsipher2022unifying,\n      title = {A unifying modeling abstraction for infinite-dimensional optimization},\n      journal = {Computers & Chemical Engineering},\n      volume = {156},\n      year = {2022},\n      issn = {0098-1354},\n      doi = {https://doi.org/10.1016/j.compchemeng.2021.107567},\n      url = {https://www.sciencedirect.com/science/article/pii/S0098135421003458},\n      author = {Joshua L. Pulsipher and Weiqi Zhang and Tyler J. Hongisto and Victor M. Zavala},\n}","category":"page"},{"location":"packages/InfiniteOpt/","page":"infiniteopt/InfiniteOpt.jl","title":"infiniteopt/InfiniteOpt.jl","text":"A pre-print version is freely available though arXiv.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"EditURL = \"getting_started_with_sets_and_indexing.jl\"","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Getting-started-with-sets-and-indexing","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Most introductory courses to linear programming will teach you to identify sets over which the decision variables and constraints are indexed. Therefore, it is common to write variables such as x_i for all i in I.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"A common stumbling block for new users to JuMP is that JuMP does not provide specialized syntax for constructing and manipulating these sets.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"We made this decision because Julia already provides a wealth of data structures for working with sets.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"In contrast, because tools like AMPL are stand-alone software packages, they had to define their own syntax for set construction and manipulation. Indeed, the AMPL Book has two entire chapters devoted to sets and indexing (Chapter 5, \"Simple Sets and Indexing,\" and Chapter 6, \"Compound Sets and Indexing\").","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"The purpose of this tutorial is to demonstrate a variety of ways in which you can construct and manipulate sets for optimization models.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"If you haven't already, you should first read Getting started with JuMP.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"using JuMP","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Unordered-sets","page":"Getting started with sets and indexing","title":"Unordered sets","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Unordered sets are useful to describe non-numeric indices, such as the names of cities or types of products.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"The most common way to construct a set is by creating a vector:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"animals = [\"dog\", \"cat\", \"chicken\", \"cow\", \"pig\"]\nmodel = Model()\n@variable(model, x[animals])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"We can also use things like the keys of a dictionary:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"weight_of_animals = Dict(\n    \"dog\" => 20.0,\n    \"cat\" => 5.0,\n    \"chicken\" => 2.0,\n    \"cow\" => 720.0,\n    \"pig\" => 150.0,\n)\nanimal_keys = keys(weight_of_animals)\nmodel = Model()\n@variable(model, x[animal_keys])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"A third option is to use Julia's Set object.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"animal_set = Set()\nfor animal in keys(weight_of_animals)\n    push!(animal_set, animal)\nend\nanimal_set","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"The nice thing about Sets is that they automatically remove duplicates:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"push!(animal_set, \"dog\")\nanimal_set","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Note how dog does not appear twice.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"model = Model()\n@variable(model, x[animal_set])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Sets-of-numbers","page":"Getting started with sets and indexing","title":"Sets of numbers","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Sets of numbers are useful to describe sets that are ordered, such as years or elements in a vector. The easiest way to create sets of numbers is to use Julia's range syntax.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"These can start at 1:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"model = Model()\n@variable(model, x[1:4])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"but they don't have to:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"model = Model()\n@variable(model, x[2012:2021])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Ranges also have a start:step:stop syntax. So the Olympic years are:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"model = Model()\n@variable(model, x[1896:4:2020])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Sets-of-other-things","page":"Getting started with sets and indexing","title":"Sets of other things","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"An important observation is that you can have any Julia type as the element of a set. It doesn't have to be a String or a Number. For example, you can have tuples:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"sources = [\"A\", \"B\", \"C\"]\nsinks = [\"D\", \"E\"]\nS = [(source, sink) for source in sources, sink in sinks]\nmodel = Model()\n@variable(model, x[S])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"x[(\"A\", \"D\")]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"For multi-dimensional sets, you can use JuMP's syntax for constructing Containers:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"model = Model()\n@variable(model, x[sources, sinks])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"x[\"A\", \"D\"]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"info: Info\nNote how we indexed x[\"A\", \"D\"] instead of x[(\"A\", \"D\")] as above.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Sets-to-watch-out-for","page":"Getting started with sets and indexing","title":"Sets to watch out for","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"JuMP supports any sets which are iterable, that is, the set set supports a for-loop like: [i for i in set]. This causes a few common errors.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"First, if T = 3, you may pass the integer T by mistake instead of a range like 1:T:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"model = Model()\nT = 3\n@variable(model, x[T])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"This results in a single variable being created, instead of three as desired. Because this is a common error, a warning is printed, advising you to pass a Vector{Int} instead:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"@variable(model, x_fixed[[T]])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Second, because Strings are iterable, passing a \"index\" as a singleton index is the same as passing ['i', 'n', 'd', 'e', 'x']:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"@variable(model, y[\"index\"])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"This time, a warning is not printed, but the work-around is similar, pass a Vector{String} instead:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"@variable(model, y_fixed[[\"index\"]])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"tip: Tip\nAs a rule of thumb, if you want an index with one element, avoid confusion by passing [index] instead of index.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Set-operations","page":"Getting started with sets and indexing","title":"Set operations","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Julia has built-in support for set operations such as union, intersect, and setdiff.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Therefore, to create a set of all years in which the summer Olympics were held, we can use:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"baseline = 1896:4:2020\ncancelled = [1916, 1940, 1944, 2020]\noff_year = [2021]\nolympic_years = union(setdiff(baseline, cancelled), off_year)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"You can also find the number of elements (that is, the cardinality) in a set using length:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"length(olympic_years)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Set-membership-operations","page":"Getting started with sets and indexing","title":"Set membership operations","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"To compute membership of sets, use the in function.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"2000 in olympic_years","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"2001 in olympic_years","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Indexing-expressions","page":"Getting started with sets and indexing","title":"Indexing expressions","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Use Julia's generator syntax to compute new sets, such as the list of Olympic years that are divisible by 3:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"olympic_3_years = [year for year in olympic_years if mod(year, 3) == 0]\nmodel = Model()\n@variable(model, x[olympic_3_years])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Alternatively, use JuMP's syntax for constructing Containers:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"model = Model()\n@variable(model, x[year in olympic_years; mod(year, 3) == 0])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Compound-sets","page":"Getting started with sets and indexing","title":"Compound sets","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Consider a transportation problem in which we need to ship goods between cities. We have been provided a list of cities:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"cities = [\"Auckland\", \"Wellington\", \"Christchurch\", \"Dunedin\"]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"and a distance matrix which records the shipping distance between pairs of cities. If we can't ship between two cities, the distance is 0.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"distances = [0 643 1071 1426; 0 0 436 790; 0 0 0 360; 1426 0 0 0]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Let's have a look at ways we could write a model with an objective function to minimize the total shipping cost. For simplicity, we'll ignore all constraints.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Fix-unused-variables","page":"Getting started with sets and indexing","title":"Fix unused variables","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"One approach is to fix all variables that we can't use to zero. Most solvers are smart-enough to remove these during a presolve phase, so it has a very small impact on performance:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"N = length(cities)\nmodel = Model()\n@variable(model, x[1:N, 1:N] >= 0)\nfor i in 1:N, j in 1:N\n    if distances[i, j] == 0\n        fix(x[i, j], 0.0; force = true)\n    end\nend\n@objective(model, Min, sum(distances[i, j] * x[i, j] for i in 1:N, j in 1:N))","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Filtered-summation","page":"Getting started with sets and indexing","title":"Filtered summation","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Another approach is to define filters whenever we want to sum over our decision variables:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"N = length(cities)\nmodel = Model()\n@variable(model, x[1:N, 1:N] >= 0)\n@objective(\n    model,\n    Min,\n    sum(\n        distances[i, j] * x[i, j] for i in 1:N, j in 1:N if distances[i, j] > 0\n    ),\n)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Filtered-indexing","page":"Getting started with sets and indexing","title":"Filtered indexing","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"We could also use JuMP's support for Containers:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"N = length(cities)\nmodel = Model()\n@variable(model, x[i = 1:N, j = 1:N; distances[i, j] > 0])\n@objective(model, Min, sum(distances[i...] * x[i] for i in eachindex(x)))","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"note: Note\nThe i... is called  a \"splat.\" It converts a tuple like (1, 2) into two indices like distances[1, 2].","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Converting-to-a-different-data-structure","page":"Getting started with sets and indexing","title":"Converting to a different data structure","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Another approach, and one that is often the most readable, is to convert the data you have into something that is easier to work with. Originally, we had a vector of strings and a matrix of distances. What we really need is something that maps usable origin-destination pairs to distances. A dictionary is an obvious choice:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"routes = Dict(\n    (a, b) => distances[i, j] for\n    (i, a) in enumerate(cities), (j, b) in enumerate(cities) if\n    distances[i, j] > 0\n)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Then, we can create our model like so:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"model = Model()\n@variable(model, x[keys(routes)])\n@objective(model, Min, sum(v * x[k] for (k, v) in routes))","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"This has a number of benefits over the other approaches, including a compacter algebraic model and variables that are named in a more meaningful way.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"tip: Tip\nIf you're struggling to formulate a problem using the available syntax in JuMP, it's probably a sign that you should convert your data into a different form.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/#Next-steps","page":"Getting started with sets and indexing","title":"Next steps","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"The purpose of this tutorial was to show how JuMP does not have specialized syntax for set creation and manipulation. Instead, you should use the tools provided by Julia itself.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"This is both an opportunity and a challenge, because you are free to pick the syntax and data structures that best suit your problem, but for new users it can be daunting to decide which structure to use.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_sets_and_indexing/","page":"Getting started with sets and indexing","title":"Getting started with sets and indexing","text":"Read through some of the other JuMP tutorials to get inspiration and ideas for how you can use Julia's syntax and data structures to your advantage.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"EditURL = \"https://github.com/jump-dev/Gurobi.jl/blob/v1.2.3/README.md\"","category":"page"},{"location":"packages/Gurobi/#Gurobi.jl","page":"jump-dev/Gurobi.jl","title":"Gurobi.jl","text":"","category":"section"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"Gurobi.jl is a wrapper for the Gurobi Optimizer.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"It has two components:","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"a thin wrapper around the complete C API\nan interface to MathOptInterface","category":"page"},{"location":"packages/Gurobi/#Affiliation","page":"jump-dev/Gurobi.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"This wrapper is maintained by the JuMP community with help from Gurobi.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"If you encounter a problem with this interface, please either open an issue in this repository directly or create a topic in the Julia Discourse with the gurobi tag.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"If you encounter a problem with the Gurobi solver, please post in Gurobi’s Community Forum, or if you are a commercial customer, please contact Gurobi directly through the Gurobi Help Center.","category":"page"},{"location":"packages/Gurobi/#License","page":"jump-dev/Gurobi.jl","title":"License","text":"","category":"section"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"Gurobi.jl is licensed under the MIT License.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"The underlying solver is a closed-source commercial product for which you must obtain a license.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"Free Gurobi licenses are available for academics and students.","category":"page"},{"location":"packages/Gurobi/#Installation","page":"jump-dev/Gurobi.jl","title":"Installation","text":"","category":"section"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"First, obtain a license of Gurobi and install Gurobi solver.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"Then, set the GUROBI_HOME environment variable as appropriate and run Pkg.add(\"Gurobi\"):","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"# On Windows, this might be\nENV[\"GUROBI_HOME\"] = \"C:\\\\Program Files\\\\gurobi1100\\\\win64\"\n# ... or perhaps ...\nENV[\"GUROBI_HOME\"] = \"C:\\\\gurobi1100\\\\win64\"\n# On Mac, this might be\nENV[\"GUROBI_HOME\"] = \"/Library/gurobi1100/mac64\"\n\nimport Pkg\nPkg.add(\"Gurobi\")","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"Note: your path may differ. Check which folder you installed Gurobi in, and update the path accordingly.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"By default, building Gurobi.jl will fail if the Gurobi library is not found. This may not be desirable in certain cases, for example when part of a package's test suite uses Gurobi as an optional test dependency, but Gurobi cannot be installed on a CI server running the test suite. To support this use case, the GUROBI_JL_SKIP_LIB_CHECK environment variable may be set (to any value) to make Gurobi.jl installable (but not usable).","category":"page"},{"location":"packages/Gurobi/#Use-with-JuMP","page":"jump-dev/Gurobi.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"To use Gurobi with JuMP, use Gurobi.Optimizer:","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"using JuMP, Gurobi\nmodel = Model(Gurobi.Optimizer)\nset_attribute(model, \"TimeLimit\", 100)\nset_attribute(model, \"Presolve\", 0)","category":"page"},{"location":"packages/Gurobi/#MathOptInterface-API","page":"jump-dev/Gurobi.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"The Gurobi optimizer supports the following constraints and attributes.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"List of supported objective functions:","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}\nMOI.ObjectiveFunction{MOI.ScalarQuadraticFunction{Float64}}\nMOI.ObjectiveFunction{MOI.VariableIndex}\nMOI.ObjectiveFunction{MOI.VectorAffineFunction{Float64}}","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"MOI.Reals","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"MOI.ScalarAffineFunction{Float64} in MOI.EqualTo{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.LessThan{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.EqualTo{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.EqualTo{Float64}\nMOI.VariableIndex in MOI.GreaterThan{Float64}\nMOI.VariableIndex in MOI.Integer\nMOI.VariableIndex in MOI.Interval{Float64}\nMOI.VariableIndex in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.Semicontinuous{Float64}\nMOI.VariableIndex in MOI.Semiinteger{Float64}\nMOI.VariableIndex in MOI.ZeroOne\nMOI.VectorOfVariables in MOI.SOS1{Float64}\nMOI.VectorOfVariables in MOI.SOS2{Float64}\nMOI.VectorOfVariables in MOI.SecondOrderCone\nMOI.VectorAffineFunction in MOI.Indicator","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"MOI.HeuristicCallback()\nMOI.LazyConstraintCallback()\nMOI.Name()\nMOI.ObjectiveSense()\nMOI.UserCutCallback()","category":"page"},{"location":"packages/Gurobi/#Options","page":"jump-dev/Gurobi.jl","title":"Options","text":"","category":"section"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"See the Gurobi Documentation for a list and description of allowable parameters.","category":"page"},{"location":"packages/Gurobi/#C-API","page":"jump-dev/Gurobi.jl","title":"C API","text":"","category":"section"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"The C API can be accessed via Gurobi.GRBxx functions, where the names and arguments are identical to the C API.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"See the Gurobi documentation for details.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"As general rules when converting from Julia to C:","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"When Gurobi requires the column index of a variable x, use Gurobi.c_column(model, x)\nWhen Gurobi requires a Ptr{T} that holds one element, like double *, use a Ref{T}().\nWhen Gurobi requires a Ptr{T} that holds multiple elements, use a Vector{T}.\nWhen Gurobi requires a double, use Cdouble\nWhen Gurobi requires an int, use Cint\nWhen Gurobi requires a NULL, use C_NULL","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"For example:","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"julia> import MathOptInterface as MOI\n\njulia> using Gurobi\n\njulia> model = Gurobi.Optimizer();\n\njulia> x = MOI.add_variable(model)\nMOI.VariableIndex(1)\n\njulia> x_col = Gurobi.c_column(model, x)\n0\n\njulia> GRBupdatemodel(model)\n0\n\njulia> pValue = Ref{Cdouble}(NaN)\nBase.RefValue{Float64}(NaN)\n\njulia> GRBgetdblattrelement(model, \"LB\", x_col, pValue)\n0\n\njulia> pValue[]\n-1.0e100\n\njulia> GRBsetdblattrelement(model, \"LB\", x_col, 1.5)\n0\n\njulia> GRBupdatemodel(model)\n0\n\njulia> GRBgetdblattrelement(model, \"LB\", x_col, pValue)\n0\n\njulia> pValue[]\n1.5","category":"page"},{"location":"packages/Gurobi/#The-C-API-from-JuMP","page":"jump-dev/Gurobi.jl","title":"The C API from JuMP","text":"","category":"section"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"You can call the C API from JuMP if you use direct_model. This is most useful for adding GRBaddgenXXX constraints. Here are some examples:","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"using JuMP, Gurobi\ncolumn(x::VariableRef) = Gurobi.c_column(backend(owner_model(x)), index(x))\nmodel = direct_model(Gurobi.Optimizer())\n@variable(model, x)\n@variable(model, y)\np = [3.0, 0.0, 0.0, 7.0, 3.0]\nGRBaddgenconstrPoly(backend(model), C_NULL, column(x), column(y), 5, p, \"\")\noptimize!(model)","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"using JuMP, Gurobi\ncolumn(x::VariableRef) = Gurobi.c_column(backend(owner_model(x)), index(x))\nmodel = direct_model(Gurobi.Optimizer())\n@variable(model, x[i in 1:2])\n@variable(model, y[1:2])\nGRBaddgenconstrPow(backend(model), \"x1^0.7\", column(x[1]), column(y[1]), 0.7, \"\")\nGRBaddgenconstrPow(backend(model), \"x2^3\", column(x[2]), column(y[2]), 3.0, \"\")\n@objective(model, Min, y[1] + y[2])\noptimize!(model)","category":"page"},{"location":"packages/Gurobi/#Reusing-the-same-Gurobi-environment-for-multiple-solves","page":"jump-dev/Gurobi.jl","title":"Reusing the same Gurobi environment for multiple solves","text":"","category":"section"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"When using this package via other packages such as JuMP.jl, the default behavior is to obtain a new Gurobi license token every time a model is created. If you are using Gurobi in a setting where the number of concurrent Gurobi uses is limited (for example, \"Single-Use\" or \"Floating-Use\" licenses), you might instead prefer to obtain a single license token that is shared by all models that your program solves.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"You can do this by passing a Gurobi.Env() object as the first parameter to Gurobi.Optimizer. For example:","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"using JuMP, Gurobi\nconst GRB_ENV = Gurobi.Env()\n\nmodel_1 = Model(() -> Gurobi.Optimizer(GRB_ENV))\n\n# The solvers can have different options too\nmodel_2 = direct_model(Gurobi.Optimizer(GRB_ENV))\nset_attribute(model_2, \"OutputFlag\", 0)","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"If you create a module with a Gurobi.Env as a module-level constant, use an __init__ function to ensure that a new environment is created each time the module is loaded:","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"module MyModule\n\nimport Gurobi\n\nconst GRB_ENV_REF = Ref{Gurobi.Env}()\n\nfunction __init__()\n    global GRB_ENV_REF\n    GRB_ENV_REF[] = Gurobi.Env()\n    return\nend\n\n# Note the need for GRB_ENV_REF[] not GRB_ENV_REF\ncreate_optimizer() = Gurobi.Optimizer(GRB_ENV_REF[])\n\nend","category":"page"},{"location":"packages/Gurobi/#Accessing-Gurobi-specific-attributes","page":"jump-dev/Gurobi.jl","title":"Accessing Gurobi-specific attributes","text":"","category":"section"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"Get and set Gurobi-specific variable, constraint, and model attributes as follows:","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"using JuMP, Gurobi\nmodel = direct_model(Gurobi.Optimizer())\n@variable(model, x >= 0)\n@constraint(model, c, 2x >= 1)\n@objective(model, Min, x)\ngrb = backend(model)\nMOI.set(grb, Gurobi.ConstraintAttribute(\"Lazy\"), index(c), 2)\noptimize!(model)\nMOI.get(grb, Gurobi.VariableAttribute(\"LB\"), index(x))  # Returns 0.0\nMOI.get(grb, Gurobi.ModelAttribute(\"NumConstrs\")) # Returns 1","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"A complete list of supported Gurobi attributes can be found in their online documentation.","category":"page"},{"location":"packages/Gurobi/#Callbacks","page":"jump-dev/Gurobi.jl","title":"Callbacks","text":"","category":"section"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"Here is an example using Gurobi's solver-specific callbacks.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"using JuMP, Gurobi, Test\n\nmodel = direct_model(Gurobi.Optimizer())\n@variable(model, 0 <= x <= 2.5, Int)\n@variable(model, 0 <= y <= 2.5, Int)\n@objective(model, Max, y)\ncb_calls = Cint[]\nfunction my_callback_function(cb_data, cb_where::Cint)\n    # You can reference variables outside the function as normal\n    push!(cb_calls, cb_where)\n    # You can select where the callback is run\n    if cb_where != GRB_CB_MIPSOL && cb_where != GRB_CB_MIPNODE\n        return\n    end\n    # You can query a callback attribute using GRBcbget\n    if cb_where == GRB_CB_MIPNODE\n        resultP = Ref{Cint}()\n        GRBcbget(cb_data, cb_where, GRB_CB_MIPNODE_STATUS, resultP)\n        if resultP[] != GRB_OPTIMAL\n            return  # Solution is something other than optimal.\n        end\n    end\n    # Before querying `callback_value`, you must call:\n    Gurobi.load_callback_variable_primal(cb_data, cb_where)\n    x_val = callback_value(cb_data, x)\n    y_val = callback_value(cb_data, y)\n    # You can submit solver-independent MathOptInterface attributes such as\n    # lazy constraints, user-cuts, and heuristic solutions.\n    if y_val - x_val > 1 + 1e-6\n        con = @build_constraint(y - x <= 1)\n        MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n    elseif y_val + x_val > 3 + 1e-6\n        con = @build_constraint(y + x <= 3)\n        MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n    end\n    if rand() < 0.1\n        # You can terminate the callback as follows:\n        GRBterminate(backend(model))\n    end\n    return\nend\n# You _must_ set this parameter if using lazy constraints.\nMOI.set(model, MOI.RawOptimizerAttribute(\"LazyConstraints\"), 1)\nMOI.set(model, Gurobi.CallbackFunction(), my_callback_function)\noptimize!(model)\n@test termination_status(model) == MOI.OPTIMAL\n@test primal_status(model) == MOI.FEASIBLE_POINT\n@test value(x) == 1\n@test value(y) == 2","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"See the Gurobi documentation for other information that can be queried with GRBcbget.","category":"page"},{"location":"packages/Gurobi/#Common-Performance-Pitfall-with-JuMP","page":"jump-dev/Gurobi.jl","title":"Common Performance Pitfall with JuMP","text":"","category":"section"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"Gurobi's API works differently than most solvers. Any changes to the model are not applied immediately, but instead go sit in a internal buffer (making any modifications appear to be instantaneous) waiting for a call to GRBupdatemodel (where the work is  done).","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"This leads to a common performance pitfall that has the following message as its main symptom:","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"Warning: excessive time spent in model updates. Consider calling update less frequently.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"This often means the JuMP program was structured in such a way that Gurobi.jl ends up calling GRBupdatemodel in each iteration of a loop.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"Usually, it is possible (and easy) to restructure the JuMP program in a way it stays ssolver-agnostic and has a close-to-ideal performance with Gurobi.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"To guide such restructuring it is good to keep in mind the following bits of information:","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"GRBupdatemodel is only called if changes were done since last GRBupdatemodel (that is, if the internal buffer is not empty).\nGRBupdatemodel is called when JuMP.optimize! is called, but this often is not the source of the problem.\nGRBupdatemodel may be called when any model attribute is queried, even if that specific attribute was not changed. This often the source of the problem.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"The worst-case scenario is, therefore, a loop of modify-query-modify-query, even if what is being modified and what is being queried are two completely distinct things.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"As an example, instead of:","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"model = Model(Gurobi.Optimizer)\n@variable(model, x[1:100] >= 0)\nfor i in 1:100\n    set_upper_bound(x[i], i)\n    # `GRBupdatemodel` called on each iteration of this loop.\n    println(lower_bound(x[i]))\nend","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"do","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"model = Model(Gurobi.Optimizer)\n@variable(model, x[1:100] >= 0)\n# All modifications are done before any queries.\nfor i in 1:100\n    set_upper_bound(x[i], i)\nend\nfor i in 1:100\n    # Only the first `lower_bound` query may trigger an `GRBupdatemodel`.\n    println(lower_bound(x[i]))\nend","category":"page"},{"location":"packages/Gurobi/#Common-errors","page":"jump-dev/Gurobi.jl","title":"Common errors","text":"","category":"section"},{"location":"packages/Gurobi/#Using-Gurobi-v9.0-and-you-got-an-error-like-Q-not-PSD?","page":"jump-dev/Gurobi.jl","title":"Using Gurobi v9.0 and you got an error like Q not PSD?","text":"","category":"section"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"You need to set the NonConvex parameter:","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"model = Model(Gurobi.Optimizer)\nset_optimizer_attribute(model, \"NonConvex\", 2)","category":"page"},{"location":"packages/Gurobi/#Gurobi-Error-1009:-Version-number-is-XX.X,-license-is-for-version-XX.X","page":"jump-dev/Gurobi.jl","title":"Gurobi Error 1009: Version number is XX.X, license is for version XX.X","text":"","category":"section"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"Make sure that your license is correct for your Gurobi version. See the Gurobi documentation for details.","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"Once you are sure that the license and Gurobi versions match, re-install Gurobi.jl by running:","category":"page"},{"location":"packages/Gurobi/","page":"jump-dev/Gurobi.jl","title":"jump-dev/Gurobi.jl","text":"import Pkg\nPkg.build(\"Gurobi\")","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/submodules/Benchmarks/overview.md\"","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/submodules/Benchmarks/overview/#The-Benchmarks-submodule","page":"Overview","title":"The Benchmarks submodule","text":"","category":"section"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"To aid the development of efficient solver wrappers, MathOptInterface provides benchmarking capability. Benchmarking a wrapper follows a two-step process.","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"First, prior to making changes, create a baseline for the benchmark results on a given benchmark suite as follows:","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"using SolverPackage  # Replace with your choice of solver.\nimport MathOptInterface as MOI\n\nsuite = MOI.Benchmarks.suite() do\n    SolverPackage.Optimizer()\nend\n\nMOI.Benchmarks.create_baseline(\n    suite, \"current\"; directory = \"/tmp\", verbose = true\n)","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"Use the exclude argument to Benchmarks.suite to exclude benchmarks that the solver doesn't support.","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"Second, after making changes to the package, re-run the benchmark suite and compare to the prior saved results:","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"using SolverPackage\nimport MathOptInterface as MOI\n\nsuite = MOI.Benchmarks.suite() do\n    SolverPackage.Optimizer()\nend\n\nMOI.Benchmarks.compare_against_baseline(\n    suite, \"current\"; directory = \"/tmp\", verbose = true\n)","category":"page"},{"location":"moi/submodules/Benchmarks/overview/","page":"Overview","title":"Overview","text":"This comparison will create a report detailing improvements and regressions.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/tutorials/latency.md\"","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/tutorials/latency/#Latency","page":"Latency","title":"Latency","text":"","category":"section"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"MathOptInterface suffers the \"time-to-first-solve\" problem of start-up latency.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"This hurts both the user- and developer-experience of MathOptInterface. In the first case, because simple models have a multi-second delay before solving, and in the latter, because our tests take so long to run.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"This page contains some advice on profiling and fixing latency-related problems in the MathOptInterface.jl repository.","category":"page"},{"location":"moi/tutorials/latency/#Background","page":"Latency","title":"Background","text":"","category":"section"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Before reading this part of the documentation, you should familiarize yourself with the reasons for latency in Julia and how to fix them.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Read the blogposts on julialang.org on precompilation and SnoopCompile\nRead the SnoopCompile documentation.\nWatch Tim Holy's talk at JuliaCon 2021\nWatch the package development workshop at JuliaCon 2021","category":"page"},{"location":"moi/tutorials/latency/#Causes","page":"Latency","title":"Causes","text":"","category":"section"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"There are three main causes of latency in MathOptInterface:","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"A large number of types\nLack of method ownership\nType-instability in the bridge layer","category":"page"},{"location":"moi/tutorials/latency/#A-large-number-of-types","page":"Latency","title":"A large number of types","text":"","category":"section"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Julia is very good at specializing method calls based on the input type. Each specialization has a compilation cost, but the benefit of faster run-time performance.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"The best-case scenario is for a method to be called a large number of times with a single set of argument types. The worst-case scenario is for a method to be called a single time for a large set of argument types.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Because of MathOptInterface's function-in-set formulation, we fall into the worst-case situation.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"This is a fundamental limitation of Julia, so there isn't much we can do about it. However, if we can precompile MathOptInterface, much of the cost can be shifted from start-up latency to the time it takes to precompile a package on installation.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"However, there are two things which make MathOptInterface hard to precompile.","category":"page"},{"location":"moi/tutorials/latency/#Lack-of-method-ownership","page":"Latency","title":"Lack of method ownership","text":"","category":"section"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Lack of method ownership happens when a call is made using a mix of structs and methods from different modules. Because of this, no single module \"owns\" the method that is being dispatched, and so it cannot be precompiled.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"tip: Tip\nThis is a slightly simplified explanation. Read the precompilation tutorial for a more in-depth discussion on back-edges.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Unfortunately, the design of MOI means that this is a frequent occurrence: we have a bunch of types in MOI.Utilities that wrap types defined in external packages (for example, the Optimizers), which implement methods of functions defined in MOI (for example, add_variable, add_constraint).","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Here's a simple example of method-ownership in practice:","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"module MyMOI\nstruct Wrapper{T}\n    inner::T\nend\noptimize!(x::Wrapper) = optimize!(x.inner)\nend  # MyMOI\n\nmodule MyOptimizer\nusing ..MyMOI\nstruct Optimizer end\nMyMOI.optimize!(x::Optimizer) = 1\nend  # MyOptimizer\n\nusing SnoopCompile\nmodel = MyMOI.Wrapper(MyOptimizer.Optimizer())\n\njulia> tinf = @snoopi_deep MyMOI.optimize!(model)\nInferenceTimingNode: 0.008256/0.008543 on InferenceFrameInfo for Core.Compiler.Timings.ROOT() with 1 direct children","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"The result is that there was one method that required type inference. If we visualize tinf:","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"using ProfileView\nProfileView.view(flamegraph(tinf))","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"we see a flamegraph with a large red-bar indicating that the method MyMOI.optimize(MyMOI.Wrapper{MyOptimizer.Optimizer}) cannot be precompiled.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"To fix this, we need to designate a module to \"own\" that method (that is, create a back-edge). The easiest way to do this is for MyOptimizer to call MyMOI.optimize(MyMOI.Wrapper{MyOptimizer.Optimizer}) during using MyOptimizer. Let's see that in practice:","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"module MyMOI\nstruct Wrapper{T}\n    inner::T\nend\noptimize(x::Wrapper) = optimize(x.inner)\nend  # MyMOI\n\nmodule MyOptimizer\nusing ..MyMOI\nstruct Optimizer end\nMyMOI.optimize(x::Optimizer) = 1\n# The syntax of this let-while loop is very particular:\n#  * `let ... end` keeps everything local to avoid polluting the MyOptimizer\n#    namespace\n#  * `while true ... break end` runs the code once, and forces Julia to compile\n#    the inner loop, rather than interpret it.\nlet\n    while true\n        model = MyMOI.Wrapper(Optimizer())\n        MyMOI.optimize(model)\n        break\n    end\nend\nend  # MyOptimizer\n\nusing SnoopCompile\nmodel = MyMOI.Wrapper(MyOptimizer.Optimizer())\n\njulia> tinf = @snoopi_deep MyMOI.optimize(model)\nInferenceTimingNode: 0.006822/0.006822 on InferenceFrameInfo for Core.Compiler.Timings.ROOT() with 0 direct children","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"There are now 0 direct children that required type inference because the method was already stored in MyOptimizer!","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Unfortunately, this trick only works if the call-chain is fully inferrable. If there are breaks (due to type instability), then the benefit of doing this is reduced. And unfortunately for us, the design of MathOptInterface has a lot of type instabilities.","category":"page"},{"location":"moi/tutorials/latency/#Type-instability-in-the-bridge-layer","page":"Latency","title":"Type instability in the bridge layer","text":"","category":"section"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Most of MathOptInterface is pretty good at ensuring type-stability. However, a key component is not type stable, and that is the bridging layer.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"In particular, the bridging layer defines Bridges.LazyBridgeOptimizer, which has fields like:","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"struct LazyBridgeOptimizer\n    constraint_bridge_types::Vector{Any}\n    constraint_node::Dict{Tuple{Type,Type},ConstraintNode}\n    constraint_types::Vector{Tuple{Type,Type}}\nend","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"This is because the LazyBridgeOptimizer needs to be able to deal with any function-in-set type passed to it, and we also allow users to pass additional bridges that they defined in external packages.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"So to recap, MathOptInterface suffers package latency because:","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"there are a large number of types and functions\nand these are split between multiple modules, including external packages\nand there are type-instabilities like those in the bridging layer.","category":"page"},{"location":"moi/tutorials/latency/#Resolutions","page":"Latency","title":"Resolutions","text":"","category":"section"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"There are no magic solutions to reduce latency. Issue #1313 tracks progress on reducing latency in MathOptInterface.","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"A useful script is the following (replace GLPK as needed):","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"import GLPK\nimport MathOptInterface as MOI\n\nfunction example_diet(optimizer, bridge)\n    category_data = [\n        1800.0 2200.0;\n          91.0    Inf;\n           0.0   65.0;\n           0.0 1779.0\n    ]\n    cost = [2.49, 2.89, 1.50, 1.89, 2.09, 1.99, 2.49, 0.89, 1.59]\n    food_data = [\n        410 24 26 730;\n        420 32 10 1190;\n        560 20 32 1800;\n        380  4 19 270;\n        320 12 10 930;\n        320 15 12 820;\n        320 31 12 1230;\n        100  8 2.5 125;\n        330  8 10 180\n    ]\n    bridge_model = if bridge\n        MOI.instantiate(optimizer; with_bridge_type=Float64)\n    else\n        MOI.instantiate(optimizer)\n    end\n    model = MOI.Utilities.CachingOptimizer(\n        MOI.Utilities.UniversalFallback(MOI.Utilities.Model{Float64}()),\n        MOI.Utilities.AUTOMATIC,\n    )\n    MOI.Utilities.reset_optimizer(model, bridge_model)\n    MOI.set(model, MOI.Silent(), true)\n    nutrition = MOI.add_variables(model, size(category_data, 1))\n    for (i, v) in enumerate(nutrition)\n        MOI.add_constraint(model, v, MOI.GreaterThan(category_data[i, 1]))\n        MOI.add_constraint(model, v, MOI.LessThan(category_data[i, 2]))\n    end\n    buy = MOI.add_variables(model, size(food_data, 1))\n    MOI.add_constraint.(model, buy, MOI.GreaterThan(0.0))\n    MOI.set(model, MOI.ObjectiveSense(), MOI.MIN_SENSE)\n    f = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(cost, buy), 0.0)\n    MOI.set(model, MOI.ObjectiveFunction{typeof(f)}(), f)\n    for (j, n) in enumerate(nutrition)\n        f = MOI.ScalarAffineFunction(\n            MOI.ScalarAffineTerm.(food_data[:, j], buy),\n            0.0,\n        )\n        push!(f.terms, MOI.ScalarAffineTerm(-1.0, n))\n        MOI.add_constraint(model, f, MOI.EqualTo(0.0))\n    end\n    MOI.optimize!(model)\n    term_status = MOI.get(model, MOI.TerminationStatus())\n    @assert term_status == MOI.OPTIMAL\n    MOI.add_constraint(\n        model,\n        MOI.ScalarAffineFunction(\n            MOI.ScalarAffineTerm.(1.0, [buy[end-1], buy[end]]),\n            0.0,\n        ),\n        MOI.LessThan(6.0),\n    )\n    MOI.optimize!(model)\n    @assert MOI.get(model, MOI.TerminationStatus()) == MOI.INFEASIBLE\n    return\nend\n\nif length(ARGS) > 0\n    bridge = get(ARGS, 2, \"\") != \"--no-bridge\"\n    println(\"Running: $(ARGS[1]) $(get(ARGS, 2, \"\"))\")\n    @time example_diet(GLPK.Optimizer, bridge)\n    @time example_diet(GLPK.Optimizer, bridge)\n    exit(0)\nend","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"You can create a flame-graph via","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"using SnoopCompile\ntinf = @snoopi_deep example_diet(GLPK.Optimizer, true)\nusing ProfileView\nProfileView.view(flamegraph(tinf))","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"Here's how things looked in mid-August 2021: (Image: flamegraph)","category":"page"},{"location":"moi/tutorials/latency/","page":"Latency","title":"Latency","text":"There are a few opportunities for improvement (non-red flames, particularly on the right). But the main problem is a large red (non-precompilable due to method ownership) flame.","category":"page"},{"location":"packages/Percival/","page":"JuliaSmoothOptimizers/Percival.jl","title":"JuliaSmoothOptimizers/Percival.jl","text":"EditURL = \"https://github.com/JuliaSmoothOptimizers/Percival.jl/blob/0448763a5f8aa9d43a5ad684309c839f70d10fbf/README.md\"","category":"page"},{"location":"packages/Percival/#Percival.jl-An-augmented-Lagrangian-solver","page":"JuliaSmoothOptimizers/Percival.jl","title":"Percival.jl - An augmented Lagrangian solver","text":"","category":"section"},{"location":"packages/Percival/","page":"JuliaSmoothOptimizers/Percival.jl","title":"JuliaSmoothOptimizers/Percival.jl","text":"(Image: CI) (Image: codecov.io) (Image: docs-stable) (Image: docs-dev) (Image: DOI)","category":"page"},{"location":"packages/Percival/","page":"JuliaSmoothOptimizers/Percival.jl","title":"JuliaSmoothOptimizers/Percival.jl","text":"Percival is an implementation of the augmented Lagrangian solver described in","category":"page"},{"location":"packages/Percival/","page":"JuliaSmoothOptimizers/Percival.jl","title":"JuliaSmoothOptimizers/Percival.jl","text":"S. Arreckx, A. Lambe, Martins, J. R. R. A., & Orban, D. (2016).\nA Matrix-Free Augmented Lagrangian Algorithm with Application to Large-Scale Structural Design Optimization.\nOptimization And Engineering, 17, 359–384. doi:10.1007/s11081-015-9287-9","category":"page"},{"location":"packages/Percival/","page":"JuliaSmoothOptimizers/Percival.jl","title":"JuliaSmoothOptimizers/Percival.jl","text":"with internal solver tron from JSOSolvers.jl. To use Percival, you have to pass it an NLPModel.","category":"page"},{"location":"packages/Percival/#How-to-Cite","page":"JuliaSmoothOptimizers/Percival.jl","title":"How to Cite","text":"","category":"section"},{"location":"packages/Percival/","page":"JuliaSmoothOptimizers/Percival.jl","title":"JuliaSmoothOptimizers/Percival.jl","text":"If you use Percival.jl in your work, please cite using the format given in CITATION.bib.","category":"page"},{"location":"packages/Percival/#Install","page":"JuliaSmoothOptimizers/Percival.jl","title":"Install","text":"","category":"section"},{"location":"packages/Percival/","page":"JuliaSmoothOptimizers/Percival.jl","title":"JuliaSmoothOptimizers/Percival.jl","text":"Use ] to enter pkg> mode of Julia, then","category":"page"},{"location":"packages/Percival/","page":"JuliaSmoothOptimizers/Percival.jl","title":"JuliaSmoothOptimizers/Percival.jl","text":"pkg> add Percival","category":"page"},{"location":"packages/Percival/#Examples","page":"JuliaSmoothOptimizers/Percival.jl","title":"Examples","text":"","category":"section"},{"location":"packages/Percival/","page":"JuliaSmoothOptimizers/Percival.jl","title":"JuliaSmoothOptimizers/Percival.jl","text":"Consider the following 2-dimensional optimization problem with an equality constraint","category":"page"},{"location":"packages/Percival/","page":"JuliaSmoothOptimizers/Percival.jl","title":"JuliaSmoothOptimizers/Percival.jl","text":"beginequation\nmin_(x_1x_2) quad (x_1 - 1)^2 + 100 (x_2 - x_1^2)^2 quad textsto quad x_1^2 + x_2^2 = 1\nendequation","category":"page"},{"location":"packages/Percival/","page":"JuliaSmoothOptimizers/Percival.jl","title":"JuliaSmoothOptimizers/Percival.jl","text":"You can solve an JuMP model model by using NLPModelsJuMP.jl to convert it.","category":"page"},{"location":"packages/Percival/","page":"JuliaSmoothOptimizers/Percival.jl","title":"JuliaSmoothOptimizers/Percival.jl","text":"using JuMP, NLPModelsJuMP, Percival\nmodel = Model(NLPModelsJuMP.Optimizer)\nset_attribute(model, \"solver\", Percival.PercivalSolver)\n@variable(model, x[i=1:2], start = [-1.2; 1.0][i])\n@objective(model, Min, (x[1] - 1)^2 + 100 * (x[2] - x[1]^2)^2)\n@constraint(model, x[1]^2 + x[2]^2 == 1)\noptimize!(model)\nsolution_summary(model)","category":"page"},{"location":"packages/Percival/","page":"JuliaSmoothOptimizers/Percival.jl","title":"JuliaSmoothOptimizers/Percival.jl","text":"percival accept as input any instance of AbstractNLPModel, for instance, using automatic differentiation via ADNLPModels.jl to solve the same problem.","category":"page"},{"location":"packages/Percival/","page":"JuliaSmoothOptimizers/Percival.jl","title":"JuliaSmoothOptimizers/Percival.jl","text":"using ADNLPModels, Percival\nnlp = ADNLPModel(\n  x -> (x[1] - 1)^2 + 100 * (x[2] - x[1]^2)^2,\n  [-1.2; 1.0],\n  x -> [x[1]^2 + x[2]^2],\n  [1.0],\n  [1.0],\n)\noutput = percival(nlp, verbose = 1)","category":"page"},{"location":"packages/Percival/#Bug-reports-and-discussions","page":"JuliaSmoothOptimizers/Percival.jl","title":"Bug reports and discussions","text":"","category":"section"},{"location":"packages/Percival/","page":"JuliaSmoothOptimizers/Percival.jl","title":"JuliaSmoothOptimizers/Percival.jl","text":"If you think you found a bug, feel free to open an issue. Focused suggestions and requests can also be opened as issues. Before opening a pull request, start an issue or a discussion on the topic, please.","category":"page"},{"location":"packages/Percival/","page":"JuliaSmoothOptimizers/Percival.jl","title":"JuliaSmoothOptimizers/Percival.jl","text":"If you want to ask a question not suited for a bug report, feel free to start a discussion here. This forum is for general discussion about this repository and the JuliaSmoothOptimizers, so questions about any of our packages are welcome.","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"EditURL = \"https://github.com/jump-dev/SCS.jl/blob/v2.0.0/README.md\"","category":"page"},{"location":"packages/SCS/#SCS.jl","page":"jump-dev/SCS.jl","title":"SCS.jl","text":"","category":"section"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"SCS.jl is a wrapper for the SCS splitting cone solver.","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"SCS can solve linear programs, second-order cone programs, semidefinite programs, exponential cone programs, and power cone programs.","category":"page"},{"location":"packages/SCS/#Affiliation","page":"jump-dev/SCS.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"This wrapper is maintained by the JuMP community and is not a project of the SCS developers.","category":"page"},{"location":"packages/SCS/#License","page":"jump-dev/SCS.jl","title":"License","text":"","category":"section"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"SCS.jl is licensed under the MIT License.","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"The underlying solver, cvxgrp/scs, is licensed under the MIT License.","category":"page"},{"location":"packages/SCS/#Installation","page":"jump-dev/SCS.jl","title":"Installation","text":"","category":"section"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"Install SCS.jl using the Julia package manager:","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"import Pkg\nPkg.add(\"SCS\")","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"In addition to installing the SCS.jl package, this will also download and install the SCS binaries. (You do not need to install SCS separately.)","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"To use a custom binary, read the Custom solver binaries section of the JuMP documentation.","category":"page"},{"location":"packages/SCS/#Use-with-Convex.jl","page":"jump-dev/SCS.jl","title":"Use with Convex.jl","text":"","category":"section"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"This example shows how we can model a simple knapsack problem with Convex and use SCS to solve it.","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"using Convex, SCS\nitems  = [:Gold, :Silver, :Bronze]\nvalues = [5.0, 3.0, 1.0]\nweights = [2.0, 1.5, 0.3]\n\n# Define a variable of size 3, each index representing an item\nx = Variable(3)\np = maximize(x' * values, 0 <= x, x <= 1, x' * weights <= 3)\nsolve!(p, SCS.Optimizer)\nprintln([items x.value])\n# [:Gold 0.9999971880377178\n#  :Silver 0.46667637765641057\n#  :Bronze 0.9999998036351865]","category":"page"},{"location":"packages/SCS/#Use-with-JuMP","page":"jump-dev/SCS.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"This example shows how we can model a simple knapsack problem with JuMP and use SCS to solve it.","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"using JuMP, SCS\nitems  = [:Gold, :Silver, :Bronze]\nvalues = Dict(:Gold => 5.0,  :Silver => 3.0,  :Bronze => 1.0)\nweight = Dict(:Gold => 2.0,  :Silver => 1.5,  :Bronze => 0.3)\n\nmodel = Model(SCS.Optimizer)\n@variable(model, 0 <= take[items] <= 1)  # Define a variable for each item\n@objective(model, Max, sum(values[item] * take[item] for item in items))\n@constraint(model, sum(weight[item] * take[item] for item in items) <= 3)\noptimize!(model)\nprintln(value.(take))\n# 1-dimensional DenseAxisArray{Float64,1,...} with index sets:\n#     Dimension 1, Symbol[:Gold, :Silver, :Bronze]\n# And data, a 3-element Array{Float64,1}:\n#  1.0000002002226671\n#  0.4666659513182934\n#  1.0000007732744878","category":"page"},{"location":"packages/SCS/#MathOptInterface-API","page":"jump-dev/SCS.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"The SCS optimizer supports the following constraints and attributes.","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"List of supported objective functions:","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"MOI.Reals","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"MOI.VectorAffineFunction{Float64} in MOI.DualExponentialCone\nMOI.VectorAffineFunction{Float64} in MOI.DualPowerCone{Float64}\nMOI.VectorAffineFunction{Float64} in MOI.ExponentialCone\nMOI.VectorAffineFunction{Float64} in MOI.Nonnegatives\nMOI.VectorAffineFunction{Float64} in MOI.PowerCone{Float64}\nMOI.VectorAffineFunction{Float64} in MOI.SecondOrderCone\nMOI.VectorAffineFunction{Float64} in MOI.Zeros\nMOI.VectorAffineFunction{Float64} in SCS.ScaledPSDCone","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"MOI.ObjectiveSense()","category":"page"},{"location":"packages/SCS/#Options","page":"jump-dev/SCS.jl","title":"Options","text":"","category":"section"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"All SCS solver options can be set through Convex.jl or MathOptInterface.jl.","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"For example:","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"model = Model(optimizer_with_attributes(SCS.Optimizer, \"max_iters\" => 10))\n\n# via MathOptInterface:\noptimizer = SCS.Optimizer()\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"max_iters\"), 10)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"verbose\"), 0)","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"Common options are:","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"max_iters: the maximum number of iterations to take\nverbose: turn printing on (1) or off (0)","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"See the glbopts.h header for other options.","category":"page"},{"location":"packages/SCS/#Linear-solvers","page":"jump-dev/SCS.jl","title":"Linear solvers","text":"","category":"section"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"SCS uses a linear solver internally, see this section of SCS documentation. SCS.jl ships with the following linear solvers:","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"SCS.DirectSolver (sparse direct, the default)\nSCS.IndirectSolver (sparse indirect, by conjugate gradient)","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"To select the linear solver, set the linear_solver option, or pass the solver as the first argument when using scs_solve directly (see the low-level wrapper section below). For example:","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"using JuMP, SCS\nmodel = Model(SCS.Optimizer)\nset_attribute(model, \"linear_solver\", SCS.IndirectSolver)","category":"page"},{"location":"packages/SCS/#SCS-with-MKL-Pardiso-linear-solver","page":"jump-dev/SCS.jl","title":"SCS with MKL Pardiso linear solver","text":"","category":"section"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"SCS.jl v2.0 introduced a breaking change. You now need to use SCS_MKL_jll instead of MKL_jll.","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"To enable the MKL Pardiso (direct sparse) solver one needs to install and load SCS_MKL_jll.","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"julia> import Pkg; Pkg.add(\"SCS_MKL_jll\");\n\njulia> using SCS, SCS_MKL_jll\n\njulia> using SCS\n\njulia> SCS.is_available(SCS.MKLDirectSolver)\ntrue","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"The MKLDirectSolver is available on Linux x86_64 platform only.","category":"page"},{"location":"packages/SCS/#SCS-with-Sparse-GPU-indirect-solver-(CUDA-only)","page":"jump-dev/SCS.jl","title":"SCS with Sparse GPU indirect solver (CUDA only)","text":"","category":"section"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"SCS.jl v2.0 introduced a breaking change. You now need to use SCS_GPU_jll instead of CUDA_jll.","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"To enable the indirect linear solver on GPU one needs to install and load SCS_GPU_jll.","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"julia> import Pkg; Pkg.add(\"SCS_GPU_jll\");\n\njulia> using SCS, SCS_GPU_jll\n\njulia> SCS.is_available(SCS.GpuIndirectSolver)\ntrue","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"The GpuIndirectSolver is available on Linux x86_64 platform only.","category":"page"},{"location":"packages/SCS/#Low-level-wrapper","page":"jump-dev/SCS.jl","title":"Low-level wrapper","text":"","category":"section"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"SCS.jl provides a low-level interface to solve a problem directly, without interfacing through MathOptInterface.","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"This is an advanced interface with a risk of incorrect usage. For new users, we recommend that you use the JuMP or Convex interfaces instead.","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"SCS solves a problem of the form:","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"minimize        1/2 * x' * P * x + c' * x\nsubject to      A * x + s = b\n                s in K","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"where K is a product cone of:","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"zero cone\npositive orthant { x | x ≥ 0 }\nbox cone { (t,x) | t*l ≤ x ≤ t*u}\nsecond-order cone (SOC) { (t,x) | ||x||_2 ≤ t }\nsemi-definite cone (SDC) { X | X is psd }\nexponential cone { (x,y,z) | y e^(x/y) ≤ z, y>0 }\npower cone { (x,y,z) | x^a * y^(1-a) ≥ |z|, x ≥ 0, y ≥ 0 }\ndual power cone { (u,v,w) | (u/a)^a * (v/(1-a))^(1-a) ≥ |w|, u ≥ 0, v ≥ 0 }.","category":"page"},{"location":"packages/SCS/","page":"jump-dev/SCS.jl","title":"jump-dev/SCS.jl","text":"To solve this problem with SCS, call SCS.scs_solve; see the docstring for details.","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"EditURL = \"lp_sensitivity.jl\"","category":"page"},{"location":"tutorials/linear/lp_sensitivity/#Sensitivity-analysis-of-a-linear-program","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"","category":"section"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"This tutorial explains how to use the lp_sensitivity_report function to create sensitivity reports like those that are produced by the Excel Solver. This is most often used in introductory classes to linear programming.","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"In brief, sensitivity analysis of a linear program is about asking two questions:","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"Given an optimal solution, how much can the objective coefficients change by before a different solution becomes optimal?\nGiven an optimal solution, how much can the right-hand side of a linear constraint change by before a different solution becomes optimal?","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"JuMP provides a function, lp_sensitivity_report, to help us compute these values, but this tutorial extends that to create more informative tables in the form of a DataFrame.","category":"page"},{"location":"tutorials/linear/lp_sensitivity/#Setup","page":"Sensitivity analysis of a linear program","title":"Setup","text":"","category":"section"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"using JuMP\nimport HiGHS\nimport DataFrames","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"as well as this small linear program:","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"model = Model(HiGHS.Optimizer)\n@variable(model, x >= 0)\n@variable(model, 0 <= y <= 3)\n@variable(model, z <= 1)\n@objective(model, Min, 12x + 20y - z)\n@constraint(model, c1, 6x + 8y >= 100)\n@constraint(model, c2, 7x + 12y >= 120)\n@constraint(model, c3, x + y <= 20)\noptimize!(model)\n@assert is_solved_and_feasible(model)\nsolution_summary(model; verbose = true)","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"Can you identify:","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"The objective coefficient of each variable?\nThe right-hand side of each constraint?\nThe optimal primal and dual solutions?","category":"page"},{"location":"tutorials/linear/lp_sensitivity/#Sensitivity-reports","page":"Sensitivity analysis of a linear program","title":"Sensitivity reports","text":"","category":"section"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"Now let's call lp_sensitivity_report:","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"report = lp_sensitivity_report(model)","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"It returns a SensitivityReport object, which maps:","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"Every variable reference to a tuple (d_lo, d_hi)::Tuple{Float64,Float64}, explaining how much the objective coefficient of the corresponding variable can change by, such that the original basis remains optimal.\nEvery constraint reference to a tuple (d_lo, d_hi)::Tuple{Float64,Float64}, explaining how much the right-hand side of the corresponding constraint can change by, such that the basis remains optimal.","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"Both tuples are relative, rather than absolute. So, given an objective coefficient of 1.0 and a tuple (-0.5, 0.5), the objective coefficient can range between 1.0 - 0.5 an 1.0 + 0.5.","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"For example:","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"report[x]","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"indicates that the objective coefficient on x, that is, 12, can decrease by -0.333 or increase by 3.0 and the primal solution (15, 1.25) will remain optimal. In addition:","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"report[c1]","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"means that the right-hand side of the c1 constraint (100), can decrease by 4 units, or increase by 2.85 units, and the primal solution (15, 1.25) will remain optimal.","category":"page"},{"location":"tutorials/linear/lp_sensitivity/#Variable-sensitivity","page":"Sensitivity analysis of a linear program","title":"Variable sensitivity","text":"","category":"section"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"By themselves, the tuples aren't informative. Let's put them in context by collating a range of other information about a variable:","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"function variable_report(xi)\n    return (\n        name = name(xi),\n        lower_bound = has_lower_bound(xi) ? lower_bound(xi) : -Inf,\n        value = value(xi),\n        upper_bound = has_upper_bound(xi) ? upper_bound(xi) : Inf,\n        reduced_cost = reduced_cost(xi),\n        obj_coefficient = coefficient(objective_function(model), xi),\n        allowed_decrease = report[xi][1],\n        allowed_increase = report[xi][2],\n    )\nend","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"Calling our function on x:","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"x_report = variable_report(x)","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"That's a bit hard to read, so let's call this on every variable in the model and put things into a DataFrame:","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"variable_df =\n    DataFrames.DataFrame(variable_report(xi) for xi in all_variables(model))","category":"page"},{"location":"tutorials/linear/lp_sensitivity/#Constraint-sensitivity","page":"Sensitivity analysis of a linear program","title":"Constraint sensitivity","text":"","category":"section"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"We can do something similar with constraints:","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"function constraint_report(c::ConstraintRef)\n    return (\n        name = name(c),\n        value = value(c),\n        rhs = normalized_rhs(c),\n        slack = normalized_rhs(c) - value(c),\n        shadow_price = shadow_price(c),\n        allowed_decrease = report[c][1],\n        allowed_increase = report[c][2],\n    )\nend\n\nc1_report = constraint_report(c1)","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"That's a bit hard to read, so let's call this on every variable in the model and put things into a DataFrame:","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"constraint_df = DataFrames.DataFrame(\n    constraint_report(ci) for (F, S) in list_of_constraint_types(model) for\n    ci in all_constraints(model, F, S) if F == AffExpr\n)","category":"page"},{"location":"tutorials/linear/lp_sensitivity/#Analysis-questions","page":"Sensitivity analysis of a linear program","title":"Analysis questions","text":"","category":"section"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"Now we can use these dataframes to ask questions of the solution.","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"For example, we can find basic variables by looking for variables with a reduced cost of 0:","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"basic = filter(row -> iszero(row.reduced_cost), variable_df)","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"and non-basic variables by looking for non-zero reduced costs:","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"non_basic = filter(row -> !iszero(row.reduced_cost), variable_df)","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"we can also find constraints that are binding by looking for zero slacks:","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"binding = filter(row -> iszero(row.slack), constraint_df)","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"or non-zero shadow prices:","category":"page"},{"location":"tutorials/linear/lp_sensitivity/","page":"Sensitivity analysis of a linear program","title":"Sensitivity analysis of a linear program","text":"binding2 = filter(row -> !iszero(row.shadow_price), constraint_df)","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/tutorials/example.md\"","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/tutorials/example/#Solving-a-problem-using-MathOptInterface","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"In this tutorial we demonstrate how to use MathOptInterface to solve the binary-constrained knapsack problem:","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"beginaligned\nmax   c^top x       \nst   w^top x le C \n         x_i in 01quad forall i=1ldotsn\nendaligned","category":"page"},{"location":"moi/tutorials/example/#Required-packages","page":"Solving a problem using MathOptInterface","title":"Required packages","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"Load the MathOptInterface module and define the shorthand MOI:","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"import MathOptInterface as MOI","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"As an optimizer, we choose GLPK:","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"using GLPK\noptimizer = GLPK.Optimizer()","category":"page"},{"location":"moi/tutorials/example/#Define-the-data","page":"Solving a problem using MathOptInterface","title":"Define the data","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"We first define the constants of the problem:","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> c = [1.0, 2.0, 3.0]\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n\njulia> w = [0.3, 0.5, 1.0]\n3-element Vector{Float64}:\n 0.3\n 0.5\n 1.0\n\njulia> C = 3.2\n3.2","category":"page"},{"location":"moi/tutorials/example/#Add-the-variables","page":"Solving a problem using MathOptInterface","title":"Add the variables","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> x = MOI.add_variables(optimizer, length(c));","category":"page"},{"location":"moi/tutorials/example/#set_objective_example","page":"Solving a problem using MathOptInterface","title":"Set the objective","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> MOI.set(\n           optimizer,\n           MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n           MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(c, x), 0.0),\n       );\n\njulia> MOI.set(optimizer, MOI.ObjectiveSense(), MOI.MAX_SENSE)","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"tip: Tip\nMOI.ScalarAffineTerm.(c, x) is a shortcut for [MOI.ScalarAffineTerm(c[i], x[i]) for i = 1:3]. This is Julia's broadcast syntax in action, and is used quite often throughout MOI.","category":"page"},{"location":"moi/tutorials/example/#Add-the-constraints","page":"Solving a problem using MathOptInterface","title":"Add the constraints","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"We add the knapsack constraint and integrality constraints:","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> MOI.add_constraint(\n           optimizer,\n           MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(w, x), 0.0),\n           MOI.LessThan(C),\n       );","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"Add integrality constraints:","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> for x_i in x\n           MOI.add_constraint(optimizer, x_i, MOI.ZeroOne())\n       end","category":"page"},{"location":"moi/tutorials/example/#Optimize-the-model","page":"Solving a problem using MathOptInterface","title":"Optimize the model","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> MOI.optimize!(optimizer)","category":"page"},{"location":"moi/tutorials/example/#Understand-why-the-solver-stopped","page":"Solving a problem using MathOptInterface","title":"Understand why the solver stopped","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"The first thing to check after optimization is why the solver stopped, for example, did it stop because of a time limit or did it stop because it found the optimal solution?","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> MOI.get(optimizer, MOI.TerminationStatus())\nOPTIMAL::TerminationStatusCode = 1","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"Looks like we found an optimal solution.","category":"page"},{"location":"moi/tutorials/example/#Understand-what-solution-was-returned","page":"Solving a problem using MathOptInterface","title":"Understand what solution was returned","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> MOI.get(optimizer, MOI.ResultCount())\n1\n\njulia> MOI.get(optimizer, MOI.PrimalStatus())\nFEASIBLE_POINT::ResultStatusCode = 1\n\njulia> MOI.get(optimizer, MOI.DualStatus())\nNO_SOLUTION::ResultStatusCode = 0","category":"page"},{"location":"moi/tutorials/example/#Query-the-objective","page":"Solving a problem using MathOptInterface","title":"Query the objective","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"What is its objective value?","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> MOI.get(optimizer, MOI.ObjectiveValue())\n6.0","category":"page"},{"location":"moi/tutorials/example/#Query-the-primal-solution","page":"Solving a problem using MathOptInterface","title":"Query the primal solution","text":"","category":"section"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"And what is the value of the variables x?","category":"page"},{"location":"moi/tutorials/example/","page":"Solving a problem using MathOptInterface","title":"Solving a problem using MathOptInterface","text":"julia> MOI.get(optimizer, MOI.VariablePrimal(), x)\n3-element Vector{Float64}:\n 1.0\n 1.0\n 1.0","category":"page"},{"location":"packages/DiffOpt/","page":"jump-dev/DiffOpt.jl","title":"jump-dev/DiffOpt.jl","text":"EditURL = \"https://github.com/jump-dev/DiffOpt.jl/blob/v0.4.2/README.md\"","category":"page"},{"location":"packages/DiffOpt/#DiffOpt.jl","page":"jump-dev/DiffOpt.jl","title":"DiffOpt.jl","text":"","category":"section"},{"location":"packages/DiffOpt/","page":"jump-dev/DiffOpt.jl","title":"jump-dev/DiffOpt.jl","text":"(Image: stable docs) (Image: development docs) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"packages/DiffOpt/","page":"jump-dev/DiffOpt.jl","title":"jump-dev/DiffOpt.jl","text":"DiffOpt.jl is a package for differentiating convex optimization programs with respect to the program parameters. DiffOpt currently supports linear, quadratic, and conic programs.","category":"page"},{"location":"packages/DiffOpt/#License","page":"jump-dev/DiffOpt.jl","title":"License","text":"","category":"section"},{"location":"packages/DiffOpt/","page":"jump-dev/DiffOpt.jl","title":"jump-dev/DiffOpt.jl","text":"DiffOpt.jl is licensed under the MIT License.","category":"page"},{"location":"packages/DiffOpt/#Installation","page":"jump-dev/DiffOpt.jl","title":"Installation","text":"","category":"section"},{"location":"packages/DiffOpt/","page":"jump-dev/DiffOpt.jl","title":"jump-dev/DiffOpt.jl","text":"Install DiffOpt using Pkg.add:","category":"page"},{"location":"packages/DiffOpt/","page":"jump-dev/DiffOpt.jl","title":"jump-dev/DiffOpt.jl","text":"import Pkg\nPkg.add(\"DiffOpt\")","category":"page"},{"location":"packages/DiffOpt/#Documentation","page":"jump-dev/DiffOpt.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/DiffOpt/","page":"jump-dev/DiffOpt.jl","title":"jump-dev/DiffOpt.jl","text":"The documentation for DiffOpt.jl includes a detailed description of the theory behind the package, along with examples, tutorials, and an API reference.","category":"page"},{"location":"packages/DiffOpt/#Use-with-JuMP","page":"jump-dev/DiffOpt.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/DiffOpt/","page":"jump-dev/DiffOpt.jl","title":"jump-dev/DiffOpt.jl","text":"Use DiffOpt with JuMP by following this brief example:","category":"page"},{"location":"packages/DiffOpt/","page":"jump-dev/DiffOpt.jl","title":"jump-dev/DiffOpt.jl","text":"using JuMP, DiffOpt, HiGHS\n# Create a model using the wrapper\nmodel = Model(() -> DiffOpt.diff_optimizer(HiGHS.Optimizer))\n# Define your model and solve it\n@variable(model, x)\n@constraint(model, cons, x >= 3)\n@objective(model, Min, 2x)\noptimize!(model)\n# Choose the problem parameters to differentiate with respect to, and set their\n# perturbations.\nMOI.set(model, DiffOpt.ReverseVariablePrimal(), x, 1.0)\n# Differentiate the model\nDiffOpt.reverse_differentiate!(model)\n# fetch the gradients\ngrad_exp = MOI.get(model, DiffOpt.ReverseConstraintFunction(), cons)  # -3 x - 1\nconstant(grad_exp)        # -1\ncoefficient(grad_exp, x)  # -3","category":"page"},{"location":"packages/DiffOpt/#GSOC2020","page":"jump-dev/DiffOpt.jl","title":"GSOC2020","text":"","category":"section"},{"location":"packages/DiffOpt/","page":"jump-dev/DiffOpt.jl","title":"jump-dev/DiffOpt.jl","text":"DiffOpt began as a NumFOCUS sponsored Google Summer of Code (2020) project","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"EditURL = \"https://github.com/jump-dev/KNITRO.jl/blob/v0.14.2/README.md\"","category":"page"},{"location":"packages/KNITRO/#KNITRO.jl","page":"jump-dev/KNITRO.jl","title":"KNITRO.jl","text":"","category":"section"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"KNITRO.jl is a wrapper for the Artelys Knitro solver.","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"It has two components:","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"a thin wrapper around the C API\nan interface to MathOptInterface.","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"KNITRO.jl v0.14.0 introduced a number of breaking changes to the low-level C API. See the Low-level wrapper section for details.","category":"page"},{"location":"packages/KNITRO/#Affiliation","page":"jump-dev/KNITRO.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"This wrapper is maintained by the JuMP community with help from Artelys.","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"Contact Artelys support if you encounter any problem with this interface or the solver.","category":"page"},{"location":"packages/KNITRO/#License","page":"jump-dev/KNITRO.jl","title":"License","text":"","category":"section"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"KNITRO.jl is licensed under the MIT License.","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"The underlying solver is a closed-source commercial product for which you must purchase a license.","category":"page"},{"location":"packages/KNITRO/#Installation","page":"jump-dev/KNITRO.jl","title":"Installation","text":"","category":"section"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"First, obtain a license and install a copy of KNITRO from Artelys.","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"Then, install KNITRO.jl using the Julia package manager:","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"import Pkg\nPkg.add(\"KNITRO\")","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"If you are having trouble installing KNITRO.jl, here are several things to try:","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"Make sure that you have defined your global variables correctly, for example with export KNITRODIR=\"/path/to/knitro-vXXX-$OS-64\" and export LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH:$KNITRODIR/lib\". You can check that KNITRO.jl sees your library with using KNITRO; KNITRO.has_knitro().\nIf KNITRO.has_knitro() returns false but you are confident that your paths are correct, try running Pkg.build(\"KNITRO\") and restarting Julia. In at least one user's experience, installing and using KNITRO in a temporary Julia environment (activated with ] activate --temp) does not work and the need to manually build is likely the reason why.","category":"page"},{"location":"packages/KNITRO/#Use-with-JuMP","page":"jump-dev/KNITRO.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"To use KNITRO with JuMP, use KNITRO.Optimizer:","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"using JuMP, KNITRO\nmodel = Model(KNITRO.Optimizer)\nset_attribute(model, \"outlev\", 1)\nset_attribute(model, \"algorithm\", 4)","category":"page"},{"location":"packages/KNITRO/#Use-with-AMPL","page":"jump-dev/KNITRO.jl","title":"Use with AMPL","text":"","category":"section"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"To use KNITRO with AmplNLWriter.jl, use KNITRO.amplexe:","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"using JuMP\nimport AmplNLWriter\nimport KNITRO\nmodel = Model(() -> AmplNLWriter.Optimizer(KNITRO.amplexe, [\"outlev=3\"]))","category":"page"},{"location":"packages/KNITRO/#Use-with-other-packages","page":"jump-dev/KNITRO.jl","title":"Use with other packages","text":"","category":"section"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"A variety of packages extend KNITRO.jl to support other optimization modeling systems. These include:","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"NLPModelsKnitro\nOptimization.jl","category":"page"},{"location":"packages/KNITRO/#MathOptInterface-API","page":"jump-dev/KNITRO.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"The Knitro optimizer supports the following constraints and attributes.","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"List of supported objective functions:","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}\nMOI.ObjectiveFunction{MOI.ScalarNonlinearFunction}\nMOI.ObjectiveFunction{MOI.ScalarQuadraticFunction{Float64}}\nMOI.ObjectiveFunction{MOI.VariableIndex}","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"MOI.Reals","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"MOI.ScalarAffineFunction{Float64} in MOI.EqualTo{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.Interval{Float64}\nMOI.ScalarAffineFunction{Float64} in MOI.LessThan{Float64}\nMOI.ScalarNonlinearFunction in MOI.EqualTo{Float64}\nMOI.ScalarNonlinearFunction in MOI.GreaterThan{Float64}\nMOI.ScalarNonlinearFunction in MOI.Interval{Float64}\nMOI.ScalarNonlinearFunction in MOI.LessThan{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.EqualTo{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.GreaterThan{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.Interval{Float64}\nMOI.ScalarQuadraticFunction{Float64} in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.EqualTo{Float64}\nMOI.VariableIndex in MOI.GreaterThan{Float64}\nMOI.VariableIndex in MOI.Integer\nMOI.VariableIndex in MOI.Interval{Float64}\nMOI.VariableIndex in MOI.LessThan{Float64}\nMOI.VariableIndex in MOI.ZeroOne\nMOI.VectorAffineFunction{Float64} in MOI.SecondOrderCone\nMOI.VectorOfVariables in MOI.Complements\nMOI.VectorOfVariables in MOI.SecondOrderCone","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"MOI.NLPBlock()\nMOI.NLPBlockDualStart()\nMOI.ObjectiveSense()","category":"page"},{"location":"packages/KNITRO/#Options","page":"jump-dev/KNITRO.jl","title":"Options","text":"","category":"section"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"A list of available options is provided in the KNITRO reference manual.","category":"page"},{"location":"packages/KNITRO/#Low-level-wrapper","page":"jump-dev/KNITRO.jl","title":"Low-level wrapper","text":"","category":"section"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"The complete C API can be accessed via KNITRO.KN_xx functions, where the names and arguments are identical to the C API.","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"See the KNITRO documentation for details.","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"As general rules when converting from Julia to C:","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"When KNITRO requires a Ptr{T} that holds one element, like double *, use a Ref{T}().\nWhen KNITRO requires a Ptr{T} that holds multiple elements, use a Vector{T}.\nWhen KNITRO requires a double, use Cdouble\nWhen KNITRO requires an int, use Cint\nWhen KNITRO requires a NULL, use C_NULL","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"Extensive examples using the C wrapper can be found in examples/.","category":"page"},{"location":"packages/KNITRO/#Breaking-changes","page":"jump-dev/KNITRO.jl","title":"Breaking changes","text":"","category":"section"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"KNITRO.jl v0.14.0 introduced a number of breaking changes to the low-level C API. The main changes were:","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"removing Julia-specific functions like KN_set_param. Use the C API functions like KN_set_int_param and KN_set_double_param_by_name.\nremoving intermediate methods that tried to make the C API more Julia-like. For example, we have removed the KN_add_var method that returned the index of the variable. There is now only the method from the C API.","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"If you have trouble updating, please open a GitHub issue.","category":"page"},{"location":"packages/KNITRO/#Multi-threading","page":"jump-dev/KNITRO.jl","title":"Multi-threading","text":"","category":"section"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"Due to limitations in the interaction between Julia and C, KNITRO.jl disables multi-threading if the problem is nonlinear. This will override any options such as par_numthreads that you may have set.","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"If you are using the low-level API, opt-in to enable multi-threading by calling KN_solve(model.env) instead of KN_solve(model), where model is the value returned by model = KN_new(). Note that calling KN_solve(model.env) is an advanced operation because it requires all callbacks you provide to be threadsafe.","category":"page"},{"location":"packages/KNITRO/","page":"jump-dev/KNITRO.jl","title":"jump-dev/KNITRO.jl","text":"Read GitHub issue #93 for more details.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"EditURL = \"https://github.com/jump-dev/MathOptInterface.jl/blob/v1.29.0/docs/src/manual/modification.md\"","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"CurrentModule = MathOptInterface\nDocTestSetup = quote\n    import MathOptInterface as MOI\nend\nDocTestFilters = [r\"MathOptInterface|MOI\"]","category":"page"},{"location":"moi/manual/modification/#Problem-modification","page":"Problem modification","title":"Problem modification","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"In addition to adding and deleting constraints and variables, MathOptInterface supports modifying, in-place, coefficients in the constraints and the objective function of a model.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"These modifications can be grouped into two categories:","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"modifications which replace the set of function of a constraint with a new set or function\nmodifications which change, in-place, a component of a function","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"warning: Warning\nSome ModelLike objects do not support problem modification.","category":"page"},{"location":"moi/manual/modification/#Modify-the-set-of-a-constraint","page":"Problem modification","title":"Modify the set of a constraint","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use set and ConstraintSet to modify the set of a constraint by replacing it with a new instance of the same type.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 0.0),\n           MOI.EqualTo(1.0),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}(1)\n\njulia> MOI.set(model, MOI.ConstraintSet(), c, MOI.EqualTo(2.0));\n\njulia> MOI.get(model, MOI.ConstraintSet(), c) == MOI.EqualTo(2.0)\ntrue","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"However, the following will fail as the new set is of a different type to the original set:","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> MOI.set(model, MOI.ConstraintSet(), c, MOI.GreaterThan(2.0))\nERROR: [...]","category":"page"},{"location":"moi/manual/modification/#Special-cases:-set-transforms","page":"Problem modification","title":"Special cases: set transforms","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"If our constraint is an affine inequality, then this corresponds to modifying the right-hand side of a constraint in linear programming.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"In some special cases, solvers may support efficiently changing the set of a constraint (for example, from LessThan to GreaterThan). For these cases, MathOptInterface provides the transform method.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"The transform function returns a new constraint index, and the old constraint index (that is, c) is no longer valid.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 0.0),\n           MOI.LessThan(1.0),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}(1)\n\njulia> new_c = MOI.transform(model, c, MOI.GreaterThan(2.0));\n\njulia> MOI.is_valid(model, c)\nfalse\n\njulia> MOI.is_valid(model, new_c)\ntrue","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"note: Note\ntransform cannot be called with a set of the same type. Use set instead.","category":"page"},{"location":"moi/manual/modification/#Modify-the-function-of-a-constraint","page":"Problem modification","title":"Modify the function of a constraint","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use set and ConstraintFunction to modify the function of a constraint by replacing it with a new instance of the same type.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 0.0),\n           MOI.EqualTo(1.0),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}(1)\n\njulia> new_f = MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(2.0, x)], 1.0);\n\njulia> MOI.set(model, MOI.ConstraintFunction(), c, new_f);\n\njulia> MOI.get(model, MOI.ConstraintFunction(), c) ≈ new_f\ntrue","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"However, the following will fail as the new function is of a different type to the original function:","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> MOI.set(model, MOI.ConstraintFunction(), c, x)\nERROR: [...]","category":"page"},{"location":"moi/manual/modification/#Modify-constant-term-in-a-scalar-function","page":"Problem modification","title":"Modify constant term in a scalar function","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use modify and ScalarConstantChange to modify the constant term in a ScalarAffineFunction or ScalarQuadraticFunction.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 0.0),\n           MOI.EqualTo(1.0),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}(1)\n\njulia> MOI.modify(model, c, MOI.ScalarConstantChange(1.0));\n\njulia> new_f = MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 1.0);\n\njulia> MOI.get(model, MOI.ConstraintFunction(), c) ≈ new_f\ntrue","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"ScalarConstantChange can also be used to modify the objective function by passing an instance of ObjectiveFunction:","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> MOI.set(\n           model,\n           MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n           new_f,\n       );\n\njulia> MOI.modify(\n           model,\n           MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n           MOI.ScalarConstantChange(-1.0)\n       );\n\njulia> MOI.get(\n           model,\n           MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n       ) ≈ MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], -1.0)\ntrue","category":"page"},{"location":"moi/manual/modification/#Modify-constant-terms-in-a-vector-function","page":"Problem modification","title":"Modify constant terms in a vector function","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use modify and VectorConstantChange to modify the constant vector in a VectorAffineFunction or VectorQuadraticFunction.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.VectorAffineFunction([\n                   MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(1.0, x)),\n                   MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(2.0, x)),\n               ],\n               [0.0, 0.0],\n           ),\n           MOI.Nonnegatives(2),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}(1)\n\njulia> MOI.modify(model, c, MOI.VectorConstantChange([3.0, 4.0]));\n\njulia> new_f = MOI.VectorAffineFunction(\n           [\n        MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(1.0, x)),\n        MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(2.0, x)),\n           ],\n           [3.0, 4.0],\n       );\n\njulia> MOI.get(model, MOI.ConstraintFunction(), c) ≈ new_f\ntrue","category":"page"},{"location":"moi/manual/modification/#Modify-affine-coefficients-in-a-scalar-function","page":"Problem modification","title":"Modify affine coefficients in a scalar function","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use modify and ScalarCoefficientChange to modify the affine coefficient of a ScalarAffineFunction or ScalarQuadraticFunction.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(1.0, x)], 0.0),\n           MOI.EqualTo(1.0),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}(1)\n\njulia> MOI.modify(model, c, MOI.ScalarCoefficientChange(x, 2.0));\n\njulia> new_f = MOI.ScalarAffineFunction([MOI.ScalarAffineTerm(2.0, x)], 0.0);\n\njulia> MOI.get(model, MOI.ConstraintFunction(), c) ≈ new_f\ntrue","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"ScalarCoefficientChange can also be used to modify the objective function by passing an instance of ObjectiveFunction.","category":"page"},{"location":"moi/manual/modification/#Modify-quadratic-coefficients-in-a-scalar-function","page":"Problem modification","title":"Modify quadratic coefficients in a scalar function","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use modify and ScalarQuadraticCoefficientChange to modify the quadratic coefficient of a ScalarQuadraticFunction.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> model = MOI.Utilities.Model{Float64}();\n\njulia> x = MOI.add_variables(model, 2);\n\njulia> c = MOI.add_constraint(\n           model,\n           1.0 * x[1] * x[1] + 2.0 * x[1] * x[2],\n           MOI.EqualTo(1.0),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.EqualTo{Float64}}(1)\n\njulia> MOI.modify(\n           model,\n           c,\n           MOI.ScalarQuadraticCoefficientChange(x[1], x[1], 3.0),\n       );\n\njulia> MOI.modify(\n           model,\n           c,\n           MOI.ScalarQuadraticCoefficientChange(x[1], x[2], 4.0),\n       );\n\njulia> new_f = 1.5 * x[1] * x[1] + 4.0 * x[1] * x[2];\n\njulia> MOI.get(model, MOI.ConstraintFunction(), c) ≈ new_f\ntrue","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"ScalarQuadraticCoefficientChange can also be used to modify the objective function by passing an instance of ObjectiveFunction.","category":"page"},{"location":"moi/manual/modification/#Modify-affine-coefficients-in-a-vector-function","page":"Problem modification","title":"Modify affine coefficients in a vector function","text":"","category":"section"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"Use modify and MultirowChange to modify a vector of affine coefficients in a VectorAffineFunction or a VectorQuadraticFunction.","category":"page"},{"location":"moi/manual/modification/","page":"Problem modification","title":"Problem modification","text":"julia> c = MOI.add_constraint(\n           model,\n           MOI.VectorAffineFunction([\n                   MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(1.0, x)),\n                   MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(2.0, x)),\n               ],\n               [0.0, 0.0],\n           ),\n           MOI.Nonnegatives(2),\n       )\nMathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}(1)\n\njulia> MOI.modify(model, c, MOI.MultirowChange(x, [(1, 3.0), (2, 4.0)]));\n\njulia> new_f = MOI.VectorAffineFunction(\n           [\n        MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(3.0, x)),\n        MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(4.0, x)),\n           ],\n           [0.0, 0.0],\n       );\n\njulia> MOI.get(model, MOI.ConstraintFunction(), c) ≈ new_f\ntrue","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"EditURL = \"facility_location.jl\"","category":"page"},{"location":"tutorials/linear/facility_location/#The-facility-location-problem","page":"The facility location problem","title":"The facility location problem","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"This tutorial was originally contributed by Mathieu Tanneau and Alexis Montoison.","category":"page"},{"location":"tutorials/linear/facility_location/#Required-packages","page":"The facility location problem","title":"Required packages","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"This tutorial requires the following packages:","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"using JuMP\nimport HiGHS\nimport LinearAlgebra\nimport Plots\nimport Random","category":"page"},{"location":"tutorials/linear/facility_location/#Uncapacitated-facility-location","page":"The facility location problem","title":"Uncapacitated facility location","text":"","category":"section"},{"location":"tutorials/linear/facility_location/#Problem-description","page":"The facility location problem","title":"Problem description","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"We are given","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"A set M=1 dots m of clients\nA set N= 1 dots n of sites where a facility can be built","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Decision variables Decision variables are split into two categories:","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Binary variable y_j indicates whether facility j is built or not\nBinary variable x_i j indicates whether client i is assigned to facility j","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Objective The objective is to minimize the total cost of serving all clients. This costs breaks down into two components:","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Fixed cost of building a facility.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"In this example, this cost is f_j = 1  forall j.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Cost of serving clients from the assigned facility.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"In this example, the cost c_i j of serving client i from facility j is the Euclidean distance between the two.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Constraints","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Each customer must be served by exactly one facility\nA facility cannot serve any client unless it is open","category":"page"},{"location":"tutorials/linear/facility_location/#MILP-formulation","page":"The facility location problem","title":"MILP formulation","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"The problem can be formulated as the following MILP:","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"beginaligned\nmin_x y    \nsum_i j c_i j x_i j +\nsum_j f_j y_j \nst \nsum_j x_i j = 1  forall i in M \n x_i j leq y_j  forall i in M j in N \n x_i j y_j in 0 1  forall i in M j in N\nendaligned","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"where the first set of constraints ensures that each client is served exactly once, and the second set of constraints ensures that no client is served from an unopened facility.","category":"page"},{"location":"tutorials/linear/facility_location/#Problem-data","page":"The facility location problem","title":"Problem data","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"To ensure reproducibility, we set the random number seed:","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Random.seed!(314)","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Here's the data we need:","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"# Number of clients\nm = 12\n# Number of facility locations\nn = 5\n\n# Clients' locations\nx_c, y_c = rand(m), rand(m)\n\n# Facilities' potential locations\nx_f, y_f = rand(n), rand(n)\n\n# Fixed costs\nf = ones(n);\n\n# Distance\nc = zeros(m, n)\nfor i in 1:m\n    for j in 1:n\n        c[i, j] = LinearAlgebra.norm([x_c[i] - x_f[j], y_c[i] - y_f[j]], 2)\n    end\nend","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Display the data","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Plots.scatter(\n    x_c,\n    y_c;\n    label = \"Clients\",\n    markershape = :circle,\n    markercolor = :blue,\n)\nPlots.scatter!(\n    x_f,\n    y_f;\n    label = \"Facility\",\n    markershape = :square,\n    markercolor = :white,\n    markersize = 6,\n    markerstrokecolor = :red,\n    markerstrokewidth = 2,\n)","category":"page"},{"location":"tutorials/linear/facility_location/#JuMP-implementation","page":"The facility location problem","title":"JuMP implementation","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Create a JuMP model","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, y[1:n], Bin);\n@variable(model, x[1:m, 1:n], Bin);\n# Each client is served exactly once\n@constraint(model, client_service[i in 1:m], sum(x[i, j] for j in 1:n) == 1);\n# A facility must be open to serve a client\n@constraint(model, open_facility[i in 1:m, j in 1:n], x[i, j] <= y[j]);\n@objective(model, Min, f' * y + sum(c .* x));\nnothing #hide","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Solve the uncapacitated facility location problem with HiGHS","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"optimize!(model)\n@assert is_solved_and_feasible(model)\nprintln(\"Optimal value: \", objective_value(model))","category":"page"},{"location":"tutorials/linear/facility_location/#Visualizing-the-solution","page":"The facility location problem","title":"Visualizing the solution","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"The threshold 1e-5 ensure that edges between clients and facilities are drawn when x[i, j] ≈ 1.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"x_is_selected = isapprox.(value.(x), 1; atol = 1e-5);\ny_is_selected = isapprox.(value.(y), 1; atol = 1e-5);\n\np = Plots.scatter(\n    x_c,\n    y_c;\n    markershape = :circle,\n    markercolor = :blue,\n    label = nothing,\n)\n\nPlots.scatter!(\n    x_f,\n    y_f;\n    markershape = :square,\n    markercolor = [(y_is_selected[j] ? :red : :white) for j in 1:n],\n    markersize = 6,\n    markerstrokecolor = :red,\n    markerstrokewidth = 2,\n    label = nothing,\n)\n\nfor i in 1:m, j in 1:n\n    if x_is_selected[i, j]\n        Plots.plot!(\n            [x_c[i], x_f[j]],\n            [y_c[i], y_f[j]];\n            color = :black,\n            label = nothing,\n        )\n    end\nend\n\np","category":"page"},{"location":"tutorials/linear/facility_location/#Capacitated-facility-location","page":"The facility location problem","title":"Capacitated facility location","text":"","category":"section"},{"location":"tutorials/linear/facility_location/#Problem-formulation","page":"The facility location problem","title":"Problem formulation","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"The capacitated variant introduces a capacity constraint on each facility, that is, clients have a certain level of demand to be served, while each facility only has finite capacity which cannot be exceeded.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Specifically,","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"The demand of client i is denoted by a_i geq 0\nThe capacity of facility j is denoted by q_j geq 0","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"The capacity constraints then write","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"beginaligned\nsum_i a_i x_i j leq q_j y_j  forall j in N\nendaligned","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Note that, if y_j is set to 0, the capacity constraint above automatically forces x_i j to 0.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Thus, the capacitated facility location can be formulated as follows","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"beginaligned\nmin_x y    \nsum_i j c_i j x_i j +\nsum_j f_j y_j \nst \nsum_j x_i j = 1  forall i in M \n sum_i a_i x_i j leq q_j y_j  forall j in N \n x_i j y_j in 0 1  forall i in M j in N\nendaligned","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"For simplicity, we will assume that there is enough capacity to serve the demand, that is, there exists at least one feasible solution.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"We need some new data:","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"# Demands\na = rand(1:3, m);\n\n# Capacities\nq = rand(5:10, n);\nnothing #hide","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Display the data","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Plots.scatter(\n    x_c,\n    y_c;\n    label = nothing,\n    markershape = :circle,\n    markercolor = :blue,\n    markersize = 2 .* (2 .+ a),\n)\n\nPlots.scatter!(\n    x_f,\n    y_f;\n    label = nothing,\n    markershape = :rect,\n    markercolor = :white,\n    markersize = q,\n    markerstrokecolor = :red,\n    markerstrokewidth = 2,\n)","category":"page"},{"location":"tutorials/linear/facility_location/#JuMP-implementation-2","page":"The facility location problem","title":"JuMP implementation","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Create a JuMP model","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"model = Model(HiGHS.Optimizer)\nset_silent(model)\n@variable(model, y[1:n], Bin);\n@variable(model, x[1:m, 1:n], Bin);\n# Each client is served exactly once\n@constraint(model, client_service[i in 1:m], sum(x[i, :]) == 1);\n# Capacity constraint\n@constraint(model, capacity, x' * a .<= (q .* y));\n# Objective\n@objective(model, Min, f' * y + sum(c .* x));\nnothing #hide","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Solve the problem","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"optimize!(model)\n@assert is_solved_and_feasible(model)\nprintln(\"Optimal value: \", objective_value(model))","category":"page"},{"location":"tutorials/linear/facility_location/#Visualizing-the-solution-2","page":"The facility location problem","title":"Visualizing the solution","text":"","category":"section"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"The threshold 1e-5 ensure that edges between clients and facilities are drawn when x[i, j] ≈ 1.","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"x_is_selected = isapprox.(value.(x), 1; atol = 1e-5);\ny_is_selected = isapprox.(value.(y), 1; atol = 1e-5);\nnothing #hide","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"Display the solution","category":"page"},{"location":"tutorials/linear/facility_location/","page":"The facility location problem","title":"The facility location problem","text":"p = Plots.scatter(\n    x_c,\n    y_c;\n    label = nothing,\n    markershape = :circle,\n    markercolor = :blue,\n    markersize = 2 .* (2 .+ a),\n)\n\nPlots.scatter!(\n    x_f,\n    y_f;\n    label = nothing,\n    markershape = :rect,\n    markercolor = [(y_is_selected[j] ? :red : :white) for j in 1:n],\n    markersize = q,\n    markerstrokecolor = :red,\n    markerstrokewidth = 2,\n)\n\nfor i in 1:m, j in 1:n\n    if x_is_selected[i, j]\n        Plots.plot!(\n            [x_c[i], x_f[j]],\n            [y_c[i], y_f[j]];\n            color = :black,\n            label = nothing,\n        )\n    end\nend\n\np","category":"page"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"EditURL = \"https://github.com/jump-dev/Xpress.jl/blob/v0.16.2/README.md\"","category":"page"},{"location":"packages/Xpress/#Xpress.jl","page":"jump-dev/Xpress.jl","title":"Xpress.jl","text":"","category":"section"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"Xpress.jl is a wrapper for the FICO Xpress Solver.","category":"page"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"It has two components:","category":"page"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"a thin wrapper around the complete C API\nan interface to MathOptInterface","category":"page"},{"location":"packages/Xpress/#Affiliation","page":"jump-dev/Xpress.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"The Xpress wrapper for Julia is community driven and not officially supported by FICO Xpress. If you are a commercial customer interested in official support for Julia from FICO Xpress, let them know.","category":"page"},{"location":"packages/Xpress/#License","page":"jump-dev/Xpress.jl","title":"License","text":"","category":"section"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"Xpress.jl is licensed under the MIT License.","category":"page"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"The underlying solver is a closed-source commercial product for which you must purchase a license.","category":"page"},{"location":"packages/Xpress/#Installation","page":"jump-dev/Xpress.jl","title":"Installation","text":"","category":"section"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"First, obtain a license of Xpress and install Xpress solver, following the instructions on the FICO website.","category":"page"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"Then, install this package using:","category":"page"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"import Pkg\nPkg.add(\"Xpress\")","category":"page"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"If you encounter an error, make sure that the XPRESSDIR environmental variable is set to the path of the Xpress directory. This should be part of a standard installation. The Xpress library will be searched for in XPRESSDIR/lib on Unix platforms and XPRESSDIR/bin on Windows.","category":"page"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"For example, on macOS, you may need:","category":"page"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"ENV[\"XPRESSDIR\"] = \"/Applications/FICO Xpress/xpressmp/\"\nimport Pkg\nPkg.add(\"Xpress\")","category":"page"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"By default, building Xpress.jl will fail if the Xpress library is not found. This may not be desirable in certain cases, for example when part of a package's test suite uses Xpress as an optional test dependency, but Xpress cannot be installed on a CI server running the test suite. To support this use case, the XPRESS_JL_SKIP_LIB_CHECK environment variable may be set (to any value) to make Xpress.jl installable (but not usable).","category":"page"},{"location":"packages/Xpress/#Use-with-JuMP","page":"jump-dev/Xpress.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"To use Xpress with JuMP, use:","category":"page"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"using JuMP, Xpress\nmodel = Model(Xpress.Optimizer)\nset_optimizer(model, \"PRESOLVE\", 0)","category":"page"},{"location":"packages/Xpress/#Options","page":"jump-dev/Xpress.jl","title":"Options","text":"","category":"section"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"For other parameters use Xpress Optimizer manual or type julia -e \"using Xpress; println(keys(Xpress.XPRS_ATTRIBUTES))\".","category":"page"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"If logfile is set to \"\", the log file is disabled and output is printed to the console (there might be issues with console output on windows (it is manually implemented with callbacks)). If logfile is set to a file's path, output is printed to that file. By default, logfile = \"\" (console).","category":"page"},{"location":"packages/Xpress/#Callbacks","page":"jump-dev/Xpress.jl","title":"Callbacks","text":"","category":"section"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"Solver specific and solver independent callbacks are working in MathOptInterface and, consequently, in JuMP. However, the current implementation should be considered experimental.","category":"page"},{"location":"packages/Xpress/#Environment-variables","page":"jump-dev/Xpress.jl","title":"Environment variables","text":"","category":"section"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"XPRESS_JL_SKIP_LIB_CHECK: Used to skip build lib check as previously described.\nXPRESS_JL_NO_INFO: Disable license info log.\nXPRESS_JL_NO_DEPS_ERROR: Disable error when do deps.jl file is found.\nXPRESS_JL_NO_AUTO_INIT: Disable automatic run of Xpress.initialize().","category":"page"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"Specially useful for explicitly loading the dynamic library.","category":"page"},{"location":"packages/Xpress/#Skipping-Xpress.postsolve","page":"jump-dev/Xpress.jl","title":"Skipping Xpress.postsolve","text":"","category":"section"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"In older versions of Xpress, the command XPRSpostsolve throws an error in infeasible models. In these older versions the post solve should not be executed. To do this, one can use the MOI.RawOptimizerAttribute(\"MOI_POST_SOLVE\") to skip this routine.","category":"page"},{"location":"packages/Xpress/#C-API","page":"jump-dev/Xpress.jl","title":"C API","text":"","category":"section"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"The C API can be accessed via Xpress.Lib.XPRSxx functions, where the names and arguments are identical to the C API. ","category":"page"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"See the Xpress documentation for details.","category":"page"},{"location":"packages/Xpress/#Documentation","page":"jump-dev/Xpress.jl","title":"Documentation","text":"","category":"section"},{"location":"packages/Xpress/","page":"jump-dev/Xpress.jl","title":"jump-dev/Xpress.jl","text":"For more information, consult the FICO optimizer manual.","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"EditURL = \"mip_duality.jl\"","category":"page"},{"location":"tutorials/linear/mip_duality/#Computing-the-duals-of-a-mixed-integer-program","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"","category":"section"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"This tutorial explains how to compute the duals of a mixed-integer linear program by fixing the discrete variables to their optimal solution and resolving as a linear program.","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"using JuMP\nimport HiGHS","category":"page"},{"location":"tutorials/linear/mip_duality/#The-model","page":"Computing the duals of a mixed-integer program","title":"The model","text":"","category":"section"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"Our example model is the unit commitment example from Unit commitment. The details are unimportant, other than to note that there are two types of continuous variables, g and w, representing the quantity of generation from thermal and wind plants, and a discrete variable dispatch, which is 1 if plant i is operating, and 0 if not.","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"We are interested in the \"dual\" of the power_balance constraint, because it represents the marginal price of electricity that consumers should pay for their consumption.","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"generators = [\n    (min = 0.0, max = 1000.0, fixed_cost = 1000.0, variable_cost = 50.0),\n    (min = 300.0, max = 1000.0, fixed_cost = 0.0, variable_cost = 100.0),\n]\nN = length(generators)\nmodel = Model(HiGHS.Optimizer)\nset_silent(model)\n@variables(model, begin\n    generators[i].min <= g[i = 1:N] <= generators[i].max\n    0 <= w <= 200\n    dispatch[i = 1:N], Bin\nend)\n@constraints(model, begin\n    power_balance, sum(g[i] for i in 1:N) + w == 1500\n    [i = 1:N], g[i] <= generators[i].max * dispatch[i]\n    [i = 1:N], g[i] >= generators[i].min * dispatch[i]\nend)\n@objective(\n    model,\n    Min,\n    sum(\n        generators[i].fixed_cost * dispatch[i] +\n        generators[i].variable_cost * g[i] for i in 1:N\n    )\n)\nprint(model)","category":"page"},{"location":"tutorials/linear/mip_duality/#Manually-fix-the-variables","page":"Computing the duals of a mixed-integer program","title":"Manually fix the variables","text":"","category":"section"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"If we optimize this model, we obtain a dual_status of NO_SOLUTION:","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"optimize!(model)\n@assert is_solved_and_feasible(model)\ndual_status(model)","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"This is because HiGHS cannot compute the duals of a mixed-integer program. We can work around this problem by fixing the integer variables to their optimal solution, relaxing integrality, and re-solving as a linear program.","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"discrete_values = value.(dispatch)\nfix.(dispatch, discrete_values; force = true)\nunset_binary.(dispatch)\nprint(model)","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"Now if we re-solve the problem, we obtain a FEASIBLE_POINT for the dual:","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"optimize!(model)\n@assert is_solved_and_feasible(model)\ndual_status(model)","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"and a marginal price of electricity of $100/MWh:","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"dual(power_balance)","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"To reset the problem back to a mixed-integer linear program, we need to unfix and call set_binary:","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"unfix.(dispatch)\nset_binary.(dispatch)\nprint(model)","category":"page"},{"location":"tutorials/linear/mip_duality/#Use-fix_discrete_variables","page":"Computing the duals of a mixed-integer program","title":"Use fix_discrete_variables","text":"","category":"section"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"Manually choosing the variables to relax and fix works for our small example, but it becomes more difficult in problems with a larger number of binary and integer variables. To automate the process we just did manually, JuMP provides the fix_discrete_variables function:","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"optimize!(model)\n@assert is_solved_and_feasible(model)\ndual_status(model)","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"undo = fix_discrete_variables(model);\nnothing #hide","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"Here undo is a function that, when called with no arguments, returns the model to the original mixed-integer formulation.","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"tip: Tip\nAfter calling fix_discrete_variables, you can set a new solver with set_optimizer if your mixed-integer solver does not support computing a dual solution.","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"print(model)","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"optimize!(model)\n@assert is_solved_and_feasible(model)\ndual_status(model)","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"dual(power_balance)","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"Finally, call undo to revert the reformulation","category":"page"},{"location":"tutorials/linear/mip_duality/","page":"Computing the duals of a mixed-integer program","title":"Computing the duals of a mixed-integer program","text":"undo()\nprint(model)","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"EditURL = \"min_ellipse.jl\"","category":"page"},{"location":"tutorials/conic/min_ellipse/#Minimal-ellipses","page":"Minimal ellipses","title":"Minimal ellipses","text":"","category":"section"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"This example comes from section 8.4.1 of the book Convex Optimization by Boyd and Vandenberghe (2004).","category":"page"},{"location":"tutorials/conic/min_ellipse/#Formulation","page":"Minimal ellipses","title":"Formulation","text":"","category":"section"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"Given a set of m ellipses of the form:","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"E(A b c) =  x  x^top A x + 2 b^top x + c leq 0 ","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"the minimal ellipse problem finds an ellipse with the minimum area that encloses the given ellipses.","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"It is convenient to parameterize the minimal enclosing ellipse as","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":" x   Px + q  leq 1 ","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"Then the optimal P and q are given by the convex semidefinite program;","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"beginaligned\ntextmaximize   quad log(det(P))  \ntextsubject to   quad tau_i geq 0  i = 1 ldots m \n quadbeginbmatrix\n    P^2 - tau_i A_i          P q - tau_i b_i       0        \n    (P q - tau_i b_i)^top    -1 - tau_i c_i     (P q)^top \n                0                     (P q)       - P^2       \nendbmatrix\npreceq 0 text (PSD)    i=1 ldots m\nendaligned","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"with helper variables tau.","category":"page"},{"location":"tutorials/conic/min_ellipse/#Required-packages","page":"Minimal ellipses","title":"Required packages","text":"","category":"section"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"using JuMP\nimport LinearAlgebra\nimport Plots\nimport SCS\nimport Test","category":"page"},{"location":"tutorials/conic/min_ellipse/#Data","page":"Minimal ellipses","title":"Data","text":"","category":"section"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"First, define the m input ellipses (here m = 6), parameterized as x^T A_i x + 2 b_i^T x + c leq 0:","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"struct Ellipse\n    A::Matrix{Float64}\n    b::Vector{Float64}\n    c::Float64\n    function Ellipse(A::Matrix{Float64}, b::Vector{Float64}, c::Float64)\n        @assert isreal(A) && LinearAlgebra.issymmetric(A)\n        return new(A, b, c)\n    end\nend\n\nellipses = [\n    Ellipse([1.2576 -0.3873; -0.3873 0.3467], [0.2722, 0.1969], 0.1831),\n    Ellipse([1.4125 -2.1777; -2.1777 6.7775], [-1.228, -0.0521], 0.3295),\n    Ellipse([1.7018 0.8141; 0.8141 1.7538], [-0.4049, 1.5713], 0.2077),\n    Ellipse([0.9742 -0.7202; -0.7202 1.5444], [0.0265, 0.5623], 0.2362),\n    Ellipse([0.6798 -0.1424; -0.1424 0.6871], [-0.4301, -1.0157], 0.3284),\n    Ellipse([0.1796 -0.1423; -0.1423 2.6181], [-0.3286, 0.557], 0.4931),\n];\nnothing #hide","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"We visualise the ellipses using the Plots package:","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"function plot_ellipse(plot, ellipse::Ellipse)\n    A, b, c = ellipse.A, ellipse.b, ellipse.c\n    θ = range(0, 2pi + 0.05; step = 0.05)\n    # Some linear algebra to convert θ into (x,y) coordinates.\n    x_y = √A \\ (√(b' * (A \\ b) - c) .* hcat(cos.(θ), sin.(θ)) .- (√A \\ b)')'\n    Plots.plot!(plot, x_y[1, :], x_y[2, :]; label = nothing, c = :navy)\n    return\nend\n\nplot = Plots.plot(; size = (600, 600))\nfor ellipse in ellipses\n    plot_ellipse(plot, ellipse)\nend\nplot","category":"page"},{"location":"tutorials/conic/min_ellipse/#Build-the-model","page":"Minimal ellipses","title":"Build the model","text":"","category":"section"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"Now let's build the model, using the change-of-variables P² = P^2 and P_q = P q. We'll recover the true value of P and q after the solve.","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"model = Model(SCS.Optimizer)\n# We need to use a tighter tolerance for this example, otherwise the bounding\n# ellipse won't actually be bounding...\nset_attribute(model, \"eps_rel\", 1e-6)\nset_silent(model)\nm, n = length(ellipses), size(first(ellipses).A, 1)\n@variable(model, τ[1:m] >= 0)\n@variable(model, P²[1:n, 1:n], PSD)\n@variable(model, P_q[1:n])\n\nfor (i, ellipse) in enumerate(ellipses)\n    A, b, c = ellipse.A, ellipse.b, ellipse.c\n    X = [\n        #! format: off\n        (P² - τ[i] * A)   (P_q - τ[i] * b) zeros(n, n)\n        (P_q - τ[i] * b)' (-1 - τ[i] * c)  P_q'\n        zeros(n, n)       P_q              -P²\n        #! format: on\n    ]\n    @constraint(model, LinearAlgebra.Symmetric(X) <= 0, PSDCone())\nend","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"We cannot directly represent the objective log(det(P)), so we introduce the conic reformulation:","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"@variable(model, log_det_P)\n@constraint(model, [log_det_P; 1; vec(P²)] in MOI.LogDetConeSquare(n))\n@objective(model, Max, log_det_P)","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"Now, solve the program:","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"optimize!(model)\nTest.@test is_solved_and_feasible(model)\nsolution_summary(model)","category":"page"},{"location":"tutorials/conic/min_ellipse/#Results","page":"Minimal ellipses","title":"Results","text":"","category":"section"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"After solving the model to optimality we can recover the solution in terms of P and q:","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"P = sqrt(value.(P²))\nq = P \\ value.(P_q)","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"Finally, overlaying the solution in the plot we see the minimal area enclosing ellipsoid:","category":"page"},{"location":"tutorials/conic/min_ellipse/","page":"Minimal ellipses","title":"Minimal ellipses","text":"Plots.plot!(\n    plot,\n    [tuple(P \\ [cos(θ) - q[1], sin(θ) - q[2]]...) for θ in 0:0.05:(2pi+0.05)];\n    c = :crimson,\n    label = nothing,\n)","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"EditURL = \"https://github.com/jump-dev/CSDP.jl/blob/3a2e4c7c48af7660a5ba258a4cb6549ab0970366/README.md\"","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"(Image: )","category":"page"},{"location":"packages/CSDP/#CSDP.jl","page":"jump-dev/CSDP.jl","title":"CSDP.jl","text":"","category":"section"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"CSDP.jl is a wrapper for the COIN-OR SemiDefinite Programming solver.","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"The wrapper has two components:","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"a thin wrapper around the low-level C API\nan interface to MathOptInterface","category":"page"},{"location":"packages/CSDP/#Affiliation","page":"jump-dev/CSDP.jl","title":"Affiliation","text":"","category":"section"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"This wrapper is maintained by the JuMP community and is not a COIN-OR project.","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"The original algorithm is described by B. Borchers (1999). CSDP, A C Library for Semidefinite Programming. Optimization Methods and Software. 11(1), 613-623. [preprint]","category":"page"},{"location":"packages/CSDP/#License","page":"jump-dev/CSDP.jl","title":"License","text":"","category":"section"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"CSDP.jl is licensed under the MIT License.","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"The underlying solver, coin-or/Csdp, is licensed under the Eclipse public license.","category":"page"},{"location":"packages/CSDP/#Installation","page":"jump-dev/CSDP.jl","title":"Installation","text":"","category":"section"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"Install CSDP using Pkg.add:","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"import Pkg\nPkg.add(\"CSDP\")","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"In addition to installing the CSDP.jl package, this will also download and install the CSDP binaries. You do not need to install CSDP separately.","category":"page"},{"location":"packages/CSDP/#Use-with-JuMP","page":"jump-dev/CSDP.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"To use CSDP with JuMP, use CSDP.Optimizer:","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"using JuMP, CSDP\nmodel = Model(CSDP.Optimizer)\nset_attribute(model, \"maxiter\", 1000)","category":"page"},{"location":"packages/CSDP/#MathOptInterface-API","page":"jump-dev/CSDP.jl","title":"MathOptInterface API","text":"","category":"section"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"The CSDP optimizer supports the following constraints and attributes.","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"List of supported objective functions:","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"List of supported variable types:","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"MOI.Nonnegatives\nMOI.PositiveSemidefiniteConeTriangle","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"List of supported constraint types:","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"MOI.ScalarAffineFunction{Float64} in MOI.EqualTo{Float64}","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"List of supported model attributes:","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"MOI.ObjectiveSense()","category":"page"},{"location":"packages/CSDP/#Options","page":"jump-dev/CSDP.jl","title":"Options","text":"","category":"section"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"The CSDP options are listed in the table below.","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"Name Default Value Explanation\naxtol 1.0e-8 Tolerance for primal feasibility\natytol 1.0e-8 Tolerance for dual feasibility\nobjtol 1.0e-8 Tolerance for relative duality gap\npinftol 1.0e8 Tolerance for determining primal infeasibility\ndinftol 1.0e8 Tolerance for determining dual infeasibility\nmaxiter 100 Limit for the total number of iterations\nminstepfrac 0.90 The minstepfrac and maxstepfrac parameters determine how close to the edge of the feasible region CSDP will step\nmaxstepfrac 0.97 The minstepfrac and maxstepfrac parameters determine how close to the edge of the feasible region CSDP will step\nminstepp 1.0e-8 If the primal step is shorter than minstepp then CSDP declares a line search failure\nminstepd 1.0e-8 If the dual step is shorter than minstepd then CSDP declares a line search failure\nusexzgap 1 If usexzgap is 0 then CSDP will use the objective duality gap d - p instead of the XY duality gap ⟨Z, X⟩\ntweakgap 0 If tweakgap is set to 1, and usexzgap is set to 0, then CSDP will attempt to \"fix\" negative duality gaps\naffine 0 If affine is set to 1, then CSDP will take only primal-dual affine steps and not make use of the barrier term. This can be useful for some problems that do not have feasible solutions that are strictly in the interior of the cone of semidefinite matrices\nperturbobj 1 The perturbobj parameter determines whether the objective function will be perturbed to help deal with problems that have unbounded optimal solution sets. If perturbobj is 0, then the objective will not be perturbed. If perturbobj is 1, then the objective function will be perturbed by a default amount. Larger values of perturbobj (for example, 100) increase the size of the perturbation. This can be helpful in solving some difficult problems.\nfastmode 0 The fastmode parameter determines whether or not CSDP will skip certain time consuming operations that slightly improve the accuracy of the solutions. If fastmode is set to 1, then CSDP may be somewhat faster, but also somewhat less accurate\nprintlevel 1 The printlevel parameter determines how much debugging information is output. Use a printlevel of 0 for no output and a printlevel of 1 for normal output. Higher values of printlevel will generate more debugging output","category":"page"},{"location":"packages/CSDP/#Problem-representation","page":"jump-dev/CSDP.jl","title":"Problem representation","text":"","category":"section"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"The primal is represented internally by CSDP as follows:","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"max ⟨C, X⟩\n      A(X) = a\n         X ⪰ 0","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"where A(X) = [⟨A_1, X⟩, ..., ⟨A_m, X⟩]. The corresponding dual is:","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"min ⟨a, y⟩\n     A'(y) - C = Z\n             Z ⪰ 0","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"where A'(y) = y_1A_1 + ... + y_mA_m","category":"page"},{"location":"packages/CSDP/#Termination-criteria","page":"jump-dev/CSDP.jl","title":"Termination criteria","text":"","category":"section"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"CSDP will terminate successfully (or partially) in the following cases:","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"If CSDP finds X, Z ⪰ 0 such that the following 3 tolerances are satisfied:\nprimal feasibility tolerance: ||A(x) - a||_2 / (1 + ||a||_2) < axtol\ndual feasibility tolerance: ||A'(y) - C - Z||_F / (1 + ||C||_F) < atytol\nrelative duality gap tolerance: gap / (1 + |⟨a, y⟩| + |⟨C, X⟩|) < objtol\nobjective duality gap: if usexygap is 0, gap = ⟨a, y⟩ - ⟨C, X⟩\nXY duality gap: if usexygap is 1, gap = ⟨Z, X⟩\nthen it returns 0.\nIf CSDP finds y and Z ⪰ 0 such that -⟨a, y⟩ / ||A'(y) - Z||_F > pinftol, it returns 1 with y such that ⟨a, y⟩ = -1.\nIf CSDP finds X ⪰ 0 such that ⟨C, X⟩ / ||A(X)||_2 > dinftol, it returns 2 with X such that ⟨C, X⟩ = 1.\nIf CSDP finds X, Z ⪰ 0 such that the following 3 tolerances are satisfied with 1000*axtol, 1000*atytol and 1000*objtol but at least one of them is not satisfied with axtol, atytol and objtol and cannot make progress, then it returns 3.","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"In addition, if the printlevel option is at least 1, the following will be printed:","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"If the return code is 1, CSDP will print ⟨a, y⟩ and ||A'(y) - Z||_F\nIf the return code is 2, CSDP will print ⟨C, X⟩ and ||A(X)||_F\nOtherwise, CSDP will print\nthe primal/dual objective value,\nthe relative primal/dual infeasibility,\nthe objective duality gap ⟨a, y⟩ - ⟨C, X⟩ and objective relative duality gap (⟨a, y⟩ - ⟨C, X⟩) / (1 + |⟨a, y⟩| + |⟨C, X⟩|),\nthe XY duality gap ⟨Z, X⟩ and XY relative duality gap ⟨Z, X⟩ / (1 + |⟨a, y⟩| + |⟨C, X⟩|)\nand the DIMACS error measures.","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"In theory, for feasible primal and dual solutions, ⟨a, y⟩ - ⟨C, X⟩ = ⟨Z, X⟩, so the objective and XY duality gap should be equivalent. However, in practice, there are sometimes solution which satisfy primal and dual feasibility tolerances but have objective duality gap which are not close to XY duality gap. In some cases, the objective duality gap may even become negative (hence the tweakgap option). This is the reason usexygap is 1 by default.","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"CSDP considers that X ⪰ 0 (resp. Z ⪰ 0) is satisfied when the Cholesky factorizations can be computed. In practice, this is somewhat more conservative than simply requiring all eigenvalues to be nonnegative.","category":"page"},{"location":"packages/CSDP/#Status","page":"jump-dev/CSDP.jl","title":"Status","text":"","category":"section"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"The table below shows how the different CSDP statuses are converted to the MathOptInterface statuses.","category":"page"},{"location":"packages/CSDP/","page":"jump-dev/CSDP.jl","title":"jump-dev/CSDP.jl","text":"CSDP code State Description MOI status\n0 Success SDP solved MOI.OPTIMAL\n1 Success The problem is primal infeasible, and we have a certificate MOI.INFEASIBLE\n2 Success The problem is dual infeasible, and we have a certificate MOI.DUAL_INFEASIBLE\n3 Partial Success A solution has been found, but full accuracy was not achieved MOI.ALMOST_OPTIMAL\n4 Failure Maximum iterations reached MOI.ITERATION_LIMIT\n5 Failure Stuck at edge of primal feasibility MOI.SLOW_PROGRESS\n6 Failure Stuck at edge of dual infeasibility MOI.SLOW_PROGRESS\n7 Failure Lack of progress MOI.SLOW_PROGRESS\n8 Failure X, Z, or O was singular MOI.NUMERICAL_ERROR\n9 Failure Detected NaN or Inf values MOI.NUMERICAL_ERROR","category":"page"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"EditURL = \"start_values.jl\"","category":"page"},{"location":"tutorials/conic/start_values/#Primal-and-dual-warm-starts","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"","category":"section"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"Some conic solvers have the ability to set warm-starts for the primal and dual solution. This can improve performance, particularly if you are repeatedly solving a sequence of related problems.","category":"page"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"tip: Tip\nSee set_start_values for a generic implementation of this function that was added to JuMP after this tutorial was written.","category":"page"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"In this tutorial, we demonstrate how to write a function that sets the primal and dual starts as the optimal solution stored in a model. It is intended to be a starting point for which you can modify if you want to do something similar in your own code.","category":"page"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"warning: Warning\nThis tutorial does not set start values for nonlinear models.","category":"page"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"using JuMP\nimport SCS","category":"page"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"The main component of this tutorial is the following function. The most important observation is that we cache all of the solution values first, and then we modify the model second. (Alternating between querying a value and modifying the model is not allowed in JuMP.)","category":"page"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"function set_optimal_start_values(model::Model)\n    # Store a mapping of the variable primal solution\n    variable_primal = Dict(x => value(x) for x in all_variables(model))\n    # In the following, we loop through every constraint and store a mapping\n    # from the constraint index to a tuple containing the primal and dual\n    # solutions.\n    constraint_solution = Dict()\n    for (F, S) in list_of_constraint_types(model)\n        # We add a try-catch here because some constraint types might not\n        # support getting the primal or dual solution.\n        try\n            for ci in all_constraints(model, F, S)\n                constraint_solution[ci] = (value(ci), dual(ci))\n            end\n        catch\n            @info(\"Something went wrong getting $F-in-$S. Skipping\")\n        end\n    end\n    # Now we can loop through our cached solutions and set the starting values.\n    for (x, primal_start) in variable_primal\n        set_start_value(x, primal_start)\n    end\n    for (ci, (primal_start, dual_start)) in constraint_solution\n        set_start_value(ci, primal_start)\n        set_dual_start_value(ci, dual_start)\n    end\n    return\nend","category":"page"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"To test our function, we use the following linear program:","category":"page"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"model = Model(SCS.Optimizer)\n@variable(model, x[1:3] >= 0)\n@constraint(model, sum(x) <= 1)\n@objective(model, Max, sum(i * x[i] for i in 1:3))\noptimize!(model)\n@assert is_solved_and_feasible(model)","category":"page"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"By looking at the log, we can see that SCS took 75 iterations to find the optimal solution. Now we set the optimal solution as our starting point:","category":"page"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"set_optimal_start_values(model)","category":"page"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"and we re-optimize:","category":"page"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"optimize!(model)","category":"page"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"Now the optimization terminates after 0 iterations because our starting point is already optimal.","category":"page"},{"location":"tutorials/conic/start_values/","page":"Primal and dual warm-starts","title":"Primal and dual warm-starts","text":"Note that some solvers do not support setting some parts of the starting solution, for example, they may support only set_start_value for variables. If you encounter an UnsupportedSupported attribute error for MOI.VariablePrimalStart, MOI.ConstraintPrimalStart, or MOI.ConstraintDualStart, comment out the corresponding part of the set_optimal_start_values function.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP, HiGHS\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/solutions/#jump_solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"This section of the manual describes how to access a solved solution to a problem. It uses the following model as an example:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> begin\n           model = Model(HiGHS.Optimizer)\n           set_silent(model)\n           @variable(model, x >= 0)\n           @variable(model, y[[:a, :b]] <= 1)\n           @objective(model, Max, -12x - 20y[:a])\n           @expression(model, my_expr, 6x + 8y[:a])\n           @constraint(model, my_expr >= 100)\n           @constraint(model, c1, 7x + 12y[:a] >= 120)\n           optimize!(model)\n           print(model)\n       end\nMax -12 x - 20 y[a]\nSubject to\n 6 x + 8 y[a] ≥ 100\n c1 : 7 x + 12 y[a] ≥ 120\n x ≥ 0\n y[a] ≤ 1\n y[b] ≤ 1","category":"page"},{"location":"manual/solutions/#Check-if-an-optimal-solution-exists","page":"Solutions","title":"Check if an optimal solution exists","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Use is_solved_and_feasible to check if the solver found an optimal solution:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> is_solved_and_feasible(model)\ntrue","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"By default, is_solved_and_feasible returns true for both global and local optima. Pass allow_local = false to check if the solver found a globally optimal solution:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> is_solved_and_feasible(model; allow_local = false)\ntrue","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Pass dual = true to check if the solver found an optimal dual solution in addition to an optimal primal solution:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> is_solved_and_feasible(model; dual = true)\ntrue","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If this function returns false, use the functions mentioned below like solution_summary, termination_status, primal_status, and dual_status to understand what solution (if any) the solver found.","category":"page"},{"location":"manual/solutions/#Solutions-summary","page":"Solutions","title":"Solutions summary","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"solution_summary can be used for checking the summary of the optimization solutions.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> solution_summary(model)\n* Solver : HiGHS\n\n* Status\n  Result count       : 1\n  Termination status : OPTIMAL\n  Message from the solver:\n  \"kHighsModelStatusOptimal\"\n\n* Candidate solution (result #1)\n  Primal status      : FEASIBLE_POINT\n  Dual status        : FEASIBLE_POINT\n  Objective value    : -2.05143e+02\n  Objective bound    : -0.00000e+00\n  Relative gap       : Inf\n  Dual objective value : -2.05143e+02\n\n* Work counters\n  Solve time (sec)   : 6.70987e-04\n  Simplex iterations : 2\n  Barrier iterations : 0\n  Node count         : -1\n\njulia> solution_summary(model; verbose = true)\n* Solver : HiGHS\n\n* Status\n  Result count       : 1\n  Termination status : OPTIMAL\n  Message from the solver:\n  \"kHighsModelStatusOptimal\"\n\n* Candidate solution (result #1)\n  Primal status      : FEASIBLE_POINT\n  Dual status        : FEASIBLE_POINT\n  Objective value    : -2.05143e+02\n  Objective bound    : -0.00000e+00\n  Relative gap       : Inf\n  Dual objective value : -2.05143e+02\n  Primal solution :\n    x : 1.54286e+01\n    y[a] : 1.00000e+00\n    y[b] : 1.00000e+00\n  Dual solution :\n    c1 : 1.71429e+00\n\n* Work counters\n  Solve time (sec)   : 6.70987e-04\n  Simplex iterations : 2\n  Barrier iterations : 0\n  Node count         : -1","category":"page"},{"location":"manual/solutions/#Why-did-the-solver-stop?","page":"Solutions","title":"Why did the solver stop?","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Usetermination_status to understand why the solver stopped.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> termination_status(model)\nOPTIMAL::TerminationStatusCode = 1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The MOI.TerminationStatusCode enum describes the full list of statuses that could be returned.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Common return values include OPTIMAL, LOCALLY_SOLVED, INFEASIBLE, DUAL_INFEASIBLE, and TIME_LIMIT.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"info: Info\nA return status of OPTIMAL means the solver found (and proved) a globally optimal solution. A return status of LOCALLY_SOLVED means the solver found a locally optimal solution (which may also be globally optimal, but it could not prove so).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nA return status of DUAL_INFEASIBLE does not guarantee that the primal is unbounded. When the dual is infeasible, the primal is unbounded if there exists a feasible primal solution.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Use raw_status to get a solver-specific string explaining why the optimization stopped:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> raw_status(model)\n\"kHighsModelStatusOptimal\"","category":"page"},{"location":"manual/solutions/#Primal-solutions","page":"Solutions","title":"Primal solutions","text":"","category":"section"},{"location":"manual/solutions/#Primal-solution-status","page":"Solutions","title":"Primal solution status","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Use primal_status to return an MOI.ResultStatusCode enum describing the status of the primal solution.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> primal_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Other common returns are NO_SOLUTION, and INFEASIBILITY_CERTIFICATE. The first means that the solver doesn't have a solution to return, and the second means that the primal solution is a certificate of dual infeasibility (a primal unbounded ray).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"You can also use has_values, which returns true if there is a solution that can be queried, and false otherwise.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> has_values(model)\ntrue","category":"page"},{"location":"manual/solutions/#Objective-values","page":"Solutions","title":"Objective values","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The objective value of a solved problem can be obtained via objective_value. The best known bound on the optimal objective value can be obtained via objective_bound. If the solver supports it, the value of the dual objective can be obtained via dual_objective_value.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> objective_value(model)\n-205.14285714285714\n\njulia> objective_bound(model)  # HiGHS only implements objective bound for MIPs\n-0.0\n\njulia> dual_objective_value(model)\n-205.1428571428571","category":"page"},{"location":"manual/solutions/#Primal-solution-values","page":"Solutions","title":"Primal solution values","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If the solver has a primal solution to return, use value to access it:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> value(x)\n15.428571428571429","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Broadcast value over containers:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> value.(y)\n1-dimensional DenseAxisArray{Float64,1,...} with index sets:\n    Dimension 1, [:a, :b]\nAnd data, a 2-element Vector{Float64}:\n 1.0\n 1.0","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"value also works on expressions:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> value(my_expr)\n100.57142857142857","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"and constraints:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> value(c1)\n120.0","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"info: Info\nCalling value on a constraint returns the constraint function evaluated at the solution.","category":"page"},{"location":"manual/solutions/#Dual-solutions","page":"Solutions","title":"Dual solutions","text":"","category":"section"},{"location":"manual/solutions/#Dual-solution-status","page":"Solutions","title":"Dual solution status","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Use dual_status to return an MOI.ResultStatusCode enum describing the status of the dual solution.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> dual_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Other common returns are NO_SOLUTION, and INFEASIBILITY_CERTIFICATE. The first means that the solver doesn't have a solution to return, and the second means that the dual solution is a certificate of primal infeasibility (a dual unbounded ray).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"You can also use has_duals, which returns true if there is a solution that can be queried, and false otherwise.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> has_duals(model)\ntrue","category":"page"},{"location":"manual/solutions/#Dual-solution-values","page":"Solutions","title":"Dual solution values","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If the solver has a dual solution to return, use dual to access it:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> dual(c1)\n1.7142857142857142","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Query the duals of variable bounds using LowerBoundRef, UpperBoundRef, and FixRef:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> dual(LowerBoundRef(x))\n0.0\n\njulia> dual.(UpperBoundRef.(y))\n1-dimensional DenseAxisArray{Float64,1,...} with index sets:\n    Dimension 1, [:a, :b]\nAnd data, a 2-element Vector{Float64}:\n -0.5714285714285694\n  0.0","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nJuMP's definition of duality is independent of the objective sense. That is, the sign of feasible duals associated with a constraint depends on the direction of the constraint and not whether the problem is maximization or minimization. This is a different convention from linear programming duality in some common textbooks. If you have a linear program, and you want the textbook definition, you probably want to use shadow_price and reduced_cost instead.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> shadow_price(c1)\n1.7142857142857142\n\njulia> reduced_cost(x)\n-0.0\n\njulia> reduced_cost.(y)\n1-dimensional DenseAxisArray{Float64,1,...} with index sets:\n    Dimension 1, [:a, :b]\nAnd data, a 2-element Vector{Float64}:\n  0.5714285714285694\n -0.0","category":"page"},{"location":"manual/solutions/#Recommended-workflow","page":"Solutions","title":"Recommended workflow","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"You should always check whether the solver found a solution before calling solution functions like value or objective_value.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"A simple approach for small scripts and notebooks is to use is_solved_and_feasible:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> function solve_and_print_solution(model)\n           optimize!(model)\n           if !is_solved_and_feasible(model; dual = true)\n               error(\n                   \"\"\"\n                   The model was not solved correctly:\n                   termination_status : $(termination_status(model))\n                   primal_status      : $(primal_status(model))\n                   dual_status        : $(dual_status(model))\n                   raw_status         : $(raw_status(model))\n                   \"\"\",\n               )\n           end\n           println(\"Solution is optimal\")\n           println(\"  objective value = \", objective_value(model))\n           println(\"  primal solution: x = \", value(x))\n           println(\"  dual solution: c1 = \", dual(c1))\n           return\n       end\nsolve_and_print_solution (generic function with 1 method)\n\njulia> solve_and_print_solution(model)\nSolution is optimal\n  objective value = -205.14285714285714\n  primal solution: x = 15.428571428571429\n  dual solution: c1 = 1.7142857142857142","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"For code like libraries that should be more robust to the range of possible termination and result statuses, do some variation of the following:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> function solve_and_print_solution(model)\n           status = termination_status(model)\n           if status in (OPTIMAL, LOCALLY_SOLVED)\n               println(\"Solution is optimal\")\n           elseif status in (ALMOST_OPTIMAL, ALMOST_LOCALLY_SOLVED)\n               println(\"Solution is optimal to a relaxed tolerance\")\n           elseif status == TIME_LIMIT\n               println(\n                   \"Solver stopped due to a time limit. If a solution is available, \" *\n                   \"it may be suboptimal.\"\n               )\n           elseif status in (\n               ITERATION_LIMIT, NODE_LIMIT, SOLUTION_LIMIT, MEMORY_LIMIT,\n               OBJECTIVE_LIMIT, NORM_LIMIT, OTHER_LIMIT,\n           )\n               println(\n                   \"Solver stopped due to a limit. If a solution is available, it \" *\n                   \"may be suboptimal.\"\n               )\n           elseif status in (INFEASIBLE, LOCALLY_INFEASIBLE)\n               println(\"The problem is primal infeasible\")\n           elseif status == DUAL_INFEASIBLE\n               println(\n                   \"The problem is dual infeasible. If a primal feasible solution \" *\n                   \"exists, the problem is unbounded. To check, set the objective \" *\n                   \"to `@objective(model, Min, 0)` and re-solve. If the problem is \" *\n                   \"feasible, the primal is unbounded. If the problem is \" *\n                   \"infeasible, both the primal and dual are infeasible.\",\n               )\n           elseif status == INFEASIBLE_OR_UNBOUNDED\n               println(\n                   \"The model is either infeasible or unbounded. Set the objective \" *\n                   \"to `@objective(model, Min, 0)` and re-solve to disambiguate. If \" *\n                   \"the problem was infeasible, it will still be infeasible. If the \" *\n                   \"problem was unbounded, it will now have a finite optimal solution.\",\n               )\n           else\n               println(\n                   \"The model was not solved correctly. The termination status is $status\",\n               )\n           end\n           if primal_status(model) in (FEASIBLE_POINT, NEARLY_FEASIBLE_POINT)\n               println(\"  objective value = \", objective_value(model))\n               println(\"  primal solution: x = \", value(x))\n           elseif primal_status(model) == INFEASIBILITY_CERTIFICATE\n               println(\"  primal certificate: x = \", value(x))\n           end\n           if dual_status(model) in (FEASIBLE_POINT, NEARLY_FEASIBLE_POINT)\n               println(\"  dual solution: c1 = \", dual(c1))\n           elseif dual_status(model) == INFEASIBILITY_CERTIFICATE\n               println(\"  dual certificate: c1 = \", dual(c1))\n           end\n           return\n       end\nsolve_and_print_solution (generic function with 1 method)\n\njulia> solve_and_print_solution(model)\nSolution is optimal\n  objective value = -205.14285714285714\n  primal solution: x = 15.428571428571429\n  dual solution: c1 = 1.7142857142857142","category":"page"},{"location":"manual/solutions/#OptimizeNotCalled-errors","page":"Solutions","title":"OptimizeNotCalled errors","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Due to differences in how solvers cache solutions internally, modifying a model after calling optimize! will reset the model into the OPTIMIZE_NOT_CALLED state. If you then attempt to query solution information, an OptimizeNotCalled error will be thrown.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If you are iteratively querying solution information and modifying a model, query all the results first, then modify the problem.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"For example, instead of:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> model = Model(HiGHS.Optimizer);\n\njulia> set_silent(model)\n\njulia> @variable(model, x >= 0);\n\njulia> optimize!(model)\n\njulia> termination_status(model)\nOPTIMAL::TerminationStatusCode = 1\n\njulia> set_upper_bound(x, 1)\n\njulia> x_val = value(x)\n┌ Warning: The model has been modified since the last call to `optimize!` (or `optimize!` has not been called yet). If you are iteratively querying solution information and modifying a model, query all the results first, then modify the model.\n└ @ JuMP ~/work/JuMP.jl/JuMP.jl/src/optimizer_interface.jl:712\nERROR: OptimizeNotCalled()\nStacktrace:\n[...]\n\njulia> termination_status(model)\nOPTIMIZE_NOT_CALLED::TerminationStatusCode = 0","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"do","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> model = Model(HiGHS.Optimizer);\n\njulia> set_silent(model)\n\njulia> @variable(model, x >= 0);\n\njulia> optimize!(model);\n\njulia> x_val = value(x)\n0.0\n\njulia> termination_status(model)\nOPTIMAL::TerminationStatusCode = 1\n\njulia> set_upper_bound(x, 1)\n\njulia> set_lower_bound(x, x_val)\n\njulia> termination_status(model)\nOPTIMIZE_NOT_CALLED::TerminationStatusCode = 0","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If you know that your particular solver supports querying solution information after modifications, you can use direct_model to bypass the OPTIMIZE_NOT_CALLED state:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> model = direct_model(HiGHS.Optimizer());\n\njulia> set_silent(model)\n\njulia> @variable(model, x >= 0);\n\njulia> optimize!(model)\n\njulia> termination_status(model)\nOPTIMAL::TerminationStatusCode = 1\n\njulia> set_upper_bound(x, 1)\n\njulia> x_val = value(x)\n0.0\n\njulia> set_lower_bound(x, x_val)\n\njulia> termination_status(model)\nOPTIMAL::TerminationStatusCode = 1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nBe careful doing this. If your particular solver does not support querying solution information after modification, it may silently return incorrect solutions or throw an error.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"# TODO: How to accurately measure the solve time.","category":"page"},{"location":"manual/solutions/#Accessing-attributes","page":"Solutions","title":"Accessing attributes","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"MathOptInterface defines many model attributes that can be queried. Some attributes can be directly accessed by getter functions. These include:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"solve_time\nrelative_gap\nsimplex_iterations\nbarrier_iterations\nnode_count","category":"page"},{"location":"manual/solutions/#Sensitivity-analysis-for-LP","page":"Solutions","title":"Sensitivity analysis for LP","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Given an LP problem and an optimal solution corresponding to a basis, we can question how much an objective coefficient or standard form right-hand side coefficient (c.f., normalized_rhs) can change without violating primal or dual feasibility of the basic solution.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Note that not all solvers compute the basis, and for sensitivity analysis, the solver interface must implement MOI.ConstraintBasisStatus.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"tip: Tip\nRead the Sensitivity analysis of a linear program for more information on sensitivity analysis.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To give a simple example, we could analyze the sensitivity of the optimal solution to the following (non-degenerate) LP problem:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> begin\n           model = Model(HiGHS.Optimizer)\n           set_silent(model)\n           @variable(model, x[1:2])\n           set_lower_bound(x[2], -0.5)\n           set_upper_bound(x[2], 0.5)\n           @constraint(model, c1, x[1] + x[2] <= 1)\n           @constraint(model, c2, x[1] - x[2] <= 1)\n           @objective(model, Max, x[1])\n           print(model)\n       end\nMax x[1]\nSubject to\n c1 : x[1] + x[2] ≤ 1\n c2 : x[1] - x[2] ≤ 1\n x[2] ≥ -0.5\n x[2] ≤ 0.5","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To analyze the sensitivity of the problem we could check the allowed perturbation ranges of, for example, the cost coefficients and the right-hand side coefficient of the constraint c1 as follows:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> optimize!(model)\n\njulia> value.(x)\n2-element Vector{Float64}:\n  1.0\n -0.0\n\njulia> report = lp_sensitivity_report(model);\n\njulia> x1_lo, x1_hi = report[x[1]]\n(-1.0, Inf)\n\njulia> println(\"The objective coefficient of x[1] could decrease by $(x1_lo) or increase by $(x1_hi).\")\nThe objective coefficient of x[1] could decrease by -1.0 or increase by Inf.\n\njulia> x2_lo, x2_hi = report[x[2]]\n(-1.0, 1.0)\n\njulia> println(\"The objective coefficient of x[2] could decrease by $(x2_lo) or increase by $(x2_hi).\")\nThe objective coefficient of x[2] could decrease by -1.0 or increase by 1.0.\n\njulia> c_lo, c_hi = report[c1]\n(-1.0, 1.0)\n\njulia> println(\"The RHS of c1 could decrease by $(c_lo) or increase by $(c_hi).\")\nThe RHS of c1 could decrease by -1.0 or increase by 1.0.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The range associated with a variable is the range of the allowed perturbation of the corresponding objective coefficient. Note that the current primal solution remains optimal within this range; however the corresponding dual solution might change since a cost coefficient is perturbed. Similarly, the range associated with a constraint is the range of the allowed perturbation of the corresponding right-hand side coefficient. In this range the current dual solution remains optimal, but the optimal primal solution might change.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If the problem is degenerate, there are multiple optimal bases and hence these ranges might not be as intuitive and seem too narrow, for example, a larger cost coefficient perturbation might not invalidate the optimality of the current primal solution. Moreover, if a problem is degenerate, due to finite precision, it can happen that, for example, a perturbation seems to invalidate a basis even though it doesn't (again providing too narrow ranges). To prevent this, increase the atol keyword argument to lp_sensitivity_report. Note that this might make the ranges too wide for numerically challenging instances. Thus, do not blindly trust these ranges, especially not for highly degenerate or numerically unstable instances.","category":"page"},{"location":"manual/solutions/#Conflicts","page":"Solutions","title":"Conflicts","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"When the model you input is infeasible, some solvers can help you find the cause of this infeasibility by offering a conflict, that is, a subset of the constraints that create this infeasibility. Depending on the solver, this can also be called an IIS (irreducible inconsistent subsystem).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If supported by the solver, use compute_conflict! to trigger the computation of a conflict. Once this process is finished, query the MOI.ConflictStatus attribute to check if a conflict was found.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If found, copy the IIS to a new model using copy_conflict, which you can then print or write to a file for easier debugging:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> using JuMP\n\njulia> import Gurobi\n\njulia> model = Model(Gurobi.Optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: Gurobi\n\njulia> set_silent(model)\n\njulia> @variable(model, x >= 0)\nx\n\njulia> @constraint(model, c1, x >= 2)\nc1 : x ≥ 2.0\n\njulia> @constraint(model, c2, x <= 1)\nc2 : x ≤ 1.0\n\njulia> optimize!(model)\n\njulia> compute_conflict!(model)\n\njulia> if get_attribute(model, MOI.ConflictStatus()) == MOI.CONFLICT_FOUND\n           iis_model, _ = copy_conflict(model)\n           print(iis_model)\n       end\nFeasibility\nSubject to\n c1 : x ≥ 2.0\n c2 : x ≤ 1.0","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If you need more control over the list of constraints that appear in the conflict, iterate over the list of constraints and query the MOI.ConstraintConflictStatus attribute:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> list_of_conflicting_constraints = ConstraintRef[]\nConstraintRef[]\n\njulia> for (F, S) in list_of_constraint_types(model)\n           for con in all_constraints(model, F, S)\n               if get_attribute(con, MOI.ConstraintConflictStatus()) == MOI.IN_CONFLICT\n                   push!(list_of_conflicting_constraints, con)\n               end\n           end\n       end\n\njulia> list_of_conflicting_constraints\n2-element Vector{ConstraintRef}:\n c1 : x ≥ 2.0\n c2 : x ≤ 1.0","category":"page"},{"location":"manual/solutions/#Multiple-solutions","page":"Solutions","title":"Multiple solutions","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Some solvers support returning multiple solutions. You can check how many solutions are available to query using result_count.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Functions for querying the solutions, for example, primal_status, dual_status, value, dual, and solution_summary all take an additional keyword argument result which can be used to specify which result to return.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nEven if termination_status is OPTIMAL, some of the returned solutions may be suboptimal. However, if the solver found at least one optimal solution, then result = 1 will always return an optimal solution. Use objective_value to assess the quality of the remaining solutions.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> using JuMP\n\njulia> import MultiObjectiveAlgorithms as MOA\n\njulia> import HiGHS\n\njulia> model = Model(() -> MOA.Optimizer(HiGHS.Optimizer));\n\njulia> set_attribute(model, MOA.Algorithm(), MOA.Dichotomy())\n\njulia> set_silent(model)\n\njulia> @variable(model, x1 >= 0)\nx1\n\njulia> @variable(model, 0 <= x2 <= 3)\nx2\n\njulia> @objective(model, Min, [3x1 + x2, -x1 - 2x2])\n2-element Vector{AffExpr}:\n 3 x1 + x2\n -x1 - 2 x2\n\njulia> @constraint(model, 3x1 - x2 <= 6)\n3 x1 - x2 ≤ 6\n\njulia> optimize!(model)\n\njulia> solution_summary(model; result = 1)\n* Solver : MOA[algorithm=MultiObjectiveAlgorithms.Dichotomy, optimizer=HiGHS]\n\n* Status\n  Result count       : 3\n  Termination status : OPTIMAL\n  Message from the solver:\n  \"Solve complete. Found 3 solution(s)\"\n\n* Candidate solution (result #1)\n  Primal status      : FEASIBLE_POINT\n  Dual status        : NO_SOLUTION\n  Objective value    : [0.00000e+00,0.00000e+00]\n  Objective bound    : [0.00000e+00,-9.00000e+00]\n  Relative gap       : Inf\n  Dual objective value : -9.00000e+00\n\n* Work counters\n  Solve time (sec)   : 1.82720e-03\n  Simplex iterations : 0\n  Barrier iterations : 0\n  Node count         : -1\n\njulia> for i in 1:result_count(model)\n           println(\"Solution $i\")\n           println(\"   x = \", value.([x1, x2]; result = i))\n           println(\" obj = \", objective_value(model; result = i))\n       end\nSolution 1\n   x = [0.0, 0.0]\n obj = [0.0, 0.0]\nSolution 2\n   x = [0.0, 3.0]\n obj = [3.0, -6.0]\nSolution 3\n   x = [3.0, 3.0]\n obj = [12.0, -9.0]","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"tip: Tip\nThe Multi-objective knapsack tutorial provides more examples of querying multiple solutions.","category":"page"},{"location":"manual/solutions/#Checking-feasibility-of-solutions","page":"Solutions","title":"Checking feasibility of solutions","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To check the feasibility of a primal solution, use primal_feasibility_report, which takes a model, a dictionary mapping each variable to a primal solution value (defaults to the last solved solution), and a tolerance atol (defaults to 0.0).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The function returns a dictionary which maps the infeasible constraint references to the distance between the primal value of the constraint and the nearest point in the corresponding set. A point is classed as infeasible if the distance is greater than the supplied tolerance atol.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"# Add a filter here because the output of the dictionary is not ordered, and\n# changes in printing order will cause the doctest to fail.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> model = Model(HiGHS.Optimizer);\n\njulia> set_silent(model)\n\njulia> @variable(model, x >= 1, Int);\n\njulia> @variable(model, y);\n\njulia> @constraint(model, c1, x + y <= 1.95);\n\njulia> point = Dict(x => 1.9, y => 0.06);\n\njulia> primal_feasibility_report(model, point)\nDict{Any, Float64} with 2 entries:\n  x integer         => 0.1\n  c1 : x + y ≤ 1.95 => 0.01\n\njulia> primal_feasibility_report(model, point; atol = 0.02)\nDict{Any, Float64} with 1 entry:\n  x integer => 0.1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If the point is feasible, an empty dictionary is returned:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> primal_feasibility_report(model, Dict(x => 1.0, y => 0.0))\nDict{Any, Float64}()","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To use the primal solution from a solve, omit the point argument:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> optimize!(model)\n\njulia> primal_feasibility_report(model; atol = 0.0)\nDict{Any, Float64}()","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Calling primal_feasibility_report without the point argument is useful when primal_status is FEASIBLE_POINT or NEARLY_FEASIBLE_POINT, and you want to assess the solution quality.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nTo apply primal_feasibility_report to infeasible models, you must also provide a candidate point (solvers generally do not provide one). To diagnose the source of infeasibility, see Conflicts.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Pass skip_mising = true to skip constraints which contain variables that are not in point:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> primal_feasibility_report(model, Dict(x => 2.1); skip_missing = true)\nDict{Any, Float64} with 1 entry:\n  x integer => 0.1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"You can also use the functional form, where the first argument is a function that maps variables to their primal values:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> optimize!(model)\n\njulia> primal_feasibility_report(v -> value(v), model)\nDict{Any, Float64}()","category":"page"},{"location":"extensions/DimensionalData/#DimensionalData.jl","page":"rafaqz/DimensionalData.jl","title":"DimensionalData.jl","text":"","category":"section"},{"location":"extensions/DimensionalData/","page":"rafaqz/DimensionalData.jl","title":"rafaqz/DimensionalData.jl","text":"DimensionalData.jl provides tools and abstractions for working with rectangular arrays that have named dimensions.","category":"page"},{"location":"extensions/DimensionalData/","page":"rafaqz/DimensionalData.jl","title":"rafaqz/DimensionalData.jl","text":"compat: Compat\nUsing the DimensionalData extension with JuMP requires Julia v1.9 or later.","category":"page"},{"location":"extensions/DimensionalData/","page":"rafaqz/DimensionalData.jl","title":"rafaqz/DimensionalData.jl","text":"The DimensionalData extension in JuMP lets you construct a DimensionalData.DimArray as an alternative to Containers.DenseAxisArray in the JuMP macros.","category":"page"},{"location":"extensions/DimensionalData/#License","page":"rafaqz/DimensionalData.jl","title":"License","text":"","category":"section"},{"location":"extensions/DimensionalData/","page":"rafaqz/DimensionalData.jl","title":"rafaqz/DimensionalData.jl","text":"DimensionalData.jl is licensed under the MIT license.","category":"page"},{"location":"extensions/DimensionalData/#Installation","page":"rafaqz/DimensionalData.jl","title":"Installation","text":"","category":"section"},{"location":"extensions/DimensionalData/","page":"rafaqz/DimensionalData.jl","title":"rafaqz/DimensionalData.jl","text":"Install DimensionalData using Pkg.add:","category":"page"},{"location":"extensions/DimensionalData/","page":"rafaqz/DimensionalData.jl","title":"rafaqz/DimensionalData.jl","text":"import Pkg\nPkg.add(\"DimensionalData\")","category":"page"},{"location":"extensions/DimensionalData/#Use-with-JuMP","page":"rafaqz/DimensionalData.jl","title":"Use with JuMP","text":"","category":"section"},{"location":"extensions/DimensionalData/","page":"rafaqz/DimensionalData.jl","title":"rafaqz/DimensionalData.jl","text":"Activate the extension by loading both JuMP and DimensionalData:","category":"page"},{"location":"extensions/DimensionalData/","page":"rafaqz/DimensionalData.jl","title":"rafaqz/DimensionalData.jl","text":"julia> using JuMP, DimensionalData","category":"page"},{"location":"extensions/DimensionalData/","page":"rafaqz/DimensionalData.jl","title":"rafaqz/DimensionalData.jl","text":"Then, pass container = DimensionalData.DimArray in the @variable, @constraint, or @expression macros:","category":"page"},{"location":"extensions/DimensionalData/","page":"rafaqz/DimensionalData.jl","title":"rafaqz/DimensionalData.jl","text":"julia> model = Model();\n\njulia> @variable(\n           model,\n           x[i = 2:4, j = [\"a\", \"b\"]] >= i,\n           container = DimensionalData.DimArray,\n       )\n╭─────────────────────────────╮\n│ 3×2 DimArray{VariableRef,2} │\n├─────────────────────────────┴─────────────────── dims ┐\n  ↓ i Sampled{Int64} 2:4 ForwardOrdered Regular Points,\n  → j Categorical{String} [\"a\", \"b\"] ForwardOrdered\n└───────────────────────────────────────────────────────┘\n ↓ →  \"a\"     \"b\"\n 2    x[2,a]  x[2,b]\n 3    x[3,a]  x[3,b]\n 4    x[4,a]  x[4,b]","category":"page"},{"location":"extensions/DimensionalData/","page":"rafaqz/DimensionalData.jl","title":"rafaqz/DimensionalData.jl","text":"Here x is a DimensionalData.Dim array object, so indexing uses the DimensionalData syntax:","category":"page"},{"location":"extensions/DimensionalData/","page":"rafaqz/DimensionalData.jl","title":"rafaqz/DimensionalData.jl","text":"julia> x[At(2), At(\"a\")]\nx[2,a]\n\njulia> x[2, 2]\nx[3,b]","category":"page"},{"location":"extensions/DimensionalData/","page":"rafaqz/DimensionalData.jl","title":"rafaqz/DimensionalData.jl","text":"You can use container = DimensionalData.DimArray in the @expression macro:","category":"page"},{"location":"extensions/DimensionalData/","page":"rafaqz/DimensionalData.jl","title":"rafaqz/DimensionalData.jl","text":"julia> @expression(\n           model,\n           expr[j = [\"a\", \"b\"]],\n           sum(x[At(i), At(j)] for i in 2:4),\n           container = DimensionalData.DimArray,\n       )\n╭───────────────────────────────╮\n│ 2-element DimArray{AffExpr,1} │\n├───────────────────────────────┴───────────── dims ┐\n  ↓ j Categorical{String} [\"a\", \"b\"] ForwardOrdered\n└───────────────────────────────────────────────────┘\n \"a\"  x[2,a] + x[3,a] + x[4,a]\n \"b\"  x[2,b] + x[3,b] + x[4,b]","category":"page"},{"location":"extensions/DimensionalData/","page":"rafaqz/DimensionalData.jl","title":"rafaqz/DimensionalData.jl","text":"and in @constraint:","category":"page"},{"location":"extensions/DimensionalData/","page":"rafaqz/DimensionalData.jl","title":"rafaqz/DimensionalData.jl","text":"julia> @constraint(\n           model,\n           [j = [\"a\", \"b\"]],\n           expr[At(j)] <= 1,\n           container = DimensionalData.DimArray,\n       )\n╭──────────────────────────────────────────────────────────────────────────────╮\n│ 2-element DimArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape},1} │\n├──────────────────────────────────────────────────────────────────────── dims ┤\n  ↓ j Categorical{String} [\"a\", \"b\"] ForwardOrdered\n└──────────────────────────────────────────────────────────────────────────────┘\n \"a\"  x[2,a] + x[3,a] + x[4,a] ≤ 1\n \"b\"  x[2,b] + x[3,b] + x[4,b] ≤ 1","category":"page"},{"location":"extensions/DimensionalData/#Documentation","page":"rafaqz/DimensionalData.jl","title":"Documentation","text":"","category":"section"},{"location":"extensions/DimensionalData/","page":"rafaqz/DimensionalData.jl","title":"rafaqz/DimensionalData.jl","text":"See the DimensionalData.jl documentation for more details on the syntax and features of DimensionalData.DimArray.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"EditURL = \"getting_started_with_JuMP.jl\"","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Getting-started-with-JuMP","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"This tutorial is aimed at providing a quick introduction to writing and solving optimization models with JuMP.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"If you're new to Julia, start by reading Getting started with Julia.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#What-is-JuMP?","page":"Getting started with JuMP","title":"What is JuMP?","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP (\"Julia for Mathematical Programming\") is an open-source modeling language that is embedded in Julia. It allows users to formulate various classes of optimization problems (linear, mixed-integer, quadratic, conic quadratic, semidefinite, and nonlinear) with easy-to-read code. These problems can then be solved using state-of-the-art open-source and commercial solvers.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP also makes advanced optimization techniques easily accessible from a high-level language.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#What-is-a-solver?","page":"Getting started with JuMP","title":"What is a solver?","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"A solver is a software package that incorporates algorithms for finding solutions to one or more classes of problem.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"For example, HiGHS is a solver for linear programming (LP) and mixed integer programming (MIP) problems. It incorporates algorithms such as the simplex method and the interior-point method.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"The Supported-solvers table lists the open-source and commercial solvers that JuMP currently supports.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#What-is-MathOptInterface?","page":"Getting started with JuMP","title":"What is MathOptInterface?","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Each solver has its own concepts and data structures for representing optimization models and obtaining results.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"MathOptInterface (MOI) is an abstraction layer that JuMP uses to convert from the problem written in JuMP to the solver-specific data structures for each solver.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"MOI can be used directly, or through a higher-level modeling interface like JuMP.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Because JuMP is built on top of MOI, you'll often see the MathOptInterface. prefix displayed when JuMP types are printed. However, you'll only need to understand and interact with MOI to accomplish advanced tasks such as creating solver-independent callbacks.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Installation","page":"Getting started with JuMP","title":"Installation","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP is a package for Julia. From Julia, JuMP is installed by using the built-in package manager.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"import Pkg\nPkg.add(\"JuMP\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"You also need to include a Julia package which provides an appropriate solver. One such solver is HiGHS.Optimizer, which is provided by the HiGHS.jl package.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"import Pkg\nPkg.add(\"HiGHS\")","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"See Installation Guide for a list of other solvers you can use.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#An-example","page":"Getting started with JuMP","title":"An example","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Let's solve the following linear programming problem using JuMP and HiGHS. We will first look at the complete code to solve the problem and then go through it step by step.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Here's the problem:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"beginaligned\n min  12x + 20y \n textst  6x + 8y geq 100 \n  7x + 12y geq 120 \n  x geq 0 \n  y in 0 3 \nendaligned","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"And here's the code to solve this problem:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"using JuMP\nusing HiGHS\nmodel = Model(HiGHS.Optimizer)\n@variable(model, x >= 0)\n@variable(model, 0 <= y <= 3)\n@objective(model, Min, 12x + 20y)\n@constraint(model, c1, 6x + 8y >= 100)\n@constraint(model, c2, 7x + 12y >= 120)\nprint(model)\noptimize!(model)\ntermination_status(model)\nprimal_status(model)\ndual_status(model)\nobjective_value(model)\nvalue(x)\nvalue(y)\nshadow_price(c1)\nshadow_price(c2)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Step-by-step","page":"Getting started with JuMP","title":"Step-by-step","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Once JuMP is installed, to use JuMP in your programs write:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"using JuMP","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We also need to include a Julia package which provides an appropriate solver. We want to use HiGHS.Optimizer here which is provided by the HiGHS.jl package:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"using HiGHS","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP builds problems incrementally in a Model object. Create a model by passing an optimizer to the Model function:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = Model(HiGHS.Optimizer)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Variables are modeled using @variable:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, x >= 0)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"info: Info\nThe macro creates a new Julia object, x, in the current scope. We could have made this more explicit by writing:x = @variable(model, x >= 0)but the macro does this automatically for us to save writing x twice.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Variables can have lower and upper bounds:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, 0 <= y <= 30)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"The objective is set using @objective:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@objective(model, Min, 12x + 20y)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Constraints are modeled using @constraint. Here, c1 and c2 are the names of our constraint:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@constraint(model, c1, 6x + 8y >= 100)\n@constraint(model, c2, 7x + 12y >= 120)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Call print to display the model:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"print(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"To solve the optimization problem, call the optimize! function:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"optimize!(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"info: Info\nThe ! after optimize is part of the name. It's nothing special. Julia has a convention that functions which mutate their arguments should end in !. A common example is push!.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Now let's see what information we can query about the solution, starting with is_solved_and_feasible:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"is_solved_and_feasible(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We can get more information about the solution by querying the three types of statuses.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"termination_status tells us why the solver stopped:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"termination_status(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"In this case, the solver found an optimal solution.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Check primal_status to see if the solver found a primal feasible point:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"primal_status(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"and dual_status to see if the solver found a dual feasible point:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"dual_status(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Now we know that our solver found an optimal solution, and that it has a primal and a dual solution to query.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Query the objective value using objective_value:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"objective_value(model)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"the primal solution using value:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"value(x)\nvalue(y)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"and the dual solution using shadow_price:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"shadow_price(c1)\nshadow_price(c2)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"warning: Warning\nYou should always check whether the solver found a solution before calling solution functions like value or objective_value. A common workflow is:optimize!(model)\nif !is_solved_and_feasible(model)\n    error(\"Solver did not find an optimal solution\")\nend","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"That's it for our simple model. In the rest of this tutorial, we expand on some of the basic JuMP operations.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Model-basics","page":"Getting started with JuMP","title":"Model basics","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Create a model by passing an optimizer:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = Model(HiGHS.Optimizer)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Alternatively, call set_optimizer at any point before calling optimize!:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = Model()\nset_optimizer(model, HiGHS.Optimizer)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"For some solvers, you can also use direct_model, which offers a more efficient connection to the underlying solver:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = direct_model(HiGHS.Optimizer())","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"warning: Warning\nSome solvers do not support direct_model!","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Solver-Options","page":"Getting started with JuMP","title":"Solver Options","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Pass options to solvers with optimizer_with_attributes:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model =\n    Model(optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => false))","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"note: Note\nThese options are solver-specific. To find out the various options available, see the GitHub README of the individual solver packages. The link to each solver's GitHub page is in the Supported solvers table.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"You can also pass options with set_attribute:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = Model(HiGHS.Optimizer)\nset_attribute(model, \"output_flag\", false)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Solution-basics","page":"Getting started with JuMP","title":"Solution basics","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We saw above how to use termination_status and primal_status to understand the solution returned by the solver.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"However, only query solution attributes like value and objective_value if there is an available solution. Here's a recommended way to check:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"function solve_infeasible()\n    model = Model(HiGHS.Optimizer)\n    @variable(model, 0 <= x <= 1)\n    @variable(model, 0 <= y <= 1)\n    @constraint(model, x + y >= 3)\n    @objective(model, Max, x + 2y)\n    optimize!(model)\n    if !is_solved_and_feasible(model)\n        @warn(\"The model was not solved correctly.\")\n        return\n    end\n    return value(x), value(y)\nend\n\nsolve_infeasible()","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Variable-basics","page":"Getting started with JuMP","title":"Variable basics","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Let's create a new empty model to explain some of the variable syntax:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = Model()","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Variable-bounds","page":"Getting started with JuMP","title":"Variable bounds","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"All of the variables we have created till now have had a bound. We can also create a free variable.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, free_x)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"While creating a variable, instead of using the <= and >= syntax, we can also use the lower_bound and upper_bound keyword arguments.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, keyword_x, lower_bound = 1, upper_bound = 2)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We can query whether a variable has a bound using the has_lower_bound and has_upper_bound functions. The values of the bound can be obtained using the lower_bound and upper_bound functions.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"has_upper_bound(keyword_x)\nupper_bound(keyword_x)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Note querying the value of a bound that does not exist will result in an error.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"try                         #hide\n    lower_bound(free_x)\ncatch err                   #hide\n    showerror(stderr, err)  #hide\nend                         #hide","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#tutorial_variable_container","page":"Getting started with JuMP","title":"Containers","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We have already seen how to add a single variable to a model using the @variable macro. Now let's look at ways to add multiple variables to a model.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP provides data structures for adding collections of variables to a model. These data structures are referred to as containers and are of three types: Arrays, DenseAxisArrays, and SparseAxisArrays.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Arrays","page":"Getting started with JuMP","title":"Arrays","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP arrays are created when you have integer indices that start at 1:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, a[1:2, 1:2])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Index elements in a as follows:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"a[1, 1]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"a[2, :]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Create an n-dimensional variable x in R^n with bounds l le x le u (l u in R^n) as follows:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"n = 10\nl = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nu = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19];\n\n@variable(model, l[i] <= x[i = 1:n] <= u[i])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We can also create variable bounds that depend upon the indices:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, y[i = 1:2, j = 1:2] >= 2i + j)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#DenseAxisArrays","page":"Getting started with JuMP","title":"DenseAxisArrays","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"DenseAxisArrays are used when the indices are not one-based integer ranges. The syntax is similar except with an arbitrary vector as an index as opposed to a one-based range:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, z[i = 2:3, j = 1:2:3] >= 0)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Indices do not have to be integers. They can be any Julia type:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, w[1:5, [\"red\", \"blue\"]] <= 1)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Index elements in a DenseAxisArray as follows:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"z[2, 1]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"w[2:3, [\"red\", \"blue\"]]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"See Forcing the container type for more details.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#SparseAxisArrays","page":"Getting started with JuMP","title":"SparseAxisArrays","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"SparseAxisArrays are created when the indices do not form a Cartesian product. For example, this applies when indices have a dependence upon previous indices (called triangular indexing):","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, u[i = 1:2, j = i:3])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We can also conditionally create variables by adding a comparison check that depends upon the named indices and is separated from the indices by a semi-colon ;:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, v[i = 1:9; mod(i, 3) == 0])","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Index elements in a DenseAxisArray as follows:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"u[1, 2]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"v[[3, 6]]","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Integrality","page":"Getting started with JuMP","title":"Integrality","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP can create binary and integer variables. Binary variables are constrained to the set  0 1, and integer variables are constrained to the set mathbbZ.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Integer-variables","page":"Getting started with JuMP","title":"Integer variables","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Create an integer variable by passing  Int:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, integer_x, Int)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"or setting the integer keyword to true:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, integer_z, integer = true)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Binary-variables","page":"Getting started with JuMP","title":"Binary variables","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Create a binary variable by passing Bin:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, binary_x, Bin)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"or setting the binary keyword to true:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, binary_z, binary = true)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Constraint-basics","page":"Getting started with JuMP","title":"Constraint basics","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We'll need a new model to explain some of the constraint  basics:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\n@variable(model, z[1:10]);\nnothing #hide","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#tutorial_constraint_container","page":"Getting started with JuMP","title":"Containers","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Just as we had containers for variables, JuMP also provides Arrays, DenseAxisArrays, and SparseAxisArrays for storing collections of constraints. Examples for each container type are given below.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Arrays-2","page":"Getting started with JuMP","title":"Arrays","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Create an Array of constraints:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@constraint(model, [i = 1:3], i * x <= i + 1)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#DenseAxisArrays-2","page":"Getting started with JuMP","title":"DenseAxisArrays","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Create an DenseAxisArray of constraints:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@constraint(model, [i = 1:2, j = 2:3], i * x <= j + 1)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#SparseAxisArrays-2","page":"Getting started with JuMP","title":"SparseAxisArrays","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Create an SparseAxisArray of constraints:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@constraint(model, [i = 1:2, j = 1:2; i != j], i * x <= j + 1)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Constraints-in-a-loop","page":"Getting started with JuMP","title":"Constraints in a loop","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We can add constraints using regular Julia loops:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"for i in 1:3\n    @constraint(model, 6x + 4y >= 5i)\nend","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"or use for each loops inside the @constraint macro:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@constraint(model, [i in 1:3], 6x + 4y >= 5i)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We can also create constraints such as sum _i = 1^10 z_i leq 1:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@constraint(model, sum(z[i] for i in 1:10) <= 1)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Objective-functions","page":"Getting started with JuMP","title":"Objective functions","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Set an objective function with @objective:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = Model(HiGHS.Optimizer)\n@variable(model, x >= 0)\n@variable(model, y >= 0)\n@objective(model, Min, 2x + y)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Create a maximization objective using Max:","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@objective(model, Max, 2x + y)","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"tip: Tip\nCalling @objective multiple times will over-write the previous objective. This can be useful when you want to solve the same problem with different objectives.","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/#Vectorized-syntax","page":"Getting started with JuMP","title":"Vectorized syntax","text":"","category":"section"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We can also add constraints and an objective to JuMP using vectorized linear algebra. We'll illustrate this by solving an LP in standard form that is,","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"beginaligned\n min  c^T x \n textst  A x = b \n  x ge 0\nendaligned","category":"page"},{"location":"tutorials/getting_started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"vector_model = Model(HiGHS.Optimizer)\nA = [1 1 9 5; 3 5 0 8; 2 0 6 13]\nb = [7, 3, 5]\nc = [1, 3, 5, 2]\n@variable(vector_model, x[1:4] >= 0)\n@constraint(vector_model, A * x .== b)\n@objective(vector_model, Min, c' * x)\noptimize!(vector_model)\n@assert is_solved_and_feasible(vector_model)\nobjective_value(vector_model)","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\n    import HiGHS\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/complex/#Complex-number-support","page":"Complex number support","title":"Complex number support","text":"","category":"section"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"This page explains the complex-valued variables and constraints that JuMP supports. For a worked-example using these features, read the Quantum state discrimination tutorial.","category":"page"},{"location":"manual/complex/#Complex-valued-variables","page":"Complex number support","title":"Complex-valued variables","text":"","category":"section"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"Create a complex-valued variable using ComplexPlane:","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"julia> model = Model();\n\njulia> @variable(model, x in ComplexPlane())\nreal(x) + imag(x) im","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"Note that x is not a VariableRef; instead, it is an affine expression with Complex{Float64}-valued coefficients:","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"julia> typeof(x)\nGenericAffExpr{ComplexF64, VariableRef}","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"Behind the scenes, JuMP has created two real-valued variables, with names \"real(x)\" and \"imag(x)\":","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"julia> all_variables(model)\n2-element Vector{VariableRef}:\n real(x)\n imag(x)\n\njulia> name.(all_variables(model))\n2-element Vector{String}:\n \"real(x)\"\n \"imag(x)\"","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"Use the real and imag functions on x to return a real-valued affine expression representing each variable:","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"julia> typeof(real(x))\nAffExpr (alias for GenericAffExpr{Float64, GenericVariableRef{Float64}})\n\njulia> typeof(imag(x))\nAffExpr (alias for GenericAffExpr{Float64, GenericVariableRef{Float64}})","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"To create an anonymous variable, use the set keyword argument:","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"julia> model = Model();\n\njulia> x = @variable(model, set = ComplexPlane())\n_[1] + _[2] im","category":"page"},{"location":"manual/complex/#Complex-valued-variable-and-start-values-bounds","page":"Complex number support","title":"Complex-valued variable and start values bounds","text":"","category":"section"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"Because complex-valued variables lack a total ordering, the definition of a variable bound for a complex-valued variable is ambiguous. If you pass a real- or complex-valued argument to keywords such as lower_bound, upper_bound, and start_value, JuMP will apply the real and imaginary parts to the associated real-valued variables.","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"julia> model = Model();\n\njulia> @variable(\n           model,\n           x in ComplexPlane(),\n           lower_bound = 1.0,\n           upper_bound = 2.0 + 3.0im,\n           start = 4im,\n       )\nreal(x) + imag(x) im\n\njulia> vars = all_variables(model)\n2-element Vector{VariableRef}:\n real(x)\n imag(x)\n\njulia> lower_bound.(vars)\n2-element Vector{Float64}:\n 1.0\n 0.0\n\njulia> upper_bound.(vars)\n2-element Vector{Float64}:\n 2.0\n 3.0\n\njulia> start_value.(vars)\n2-element Vector{Float64}:\n 0.0\n 4.0","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"You can modify the bounds and start values by passing imag(x) or real(x) to the appropriate function:","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"julia> set_lower_bound(imag(x), 2)\n\njulia> lower_bound(imag(x))\n2.0\n\njulia> delete_upper_bound(real(x))\n\njulia> has_upper_bound(real(x))\nfalse\n\njulia> set_start_value(imag(x), 3)\n\njulia> start_value(imag(x))\n3.0","category":"page"},{"location":"manual/complex/#Complex-valued-equality-constraints","page":"Complex number support","title":"Complex-valued equality constraints","text":"","category":"section"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"JuMP reformulates complex-valued equality constraints into two real-valued constraints: one representing the real part, and one representing the imaginary part. Thus, complex-valued equality constraints can be solved any solver that supports the real-valued constraint type.","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"For example:","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"julia> model = Model(HiGHS.Optimizer);\n\njulia> set_silent(model)\n\njulia> @variable(model, x[1:2]);\n\njulia> @constraint(model, (1 + 2im) * x[1] + 3 * x[2] == 4 + 5im)\n(1 + 2im) x[1] + 3 x[2] = (4 + 5im)\n\njulia> optimize!(model)\n\njulia> value.(x)\n2-element Vector{Float64}:\n 2.5\n 0.5","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"is equivalent to","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"julia> model = Model(HiGHS.Optimizer);\n\njulia> set_silent(model)\n\njulia> @variable(model, x[1:2]);\n\njulia> @constraint(model, 1 * x[1] + 3 * x[2] == 4)  # real component\nx[1] + 3 x[2] = 4\n\njulia> @constraint(model, 2 * x[1] == 5)  # imag component\n2 x[1] = 5\n\njulia> optimize!(model)\n\njulia> value.(x)\n2-element Vector{Float64}:\n 2.5\n 0.5","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"This also applies if the variables are complex-valued:","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"julia> model = Model(HiGHS.Optimizer);\n\njulia> set_silent(model)\n\njulia> @variable(model, x in ComplexPlane());\n\njulia> @constraint(model, (1 + 2im) * x + 3 * x == 4 + 5im)\n(4 + 2im) real(x) + (-2 + 4im) imag(x) = (4 + 5im)\n\njulia> optimize!(model)\n\njulia> value(x)\n1.3 + 0.6000000000000001im","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"which is equivalent to","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"julia> model = Model(HiGHS.Optimizer);\n\njulia> set_silent(model)\n\njulia> @variable(model, x_real);\n\njulia> @variable(model, x_imag);\n\njulia> @constraint(model, x_real - 2 * x_imag + 3 * x_real == 4)\n4 x_real - 2 x_imag = 4\n\njulia> @constraint(model, x_imag + 2 * x_real + 3 * x_imag == 5)\n2 x_real + 4 x_imag = 5\n\njulia> optimize!(model)\n\njulia> value(x_real) + value(x_imag) * im\n1.3 + 0.6000000000000001im","category":"page"},{"location":"manual/complex/#Hermitian-PSD-Cones","page":"Complex number support","title":"Hermitian PSD Cones","text":"","category":"section"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"JuMP supports creating matrices where are Hermitian.","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"julia> model = Model();\n\njulia> @variable(model, H[1:3, 1:3] in HermitianPSDCone())\n3×3 LinearAlgebra.Hermitian{GenericAffExpr{ComplexF64, VariableRef}, Matrix{GenericAffExpr{ComplexF64, VariableRef}}}:\n real(H[1,1])                    …  real(H[1,3]) + imag(H[1,3]) im\n real(H[1,2]) - imag(H[1,2]) im     real(H[2,3]) + imag(H[2,3]) im\n real(H[1,3]) - imag(H[1,3]) im     real(H[3,3])","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"Behind the scenes, JuMP has created nine real-valued decision variables:","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"julia> all_variables(model)\n9-element Vector{VariableRef}:\n real(H[1,1])\n real(H[1,2])\n real(H[2,2])\n real(H[1,3])\n real(H[2,3])\n real(H[3,3])\n imag(H[1,2])\n imag(H[1,3])\n imag(H[2,3])","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"and a Vector{VariableRef}-in-MOI.HermitianPositiveSemidefiniteConeTriangle constraint:","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"julia> num_constraints(model, Vector{VariableRef}, MOI.HermitianPositiveSemidefiniteConeTriangle)\n1","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"The MOI.HermitianPositiveSemidefiniteConeTriangle set can be efficiently bridged to MOI.PositiveSemidefiniteConeTriangle, so it can be solved by any solver that supports PSD constraints.","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"Each element of H is an affine expression with Complex{Float64}-valued coefficients:","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"julia> typeof(H[1, 1])\nGenericAffExpr{ComplexF64, VariableRef}\n\njulia> typeof(H[2, 1])\nGenericAffExpr{ComplexF64, VariableRef}","category":"page"},{"location":"manual/complex/#Start-values","page":"Complex number support","title":"Start values","text":"","category":"section"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"When setting the start value, you must be careful to set only the upper triangle of real variables, and the upper triangle excluding the diagonal of imaginary variables:","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"julia> import LinearAlgebra\n\njulia> function set_hermitian_start(\n           H::LinearAlgebra.Hermitian,\n           start::LinearAlgebra.Hermitian,\n       )\n           for j in 1:size(H, 2), i in 1:j\n               set_start_value(real(H[i, j]), real(start[i, j]))\n               if i < j\n                   set_start_value(imag(H[i, j]), imag(start[i, j]))\n               end\n           end\n           return\n       end\nset_hermitian_start (generic function with 1 method)\n\njulia> H0 = LinearAlgebra.Hermitian(\n           [1 (2+3im) (5+6im); (2-3im) 4 (7+8im); (5-6im) (7-8im) 9],\n       )\n3×3 LinearAlgebra.Hermitian{Complex{Int64}, Matrix{Complex{Int64}}}:\n 1+0im  2+3im  5+6im\n 2-3im  4+0im  7+8im\n 5-6im  7-8im  9+0im\n\njulia> set_hermitian_start(H, H0)\n\njulia> start_value.(all_variables(model))\n9-element Vector{Float64}:\n 1.0\n 2.0\n 4.0\n 5.0\n 7.0\n 9.0\n 3.0\n 6.0\n 8.0","category":"page"},{"location":"manual/complex/#Hermitian-PSD-constraints","page":"Complex number support","title":"Hermitian PSD constraints","text":"","category":"section"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"The HermitianPSDCone can also be used in the @constraint macro:","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"julia> model = Model();\n\njulia> @variable(model, x[1:2])\n2-element Vector{VariableRef}:\n x[1]\n x[2]\n\njulia> import LinearAlgebra\n\njulia> H = LinearAlgebra.Hermitian([x[1] 1im; -1im -x[2]])\n2×2 LinearAlgebra.Hermitian{GenericAffExpr{ComplexF64, VariableRef}, Matrix{GenericAffExpr{ComplexF64, VariableRef}}}:\n x[1]  im\n -im   -x[2]\n\njulia> @constraint(model, H in HermitianPSDCone())\n[x[1]  im;\n -im   -x[2]] ∈ HermitianPSDCone()","category":"page"},{"location":"manual/complex/","page":"Complex number support","title":"Complex number support","text":"note: Note\nThe matrix H in H in HermitianPSDCone() must be a LinearAlgebra.Hermitian matrix type. A build_constraint error will be thrown if the matrix is a different matrix type.","category":"page"},{"location":"tutorials/nonlinear/user_defined_hessians/","page":"User-defined Hessians","title":"User-defined Hessians","text":"EditURL = \"user_defined_hessians.jl\"","category":"page"},{"location":"tutorials/nonlinear/user_defined_hessians/#User-defined-Hessians","page":"User-defined Hessians","title":"User-defined Hessians","text":"","category":"section"},{"location":"tutorials/nonlinear/user_defined_hessians/","page":"User-defined Hessians","title":"User-defined Hessians","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/nonlinear/user_defined_hessians/","page":"User-defined Hessians","title":"User-defined Hessians","text":"In this tutorial, we explain how to write a user-defined operator (see User-defined operators) with a Hessian matrix explicitly provided by the user.","category":"page"},{"location":"tutorials/nonlinear/user_defined_hessians/","page":"User-defined Hessians","title":"User-defined Hessians","text":"For a more advanced example, see Nested optimization problems.","category":"page"},{"location":"tutorials/nonlinear/user_defined_hessians/","page":"User-defined Hessians","title":"User-defined Hessians","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/nonlinear/user_defined_hessians/","page":"User-defined Hessians","title":"User-defined Hessians","text":"using JuMP\nimport Ipopt","category":"page"},{"location":"tutorials/nonlinear/user_defined_hessians/#Rosenbrock-example","page":"User-defined Hessians","title":"Rosenbrock example","text":"","category":"section"},{"location":"tutorials/nonlinear/user_defined_hessians/","page":"User-defined Hessians","title":"User-defined Hessians","text":"As a simple example, we consider the Rosenbrock function:","category":"page"},{"location":"tutorials/nonlinear/user_defined_hessians/","page":"User-defined Hessians","title":"User-defined Hessians","text":"rosenbrock(x...) = (1 - x[1])^2 + 100 * (x[2] - x[1]^2)^2","category":"page"},{"location":"tutorials/nonlinear/user_defined_hessians/","page":"User-defined Hessians","title":"User-defined Hessians","text":"which has the gradient vector:","category":"page"},{"location":"tutorials/nonlinear/user_defined_hessians/","page":"User-defined Hessians","title":"User-defined Hessians","text":"function ∇rosenbrock(g::AbstractVector, x...)\n    g[1] = 400 * x[1]^3 - 400 * x[1] * x[2] + 2 * x[1] - 2\n    g[2] = 200 * (x[2] - x[1]^2)\n    return\nend","category":"page"},{"location":"tutorials/nonlinear/user_defined_hessians/","page":"User-defined Hessians","title":"User-defined Hessians","text":"and the Hessian matrix:","category":"page"},{"location":"tutorials/nonlinear/user_defined_hessians/","page":"User-defined Hessians","title":"User-defined Hessians","text":"function ∇²rosenbrock(H::AbstractMatrix, x...)\n    H[1, 1] = 1200 * x[1]^2 - 400 * x[2] + 2\n    # H[1, 2] = -400 * x[1] <-- not needed because Hessian is symmetric\n    H[2, 1] = -400 * x[1]\n    H[2, 2] = 200.0\n    return\nend","category":"page"},{"location":"tutorials/nonlinear/user_defined_hessians/","page":"User-defined Hessians","title":"User-defined Hessians","text":"You may assume the Hessian matrix H is initialized with zeros, and because it is symmetric you need only to fill in the non-zero of the lower-triangular terms.","category":"page"},{"location":"tutorials/nonlinear/user_defined_hessians/","page":"User-defined Hessians","title":"User-defined Hessians","text":"The matrix type passed in as H depends on the automatic differentiation system, so make sure the first argument to the Hessian function supports an AbstractMatrix (it may be something other than Matrix{Float64}). However, you may assume only that H supports size(H) and setindex!.","category":"page"},{"location":"tutorials/nonlinear/user_defined_hessians/","page":"User-defined Hessians","title":"User-defined Hessians","text":"Now that we have the function, its gradient, and its Hessian, we can construct a JuMP model, add the operator, and use it in a macro:","category":"page"},{"location":"tutorials/nonlinear/user_defined_hessians/","page":"User-defined Hessians","title":"User-defined Hessians","text":"model = Model(Ipopt.Optimizer)\n@variable(model, x[1:2])\n@operator(model, op_rosenbrock, 2, rosenbrock, ∇rosenbrock, ∇²rosenbrock)\n@objective(model, Min, op_rosenbrock(x[1], x[2]))\noptimize!(model)\n@assert is_solved_and_feasible(model)\nsolution_summary(model; verbose = true)","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"EditURL = \"operator_ad.jl\"","category":"page"},{"location":"tutorials/nonlinear/operator_ad/#Automatic-differentiation-of-user-defined-operators","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"","category":"section"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"This tutorial was generated using Literate.jl. Download the source as a .jl file.","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"The purpose of this tutorial is to demonstrate how to apply automatic differentiation to User-defined operators.","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"tip: Tip\nThis tutorial is for advanced users. As an alternative, consider using Function tracing instead of creating an operator, and if an operator is necessary, consider using the default of @operator(model, op_f, N, f) instead of passing explicit Gradients and Hessians.","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"using JuMP\nimport Enzyme\nimport ForwardDiff\nimport Ipopt\nimport Test","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"As a simple example, we consider the Rosenbrock function:","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"f(x::T...) where {T} = (1 - x[1])^2 + 100 * (x[2] - x[1]^2)^2","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"Here's the value at a random point:","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"x = rand(2)","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"f(x...)","category":"page"},{"location":"tutorials/nonlinear/operator_ad/#Analytic-derivative","page":"Automatic differentiation of user-defined operators","title":"Analytic derivative","text":"","category":"section"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"If expressions are simple enough, you can provide analytic functions for the gradient and Hessian.","category":"page"},{"location":"tutorials/nonlinear/operator_ad/#Gradient","page":"Automatic differentiation of user-defined operators","title":"Gradient","text":"","category":"section"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"The Rosenbrock function has the gradient vector:","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"function analytic_∇f(g::AbstractVector, x...)\n    g[1] = 400 * x[1]^3 - 400 * x[1] * x[2] + 2 * x[1] - 2\n    g[2] = 200 * (x[2] - x[1]^2)\n    return\nend","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"Let's evaluate it at the same vector x:","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"analytic_g = zeros(2)\nanalytic_∇f(analytic_g, x...)\nanalytic_g","category":"page"},{"location":"tutorials/nonlinear/operator_ad/#Hessian","page":"Automatic differentiation of user-defined operators","title":"Hessian","text":"","category":"section"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"The Hessian matrix is:","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"function analytic_∇²f(H::AbstractMatrix, x...)\n    H[1, 1] = 1200 * x[1]^2 - 400 * x[2] + 2\n    # H[1, 2] = -400 * x[1] <-- not needed because Hessian is symmetric\n    H[2, 1] = -400 * x[1]\n    H[2, 2] = 200.0\n    return\nend","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"Note that because the Hessian is symmetric, JuMP requires that we fill in only the lower triangle.","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"analytic_H = zeros(2, 2)\nanalytic_∇²f(analytic_H, x...)\nanalytic_H","category":"page"},{"location":"tutorials/nonlinear/operator_ad/#JuMP-example","page":"Automatic differentiation of user-defined operators","title":"JuMP example","text":"","category":"section"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"Putting our analytic functions together, we get:","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"function analytic_rosenbrock()\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, x[1:2])\n    @operator(model, op_rosenbrock, 2, f, analytic_∇f, analytic_∇²f)\n    @objective(model, Min, op_rosenbrock(x[1], x[2]))\n    optimize!(model)\n    Test.@test is_solved_and_feasible(model)\n    return value.(x)\nend\n\nanalytic_rosenbrock()","category":"page"},{"location":"tutorials/nonlinear/operator_ad/#ForwardDiff","page":"Automatic differentiation of user-defined operators","title":"ForwardDiff","text":"","category":"section"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"Instead of analytic functions, you can use ForwardDiff.jl to compute derivatives.","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"info: Info\nIf you do not specify a gradient or Hessian, JuMP will use ForwardDiff.jl to compute derivatives by default. We provide this section as a worked example of what is going on under the hood.","category":"page"},{"location":"tutorials/nonlinear/operator_ad/#Pros-and-cons","page":"Automatic differentiation of user-defined operators","title":"Pros and cons","text":"","category":"section"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"The main benefit of ForwardDiff is that it is simple, robust, and works with a broad range of Julia syntax.","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"The main downside is that f must be a function that accepts arguments of x::Real.... See Common mistakes when writing a user-defined operator for more details.","category":"page"},{"location":"tutorials/nonlinear/operator_ad/#Gradient-2","page":"Automatic differentiation of user-defined operators","title":"Gradient","text":"","category":"section"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"The gradient can be computed using ForwardDiff.gradient!. Note that ForwardDiff expects a single Vector{T} argument, but we receive x as a tuple, so we need y -> f(y...) and collect(x) to get things in the right format.","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"function fdiff_∇f(g::AbstractVector{T}, x::Vararg{T,N}) where {T,N}\n    ForwardDiff.gradient!(g, y -> f(y...), collect(x))\n    return\nend","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"Let's check that we find the analytic solution:","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"fdiff_g = zeros(2)\nfdiff_∇f(fdiff_g, x...)\nTest.@test ≈(analytic_g, fdiff_g)","category":"page"},{"location":"tutorials/nonlinear/operator_ad/#Hessian-2","page":"Automatic differentiation of user-defined operators","title":"Hessian","text":"","category":"section"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"The Hessian is a bit more complicated, but code to implement it is:","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"function fdiff_∇²f(H::AbstractMatrix{T}, x::Vararg{T,N}) where {T,N}\n    h = ForwardDiff.hessian(y -> f(y...), collect(x))\n    for i in 1:N, j in 1:i\n        H[i, j] = h[i, j]\n    end\n    return\nend","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"Let's check that we find the analytic solution:","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"fdiff_H = zeros(2, 2)\nfdiff_∇²f(fdiff_H, x...)\nTest.@test ≈(analytic_H, fdiff_H)","category":"page"},{"location":"tutorials/nonlinear/operator_ad/#JuMP-example-2","page":"Automatic differentiation of user-defined operators","title":"JuMP example","text":"","category":"section"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"The code for computing the gradient and Hessian using ForwardDiff can be re-used for many operators. Thus, it is helpful to encapsulate it into the function:","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"\"\"\"\n    fdiff_derivatives(f::Function) -> Tuple{Function,Function}\n\nReturn a tuple of functions that evaluate the gradient and Hessian of `f` using\nForwardDiff.jl.\n\"\"\"\nfunction fdiff_derivatives(f::Function)\n    function ∇f(g::AbstractVector{T}, x::Vararg{T,N}) where {T,N}\n        ForwardDiff.gradient!(g, y -> f(y...), collect(x))\n        return\n    end\n    function ∇²f(H::AbstractMatrix{T}, x::Vararg{T,N}) where {T,N}\n        h = ForwardDiff.hessian(y -> f(y...), collect(x))\n        for i in 1:N, j in 1:i\n            H[i, j] = h[i, j]\n        end\n        return\n    end\n    return ∇f, ∇²f\nend","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"Here's an example using fdiff_derivatives:","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"function fdiff_rosenbrock()\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, x[1:2])\n    @operator(model, op_rosenbrock, 2, f, fdiff_derivatives(f)...)\n    @objective(model, Min, op_rosenbrock(x[1], x[2]))\n    optimize!(model)\n    Test.@test is_solved_and_feasible(model)\n    return value.(x)\nend\n\nfdiff_rosenbrock()","category":"page"},{"location":"tutorials/nonlinear/operator_ad/#Enzyme","page":"Automatic differentiation of user-defined operators","title":"Enzyme","text":"","category":"section"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"Another library for automatic differentiation in Julia is Enzyme.jl.","category":"page"},{"location":"tutorials/nonlinear/operator_ad/#Pros-and-cons-2","page":"Automatic differentiation of user-defined operators","title":"Pros and cons","text":"","category":"section"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"The main benefit of Enzyme is that it can produce fast derivatives for functions with many input arguments.","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"The main downsides are that it may throw unusual errors if your code uses an unsupported feature of Julia and that it may have large compile times.","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"warning: Warning\nThe JuMP developers cannot help you debug error messages related to Enzyme. If the operator works, it works. If not, we suggest you try a different automatic differentiation library. See juliadiff.org for details.","category":"page"},{"location":"tutorials/nonlinear/operator_ad/#Gradient-3","page":"Automatic differentiation of user-defined operators","title":"Gradient","text":"","category":"section"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"The gradient can be computed using Enzyme.autodiff with the Enzyme.Reverse mode. We need to wrap x in Enzyme.Active to indicate that we want to compute the derivatives with respect to these arguments.","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"function enzyme_∇f(g::AbstractVector{T}, x::Vararg{T,N}) where {T,N}\n    g .= Enzyme.autodiff(Enzyme.Reverse, f, Enzyme.Active.(x)...)[1]\n    return\nend","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"Let's check that we find the analytic solution:","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"enzyme_g = zeros(2)\nenzyme_∇f(enzyme_g, x...)\nTest.@test ≈(analytic_g, enzyme_g)","category":"page"},{"location":"tutorials/nonlinear/operator_ad/#Hessian-3","page":"Automatic differentiation of user-defined operators","title":"Hessian","text":"","category":"section"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"We can compute the Hessian in Enzyme using forward-over-reverse automatic differentiation.","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"The code to implement the Hessian in Enzyme is complicated, so we will not explain it in detail; see the Enzyme documentation.","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"function enzyme_∇²f(H::AbstractMatrix{T}, x::Vararg{T,N}) where {T,N}\n    # direction(i) returns a tuple with a `1` in the `i`'th entry and `0`\n    # otherwise\n    direction(i) = ntuple(j -> Enzyme.Active(T(i == j)), N)\n    # As the inner function, compute the gradient using Reverse mode\n    ∇f_deferred(x...) = Enzyme.autodiff_deferred(Enzyme.Reverse, f, x...)[1]\n    # For the outer autodiff, use Forward mode.\n    hess = Enzyme.autodiff(\n        Enzyme.Forward,\n        ∇f_deferred,\n        # Compute multiple evaluations of Forward mode, each time using `x` but\n        # initializing with a different direction.\n        Enzyme.BatchDuplicated.(Enzyme.Active.(x), ntuple(direction, N))...,\n    )[1]\n    # Unpack Enzyme's `hess` data structure into the matrix `H` expected by\n    # JuMP.\n    for j in 1:N, i in 1:j\n        H[j, i] = hess[j][i]\n    end\n    return\nend","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"Let's check that we find the analytic solution:","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"enzyme_H = zeros(2, 2)\nenzyme_∇²f(enzyme_H, x...)\nTest.@test ≈(analytic_H, enzyme_H)","category":"page"},{"location":"tutorials/nonlinear/operator_ad/#JuMP-example-3","page":"Automatic differentiation of user-defined operators","title":"JuMP example","text":"","category":"section"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"The code for computing the gradient and Hessian using Enzyme can be re-used for many operators. Thus, it is helpful to encapsulate it into the function:","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"\"\"\"\n    enzyme_derivatives(f::Function) -> Tuple{Function,Function}\n\nReturn a tuple of functions that evaluate the gradient and Hessian of `f` using\nEnzyme.jl.\n\"\"\"\nfunction enzyme_derivatives(f::Function)\n    function ∇f(g::AbstractVector{T}, x::Vararg{T,N}) where {T,N}\n        g .= Enzyme.autodiff(Enzyme.Reverse, f, Enzyme.Active.(x)...)[1]\n        return\n    end\n    function ∇²f(H::AbstractMatrix{T}, x::Vararg{T,N}) where {T,N}\n        direction(i) = ntuple(j -> Enzyme.Active(T(i == j)), N)\n        ∇f_deferred(x...) = Enzyme.autodiff_deferred(Enzyme.Reverse, f, x...)[1]\n        hess = Enzyme.autodiff(\n            Enzyme.Forward,\n            ∇f_deferred,\n            Enzyme.BatchDuplicated.(Enzyme.Active.(x), ntuple(direction, N))...,\n        )[1]\n        for j in 1:N, i in 1:j\n            H[j, i] = hess[j][i]\n        end\n        return\n    end\n    return ∇f, ∇²f\nend","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"Here's an example using enzyme_derivatives:","category":"page"},{"location":"tutorials/nonlinear/operator_ad/","page":"Automatic differentiation of user-defined operators","title":"Automatic differentiation of user-defined operators","text":"function enzyme_rosenbrock()\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, x[1:2])\n    @operator(model, op_rosenbrock, 2, f, enzyme_derivatives(f)...)\n    @objective(model, Min, op_rosenbrock(x[1], x[2]))\n    optimize!(model)\n    Test.@test is_solved_and_feasible(model)\n    return value.(x)\nend\n\nenzyme_rosenbrock()","category":"page"}]
}
