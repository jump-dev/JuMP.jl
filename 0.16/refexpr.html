<!DOCTYPE html><HTML class="no-js" lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Expressions and Constraints — JuMP -- Julia for Mathematical Optimization 0.16 documentation</title><link href="_static/css/theme.css" rel="stylesheet" type="text/css"/><link href="genindex.html" rel="index" title="Index"/><link href="search.html" rel="search" title="Search"/><link href="index.html" rel="top" title="JuMP -- Julia for Mathematical Optimization 0.16 documentation"/><link href="probmod.html" rel="next" title="Problem Modification"/><link href="refvariable.html" rel="prev" title="Variables"/><script src="_static/js/modernizr.min.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body class="wy-body-for-nav" role="document"><div class="wy-grid-for-nav"><nav class="wy-nav-side" data-toggle="wy-nav-shift"><div class="wy-side-scroll"><div class="wy-side-nav-search"><a class="icon icon-home" href="index.html"> JuMP -- Julia for Mathematical Optimization
          

          
          </a><div class="version">
                0.16
              </div><div role="search"><form action="search.html" class="wy-form" id="rtd-search-form" method="get"><input name="q" placeholder="Search docs" type="text"/><input name="check_keywords" type="hidden" value="yes"/><input name="area" type="hidden" value="default"/></form></div></div><div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation"><ul class="current"><li class="toctree-l1"><a class="reference internal" href="installation.html">Installation Guide</a></li><li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quick Start Guide</a></li><li class="toctree-l1"><a class="reference internal" href="refmodel.html">Models</a></li><li class="toctree-l1"><a class="reference internal" href="refvariable.html">Variables</a></li><li class="toctree-l1 current"><a class="current reference internal" href="#">Expressions and Constraints</a><ul><li class="toctree-l2"><a class="reference internal" href="#constructor">Constructor</a></li><li class="toctree-l2"><a class="reference internal" href="#methods">Methods</a></li><li class="toctree-l2"><a class="reference internal" href="#constraint-references">Constraint References</a></li><li class="toctree-l2"><a class="reference internal" href="#conic-constraint-duals">Conic constraint duals</a></li><li class="toctree-l2"><a class="reference internal" href="#vectorized-operations">Vectorized operations</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="probmod.html">Problem Modification</a></li><li class="toctree-l1"><a class="reference internal" href="callbacks.html">Solver Callbacks</a></li><li class="toctree-l1"><a class="reference internal" href="nlp.html">Nonlinear Modeling</a></li></ul></div></div></nav><section class="wy-nav-content-wrap" data-toggle="wy-nav-shift"><nav aria-label="top navigation" class="wy-nav-top" role="navigation"><i class="fa fa-bars" data-toggle="wy-nav-top"></i><a href="index.html">JuMP -- Julia for Mathematical Optimization</a></nav><div class="wy-nav-content"><div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation"><ul class="wy-breadcrumbs"><li><a href="index.html">Docs</a> »</li><li>Expressions and Constraints</li><li class="wy-breadcrumbs-aside"><a href="_sources/refexpr.txt" rel="nofollow"> View page source</a></li></ul><hr/></div><div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main"><div itemprop="articleBody"><div class="admonition warning" id="officialwarn"><p class="first admonition-title">Warning</p><p class="last">This documentation tracks the development branch of JuMP. For the documentation of the latest JuMP release, see <a href="http://www.juliaopt.org/JuMP.jl/0.15/">here</a>.</p></div><script type="text/javascript">
if(!(location.hostname.match('readthedocs') || location.hostname.match('rtfd'))){
    document.getElementById("officialwarn").style.display = 'none';
}
</script><div class="section" id="expressions-and-constraints"><span id="ref-expr"></span><h1>Expressions and Constraints<a class="headerlink" href="#expressions-and-constraints" title="Permalink to this headline">¶</a></h1><div class="section" id="constructor"><h2>Constructor<a class="headerlink" href="#constructor" title="Permalink to this headline">¶</a></h2><p><code class="docutils literal"><span class="pre">AffExpr</span></code> is an affine expression type defined by JuMP. It has three fields:
a vector of coefficients, a vector of variables, and a constant. Apart from
a default constructor that takes no arguments, it also has a full constructor that
can be useful if you want to manually build an affine expression:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">aff</span><span class="o">=</span><span class="n">AffExpr</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">],</span><span class="p">[</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">4.0</span><span class="p">],</span><span class="mf">2.0</span><span class="p">)</span><span class="c"># 3x + 4z + 2</span></pre></div></div><p>Note that the coefficients must be floating point numbers. The matching
constraint for <code class="docutils literal"><span class="pre">AffExpr</span></code> is <code class="docutils literal"><span class="pre">LinearConstraint</span></code> which is defined by an
<code class="docutils literal"><span class="pre">AffExpr</span></code> and a lower and upper bound. If a solver interface does not
support range constraints, this will automatically translated into two
constraints at solve time. Constructing constraints manually is not an
expected behavior and won’t add the constraint to a model automatically.
See below for the correct methods.</p><p>There is also <code class="docutils literal"><span class="pre">QuadExpr</span></code> for quadratic expressions type that also provides
a default constructor that takes no arguments and a full constructor. There
are four fields: two vectors of variables, a vector of coefficients, and the
affine part of the expression. This is best explained by example:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">aff</span><span class="o">=</span><span class="n">AffExpr</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">],</span><span class="p">[</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">4.0</span><span class="p">],</span><span class="mf">2.0</span><span class="p">)</span><span class="c"># 3x + 4z + 2</span><span class="n">quad</span><span class="o">=</span><span class="n">QuadExpr</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">],[</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">],[</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">4.0</span><span class="p">],</span><span class="n">aff</span><span class="p">)</span><span class="c"># 3x^2 + 4yz + 3x + 4z + 2</span></pre></div></div><p>The corresponding constraint is <code class="docutils literal"><span class="pre">QuadConstraint</span></code>, which is expected to
be a convex quadratic constraint.</p></div><div class="section" id="methods"><h2>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h2><ul><li><p class="first"><code class="docutils literal"><span class="pre">@constraint(m::Model,</span><span class="pre">con)</span></code> - add linear or quadratic constraints.</p></li><li><p class="first"><code class="docutils literal"><span class="pre">@constraint(m::Model,</span><span class="pre">ref,</span><span class="pre">con)</span></code> - add groups of linear or quadratic constraints.
See Constraint Reference section for details.</p></li><li><p class="first"><code class="docutils literal"><span class="pre">JuMP.addconstraint(m::Model,</span><span class="pre">con)</span></code> - general way to add linear and quadratic
constraints.</p></li><li><p class="first"><code class="docutils literal"><span class="pre">@constraints</span></code> - add groups of constraints at once, in the same fashion as @constraint. The model must be the first argument, and multiple constraints can be added on multiple lines wrapped in a <code class="docutils literal"><span class="pre">begin</span><span class="pre">...</span><span class="pre">end</span></code> block. For example:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">constraints</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="k">begin</span><span class="n">x</span><span class="o">&gt;=</span><span class="mi">1</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">&lt;=</span><span class="mi">2</span><span class="n">sum_to_one</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">y</span><span class="o">==</span><span class="mi">1</span><span class="k">end</span><span class="p">)</span></pre></div></div></li><li><p class="first"><code class="docutils literal"><span class="pre">@expression(m::Model,</span><span class="pre">ref,</span><span class="pre">expr)</span></code> - efficiently builds a linear, quadratic, or second-order cone expression but does not add to model immediately. Instead, returns the expression which can then be inserted in other constraints. For example:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">expression</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">shared</span><span class="p">,</span><span class="n">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="k">for</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">))</span><span class="p">@</span><span class="n">constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">shared</span><span class="o">+</span><span class="n">y</span><span class="o">&gt;=</span><span class="mi">5</span><span class="p">)</span><span class="p">@</span><span class="n">constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">shared</span><span class="o">+</span><span class="n">z</span><span class="o">&lt;=</span><span class="mi">10</span><span class="p">)</span></pre></div></div></li></ul><p>The <code class="docutils literal"><span class="pre">ref</span></code> accepts index sets in the same way as <code class="docutils literal"><span class="pre">@variable</span></code>, and those indices can be used in the construction of the expressions:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">expression</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">expr</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="n">i</span><span class="o">*</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="k">for</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">))</span></pre></div></div><p>Anonymous syntax is also supported:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">expr</span><span class="o">=</span><span class="p">@</span><span class="n">expression</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="n">i</span><span class="o">*</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="k">for</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">))</span></pre></div></div><ul class="simple"><li><code class="docutils literal"><span class="pre">@SDconstraint(m::Model,</span><span class="pre">expr)</span></code> - adds a semidefinite constraint to the model <code class="docutils literal"><span class="pre">m</span></code>. The expression <code class="docutils literal"><span class="pre">expr</span></code> must be a square, two-dimensional array.</li><li><code class="docutils literal"><span class="pre">addSOS1(m::Model,</span><span class="pre">coll::Vector{AffExpr})</span></code> - adds special ordered set constraint
of type 1 (SOS1). Specify the set as a vector of weighted variables, e.g. <code class="docutils literal"><span class="pre">coll</span><span class="pre">=</span><span class="pre">[3x,</span><span class="pre">y,</span><span class="pre">2z]</span></code>.
Note that solvers expect the weights to be unique. See
<a class="reference external" href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for more details. If there is no inherent
weighting in your model, an SOS constraint is probably unnecessary.</li><li><code class="docutils literal"><span class="pre">addSOS2(m::Model,</span><span class="pre">coll::Vector{AffExpr})</span></code> - adds special ordered set constraint
of type 2 (SOS2). Specify the set as a vector of weighted variables, e.g. <code class="docutils literal"><span class="pre">coll</span><span class="pre">=</span><span class="pre">[3x,</span><span class="pre">y,</span><span class="pre">2z]</span></code>.
Note that solvers expect the weights to be unique.
See <a class="reference external" href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for more details.</li><li><code class="docutils literal"><span class="pre">@LinearConstraint(expr)</span></code> - Constructs a <code class="docutils literal"><span class="pre">LinearConstraint</span></code> instance efficiently by parsing the <code class="docutils literal"><span class="pre">expr</span></code>. The same as <code class="docutils literal"><span class="pre">@constraint</span></code>, except it does not attach the constraint to any model.</li><li><code class="docutils literal"><span class="pre">@LinearConstraints(expr)</span></code> - Constructs a vector of <code class="docutils literal"><span class="pre">LinearConstraint</span></code> objects. Similar to <code class="docutils literal"><span class="pre">@LinearConstraint</span></code>, except it accepts multiple constraints as input as long as they are separated by newlines.</li><li><code class="docutils literal"><span class="pre">@QuadConstraint(expr)</span></code> - Constructs a <code class="docutils literal"><span class="pre">QuadConstraint</span></code> instance efficiently by parsing the <code class="docutils literal"><span class="pre">expr</span></code>. The same as <code class="docutils literal"><span class="pre">@constraint</span></code>, except it does not attach the constraint to any model.</li><li><code class="docutils literal"><span class="pre">@QuadConstraints(expr)</span></code> - Constructs a vector of <code class="docutils literal"><span class="pre">QuadConstraint</span></code> objects. Similar to <code class="docutils literal"><span class="pre">@QuadConstraint</span></code>, except it accepts multiple constraints as input as long as they are separated by newlines.</li><li><code class="docutils literal"><span class="pre">push!(aff::AffExpr,</span><span class="pre">new_coeff::Float64,</span><span class="pre">new_var::Variable)</span></code> - efficient
way to grow an affine expression by one term. For example, to add <code class="docutils literal"><span class="pre">5x</span></code> to
an existing expression <code class="docutils literal"><span class="pre">aff</span></code>, use <code class="docutils literal"><span class="pre">push!(aff,</span><span class="pre">5.0,</span><span class="pre">x)</span></code>. This is
significantly more efficient than <code class="docutils literal"><span class="pre">aff</span><span class="pre">+=</span><span class="pre">5.0*x</span></code>.</li><li><code class="docutils literal"><span class="pre">append!(aff::AffExpr,</span><span class="pre">other::AffExpr)</span></code> - efficiently append the terms of
an affine expression to an existing affine expression. For example, given
<code class="docutils literal"><span class="pre">aff</span><span class="pre">=</span><span class="pre">5.0*x</span></code> and <code class="docutils literal"><span class="pre">other</span><span class="pre">=</span><span class="pre">7.0*y</span><span class="pre">+</span><span class="pre">3.0*z</span></code>, we can grow <code class="docutils literal"><span class="pre">aff</span></code> using
<code class="docutils literal"><span class="pre">append!(aff,</span><span class="pre">other)</span></code> which results in <code class="docutils literal"><span class="pre">aff</span></code> equaling <code class="docutils literal"><span class="pre">5x</span><span class="pre">+</span><span class="pre">7y</span><span class="pre">+</span><span class="pre">3z</span></code>.
This is significantly more efficient than using <code class="docutils literal"><span class="pre">aff</span><span class="pre">+=</span><span class="pre">other</span></code>.</li><li><code class="docutils literal"><span class="pre">sum(affs::Array{AffExpr})</span></code> - efficiently sum an array of affine expressions.</li><li><code class="docutils literal"><span class="pre">getvalue(expr)</span></code> - evaluate an <code class="docutils literal"><span class="pre">AffExpr</span></code> or <code class="docutils literal"><span class="pre">QuadExpr</span></code>, given the current solution values.</li><li><code class="docutils literal"><span class="pre">linearterms{C,V}(aff::GenericAffExpr{C,V})</span></code> - provides an iterator over the <code class="docutils literal"><span class="pre">(a_i::C,x_i::V)</span></code> terms in affine expression <span class="math">\(\sum_i a_i x_i + b\)</span>.</li></ul></div><div class="section" id="constraint-references"><h2>Constraint References<a class="headerlink" href="#constraint-references" title="Permalink to this headline">¶</a></h2><p>In order to manipulate constraints after creation, it is necessary to maintain
a reference. The simplest way to do this is to use the special three-argument
named constraint syntax for <code class="docutils literal"><span class="pre">@constraint</span></code>, which additionally allows you
to create groups of constraints indexed by sets analogously to <code class="docutils literal"><span class="pre">@variable</span></code>.
For example:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">6</span><span class="p">])</span><span class="p">@</span><span class="n">constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">xyconstr</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span></pre></div></div><p>adds 9 constraints to the model <code class="docutils literal"><span class="pre">m</span></code> of the expected form. The variable <code class="docutils literal"><span class="pre">xyconstr</span></code>
is a collection of <code class="docutils literal"><span class="pre">ConstraintRef{Model,LinearConstraint}</span></code> instances indexed
by the ranges <code class="docutils literal"><span class="pre">1:3</span></code> and <code class="docutils literal"><span class="pre">6:-2:2</span></code> (the ordered tuple <code class="docutils literal"><span class="pre">(6,4,2)</span></code>), so, for example
<code class="docutils literal"><span class="pre">xyconstr[2,4]</span></code> is a reference to the constraint <code class="docutils literal"><span class="pre">x[2]</span><span class="pre">-</span><span class="pre">y[4]</span><span class="pre">==</span><span class="pre">1</span></code>. Indices can
have dependencies on preceding indices, e.g. triangular indexing is allowed:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">triconstr</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="n">i</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">6</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span></pre></div></div><p>A condition can be added following the indices; a semicolon is used to separate index sets from the condition:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">constr</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">&gt;=</span><span class="mi">3</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span></pre></div></div><p>Note that only one condition can be added, although expressions can be built up by using the usual <code class="docutils literal"><span class="pre">&amp;&amp;</span></code> and <code class="docutils literal"><span class="pre">||</span></code> logical operators.</p><p>Anonymous syntax is supported:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">constr</span><span class="o">=</span><span class="p">@</span><span class="n">constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">&gt;=</span><span class="mi">3</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span></pre></div></div><p>To obtain the dual of a constraint, call <code class="docutils literal"><span class="pre">getdual</span></code> on the constraint reference:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">println</span><span class="p">(</span><span class="n">getdual</span><span class="p">(</span><span class="n">xyconstr</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">]))</span></pre></div></div><p>When an LP model is infeasible, <code class="docutils literal"><span class="pre">getdual</span></code> will return the corresponding component of the
infeasibility ray (Farkas proof), if available from the solver.</p><p>Dual information is also accessible for second-order cone problems as described below. Duals are unavailable for MIPs.</p><p>One may retrieve the corresponding internal <code class="docutils literal"><span class="pre">LinearConstraint</span></code> object from a
<code class="docutils literal"><span class="pre">ConstraintRef{Model,LinearConstraint}</span></code> object <code class="docutils literal"><span class="pre">constr</span></code> by calling <code class="docutils literal"><span class="pre">LinearConstraint(constr)</span></code>.
This functionality is not yet implemented for other classes of constraints.</p><p>For users who prefer to generate constraints in an explicit loop, we also
provide the <code class="docutils literal"><span class="pre">@constraintref</span></code> convenience macro, e.g.:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">constraintref</span><span class="n">constraintName</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span></pre></div></div><p>You can then iterate over constraints and store
references in this structure, e.g.:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span><span class="p">@</span><span class="n">constraintref</span><span class="n">myCons</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span><span class="k">for</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="n">myCons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">@</span><span class="n">constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">i</span><span class="p">)</span><span class="k">end</span></pre></div></div></div><div class="section" id="conic-constraint-duals"><h2>Conic constraint duals<a class="headerlink" href="#conic-constraint-duals" title="Permalink to this headline">¶</a></h2><p>JuMP supports accessing the dual solutions to second-order cone problems. Dual multipliers on variable bounds, linear constraints,
and second-order cone constraints are accessible through <code class="docutils literal"><span class="pre">getdual()</span></code> given the corresponding variable or constraint reference object.
For second-order cone constraints, <code class="docutils literal"><span class="pre">getdual(c::ConstraintRef{Model,SOCConstraint})</span></code> returns a vector of dual variables in the dimension of the corresponding cone.
Duals are defined such that they are consistent in sign with linear programming duals in the case that the second-order cone constraints
are inactive.</p><p>For example:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">=</span><span class="n">Model</span><span class="p">()</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">)</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">t</span><span class="p">)</span><span class="p">@</span><span class="n">objective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">Min</span><span class="p">,</span><span class="n">t</span><span class="p">)</span><span class="p">@</span><span class="n">constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">soc</span><span class="p">,</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="k">for</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">t</span><span class="p">)</span><span class="n">status</span><span class="o">=</span><span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="p">@</span><span class="n">show</span><span class="n">getvalue</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="c"># [1.000000000323643,1.0000000003235763]</span><span class="p">@</span><span class="n">show</span><span class="n">getvalue</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="c"># 1.4142135583106126</span><span class="p">@</span><span class="n">show</span><span class="n">getdual</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="c"># [0.7071067807797846,0.7071067802906756]</span><span class="p">@</span><span class="n">show</span><span class="n">getdual</span><span class="p">(</span><span class="n">soc</span><span class="p">)</span><span class="c"># [-1.0000000004665652,0.707106779497123,0.707106779008014]</span></pre></div></div><p>Note that the <em>negative</em> of the dual vector <code class="docutils literal"><span class="pre">getdual(soc)</span></code> belongs to the second-order cone.
See the <a class="reference external" href="http://mathprogbasejl.readthedocs.org/en/latest/conic.html">MathProgBase documentation</a> for more
on the definition of the dual problem. The dual solutions returned by JuMP agree with the definitions from
MathProgBase up to a possible change in sign.</p></div><div class="section" id="vectorized-operations"><h2>Vectorized operations<a class="headerlink" href="#vectorized-operations" title="Permalink to this headline">¶</a></h2><p>JuMP supports vectorized expressions and constraints for linear and quadratic models. Although this syntax may
be familiar for users coming from MATLAB-based modeling languages, we caution that this syntax may be slower than
the scalar versions using loops—especially for large operations. Nevertheless, the syntax often proves useful,
for example in constraints involving small, dense matrix-vector products.</p><p>Linear algebraic operators are available to give meaning to expressions like <code class="docutils literal"><span class="pre">A*x</span></code> where <code class="docutils literal"><span class="pre">A</span></code> is a matrix
of numbers and <code class="docutils literal"><span class="pre">x</span></code> is a vector of <code class="docutils literal"><span class="pre">Variable</span></code> objects. You may also use objects of type <code class="docutils literal"><span class="pre">Array{Variable}</span></code> in these kinds of
expressions; for example, any object you construct with <code class="docutils literal"><span class="pre">@variable</span></code> where each of the index sets are of the form
<code class="docutils literal"><span class="pre">1:n</span></code>. For example:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span><span class="n">expr</span><span class="o">=</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">x</span></pre></div></div><p>is allowed, while:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span><span class="n">expr</span><span class="o">=</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">x</span></pre></div></div><p>is not. Addition and subtraction are also defined in similar ways, following the usual Julia rules for linear
algebra over arrays.</p><p>Vectorized constraints can be added to the model, using the elementwise comparison operators <code class="docutils literal"><span class="pre">.==</span></code>, <code class="docutils literal"><span class="pre">.&gt;=</span></code>,
and <code class="docutils literal"><span class="pre">.&lt;=</span></code>. For instance, you can write constraints of the form:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span><span class="n">A</span><span class="o">=</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="n">b</span><span class="o">=</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">@</span><span class="n">constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">A</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">b</span><span class="o">.&lt;=</span><span class="mi">1</span><span class="p">)</span></pre></div></div><p>Note that scalar literals (such as 1 or 0) are allowed in expressions.</p><p>Concatenation is also possible for these arrays of variables or expressions. For instance, the following
will create a matrix of <code class="docutils literal"><span class="pre">QuadExpr</span></code> that you can use elsewhere in your model:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span><span class="n">A</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="n">x</span><span class="o">'</span><span class="n">x</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">'</span><span class="p">]</span></pre></div></div><p>Finally, note that this feature is not currently supported directly in nonlinear expressions; for example, a
matrix–vector product will not work inside a call to the <code class="docutils literal"><span class="pre">@NLconstraint</span></code> macro.</p></div></div></div></div><footer><div aria-label="footer navigation" class="rst-footer-buttons" role="navigation"><a accesskey="n" class="btn btn-neutral float-right" href="probmod.html" title="Problem Modification">Next <span class="fa fa-arrow-circle-right"></span></a><a accesskey="p" class="btn btn-neutral" href="refvariable.html" title="Variables"><span class="fa fa-arrow-circle-left"></span> Previous</a></div><hr/><div role="contentinfo"><p>
        © Copyright 2017, Miles Lubin, Iain Dunning, and Joey Huchette.

    </p></div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer></div></div></section></div><script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.16',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script><script src="_static/jquery.js" type="text/javascript"></script><script src="_static/underscore.js" type="text/javascript"></script><script src="_static/doctools.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script src="_static/js/theme.js" type="text/javascript"></script><script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script><script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview');
</script><script async="" src="https://www.google-analytics.com/analytics.js"></script></body></HTML>