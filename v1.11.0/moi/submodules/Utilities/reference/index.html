<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · JuMP</title><meta name="title" content="API Reference · JuMP"/><meta property="og:title" content="API Reference · JuMP"/><meta property="twitter:title" content="API Reference · JuMP"/><meta name="description" content="Documentation for JuMP."/><meta property="og:description" content="Documentation for JuMP."/><meta property="twitter:description" content="Documentation for JuMP."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-44252521-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-44252521-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.048/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script><link href="../../../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img class="docs-light-only" src="../../../../assets/logo.svg" alt="JuMP logo"/><img class="docs-dark-only" src="../../../../assets/logo-dark.svg" alt="JuMP logo"/></a><form class="docs-search" action="../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs (Ctrl + /)"/></form><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../">Introduction</a></li><li><a class="tocitem" href="../../../../should_i_use/">Should you use JuMP?</a></li><li><a class="tocitem" href="../../../../installation/">Installation Guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/getting_started/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/getting_started_with_julia/">Getting started with Julia</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/getting_started_with_JuMP/">Getting started with JuMP</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/getting_started_with_sets_and_indexing/">Getting started with sets and indexing</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/getting_started_with_data_and_plotting/">Getting started with data and plotting</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/debugging/">Debugging</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/design_patterns_for_larger_models/">Design patterns for larger models</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/performance_tips/">Performance tips</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Linear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/linear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../tutorials/linear/diet/">The diet problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../../../tutorials/linear/facility_location/">The facility location problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../../../../tutorials/linear/finance/">Financial modeling problems</a></li><li><a class="tocitem" href="../../../../tutorials/linear/geographic_clustering/">Geographical clustering</a></li><li><a class="tocitem" href="../../../../tutorials/linear/multi_objective_knapsack/">Multi-objective knapsack</a></li><li><a class="tocitem" href="../../../../tutorials/linear/multi_objective_examples/">Simple multi-objective examples</a></li><li><a class="tocitem" href="../../../../tutorials/linear/knapsack/">The knapsack problem example</a></li><li><a class="tocitem" href="../../../../tutorials/linear/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/n-queens/">N-Queens</a></li><li><a class="tocitem" href="../../../../tutorials/linear/lp_sensitivity/">Sensitivity analysis of a linear program</a></li><li><a class="tocitem" href="../../../../tutorials/linear/network_flows/">Network flow problems</a></li><li><a class="tocitem" href="../../../../tutorials/linear/sudoku/">Sudoku</a></li><li><a class="tocitem" href="../../../../tutorials/linear/transp/">The transportation problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../../tutorials/linear/constraint_programming/">Constraint programming</a></li><li><a class="tocitem" href="../../../../tutorials/linear/mip_duality/">Computing the duals of a mixed-integer program</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Nonlinear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/nonlinear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/simple_examples/">Simple examples</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/portfolio/">Portfolio optimization</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/rocket_control/">Rocket Control</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/space_shuttle_reentry_trajectory/">Optimal control for a Space Shuttle reentry trajectory</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/user_defined_hessians/">User-defined Hessians</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/nested_problems/">Nested optimization problems</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/querying_hessians/">Computing Hessians</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Conic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/conic/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../tutorials/conic/start_values/">Primal and dual warm-starts</a></li><li><a class="tocitem" href="../../../../tutorials/conic/tips_and_tricks/">Tips and Tricks</a></li><li><a class="tocitem" href="../../../../tutorials/conic/simple_examples/">Simple semidefinite programming examples</a></li><li><a class="tocitem" href="../../../../tutorials/conic/logistic_regression/">Logistic regression</a></li><li><a class="tocitem" href="../../../../tutorials/conic/experiment_design/">Experiment design</a></li><li><a class="tocitem" href="../../../../tutorials/conic/min_ellipse/">Minimal ellipses</a></li><li><a class="tocitem" href="../../../../tutorials/conic/ellipse_approx/">Ellipsoid approximation</a></li><li><a class="tocitem" href="../../../../tutorials/conic/quantum_discrimination/">Quantum state discrimination</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/algorithms/benders_decomposition/">Benders decomposition</a></li><li><a class="tocitem" href="../../../../tutorials/algorithms/cutting_stock_column_generation/">Column generation</a></li><li><a class="tocitem" href="../../../../tutorials/algorithms/tsp_lazy_constraints/">Traveling Salesperson Problem</a></li><li><a class="tocitem" href="../../../../tutorials/algorithms/parallelism/">Parallelism</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/applications/power_systems/">Power Systems</a></li><li><a class="tocitem" href="../../../../tutorials/applications/web_app/">Serving web apps</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../manual/models/">Models</a></li><li><a class="tocitem" href="../../../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../../manual/expressions/">Expressions</a></li><li><a class="tocitem" href="../../../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../../../manual/containers/">Containers</a></li><li><a class="tocitem" href="../../../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../../manual/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../../../manual/callbacks/">Solver-independent Callbacks</a></li><li><a class="tocitem" href="../../../../manual/complex/">Complex number support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../reference/models/">Models</a></li><li><a class="tocitem" href="../../../../reference/variables/">Variables</a></li><li><a class="tocitem" href="../../../../reference/expressions/">Expressions</a></li><li><a class="tocitem" href="../../../../reference/objectives/">Objectives</a></li><li><a class="tocitem" href="../../../../reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../../reference/containers/">Containers</a></li><li><a class="tocitem" href="../../../../reference/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../../reference/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../../../reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../../reference/extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Background Information</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../background/algebraic_modeling_languages/">Algebraic modeling languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../developers/contributing/">Contributing</a></li><li><a class="tocitem" href="../../../../developers/extensions/">Extensions</a></li><li><a class="tocitem" href="../../../../developers/custom_solver_binaries/">Custom binaries</a></li><li><a class="tocitem" href="../../../../developers/style/">Style Guide</a></li><li><a class="tocitem" href="../../../../developers/roadmap/">Roadmap</a></li><li><a class="tocitem" href="../../../../developers/release_process/">Release process</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../packages/solvers/">Introduction</a></li><li><a class="tocitem" href="../../../../packages/AmplNLWriter/">jump-dev/AmplNLWriter.jl</a></li><li><a class="tocitem" href="../../../../packages/BARON/">jump-dev/BARON.jl</a></li><li><a class="tocitem" href="../../../../packages/CPLEX/">jump-dev/CPLEX.jl</a></li><li><a class="tocitem" href="../../../../packages/CSDP/">jump-dev/CSDP.jl</a></li><li><a class="tocitem" href="../../../../packages/Cbc/">jump-dev/Cbc.jl</a></li><li><a class="tocitem" href="../../../../packages/Clp/">jump-dev/Clp.jl</a></li><li><a class="tocitem" href="../../../../packages/Dualization/">jump-dev/Dualization.jl</a></li><li><a class="tocitem" href="../../../../packages/ECOS/">jump-dev/ECOS.jl</a></li><li><a class="tocitem" href="../../../../packages/GLPK/">jump-dev/GLPK.jl</a></li><li><a class="tocitem" href="../../../../packages/Gurobi/">jump-dev/Gurobi.jl</a></li><li><a class="tocitem" href="../../../../packages/HiGHS/">jump-dev/HiGHS.jl</a></li><li><a class="tocitem" href="../../../../packages/Ipopt/">jump-dev/Ipopt.jl</a></li><li><a class="tocitem" href="../../../../packages/KNITRO/">jump-dev/KNITRO.jl</a></li><li><a class="tocitem" href="../../../../packages/MiniZinc/">jump-dev/MiniZinc.jl</a></li><li><a class="tocitem" href="../../../../packages/MosekTools/">jump-dev/MosekTools.jl</a></li><li><a class="tocitem" href="../../../../packages/MultiObjectiveAlgorithms/">jump-dev/MultiObjectiveAlgorithms.jl</a></li><li><a class="tocitem" href="../../../../packages/Pajarito/">jump-dev/Pajarito.jl</a></li><li><a class="tocitem" href="../../../../packages/Pavito/">jump-dev/Pavito.jl</a></li><li><a class="tocitem" href="../../../../packages/Penopt/">jump-dev/Penopt.jl</a></li><li><a class="tocitem" href="../../../../packages/SCS/">jump-dev/SCS.jl</a></li><li><a class="tocitem" href="../../../../packages/SDPA/">jump-dev/SDPA.jl</a></li><li><a class="tocitem" href="../../../../packages/SDPNAL/">jump-dev/SDPNAL.jl</a></li><li><a class="tocitem" href="../../../../packages/SDPT3/">jump-dev/SDPT3.jl</a></li><li><a class="tocitem" href="../../../../packages/SeDuMi/">jump-dev/SeDuMi.jl</a></li><li><a class="tocitem" href="../../../../packages/Xpress/">jump-dev/Xpress.jl</a></li><li><a class="tocitem" href="../../../../packages/PATHSolver/">chkwon/PATHSolver.jl</a></li><li><a class="tocitem" href="../../../../packages/NEOSServer/">odow/NEOSServer.jl</a></li><li><a class="tocitem" href="../../../../packages/SCIP/">scipopt/SCIP.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Extensions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../packages/extensions/">Introduction</a></li><li><a class="tocitem" href="../../../../packages/DiffOpt/">jump-dev/DiffOpt.jl</a></li><li><a class="tocitem" href="../../../../packages/ParametricOptInterface/">jump-dev/ParametricOptInterface.jl</a></li><li><a class="tocitem" href="../../../../packages/PolyJuMP/">jump-dev/PolyJuMP.jl</a></li><li><a class="tocitem" href="../../../../packages/SumOfSquares/">jump-dev/SumOfSquares.jl</a></li><li><a class="tocitem" href="../../../../packages/SDDP/">odow/SDDP.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox" checked/><label class="tocitem" for="menuitem-9"><span class="docs-label">MathOptInterface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-1" type="checkbox"/><label class="tocitem" for="menuitem-9-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../">Introduction</a></li><li><a class="tocitem" href="../../../background/motivation/">Motivation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-2" type="checkbox"/><label class="tocitem" for="menuitem-9-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/example/">Solving a problem using MathOptInterface</a></li><li><a class="tocitem" href="../../../tutorials/implementing/">Implementing a solver interface</a></li><li><a class="tocitem" href="../../../tutorials/mathprogbase/">Transitioning from MathProgBase</a></li><li><a class="tocitem" href="../../../tutorials/bridging_constraint/">Implementing a constraint bridge</a></li><li><a class="tocitem" href="../../../tutorials/manipulating_expressions/">Manipulating expressions</a></li><li><a class="tocitem" href="../../../tutorials/latency/">Latency</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-3" type="checkbox"/><label class="tocitem" for="menuitem-9-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../manual/standard_form/">Standard form problem</a></li><li><a class="tocitem" href="../../../manual/models/">Models</a></li><li><a class="tocitem" href="../../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../manual/modification/">Problem modification</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-4" type="checkbox"/><label class="tocitem" for="menuitem-9-4"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../background/duality/">Duality</a></li><li><a class="tocitem" href="../../../background/infeasibility_certificates/">Infeasibility certificates</a></li><li><a class="tocitem" href="../../../background/naming_conventions/">Naming conventions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-5" type="checkbox"/><label class="tocitem" for="menuitem-9-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../reference/standard_form/">Standard form</a></li><li><a class="tocitem" href="../../../reference/models/">Models</a></li><li><a class="tocitem" href="../../../reference/variables/">Variables</a></li><li><a class="tocitem" href="../../../reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../reference/modification/">Modifications</a></li><li><a class="tocitem" href="../../../reference/nonlinear/">Nonlinear programming</a></li><li><a class="tocitem" href="../../../reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../reference/errors/">Errors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox" checked/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-6-1" type="checkbox"/><label class="tocitem" for="menuitem-9-6-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-2" type="checkbox"/><label class="tocitem" for="menuitem-9-6-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Bridges/overview/">Overview</a></li><li><a class="tocitem" href="../../Bridges/list_of_bridges/">List of bridges</a></li><li><a class="tocitem" href="../../Bridges/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-3" type="checkbox"/><label class="tocitem" for="menuitem-9-6-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../FileFormats/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-4" type="checkbox"/><label class="tocitem" for="menuitem-9-6-4"><span class="docs-label">Nonlinear</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nonlinear/overview/">Overview</a></li><li><a class="tocitem" href="../../Nonlinear/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-5" type="checkbox" checked/><label class="tocitem" for="menuitem-9-6-5"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Utilities.Model"><span>Utilities.Model</span></a></li><li><a class="tocitem" href="#Utilities.UniversalFallback"><span>Utilities.UniversalFallback</span></a></li><li><a class="tocitem" href="#Utilities.@model"><span>Utilities.@model</span></a></li><li><a class="tocitem" href="#Caching-optimizer"><span>Caching optimizer</span></a></li><li><a class="tocitem" href="#Mock-optimizer"><span>Mock optimizer</span></a></li><li><a class="tocitem" href="#Printing"><span>Printing</span></a></li><li><a class="tocitem" href="#Copy-utilities"><span>Copy utilities</span></a></li><li><a class="tocitem" href="#Penalty-relaxation"><span>Penalty relaxation</span></a></li><li><a class="tocitem" href="#MatrixOfConstraints"><span>MatrixOfConstraints</span></a></li><li><a class="tocitem" href="#Fallbacks"><span>Fallbacks</span></a></li><li><a class="tocitem" href="#Function-utilities"><span>Function utilities</span></a></li><li><a class="tocitem" href="#Constraint-utilities"><span>Constraint utilities</span></a></li><li><a class="tocitem" href="#Set-utilities"><span>Set utilities</span></a></li><li><a class="tocitem" href="#DoubleDicts"><span>DoubleDicts</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6-6"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Test/overview/">Overview</a></li><li><a class="tocitem" href="../../Test/reference/">API Reference</a></li></ul></li></ul></li><li><a class="tocitem" href="../../../release_notes/">Release notes</a></li></ul></li><li><a class="tocitem" href="../../../../release_notes/">Release notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">MathOptInterface</a></li><li><a class="is-disabled">Submodules</a></li><li><a class="is-disabled">Utilities</a></li><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/moi/submodules/Utilities/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Utilities.Model"><a class="docs-heading-anchor" href="#Utilities.Model">Utilities.Model</a><a id="Utilities.Model-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities.Model" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.Model" href="#MathOptInterface.Utilities.Model"><code>MathOptInterface.Utilities.Model</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An implementation of <code>ModelLike</code> that supports all functions and sets defined in MOI. It is parameterized by the coefficient type.</p><p><strong>Examples</strong></p><pre><code class="language-jl hljs">model = Model{Float64}()
x = add_variable(model)</code></pre></div></section></article><h2 id="Utilities.UniversalFallback"><a class="docs-heading-anchor" href="#Utilities.UniversalFallback">Utilities.UniversalFallback</a><a id="Utilities.UniversalFallback-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities.UniversalFallback" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.UniversalFallback" href="#MathOptInterface.Utilities.UniversalFallback"><code>MathOptInterface.Utilities.UniversalFallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UniversalFallback</code></pre><p>The <code>UniversalFallback</code> can be applied on a <a href="../../../reference/models/#MathOptInterface.ModelLike"><code>MOI.ModelLike</code></a> <code>model</code> to create the model <code>UniversalFallback(model)</code> supporting <em>any</em> constraint and attribute. This allows to have a specialized implementation in <code>model</code> for performance critical constraints and attributes while still supporting other attributes with a small performance penalty. Note that <code>model</code> is unaware of constraints and attributes stored by <code>UniversalFallback</code> so this is not appropriate if <code>model</code> is an optimizer (for this reason, <a href="../../../reference/models/#MathOptInterface.optimize!"><code>MOI.optimize!</code></a> has not been implemented). In that case, optimizer bridges should be used instead.</p></div></section></article><h2 id="Utilities.@model"><a class="docs-heading-anchor" href="#Utilities.@model">Utilities.@model</a><a id="Utilities.@model-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities.@model" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.@model" href="#MathOptInterface.Utilities.@model"><code>MathOptInterface.Utilities.@model</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">macro model(
    model_name,
    scalar_sets,
    typed_scalar_sets,
    vector_sets,
    typed_vector_sets,
    scalar_functions,
    typed_scalar_functions,
    vector_functions,
    typed_vector_functions,
    is_optimizer = false
)</code></pre><p>Creates a type <code>model_name</code> implementing the MOI model interface and containing <code>scalar_sets</code> scalar sets <code>typed_scalar_sets</code> typed scalar sets, <code>vector_sets</code> vector sets, <code>typed_vector_sets</code> typed vector sets, <code>scalar_functions</code> scalar functions, <code>typed_scalar_functions</code> typed scalar functions, <code>vector_functions</code> vector functions and <code>typed_vector_functions</code> typed vector functions. To give no set/function, write <code>()</code>, to give one set <code>S</code>, write <code>(S,)</code>.</p><p>The function <a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> should not be given in <code>scalar_functions</code>. The model supports <a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a>-in-<code>S</code> constraints where <code>S</code> is <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.Interval"><code>MOI.Interval</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.Integer"><code>MOI.Integer</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.ZeroOne"><code>MOI.ZeroOne</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.Semicontinuous"><code>MOI.Semicontinuous</code></a> or <a href="../../../reference/standard_form/#MathOptInterface.Semiinteger"><code>MOI.Semiinteger</code></a>. The sets supported with the <a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> cannot be controlled from the macro, use the <a href="#MathOptInterface.Utilities.UniversalFallback"><code>UniversalFallback</code></a> to support more sets.</p><p>This macro creates a model specialized for specific types of constraint, by defining specialized structures and methods. To create a model that, in addition to be optimized for specific constraints, also support arbitrary constraints and attributes, use <a href="#MathOptInterface.Utilities.UniversalFallback"><code>UniversalFallback</code></a>.</p><p>If <code>is_optimizer = true</code>, the resulting struct is a of <a href="#MathOptInterface.Utilities.GenericOptimizer"><code>GenericOptimizer</code></a>, which is a subtype of <a href="../../../reference/models/#MathOptInterface.AbstractOptimizer"><code>MOI.AbstractOptimizer</code></a>, otherwise, it is a <a href="#MathOptInterface.Utilities.GenericModel"><code>GenericModel</code></a>, which is a subtype of <a href="../../../reference/models/#MathOptInterface.ModelLike"><code>MOI.ModelLike</code></a>.</p><p><strong>Examples</strong></p><p>The model describing an linear program would be:</p><pre><code class="language-julia hljs">@model(LPModel,                                                   # Name of model
      (),                                                         # untyped scalar sets
      (MOI.EqualTo, MOI.GreaterThan, MOI.LessThan, MOI.Interval), #   typed scalar sets
      (MOI.Zeros, MOI.Nonnegatives, MOI.Nonpositives),            # untyped vector sets
      (),                                                         #   typed vector sets
      (),                                                         # untyped scalar functions
      (MOI.ScalarAffineFunction,),                                #   typed scalar functions
      (MOI.VectorOfVariables,),                                   # untyped vector functions
      (MOI.VectorAffineFunction,),                                #   typed vector functions
      false
    )</code></pre><p>Let <code>MOI</code> denote <code>MathOptInterface</code>, <code>MOIU</code> denote <code>MOI.Utilities</code>. The macro would create the following types with <a href="#MathOptInterface.Utilities.struct_of_constraint_code"><code>struct_of_constraint_code</code></a>:</p><pre><code class="language-julia hljs">struct LPModelScalarConstraints{T, C1, C2, C3, C4} &lt;: MOIU.StructOfConstraints
    moi_equalto::C1
    moi_greaterthan::C2
    moi_lessthan::C3
    moi_interval::C4
end
struct LPModelVectorConstraints{T, C1, C2, C3} &lt;: MOIU.StructOfConstraints
    moi_zeros::C1
    moi_nonnegatives::C2
    moi_nonpositives::C3
end
struct LPModelFunctionConstraints{T} &lt;: MOIU.StructOfConstraints
    moi_scalaraffinefunction::LPModelScalarConstraints{
        T,
        MOIU.VectorOfConstraints{MOI.ScalarAffineFunction{T}, MOI.EqualTo{T}},
        MOIU.VectorOfConstraints{MOI.ScalarAffineFunction{T}, MOI.GreaterThan{T}},
        MOIU.VectorOfConstraints{MOI.ScalarAffineFunction{T}, MOI.LessThan{T}},
        MOIU.VectorOfConstraints{MOI.ScalarAffineFunction{T}, MOI.Interval{T}}
    }
    moi_vectorofvariables::LPModelVectorConstraints{
        T,
        MOIU.VectorOfConstraints{MOI.VectorOfVariables, MOI.Zeros},
        MOIU.VectorOfConstraints{MOI.VectorOfVariables, MOI.Nonnegatives},
        MOIU.VectorOfConstraints{MOI.VectorOfVariables, MOI.Nonpositives}
    }
    moi_vectoraffinefunction::LPModelVectorConstraints{
        T,
        MOIU.VectorOfConstraints{MOI.VectorAffineFunction{T}, MOI.Zeros},
        MOIU.VectorOfConstraints{MOI.VectorAffineFunction{T}, MOI.Nonnegatives},
        MOIU.VectorOfConstraints{MOI.VectorAffineFunction{T}, MOI.Nonpositives}
    }
end
const LPModel{T} = MOIU.GenericModel{T,MOIU.ObjectiveContainer{T},MOIU.VariablesContainer{T},LPModelFunctionConstraints{T}}</code></pre><p>The type <code>LPModel</code> implements the MathOptInterface API except methods specific to optimizers like <code>optimize!</code> or <code>get</code> with <code>VariablePrimal</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.GenericModel" href="#MathOptInterface.Utilities.GenericModel"><code>MathOptInterface.Utilities.GenericModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct GenericModel{T,O,V,C} &lt;: AbstractModelLike{T}</code></pre><p>Implements a model supporting coefficients of type <code>T</code> and:</p><ul><li>An objective function stored in <code>.objective::O</code></li><li>Variables and <code>VariableIndex</code> constraints stored in <code>.variable_bounds::V</code></li><li><code>F</code>-in-<code>S</code> constraints (excluding <code>VariableIndex</code> constraints) stored in <code>.constraints::C</code></li></ul><p>All interactions should take place via the MOI interface, so the types <code>O</code>, <code>V</code>, and <code>C</code> should implement the API as needed for their functionality.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.GenericOptimizer" href="#MathOptInterface.Utilities.GenericOptimizer"><code>MathOptInterface.Utilities.GenericOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct GenericOptimizer{T,O,V,C} &lt;: AbstractOptimizer{T}</code></pre><p>Implements a model supporting coefficients of type <code>T</code> and:</p><ul><li>An objective function stored in <code>.objective::O</code></li><li>Variables and <code>VariableIndex</code> constraints stored in <code>.variable_bounds::V</code></li><li><code>F</code>-in-<code>S</code> constraints (excluding <code>VariableIndex</code> constraints) stored in <code>.constraints::C</code></li></ul><p>All interactions should take place via the MOI interface, so the types <code>O</code>, <code>V</code>, and <code>C</code> should implement the API as needed for their functionality.</p></div></section></article><h3 id=".objective"><a class="docs-heading-anchor" href="#.objective"><code>.objective</code></a><a id=".objective-1"></a><a class="docs-heading-anchor-permalink" href="#.objective" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.ObjectiveContainer" href="#MathOptInterface.Utilities.ObjectiveContainer"><code>MathOptInterface.Utilities.ObjectiveContainer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObjectiveContainer{T}</code></pre><p>A helper struct to simplify the handling of objective functions in Utilities.Model.</p></div></section></article><h3 id=".variables"><a class="docs-heading-anchor" href="#.variables"><code>.variables</code></a><a id=".variables-1"></a><a class="docs-heading-anchor-permalink" href="#.variables" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.VariablesContainer" href="#MathOptInterface.Utilities.VariablesContainer"><code>MathOptInterface.Utilities.VariablesContainer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct VariablesContainer{T} &lt;: AbstractVectorBounds
    set_mask::Vector{UInt16}
    lower::Vector{T}
    upper::Vector{T}
end</code></pre><p>A struct for storing variables and VariableIndex-related constraints. Used in <code>MOI.Utilities.Model</code> by default.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.FreeVariables" href="#MathOptInterface.Utilities.FreeVariables"><code>MathOptInterface.Utilities.FreeVariables</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct FreeVariables &lt;: MOI.ModelLike
    n::Int64
    FreeVariables() = new(0)
end</code></pre><p>A struct for storing free variables that can be used as the <code>variables</code> field of <a href="#MathOptInterface.Utilities.GenericModel"><code>GenericModel</code></a> or <a href="#MathOptInterface.Utilities.GenericModel"><code>GenericModel</code></a>. It represents a model that does not support any constraint nor objective function.</p><p><strong>Example</strong></p><p>The following model type represents a conic model in geometric form. As opposed to <a href="#MathOptInterface.Utilities.VariablesContainer"><code>VariablesContainer</code></a>, <code>FreeVariables</code> does not support constraint bounds so they are bridged into an affine constraint in the <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a> cone as expected for the geometric conic form.</p><pre><code class="language-jldocstest hljs">julia&gt; MOI.Utilities.@product_of_sets(
    Cones,
    MOI.Zeros,
    MOI.Nonnegatives,
    MOI.SecondOrderCone,
    MOI.PositiveSemidefiniteConeTriangle,
);

julia&gt; const ConicModel{T} = MOI.Utilities.GenericOptimizer{
    T,
    MOI.Utilities.ObjectiveContainer{T},
    MOI.Utilities.FreeVariables,
    MOI.Utilities.MatrixOfConstraints{
        T,
        MOI.Utilities.MutableSparseMatrixCSC{
            T,
            Int,
            MOI.Utilities.OneBasedIndexing,
        },
        Vector{T},
        Cones{T},
    },
};

julia&gt; model = MOI.instantiate(ConicModel{Float64}, with_bridge_type=Float64);

julia&gt; x = MOI.add_variable(model)
MathOptInterface.VariableIndex(1)

julia&gt; c = MOI.add_constraint(model, x, MOI.GreaterThan(1.0))
MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64}}(1)

julia&gt; MOI.Bridges.is_bridged(model, c)
true

julia&gt; bridge = MOI.Bridges.bridge(model, c)
MathOptInterface.Bridges.Constraint.VectorizeBridge{Float64, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives, MathOptInterface.VariableIndex}(MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}(1), 1.0)

julia&gt; bridge.vector_constraint
MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}(1)

julia&gt; MOI.Bridges.is_bridged(model, bridge.vector_constraint)
false</code></pre></div></section></article><h3 id=".constraints"><a class="docs-heading-anchor" href="#.constraints"><code>.constraints</code></a><a id=".constraints-1"></a><a class="docs-heading-anchor-permalink" href="#.constraints" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.VectorOfConstraints" href="#MathOptInterface.Utilities.VectorOfConstraints"><code>MathOptInterface.Utilities.VectorOfConstraints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct VectorOfConstraints{
    F&lt;:MOI.AbstractFunction,
    S&lt;:MOI.AbstractSet,
} &lt;: MOI.ModelLike
    constraints::CleverDicts.CleverDict{
        MOI.ConstraintIndex{F,S},
        Tuple{F,S},
        typeof(CleverDicts.key_to_index),
        typeof(CleverDicts.index_to_key),
    }
end</code></pre><p>A struct storing <code>F</code>-in-<code>S</code> constraints as a mapping between the constraint indices to the corresponding tuple of function and set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.StructOfConstraints" href="#MathOptInterface.Utilities.StructOfConstraints"><code>MathOptInterface.Utilities.StructOfConstraints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type StructOfConstraints &lt;: MOI.ModelLike end</code></pre><p>A struct storing a subfields other structs storing constraints of different types.</p><p>See <a href="#MathOptInterface.Utilities.@struct_of_constraints_by_function_types"><code>Utilities.@struct_of_constraints_by_function_types</code></a> and <a href="#MathOptInterface.Utilities.@struct_of_constraints_by_set_types"><code>Utilities.@struct_of_constraints_by_set_types</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.@struct_of_constraints_by_function_types" href="#MathOptInterface.Utilities.@struct_of_constraints_by_function_types"><code>MathOptInterface.Utilities.@struct_of_constraints_by_function_types</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">Utilities.@struct_of_constraints_by_function_types(name, func_types...)</code></pre><p>Given a vector of <code>n</code> function types <code>(F1, F2,..., Fn)</code> in <code>func_types</code>, defines a subtype of <code>StructOfConstraints</code> of name <code>name</code> and which type parameters <code>{T, C1, C2, ..., Cn}</code>. It contains <code>n</code> field where the <code>i</code>th field has type <code>Ci</code> and stores the constraints of function type <code>Fi</code>.</p><p>The expression <code>Fi</code> can also be a union in which case any constraint for which the function type is in the union is stored in the field with type <code>Ci</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.@struct_of_constraints_by_set_types" href="#MathOptInterface.Utilities.@struct_of_constraints_by_set_types"><code>MathOptInterface.Utilities.@struct_of_constraints_by_set_types</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">Utilities.@struct_of_constraints_by_set_types(name, func_types...)</code></pre><p>Given a vector of <code>n</code> set types <code>(S1, S2,..., Sn)</code> in <code>func_types</code>, defines a subtype of <code>StructOfConstraints</code> of name <code>name</code> and which type parameters <code>{T, C1, C2, ..., Cn}</code>. It contains <code>n</code> field where the <code>i</code>th field has type <code>Ci</code> and stores the constraints of set type <code>Si</code>. The expression <code>Si</code> can also be a union in which case any constraint for which the set type is in the union is stored in the field with type <code>Ci</code>. This can be useful if <code>Ci</code> is a <a href="#MathOptInterface.Utilities.MatrixOfConstraints"><code>MatrixOfConstraints</code></a> in order to concatenate the coefficients of constraints of several different set types in the same matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.struct_of_constraint_code" href="#MathOptInterface.Utilities.struct_of_constraint_code"><code>MathOptInterface.Utilities.struct_of_constraint_code</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">struct_of_constraint_code(struct_name, types, field_types = nothing)</code></pre><p>Given a vector of <code>n</code> <code>Union{SymbolFun,_UnionSymbolFS{SymbolFun}}</code> or <code>Union{SymbolSet,_UnionSymbolFS{SymbolSet}}</code> in <code>types</code>, defines a subtype of <code>StructOfConstraints</code> of name <code>name</code> and which type parameters <code>{T, F1, F2, ..., Fn}</code> if <code>field_types</code> is <code>nothing</code> and a <code>{T}</code> otherwise. It contains <code>n</code> field where the <code>i</code>th field has type <code>Ci</code> if <code>field_types</code> is <code>nothing</code> and type <code>field_types[i]</code> otherwise. If <code>types</code> is vector of <code>Union{SymbolFun,_UnionSymbolFS{SymbolFun}}</code> (resp. <code>Union{SymbolSet,_UnionSymbolFS{SymbolSet}}</code>) then the constraints of that function (resp. set) type are stored in the corresponding field.</p><p>This function is used by the macros <a href="#MathOptInterface.Utilities.@model"><code>@model</code></a>, <a href="#MathOptInterface.Utilities.@struct_of_constraints_by_function_types"><code>@struct_of_constraints_by_function_types</code></a> and <a href="#MathOptInterface.Utilities.@struct_of_constraints_by_set_types"><code>@struct_of_constraints_by_set_types</code></a>.</p></div></section></article><h2 id="Caching-optimizer"><a class="docs-heading-anchor" href="#Caching-optimizer">Caching optimizer</a><a id="Caching-optimizer-1"></a><a class="docs-heading-anchor-permalink" href="#Caching-optimizer" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.CachingOptimizer" href="#MathOptInterface.Utilities.CachingOptimizer"><code>MathOptInterface.Utilities.CachingOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CachingOptimizer</code></pre><p><code>CachingOptimizer</code> is an intermediate layer that stores a cache of the model and links it with an optimizer. It supports incremental model construction and modification even when the optimizer doesn&#39;t.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">    CachingOptimizer(cache::MOI.ModelLike, optimizer::AbstractOptimizer)</code></pre><p>Creates a <code>CachingOptimizer</code> in <code>AUTOMATIC</code> mode, with the optimizer <code>optimizer</code>.</p><p>The type of the optimizer returned is <code>CachingOptimizer{typeof(optimizer), typeof(cache)}</code> so it does not support the function <code>reset_optimizer(::CachingOptimizer, new_optimizer)</code> if the type of <code>new_optimizer</code> is different from the type of <code>optimizer</code>.</p><pre><code class="language-julia hljs">    CachingOptimizer(cache::MOI.ModelLike, mode::CachingOptimizerMode)</code></pre><p>Creates a <code>CachingOptimizer</code> in the <code>NO_OPTIMIZER</code> state and mode <code>mode</code>.</p><p>The type of the optimizer returned is <code>CachingOptimizer{MOI.AbstractOptimizer,typeof(cache)}</code> so it <em>does</em> support the function <code>reset_optimizer(::CachingOptimizer, new_optimizer)</code> if the type of <code>new_optimizer</code> is different from the type of <code>optimizer</code>.</p><p><strong>About the type</strong></p><p><strong>States</strong></p><p>A <code>CachingOptimizer</code> may be in one of three possible states (<code>CachingOptimizerState</code>):</p><ul><li><code>NO_OPTIMIZER</code>: The CachingOptimizer does not have any optimizer.</li><li><code>EMPTY_OPTIMIZER</code>: The CachingOptimizer has an empty optimizer. The optimizer is not synchronized with the cached model.</li><li><code>ATTACHED_OPTIMIZER</code>: The CachingOptimizer has an optimizer, and it is synchronized with the cached model.</li></ul><p><strong>Modes</strong></p><p>A <code>CachingOptimizer</code> has two modes of operation (<code>CachingOptimizerMode</code>):</p><ul><li><code>MANUAL</code>: The only methods that change the state of the <code>CachingOptimizer</code> are <a href="#MathOptInterface.Utilities.reset_optimizer"><code>Utilities.reset_optimizer</code></a>, <a href="#MathOptInterface.Utilities.drop_optimizer"><code>Utilities.drop_optimizer</code></a>, and <a href="#MathOptInterface.Utilities.attach_optimizer"><code>Utilities.attach_optimizer</code></a>. Attempting to perform an operation in the incorrect state results in an error.</li><li><code>AUTOMATIC</code>: The <code>CachingOptimizer</code> changes its state when necessary. For example, <code>optimize!</code> will automatically call <code>attach_optimizer</code> (an optimizer must have been previously set). Attempting to add a constraint or perform a modification not supported by the optimizer results in a drop to <code>EMPTY_OPTIMIZER</code> mode.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.attach_optimizer" href="#MathOptInterface.Utilities.attach_optimizer"><code>MathOptInterface.Utilities.attach_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">attach_optimizer(model::CachingOptimizer)</code></pre><p>Attaches the optimizer to <code>model</code>, copying all model data into it. Can be called only from the <code>EMPTY_OPTIMIZER</code> state. If the copy succeeds, the <code>CachingOptimizer</code> will be in state <code>ATTACHED_OPTIMIZER</code> after the call, otherwise an error is thrown; see <a href="../../../reference/models/#MathOptInterface.copy_to"><code>MOI.copy_to</code></a> for more details on which errors can be thrown.</p></div></section><section><div><pre><code class="language-julia hljs">MOIU.attach_optimizer(model::Model)</code></pre><p>Call <code>MOIU.attach_optimizer</code> on the backend of <code>model</code>.</p><p>Cannot be called in direct mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/160b22eded2d0ea77e71a4e68da7e060fda7b9e2/src/optimizer_interface.jl#L309-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.reset_optimizer" href="#MathOptInterface.Utilities.reset_optimizer"><code>MathOptInterface.Utilities.reset_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reset_optimizer(m::CachingOptimizer, optimizer::MOI.AbstractOptimizer)</code></pre><p>Sets or resets <code>m</code> to have the given empty optimizer <code>optimizer</code>.</p><p>Can be called from any state. An assertion error will be thrown if <code>optimizer</code> is not empty.</p><p>The <code>CachingOptimizer</code> <code>m</code> will be in state <code>EMPTY_OPTIMIZER</code> after the call.</p></div></section><section><div><pre><code class="language-julia hljs">reset_optimizer(m::CachingOptimizer)</code></pre><p>Detaches and empties the current optimizer. Can be called from <code>ATTACHED_OPTIMIZER</code> or <code>EMPTY_OPTIMIZER</code> state. The <code>CachingOptimizer</code> will be in state <code>EMPTY_OPTIMIZER</code> after the call.</p></div></section><section><div><pre><code class="language-julia hljs">MOIU.reset_optimizer(model::Model, optimizer::MOI.AbstractOptimizer)</code></pre><p>Call <code>MOIU.reset_optimizer</code> on the backend of <code>model</code>.</p><p>Cannot be called in direct mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/160b22eded2d0ea77e71a4e68da7e060fda7b9e2/src/optimizer_interface.jl#L266-L272">source</a></section><section><div><pre><code class="language-julia hljs">MOIU.reset_optimizer(model::Model)</code></pre><p>Call <code>MOIU.reset_optimizer</code> on the backend of <code>model</code>.</p><p>Cannot be called in direct mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/160b22eded2d0ea77e71a4e68da7e060fda7b9e2/src/optimizer_interface.jl#L283-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.drop_optimizer" href="#MathOptInterface.Utilities.drop_optimizer"><code>MathOptInterface.Utilities.drop_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">drop_optimizer(m::CachingOptimizer)</code></pre><p>Drops the optimizer, if one is present. Can be called from any state. The <code>CachingOptimizer</code> will be in state <code>NO_OPTIMIZER</code> after the call.</p></div></section><section><div><pre><code class="language-julia hljs">MOIU.drop_optimizer(model::Model)</code></pre><p>Call <code>MOIU.drop_optimizer</code> on the backend of <code>model</code>.</p><p>Cannot be called in direct mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/160b22eded2d0ea77e71a4e68da7e060fda7b9e2/src/optimizer_interface.jl#L296-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.state" href="#MathOptInterface.Utilities.state"><code>MathOptInterface.Utilities.state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">state(m::CachingOptimizer)::CachingOptimizerState</code></pre><p>Returns the state of the CachingOptimizer <code>m</code>. See <a href="#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.mode" href="#MathOptInterface.Utilities.mode"><code>MathOptInterface.Utilities.mode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mode(m::CachingOptimizer)::CachingOptimizerMode</code></pre><p>Returns the operating mode of the CachingOptimizer <code>m</code>. See <a href="#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a>.</p></div></section></article><h2 id="Mock-optimizer"><a class="docs-heading-anchor" href="#Mock-optimizer">Mock optimizer</a><a id="Mock-optimizer-1"></a><a class="docs-heading-anchor-permalink" href="#Mock-optimizer" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.MockOptimizer" href="#MathOptInterface.Utilities.MockOptimizer"><code>MathOptInterface.Utilities.MockOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MockOptimizer</code></pre><p><code>MockOptimizer</code> is a fake optimizer especially useful for testing. Its main feature is that it can store the values that should be returned for each attribute.</p></div></section></article><h2 id="Printing"><a class="docs-heading-anchor" href="#Printing">Printing</a><a id="Printing-1"></a><a class="docs-heading-anchor-permalink" href="#Printing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.latex_formulation" href="#MathOptInterface.Utilities.latex_formulation"><code>MathOptInterface.Utilities.latex_formulation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">latex_formulation(model::MOI.ModelLike; kwargs...)</code></pre><p>Wrap <code>model</code> in a type so that it can be pretty-printed as <code>text/latex</code> in a notebook like IJulia, or in Documenter.</p><p>To render the model, end the cell with <code>latex_formulation(model)</code>, or call <code>display(latex_formulation(model))</code> in to force the display of the model from inside a function.</p><p>Possible keyword arguments are:</p><ul><li><code>simplify_coefficients</code> : Simplify coefficients if possible by omitting them or removing trailing zeros.</li><li><code>default_name</code> : The name given to variables with an empty name.</li><li><code>print_types</code> : Print the MOI type of each function and set for clarity.</li></ul></div></section></article><h2 id="Copy-utilities"><a class="docs-heading-anchor" href="#Copy-utilities">Copy utilities</a><a id="Copy-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Copy-utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.default_copy_to" href="#MathOptInterface.Utilities.default_copy_to"><code>MathOptInterface.Utilities.default_copy_to</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default_copy_to(dest::MOI.ModelLike, src::MOI.ModelLike)</code></pre><p>A default implementation of <code>MOI.copy_to(dest, src)</code> for models that implement the incremental interface, i.e., <a href="../../../reference/models/#MathOptInterface.supports_incremental_interface"><code>MOI.supports_incremental_interface</code></a> returns <code>true</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.IndexMap" href="#MathOptInterface.Utilities.IndexMap"><code>MathOptInterface.Utilities.IndexMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndexMap()</code></pre><p>The dictionary-like object returned by <a href="../../../reference/models/#MathOptInterface.copy_to"><code>MOI.copy_to</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.identity_index_map" href="#MathOptInterface.Utilities.identity_index_map"><code>MathOptInterface.Utilities.identity_index_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">identity_index_map(model::MOI.ModelLike)</code></pre><p>Return an <a href="#MathOptInterface.Utilities.IndexMap"><code>IndexMap</code></a> that maps all variable and constraint indices of <code>model</code> to themselves.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.ModelFilter" href="#MathOptInterface.Utilities.ModelFilter"><code>MathOptInterface.Utilities.ModelFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModelFilter(filter::Function, model::MOI.ModelLike)</code></pre><p>A layer to filter out various components of <code>model</code>.</p><p>The filter function takes a single argument, which is each element from the list returned by the attributes below. It returns <code>true</code> if the element should be visible in the filtered model and <code>false</code> otherwise.</p><p>The components that are filtered are:</p><ul><li>Entire constraint types via:<ul><li><code>MOI.ListOfConstraintTypesPresent</code></li></ul></li><li>Individual constraints via:<ul><li><code>MOI.ListOfConstraintIndices{F,S}</code></li></ul></li><li>Specific attributes via:<ul><li><code>MOI.ListOfModelAttributesSet</code></li><li><code>MOI.ListOfConstraintAttributesSet</code></li><li><code>MOI.ListOfVariableAttributesSet</code></li></ul></li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The list of attributes filtered may change in a future release. You should write functions that are generic and not limited to the five types listed above. Thus, you should probably define a fallback <code>filter(::Any) = true</code>.</p></div></div><p>See below for examples of how this works.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This layer has a limited scope. It is intended by be used in conjunction with <code>MOI.copy_to</code>.</p></div></div><p><strong>Example: copy model excluding integer constraints</strong></p><p>Use the <code>do</code> syntax to provide a single function.</p><pre><code class="language-julia hljs">filtered_src = MOI.Utilities.ModelFilter(src) do item
    return item != (MOI.VariableIndex, MOI.Integer)
end
MOI.copy_to(dest, filtered_src)</code></pre><p><strong>Example: copy model excluding names</strong></p><p>Use type dispatch to simplify the implementation:</p><pre><code class="language-julia hljs">my_filter(::Any) = true  # Note the generic fallback!
my_filter(::MOI.VariableName) = false
my_filter(::MOI.ConstraintName) = false
filtered_src = MOI.Utilities.ModelFilter(my_filter, src)
MOI.copy_to(dest, filtered_src)</code></pre><p><strong>Example: copy irreducible infeasible subsystem</strong></p><pre><code class="language-julia hljs">my_filter(::Any) = true  # Note the generic fallback!
function my_filter(ci::MOI.ConstraintIndex)
    status = MOI.get(dest, MOI.ConstraintConflictStatus(), ci)
    return status != MOI.NOT_IN_CONFLICT
end
filtered_src = MOI.Utilities.ModelFilter(my_filter, src)
MOI.copy_to(dest, filtered_src)</code></pre></div></section></article><h2 id="Penalty-relaxation"><a class="docs-heading-anchor" href="#Penalty-relaxation">Penalty relaxation</a><a id="Penalty-relaxation-1"></a><a class="docs-heading-anchor-permalink" href="#Penalty-relaxation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.PenaltyRelaxation" href="#MathOptInterface.Utilities.PenaltyRelaxation"><code>MathOptInterface.Utilities.PenaltyRelaxation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PenaltyRelaxation(
    penalties = Dict{MOI.ConstraintIndex,Float64}();
    default::Union{Nothing,T} = 1.0,
)</code></pre><p>A problem modifier that, when passed to <a href="../../../reference/modification/#MathOptInterface.modify"><code>MOI.modify</code></a>, destructively modifies the model in-place to create a penalized relaxation of the constraints.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This is a destructive routine that modifies the model in-place. If you don&#39;t want to modify the original model, use <code>JuMP.copy_model</code> to create a copy before calling <a href="../../../reference/modification/#MathOptInterface.modify"><code>MOI.modify</code></a>.</p></div></div><p><strong>Reformulation</strong></p><p>See <a href="#MathOptInterface.Utilities.ScalarPenaltyRelaxation"><code>Utilities.ScalarPenaltyRelaxation</code></a> for details of the reformulation.</p><p>For each constraint <code>ci</code>, the penalty passed to <a href="#MathOptInterface.Utilities.ScalarPenaltyRelaxation"><code>Utilities.ScalarPenaltyRelaxation</code></a> is <code>get(penalties, ci, default)</code>. If the value is <code>nothing</code>, because <code>ci</code> does not exist in <code>penalties</code> and <code>default = nothing</code>, then the constraint is skipped.</p><p><strong>Return value</strong></p><p><code>MOI.modify(model, PenaltyRelaxation())</code> returns a <code>Dict{MOI.ConstraintIndex,MOI.ScalarAffineFunction}</code> that maps each constraint index to the corresponding <code>y + z</code> as a <a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction</code></a>. In an optimal solution, query the value of these functions to compute the violation of each constraint.</p><p><strong>Relax a subset of constraints</strong></p><p>To relax a subset of constraints, pass a <code>penalties</code> dictionary and set <code>default = nothing</code>.</p><p><strong>Supported constraint types</strong></p><p>The penalty relaxation is currently limited to modifying <a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction</code></a> and <a href="../../../reference/standard_form/#MathOptInterface.ScalarQuadraticFunction"><code>MOI.ScalarQuadraticFunction</code></a> constraints in the linear sets <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo</code></a> and <a href="../../../reference/standard_form/#MathOptInterface.Interval"><code>MOI.Interval</code></a>.</p><p>It does not include variable bound or integrality constraints, because these cannot be modified in-place.</p><p>To modify variable bounds, rewrite them as linear constraints.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = MOI.Utilities.Model{Float64}();

julia&gt; x = MOI.add_variable(model);

julia&gt; c = MOI.add_constraint(model, 1.0 * x, MOI.LessThan(2.0));

julia&gt; map = MOI.modify(model, MOI.Utilities.PenaltyRelaxation(default = 2.0));

julia&gt; print(model)
Minimize ScalarAffineFunction{Float64}:
 0.0 + 2.0 v[2]

Subject to:

ScalarAffineFunction{Float64}-in-LessThan{Float64}
 0.0 + 1.0 v[1] - 1.0 v[2] &lt;= 2.0

VariableIndex-in-GreaterThan{Float64}
 v[2] &gt;= 0.0

julia&gt; map[c] isa MOI.ScalarAffineFunction{Float64}
true</code></pre><pre><code class="language-julia-repl hljs">julia&gt; model = MOI.Utilities.Model{Float64}();

julia&gt; x = MOI.add_variable(model);

julia&gt; c = MOI.add_constraint(model, 1.0 * x, MOI.LessThan(2.0));

julia&gt; map = MOI.modify(model, MOI.Utilities.PenaltyRelaxation(Dict(c =&gt; 3.0)));

julia&gt; print(model)
Minimize ScalarAffineFunction{Float64}:
 0.0 + 3.0 v[2]

Subject to:

ScalarAffineFunction{Float64}-in-LessThan{Float64}
 0.0 + 1.0 v[1] - 1.0 v[2] &lt;= 2.0

VariableIndex-in-GreaterThan{Float64}
 v[2] &gt;= 0.0

julia&gt; map[c] isa MOI.ScalarAffineFunction{Float64}
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.ScalarPenaltyRelaxation" href="#MathOptInterface.Utilities.ScalarPenaltyRelaxation"><code>MathOptInterface.Utilities.ScalarPenaltyRelaxation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScalarPenaltyRelaxation(penalty::T) where {T}</code></pre><p>A problem modifier that, when passed to <a href="../../../reference/modification/#MathOptInterface.modify"><code>MOI.modify</code></a>, destructively modifies the constraint in-place to create a penalized relaxation of the constraint.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This is a destructive routine that modifies the constraint in-place. If you don&#39;t want to modify the original model, use <code>JuMP.copy_model</code> to create a copy before calling <a href="../../../reference/modification/#MathOptInterface.modify"><code>MOI.modify</code></a>.</p></div></div><p><strong>Reformulation</strong></p><p>The penalty relaxation modifies constraints of the form <span>$f(x) \in S$</span> into <span>$f(x) + y - z \in S$</span>, where <span>$y, z \ge 0$</span>, and then it introduces a penalty term into the objective of <span>$a \times (y + z)$</span> (if minimizing, else <span>$-a$</span>), where <span>$a$</span> is <code>penalty</code></p><p>When <code>S</code> is <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan</code></a> or <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan</code></a>, we omit <code>y</code> or <code>z</code> respectively as a performance optimization.</p><p><strong>Return value</strong></p><p><code>MOI.modify(model, ci, ScalarPenaltyRelaxation(penalty))</code> returns <code>y + z</code> as a <a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction</code></a>. In an optimal solution, query the value of this function to compute the violation of the constraint.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = MOI.Utilities.Model{Float64}();

julia&gt; x = MOI.add_variable(model);

julia&gt; c = MOI.add_constraint(model, 1.0 * x, MOI.LessThan(2.0));

julia&gt; f = MOI.modify(model, c, MOI.Utilities.ScalarPenaltyRelaxation(2.0));

julia&gt; print(model)
Minimize ScalarAffineFunction{Float64}:
 0.0 + 2.0 v[2]

Subject to:

ScalarAffineFunction{Float64}-in-LessThan{Float64}
 0.0 + 1.0 v[1] - 1.0 v[2] &lt;= 2.0

VariableIndex-in-GreaterThan{Float64}
 v[2] &gt;= 0.0

julia&gt; f isa MOI.ScalarAffineFunction{Float64}
true</code></pre></div></section></article><h2 id="MatrixOfConstraints"><a class="docs-heading-anchor" href="#MatrixOfConstraints">MatrixOfConstraints</a><a id="MatrixOfConstraints-1"></a><a class="docs-heading-anchor-permalink" href="#MatrixOfConstraints" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.MatrixOfConstraints" href="#MathOptInterface.Utilities.MatrixOfConstraints"><code>MathOptInterface.Utilities.MatrixOfConstraints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct MatrixOfConstraints{T,AT,BT,ST} &lt;: MOI.ModelLike
    coefficients::AT
    constants::BT
    sets::ST
    caches::Vector{Any}
    are_indices_mapped::Vector{BitSet}
    final_touch::Bool
end</code></pre><p>Represent <code>ScalarAffineFunction</code> and <code>VectorAffinefunction</code> constraints in a matrix form where the linear coefficients of the functions are stored in the <code>coefficients</code> field, the constants of the functions or sets are stored in the <code>constants</code> field. Additional information about the sets are stored in the <code>sets</code> field.</p><p>This model can only be used as the <code>constraints</code> field of a <code>MOI.Utilities.AbstractModel</code>.</p><p>When the constraints are added, they are stored in the <code>caches</code> field. They are only loaded in the <code>coefficients</code> and <code>constants</code> fields once <code>MOI.Utilities.final_touch</code> is called. For this reason, <code>MatrixOfConstraints</code> should not be used by an incremental interface. Use <code>MOI.copy_to</code> instead.</p><p>The constraints can be added in two different ways:</p><ol><li>With <code>add_constraint</code>, in which case a canonicalized copy of the function is stored in <code>caches</code>.</li><li>With <code>pass_nonvariable_constraints</code>, in which case the functions and sets are stored themselves in <code>caches</code> without mapping the variable indices. The corresponding index in <code>caches</code> is added in <code>are_indices_mapped</code>. This avoids doing a copy of the function in case the getter of <code>CanonicalConstraintFunction</code> does not make a copy for the source model, e.g., this is the case of <code>VectorOfConstraints</code>.</li></ol><p>We illustrate this with an example. Suppose a model is copied from a <code>src::MOI.Utilities.Model</code> to a bridged model with a <code>MatrixOfConstraints</code>. For all the types that are not bridged, the constraints will be copied with <code>pass_nonvariable_constraints</code>. Hence the functions stored in <code>caches</code> are exactly the same as the ones stored in <code>src</code>. This is ok since this is only during the <code>copy_to</code> operation during which <code>src</code> cannot be modified. On the other hand, for the types that are bridged, the functions added may contain duplicates even if the functions did not contain duplicates in <code>src</code> so duplicates are removed with <code>MOI.Utilities.canonical</code>.</p><p><strong>Interface</strong></p><p>The <code>.coefficients::AT</code> type must implement:</p><ul><li><code>AT()</code></li><li><code>MOI.empty(::AT)!</code></li><li><a href="#MathOptInterface.Utilities.add_column"><code>MOI.Utilities.add_column</code></a></li><li><a href="#MathOptInterface.Utilities.set_number_of_rows"><code>MOI.Utilities.set_number_of_rows</code></a></li><li><a href="#MathOptInterface.Utilities.allocate_terms"><code>MOI.Utilities.allocate_terms</code></a></li><li><a href="#MathOptInterface.Utilities.load_terms"><code>MOI.Utilities.load_terms</code></a></li><li><a href="#MathOptInterface.Utilities.final_touch"><code>MOI.Utilities.final_touch</code></a></li></ul><p>The <code>.constants::BT</code> type must implement:</p><ul><li><code>BT()</code></li><li><code>Base.empty!(::BT)</code></li><li><code>Base.resize(::BT)</code></li><li><a href="#MathOptInterface.Utilities.load_constants"><code>MOI.Utilities.load_constants</code></a></li><li><a href="#MathOptInterface.Utilities.function_constants"><code>MOI.Utilities.function_constants</code></a></li><li><a href="#MathOptInterface.Utilities.set_from_constants"><code>MOI.Utilities.set_from_constants</code></a></li></ul><p>The <code>.sets::ST</code> type must implement:</p><ul><li><code>ST()</code></li><li><code>MOI.is_empty(::ST)</code></li><li><code>MOI.empty(::ST)</code></li><li><code>MOI.dimension(::ST)</code></li><li><code>MOI.is_valid(::ST, ::MOI.ConstraintIndex)</code></li><li><code>MOI.get(::ST, ::MOI.ListOfConstraintTypesPresent)</code></li><li><code>MOI.get(::ST, ::MOI.NumberOfConstraints)</code></li><li><code>MOI.get(::ST, ::MOI.ListOfConstraintIndices)</code></li><li><a href="#MathOptInterface.Utilities.set_types"><code>MOI.Utilities.set_types</code></a></li><li><a href="#MathOptInterface.Utilities.set_index"><code>MOI.Utilities.set_index</code></a></li><li><a href="#MathOptInterface.Utilities.add_set"><code>MOI.Utilities.add_set</code></a></li><li><a href="#MathOptInterface.Utilities.rows"><code>MOI.Utilities.rows</code></a></li><li><a href="#MathOptInterface.Utilities.final_touch"><code>MOI.Utilities.final_touch</code></a></li></ul></div></section></article><h3 id=".coefficients"><a class="docs-heading-anchor" href="#.coefficients"><code>.coefficients</code></a><a id=".coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#.coefficients" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.add_column" href="#MathOptInterface.Utilities.add_column"><code>MathOptInterface.Utilities.add_column</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_column(coefficients)::Nothing</code></pre><p>Tell <code>coefficients</code> to pre-allocate datastructures as needed to store one column.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.allocate_terms" href="#MathOptInterface.Utilities.allocate_terms"><code>MathOptInterface.Utilities.allocate_terms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">allocate_terms(coefficients, index_map, func)::Nothing</code></pre><p>Tell <code>coefficients</code> that the terms of the function <code>func</code> where the variable indices are mapped with <code>index_map</code> will be loaded with <a href="#MathOptInterface.Utilities.load_terms"><code>load_terms</code></a>.</p><p>The function <code>func</code> must be canonicalized before calling <code>allocate_terms</code>. See <a href="#MathOptInterface.Utilities.is_canonical"><code>is_canonical</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.set_number_of_rows" href="#MathOptInterface.Utilities.set_number_of_rows"><code>MathOptInterface.Utilities.set_number_of_rows</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_number_of_rows(coefficients, n)::Nothing</code></pre><p>Tell <code>coefficients</code> to pre-allocate datastructures as needed to store <code>n</code> rows.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.load_terms" href="#MathOptInterface.Utilities.load_terms"><code>MathOptInterface.Utilities.load_terms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_terms(coefficients, index_map, func, offset)::Nothing</code></pre><p>Loads the terms of <code>func</code> to <code>coefficients</code>, mapping the variable indices with <code>index_map</code>.</p><p>The <code>i</code>th dimension of <code>func</code> is loaded at the <code>(offset + i)</code>th row of <code>coefficients</code>.</p><p>The function must be allocated first with <a href="#MathOptInterface.Utilities.allocate_terms"><code>allocate_terms</code></a>.</p><p>The function <code>func</code> must be canonicalized, see <a href="#MathOptInterface.Utilities.is_canonical"><code>is_canonical</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.final_touch" href="#MathOptInterface.Utilities.final_touch"><code>MathOptInterface.Utilities.final_touch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">final_touch(coefficients)::Nothing</code></pre><p>Informs the <code>coefficients</code> that all functions have been added with <code>load_terms</code>. No more modification is allowed unless <code>MOI.empty!</code> is called.</p><pre><code class="nohighlight hljs">final_touch(sets)::Nothing</code></pre><p>Informs the <code>sets</code> that all functions have been added with <code>add_set</code>. No more modification is allowed unless <code>MOI.empty!</code> is called.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.extract_function" href="#MathOptInterface.Utilities.extract_function"><code>MathOptInterface.Utilities.extract_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_function(coefficients, row::Integer, constant::T) where {T}</code></pre><p>Return the <code>MOI.ScalarAffineFunction{T}</code> function corresponding to row <code>row</code> in <code>coefficients</code>.</p><pre><code class="nohighlight hljs">extract_function(
    coefficients,
    rows::UnitRange,
    constants::Vector{T},
) where{T}</code></pre><p>Return the <code>MOI.VectorAffineFunction{T}</code> function corresponding to rows <code>rows</code> in <code>coefficients</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.MutableSparseMatrixCSC" href="#MathOptInterface.Utilities.MutableSparseMatrixCSC"><code>MathOptInterface.Utilities.MutableSparseMatrixCSC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct MutableSparseMatrixCSC{Tv,Ti&lt;:Integer,I&lt;:AbstractIndexing}
    indexing::I
    m::Int
    n::Int
    colptr::Vector{Ti}
    rowval::Vector{Ti}
    nzval::Vector{Tv}
    nz_added::Vector{Ti}
end</code></pre><p>Matrix type loading sparse matrices in the Compressed Sparse Column format. The indexing used is <code>indexing</code>, see <a href="#MathOptInterface.Utilities.AbstractIndexing"><code>AbstractIndexing</code></a>. The other fields have the same meaning than for <code>SparseArrays.SparseMatrixCSC</code> except that the indexing is different unless <code>indexing</code> is <code>OneBasedIndexing</code>. In addition, <code>nz_added</code> is used to cache the number of non-zero terms that have been added to each column due to the incremental nature of <code>load_terms</code>.</p><p>The matrix is loaded in 5 steps:</p><ol><li><code>MOI.empty!</code> is called.</li><li><code>MOI.Utilities.add_column</code> and <code>MOI.Utilities.allocate_terms</code> are called in any order.</li><li><code>MOI.Utilities.set_number_of_rows</code> is called.</li><li><code>MOI.Utilities.load_terms</code> is called for each affine function.</li><li><code>MOI.Utilities.final_touch</code> is called.</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.AbstractIndexing" href="#MathOptInterface.Utilities.AbstractIndexing"><code>MathOptInterface.Utilities.AbstractIndexing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractIndexing end</code></pre><p>Indexing to be used for storing the row and column indices of <code>MutableSparseMatrixCSC</code>. See <a href="#MathOptInterface.Utilities.ZeroBasedIndexing"><code>ZeroBasedIndexing</code></a> and <a href="#MathOptInterface.Utilities.OneBasedIndexing"><code>OneBasedIndexing</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.ZeroBasedIndexing" href="#MathOptInterface.Utilities.ZeroBasedIndexing"><code>MathOptInterface.Utilities.ZeroBasedIndexing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ZeroBasedIndexing &lt;: AbstractIndexing end</code></pre><p>Zero-based indexing: the <code>i</code>th row or column has index <code>i - 1</code>. This is useful when the vectors of row and column indices need to be communicated to a library using zero-based indexing such as C libraries.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.OneBasedIndexing" href="#MathOptInterface.Utilities.OneBasedIndexing"><code>MathOptInterface.Utilities.OneBasedIndexing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ZeroBasedIndexing &lt;: AbstractIndexing end</code></pre><p>One-based indexing: the <code>i</code>th row or column has index <code>i</code>. This enables an allocation-free conversion of <a href="#MathOptInterface.Utilities.MutableSparseMatrixCSC"><code>MutableSparseMatrixCSC</code></a> to <code>SparseArrays.SparseMatrixCSC</code>.</p></div></section></article><h3 id=".constants"><a class="docs-heading-anchor" href="#.constants"><code>.constants</code></a><a id=".constants-1"></a><a class="docs-heading-anchor-permalink" href="#.constants" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.load_constants" href="#MathOptInterface.Utilities.load_constants"><code>MathOptInterface.Utilities.load_constants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_constants(constants, offset, func_or_set)::Nothing</code></pre><p>This function loads the constants of <code>func_or_set</code> in <code>constants</code> at an offset of <code>offset</code>. Where <code>offset</code> is the sum of the dimensions of the constraints already loaded. The storage should be preallocated with <code>resize!</code> before calling this function.</p><p>This function should be implemented to be usable as storage of constants for <a href="#MathOptInterface.Utilities.MatrixOfConstraints"><code>MatrixOfConstraints</code></a>.</p><p>The constants are loaded in three steps:</p><ol><li><code>Base.empty!</code> is called.</li><li><code>Base.resize!</code> is called with the sum of the dimensions of all constraints.</li><li><code>MOI.Utilities.load_constants</code> is called for each function for vector constraint or set for scalar constraint.</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.function_constants" href="#MathOptInterface.Utilities.function_constants"><code>MathOptInterface.Utilities.function_constants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function_constants(constants, rows)</code></pre><p>This function returns the function constants that were loaded with <a href="#MathOptInterface.Utilities.load_constants"><code>load_constants</code></a> at the rows <code>rows</code>.</p><p>This function should be implemented to be usable as storage of constants for <a href="#MathOptInterface.Utilities.MatrixOfConstraints"><code>MatrixOfConstraints</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.set_from_constants" href="#MathOptInterface.Utilities.set_from_constants"><code>MathOptInterface.Utilities.set_from_constants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_from_constants(constants, S::Type, rows)::S</code></pre><p>This function returns an instance of the set <code>S</code> for which the constants where loaded with <a href="#MathOptInterface.Utilities.load_constants"><code>load_constants</code></a> at the rows <code>rows</code>.</p><p>This function should be implemented to be usable as storage of constants for <a href="#MathOptInterface.Utilities.MatrixOfConstraints"><code>MatrixOfConstraints</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.Hyperrectangle" href="#MathOptInterface.Utilities.Hyperrectangle"><code>MathOptInterface.Utilities.Hyperrectangle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Hyperrectangle{T} &lt;: AbstractVectorBounds
    lower::Vector{T}
    upper::Vector{T}
end</code></pre><p>A struct for the .constants field in MatrixOfConstraints.</p></div></section></article><h3 id=".sets"><a class="docs-heading-anchor" href="#.sets"><code>.sets</code></a><a id=".sets-1"></a><a class="docs-heading-anchor-permalink" href="#.sets" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.set_index" href="#MathOptInterface.Utilities.set_index"><code>MathOptInterface.Utilities.set_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_index(sets, ::Type{S})::Union{Int,Nothing} where {S&lt;:MOI.AbstractSet}</code></pre><p>Return an integer corresponding to the index of the set type in the list given by <a href="#MathOptInterface.Utilities.set_types"><code>set_types</code></a>.</p><p>If <code>S</code> is not part of the list, return <code>nothing</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.set_types" href="#MathOptInterface.Utilities.set_types"><code>MathOptInterface.Utilities.set_types</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_types(sets)::Vector{Type}</code></pre><p>Return the list of the types of the sets allowed in <code>sets</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.add_set" href="#MathOptInterface.Utilities.add_set"><code>MathOptInterface.Utilities.add_set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_set(sets, i)::Int64</code></pre><p>Add a scalar set of type index <code>i</code>.</p><pre><code class="nohighlight hljs">add_set(sets, i, dim)::Int64</code></pre><p>Add a vector set of type index <code>i</code> and dimension <code>dim</code>.</p><p>Both methods return a unique <code>Int64</code> of the set that can be used to reference this set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.rows" href="#MathOptInterface.Utilities.rows"><code>MathOptInterface.Utilities.rows</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rows(sets, ci::MOI.ConstraintIndex)::Union{Int,UnitRange{Int}}</code></pre><p>Return the rows in <code>1:MOI.dimension(sets)</code> corresponding to the set of id <code>ci.value</code>.</p><p>For scalar sets, this returns an <code>Int</code>. For vector sets, this returns an <code>UnitRange{Int}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.num_rows" href="#MathOptInterface.Utilities.num_rows"><code>MathOptInterface.Utilities.num_rows</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_rows(sets::OrderedProductOfSets, ::Type{S}) where {S}</code></pre><p>Return the number of rows corresponding to a set of type <code>S</code>. That is, it is the sum of the dimensions of the sets of type <code>S</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.set_with_dimension" href="#MathOptInterface.Utilities.set_with_dimension"><code>MathOptInterface.Utilities.set_with_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_with_dimension(::Type{S}, dim) where {S&lt;:MOI.AbstractVectorSet}</code></pre><p>Returns the instance of <code>S</code> of <a href="../../../reference/standard_form/#MathOptInterface.dimension"><code>MOI.dimension</code></a> <code>dim</code>. This needs to be implemented for sets of type <code>S</code> to be useable with <a href="#MathOptInterface.Utilities.MatrixOfConstraints"><code>MatrixOfConstraints</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.ProductOfSets" href="#MathOptInterface.Utilities.ProductOfSets"><code>MathOptInterface.Utilities.ProductOfSets</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ProductOfSets{T} end</code></pre><p>Represents a cartesian product of sets of given types.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.MixOfScalarSets" href="#MathOptInterface.Utilities.MixOfScalarSets"><code>MathOptInterface.Utilities.MixOfScalarSets</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type MixOfScalarSets{T} &lt;: ProductOfSets{T} end</code></pre><p>Product of scalar sets in the order the constraints are added, mixing the constraints of different types.</p><p>Use <a href="#MathOptInterface.Utilities.@mix_of_scalar_sets"><code>@mix_of_scalar_sets</code></a> to generate a new subtype.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.@mix_of_scalar_sets" href="#MathOptInterface.Utilities.@mix_of_scalar_sets"><code>MathOptInterface.Utilities.@mix_of_scalar_sets</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@mix_of_scalar_sets(name, set_types...)</code></pre><p>Generate a new <a href="#MathOptInterface.Utilities.MixOfScalarSets"><code>MixOfScalarSets</code></a> subtype.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">@mix_of_scalar_sets(
    MixedIntegerLinearProgramSets,
    MOI.GreaterThan{T},
    MOI.LessThan{T},
    MOI.EqualTo{T},
    MOI.Integer,
)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.OrderedProductOfSets" href="#MathOptInterface.Utilities.OrderedProductOfSets"><code>MathOptInterface.Utilities.OrderedProductOfSets</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type OrderedProductOfSets{T} &lt;: ProductOfSets{T} end</code></pre><p>Product of sets in the order the constraints are added, grouping the constraints of the same types contiguously.</p><p>Use <a href="#MathOptInterface.Utilities.@product_of_sets"><code>@product_of_sets</code></a> to generate new subtypes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.@product_of_sets" href="#MathOptInterface.Utilities.@product_of_sets"><code>MathOptInterface.Utilities.@product_of_sets</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@product_of_sets(name, set_types...)</code></pre><p>Generate a new <a href="#MathOptInterface.Utilities.OrderedProductOfSets"><code>OrderedProductOfSets</code></a> subtype.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">@product_of_sets(
    LinearOrthants,
    MOI.Zeros,
    MOI.Nonnegatives,
    MOI.Nonpositives,
    MOI.ZeroOne,
)</code></pre></div></section></article><h2 id="Fallbacks"><a class="docs-heading-anchor" href="#Fallbacks">Fallbacks</a><a id="Fallbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Fallbacks" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.get_fallback" href="#MathOptInterface.Utilities.get_fallback"><code>MathOptInterface.Utilities.get_fallback</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_fallback(model::MOI.ModelLike, ::MOI.ObjectiveValue)</code></pre><p>Compute the objective function value using the <code>VariablePrimal</code> results and the <code>ObjectiveFunction</code> value.</p></div></section><section><div><pre><code class="language-julia hljs">get_fallback(model::MOI.ModelLike, ::MOI.DualObjectiveValue, T::Type)::T</code></pre><p>Compute the dual objective value of type <code>T</code> using the <code>ConstraintDual</code> results and the <code>ConstraintFunction</code> and <code>ConstraintSet</code> values. Note that the nonlinear part of the model is ignored.</p></div></section><section><div><pre><code class="language-julia hljs">get_fallback(model::MOI.ModelLike, ::MOI.ConstraintPrimal,
             constraint_index::MOI.ConstraintIndex)</code></pre><p>Compute the value of the function of the constraint of index <code>constraint_index</code> using the <code>VariablePrimal</code> results and the <code>ConstraintFunction</code> values.</p></div></section><section><div><pre><code class="language-julia hljs">get_fallback(model::MOI.ModelLike, attr::MOI.ConstraintDual,
             ci::MOI.ConstraintIndex{Union{MOI.VariableIndex,
                                           MOI.VectorOfVariables}})</code></pre><p>Compute the dual of the constraint of index <code>ci</code> using the <code>ConstraintDual</code> of other constraints and the <code>ConstraintFunction</code> values. Throws an error if some constraints are quadratic or if there is one another <code>MOI.VariableIndex</code>-in-<code>S</code> or <code>MOI.VectorOfVariables</code>-in-<code>S</code> constraint with one of the variables in the function of the constraint <code>ci</code>.</p></div></section></article><h2 id="Function-utilities"><a class="docs-heading-anchor" href="#Function-utilities">Function utilities</a><a id="Function-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Function-utilities" title="Permalink"></a></h2><p>The following utilities are available for functions:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.eval_variables" href="#MathOptInterface.Utilities.eval_variables"><code>MathOptInterface.Utilities.eval_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_variables(varval::Function, f::AbstractFunction)</code></pre><p>Returns the value of function <code>f</code> if each variable index <code>vi</code> is evaluated as <code>varval(vi)</code>. Note that <code>varval</code> should return a number, see <a href="#MathOptInterface.Utilities.substitute_variables"><code>substitute_variables</code></a> for a similar function where <code>varval</code> returns a function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.map_indices" href="#MathOptInterface.Utilities.map_indices"><code>MathOptInterface.Utilities.map_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">map_indices(index_map::Function, attr::MOI.AnyAttribute, x::X)::X where {X}</code></pre><p>Substitute any <a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> (resp. <a href="../../../reference/constraints/#MathOptInterface.ConstraintIndex"><code>MOI.ConstraintIndex</code></a>) in <code>x</code> by the <a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> (resp. <a href="../../../reference/constraints/#MathOptInterface.ConstraintIndex"><code>MOI.ConstraintIndex</code></a>) of the same type given by <code>index_map(x)</code>.</p><p><strong>When to implement this method for new types <code>X</code></strong></p><p>This function is used by implementations of <a href="../../../reference/models/#MathOptInterface.copy_to"><code>MOI.copy_to</code></a> on constraint functions, attribute values and submittable values. If you define a new attribute whose values <code>x::X</code> contain variable or constraint indices, you must also implement this function.</p></div></section><section><div><pre><code class="language-julia hljs">map_indices(
    variable_map::AbstractDict{T,T},
    x::X,
)::X where {T&lt;:MOI.Index,X}</code></pre><p>Shortcut for <code>map_indices(vi -&gt; variable_map[vi], x)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.substitute_variables" href="#MathOptInterface.Utilities.substitute_variables"><code>MathOptInterface.Utilities.substitute_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">substitute_variables(variable_map::Function, x)</code></pre><p>Substitute any <a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <code>x</code> by <code>variable_map(x)</code>. The <code>variable_map</code> function returns either <a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> or <a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction</code></a>, see <a href="#MathOptInterface.Utilities.eval_variables"><code>eval_variables</code></a> for a similar function where <code>variable_map</code> returns a number.</p><p>This function is used by bridge optimizers on constraint functions, attribute values and submittable values when at least one variable bridge is used hence it needs to be implemented for custom types that are meant to be used as attribute or submittable value.</p><p>WARNING: Don&#39;t use <code>substitude_variables(::Function, ...)</code> because Julia will not specialize on this. Use instead <code>substitude_variables(::F, ...) where {F&lt;:Function}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.filter_variables" href="#MathOptInterface.Utilities.filter_variables"><code>MathOptInterface.Utilities.filter_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filter_variables(keep::Function, f::AbstractFunction)</code></pre><p>Return a new function <code>f</code> with the variable <code>vi</code> such that <code>!keep(vi)</code> removed.</p><p>WARNING: Don&#39;t define <code>filter_variables(::Function, ...)</code> because Julia will not specialize on this. Define instead <code>filter_variables(::F, ...) where {F&lt;:Function}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.remove_variable" href="#MathOptInterface.Utilities.remove_variable"><code>MathOptInterface.Utilities.remove_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remove_variable(f::AbstractFunction, vi::VariableIndex)</code></pre><p>Return a new function <code>f</code> with the variable vi removed.</p></div></section><section><div><pre><code class="language-julia hljs">remove_variable(f::MOI.AbstractFunction, s::MOI.AbstractSet, vi::MOI.VariableIndex)</code></pre><p>Return a tuple <code>(g, t)</code> representing the constraint <code>f</code>-in-<code>s</code> with the variable <code>vi</code> removed. That is, the terms containing the variable <code>vi</code> in the function <code>f</code> are removed and the dimension of the set <code>s</code> is updated if needed (e.g. when <code>f</code> is a <code>VectorOfVariables</code> with <code>vi</code> being one of the variables).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.all_coefficients" href="#MathOptInterface.Utilities.all_coefficients"><code>MathOptInterface.Utilities.all_coefficients</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">all_coefficients(p::Function, f::MOI.AbstractFunction)</code></pre><p>Determine whether predicate <code>p</code> returns <code>true</code> for all coefficients of <code>f</code>, returning <code>false</code> as soon as the first coefficient of <code>f</code> for which <code>p</code> returns <code>false</code> is encountered (short-circuiting). Similar to <code>all</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.unsafe_add" href="#MathOptInterface.Utilities.unsafe_add"><code>MathOptInterface.Utilities.unsafe_add</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_add(t1::MOI.ScalarAffineTerm, t2::MOI.ScalarAffineTerm)</code></pre><p>Sums the coefficients of <code>t1</code> and <code>t2</code> and returns an output <code>MOI.ScalarAffineTerm</code>. It is unsafe because it uses the <code>variable</code> of <code>t1</code> as the <code>variable</code> of the output without checking that it is equal to that of <code>t2</code>.</p></div></section><section><div><pre><code class="language-julia hljs">unsafe_add(t1::MOI.ScalarQuadraticTerm, t2::MOI.ScalarQuadraticTerm)</code></pre><p>Sums the coefficients of <code>t1</code> and <code>t2</code> and returns an output <code>MOI.ScalarQuadraticTerm</code>. It is unsafe because it uses the <code>variable</code>&#39;s of <code>t1</code> as the <code>variable</code>&#39;s of the output without checking that they are the same (up to permutation) to those of <code>t2</code>.</p></div></section><section><div><pre><code class="language-julia hljs">unsafe_add(t1::MOI.VectorAffineTerm, t2::MOI.VectorAffineTerm)</code></pre><p>Sums the coefficients of <code>t1</code> and <code>t2</code> and returns an output <code>MOI.VectorAffineTerm</code>. It is unsafe because it uses the <code>output_index</code> and <code>variable</code> of <code>t1</code> as the <code>output_index</code> and <code>variable</code> of the output term without checking that they are equal to those of <code>t2</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.isapprox_zero" href="#MathOptInterface.Utilities.isapprox_zero"><code>MathOptInterface.Utilities.isapprox_zero</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isapprox_zero(f::MOI.AbstractFunction, tol)</code></pre><p>Return a <code>Bool</code> indicating whether the function <code>f</code> is approximately zero using <code>tol</code> as a tolerance.</p><p><strong>Important note</strong></p><p>This function assumes that <code>f</code> does not contain any duplicate terms, you might want to first call <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a> if that is not guaranteed. For instance, given</p><pre><code class="language-julia hljs">f = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([1, -1], [x, x]), 0)</code></pre><p>then <code>isapprox_zero(f)</code> is <code>false</code> but <code>isapprox_zero(MOIU.canonical(f))</code> is <code>true</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.modify_function" href="#MathOptInterface.Utilities.modify_function"><code>MathOptInterface.Utilities.modify_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modify_function(f::AbstractFunction, change::AbstractFunctionModification)</code></pre><p>Return a copy of the function <code>f</code>, modified according to <code>change</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.zero_with_output_dimension" href="#MathOptInterface.Utilities.zero_with_output_dimension"><code>MathOptInterface.Utilities.zero_with_output_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zero_with_output_dimension(::Type{T}, output_dimension::Integer) where {T}</code></pre><p>Create an instance of type <code>T</code> with the output dimension <code>output_dimension</code>.</p><p>This is mostly useful in Bridges, when code needs to be agnostic to the type of vector-valued function that is passed in.</p></div></section></article><p>The following functions can be used to canonicalize a function:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.is_canonical" href="#MathOptInterface.Utilities.is_canonical"><code>MathOptInterface.Utilities.is_canonical</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_canonical(f::Union{ScalarAffineFunction, VectorAffineFunction})</code></pre><p>Returns a Bool indicating whether the function is in canonical form. See <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a>.</p></div></section><section><div><pre><code class="language-julia hljs">is_canonical(f::Union{ScalarQuadraticFunction, VectorQuadraticFunction})</code></pre><p>Returns a Bool indicating whether the function is in canonical form. See <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.canonical" href="#MathOptInterface.Utilities.canonical"><code>MathOptInterface.Utilities.canonical</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">canonical(
    f::Union{
        ScalarAffineFunction,
        VectorAffineFunction,
        ScalarQuadraticFunction,
        VectorQuadraticFunction,
    },
)</code></pre><p>Returns the function in a canonical form, i.e.</p><ul><li>A term appear only once.</li><li>The coefficients are nonzero.</li><li>The terms appear in increasing order of variable where there the order of the variables is the order of their value.</li><li>For a <code>AbstractVectorFunction</code>, the terms are sorted in ascending order of output index.</li></ul><p>The output of <code>canonical</code> can be assumed to be a copy of <code>f</code>, even for <code>VectorOfVariables</code>.</p><p><strong>Examples</strong></p><p>If <code>x</code> (resp. <code>y</code>, <code>z</code>) is <code>VariableIndex(1)</code> (resp. 2, 3). The canonical representation of <code>ScalarAffineFunction([y, x, z, x, z], [2, 1, 3, -2, -3], 5)</code> is <code>ScalarAffineFunction([x, y], [-1, 2], 5)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.canonicalize!" href="#MathOptInterface.Utilities.canonicalize!"><code>MathOptInterface.Utilities.canonicalize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">canonicalize!(f::Union{ScalarAffineFunction, VectorAffineFunction})</code></pre><p>Convert a function to canonical form in-place, without allocating a copy to hold the result. See <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a>.</p></div></section><section><div><pre><code class="language-julia hljs">canonicalize!(f::Union{ScalarQuadraticFunction, VectorQuadraticFunction})</code></pre><p>Convert a function to canonical form in-place, without allocating a copy to hold the result. See <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a>.</p></div></section></article><p>The following functions can be used to manipulate functions with basic algebra:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.scalar_type" href="#MathOptInterface.Utilities.scalar_type"><code>MathOptInterface.Utilities.scalar_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scalar_type(F::Type{&lt;:MOI.AbstractVectorFunction})</code></pre><p>Type of functions obtained by indexing objects obtained by calling <code>eachscalar</code> on functions of type <code>F</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.scalarize" href="#MathOptInterface.Utilities.scalarize"><code>MathOptInterface.Utilities.scalarize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scalarize(func::MOI.VectorOfVariables, ignore_constants::Bool = false)</code></pre><p>Returns a vector of scalar functions making up the vector function in the form of a <code>Vector{MOI.SingleVariable}</code>.</p><p>See also <a href="#MathOptInterface.Utilities.eachscalar"><code>eachscalar</code></a>.</p></div></section><section><div><pre><code class="language-julia hljs">scalarize(func::MOI.VectorAffineFunction{T}, ignore_constants::Bool = false)</code></pre><p>Returns a vector of scalar functions making up the vector function in the form of a <code>Vector{MOI.ScalarAffineFunction{T}}</code>.</p><p>See also <a href="#MathOptInterface.Utilities.eachscalar"><code>eachscalar</code></a>.</p></div></section><section><div><pre><code class="language-julia hljs">scalarize(func::MOI.VectorQuadraticFunction{T}, ignore_constants::Bool = false)</code></pre><p>Returns a vector of scalar functions making up the vector function in the form of a <code>Vector{MOI.ScalarQuadraticFunction{T}}</code>.</p><p>See also <a href="#MathOptInterface.Utilities.eachscalar"><code>eachscalar</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.eachscalar" href="#MathOptInterface.Utilities.eachscalar"><code>MathOptInterface.Utilities.eachscalar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eachscalar(f::MOI.AbstractVectorFunction)</code></pre><p>Returns an iterator for the scalar components of the vector function.</p><p>See also <a href="#MathOptInterface.Utilities.scalarize"><code>scalarize</code></a>.</p></div></section><section><div><pre><code class="language-julia hljs">eachscalar(f::MOI.AbstractVector)</code></pre><p>Returns an iterator for the scalar components of the vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.promote_operation" href="#MathOptInterface.Utilities.promote_operation"><code>MathOptInterface.Utilities.promote_operation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">promote_operation(
    op::Function,
    ::Type{T},
    ArgsTypes::Type{&lt;:Union{T, MOI.AbstractFunction}}...,
) where {T}</code></pre><p>Returns the type of the <code>MOI.AbstractFunction</code> returned to the call <code>operate(op, T, args...)</code> where the types of the arguments <code>args</code> are <code>ArgsTypes</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.operate" href="#MathOptInterface.Utilities.operate"><code>MathOptInterface.Utilities.operate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">operate(
    op::Function,
    ::Type{T},
    args::Union{T,MOI.AbstractFunction}...,
)::MOI.AbstractFunction where {T}</code></pre><p>Returns an <code>MOI.AbstractFunction</code> representing the function resulting from the operation <code>op(args...)</code> on functions of coefficient type <code>T</code>. No argument can be modified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.operate!" href="#MathOptInterface.Utilities.operate!"><code>MathOptInterface.Utilities.operate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">operate!(
    op::Function,
    ::Type{T},
    args::Union{T, MOI.AbstractFunction}...,
)::MOI.AbstractFunction where {T}</code></pre><p>Returns an <code>MOI.AbstractFunction</code> representing the function resulting from the operation <code>op(args...)</code> on functions of coefficient type <code>T</code>. The first argument can be modified. The return type is the same than the method <code>operate(op, T, args...)</code> without <code>!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.operate_output_index!" href="#MathOptInterface.Utilities.operate_output_index!"><code>MathOptInterface.Utilities.operate_output_index!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">operate_output_index!(
    op::Function,
    ::Type{T},
    output_index::Integer,
    func::MOI.AbstractVectorFunction
    args::Union{T, MOI.AbstractScalarFunction}...
)::MOI.AbstractFunction where {T}</code></pre><p>Returns an <code>MOI.AbstractVectorFunction</code> where the function at <code>output_index</code> is the result of the operation <code>op</code> applied to the function at <code>output_index</code> of <code>func</code> and <code>args</code>. The functions at output index different to <code>output_index</code> are the same as the functions at the same output index in <code>func</code>. The first argument can be modified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.vectorize" href="#MathOptInterface.Utilities.vectorize"><code>MathOptInterface.Utilities.vectorize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vectorize(x::AbstractVector{&lt;:Number})</code></pre><p>Returns <code>x</code>.</p></div></section><section><div><pre><code class="language-julia hljs">vectorize(x::AbstractVector{MOI.VariableIndex})</code></pre><p>Returns the vector of scalar affine functions in the form of a <code>MOI.VectorAffineFunction{T}</code>.</p></div></section><section><div><pre><code class="language-julia hljs">vectorize(funcs::AbstractVector{MOI.ScalarAffineFunction{T}}) where T</code></pre><p>Returns the vector of scalar affine functions in the form of a <code>MOI.VectorAffineFunction{T}</code>.</p></div></section><section><div><pre><code class="language-julia hljs">vectorize(funcs::AbstractVector{MOI.ScalarQuadraticFunction{T}}) where T</code></pre><p>Returns the vector of scalar quadratic functions in the form of a <code>MOI.VectorQuadraticFunction{T}</code>.</p></div></section></article><h2 id="Constraint-utilities"><a class="docs-heading-anchor" href="#Constraint-utilities">Constraint utilities</a><a id="Constraint-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-utilities" title="Permalink"></a></h2><p>The following utilities are available for moving the function constant to the set for scalar constraints:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.shift_constant" href="#MathOptInterface.Utilities.shift_constant"><code>MathOptInterface.Utilities.shift_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shift_constant(set::MOI.AbstractScalarSet, offset)</code></pre><p>Returns a new scalar set <code>new_set</code> such that <code>func</code>-in-<code>set</code> is equivalent to <code>func + offset</code>-in-<code>new_set</code>.</p><p>Only define this function if it makes sense to!</p><p>Use <a href="#MathOptInterface.Utilities.supports_shift_constant"><code>supports_shift_constant</code></a> to check if the set supports shifting:</p><pre><code class="language-Julia hljs">if supports_shift_constant(typeof(old_set))
    new_set = shift_constant(old_set, offset)
    f.constant = 0
    add_constraint(model, f, new_set)
else
    add_constraint(model, f, old_set)
end</code></pre><p>See also <a href="#MathOptInterface.Utilities.supports_shift_constant"><code>supports_shift_constant</code></a>.</p><p><strong>Examples</strong></p><p>The call <code>shift_constant(MOI.Interval(-2, 3), 1)</code> is equal to <code>MOI.Interval(-1, 4)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.supports_shift_constant" href="#MathOptInterface.Utilities.supports_shift_constant"><code>MathOptInterface.Utilities.supports_shift_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">supports_shift_constant(::Type{S}) where {S&lt;:MOI.AbstractSet}</code></pre><p>Return <code>true</code> if <a href="#MathOptInterface.Utilities.shift_constant"><code>shift_constant</code></a> is defined for set <code>S</code>.</p><p>See also <a href="#MathOptInterface.Utilities.shift_constant"><code>shift_constant</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.normalize_and_add_constraint" href="#MathOptInterface.Utilities.normalize_and_add_constraint"><code>MathOptInterface.Utilities.normalize_and_add_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_and_add_constraint(
    model::MOI.ModelLike,
    func::MOI.AbstractScalarFunction,
    set::MOI.AbstractScalarSet;
    allow_modify_function::Bool = false,
)</code></pre><p>Adds the scalar constraint obtained by moving the constant term in <code>func</code> to the set in <code>model</code>. If <code>allow_modify_function</code> is <code>true</code> then the function <code>func</code> can be modified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.normalize_constant" href="#MathOptInterface.Utilities.normalize_constant"><code>MathOptInterface.Utilities.normalize_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_constant(
    func::MOI.AbstractScalarFunction,
    set::MOI.AbstractScalarSet;
    allow_modify_function::Bool = false,
)</code></pre><p>Return the <code>func</code>-in-<code>set</code> constraint in normalized form. That is, if <code>func</code> is <a href="../../../reference/standard_form/#MathOptInterface.ScalarQuadraticFunction"><code>MOI.ScalarQuadraticFunction</code></a> or <a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction</code></a>, the constant is moved to the set. If <code>allow_modify_function</code> is <code>true</code> then the function <code>func</code> can be modified.</p></div></section></article><p>The following utility identifies those constraints imposing bounds on a given variable, and returns those bound values:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.get_bounds" href="#MathOptInterface.Utilities.get_bounds"><code>MathOptInterface.Utilities.get_bounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_bounds(model::MOI.ModelLike, ::Type{T}, x::MOI.VariableIndex)</code></pre><p>Return a tuple <code>(lb, ub)</code> of type <code>Tuple{T, T}</code>, where <code>lb</code> and <code>ub</code> are lower  and upper bounds, respectively, imposed on <code>x</code> in <code>model</code>.</p></div></section></article><p>The following utilities are useful when working with symmetric matrix cones.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.is_diagonal_vectorized_index" href="#MathOptInterface.Utilities.is_diagonal_vectorized_index"><code>MathOptInterface.Utilities.is_diagonal_vectorized_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_diagonal_vectorized_index(index::Base.Integer)</code></pre><p>Return whether <code>index</code> is the index of a diagonal element in a <a href="../../../reference/standard_form/#MathOptInterface.AbstractSymmetricMatrixSetTriangle"><code>MOI.AbstractSymmetricMatrixSetTriangle</code></a> set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.side_dimension_for_vectorized_dimension" href="#MathOptInterface.Utilities.side_dimension_for_vectorized_dimension"><code>MathOptInterface.Utilities.side_dimension_for_vectorized_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">side_dimension_for_vectorized_dimension(n::Integer)</code></pre><p>Return the dimension <code>d</code> such that <code>MOI.dimension(MOI.PositiveSemidefiniteConeTriangle(d))</code> is <code>n</code>.</p></div></section></article><h2 id="Set-utilities"><a class="docs-heading-anchor" href="#Set-utilities">Set utilities</a><a id="Set-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Set-utilities" title="Permalink"></a></h2><p>The following utilities are available for sets:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.AbstractDistance" href="#MathOptInterface.Utilities.AbstractDistance"><code>MathOptInterface.Utilities.AbstractDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractDistance end</code></pre><p>An abstract type used to enabble dispatch of <a href="#MathOptInterface.Utilities.distance_to_set"><code>Utilities.distance_to_set</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.ProjectionUpperBoundDistance" href="#MathOptInterface.Utilities.ProjectionUpperBoundDistance"><code>MathOptInterface.Utilities.ProjectionUpperBoundDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProjectionUpperBoundDistance() &lt;: AbstractDistance</code></pre><p>An upper bound on the minimum distance between <code>point</code> and the closest feasible point in <code>set</code>.</p><p><strong>Definition of distance</strong></p><p>The minimum distance is computed as:</p><p class="math-container">\[d(x, \mathcal{K}) = \min_{y \in \mathcal{K}} || x - y ||\]</p><p>where <span>$x$</span> is <code>point</code> and <span>$\mathcal{K}$</span> is <code>set</code>. The norm is computed as:</p><p class="math-container">\[||x|| = \sqrt{f(x, x, \mathcal{K})}\]</p><p>where <span>$f$</span> is <a href="#MathOptInterface.Utilities.set_dot"><code>Utilities.set_dot</code></a>.</p><p>In the default case, where the set does not have a specialized method for <a href="#MathOptInterface.Utilities.set_dot"><code>Utilities.set_dot</code></a>, the norm is equivalent to the Euclidean norm <span>$||x|| = \sqrt{\sum x_i^2}$</span>.</p><p><strong>Why an upper bound?</strong></p><p>In most cases, <code>distance_to_set</code> should return the smallest upper bound, but it may return a larger value if the smallest upper bound is expensive to compute.</p><p>For example, given an epigraph from of a conic set, <span>$\{(t, x) | f(x) \le t\}$</span>, it may be simpler to return <span>$\delta$</span> such that <span>$f(x) \le t + \delta$</span>, rather than computing the nearest projection onto the set.</p><p>If the distance is not the smallest upper bound, the docstring of the appropriate <code>distance_to_set</code> method <em>must</em> describe the way that the distance is computed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.distance_to_set" href="#MathOptInterface.Utilities.distance_to_set"><code>MathOptInterface.Utilities.distance_to_set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distance_to_set(
    [d::AbstractDistance = ProjectionUpperBoundDistance()],]
    point::T,
    set::MOI.AbstractScalarSet,
) where {T}

distance_to_set(
    [d::AbstractDistance = ProjectionUpperBoundDistance(),]
    point::AbstractVector{T},
    set::MOI.AbstractVectorSet,
) where {T}</code></pre><p>Compute the distance between <code>point</code> and <code>set</code> using the distance metric <code>d</code>. If <code>point</code> is in the set <code>set</code>, this function <em>must</em> return <code>zero(T)</code>.</p><p>If <code>d</code> is omitted, the default distance is <a href="#MathOptInterface.Utilities.ProjectionUpperBoundDistance"><code>Utilities.ProjectionUpperBoundDistance</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.set_dot" href="#MathOptInterface.Utilities.set_dot"><code>MathOptInterface.Utilities.set_dot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_dot(x::AbstractVector, y::AbstractVector, set::AbstractVectorSet)</code></pre><p>Return the scalar product between a vector <code>x</code> of the set <code>set</code> and a vector <code>y</code> of the dual of the set <code>s</code>.</p></div></section><section><div><pre><code class="language-julia hljs">set_dot(x, y, set::AbstractScalarSet)</code></pre><p>Return the scalar product between a number <code>x</code> of the set <code>set</code> and a number <code>y</code> of the dual of the set <code>s</code>.</p></div></section></article><h2 id="DoubleDicts"><a class="docs-heading-anchor" href="#DoubleDicts">DoubleDicts</a><a id="DoubleDicts-1"></a><a class="docs-heading-anchor-permalink" href="#DoubleDicts" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.DoubleDicts.DoubleDict" href="#MathOptInterface.Utilities.DoubleDicts.DoubleDict"><code>MathOptInterface.Utilities.DoubleDicts.DoubleDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DoubleDict{V}</code></pre><p>An optimized dictionary to map <code>MOI.ConstraintIndex</code> to values of type <code>V</code>.</p><p>Works as a <code>AbstractDict{MOI.ConstraintIndex,V}</code> with minimal differences.</p><p>If <code>V</code> is also a <code>MOI.ConstraintIndex</code>, use <a href="#MathOptInterface.Utilities.DoubleDicts.IndexDoubleDict"><code>IndexDoubleDict</code></a>.</p><p>Note that <code>MOI.ConstraintIndex</code> is not a concrete type, opposed to <code>MOI.ConstraintIndex{MOI.VariableIndex, MOI.Integers}</code>, which is a concrete type.</p><p>When looping through multiple keys of the same Function-in-Set type, use</p><pre><code class="language-julia hljs">inner = dict[F, S]</code></pre><p>to return a type-stable <a href="#MathOptInterface.Utilities.DoubleDicts.DoubleDictInner"><code>DoubleDictInner</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.DoubleDicts.DoubleDictInner" href="#MathOptInterface.Utilities.DoubleDicts.DoubleDictInner"><code>MathOptInterface.Utilities.DoubleDicts.DoubleDictInner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DoubleDictInner{F,S,V}</code></pre><p>A type stable inner dictionary of <a href="#MathOptInterface.Utilities.DoubleDicts.DoubleDict"><code>DoubleDict</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.DoubleDicts.IndexDoubleDict" href="#MathOptInterface.Utilities.DoubleDicts.IndexDoubleDict"><code>MathOptInterface.Utilities.DoubleDicts.IndexDoubleDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndexDoubleDict</code></pre><p>A specialized version of [<code>DoubleDict</code>] in which the values are of type <code>MOI.ConstraintIndex</code></p><p>When looping through multiple keys of the same Function-in-Set type, use</p><pre><code class="language-julia hljs">inner = dict[F, S]</code></pre><p>to return a type-stable <a href="#MathOptInterface.Utilities.DoubleDicts.IndexDoubleDictInner"><code>IndexDoubleDictInner</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.DoubleDicts.IndexDoubleDictInner" href="#MathOptInterface.Utilities.DoubleDicts.IndexDoubleDictInner"><code>MathOptInterface.Utilities.DoubleDicts.IndexDoubleDictInner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndexDoubleDictInner{F,S}</code></pre><p>A type stable inner dictionary of <a href="#MathOptInterface.Utilities.DoubleDicts.IndexDoubleDict"><code>IndexDoubleDict</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.DoubleDicts.outer_keys" href="#MathOptInterface.Utilities.DoubleDicts.outer_keys"><code>MathOptInterface.Utilities.DoubleDicts.outer_keys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outer_keys(d::AbstractDoubleDict)</code></pre><p>Return an iterator over the outer keys of the <code>AbstractDoubleDict</code> <code>d</code>. Each outer key is a <code>Tuple{Type,Type}</code> so that a double loop can be easily used:</p><pre><code class="language-julia hljs">for (F, S) in DoubleDicts.outer_keys(dict)
    for (k, v) in dict[F, S]
        # ...
    end
end</code></pre><p>For performance, it is recommended that the inner loop lies in a separate function to gurantee type-stability. Some outer keys <code>(F, S)</code> might lead to an empty <code>dict[F, S]</code>. If you want only nonempty <code>dict[F, S]</code>, use <a href="#MathOptInterface.Utilities.DoubleDicts.nonempty_outer_keys"><code>nonempty_outer_keys</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.DoubleDicts.nonempty_outer_keys" href="#MathOptInterface.Utilities.DoubleDicts.nonempty_outer_keys"><code>MathOptInterface.Utilities.DoubleDicts.nonempty_outer_keys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nonempty_outer_keys(d::AbstractDoubleDict)</code></pre><p>Return a vector of outer keys of the <code>AbstractDoubleDict</code> <code>d</code>.</p><p>Only outer keys that have a nonempty set of inner keys will be returned.</p><p>Each outer key is a <code>Tuple{Type,Type}</code> so that a double loop can be easily used</p><pre><code class="language-julia hljs">for (F, S) in DoubleDicts.nonempty_outer_keys(dict)
    for (k, v) in dict[F, S]
        # ...
    end
end
For performance, it is recommended that the inner loop lies in a separate
function to gurantee type-stability.

If you want an iterator of all current outer keys, use [`outer_keys`](@ref).</code></pre></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview/">« Overview</a><a class="docs-footer-nextpage" href="../../Test/overview/">Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Wednesday 3 May 2023 03:42">Wednesday 3 May 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
