<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Query Solutions · JuMP</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><a href="../index.html"><img alt="JuMP logo" class="logo" src="../assets/logo.png"/></a><h1>JuMP</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search/" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../installation/">Installation Guide</a></li><li><a class="toctext" href="../quickstart/">Quick Start Guide</a></li><li><a class="toctext" href="../variables/">Variables</a></li><li><a class="toctext" href="../expressions/">Expressions</a></li><li><a class="toctext" href="../objective/">Objective</a></li><li><a class="toctext" href="../constraints/">Constraints</a></li><li><a class="toctext" href="../containers/">Containers</a></li><li><a class="toctext" href="../solvers/">Solvers</a></li><li class="current"><a class="toctext" href="">Query Solutions</a><ul class="internal"><li><a class="toctext" href="#Termination-statuses-1">Termination statuses</a></li><li><a class="toctext" href="#Solution-statuses-1">Solution statuses</a></li><li><a class="toctext" href="#Obtaining-solutions-1">Obtaining solutions</a></li><li><a class="toctext" href="#Reference-1">Reference</a></li></ul></li><li><a class="toctext" href="../nlp/">Nonlinear Modeling</a></li><li><a class="toctext" href="../style/">Style Guide</a></li><li><a class="toctext" href="../extensions/">Extensions</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="">Query Solutions</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/JuMP.jl/blob/master/docs/src/solutions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Query Solutions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Querying-Solutions-1" id="Querying-Solutions-1">Querying Solutions</a></h1><p>So far we have seen all the elements and constructs related to writing a JuMP optimization model. In this section we reach the point of what to do with a solved problem. Suppose your model is named <code>model</code>. Right after the call to <code>optimize!(model)</code>, it's natural to ask JuMP questions about the finished optimization step. Typical questions include:</p><ul><li>Why has the optimization process stopped? Did it hit the time limit or run into numerical issues?</li><li>Do I have a solution to my problem?</li><li>Is it optimal?</li><li>Do I have a dual solution?</li></ul><p>JuMP follows closely the concepts defined in <a href="https://github.com/JuliaOpt/MathOptInterface.jl">MathOptInterface (MOI)</a> to answer user questions about a finished call to <code>optimize!(model)</code>. There are three main steps in querying a solution:</p><p>First, we can query the <a href="#JuMP.termination_status"><code>termination_status</code></a> which will tell us why the optimization stopped. This could be due to a number of reasons. For example, the solver found an optimal solution, the problem was proven to be infeasible, or a user-provided limit such as a time limit was encountered. For more information, see the <a href="#Termination-statuses-1">Termination statuses</a> section below.</p><p>Second, we can query the <a href="#JuMP.primal_status"><code>primal_status</code></a> and the <a href="#JuMP.dual_status"><code>dual_status</code></a>, which will tell us what kind of results we have for our primal and dual solutions. This might be an optimal primal-dual pair, a primal solution without  a corresponding dual solution, or a certificate of primal or dual infeasibility. For more information, see the <a href="#Solution-statuses-1">Solution statuses</a> section below.</p><p>Third, we can query <a href="#JuMP.value"><code>value</code></a> and <a href="#JuMP.dual"><code>dual</code></a> to obtain the primal and dual values of the optimization variables and constraints (if there are values to be queried).</p><h2><a class="nav-anchor" href="#Termination-statuses-1" id="Termination-statuses-1">Termination statuses</a></h2><p>The reason why the optimization of <code>model</code> was finished is given by</p><pre><code class="language-julia">termination_status(model)</code></pre><p>This function will return a <code>MOI.TerminationStatusCode</code><code>enum</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#MathOptInterface.TerminationStatusCode" id="MathOptInterface.TerminationStatusCode"><code>MathOptInterface.TerminationStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TerminationStatusCode</code></pre><p>An Enum of possible values for the <code>TerminationStatus</code> attribute. This attribute is meant to explain the reason why the optimizer stopped executing in the most recent call to <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>.</p><p>If no call has been made to <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>, then the <code>TerminationStatus</code> is:</p><ul><li><code>OPTIMIZE_NOT_CALLED</code>: The algorithm has not started.</li></ul><p><strong>OK</strong></p><p>These are generally OK statuses, i.e., the algorithm ran to completion normally.</p><ul><li><code>OPTIMAL</code>: The algorithm found a globally optimal solution.</li><li><code>INFEASIBLE</code>: The algorithm concluded that no feasible solution exists.</li><li><code>DUAL_INFEASIBLE</code>: The algorithm concluded that no dual bound exists for the problem. If, additionally, a feasible (primal) solution is known to exist, this status typically implies that the problem is unbounded, with some technical exceptions.</li><li><code>LOCALLY_SOLVED</code>: The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.</li><li><code>LOCALLY_INFEASIBLE</code>: The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.</li><li><code>INFEASIBLE_OR_UNBOUNDED</code>: The algorithm stopped because it decided that the problem is infeasible or unbounded; this occasionally happens during MIP presolve.</li></ul><p><strong>Solved to relaxed tolerances</strong></p><ul><li><code>ALMOST_OPTIMAL</code>: The algorithm found a globally optimal solution to relaxed tolerances.</li><li><code>ALMOST_INFEASIBLE</code>: The algorithm concluded that no feasible solution exists within relaxed tolerances.</li><li><code>ALMOST_DUAL_INFEASIBLE</code>: The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.</li><li><code>ALMOST_LOCALLY_SOLVED</code>: The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.</li></ul><p><strong>Limits</strong></p><p>The optimizer stopped because of some user-defined limit.</p><ul><li><code>ITERATION_LIMIT</code>: An iterative algorithm stopped after conducting the maximum number of iterations.</li><li><code>TIME_LIMIT</code>: The algorithm stopped after a user-specified computation time.</li><li><code>NODE_LIMIT</code>: A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.</li><li><code>SOLUTION_LIMIT</code>: The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.</li><li><code>MEMORY_LIMIT</code>: The algorithm stopped because it ran out of memory.</li><li><code>OBJECTIVE_LIMIT</code>: The algorthm stopped because it found a solution better than a minimum limit set by the user.</li><li><code>NORM_LIMIT</code>: The algorithm stopped because the norm of an iterate became too large.</li><li><code>OTHER_LIMIT</code>: The algorithm stopped due to a limit not covered by one of the above.</li></ul><p><strong>Problematic</strong></p><p>This group of statuses means that something unexpected or problematic happened.</p><ul><li><code>SLOW_PROGRESS</code>: The algorithm stopped because it was unable to continue making progress towards the solution.</li><li><code>NUMERICAL_ERROR</code>: The algorithm stopped because it encountered unrecoverable numerical error.</li><li><code>INVALID_MODEL</code>: The algorithm stopped because the model is invalid.</li><li><code>INVALID_OPTION</code>: The algorithm stopped because it was provided an invalid option.</li><li><code>INTERRUPTED</code>: The algorithm stopped because of an interrupt signal.</li><li><code>OTHER_ERROR</code>: The algorithm stopped because of an error not covered by one of the statuses defined above.</li></ul></div></div><a class="source-link" href="https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/#L0-L78" target="_blank">source</a></section><h2><a class="nav-anchor" href="#Solution-statuses-1" id="Solution-statuses-1">Solution statuses</a></h2><p>These statuses indicate what kind of result is available to be queried with <a href="#JuMP.value"><code>value</code></a> and <a href="#JuMP.dual"><code>dual</code></a>. It's possible that no result is available to be queried.</p><p>We can obtain these statuses by calling <a href="#JuMP.primal_status"><code>primal_status</code></a> for the primal status, and <a href="#JuMP.dual_status"><code>dual_status</code></a> for the dual status. Both will return a <code>MOI.ResultStatusCode</code><code>enum</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#MathOptInterface.ResultStatusCode" id="MathOptInterface.ResultStatusCode"><code>MathOptInterface.ResultStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ResultStatusCode</code></pre><p>An Enum of possible values for the <code>PrimalStatus</code> and <code>DualStatus</code> attributes. The values indicate how to interpret the result vector.</p><ul><li><code>NO_SOLUTION</code>: the result vector is empty.</li><li><code>FEASIBLE_POINT</code>: the result vector is a feasible point.</li><li><code>NEARLY_FEASIBLE_POINT</code>: the result vector is feasible if some constraint tolerances are relaxed.</li><li><code>INFEASIBLE_POINT</code>: the result vector is an infeasible point.</li><li><code>INFEASIBILITY_CERTIFICATE</code>: the result vector is an infeasibility certificate. If the <code>PrimalStatus</code> is <code>INFEASIBILITY_CERTIFICATE</code>, then the primal result vector is a certificate of dual infeasibility. If the <code>DualStatus</code> is <code>INFEASIBILITY_CERTIFICATE</code>, then the dual result vector is a proof of primal infeasibility.</li><li><code>NEARLY_INFEASIBILITY_CERTIFICATE</code>: the result satisfies a relaxed criterion for a certificate of infeasibility.</li><li><code>UNKNOWN_RESULT_STATUS</code>: the result vector contains a solution with an unknown interpretation.</li><li><code>OTHER_RESULT_STATUS</code>: the result vector contains a solution with an interpretation not covered by one of the statuses defined above.</li></ul></div></div><a class="source-link" href="https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/#L0-L22" target="_blank">source</a></section><p>Common status situations are described in the <a href="http://www.juliaopt.org/MathOptInterface.jl/v0.8/apimanual/#Common-status-situations-1">MOI docs</a>.</p><h2><a class="nav-anchor" href="#Obtaining-solutions-1" id="Obtaining-solutions-1">Obtaining solutions</a></h2><p>Provided the primal status is not <code>MOI.NO_SOLUTION</code>, the primal solution can be obtained by calling <a href="#JuMP.value"><code>value</code></a>. For the dual solution, the function is <a href="#JuMP.dual"><code>dual</code></a>. Calling <a href="#JuMP.has_values"><code>has_values</code></a> for the primal status and <a href="#JuMP.has_duals"><code>has_duals</code></a> for the dual solution is an equivalent way to check whether the status is <code>MOI.NO_SOLUTION</code>. </p><p>It is important to note that if <a href="#JuMP.has_values"><code>has_values</code></a> or <a href="#JuMP.has_duals"><code>has_duals</code></a> return false, calls to <a href="#JuMP.value"><code>value</code></a> and <a href="#JuMP.dual"><code>dual</code></a> might throw an error or return arbitrary values.</p><p>The container type (e.g., scalar, vector, or matrix) of the returned solution (primal or dual) depends on the type of the variable or constraint. See <a href="../extensions/#JuMP.AbstractShape"><code>AbstractShape</code></a> and <a href="../extensions/#JuMP.dual_shape"><code>dual_shape</code></a> for details.</p><p>To call <a href="#JuMP.value"><code>value</code></a> or <a href="#JuMP.dual"><code>dual</code></a> on containers of <a href="../variables/#JuMP.VariableRef"><code>VariableRef</code></a> or <a href="../constraints/#JuMP.ConstraintRef"><code>ConstraintRef</code></a>, use the broadcast syntax, e.g., <code>value.(x)</code>.</p><p>The objective value of a solved problem can be obtained via <a href="../objective/#JuMP.objective_value"><code>objective_value</code></a>. The best known bound on the optimal objective value can be obtained via <a href="../objective/#JuMP.objective_bound"><code>objective_bound</code></a>.</p><p>The following is a recommended workflow for solving a model and querying the solution: </p><pre><code class="language-julia">using JuMP
model = Model()
@variable(model, x[1:10] &gt;= 0)
# ... other constraints ...
optimize!(model)

if termination_status(model) == MOI.OPTIMAL
    optimal_solution = value.(x)
    optimal_objective = objective_value(model)
elseif termination_status(model) == MOI.TIME_LIMIT &amp;&amp; has_values(model)
    suboptimal_solution = value.(x)
    suboptimal_objective = objective_value(model)
else
    error("The model was not solved correctly.")
end</code></pre><h2><a class="nav-anchor" href="#Reference-1" id="Reference-1">Reference</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.termination_status" id="JuMP.termination_status"><code>JuMP.termination_status</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">termination_status(model::Model)</code></pre><p>Return the reason why the solver stopped (i.e., the MathOptInterface model attribute <code>TerminationStatus</code>).</p></div></div><a class="source-link" href="https://github.com/JuliaOpt/JuMP.jl/blob/ebd368bead1656b1269d91bb997e5368b368383b/src/JuMP.jl#L406-L411" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.primal_status" id="JuMP.primal_status"><code>JuMP.primal_status</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">primal_status(model::Model)</code></pre><p>Return the status of the most recent primal solution of the solver (i.e., the MathOptInterface model attribute <code>PrimalStatus</code>).</p></div></div><a class="source-link" href="https://github.com/JuliaOpt/JuMP.jl/blob/ebd368bead1656b1269d91bb997e5368b368383b/src/JuMP.jl#L416-L421" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.has_values" id="JuMP.has_values"><code>JuMP.has_values</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_values(model::Model)</code></pre><p>Return <code>true</code> if the solver has a primal solution available to query, otherwise return <code>false</code>. See also <a href="#JuMP.value"><code>value</code></a>.</p></div></div><a class="source-link" href="https://github.com/JuliaOpt/JuMP.jl/blob/ebd368bead1656b1269d91bb997e5368b368383b/src/variables.jl#L724-L729" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.value" id="JuMP.value"><code>JuMP.value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">value(cref::ConstraintRef)</code></pre><p>Get the primal value of this constraint in the result returned by a solver. That is, if <code>cref</code> is the reference of a constraint <code>func</code>-in-<code>set</code>, it returns the value of <code>func</code> evaluated at the value of the variables (given by <a href="#JuMP.value"><code>value(::VariableRef)</code></a>). Use <a href="#JuMP.has_values"><code>has_values</code></a> to check if a result exists before asking for values.</p><p><strong>Note</strong></p><p>For scalar contraints, the constant is moved to the <code>set</code> so it is not taken into account in the primal value of the constraint. For instance, the constraint <code>@constraint(model, 2x + 3y + 1 == 5)</code> is transformed into <code>2x + 3y</code>-in-<code>MOI.EqualTo(4)</code> so the value returned by this function is the evaluation of <code>2x + 3y</code>. ```</p></div></div><a class="source-link" href="https://github.com/JuliaOpt/JuMP.jl/blob/ebd368bead1656b1269d91bb997e5368b368383b/src/constraints.jl#L428-L445" target="_blank">source</a><div><div><pre><code class="language-none">value(v::VariableRef)</code></pre><p>Get the value of this variable in the result returned by a solver. Use <a href="#JuMP.has_values"><code>has_values</code></a> to check if a result exists before asking for values.</p></div></div><a class="source-link" href="https://github.com/JuliaOpt/JuMP.jl/blob/ebd368bead1656b1269d91bb997e5368b368383b/src/variables.jl#L714-L719" target="_blank">source</a><div><div><pre><code class="language-none">value(ex::GenericAffExpr, var_value::Function)</code></pre><p>Evaluate <code>ex</code> using <code>var_value(v)</code> as the value for each variable <code>v</code>.</p></div></div><a class="source-link" href="https://github.com/JuliaOpt/JuMP.jl/blob/ebd368bead1656b1269d91bb997e5368b368383b/src/aff_expr.jl#L110-L114" target="_blank">source</a><div><div><pre><code class="language-none">value(v::GenericAffExpr)</code></pre><p>Evaluate an <code>GenericAffExpr</code> given the result returned by a solver. Replaces <code>getvalue</code> for most use cases.</p></div></div><a class="source-link" href="https://github.com/JuliaOpt/JuMP.jl/blob/ebd368bead1656b1269d91bb997e5368b368383b/src/aff_expr.jl#L284-L289" target="_blank">source</a><div><div><pre><code class="language-none">value(p::NonlinearParameter)</code></pre><p>Return the current value stored in the nonlinear parameter <code>p</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">model = Model()
@NLparameter(model, p == 10)
value(p)

# output
10.0</code></pre></div></div><a class="source-link" href="https://github.com/JuliaOpt/JuMP.jl/blob/ebd368bead1656b1269d91bb997e5368b368383b/src/nlp.jl#L110-L124" target="_blank">source</a><div><div><pre><code class="language-none">value(ex::NonlinearExpression, var_value::Function)</code></pre><p>Evaluate <code>ex</code> using <code>var_value(v)</code> as the value for each variable <code>v</code>.</p></div></div><a class="source-link" href="https://github.com/JuliaOpt/JuMP.jl/blob/ebd368bead1656b1269d91bb997e5368b368383b/src/nlp.jl#L1059-L1063" target="_blank">source</a><div><div><pre><code class="language-none">value(ex::NonlinearExpression)</code></pre><p>Evaluate <code>ex</code> using <code>value</code> as the value for each variable <code>v</code>.</p></div></div><a class="source-link" href="https://github.com/JuliaOpt/JuMP.jl/blob/ebd368bead1656b1269d91bb997e5368b368383b/src/nlp.jl#L1121-L1125" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.dual_status" id="JuMP.dual_status"><code>JuMP.dual_status</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dual_status(model::Model)</code></pre><p>Return the status of the most recent dual solution of the solver (i.e., the MathOptInterface model attribute <code>DualStatus</code>).</p></div></div><a class="source-link" href="https://github.com/JuliaOpt/JuMP.jl/blob/ebd368bead1656b1269d91bb997e5368b368383b/src/JuMP.jl#L426-L431" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.has_duals" id="JuMP.has_duals"><code>JuMP.has_duals</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_duals(model::Model)</code></pre><p>Return true if the solver has a dual solution available to query, otherwise return false.</p><p>See also <a href="#JuMP.dual"><code>dual</code></a> and <a href="../constraints/#JuMP.shadow_price"><code>shadow_price</code></a>.</p></div></div><a class="source-link" href="https://github.com/JuliaOpt/JuMP.jl/blob/ebd368bead1656b1269d91bb997e5368b368383b/src/constraints.jl#L462-L469" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.dual" id="JuMP.dual"><code>JuMP.dual</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dual(cref::ConstraintRef)</code></pre><p>Get the dual value of this constraint in the result returned by a solver. Use <code>has_dual</code> to check if a result exists before asking for values. See also <a href="../constraints/#JuMP.shadow_price"><code>shadow_price</code></a>.</p></div></div><a class="source-link" href="https://github.com/JuliaOpt/JuMP.jl/blob/ebd368bead1656b1269d91bb997e5368b368383b/src/constraints.jl#L472-L478" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.OptimizeNotCalled" id="JuMP.OptimizeNotCalled"><code>JuMP.OptimizeNotCalled</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct OptimizeNotCalled &lt;: Exception end</code></pre><p>A result attribute cannot be queried before <a href="../solvers/#JuMP.optimize!"><code>optimize!</code></a> is called.</p></div></div><a class="source-link" href="https://github.com/JuliaOpt/JuMP.jl/blob/ebd368bead1656b1269d91bb997e5368b368383b/src/JuMP.jl#L555-L559" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#MathOptInterface.optimize!" id="MathOptInterface.optimize!"><code>MathOptInterface.optimize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">optimize!(optimizer::AbstractOptimizer)</code></pre><p>Start the solution procedure.</p></div></div><a class="source-link" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/b63ab44e22cd23d86296aff7f465bb95f32a85e2/src/MathOptInterface.jl#L27-L31" target="_blank">source</a></section><footer><hr/><a class="previous" href="../solvers/"><span class="direction">Previous</span><span class="title">Solvers</span></a><a class="next" href="../nlp/"><span class="direction">Next</span><span class="title">Nonlinear Modeling</span></a></footer></article></body></HTML>