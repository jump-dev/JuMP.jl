var documenterSearchIndex = {"docs":
[{"location":"installation/#Installation-Guide-1","page":"Installation Guide","title":"Installation Guide","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"JuMP is a package for Julia. To use JuMP, first download and install Julia or open up a remote notebook at JuliaBox or similar services.","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"This version of JuMP is compatible with Julia 1.0 and later.","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"From Julia, JuMP is installed by using the built-in package manager:","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.add(\"JuMP\")","category":"page"},{"location":"installation/#Getting-Solvers-1","page":"Installation Guide","title":"Getting Solvers","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"JuMP depends on solvers to solve optimization problems. Most solvers are not written in Julia, and some require commercial licenses to use, so installation is often more complex. We list below the currently available solvers.","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nThis list is open for new contributions. See also Interacting with solvers and the MathOptInterface docs for more details on how JuMP interacts with solvers. Please get in touch with any questions about connecting new solvers with JuMP.","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"Solver Julia Package License Supports\nArtelys Knitro KNITRO.jl Comm. LP, MILP, SOCP, MISOCP, NLP, MINLP\nCbc Cbc.jl EPL MILP\nCDCS CDCS.jl GPL LP, SOCP, SDP\nCDD CDDLib.jl GPL LP\nClp Clp.jl EPL LP\nCOSMO COSMO.jl Apache LP, QP, SOCP, SDP\nCPLEX CPLEX.jl Comm. LP, MILP, SOCP, MISOCP\nCSDP CSDP.jl EPL LP, SDP\nECOS ECOS.jl GPL LP, SOCP\nFICO Xpress Xpress.jl Comm. LP, MILP, SOCP, MISOCP\nGLPK GLPK.jl GPL LP, MILP\nGurobi Gurobi.jl Comm. LP, MILP, SOCP, MISOCP\nIpopt Ipopt.jl EPL LP, QP, NLP\nJuniper Juniper.jl MIT MISOCP, MINLP\nMOSEK MosekTools.jl Comm. LP, MILP, SOCP, MISOCP, SDP\nOSQP OSQP.jl Apache LP, QP\nProxSDP ProxSDP.jl MIT LP, SOCP, SDP\nSCIP SCIP.jl ZIB MILP, MINLP\nSCS SCS.jl MIT LP, SOCP, SDP\nSDPA SDPA.jl, SDPAFamily.jl GPL LP, SDP\nSDPNAL SDPNAL.jl CC BY-SA LP, SDP\nSDPT3 SDPT3.jl GPL LP, SOCP, SDP\nSeDuMi SeDuMi.jl GPL LP, SOCP, SDP\nTulip Tulip.jl MPL-2 LP","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"Where:","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"LP = Linear programming\nQP = Quadratic programming\nSOCP = Second-order conic programming (including problems with convex quadratic constraints and/or objective)\nMILP = Mixed-integer linear programming\nNLP = Nonlinear programming\nMINLP = Mixed-integer nonlinear programming\nSDP = Semidefinite programming\nMISDP = Mixed-integer semidefinite programming","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"You may also use AmplNLWriter to access solvers that support the nl format. Such solvers include Bonmin and Couenne. See a more complete list here.","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"To install Gurobi, for example, and use it with a JuMP model model, run:","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.add(\"Gurobi\")\nusing JuMP\nusing Gurobi\nmodel = Model(Gurobi.Optimizer)","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"Most packages follow the ModuleName.Optimizer naming convention, but exceptions may exist. See the corresponding Julia package README for more details on how to use the solver.","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"Use set_optimizer_attributes to set solver-specific options. Continuing the example from above,","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"set_optimizer_attributes(model, \"Presolve\" => 0, \"Heuristics\" => 0.01)","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"sets Gurobi's Presolve parameter to zero and Heuristics to 0.01.","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"The following solvers were compatible with JuMP up to release 0.18 but are not yet compatible with the latest version because they do not implement the new MathOptInterface API:","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"Alpine\nBARON\nNLopt\nPavito\nPajarito","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"Solver-specific notes follow below.","category":"page"},{"location":"installation/#Artelys-Knitro-1","page":"Installation Guide","title":"Artelys Knitro","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"Requires a license.","category":"page"},{"location":"installation/#BARON-1","page":"Installation Guide","title":"BARON","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"Requires a license. A trial version is available for small problem instances.","category":"page"},{"location":"installation/#CDD-1","page":"Installation Guide","title":"CDD","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"CDD can solve the problem both using Float64 and Rational{BigInt} arithmetics. The arithmetic used the type T given in CDDLib.Optimizer{T}. Only CDDLib.Optimizer{Float64} can be used with JuMP as JuMP inputs the problem in Float64 arithmetics. Use MOI directly for CDDLib.Optimizer{Rational{BigInt}}.","category":"page"},{"location":"installation/#COIN-OR-Cbc-1","page":"Installation Guide","title":"COIN-OR Cbc","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"Cbc supports \"SOS\" constraints.","category":"page"},{"location":"installation/#COSMO-1","page":"Installation Guide","title":"COSMO","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"COSMO can solve LPs, QPs, SOCPs and SDPs. It can handle SDPs with  quadratic objective functions and supports chordal decomposition of large structured PSD constraints. COSMO is a first order method that performs well on large problems but has a low accuracy by default (10^4). See the COSMO.jl documentation for more information.","category":"page"},{"location":"installation/#CPLEX-1","page":"Installation Guide","title":"CPLEX","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"Requires a working installation of CPLEX with a license (free for faculty members and graduate teaching assistants). The interface requires using CPLEX as a shared library, which is unsupported by the CPLEX developers. Special installation steps are required on Mac OS. CPLEX supports \"SOS\" constraints.","category":"page"},{"location":"installation/#ECOS-1","page":"Installation Guide","title":"ECOS","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"ECOS can be used by JuMP to solve LPs and SOCPs. ECOS does not support general quadratic objectives or constraints, only second-order conic constraints specified by using the SecondOrderCone set.","category":"page"},{"location":"installation/#Gurobi-1","page":"Installation Guide","title":"Gurobi","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"Requires a working installation of Gurobi with an activated license (free for academic use). Gurobi supports \"SOS\" constraints.","category":"page"},{"location":"installation/#FICO-Xpress-1","page":"Installation Guide","title":"FICO Xpress","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"Requires a working installation of Xpress with an active license (it is possible to get a license for academic use, see FICO Academic Partner Program). Supports SOCP and \"SOS\" constraints.","category":"page"},{"location":"installation/#MOSEK-1","page":"Installation Guide","title":"MOSEK","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"Requires a license (free for academic use). The Mosek interface is maintained by the Mosek team. (Thanks!) Note that even if the package implementing MathOptInterface is MosekTools, for consistency the MOI optimizer is called Mosek.Optimizer so do the following to create a model with the Mosek solver:","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"julia> using MosekTools\njulia> model = Model(Mosek.Optimizer)","category":"page"},{"location":"installation/#ProxSDP-1","page":"Installation Guide","title":"ProxSDP","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"ProxSDP solves general SDP problems by means of a first order proximal algorithm based on the primal-dual hybrid gradient, also known as Chambolle-Pock method. The main advantage of ProxSDP over other state-of-the-art solvers is the ability to exploit the low-rank property inherent to several SDP problems. ProxSDP is a first order solver and has low accuracy. See the ProxSDP.jl documentation for more information.","category":"page"},{"location":"installation/#SCS-1","page":"Installation Guide","title":"SCS","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"SCS can be used by JuMP to solve LPs and SOCPs, and SDPs. SCS is a first order solver and has low accuracy (10^4) by default; see the SCS.jl documentation for more information.","category":"page"},{"location":"installation/#SDPA-1","page":"Installation Guide","title":"SDPA","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"SDPA is a second order solver which comes in several variants. The main version has a C++ interface which SDPA.jl uses for efficiently communicating the problem instance to the solver. The three high-precision variants, SDPA-GMP (arbitrary precision), SDPA-QD (\"quad-double\" precision) and SDPA-DD (\"double-double\" precision) do not expose a library interface, but can used via SDPAFamily.jl which writes and reads files to interact with the solver binary.","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"solutions/#Querying-Solutions-1","page":"Query Solutions","title":"Querying Solutions","text":"","category":"section"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"So far we have seen all the elements and constructs related to writing a JuMP optimization model. In this section we reach the point of what to do with a solved problem. Suppose your model is named model. Right after the call to optimize!(model), it's natural to ask JuMP questions about the finished optimization step. Typical questions include:","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"Why has the optimization process stopped? Did it hit the time limit or run into numerical issues?\nDo I have a solution to my problem?\nIs it optimal?\nDo I have a dual solution?\nHow sensitive is the solution to data perturbations?","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"JuMP follows closely the concepts defined in MathOptInterface (MOI) to answer user questions about a finished call to optimize!(model). There are three main steps in querying a solution:","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"First, we can query the termination_status which will tell us why the optimization stopped. This could be due to a number of reasons. For example, the solver found an optimal solution, the problem was proven to be infeasible, or a user-provided limit such as a time limit was encountered. For more information, see the Termination statuses section below.","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"Second, we can query the primal_status and the dual_status, which will tell us what kind of results we have for our primal and dual solutions. This might be an optimal primal-dual pair, a primal solution without a corresponding dual solution, or a certificate of primal or dual infeasibility. For more information, see the Solution statuses section below.","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"Third, we can query value and dual to obtain the primal and dual values of the optimization variables and constraints (if there are values to be queried).","category":"page"},{"location":"solutions/#Termination-statuses-1","page":"Query Solutions","title":"Termination statuses","text":"","category":"section"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"The reason why the optimization of model was finished is given by","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"termination_status(model)","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"This function will return a MOI.TerminationStatusCode enum.","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"MOI.TerminationStatusCode","category":"page"},{"location":"solutions/#MathOptInterface.TerminationStatusCode","page":"Query Solutions","title":"MathOptInterface.TerminationStatusCode","text":"TerminationStatusCode\n\nAn Enum of possible values for the TerminationStatus attribute. This attribute is meant to explain the reason why the optimizer stopped executing in the most recent call to optimize!.\n\nIf no call has been made to optimize!, then the TerminationStatus is:\n\nOPTIMIZE_NOT_CALLED: The algorithm has not started.\n\nOK\n\nThese are generally OK statuses, i.e., the algorithm ran to completion normally.\n\nOPTIMAL: The algorithm found a globally optimal solution.\nINFEASIBLE: The algorithm concluded that no feasible solution exists.\nDUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem. If, additionally, a feasible (primal) solution is known to exist, this status typically implies that the problem is unbounded, with some technical exceptions.\nLOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.\nLOCALLY_INFEASIBLE: The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.\nINFEASIBLE_OR_UNBOUNDED: The algorithm stopped because it decided that the problem is infeasible or unbounded; this occasionally happens during MIP presolve.\n\nSolved to relaxed tolerances\n\nALMOST_OPTIMAL: The algorithm found a globally optimal solution to relaxed tolerances.\nALMOST_INFEASIBLE: The algorithm concluded that no feasible solution exists within relaxed tolerances.\nALMOST_DUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.\nALMOST_LOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.\n\nLimits\n\nThe optimizer stopped because of some user-defined limit.\n\nITERATION_LIMIT: An iterative algorithm stopped after conducting the maximum number of iterations.\nTIME_LIMIT: The algorithm stopped after a user-specified computation time.\nNODE_LIMIT: A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.\nSOLUTION_LIMIT: The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.\nMEMORY_LIMIT: The algorithm stopped because it ran out of memory.\nOBJECTIVE_LIMIT: The algorthm stopped because it found a solution better than a minimum limit set by the user.\nNORM_LIMIT: The algorithm stopped because the norm of an iterate became too large.\nOTHER_LIMIT: The algorithm stopped due to a limit not covered by one of the above.\n\nProblematic\n\nThis group of statuses means that something unexpected or problematic happened.\n\nSLOW_PROGRESS: The algorithm stopped because it was unable to continue making progress towards the solution.\nNUMERICAL_ERROR: The algorithm stopped because it encountered unrecoverable numerical error.\nINVALID_MODEL: The algorithm stopped because the model is invalid.\nINVALID_OPTION: The algorithm stopped because it was provided an invalid option.\nINTERRUPTED: The algorithm stopped because of an interrupt signal.\nOTHER_ERROR: The algorithm stopped because of an error not covered by one of the statuses defined above.\n\n\n\n\n\n","category":"type"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"Additionally, we can receive a solver specific string explaning why the optimization stopped with raw_status.","category":"page"},{"location":"solutions/#Solution-statuses-1","page":"Query Solutions","title":"Solution statuses","text":"","category":"section"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"These statuses indicate what kind of result is available to be queried with value and dual. It's possible that no result is available to be queried.","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"We can obtain these statuses by calling primal_status for the primal status, and dual_status for the dual status. Both will return a MOI.ResultStatusCode enum.","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"MOI.ResultStatusCode","category":"page"},{"location":"solutions/#MathOptInterface.ResultStatusCode","page":"Query Solutions","title":"MathOptInterface.ResultStatusCode","text":"ResultStatusCode\n\nAn Enum of possible values for the PrimalStatus and DualStatus attributes. The values indicate how to interpret the result vector.\n\nNO_SOLUTION: the result vector is empty.\nFEASIBLE_POINT: the result vector is a feasible point.\nNEARLY_FEASIBLE_POINT: the result vector is feasible if some constraint tolerances are relaxed.\nINFEASIBLE_POINT: the result vector is an infeasible point.\nINFEASIBILITY_CERTIFICATE: the result vector is an infeasibility certificate. If the PrimalStatus is INFEASIBILITY_CERTIFICATE, then the primal result vector is a certificate of dual infeasibility. If the DualStatus is INFEASIBILITY_CERTIFICATE, then the dual result vector is a proof of primal infeasibility.\nNEARLY_INFEASIBILITY_CERTIFICATE: the result satisfies a relaxed criterion for a certificate of infeasibility.\nREDUCTION_CERTIFICATE: the result vector is an ill-posed certificate; see this article for details. If the PrimalStatus is REDUCTION_CERTIFICATE, then the primal result vector is a proof that the dual problem is ill-posed. If the DualStatus is REDUCTION_CERTIFICATE, then the dual result vector is a proof that the primal is ill-posed.\nNEARLY_REDUCTION_CERTIFICATE: the result satisfies a relaxed criterion for an ill-posed certificate.\nUNKNOWN_RESULT_STATUS: the result vector contains a solution with an unknown interpretation.\nOTHER_RESULT_STATUS: the result vector contains a solution with an interpretation not covered by one of the statuses defined above.\n\n\n\n\n\n","category":"type"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"Common status situations are described in the MOI docs.","category":"page"},{"location":"solutions/#Obtaining-solutions-1","page":"Query Solutions","title":"Obtaining solutions","text":"","category":"section"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"Provided the primal status is not MOI.NO_SOLUTION, the primal solution can be obtained by calling value. For the dual solution, the function is dual. Calling has_values for the primal status and has_duals for the dual solution is an equivalent way to check whether the status is MOI.NO_SOLUTION.","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"It is important to note that if has_values or has_duals return false, calls to value and dual might throw an error or return arbitrary values.","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"The container type (e.g., scalar, vector, or matrix) of the returned solution (primal or dual) depends on the type of the variable or constraint. See AbstractShape and dual_shape for details.","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"info: Info\nTo call value or dual on containers of VariableRef or ConstraintRef, use the broadcast syntax, e.g., value.(x).","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"The objective value of a solved problem can be obtained via objective_value. The best known bound on the optimal objective value can be obtained via objective_bound. If the solver supports it, the value of the dual objective can be obtained via dual_objective_value.","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"The following is a recommended workflow for solving a model and querying the solution:","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"using JuMP\nmodel = Model()\n@variable(model, x[1:10] >= 0)\n# ... other constraints ...\noptimize!(model)\n\nif termination_status(model) == MOI.OPTIMAL\n    optimal_solution = value.(x)\n    optimal_objective = objective_value(model)\nelseif termination_status(model) == MOI.TIME_LIMIT && has_values(model)\n    suboptimal_solution = value.(x)\n    suboptimal_objective = objective_value(model)\nelse\n    error(\"The model was not solved correctly.\")\nend","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"warning: Querying after modification\nIf a solved model is modified, then querying the solution is undefined behavior. Adding, deleting, or modifying a constraint (or variable) may invalidate any part of the solution.","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"# TODO: How to accurately measure the solve time.","category":"page"},{"location":"solutions/#Accessing-MathOptInterface-attributes-1","page":"Query Solutions","title":"Accessing MathOptInterface attributes","text":"","category":"section"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"MathOptInterface defines a large number of model attributes that can be queried. Examples include MOI.RelativeGap and MOI.SimplexIterations.","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"To query these attributes, use:","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"using JuMP\nmodel = Model()\n# ...\noptimize!(model)\nMOI.get(model, MOI.RelativeGap())","category":"page"},{"location":"solutions/#Sensitivity-analysis-for-LP-1","page":"Query Solutions","title":"Sensitivity analysis for LP","text":"","category":"section"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"Given an LP problem and an optimal solution corresponding to a basis, we can question how much an objective coefficient or standard form rhs coefficient (c.f., normalized_rhs) can change without violating primal or dual feasibility of the basic solution. Note that not all solvers compute the basis, and for sensitivity analysis, the solver interface must implement MOI.ConstraintBasisStatus.","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"Given an LP optimal solution (and both has_values and has_duals returns true) lp_objective_perturbation_range returns a range of the allowed perturbation of the cost coefficient corresponding to the input variable. Note that the current primal solution remains optimal within this range, however the corresponding dual solution might change since a cost coefficient is perturbed. Similarly, lp_rhs_perturbation_range returns a range of the allowed perturbation of the rhs coefficient corresponding to the input constraint. And in this range the current dual solution remains optimal but the primal solution might change since a rhs coefficient is perturbed.","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"However, if the problem is degenerate, there are multiple optimal bases and hence these ranges might not be as intuitive and seem too narrow. E.g., a larger cost coefficient perturbation might not invalidate the optimality of the current primal solution. Moreover, if a problem is degenerate, due to finite precision, it can happen that, e.g., a perturbation seems to invalidate a basis even though it doesn't (again providing too narrow ranges). To prevent this feasibility_tolerance and optimality_tolerance is introduced, which in turn, might make the ranges too wide for numerically challenging instances. Thus do not blindly trust these ranges, especially not for highly degenerate or numerically unstable instances.","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"To give a simple example, we could analyze the sensitivity of the optimal solution to the following (non-degenerate) LP problem:","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"julia> model = Model();\njulia> @variable(model, x[1:2]);\njulia> @constraint(model, c1, x[1] + x[2] <= 1);\njulia> @constraint(model, c2, x[1] - x[2] <= 1);\njulia> @constraint(model, c3, -0.5 <= x[2] <= 0.5);\njulia> @objective(model, Max, x[1]);","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"DocTestSetup = quote\n    using JuMP\n    model = Model(() -> MOIU.MockOptimizer(MOIU.Model{Float64}(),\n                          eval_variable_constraint_dual=true));\n    @variable(model, x[1:2]);\n    @constraint(model, c1, x[1] + x[2] <= 1);\n    @constraint(model, c2, x[1] - x[2] <= 1);\n    @constraint(model, c3, -0.5 <= x[2] <= 0.5);\n    @objective(model, Max, x[1]);\n    optimize!(model);\n    mock = backend(model).optimizer.model;\n    MOI.set(mock, MOI.TerminationStatus(), MOI.OPTIMAL);\n    MOI.set(mock, MOI.DualStatus(), MOI.FEASIBLE_POINT);\n    MOI.set(mock, MOI.VariablePrimal(), JuMP.optimizer_index(x[1]), 1.0);\n    MOI.set(mock, MOI.VariablePrimal(), JuMP.optimizer_index(x[2]), 0.0);\n    MOI.set(mock, MOI.ConstraintBasisStatus(), JuMP.optimizer_index(c1), MOI.NONBASIC);\n    MOI.set(mock, MOI.ConstraintBasisStatus(), JuMP.optimizer_index(c2), MOI.NONBASIC);\n    MOI.set(mock, MOI.ConstraintBasisStatus(), JuMP.optimizer_index(c3), MOI.BASIC);\n    MOI.set(mock, MOI.ConstraintDual(), optimizer_index(c1), -0.5);\n    MOI.set(mock, MOI.ConstraintDual(), optimizer_index(c2), -0.5);\n    MOI.set(mock, MOI.ConstraintDual(), optimizer_index(c3), 0.0);\nend","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"To analyze the sensitivity of the problem we could check the allowed perturbation ranges of, e.g., the cost coefficients and the rhs coefficient of constraint c1 as follows:","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"julia> optimize!(model);\n\njulia> value.(x)\n2-element Array{Float64,1}:\n 1.0\n 0.0\njulia> lp_objective_perturbation_range(x[1])\n(-1.0, Inf)\njulia> lp_objective_perturbation_range(x[2])\n(-1.0, 1.0)\njulia> lp_rhs_perturbation_range(c1)\n(-1.0, 1.0)","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"lp_objective_perturbation_range\nlp_rhs_perturbation_range","category":"page"},{"location":"solutions/#JuMP.lp_objective_perturbation_range","page":"Query Solutions","title":"JuMP.lp_objective_perturbation_range","text":"lp_objective_perturbation_range(var::VariableRef;\n                                optimality_tolerance::Float64)\n                                ::Tuple{Float64, Float64}\n\nGives the range by which the cost coefficient can change and the current LP basis remains optimal, i.e., the reduced costs remain valid.\n\nNotes\n\nThe range denotes valid changes, Δ ∈ [l, u], for which cost[var] += Δ do not violate the current optimality conditions.\noptimality_tolerance is the dual feasibility tolerance, this should preferably match the tolerance used by the solver. The defualt tolerance should however apply in most situations (c.f. \"Computational Techniques of the Simplex Method\" by István Maros, section 9.3.4).\n\n\n\n\n\n","category":"function"},{"location":"solutions/#JuMP.lp_rhs_perturbation_range","page":"Query Solutions","title":"JuMP.lp_rhs_perturbation_range","text":"lp_rhs_perturbation_range(constraint::ConstraintRef;\n                          feasibility_tolerance::Float64)\n                          ::Tuple{Float64, Float64}\n\nGives the range by which the rhs coefficient can change and the current LP basis remains feasible, i.e., where the shadow prices apply.\n\nNotes\n\nThe rhs coefficient is the value right of the relation, i.e., b for the constraint when of the form a*x □ b, where □ is ≤, =, or ≥.\nThe range denotes valid changes, e.g., for a*x <= b + Δ, the LP basis remains feasible for all Δ ∈ [l, u].\nfeasibility_tolerance is the primal feasibility tolerance, this should preferably match the tolerance used by the solver. The default tolerance should however apply in most situations (c.f. \"Computational Techniques of the Simplex Method\" by István Maros, section 9.3.4).\n\n\n\n\n\n","category":"function"},{"location":"solutions/#Multiple-solutions-1","page":"Query Solutions","title":"Multiple solutions","text":"","category":"section"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"Some solvers support returning multiple solutions. You can check how many solutions are available to query using result_count.","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"Functions for querying the solutions, e.g., primal_status and value, all take an additional keyword argument result which can be used to specify which result to return.","category":"page"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"using JuMP\nmodel = Model()\n@variable(model, x[1:10] >= 0)\n# ... other constraints ...\noptimize!(model)\n\nif termination_status(model) != MOI.OPTIMAL\n    error(\"The model was not solved correctly.\")\nend\n\nnum_results = result_count(model)\n@assert has_values(model; result = num_results)\nan_optimal_solution = value.(x; result = num_results)\nan_optimal_objective = objective_value(model; result = num_results)","category":"page"},{"location":"solutions/#Reference-1","page":"Query Solutions","title":"Reference","text":"","category":"section"},{"location":"solutions/#","page":"Query Solutions","title":"Query Solutions","text":"JuMP.termination_status\nJuMP.raw_status\nJuMP.primal_status\nJuMP.has_values\nJuMP.value\nJuMP.dual_status\nJuMP.has_duals\nJuMP.dual\nJuMP.solve_time\nOptimizeNotCalled\nMOI.optimize!\nJuMP.result_count","category":"page"},{"location":"solutions/#JuMP.termination_status","page":"Query Solutions","title":"JuMP.termination_status","text":"termination_status(model::Model)\n\nReturn the reason why the solver stopped (i.e., the MathOptInterface model attribute TerminationStatus).\n\n\n\n\n\n","category":"function"},{"location":"solutions/#JuMP.raw_status","page":"Query Solutions","title":"JuMP.raw_status","text":"raw_status(model::Model)\n\nReturn the reason why the solver stopped in its own words (i.e., the MathOptInterface model attribute RawStatusString).\n\n\n\n\n\n","category":"function"},{"location":"solutions/#JuMP.primal_status","page":"Query Solutions","title":"JuMP.primal_status","text":"primal_status(model::Model; result::Int = 1)\n\nReturn the status of the most recent primal solution of the solver (i.e., the MathOptInterface model attribute PrimalStatus) associated with the result index result.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#JuMP.has_values","page":"Query Solutions","title":"JuMP.has_values","text":"has_values(model::Model; result::Int = 1)\n\nReturn true if the solver has a primal solution in result index result available to query, otherwise return false.\n\nSee also value and result_count.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#JuMP.value","page":"Query Solutions","title":"JuMP.value","text":"value(con_ref::ConstraintRef; result::Int = 1)\n\nReturn the primal value of constraint con_ref associated with result index result of the most-recent solution returned by the solver.\n\nThat is, if con_ref is the reference of a constraint func-in-set, it returns the value of func evaluated at the value of the variables (given by value(::VariableRef)).\n\nUse has_values to check if a result exists before asking for values.\n\nSee also: result_count.\n\nNote\n\nFor scalar contraints, the constant is moved to the set so it is not taken into account in the primal value of the constraint. For instance, the constraint @constraint(model, 2x + 3y + 1 == 5) is transformed into 2x + 3y-in-MOI.EqualTo(4) so the value returned by this function is the evaluation of 2x + 3y. ```\n\n\n\n\n\nvalue(v::VariableRef; result = 1)\n\nReturn the value of variable v associated with result index result of the most-recent returned by the solver.\n\nUsehas_values to check if a result exists before asking for values.\n\nSee also: result_count.\n\n\n\n\n\nvalue(ex::GenericAffExpr, var_value::Function)\n\nEvaluate ex using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(v::GenericAffExpr; result::Int = 1)\n\nReturn the value of the GenericAffExpr v associated with result index result of the most-recent solution returned by the solver.\n\nReplaces getvalue for most use cases.\n\nSee also: result_count.\n\n\n\n\n\nvalue(v::GenericQuadExpr; result::Int = 1)\n\nReturn the value of the GenericQuadExpr v associated with result index result of the most-recent solution returned by the solver.\n\nReplaces getvalue for most use cases.\n\nSee also: result_count.\n\n\n\n\n\nvalue(p::NonlinearParameter)\n\nReturn the current value stored in the nonlinear parameter p.\n\nExample\n\nmodel = Model()\n@NLparameter(model, p == 10)\nvalue(p)\n\n# output\n10.0\n\n\n\n\n\nvalue(ex::NonlinearExpression, var_value::Function)\n\nEvaluate ex using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(ex::NonlinearExpression; result::Int = 1)\n\nReturn the value of the NonlinearExpression ex associated with result index result of the most-recent solution returned by the solver.\n\nReplaces getvalue for most use cases.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#JuMP.dual_status","page":"Query Solutions","title":"JuMP.dual_status","text":"dual_status(model::Model; result::Int = 1)\n\nReturn the status of the most recent dual solution of the solver (i.e., the MathOptInterface model attribute DualStatus) associated with the result index result.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#JuMP.has_duals","page":"Query Solutions","title":"JuMP.has_duals","text":"has_duals(model::Model; result::Int = 1)\n\nReturn true if the solver has a dual solution in result index result available to query, otherwise return false.\n\nSee also dual, shadow_price, and result_count.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#JuMP.dual","page":"Query Solutions","title":"JuMP.dual","text":"dual(con_ref::ConstraintRef; result::Int = 1)\n\nReturn the dual value of constraint con_ref associated with result index result of the most-recent solution returned by the solver.\n\nUse has_dual to check if a result exists before asking for values.\n\nSee also: result_count, shadow_price.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#JuMP.solve_time","page":"Query Solutions","title":"JuMP.solve_time","text":"solve_time(model::Model)\n\nIf available, returns the solve time reported by the solver. Returns \"ArgumentError: ModelLike of type Solver.Optimizer does not support accessing the attribute MathOptInterface.SolveTime()\" if the attribute is not implemented.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#JuMP.OptimizeNotCalled","page":"Query Solutions","title":"JuMP.OptimizeNotCalled","text":"struct OptimizeNotCalled <: Exception end\n\nA result attribute cannot be queried before optimize! is called.\n\n\n\n\n\n","category":"type"},{"location":"solutions/#MathOptInterface.optimize!","page":"Query Solutions","title":"MathOptInterface.optimize!","text":"optimize!(optimizer::AbstractOptimizer)\n\nStart the solution procedure.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#JuMP.result_count","page":"Query Solutions","title":"JuMP.result_count","text":"result_count(model::Model)\n\nReturn the number of results available to query after a call to optimize!.\n\n\n\n\n\n","category":"function"},{"location":"style/#Style-guide-and-design-principles-1","page":"Style Guide","title":"Style guide and design principles","text":"","category":"section"},{"location":"style/#Style-guide-1","page":"Style Guide","title":"Style guide","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"This section describes the coding style rules that apply to JuMP code and that we recommend for JuMP models and surrounding Julia code. The motivations for a style guide include:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"conveying best practices for writing readable and maintainable code\nreducing the amount of time spent on bike-shedding by establishing basic naming and formatting conventions\nlowering the barrier for new contributors by codifying the existing practices (e.g., you can be more confident your code will pass review if you follow the style guide)","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"In some cases, the JuMP style guide diverges from the Julia style guide. All such cases will be explicitly noted and justified.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"The JuMP style guide adopts many recommendations from the Google style guides.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"info: Info\nThe style guide is always a work in progress, and not all JuMP code follows the rules. When modifying JuMP, please fix the style violations of the surrounding code (i.e., leave the code tidier than when you started). If large changes are needed, consider separating them into another PR.","category":"page"},{"location":"style/#Formatting-1","page":"Style Guide","title":"Formatting","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Julia unfortunately does not have an autoformatting tool like gofmt. Until a reliable autoformatting tool is available, we adopt the following conventions.","category":"page"},{"location":"style/#Whitespace-1","page":"Style Guide","title":"Whitespace","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"For conciseness, never use more than one blank line within a function, and never begin a function with a blank line.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"function foo(x)\n    y = 2 * x\n\n\n    return y\nend\n\nfunction foo(x)\n\n    y = 2 * x\n    return y\nend","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Julia is mostly insensitive to whitespace characters within lines. For consistency:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Use spaces between binary operators (with some exceptions, see below)\nUse a single space after commas and semicolons\nDo not use extra spaces for unary operators, parentheses, or braces\nIndent within new blocks (except module) using 4 spaces","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"f(x, y) = [3 * dot(x, y); x']","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"f(x,y) = [ 3*dot(x,y) ; x' ]","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"module Foo\n\nfunction f(x)\n    return x + 1\nend\n\nend # module Foo","category":"page"},{"location":"style/#Exceptions-1","page":"Style Guide","title":"Exceptions","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"For aesthetic reasons, we make an exception for whitespace surrounding the exponential operator ^.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"f(x) = x^2","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"f(x) = x ^ 2","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"We also make an exception for the : operator when it is used to form a range.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"x = 1:5","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"x = 1 : 5","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"One reason is that it can be confused with Julia's conditional statement: cond ? x : y which requires whitespace around the :.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"We also make an exception for juxtaposed multiplication (i.e. dropping the * between a numeric literal and an expression) when the right-hand side is a symbol.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"2x  # Acceptable if there are space constraints.\n2 * x  # This preferred if space is not an issue.\n2 * (x + 1)","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"2(x + 1)","category":"page"},{"location":"style/#Return-statements-1","page":"Style Guide","title":"Return statements","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"To avoid situations in which it is unclear whether the author intended to return a certain value or not, always use an explicit return statement to exit from a function. If the return from a function is nothing, use return instead of return nothing.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"We make an exception for assignment-form one-line functions (f(x) = 2x).","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"foo(x) = 2x  # Acceptable if one line\nfunction foo(x)\n    return 2x\nend\nfunction foo(x)\n    x[1] += 1\n    return\nend","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"function foo(x)\n    2x\nend\nfunction foo(x)\n    x[1] += 1\n    return nothing\nend","category":"page"},{"location":"style/#Line-length-1","page":"Style Guide","title":"Line length","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Line lengths are a contentious issue. Our foremost goal is to maximize code readability. Very long line lengths can be hard to easily comprehend. However, arbitrarily enforcing a maximum line length (like 80 characters) inevitably leads to cases in which slightly longer lines (e.g. 81 characters) might be more readable.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Therefore, aim to keep line lengths under 80 characters by breaking lines for maximum readability (examples are given in the Line breaks section), but don't treat this as a hard rule.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"We make exceptions for","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"URLs\npathnames","category":"page"},{"location":"style/#Line-breaks-1","page":"Style Guide","title":"Line breaks","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"The \"readability\" of a line is subjective. In this section we give suggestions of good and bad style of how to break a line. These suggestions are inspired by Google's Python style guide.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"note: Note\nIf you're unsure about how format your code, you can experiment (in Python) using YAPF.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"When defining functions, align arguments vertically after the opening parenthesis, or list all arguments on a new (indented) line.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"# Arguments to the function are aligned vertically.\nfunction my_very_long_function_name(with_lots_of_long_arguments_1,\n                                    and_another_long_one)\n    # First line of the function begins here.\nend\n\n# Arguments to the function are listed on a new line and indented.\nfunction my_very_long_function_name(\n    with_lots_of_long_arguments_1, and_another_long_one)\n    # First line of the function begins here.\nend","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"# When defining functions, if vertical alignment is not used, then the arguments\n# should not begin on the first line.\nfunction my_very_long_function_name(with_lots_of_long_arguments_1,\n    and_another_long_one)\n    # First line of the function begins here.\nend","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Don't use vertical alignment if all of the arguments are very far to the right.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"a_very_long_variable_name = a_long_variable_name_with_arguments(first_argument,\n                                                                second_argument)","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Better:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"a_very_long_variable_name = a_long_variable_name_with_arguments(\n    first_argument, second_argument)","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Don't use vertical alignment if it would be more readable to place all arguments on a new indented line.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"con_index = MOI.add_constraint(backend(owner_model(variable)),\n                               MOI.SingleVariable(index(variable)), set)","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Better:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"con_index = MOI.add_constraint(\n    backend(owner_model(variable)), MOI.SingleVariable(index(variable)), set)","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Don't break lines at an inner-level of function nesting.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"con_index = MOI.add_constraint(\n    backend(owner_model(variable)), MOI.SingleVariable(\n    index(variable)), new_set)","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Better:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"con_index = MOI.add_constraint(\n    backend(owner_model(variable)),\n    MOI.SingleVariable(index(variable)), new_set)","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"For readability, don't split a one-line function over multiple lines.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"f(x) = 1 + x +\n    x^2 + x^3","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Better:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"f(x) = 1 + x + x^2 + x^3 + x^3","category":"page"},{"location":"style/#Syntax-1","page":"Style Guide","title":"Syntax","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Julia sometimes provides equivalent syntax to express the same basic operation. We discuss these cases below.","category":"page"},{"location":"style/#for-loops-1","page":"Style Guide","title":"for loops","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Julia allows both for x = 1:N and for x in 1:N. Always prefer to use in over =, because in generalizes better to other index sets like for x in eachindex(A).","category":"page"},{"location":"style/#Empty-vectors-1","page":"Style Guide","title":"Empty vectors","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"For a type T, T[] and Vector{T}() are equivalent ways to create an empty vector with element type T. Prefer T[] because it is more concise.","category":"page"},{"location":"style/#Trailing-periods-in-floating-point-constants-1","page":"Style Guide","title":"Trailing periods in floating-point constants","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Both 1.0 and 1. create a Float64 with value 1.0. Prefer 1.0 over 1. because it is more easily distinguished from the integer constant 1.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Moreover, as recommended by the Julia style guide, never use 1.0 when 1 is okay.","category":"page"},{"location":"style/#Comments-1","page":"Style Guide","title":"Comments","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"For non-native speakers and for general clarity, comments in code must be proper English sentences with appropriate punctuation.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"# This is a comment demonstrating a good comment.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"# a bad comment","category":"page"},{"location":"style/#JuMP-macro-syntax-1","page":"Style Guide","title":"JuMP macro syntax","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"For consistency, always use parentheses.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0)","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"@variable model x >= 0","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"For consistency, always use constant * variable as opposed to variable * constant. This makes it easier to read models in ambiguous cases like a * x.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"a = 4\n@constraint(model, 3 * x <= 1)\n@constraint(model, a * x <= 1)","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"a = 4\n@constraint(model, x * 3 <= 1)\n@constraint(model, x * a <= 1)","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"In order to reduce boilerplate code, prefer the plural form of macros over lots of repeated calls to singular forms.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"@variables(model, begin\n    x >= 0\n    y >= 1\n    z <= 2\nend)","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0)\n@variable(model, y >= 1)\n@variable(model, z <= 2)","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"An exception is made for calls with many keyword arguments, since these need to be enclosed in parentheses in order to parse properly.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Acceptable:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0, start = 0.0, base_name = \"my_x\")\n@variable(model, y >= 1, start = 2.0)\n@variable(model, z <= 2, start = -1.0)","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Also acceptable:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"@variables(model, begin\n    x >= 0, (start = 0.0, base_name = \"my_x\")\n    y >= 1, (start = 2.0)\n    z <= 2, (start = -1.0)\nend)","category":"page"},{"location":"style/#Naming-1","page":"Style Guide","title":"Naming","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"module SomeModule end\nfunction some_function end\nconst SOME_CONSTANT = ...\nstruct SomeStruct\n  some_field::SomeType\nend\n@enum SomeEnum ENUM_VALUE_A ENUM_VALUE_B\nsome_local_variable = ...\nsome_file.jl # Except for ModuleName.jl.","category":"page"},{"location":"style/#Exported-and-non-exported-names-1","page":"Style Guide","title":"Exported and non-exported names","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Begin private module level functions and constants with an underscore. All other objects in the scope of a module should be exported. (See JuMP.jl for an example of how to do this.)","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Names beginning with an underscore should only be used for distinguishing between exported (public) and non-exported (private) objects. Therefore, never begin the name of a local variable with an underscore.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"module MyModule\n\nexport public_function, PUBLIC_CONSTANT\n\nfunction _private_function()\n    local_variable = 1\n    return\nend\n\nfunction public_function end\n\nconst _PRIVATE_CONSTANT = 3.14159\nconst PUBLIC_CONSTANT = 1.41421\n\nend","category":"page"},{"location":"style/#Use-of-underscores-within-names-1","page":"Style Guide","title":"Use of underscores within names","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"The Julia style guide recommends avoiding underscores \"when readable\", for example, haskey, isequal, remotecall, and remotecall_fetch. This convention creates the potential for unnecessary bikeshedding and also forces the user to recall the presence/absence of an underscore, e.g., \"was that argument named basename or base_name?\". For consistency, always use underscores in variable names and function names to separate words.","category":"page"},{"location":"style/#Use-of-!-1","page":"Style Guide","title":"Use of !","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Julia has a convention of appending ! to a function name if the function modifies its arguments. We recommend to:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Omit ! when the name itself makes it clear that modification is taking place, e.g., add_constraint and set_name. We depart from the Julia style guide because ! does not provide a reader with any additional information in this case, and adherence to this convention is not uniform even in base Julia itself (consider Base.println and Base.finalize).\nUse ! in all other cases. In particular it can be used to distinguish between modifying and non-modifying variants of the same function like scale and scale!.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Note that ! is not a self-documenting feature because it is still ambiguous which arguments are modified when multiple arguments are present. Be sure to document which arguments are modified in the method's docstring.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"See also the Julia style guide recommendations for ordering of function arguments.","category":"page"},{"location":"style/#Abbreviations-1","page":"Style Guide","title":"Abbreviations","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Abbreviate names to make the code more readable, not to save typing. Don't arbitrarily delete letters from a word to abbreviate it (e.g., indx). Use abbreviations consistently within a body of code (e.g., do not mix con and constr, idx and indx).","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Common abbreviations:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"num for number\ncon for constraint","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"TODO: add more","category":"page"},{"location":"style/#Miscellaneous-1","page":"Style Guide","title":"Miscellaneous","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"(TODO: Rethink categories.)","category":"page"},{"location":"style/#User-facing-MethodError-1","page":"Style Guide","title":"User-facing MethodError","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Specifying argument types for methods is mostly optional in Julia, which means that it's possible to find out that you are working with unexpected types deep in the call chain. Avoid this situation or handle it with a helpful error message. A user should see a MethodError only for methods that they called directly.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"internal_function(x::Integer) = x + 1\n# The user sees a MethodError for internal_function when calling\n# public_function(\"a string\"). This is not very helpful.\npublic_function(x) = internal_function(x)","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"internal_function(x::Integer) = x + 1\n# The user sees a MethodError for public_function when calling\n# public_function(\"a string\"). This is easy to understand.\npublic_function(x::Integer) = internal_function(x)","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"If it is hard to provide an error message at the top of the call chain, then the following pattern is also ok:","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"internal_function(x::Integer) = x + 1\nfunction internal_function(x)\n    error(\"Internal error. This probably means that you called \" *\n          \"public_function() with the wrong type.\")\nend\npublic_function(x) = internal_function(x)","category":"page"},{"location":"style/#@enum-vs.-Symbol-1","page":"Style Guide","title":"@enum vs. Symbol","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"The @enum macro lets you define types with a finite number of values that are explicitly enumerated (like enum in C/C++). Symbols are lightweight strings that are used to represent identifiers in Julia (for example, :x).","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"@enum provides type safety and can have docstrings attached to explain the possible values. Use @enums when applicable, e.g., for reporting statuses. Use strings to provide long-form additional information like error messages.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Use of Symbol should typically be reserved for identifiers, e.g., for lookup in the JuMP model (model[:my_variable]).","category":"page"},{"location":"style/#using-vs.-import-1","page":"Style Guide","title":"using vs. import","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"using ModuleName brings all symbols exported by the module ModuleName into scope, while import ModuleName brings only the module itself into scope. (See the Julia manual) for examples and more details.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"For the same reason that from <module> import * is not recommended in python (PEP 8), avoid using ModuleName except in throw-away scripts or at the REPL. The using statement makes it harder to track where symbols come from and exposes the code to ambiguities when two modules export the same symbol.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Prefer using ModuleName: x, p to import ModuleName.x, ModuleName.p and import MyModule: x, p because the import versions allow method extension without qualifying with the module name.","category":"page"},{"location":"style/#Documentation-1","page":"Style Guide","title":"Documentation","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"This section describes the writing style that should be used when writing documentation for JuMP (and supporting packages).","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"We can recommend the documentation style guides by Divio, Google, and Write the Docs as general reading for those writing documentation. This guide delegates a thorough handling of the topic to those guides and instead elaborates on the more points more specific to Julia and documentation that uses Documenter.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"Be concise.\nUse lists instead of long sentences.\nUse numbered lists when describing a sequence, e.g., (1) do X, (2) then Y.\nUse bullet points when the items are not ordered.\nExample code should be covered by doctests. (But it's unclear what to do if the code depends on a solver.)\nWhen a word is a Julia symbol and not an English word, enclose it with backticks. In addition, if it has a docstring in this doc add a link using @ref. If it is a plural, add the \"s\" after the closing backtick. For example,\n[`VariableRef`](@ref)s\nUse @meta blocks for TODOs and other comments that shouldn't be visible to readers. For example,\n```@meta\n# TODO: Mention also X, Y, and Z.\n```","category":"page"},{"location":"style/#Design-principles-1","page":"Style Guide","title":"Design principles","text":"","category":"section"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"TODO: How to structure and test large JuMP models, libraries that use JuMP.","category":"page"},{"location":"style/#","page":"Style Guide","title":"Style Guide","text":"For how to write a solver, see MOI.","category":"page"},{"location":"solvers/#Interacting-with-solvers-1","page":"Solvers","title":"Interacting with solvers","text":"","category":"section"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"A JuMP model keeps a MathOptInterface (MOI) backend of type MOI.ModelLike that stores the optimization problem and acts as the optimization solver. We call it an MOI backend and not optimizer as it can also be a wrapper around an optimization file format such as MPS that writes the JuMP model in a file. From JuMP, the MOI backend can be accessed using the backend function. JuMP can be viewed as a lightweight, user-friendly layer on top of the MOI backend, in the sense that:","category":"page"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"JuMP does not maintain any copy of the model outside this MOI backend.\nJuMP variable (resp. constraint) references are simple structures containing both a reference to the JuMP model and the MOI index of the variable (resp. constraint).\nJuMP gives the constraints to the MOI backend in the form provided by the user without doing any automatic reformulation.\nvariables additions, constraints additions/modifications and objective modifications are directly applied to the MOI backend thus expecting the backend to support such modifications.","category":"page"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"While this allows JuMP to be a thin wrapper on top of the solver API, as mentioned in the last point above, this seems rather demanding on the solver. Indeed, while some solvers support incremental building of the model and modifications before and after solve, other solvers only support the model being copied at once before solve. Moreover, it seems to require all solvers to implement all possible reformulations independently which seems both very ambitious and might generate a lot of duplicated code.","category":"page"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"These apparent limitations are addressed at level of MOI in a manner that is completely transparent to JuMP. While the MOI API may seem very demanding, it allows MOI models to be a succession of lightweight MOI layers that fill the gap between JuMP requirements and the solver capabilities. The remainder of this section describes how JuMP interacts with the MOI backend.","category":"page"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"JuMP models can be created in three different modes: AUTOMATIC, MANUAL and DIRECT.","category":"page"},{"location":"solvers/#Automatic-and-Manual-modes-1","page":"Solvers","title":"Automatic and Manual modes","text":"","category":"section"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"In AUTOMATIC and MANUAL modes, two MOI layers are automatically applied to the optimizer:","category":"page"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"CachingOptimizer: maintains a cache of the model so that when the optimizer does not support an incremental change to the model, the optimizer's internal model can be discarded and restored from the cache just before optimization. The CachingOptimizer has two different modes: AUTOMATIC and MANUAL corresponding to the two JuMP modes with the same names.\nLazyBridgeOptimizer (this can be disabled using the bridge_constraints keyword argument to Model constructor): when a constraint added is not supported by the optimizer, it attempts to transform the constraint into an equivalent form, possibly adding new variables and constraints that are supported by the optimizer. The applied transformations are selected among known recipes which are called bridges. A few default bridges are defined in MOI but new ones can be defined and added to the LazyBridgeOptimizer used by JuMP.","category":"page"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"See the MOI documentation for more details on these two MOI layers.","category":"page"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"To attach an optimizer to a JuMP model, JuMP needs to be able to create a new empty optimizer instance. For this reason, we provide JuMP with a function that creates a new optimizer (i.e., an optimizer factory), instead of a concrete optimizer object.","category":"page"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"The factory can be provided either at model construction time by calling set_optimizer. An optimizer must be set before a call to optimize!. The optimizer can be grouped with attributes to be set before optimization with optimizer_with_attributes.","category":"page"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"set_optimizer\noptimizer_with_attributes\nNoOptimizer\nJuMP.optimize!","category":"page"},{"location":"solvers/#JuMP.set_optimizer","page":"Solvers","title":"JuMP.set_optimizer","text":"set_optimizer(model::Model, optimizer_factory;\n              bridge_constraints::Bool=true)\n\nCreates an empty MathOptInterface.AbstractOptimizer instance by calling optimizer_factory() and sets it as the optimizer of model. Specifically, optimizer_factory must be callable with zero arguments and return an empty MathOptInterface.AbstractOptimizer.\n\nIf bridge_constraints is true, constraints that are not supported by the optimizer are automatically bridged to equivalent supported constraints when an appropriate transformation is defined in the MathOptInterface.Bridges module or is defined in another module and is explicitly added.\n\nSee set_optimizer_attributes and set_optimizer_attribute for setting solver-specific parameters of the optimizer.\n\nExamples\n\nmodel = Model()\nset_optimizer(model, GLPK.Optimizer)\n\n\n\n\n\n","category":"function"},{"location":"solvers/#JuMP.optimizer_with_attributes","page":"Solvers","title":"JuMP.optimizer_with_attributes","text":"optimizer_with_attributes(optimizer_constructor, attrs::Pair...)\n\nGroups an optimizer constructor with the list of attributes attrs. Note that it is equivalent to MOI.OptimizerWithAttributes.\n\nWhen provided to the Model constructor or to set_optimizer, it creates an optimizer by calling optimizer_constructor(), and then sets the attributes using set_optimizer_attribute.\n\nExample\n\nmodel = Model(\n    optimizer_with_attributes(\n        Gurobi.Optimizer, \"Presolve\" => 0, \"OutputFlag\" => 1\n    )\n)\n````\nis equivalent to:\n\njulia model = Model(Gurobi.Optimizer) setoptimizerattribute(model, \"Presolve\", 0) setoptimizerattribute(model, \"OutputFlag\", 1) ````\n\nNote\n\nThe string names of the attributes are specific to each solver. One should consult the solver's documentation to find the attributes of interest.\n\nSee also: set_optimizer_attribute, set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#JuMP.NoOptimizer","page":"Solvers","title":"JuMP.NoOptimizer","text":"struct NoOptimizer <: Exception end\n\nNo optimizer is set. The optimizer can be provided to the Model constructor or by calling set_optimizer.\n\n\n\n\n\n","category":"type"},{"location":"solvers/#JuMP.optimize!","page":"Solvers","title":"JuMP.optimize!","text":"optimize!(model::Model;\n          ignore_optimize_hook=(model.optimize_hook === nothing),\n          kwargs...)\n\nOptimize the model. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nKeyword arguments kwargs are passed to the optimize_hook. An error is thrown if optimize_hook is nothing and keyword arguments are provided. ```\n\n\n\n\n\n","category":"function"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"New JuMP models are created using the Model constructor:","category":"page"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"Model()\nModel(::Any)","category":"page"},{"location":"solvers/#JuMP.Model-Tuple{}","page":"Solvers","title":"JuMP.Model","text":"Model(; caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC)\n\nReturn a new JuMP model without any optimizer; the model is stored the model in a cache. The mode of the CachingOptimizer storing this cache is caching_mode. Use set_optimizer to set the optimizer before calling optimize!.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#JuMP.Model-Tuple{Any}","page":"Solvers","title":"JuMP.Model","text":"Model(optimizer_factory;\n      caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC,\n      bridge_constraints::Bool=true)\n\nReturn a new JuMP model with the provided optimizer and bridge settings. This function is equivalent to:\n\n    model = Model()\n    set_optimizer(model, optimizer_factory,\n                  bridge_constraints=bridge_constraints)\n    return model\n\nSee set_optimizer for the description of the optimizer_factory and bridge_constraints arguments.\n\nExamples\n\nThe following creates a model with the optimizer set to Ipopt:\n\nmodel = Model(Ipopt.Optimizer)\n\n\n\n\n\n","category":"method"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"# TODO: how to control the caching optimizer states","category":"page"},{"location":"solvers/#Direct-mode-1","page":"Solvers","title":"Direct mode","text":"","category":"section"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"JuMP models can be created in DIRECT mode using the JuMP.direct_model function.","category":"page"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"JuMP.direct_model","category":"page"},{"location":"solvers/#JuMP.direct_model","page":"Solvers","title":"JuMP.direct_model","text":"direct_model(backend::MOI.ModelLike)\n\nReturn a new JuMP model using backend to store the model and solve it. As opposed to the Model constructor, no cache of the model is stored outside of backend and no bridges are automatically applied to backend. The absence of cache reduces the memory footprint but it is important to bear in mind the following implications of creating models using this direct mode:\n\nWhen backend does not support an operation, such as modifying constraints or adding variables/constraints after solving, an error is thrown. For models created using the Model constructor, such situations can be dealt with by storing the modifications in a cache and loading them into the optimizer when optimize! is called.\nNo constraint bridging is supported by default.\nThe optimizer used cannot be changed the model is constructed.\nThe model created cannot be copied.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"JuMP.backend","category":"page"},{"location":"solvers/#JuMP.backend","page":"Solvers","title":"JuMP.backend","text":"backend(model::Model)\n\nReturn the lower-level MathOptInterface model that sits underneath JuMP. This model depends on which operating mode JuMP is in (manual, automatic, or direct), and whether there are any bridges in the model.\n\nIf JuMP is in direct mode (i.e., the model was created using direct_model), the backend with be the optimizer passed to direct_model. If JuMP is in manual or automatic mode, the backend is a MOI.Utilities.CachingOptimizer.\n\nThis function should only be used by advanced users looking to access low-level MathOptInterface or solver-specific functionality.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#Solver-attributes-1","page":"Solvers","title":"Solver attributes","text":"","category":"section"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"Some solver attributes can be queried and set through JuMP models.","category":"page"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"solver_name\n\nbridge_constraints\n\nget_optimizer_attribute\nset_optimizer_attribute\nset_optimizer_attributes\nset_silent\nunset_silent\nset_time_limit_sec\nunset_time_limit_sec\ntime_limit_sec","category":"page"},{"location":"solvers/#JuMP.solver_name","page":"Solvers","title":"JuMP.solver_name","text":"solver_name(model::Model)\n\nIf available, returns the SolverName property of the underlying optimizer. Returns \"No optimizer attached\" in AUTOMATIC or MANUAL modes when no optimizer is attached. Returns \"SolverName() attribute not implemented by the optimizer.\" if the attribute is not implemented.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#JuMP.bridge_constraints","page":"Solvers","title":"JuMP.bridge_constraints","text":"bridge_constraints(model::Model)\n\nWhen in direct mode, return false. When in manual or automatic mode, return a Bool indicating whether the optimizer is set and unsupported constraints are automatically bridged to equivalent supported constraints when an appropriate transformation is available.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#JuMP.get_optimizer_attribute","page":"Solvers","title":"JuMP.get_optimizer_attribute","text":"get_optimizer_attribute(model, name::String)\n\nReturn the value associated with the solver-specific attribute named name.\n\nNote that this is equivalent to get_optimizer_attribute(model, MOI.RawParameter(name)).\n\nExample\n\njulia get_optimizer_attribute(model, \"SolverSpecificAttributeName\")`\n\nSee also: set_optimizer_attribute, set_optimizer_attributes.\n\n\n\n\n\nget_optimizer_attribute(\n    model::Model, attr::MOI.AbstractOptimizerAttribute\n)\n\nReturn the value of the solver-specific attribute attr in model.\n\nExample\n\njulia get_optimizer_attribute(model, MOI.Silent())`\n\nSee also: set_optimizer_attribute, set_optimizer_attributes.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#JuMP.set_optimizer_attribute","page":"Solvers","title":"JuMP.set_optimizer_attribute","text":"set_optimizer_attribute(model::Model, name::String, value)\n\nSets solver-specific attribute identified by name to value.\n\nNote that this is equivalent to set_optimizer_attribute(model, MOI.RawParameter(name), value).\n\nExample\n\nset_optimizer_attribute(model, \"SolverSpecificAttributeName\", true)\n\nSee also: set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\nset_optimizer_attribute(\n    model::Model, attr::MOI.AbstractOptimizerAttribute, value\n)\n\nSet the solver-specific attribute attr in model to value.\n\nExample\n\nset_optimizer_attribute(model, MOI.Silent(), true)\n\nSee also: set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#JuMP.set_optimizer_attributes","page":"Solvers","title":"JuMP.set_optimizer_attributes","text":"set_optimizer_attributes(model::Model, pairs::Pair...)\n\nGiven a list of attribute => value pairs, calls set_optimizer_attribute(model, attribute, value) for each pair.\n\nExample\n\nmodel = Model(Ipopt.Optimizer)\nset_optimizer_attributes(model, \"tol\" => 1e-4, \"max_iter\" => 100)\n\nis equivalent to:\n\nmodel = Model(Ipopt.Optimizer)\nset_optimizer_attribute(model, \"tol\", 1e-4)\nset_optimizer_attribute(model, \"max_iter\", 100)\n\nSee also: set_optimizer_attribute, get_optimizer_attribute.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#JuMP.set_silent","page":"Solvers","title":"JuMP.set_silent","text":"set_silent(model::Model)\n\nTakes precedence over any other attribute controlling verbosity and requires the solver to produce no output.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#JuMP.unset_silent","page":"Solvers","title":"JuMP.unset_silent","text":"unset_silent(model::Model)\n\nNeutralize the effect of the set_silent function and let the solver attributes control the verbosity.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#JuMP.set_time_limit_sec","page":"Solvers","title":"JuMP.set_time_limit_sec","text":"set_time_limit_sec(model::Model, limit)\n\nSets the time limit (in seconds) of the solver. Can be unset using unset_time_limit_sec or with limit set to nothing.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#JuMP.unset_time_limit_sec","page":"Solvers","title":"JuMP.unset_time_limit_sec","text":"unset_time_limit_sec(model::Model)\n\nUnsets the time limit of the solver. Can be set using set_time_limit_sec.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#JuMP.time_limit_sec","page":"Solvers","title":"JuMP.time_limit_sec","text":"time_limit_sec(model::Model)\n\nGets the time limit (in seconds) of the model (nothing if unset). Can be set using set_time_limit_sec.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#File-formats-1","page":"Solvers","title":"File formats","text":"","category":"section"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"JuMP can write models to a variety of file-formats using write_to_file and Base.write.","category":"page"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"write_to_file\nBase.write(::IO, ::Model; ::MOI.FileFormats.FileFormat)","category":"page"},{"location":"solvers/#JuMP.write_to_file","page":"Solvers","title":"JuMP.write_to_file","text":"write_to_file(\n    model::Model,\n    filename::String;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_AUTOMATIC\n)\n\nWrite the JuMP model model to filename in the format format.\n\nIf the filename ends in .gz, it will be compressed using Gzip. If the filename ends in .bz2, it will be compressed using BZip2.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#Base.write-Tuple{IO,Model}","page":"Solvers","title":"Base.write","text":"Base.write(\n    io::IO,\n    model::Model;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_MOF\n)\n\nWrite the JuMP model model to io in the format format.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"JuMP models can be created from file formats using read_from_file and Base.read.","category":"page"},{"location":"solvers/#","page":"Solvers","title":"Solvers","text":"read_from_file\nBase.read(::IO, ::Type{Model}; ::MOI.FileFormats.FileFormat)","category":"page"},{"location":"solvers/#JuMP.read_from_file","page":"Solvers","title":"JuMP.read_from_file","text":"read_from_file(\n    filename::String;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_AUTOMATIC\n)\n\nReturn a JuMP model read from filename in the format format.\n\nIf the filename ends in .gz, it will be uncompressed using Gzip. If the filename ends in .bz2, it will be uncompressed using BZip2.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#Base.read-Tuple{IO,Type{Model}}","page":"Solvers","title":"Base.read","text":"Base.read(io::IO, ::Type{Model}; format::MOI.FileFormats.FileFormat)\n\nReturn a JuMP model read from io in the format format.\n\n\n\n\n\n","category":"method"},{"location":"roadmap/#Development-roadmap-1","page":"Development Roadmap","title":"Development roadmap","text":"","category":"section"},{"location":"roadmap/#","page":"Development Roadmap","title":"Development Roadmap","text":"This page is not JuMP documentation per se but are notes for the JuMP community. The JuMP developers have compiled this roadmap document to share their plans and goals. Contributions to roadmap issues are especially invited.","category":"page"},{"location":"roadmap/#JuMP-1.0-1","page":"Development Roadmap","title":"JuMP 1.0","text":"","category":"section"},{"location":"roadmap/#","page":"Development Roadmap","title":"Development Roadmap","text":"JuMP 1.0 will be ready to release roughly when all of these tasks are completed. Some but not all of these tasks are summarized in the JuMP 1.0 milestone.","category":"page"},{"location":"roadmap/#","page":"Development Roadmap","title":"Development Roadmap","text":"Create a website for JuMP.\nDeprecate the JuliaOpt organization and move repositories to the JuMP-dev organization.\nAddress major regressions from JuMP 0.18.\nPerformance (#1403,              #1654,              #1607)\nCallbacks\nColumn generation syntax (Done: see examples/cutting_stock_column_generation.jl)\nSupport for second-order cones in Gurobi, CPLEX, and Xpress.\nFix issues that we promised MOI would fix.\nChecking feasibility of solutions (#693)\nAccessing IIS (#1053)\nAccessing multiple results from solvers\nDual warm-starts (#2094)\nAddress “easy” usability issues\nLine numbers in error messages (#1174)\nLP sensitivity summary (Done: see Sensitivity analysis for LP)\nInferred element types for collections in macros (Done: #2070)\nExpose solver-independent options from JuMP (Done: see set_silent etc.)\nImprove the documentation (#1062)\nSeparate how-to, concept explanation, and technical reference following the Divio recommendations\nFully integrate JuMPTutorials with JuMP's documentation.\nDeveloper experience\nGet JuMP’s unit tests running in less than two minutes. See #1745.\nAll solvers should complete the transition to MOI.\nProvide packages for installing Bonmin and Couenne.\nMathOptFormat 1.0","category":"page"},{"location":"roadmap/#MOI-1.0-1","page":"Development Roadmap","title":"MOI 1.0","text":"","category":"section"},{"location":"roadmap/#","page":"Development Roadmap","title":"Development Roadmap","text":"# TODO: List MOI 1.0 items here.","category":"page"},{"location":"roadmap/#Beyond-JuMP-1.0-1","page":"Development Roadmap","title":"Beyond JuMP 1.0","text":"","category":"section"},{"location":"roadmap/#","page":"Development Roadmap","title":"Development Roadmap","text":"# TODO: Copy over list of items not tied to JuMP 1.0. These should have more\n# elaborate explanations so that potential contributors know what we mean,\n# i.e., a few sentences each or a link to a document/issue.","category":"page"},{"location":"containers/#","page":"Containers","title":"Containers","text":"DocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"containers/#Containers-1","page":"Containers","title":"Containers","text":"","category":"section"},{"location":"containers/#","page":"Containers","title":"Containers","text":"JuMP provides a specialized container similar to AxisArrays that enables indexing with non-integer indices. Normally these are created automatically by JuMP's macros. The following constructors can be used to create them manually.","category":"page"},{"location":"containers/#","page":"Containers","title":"Containers","text":"JuMP.Containers.DenseAxisArray\nJuMP.Containers.SparseAxisArray","category":"page"},{"location":"containers/#JuMP.Containers.DenseAxisArray","page":"Containers","title":"JuMP.Containers.DenseAxisArray","text":"DenseAxisArray(data::Array{T, N}, axes...) where {T, N}\n\nConstruct a JuMP array with the underlying data specified by the data array and the given axes. Exactly N axes must be provided, and their lengths must match size(data) in the corresponding dimensions.\n\nExample\n\njulia> array = JuMP.Containers.DenseAxisArray([1 2; 3 4], [:a, :b], 2:3)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 2:3\nAnd data, a 2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> array[:b, 3]\n4\n\n\n\n\n\nDenseAxisArray{T}(undef, axes...) where T\n\nConstruct an uninitialized DenseAxisArray with element-type T indexed over the given axes.\n\nExample\n\njulia> array = JuMP.Containers.DenseAxisArray{Float64}(undef, [:a, :b], 1:2);\n\njulia> fill!(array, 1.0)\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 1:2\nAnd data, a 2×2 Array{Float64,2}:\n 1.0  1.0\n 1.0  1.0\n\njulia> array[:a, 2] = 5.0\n5.0\n\njulia> array[:a, 2]\n5.0\n\njulia> array\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 1:2\nAnd data, a 2×2 Array{Float64,2}:\n 1.0  5.0\n 1.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"containers/#JuMP.Containers.SparseAxisArray","page":"Containers","title":"JuMP.Containers.SparseAxisArray","text":"struct SparseAxisArray{T,N,K<:NTuple{N, Any}} <: AbstractArray{T,N}\n    data::Dict{K,T}\nend\n\nN-dimensional array with elements of type T where only a subset of the entries are defined. The entries with indices idx = (i1, i2, ..., iN) in keys(data) has value data[idx]. Note that as opposed to SparseArrays.AbstractSparseArray, the missing entries are not assumed to be zero(T), they are simply not part of the array. This means that the result of map(f, sa::SparseAxisArray) or f.(sa::SparseAxisArray) has the same sparsity structure than sa even if f(zero(T)) is not zero.\n\nExample\n\njulia> dict = Dict((:a, 2) => 1.0, (:a, 3) => 2.0, (:b, 3) => 3.0)\nDict{Tuple{Symbol,Int64},Float64} with 3 entries:\n  (:b, 3) => 3.0\n  (:a, 2) => 1.0\n  (:a, 3) => 2.0\n\njulia> array = JuMP.Containers.SparseAxisArray(dict)\nJuMP.Containers.SparseAxisArray{Float64,2,Tuple{Symbol,Int64}} with 3 entries:\n  [b, 3]  =  3.0\n  [a, 2]  =  1.0\n  [a, 3]  =  2.0\n\njulia> array[:b, 3]\n3.0\n\n\n\n\n\n","category":"type"},{"location":"containers/#Containers-in-macros-1","page":"Containers","title":"Containers in macros","text":"","category":"section"},{"location":"containers/#","page":"Containers","title":"Containers","text":"The container function encodes the logic for how containers are constructed in JuMP's macros. The @container macro is available to create containers independently of any JuMP model.","category":"page"},{"location":"containers/#","page":"Containers","title":"Containers","text":"JuMP.Containers.container\nJuMP.Containers.default_container\nJuMP.Containers.VectorizedProductIterator\nJuMP.Containers.NestedIterator\nJuMP.Containers.@container","category":"page"},{"location":"containers/#JuMP.Containers.container","page":"Containers","title":"JuMP.Containers.container","text":"container(f::Function, indices, ::Type{C})\n\nCreate a container of type C with indices indices and values at given indices given by f.\n\ncontainer(f::Function, indices)\n\nCreate a container with indices indices and values at given indices given by f. The type of container used is determined by default_container.\n\nExamples\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(Base.OneTo(3), Base.OneTo(3)))\n3×3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(1:3, 1:3))\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, 1:3\nAnd data, a 3×3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(2:3, Base.OneTo(3)))\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, Base.OneTo(3)\nAnd data, a 2×3 Array{Int64,2}:\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.nested(() -> 1:3, i -> i:3, condition = (i, j) -> isodd(i) || isodd(j)))\nSparseAxisArray{Int64,2,Tuple{Int64,Int64}} with 5 entries:\n  [1, 2]  =  3\n  [2, 3]  =  5\n  [3, 3]  =  6\n  [1, 1]  =  2\n  [1, 3]  =  4\n\n\n\n\n\n","category":"function"},{"location":"containers/#JuMP.Containers.default_container","page":"Containers","title":"JuMP.Containers.default_container","text":"default_container(indices)\n\nIf indices is a NestedIterator, return a SparseAxisArray. Otherwise, indices should be a VectorizedProductIterator and the function returns Array if all iterators of the product are Base.OneTo and retunrs DenseAxisArray otherwise.\n\n\n\n\n\n","category":"function"},{"location":"containers/#JuMP.Containers.VectorizedProductIterator","page":"Containers","title":"JuMP.Containers.VectorizedProductIterator","text":"struct VectorizedProductIterator{T}\n    prod::Iterators.ProductIterator{T}\nend\n\nCartesian product of the iterators prod.iterators. It is the same iterator as Base.Iterators.ProductIterator except that it is independent of the IteratorSize of the elements of prod.iterators. For instance:\n\nsize(Iterators.product(1, 2)) is tuple() while size(VectorizedProductIterator(1, 2)) is (1, 1).\nsize(Iterators.product(ones(2, 3))) is (2, 3) while size(VectorizedProductIterator(ones(2, 3))) is (1, 1).\n\n\n\n\n\n","category":"type"},{"location":"containers/#JuMP.Containers.NestedIterator","page":"Containers","title":"JuMP.Containers.NestedIterator","text":"struct NestedIterator{T}\n    iterators::T # Tuple of functions\n    condition::Function\nend\n\nIterators over the tuples that are produced by a nested for loop. For instance, if length(iterators) == 3 , this corresponds to the tuples (i1, i2, i3) produced by:\n\nfor i1 in iterators[1]()\n    for i2 in iterator[2](i1)\n        for i3 in iterator[3](i1, i2)\n            if condition(i1, i2, i3)\n                # produces (i1, i2, i3)\n            end\n        end\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"containers/#JuMP.Containers.@container","page":"Containers","title":"JuMP.Containers.@container","text":"@container([i=..., j=..., ...], expr)\n\nCreate a container with indices i, j, ... and values given by expr that may depend on the value of the indices.\n\n@container(ref[i=..., j=..., ...], expr)\n\nSame as above but the container is assigned to the variable of name ref.\n\nThe type of container can be controlled by the container keyword. See Containers in macros. Note that when the index set is explicitly given as 1:n for any expression n, it is transformed to Base.OneTo(n) before being given to container.\n\nExamples\n\njulia> Containers.@container([i = 1:3, j = 1:3], i + j)\n3×3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> I = 1:3\n1:3\n\njulia> Containers.@container([i = I, j = I], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, 1:3\nAnd data, a 3×3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.@container([i = 2:3, j = 1:3], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, Base.OneTo(3)\nAnd data, a 2×3 Array{Int64,2}:\n 3  4  5\n 4  5  6\n\njulia> Containers.@container([i = 1:3, j = 1:3; i <= j], i + j)\nJuMP.Containers.SparseAxisArray{Int64,2,Tuple{Int64,Int64}} with 6 entries:\n  [1, 2]  =  3\n  [2, 3]  =  5\n  [3, 3]  =  6\n  [2, 2]  =  4\n  [1, 1]  =  2\n  [1, 3]  =  4\n\n\n\n\n\n","category":"macro"},{"location":"containers/#","page":"Containers","title":"Containers","text":"In the @variable (resp. @constraint) macro, containers of variables (resp. constraints) can be created with the following syntax:","category":"page"},{"location":"containers/#","page":"Containers","title":"Containers","text":"name[index_set_1, index_set_2, ..., index_set_n] creating an n-dimensional container of name name; or\n[index_set_1, index_set_2, ..., index_set_n] creating an anonymous n-dimensional container.","category":"page"},{"location":"containers/#","page":"Containers","title":"Containers","text":"Each expression index_set_i can either be","category":"page"},{"location":"containers/#","page":"Containers","title":"Containers","text":"of the form index_set specifying that the ith index set of the container is index_set; or\nof the form index_name=index_set specifying that the ith index set of the container is index_set and allowing values used in the macro expression and keyword arguments to be expressions depending on the index_name.","category":"page"},{"location":"containers/#","page":"Containers","title":"Containers","text":"The macro then creates the container using the JuMP.Containers.container function with the following arguments:","category":"page"},{"location":"containers/#","page":"Containers","title":"Containers","text":"A function taking as argument the value of the indices and returning the value to be stored in the container, e.g. a variable for the @variable macro and a constraint for the @constraint macro.\nAn iterator over the indices of the container.\nThe value of the container keyword argument if given.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"constraints/#Constraints-1","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"This page explains how to write various types of constraints in JuMP. Before reading further, please make sure you are familiar with JuMP models, and JuMP Variables. For nonlinear constraints, see Nonlinear Modeling instead.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"JuMP is based on the MathOptInterface (MOI) API. Because of this, JuMP thinks of a constraint as the restriction that the output of a function belongs to a set. For example, instead of representing a constraint a^top x le b as a less-than-or-equal-to constraint, JuMP models this as the scalar affine function a^top x belonging to the less-than set (-infty b. Thus, instead of a less-than-or-equal-to constraint, we consider this constraint to be a scalar affine -in- less than constraint. More generally, we use the shorthand function-in-set to refer to constraints composed of different types of functions and sets. In the rest of this page, we will introduce the different types of functions and sets that JuMP knows about as needed. You can read more details about this function-in-set concept in the MOI documentation.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"note: Note\nThe examples use MOI as an alias for the MathOptInterface module. This alias is defined by using JuMP. You may also define it in your code byimport MathOptInterface\nconst MOI = MathOptInterface","category":"page"},{"location":"constraints/#The-@constraint-macro-1","page":"Constraints","title":"The @constraint macro","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Constraints are added to a JuMP model using the @constraint macro. Here is an example of how to add the constraint 2x le 1 to a JuMP model:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Wasn't that easy! Let's unpack what happened, because just like @variable there are a few subtle things going on.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"The mathematical constraint 2x le 1 was added to the model.\nA Julia variable called con was created that is a reference to the constraint.\nThis Julia variable was stored in model and can be accessed by model[:con].\nJuMP set the name attribute (the one that is shown when printing) of the constraint to \"con\".","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Just like the Julia variables created in @variable, con can be bound to a different value. For example:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> con\ncon : 2 x <= 1.0\n\njulia> con = 1\n1\n\njulia> con\n1","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"However, the reference can be retrieved by querying the model using the symbolic name:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> con = model[:con]\ncon : 2 x <= 1.0\n\njulia> con\ncon : 2 x <= 1.0","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Because the named variables and constraints are stored in the same namespace, creating a constraint with the same name as a variable or an existing constraint will result in an error. To overcome this limitation, it is possible to create anonymous constraints, just like it is possible to create Anonymous JuMP variables. This is done by dropping the second argument to @constraint:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> con = @constraint(model, 2x <= 1)\n2 x <= 1.0","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"It is also possible use different comparison operators (e.g., >= and ==) to create the following types of constraints:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, 2x >= 1)\n2 x >= 1.0\n\njulia> @constraint(model, 2x == 1)\n2 x = 1.0\n\njulia> @constraint(model, 1 <= 2x <= 3)\n2 x ∈ [1.0, 3.0]","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Note that JuMP normalizes the constraints by moving all of the terms containing variables to the left-hand side, and all of the constant terms to the right-hand side. Thus, we get:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, 2x + 1 <= 4x + 4)\n-2 x <= 3.0","category":"page"},{"location":"constraints/#The-@constraints-macro-1","page":"Constraints","title":"The @constraints macro","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Like @variables, there is a \"plural\" version of the @constraint macro:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraints(model, begin\n           2x <=  1\n            x >= -1\n       end)\n\njulia> print(model)\nFeasibility\nSubject to\n x ≥ -1.0\n 2 x ≤ 1.0","category":"page"},{"location":"constraints/#constraint_duality-1","page":"Constraints","title":"Duality","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"JuMP adopts the notion of conic duality from MOI. For linear programs, a feasible dual on a >= constraint is nonnegative and a feasible dual on a <= constraint is nonpositive. If the constraint is an equality constraint, it depends on which direction is binding.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"note: Note\nJuMP's definition of duality is independent of the objective sense. That is, the sign of feasible duals associated with a constraint depends on the direction of the constraint and not whether the problem is maximization or minimization. This is a different convention from linear programming duality in some common textbooks.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"The dual value associated with a constraint in the most recent solution can be accessed using the dual function. You can use the has_duals function to check whether the model has a dual solution available to query. For example:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x <= 1)\ncon : x <= 1.0\n\njulia> has_duals(model)\nfalse","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"DocTestSetup = quote\n    using JuMP\n    model = Model(() -> MOIU.MockOptimizer(\n                            MOIU.Model{Float64}(),\n                            eval_objective_value = false,\n                            eval_variable_constraint_dual = false));\n    @variable(model, x);\n    @constraint(model, con, x <= 1);\n    @objective(model, Max, -2x);\n    optimize!(model);\n    mock = backend(model).optimizer.model;\n    MOI.set(mock, MOI.TerminationStatus(), MOI.OPTIMAL)\n    MOI.set(mock, MOI.DualStatus(), MOI.FEASIBLE_POINT)\n    MOI.set(mock, MOI.ConstraintDual(), optimizer_index(con), -2.0)\nend","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @objective(model, Min, -2x)\n-2 x\n\njulia> optimize!(model)\n\njulia> has_duals(model)\ntrue\n\njulia> dual(con)\n-2.0\n\njulia> @objective(model, Max, 2x)\n2 x\n\njulia> optimize!(model)\n\njulia> dual(con)\n-2.0","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"To help users who may be less familiar with conic duality, JuMP provides the shadow_price function which returns a value that can be interpreted as the improvement in the objective in response to an infinitesimal relaxation (on the scale of one unit) in the right-hand side of the constraint. shadow_price can be used only on linear constraints with a <=, >=, or == comparison operator.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"In the example above, dual(con) returned -2.0 regardless of the optimization sense. However, in the second case when the optimization sense is Max, shadow_price returns:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> shadow_price(con)\n2.0","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"To query the dual variables associated with a variable bound, first obtain a constraint reference using one of UpperBoundRef, LowerBoundRef, or FixRef, and then call dual on the returned constraint reference. Note that in linear programming, the duals on variable bounds are also called the reduced costs (although the sign might differ from the one you expect).","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"DocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"constraints/#Constraint-names-1","page":"Constraints","title":"Constraint names","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"The name, i.e. the value of the MOI.ConstraintName attribute, of a constraint can be obtained by name(::JuMP.ConstraintRef) and set by set_name(::JuMP.ConstraintRef, ::String).","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"name(::JuMP.ConstraintRef{Model, <:JuMP.MOI.ConstraintIndex})\nset_name(::JuMP.ConstraintRef{Model, <:JuMP.MOI.ConstraintIndex}, ::String)","category":"page"},{"location":"constraints/#JuMP.name-Tuple{ConstraintRef{Model,#s313,Shape} where Shape<:AbstractShape where #s313<:MathOptInterface.ConstraintIndex}","page":"Constraints","title":"JuMP.name","text":"name(con_ref::ConstraintRef)\n\nGet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#JuMP.set_name-Tuple{ConstraintRef{Model,#s313,Shape} where Shape<:AbstractShape where #s313<:MathOptInterface.ConstraintIndex,String}","page":"Constraints","title":"JuMP.set_name","text":"set_name(con_ref::ConstraintRef, s::AbstractString)\n\nSet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"The constraint can also be retrieved from its name using constraint_by_name.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"constraint_by_name","category":"page"},{"location":"constraints/#JuMP.constraint_by_name","page":"Constraints","title":"JuMP.constraint_by_name","text":"constraint_by_name(model::AbstractModel,\n                   name::String)::Union{ConstraintRef, Nothing}\n\nReturns the reference of the constraint with name attribute name or Nothing if no constraint has this name attribute. Throws an error if several constraints have name as their name attribute.\n\nconstraint_by_name(model::AbstractModel,\n                   name::String,\n                   F::Type{<:Union{AbstractJuMPScalar,\n                                   Vector{<:AbstractJuMPScalar},\n                                   MOI.AbstactFunction}},\n                   S::Type{<:MOI.AbstractSet})::Union{ConstraintRef, Nothing}\n\nSimilar to the method above, except that it throws an error if the constraint is not an F-in-S contraint where F is either the JuMP or MOI type of the function, and S is the MOI type of the set. This method is recommended if you know the type of the function and set since its returned type can be inferred while for the method above (i.e. without F and S), the exact return type of the constraint index cannot be inferred.\n\njulia> using JuMP\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x^2 == 1)\ncon : x² = 1.0\n\njulia> constraint_by_name(model, \"kon\")\n\njulia> constraint_by_name(model, \"con\")\ncon : x² = 1.0\n\njulia> constraint_by_name(model, \"con\", AffExpr, MOI.EqualTo{Float64})\n\njulia> constraint_by_name(model, \"con\", QuadExpr, MOI.EqualTo{Float64})\ncon : x² = 1.0\n\n\n\n\n\n","category":"function"},{"location":"constraints/#Constraint-containers-1","page":"Constraints","title":"Constraint containers","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"So far, we've added constraints one-by-one. However, just like Variable containers, JuMP provides a mechanism for building groups of constraints compactly. References to these groups of constraints are returned in containers. Three types of constraint containers are supported: Arrays, DenseAxisArrays, and SparseAxisArrays. We explain each of these in the following.","category":"page"},{"location":"constraints/#constraint_arrays-1","page":"Constraints","title":"Arrays","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"One way of adding a group of constraints compactly is the following:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con[i = 1:3], i * x <= i + 1)\n3-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n con[1] : x <= 2.0\n con[2] : 2 x <= 3.0\n con[3] : 3 x <= 4.0","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"JuMP returns references to the three constraints in an Array that is bound to the Julia variable con. This array can be accessed and sliced as you would with any Julia array:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> con[1]\ncon[1] : x <= 2.0\n\njulia> con[2:3]\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n con[2] : 2 x <= 3.0\n con[3] : 3 x <= 4.0","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Anonymous containers can also be constructed by dropping the name (e.g. con) before the square brackets:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, [i = 1:2], i * x <= i + 1)\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n x <= 2.0\n 2 x <= 3.0","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Just like @variable, JuMP will form an Array of constraints when it can determine at parse time that the indices are one-based integer ranges. Therefore con[1:b] will create an Array, but con[a:b] will not. A special case is con[Base.OneTo(n)] which will produce an Array. If JuMP cannot determine that the indices are one-based integer ranges (e.g., in the case of con[a:b]), JuMP will create a DenseAxisArray instead.","category":"page"},{"location":"constraints/#DenseAxisArrays-1","page":"Constraints","title":"DenseAxisArrays","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"The syntax for constructing a DenseAxisArray of constraints is very similar to the syntax for constructing a DenseAxisArray of variables.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con[i = 1:2, j = 2:3], i * x <= j + 1)\n2-dimensional DenseAxisArray{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, 2:3\nAnd data, a 2×2 Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},2}:\n con[1,2] : x <= 3.0    con[1,3] : x <= 4.0\n con[2,2] : 2 x <= 3.0  con[2,3] : 2 x <= 4.0","category":"page"},{"location":"constraints/#SparseAxisArrays-1","page":"Constraints","title":"SparseAxisArrays","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"The syntax for constructing a SparseAxisArray of constraints is very similar to the syntax for constructing a SparseAxisArray of variables.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con[i = 1:2, j = 1:2; i != j], i * x <= j + 1)\nJuMP.Containers.SparseAxisArray{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},2,Tuple{Int64,Int64}} with 2 entries:\n  [1, 2]  =  con[1,2] : x <= 3.0\n  [2, 1]  =  con[2,1] : 2 x <= 2.0","category":"page"},{"location":"constraints/#Forcing-the-container-type-1","page":"Constraints","title":"Forcing the container type","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"When creating a container of constraints, JuMP will attempt to choose the tightest container type that can store the constraints. However, because this happens at parse time, it does not always make the best choice. Just like in @variable, we can force the type of container using the container keyword. For syntax and the reason behind this, take a look at the variable docs.","category":"page"},{"location":"constraints/#Vectorized-constraints-1","page":"Constraints","title":"Vectorized constraints","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"We can also add constraints to JuMP using vectorized linear algebra. For example:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[i=1:2])\n2-element Array{VariableRef,1}:\n x[1]\n x[2]\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> b = [5, 6]\n2-element Array{Int64,1}:\n 5\n 6\n\njulia> @constraint(model, con, A * x .== b)\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}},ScalarShape},1}:\n x[1] + 2 x[2] == 5.0\n 3 x[1] + 4 x[2] == 6.0","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"note: Note\nMake sure to use Julia's dot syntax in front of the comparison operators (e.g. .==, .>=, and .<=). If you use a comparison without the dot, an error will be thrown.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Instead of adding an array of ScalarAffineFunction-in-EqualTo constraints, we can instead construct a VectorAffineFunction-in-Nonnegatives constraint as follows:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, A * x - b in MOI.Nonnegatives(2))\n[x[1] + 2 x[2] - 5, 3 x[1] + 4 x[2] - 6] in MathOptInterface.Nonnegatives(2)","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"In addition to the Nonnegatives set, MOI defines a number of other vector-valued sets such as Nonpositives. See the MOI documentation for more information.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Note also that for the first time we have used an explicit function-in-set description of the constraint. Read more about this representation for constraints in the MOI documentation.","category":"page"},{"location":"constraints/#Constraints-on-a-single-variable-1","page":"Constraints","title":"Constraints on a single variable","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"In Variables, we saw how to modify the variable bounds, as well as add binary and integer restrictions to the domain of each variable. This can also be achieved using the @constraint macro. For example, MOI.ZeroOne() restricts the domain to 0 1:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.ZeroOne())\nx binary","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"and MOI.Integer() restricts to the domain to the integers mathbbZ:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.Integer())\nx integer","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"JuMP also supports modeling semi-continuous variables, whose domain is 0  l u, using the MOI.Semicontinuous set:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.Semicontinuous(1.5, 3.5))\nx in MathOptInterface.Semicontinuous{Float64}(1.5, 3.5)","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"as well as semi-integer variables, whose domain is 0  l l+1 dots u, using the MOI.Semiinteger set:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.Semiinteger(1.0, 3.0))\nx in MathOptInterface.Semiinteger{Float64}(1.0, 3.0)","category":"page"},{"location":"constraints/#Quadratic-constraints-1","page":"Constraints","title":"Quadratic constraints","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"In addition to affine functions, JuMP also supports constraints with quadratic terms. (For more general nonlinear functions, see Nonlinear Modeling.) For example:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[i=1:2])\n2-element Array{VariableRef,1}:\n x[1]\n x[2]\n\njulia> @variable(model, t >= 0)\nt\n\njulia> @constraint(model, x[1]^2 + x[2]^2 <= t^2)\nx[1]² + x[2]² - t² <= 0.0","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Note that this quadratic constraint (including the lower bound on t) is equivalent to a second order cone constraint where ||x[1]^2 + x[2]^2||\\_2 ≤ t and t ≥ 0. Instead of writing out the quadratic expansion, we can pass JuMP the constraint in function-in-set form. To do so, we need to define the function and the set.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"The function is a vector of variables:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> [t, x[1], x[2]]\n3-element Array{VariableRef,1}:\n t\n x[1]\n x[2]","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Note that the variable t comes first, followed by the x arguments. The set is an instance of SecondOrderCone: SecondOrderCone(). Thus, we can add the second order cone constraint as follows:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, [t, x[1], x[2]] in SecondOrderCone())\n[t, x[1], x[2]] in MathOptInterface.SecondOrderCone(3)","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"JuMP also supports the RotatedSecondOrderCone which requires the addition of a perspective variable u. The rotated second order cone constraints the variables t, u, and x such that: ||x[1]^2 + x[2]^2||\\_2 ≤ t × u and t, u ≥ 0. It can be added as follows:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @variable(model, u)\nu\n\njulia> @constraint(model, [t, u, x[1], x[2]] in RotatedSecondOrderCone())\n[t, u, x[1], x[2]] in MathOptInterface.RotatedSecondOrderCone(4)","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"In addition to the second order cone and rotated second order cone, MOI defines a number of other conic sets such as the exponential and power cones. See the MathOptInterface documentation for more information.","category":"page"},{"location":"constraints/#Constraints-on-a-collection-of-variables-1","page":"Constraints","title":"Constraints on a collection of variables","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"In addition to constraining the domain of a single variable, JuMP supports placing constraints of a subset of the variables. We already saw an example of this in the Quadratic constraints section when we constrained a vector of variables to belong to the second order cone.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"In a special ordered set of type I (often denoted SOS-I), at most one variable can take a non-zero value. We can construct SOS-I constraints using the MOI.SOS1 set:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in MOI.SOS1([1.0, 2.0, 3.0]))\n[x[1], x[2], x[3]] in MathOptInterface.SOS1{Float64}([1.0, 2.0, 3.0])","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Note that we have to pass MOI.SOS1 a weight vector. This vector implies an ordering on the variables. If the decision variables are related and have a physical ordering (e.g., they correspond to the size of a factory to be built, and the SOS-I constraint enforces that only one factory can be built), then the weight vector, although not used directly in the constraint, can help the solver make a better decision in the solution process.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"This ordering is more important in a special ordered set of type II (SOS-II), in which at most two values can be non-zero, and if there are two non-zeros, they must be consecutive according to the ordering. For example, in the following constraint, the possible non-zero pairs are (x[1] and x[3]) and (x[2] and x[3]):","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.SOS2([3.0, 1.0, 2.0]))\n[x[1], x[2], x[3]] in MathOptInterface.SOS2{Float64}([3.0, 1.0, 2.0])","category":"page"},{"location":"constraints/#Indicator-constraints-1","page":"Constraints","title":"Indicator constraints","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"JuMP provides a special syntax for creating indicator constraints, that is, enforce a constraint to hold depending on the value of a binary variable. In order to constrain the constraint x + y <= 1 to hold when a binary variable a is one, use the following syntax:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @variable(model, a, Bin)\na\n\njulia> @constraint(model, a => {x + y <= 1})\na => {x + y ≤ 1.0}","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"If instead the constraint should hold when a is zero, simply add a ! or ¬ before the binary variable.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, !a => {x + y <= 1})\n!a => {x + y ≤ 1.0}","category":"page"},{"location":"constraints/#Semidefinite-constraints-1","page":"Constraints","title":"Semidefinite constraints","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"JuMP provides a special syntax for constraining a matrix to be symmetric positive semidefinite (PSD) with the @SDconstraint macro. In the context of this macro, the inequality A >= B between two square matrices A and B is understood as constraining A - B to be symmetric positive semidefinite.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x)\nx\n\njulia> @SDconstraint(model, [x 2x; 3x 4x] >= ones(2, 2))\n[x - 1    2 x - 1;\n 3 x - 1  4 x - 1] ∈ PSDCone()","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Solvers supporting such constraints usually expect to be given a matrix that is symbolically symmetric, that is, for which the expression in corresponding off-diagonal entries are the same. In our example, the expressions of entries (1, 2) and (2, 1) are respectively 2x - 1 and 3x - 1 which are different. To bridge the gap between the constraint modeled and what the solver expects, JuMP creates an equality constraint 3x - 1 == 2x - 1 and constrains the symmetric matrix [x - 1, 2 x - 1, 2 x - 1, 4 x - 1] to be positive semidefinite.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"note: Note\nIf the matrix provided is already symbolically symmetric, the equality constrains are equivalent to 0 = 0 and are not added. In practice, if all coefficients are smaller than 1e-10, the constraint is ignored, if all coefficients are smaller than 1e-8 but some are larger than 1e-10, it is ignored but a warning is displayed, otherwise if at least one coefficient is larger than 1e-8, the constraint is added.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"If the matrix is known to be symmetric, the PSD constraint can be added as follows:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> using LinearAlgebra\n\njulia> @constraint(model, Symmetric([x 2x; 2x 4x] - ones(2, 2)) in PSDCone())\n[x - 1    2 x - 1;\n 2 x - 1  4 x - 1] ∈ PSDCone()","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Note that the lower triangular entries are silently ignored even if they are different so use it with caution:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> cref = @constraint(model, Symmetric([x 2x; 3x 4x]) in PSDCone())\n[x    2 x;\n 2 x  4 x] ∈ PSDCone()\n\njulia> jump_function(constraint_object(cref))\n3-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x\n 2 x\n 4 x\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeTriangle(2)","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Note that as @SDconstraint(model, A >= B) constrains A - B to be symmetric positive semidefinite, even if A is a matrix of variables and B is a matrix of zeros, A - B will be a matrix of affine expressions. For instance, in the example below, the function is VectorAffineFunction instead of VectorOfVariables.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> typeof(@SDconstraint(model, [x x; x x] >= zeros(2, 2)))\nConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64},MathOptInterface.PositiveSemidefiniteConeSquare},SquareMatrixShape}","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Moreover, the Symmetric structure can be lost in the operation A - B. For instance, in the example below, the set is PositiveSemidefiniteConeSquare instead of PositiveSemidefiniteConeTriangle.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> typeof(@SDconstraint(model, Symmetric([x x; x x]) >= zeros(2, 2)))\nConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64},MathOptInterface.PositiveSemidefiniteConeSquare},SquareMatrixShape}","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"To create a constraint on the vector of variables with the @SDconstraint macro, use the 0 symbol. The following three syntax are equivalent:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"@SDconstraint(model, A >= 0),\n@SDconstraint(model, 0 <= A) and\n@constraint(model, A in PSDCone()).","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> typeof(@SDconstraint(model, [x x; x x] >= 0))\nConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables,MathOptInterface.PositiveSemidefiniteConeSquare},SquareMatrixShape}\n\njulia> typeof(@SDconstraint(model, 0 <= Symmetric([x x; x x])))\nConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables,MathOptInterface.PositiveSemidefiniteConeTriangle},SymmetricMatrixShape}","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"As the syntax is recognized at parse time, using a variable with value zero does not work:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> a = 0\n0\n\njulia> @SDconstraint(model, [x x; x x] >= a)\nERROR: Operation `-` between `Array{VariableRef,2}` and `Int64` is not allowed. You should use broadcast.\n[...]","category":"page"},{"location":"constraints/#Constraint-modifications-1","page":"Constraints","title":"Constraint modifications","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"A common paradigm, especially in linear programming, is to repeatedly solve a model with different coefficients.","category":"page"},{"location":"constraints/#Modifying-a-constant-term-1","page":"Constraints","title":"Modifying a constant term","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Use set_normalized_rhs to modify the right-hand side (constant) term of a constraint. Use normalized_rhs to query the right-hand side term.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0\n\njulia> set_normalized_rhs(con, 3)\n\njulia> con\ncon : 2 x <= 3.0\n\njulia> normalized_rhs(con)\n3.0","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"note: Note\nJuMP normalizes constraints into a standard form by moving all constant terms onto the right-hand side of the constraint.@constraint(model, 2x - 1 <= 2)will be normalized to@constraint(model, 2x <= 3)set_normalized_rhs sets the right-hand side term of the normalized constraint.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"If constraints are complicated, e.g., they are composed of a number of components, each of which has a constant term, then it may be difficult to calculate what the right-hand side term should be in the standard form.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"For this situation, JuMP includes the ability to fix variables to a value using the fix function. Fixing a variable sets its lower and upper bound to the same value. Thus, changes in a constant term can be simulated by adding a dummy variable and fixing it to different values. Here is an example:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @variable(model, const_term)\nconst_term\n\njulia> @constraint(model, con, 2x <= const_term + 1)\ncon : 2 x - const_term <= 1.0\n\njulia> fix(const_term, 1.0)","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"The constraint con is now equivalent to 2x <= 2.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"note: Note\nEven though const_term is fixed, it is still a decision variable. Thus, const_term * x is bilinear. Fixed variables are not replaced with constants when communicating the problem to a solver.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Another option is to use add_to_function_constant. The constant given is added to the function of a func-in-set constraint. In the following example, adding 2 to the function has the effect of removing 2 to the right-hand side:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0\n\njulia> add_to_function_constant(con, 2)\n\njulia> con\ncon : 2 x <= -1.0\n\njulia> normalized_rhs(con)\n-1.0","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"In the case of interval constraints, the constant is removed in each bounds.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 0 <= 2x + 1 <= 2)\ncon : 2 x ∈ [-1.0, 1.0]\n\njulia> add_to_function_constant(con, 3)\n\njulia> con\ncon : 2 x ∈ [-4.0, -2.0]","category":"page"},{"location":"constraints/#Modifying-a-variable-coefficient-1","page":"Constraints","title":"Modifying a variable coefficient","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"To modify the coefficients for a linear term in a constraint (but notably not yet the coefficients on a quadratic term), use set_normalized_coefficient. To query the current coefficient, use normalized_coefficient.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x[1] + x[2] <= 1)\ncon : 2 x[1] + x[2] ≤ 1.0\n\njulia> set_normalized_coefficient(con, x[2], 0)\n\njulia> con\ncon : 2 x[1] ≤ 1.0\n\njulia> normalized_coefficient(con, x[2])\n0.0","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"note: Note\nJuMP normalizes constraints into a standard form by moving all terms involving variables onto the left-hand side of the constraint.@constraint(model, 2x <= 1 - x)will be normalized to@constraint(model, 3x <= 1)set_normalized_coefficient sets the coefficient of the normalized constraint.","category":"page"},{"location":"constraints/#Constraint-deletion-1","page":"Constraints","title":"Constraint deletion","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Constraints can be deleted from a model using delete. Just like variable references, it is possible to check if a constraint reference is valid using is_valid. Here is an example of deleting a constraint:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0\n\njulia> is_valid(model, con)\ntrue\n\njulia> delete(model, con)\n\njulia> is_valid(model, con)\nfalse","category":"page"},{"location":"constraints/#Accessing-constraints-from-a-model-1","page":"Constraints","title":"Accessing constraints from a model","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"You can query the types of constraints currently present in the model by calling list_of_constraint_types. Then, given a function and set type, use num_constraints to access the number of constraints of this type and all_constraints to access a list of their references. Then use constraint_object to get an instance of an AbstractConstraint object, either ScalarConstraint or VectorConstraint, that stores the constraint data.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[i=1:2] >= i, Int);\n\njulia> @constraint(model, x[1] + x[2] <= 1);\n\njulia> list_of_constraint_types(model)\n3-element Array{Tuple{DataType,DataType},1}:\n (GenericAffExpr{Float64,VariableRef}, MathOptInterface.LessThan{Float64})\n (VariableRef, MathOptInterface.GreaterThan{Float64})\n (VariableRef, MathOptInterface.Integer)\n\njulia> num_constraints(model, VariableRef, MOI.Integer)\n2\n\njulia> all_constraints(model, VariableRef, MOI.Integer)\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.Integer},ScalarShape},1}:\n x[1] integer\n x[2] integer\n\njulia> num_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n2\n\njulia> all_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}},ScalarShape},1}:\n x[1] ≥ 1.0\n x[2] ≥ 2.0\n\njulia> num_constraints(model, GenericAffExpr{Float64,VariableRef}, MOI.LessThan{Float64})\n1\n\njulia> less_than_constraints = all_constraints(model, GenericAffExpr{Float64,VariableRef}, MOI.LessThan{Float64})\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n x[1] + x[2] ≤ 1.0\n\njulia> con = constraint_object(less_than_constraints[1])\nScalarConstraint{GenericAffExpr{Float64,VariableRef},MathOptInterface.LessThan{Float64}}(x[1] + x[2], MathOptInterface.LessThan{Float64}(1.0))\n\njulia> con.func\nx[1] + x[2]\n\njulia> con.set\nMathOptInterface.LessThan{Float64}(1.0)","category":"page"},{"location":"constraints/#Complementarity-constraints-1","page":"Constraints","title":"Complementarity constraints","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"A mixed complementarity constraint F(x) ⟂ x consists of finding x in the interval [lb, ub], such that the following holds:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"F(x) == 0 if lb < x < ub\nF(x) >= 0 if lb == x\nF(x) <= 0 if x == ub","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"For more information, see the MOI.Complements documentation.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"JuMP supports mixed complementarity constraints via complements(F(x), x) or F(x) ⟂ x in the @constraint macro. The interval set [lb, ub] is obtained from the variable bounds on x.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"For example, to define the problem 2x - 1 ⟂ x with x ∈ [0, ∞), do:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x >= 0)\nx\n\njulia> @constraint(model, 2x - 1 ⟂ x)\n[2 x - 1, x] ∈ MathOptInterface.Complements(1)","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"This problem has a unique solution at x = 0.5.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"The perp operator ⟂ can be entered in most editors (and the Julia REPL) by typing \\perp<tab>.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"An alternative approach that does not require the ⟂ symbol uses the complements function as follows:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, complements(2x - 1, x))\n[2 x - 1, x] ∈ MathOptInterface.Complements(1)","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"In both cases, the mapping F(x) is supplied as the first argument, and the matching variable x is supplied as the second.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Vector-valued complementarity constraints are also supported:","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"julia> @variable(model, -2 <= y[1:2] <= 2)\n2-element Array{VariableRef,1}:\n y[1]\n y[2]\n\njulia> M = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> q = [5, 6]\n2-element Array{Int64,1}:\n 5\n 6\n\njulia> @constraint(model, M * y + q ⟂ y)\n[y[1] + 2 y[2] + 5, 3 y[1] + 4 y[2] + 6, y[1], y[2]] ∈ MathOptInterface.Complements(2)","category":"page"},{"location":"constraints/#Reference-1","page":"Constraints","title":"Reference","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"@constraint\n@SDconstraint\nSecondOrderCone\nRotatedSecondOrderCone\nPSDCone\nshadow_price\nnormalized_coefficient\nset_normalized_coefficient\nnormalized_rhs\nset_normalized_rhs\nadd_to_function_constant\nis_valid\nJuMP.delete\nLowerBoundRef\nUpperBoundRef\nFixRef\nConstraintRef\nlist_of_constraint_types\nall_constraints\nnum_constraints\nconstraint_object\nAbstractConstraint\nScalarConstraint\nVectorConstraint\nindex(::ConstraintRef)\noptimizer_index(::ConstraintRef{Model})","category":"page"},{"location":"constraints/#JuMP.@constraint","page":"Constraints","title":"JuMP.@constraint","text":"@constraint(m::Model, expr)\n\nAdd a constraint described by the expression expr.\n\n@constraint(m::Model, ref[i=..., j=..., ...], expr)\n\nAdd a group of constraints described by the expression expr parametrized by i, j, ...\n\nThe expression expr can either be\n\nof the form func in set constraining the function func to belong to the set set which is either a MathOptInterface.AbstractSet or one of the JuMP shortcuts SecondOrderCone, RotatedSecondOrderCone and PSDCone, e.g. @constraint(model, [1, x-1, y-2] in SecondOrderCone()) constrains the norm of [x-1, y-2] be less than 1;\nof the form a sign b, where sign is one of ==, ≥, >=, ≤ and <= building the single constraint enforcing the comparison to hold for the expression a and b, e.g. @constraint(m, x^2 + y^2 == 1) constrains x and y to lie on the unit circle;\nof the form a ≤ b ≤ c or a ≥ b ≥ c (where ≤ and <= (resp. ≥ and >=) can be used interchangeably) constraining the paired the expression b to lie between a and c;\nof the forms @constraint(m, a .sign b) or @constraint(m, a .sign b .sign c) which broadcast the constraint creation to each element of the vectors.\n\nNote for extending the constraint macro\n\nEach constraint will be created using add_constraint(m, build_constraint(_error, func, set)) where\n\n_error is an error function showing the constraint call in addition to the error message given as argument,\nfunc is the expression that is constrained\nand set is the set in which it is constrained to belong.\n\nFor expr of the first type (i.e. @constraint(m, func in set)), func and set are passed unchanged to build_constraint but for the other types, they are determined from the expressions and signs. For instance, @constraint(m, x^2 + y^2 == 1) is transformed into add_constraint(m, build_constraint(_error, x^2 + y^2, MOI.EqualTo(1.0))).\n\nTo extend JuMP to accept new constraints of this form, it is necessary to add the corresponding methods to build_constraint. Note that this will likely mean that either func or set will be some custom type, rather than e.g. a Symbol, since we will likely want to dispatch on the type of the function or set appearing in the constraint.\n\n\n\n\n\n","category":"macro"},{"location":"constraints/#JuMP.@SDconstraint","page":"Constraints","title":"JuMP.@SDconstraint","text":"@SDconstraint(model::Model, expr)\n\nAdd a semidefinite constraint described by the expression expr.\n\n@SDconstraint(model::Model, ref[i=..., j=..., ...], expr)\n\nAdd a group of semidefinite constraints described by the expression expr parametrized by i, j, ...\n\nThe expression expr needs to be of the form a sign b where sign is ⪰, ≥, >=, ⪯, ≤ or <= and a and b are square matrices. It constrains the square matrix x (or -x if the sign is ⪯, ≤ or <=) to be symmetric and positive semidefinite where\n\nx = a, if b is the symbol 0,\nx = -b, if a is the symbol 0,\notherwise, x = a - b.\n\nBy default, we check numerical symmetry of the matrix x, and if symmetry is violated by some arbitrary amount, we add explicit equality constraints. You can use Symmetric(x) in PSDCone() with the @constraint macro to skip these checks if you know the matrix must be symmetric; see PSDCone for more information.\n\nExamples\n\nThe following constrains the matrix [x-1 2x-2; -3 x-4] to be symmetric and positive semidefinite, that is, it constrains 2x-2 to be equal to -3 and constrains all eigenvalues of the matrix to be nonnegative.\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> a = [x 2x\n            0  x];\n\njulia> b = [1 2\n            3 4];\n\njulia> cref = @SDconstraint(model, a ⪰ b)\n[x - 1  2 x - 2;\n -3     x - 4  ] ∈ PSDCone()\n\njulia> jump_function(constraint_object(cref))\n4-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n -3\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeSquare(2)\n\nIn the set PositiveSemidefiniteConeSquare(2) in the last output, Square means that the matrix is passed as a square matrix as the corresponding off-diagonal entries need to be constrained to be equal. A similar set PositiveSemidefiniteConeTriangle exists which only uses the upper triangular part of the matrix assuming that it is symmetric, see PSDCone to see how to use it.\n\n\n\n\n\n","category":"macro"},{"location":"constraints/#JuMP.SecondOrderCone","page":"Constraints","title":"JuMP.SecondOrderCone","text":"SecondOrderCone\n\nSecond order cone object that can be used to constrain the euclidean norm of a vector x to be less than or equal to a nonnegative scalar t. This is a shortcut for the MathOptInterface.SecondOrderCone.\n\nExamples\n\nThe following constrains (x-1 x-2)_2 le t and t ge 0:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, t)\nt\n\njulia> @constraint(model, [t, x-1, x-2] in SecondOrderCone())\n[t, x - 1, x - 2] ∈ MathOptInterface.SecondOrderCone(3)\n\n\n\n\n\n","category":"type"},{"location":"constraints/#JuMP.RotatedSecondOrderCone","page":"Constraints","title":"JuMP.RotatedSecondOrderCone","text":"RotatedSecondOrderCone\n\nRotated second order cone object that can be used to constrain the square of the euclidean norm of a vector x to be less than or equal to 2tu where t and u are nonnegative scalars. This is a shortcut for the MathOptInterface.RotatedSecondOrderCone.\n\nExamples\n\nThe following constrains (x-1 x-2)_2 le 2tx and t x ge 0:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, t)\nt\n\njulia> @constraint(model, [t, x, x-1, x-2] in RotatedSecondOrderCone())\n[t, x, x - 1, x - 2] ∈ MathOptInterface.RotatedSecondOrderCone(4)\n\n\n\n\n\n","category":"type"},{"location":"constraints/#JuMP.PSDCone","page":"Constraints","title":"JuMP.PSDCone","text":"PSDCone\n\nPositive semidefinite cone object that can be used to constrain a square matrix to be positive semidefinite in the @constraint macro. If the matrix has type Symmetric then the columns vectorization (the vector obtained by concatenating the columns) of its upper triangular part is constrained to belong to the MOI.PositiveSemidefiniteConeTriangle set, otherwise its column vectorization is constrained to belong to the MOI.PositiveSemidefiniteConeSquare set.\n\nExamples\n\nConsider the following example:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> a = [ x 2x\n            2x  x];\n\njulia> b = [1 2\n            2 4];\n\njulia> cref = @SDconstraint(model, a ⪰ b)\n[x - 1    2 x - 2;\n 2 x - 2  x - 4  ] ∈ PSDCone()\n\njulia> jump_function(constraint_object(cref))\n4-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n 2 x - 2\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeSquare(2)\n\nWe see in the output of the last command that the matrix the vectorization of the matrix is constrained to belong to the PositiveSemidefiniteConeSquare.\n\njulia> using LinearAlgebra # For Symmetric\n\njulia> cref = @constraint(model, Symmetric(a - b) in PSDCone())\n[x - 1    2 x - 2;\n 2 x - 2  x - 4  ] ∈ PSDCone()\n\njulia> jump_function(constraint_object(cref))\n3-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeTriangle(2)\n\nAs we see in the output of the last command, the vectorization of only the upper triangular part of the matrix is constrained to belong to the PositiveSemidefiniteConeSquare.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#JuMP.shadow_price","page":"Constraints","title":"JuMP.shadow_price","text":"shadow_price(con_ref::ConstraintRef)\n\nReturn the change in the objective from an infinitesimal relaxation of the constraint.\n\nThis value is computed from dual and can be queried only when has_duals is true and the objective sense is MIN_SENSE or MAX_SENSE (not FEASIBILITY_SENSE). For linear constraints, the shadow prices differ at most in sign from the dual value depending on the objective sense.\n\nNotes\n\nThe function simply translates signs from dual and does not validate the conditions needed to guarantee the sensitivity interpretation of the shadow price. The caller is responsible, e.g., for checking whether the solver converged to an optimal primal-dual pair or a proof of infeasibility.\nThe computation is based on the current objective sense of the model. If this has changed since the last solve, the results will be incorrect.\nRelaxation of equality constraints (and hence the shadow price) is defined based on which sense of the equality constraint is active.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#JuMP.normalized_coefficient","page":"Constraints","title":"JuMP.normalized_coefficient","text":"normalized_coefficient(con_ref::ConstraintRef, variable::VariableRef)\n\nReturn the coefficient associated with variable in constraint after JuMP has normalized the constraint into its standard form. See also set_normalized_coefficient.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#JuMP.set_normalized_coefficient","page":"Constraints","title":"JuMP.set_normalized_coefficient","text":"set_normalized_coefficient(con_ref::ConstraintRef, variable::VariableRef, value)\n\nSet the coefficient of variable in the constraint constraint to value.\n\nNote that prior to this step, JuMP will aggregate multiple terms containing the same variable. For example, given a constraint 2x + 3x <= 2, set_normalized_coefficient(con, x, 4) will create the constraint 4x <= 2.\n\nmodel = Model()\n@variable(model, x)\n@constraint(model, con, 2x + 3x <= 2)\nset_normalized_coefficient(con, x, 4)\ncon\n\n# output\n\ncon : 4 x <= 2.0\n\n\n\n\n\n","category":"function"},{"location":"constraints/#JuMP.normalized_rhs","page":"Constraints","title":"JuMP.normalized_rhs","text":"normalized_rhs(con_ref::ConstraintRef)\n\nReturn the right-hand side term of con_ref after JuMP has converted the constraint into its normalized form. See also set_normalized_rhs.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#JuMP.set_normalized_rhs","page":"Constraints","title":"JuMP.set_normalized_rhs","text":"set_normalized_rhs(con_ref::ConstraintRef, value)\n\nSet the right-hand side term of constraint to value.\n\nNote that prior to this step, JuMP will aggregate all constant terms onto the right-hand side of the constraint. For example, given a constraint 2x + 1 <= 2, set_normalized_rhs(con, 4) will create the constraint 2x <= 4, not 2x + 1 <= 4.\n\njulia> @constraint(model, con, 2x + 1 <= 2)\ncon : 2 x <= 1.0\n\njulia> set_normalized_rhs(con, 4)\n\njulia> con\ncon : 2 x <= 4.0\n\n\n\n\n\n","category":"function"},{"location":"constraints/#JuMP.add_to_function_constant","page":"Constraints","title":"JuMP.add_to_function_constant","text":"add_to_function_constant(constraint::ConstraintRef, value)\n\nAdd value to the function constant term.\n\nNote that for scalar constraints, JuMP will aggregate all constant terms onto the right-hand side of the constraint so instead of modifying the function, the set will be translated by -value. For example, given a constraint 2x <= 3, add_to_function_constant(c, 4) will modify it to 2x <= -1.\n\nExamples\n\nFor scalar constraints, the set is translated by -value:\n\njulia> @constraint(model, con, 0 <= 2x - 1 <= 2)\ncon : 2 x ∈ [1.0, 3.0]\n\njulia> add_to_function_constant(con, 4)\n\njulia> con\ncon : 2 x ∈ [-3.0, -1.0]\n\nFor vector constraints, the constant is added to the function:\n\njulia> @constraint(model, con, [x + y, x, y] in SecondOrderCone())\ncon : [x + y, x, y] in MOI.SecondOrderCone(3)\n\njulia> add_to_function_constant(con, [1, 2, 2])\n\njulia> con\ncon : [x + y + 1, x + 2, y + 2] in MOI.SecondOrderCone(3)\n\n\n\n\n\n","category":"function"},{"location":"constraints/#JuMP.is_valid","page":"Constraints","title":"JuMP.is_valid","text":"is_valid(model::Model, con_ref::ConstraintRef{Model})\n\nReturn true if constraint_ref refers to a valid constraint in model.\n\n\n\n\n\nis_valid(model::Model, variable_ref::VariableRef)\n\nReturn true if variable refers to a valid variable in model.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#JuMP.delete","page":"Constraints","title":"JuMP.delete","text":"delete(model::Model, con_ref::ConstraintRef)\n\nDelete the constraint associated with constraint_ref from the model model.\n\n\n\n\n\ndelete(model::Model, con_refs::Vector{<:ConstraintRef})\n\nDelete the constraints associated with con_refs from the model model. Solvers may implement specialized methods for deleting multiple constraints of the same concrete type, i.e., when isconcretetype(eltype(con_refs)). These may be more efficient than repeatedly calling the single constraint delete method.\n\n\n\n\n\ndelete(model::Model, variable_ref::VariableRef)\n\nDelete the variable associated with variable_ref from the model model.\n\n\n\n\n\ndelete(model::Model, variable_refs::Vector{VariableRef})\n\nDelete the variables associated with variable_refs from the model model. Solvers may implement methods for deleting multiple variables that are more efficient than repeatedly calling the single variable delete method.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#JuMP.LowerBoundRef","page":"Constraints","title":"JuMP.LowerBoundRef","text":"LowerBoundRef(v::VariableRef)\n\nReturn a constraint reference to the lower bound constraint of v. Errors if one does not exist.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#JuMP.UpperBoundRef","page":"Constraints","title":"JuMP.UpperBoundRef","text":"UpperBoundRef(v::VariableRef)\n\nReturn a constraint reference to the upper bound constraint of v. Errors if one does not exist.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#JuMP.FixRef","page":"Constraints","title":"JuMP.FixRef","text":"FixRef(v::VariableRef)\n\nReturn a constraint reference to the constraint fixing the value of v. Errors if one does not exist.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#JuMP.ConstraintRef","page":"Constraints","title":"JuMP.ConstraintRef","text":"ConstraintRef\n\nHolds a reference to the model and the corresponding MOI.ConstraintIndex.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#JuMP.list_of_constraint_types","page":"Constraints","title":"JuMP.list_of_constraint_types","text":"list_of_constraint_types(model::Model)\n\nReturn a list of tuples of the form (F, S) where F is a JuMP function type and S is an MOI set type such that all_constraints(model, F, S) returns a nonempty list.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> list_of_constraint_types(model)\n3-element Array{Tuple{DataType,DataType},1}:\n (GenericAffExpr{Float64,VariableRef}, MathOptInterface.LessThan{Float64})\n (VariableRef, MathOptInterface.GreaterThan{Float64})\n (VariableRef, MathOptInterface.ZeroOne)\n\n\n\n\n\n","category":"function"},{"location":"constraints/#JuMP.all_constraints","page":"Constraints","title":"JuMP.all_constraints","text":"all_constraints(model::Model, function_type, set_type)::Vector{<:ConstraintRef}\n\nReturn a list of all constraints currently in the model where the function has type function_type and the set has type set_type. The constraints are ordered by creation time.\n\nSee also list_of_constraint_types and num_constraints.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> all_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}},ScalarShape},1}:\n x ≥ 0.0\n\njulia> all_constraints(model, VariableRef, MOI.ZeroOne)\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.ZeroOne},ScalarShape},1}:\n x binary\n\njulia> all_constraints(model, AffExpr, MOI.LessThan{Float64})\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n 2 x ≤ 1.0\n\n\n\n\n\n","category":"function"},{"location":"constraints/#JuMP.num_constraints","page":"Constraints","title":"JuMP.num_constraints","text":"num_constraints(model::Model, function_type, set_type)::Int64\n\nReturn the number of constraints currently in the model where the function has type function_type and the set has type set_type.\n\nSee also list_of_constraint_types and all_constraints.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @variable(model, y);\n\njulia> @constraint(model, y in MOI.GreaterThan(1.0));\n\njulia> @constraint(model, y <= 1.0);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> num_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n2\n\njulia> num_constraints(model, VariableRef, MOI.ZeroOne)\n1\n\njulia> num_constraints(model, AffExpr, MOI.LessThan{Float64})\n2\n\n\n\n\n\n","category":"function"},{"location":"constraints/#JuMP.constraint_object","page":"Constraints","title":"JuMP.constraint_object","text":"constraint_object(con_ref::ConstraintRef)\n\nReturn the underlying constraint data for the constraint referenced by ref.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#JuMP.AbstractConstraint","page":"Constraints","title":"JuMP.AbstractConstraint","text":"abstract type AbstractConstraint\n\nAn abstract base type for all constraint types. AbstractConstraints store the function and set directly, unlike ConstraintRefs that are merely references to constraints stored in a model. AbstractConstraints do not need to be attached to a model.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#JuMP.ScalarConstraint","page":"Constraints","title":"JuMP.ScalarConstraint","text":"struct ScalarConstraint\n\nThe data for a scalar constraint. The func field containts a JuMP object representing the function and the set field contains the MOI set. See also the documentation on JuMP's representation of constraints for more background.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#JuMP.VectorConstraint","page":"Constraints","title":"JuMP.VectorConstraint","text":"struct VectorConstraint\n\nThe data for a vector constraint. The func field containts a JuMP object representing the function and the set field contains the MOI set. The shape field contains an AbstractShape matching the form in which the constraint was constructed (e.g., by using matrices or flat vectors). See also the documentation on JuMP's representation of constraints.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#JuMP.index-Tuple{ConstraintRef}","page":"Constraints","title":"JuMP.index","text":"index(cr::ConstraintRef)::MOI.ConstraintIndex\n\nReturn the index of the constraint that corresponds to cr in the MOI backend.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#JuMP.optimizer_index-Tuple{ConstraintRef{Model,C,Shape} where Shape<:AbstractShape where C}","page":"Constraints","title":"JuMP.optimizer_index","text":"optimizer_index(cr::ConstraintRef{Model})::MOI.ConstraintIndex\n\nReturn the index of the constraint that corresponds to cr in the optimizer model. It throws NoOptimizer if no optimizer is set and throws an ErrorException if the optimizer is set but is not attached or if the constraint is bridged.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#Constructing-constraints-without-adding-them-to-the-model-1","page":"Constraints","title":"Constructing constraints without adding them to the model","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"For advanced use cases.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"@build_constraint","category":"page"},{"location":"constraints/#JuMP.@build_constraint","page":"Constraints","title":"JuMP.@build_constraint","text":"@build_constraint(constraint_expr)\n\nConstructs a ScalarConstraint or VectorConstraint using the same machinery as @constraint but without adding the constraint to a model.\n\nConstraints using broadcast operators like x .<= 1 are also supported and will create arrays of ScalarConstraint or VectorConstraint.\n\nExamples\n\nmodel = Model();\n@variable(model, x);\n@build_constraint(2x >= 1)\n\n# output\nScalarConstraint{GenericAffExpr{Float64,VariableRef},MathOptInterface.GreaterThan{Float64}}(2 x, MathOptInterface.GreaterThan{Float64}(1.0))\n\n\n\n\n\n","category":"macro"},{"location":"nlp/#Nonlinear-Modeling-1","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"","category":"section"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP has support for general smooth nonlinear (convex and nonconvex) optimization problems. JuMP is able to provide exact, sparse second-order derivatives to solvers. This information can improve solver accuracy and performance.","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear objectives and constraints are specified by using the @NLobjective and @NLconstraint macros. The familiar sum() syntax is supported within these macros, as well as prod() which analogously represents the product of the terms within. Note that the @objective and @constraint macros (and corresponding functions) do not currently support nonlinear expressions. However, a model can contain a mix of linear, quadratic, and nonlinear contraints or objective functions. Starting points may be provided by using the start keyword argument to @variable.","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For example, we can solve the classical Rosenbrock problem (with a twist) as follows:","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using Ipopt\nmodel = Model(Ipopt.Optimizer)\n@variable(model, x, start = 0.0)\n@variable(model, y, start = 0.0)\n\n@NLobjective(model, Min, (1 - x)^2 + 100 * (y - x^2)^2)\n\noptimize!(model)\nprintln(\"x = \", value(x), \" y = \", value(y))\n\n# adding a (linear) constraint\n@constraint(model, x + y == 10)\noptimize!(model)\nprintln(\"x = \", value(x), \" y = \", value(y))","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"See the JuMP examples directory for more examples (which include mle.jl, rosenbrock.jl, and clnlbeam.jl).","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The NLP solver tests contain additional examples.","category":"page"},{"location":"nlp/#Syntax-notes-1","page":"Nonlinear Modeling","title":"Syntax notes","text":"","category":"section"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The syntax accepted in nonlinear expressions is more restricted than the syntax for linear and quadratic expressions. We note some important points below.","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"With the exception of the splatting syntax discussed below, all expressions must be simple scalar operations. You cannot use dot, matrix-vector products, vector slices, etc. Translate vector operations into explicit sum() operations or use the AffExpr plus auxiliary variable trick described below.\nThere is no operator overloading provided to build up nonlinear expressions. For example, if x is a JuMP variable, the code 3x will return an AffExpr object that can be used inside of future expressions and linear constraints. However, the code sin(x) is an error. All nonlinear expressions must be inside of macros.\nUser-defined Functions may be used within nonlinear expressions only after they are registered. For example, the follow code results in an error because register() must be called first to register my_function.","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"model = Model()\nmy_function(a, b) = exp(a) * b\n@variable(model, x)\n@variable(model, y)\n@NLobjective(model, Min, my_function(x, y))\n\n# output\n\nERROR: Unrecognized function \"my_function\" used in nonlinear expression.","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"AffExpr and QuadExpr objects cannot currently be used inside nonlinear expressions. Instead, introduce auxiliary variables, e.g.:","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"    my_expr = dot(c, x) + 3y # where x and y are variables\n    @variable(model, aux)\n    @constraint(model, aux == my_expr)\n    @NLobjective(model, Min, sin(aux))","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"You can declare embeddable nonlinear expressions with @NLexpression. For example:","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"    @NLexpression(model, my_expr[i = 1:n], sin(x[i]))\n    @NLconstraint(model, my_constr[i = 1:n], my_expr[i] <= 0.5)","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Anonymous syntax is supported in @NLexpression and @NLconstraint:","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"    my_expr = @NLexpression(model, [i = 1:n], sin(x[i]))\n    my_constr = @NLconstraint(model, [i = 1:n], my_expr[i] <= 0.5)","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The splatting operator ... is recognized in a very restricted setting for expanding function arguments. The expression splatted can be only a symbol. More complex expressions are not recognized.","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x[1:3]);\n\njulia> @NLconstraint(model, *(x...) <= 1.0)\nx[1] * x[2] * x[3] - 1.0 ≤ 0\n\njulia> @NLconstraint(model, *((x / 2)...) <= 0.0)\nERROR: LoadError: Unexpected expression in (*)(x / 2...). JuMP supports splatting only symbols. For example, x... is ok, but (x + 1)..., [x; y]... and g(f(y)...) are not.","category":"page"},{"location":"nlp/#Nonlinear-Parameters-1","page":"Nonlinear Modeling","title":"Nonlinear Parameters","text":"","category":"section"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For nonlinear models only, JuMP offers a syntax for explicit \"parameter\" objects which can be used to modify a model in-place just by updating the value of the parameter. Nonlinear parameters are declared by using the @NLparameter macro and may be indexed by arbitrary sets analogously to JuMP variables and expressions. The initial value of the parameter must be provided on the right-hand side of the == sign. There is no anonymous syntax for creating parameters.","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLparameter","category":"page"},{"location":"nlp/#JuMP.@NLparameter","page":"Nonlinear Modeling","title":"JuMP.@NLparameter","text":"@NLparameter(model, param == value)\n\nCreate and return a nonlinear parameter param attached to the model model with initial value set to value. Nonlinear parameters may be used only in nonlinear expressions.\n\nExample\n\nmodel = Model()\n@NLparameter(model, x == 10)\nvalue(x)\n\n# output\n10.0\n\n@NLparameter(model, param_collection[...] == value_expr)\n\nCreate and return a collection of nonlinear parameters param_collection attached to the model model with initial value set to value_expr (may depend on index sets). Uses the same syntax for specifying index sets as @variable.\n\nExample\n\nmodel = Model()\n@NLparameter(model, y[i = 1:10] == 2 * i)\nvalue(y[9])\n\n# output\n18.0\n\n\n\n\n\n","category":"macro"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"You may use value and set_value to query or update the value of a parameter.","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"value(::JuMP.NonlinearParameter)\nset_value(::JuMP.NonlinearParameter, ::Number)","category":"page"},{"location":"nlp/#JuMP.value-Tuple{NonlinearParameter}","page":"Nonlinear Modeling","title":"JuMP.value","text":"value(p::NonlinearParameter)\n\nReturn the current value stored in the nonlinear parameter p.\n\nExample\n\nmodel = Model()\n@NLparameter(model, p == 10)\nvalue(p)\n\n# output\n10.0\n\n\n\n\n\n","category":"method"},{"location":"nlp/#JuMP.set_value-Tuple{NonlinearParameter,Number}","page":"Nonlinear Modeling","title":"JuMP.set_value","text":"set_value(p::NonlinearParameter, v::Number)\n\nStore the value v in the nonlinear parameter p.\n\nExample\n\nmodel = Model()\n@NLparameter(model, p == 0)\nset_value(p, 5)\nvalue(p)\n\n# output\n5.0\n\n\n\n\n\n","category":"method"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear parameters can be used within nonlinear expressions only:","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLparameter(model, x == 10)\n@variable(model, z)\n@objective(model, Max, x * z)             # Error: x is a nonlinear parameter.\n@NLobjective(model, Max, x * z)           # Ok.\n@expression(model, my_expr, x * z^2)      # Error: x is a nonlinear parameter.\n@NLexpression(model, my_nl_expr, x * z^2) # Ok.","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear parameters are useful when solving nonlinear models in a sequence:","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using Ipopt\nmodel = Model(Ipopt.Optimizer)\n@variable(model, z)\n@NLparameter(model, x == 1.0)\n@NLobjective(model, Min, (z - x)^2)\noptimize!(model)\nvalue(z) # Equals 1.0.\n\n# Now, update the value of x to solve a different problem.\nset_value(x, 5.0)\noptimize!(model)\nvalue(z) # Equals 5.0","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Using nonlinear parameters can be faster than creating a new model from scratch with updated data because JuMP is able to avoid repeating a number of steps in processing the model before handing it off to the solver.","category":"page"},{"location":"nlp/#User-defined-Functions-1","page":"Nonlinear Modeling","title":"User-defined Functions","text":"","category":"section"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP's library of recognized univariate functions is derived from the Calculus.jl package. If you encounter a standard special function not currently supported by JuMP, consider contributing to the list of derivative rules there. In addition to this built-in list of functions, it is possible to register custom (user-defined) nonlinear functions to use within nonlinear expressions. JuMP does not support black-box optimization, so all user-defined functions must provide derivatives in some form. Fortunately, JuMP supports automatic differentiation of user-defined functions, a feature to our knowledge not available in any comparable modeling systems.","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"note: Note\nAutomatic differentiation is not finite differencing. JuMP's automatically computed derivatives are not subject to approximation error.","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP uses ForwardDiff.jl to perform automatic differentiation; see the ForwardDiff.jl documentation for a description of how to write a function suitable for automatic differentiation.","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"note: Note\nIf you see method errors with ForwardDiff.Duals, see the guidelines at ForwardDiff.jl. The most common error is that your user-defined function is not generic with respect to the number type, i.e., don't assume that the input to the function is Float64.f(x::Float64) = 2 * x  # This will not work.\nf(x::Real)    = 2 * x  # This is good.\nf(x)          = 2 * x  # This is also good.","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"To register a user-defined function with derivatives computed by automatic differentiation, use the register method as in the following example:","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"my_square(x) = x^2\nmy_f(x,y) = (x - 1)^2 + (y - 2)^2\n\nmodel = Model()\n\nregister(model, :my_f, 2, my_f, autodiff=true)\nregister(model, :my_square, 1, my_square, autodiff=true)\n\n@variable(model, x[1:2] >= 0.5)\n@NLobjective(model, Min, my_f(x[1], my_square(x[2])))","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The above code creates a JuMP model with the objective function (x[1] - 1)^2 + (x[2]^2 - 2)^2. The first argument to register is the model for which the functions are registered. The second argument is a Julia symbol object which serves as the name of the user-defined function in JuMP expressions; the JuMP name need not be the same as the name of the corresponding Julia method. The third argument specifies how many arguments the function takes. The fourth argument is the name of the Julia method which computes the function, and autodiff=true instructs JuMP to compute exact gradients automatically.","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Forward-mode automatic differentiation as implemented by ForwardDiff.jl has a computational cost that scales linearly with the number of input dimensions. As such, it is not the most efficient way to compute gradients of user-defined functions if the number of input arguments is large. In this case, users may want to provide their own routines for evaluating gradients. The more general syntax for register which accepts user-provided derivative evaluation routines is:","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP.register(model::Model, s::Symbol, dimension::Integer, f::Function,\n              ∇f::Function, ∇²f::Function)","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The input differs between functions which take a single input argument and functions which take more than one. For univariate functions, the derivative evaluation routines should return a number which represents the first and second-order derivatives respectively. For multivariate functions, the derivative evaluation routines will be passed a gradient vector which they must explicitly fill. Second-order derivatives of multivariate functions are not currently supported; this argument should be omitted. The following example sets up the same optimization problem as before, but now we explicitly provide evaluation routines for the user-defined functions:","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"my_square(x) = x^2\nmy_square_prime(x) = 2x\nmy_square_prime_prime(x) = 2\n\nmy_f(x, y) = (x - 1)^2 + (y - 2)^2\nfunction ∇f(g, x, y)\n    g[1] = 2 * (x - 1)\n    g[2] = 2 * (y - 2)\nend\n\nmodel = Model()\n\nregister(model, :my_f, 2, my_f, ∇f)\nregister(model, :my_square, 1, my_square, my_square_prime,\n         my_square_prime_prime)\n\n@variable(model, x[1:2] >= 0.5)\n@NLobjective(model, Min, my_f(x[1], my_square(x[2])))","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Once registered, user-defined functions can also be used in constraints. For example:","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLconstraint(model, my_square(x[1]) <= 2.0)","category":"page"},{"location":"nlp/#User-defined-functions-with-vector-inputs-1","page":"Nonlinear Modeling","title":"User-defined functions with vector inputs","text":"","category":"section"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"User-defined functions which take vectors as input arguments (e.g. f(x::Vector)) are not supported. Instead, use Julia's splatting syntax to create a function with scalar arguments. For example, instead of","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"f(x::Vector) = sum(x[i]^i for i in 1:length(x))","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"define:","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"f(x...) = sum(x[i]^i for i in 1:length(x))","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This function f can be used in a JuMP model as follows:","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"model = Model()\n@variable(model, x[1:5] >= 0)\nf(x...) = sum(x[i]^i for i in 1:length(x))\nregister(model, :f, 5, f; autodiff = true)\n@NLobjective(model, Min, f(x...))","category":"page"},{"location":"nlp/#Factors-affecting-solution-time-1","page":"Nonlinear Modeling","title":"Factors affecting solution time","text":"","category":"section"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The execution time when solving a nonlinear programming problem can be divided into two parts, the time spent in the optimization algorithm (the solver) and the time spent evaluating the nonlinear functions and corresponding derivatives. Ipopt explicitly displays these two timings in its output, for example:","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Total CPU secs in IPOPT (w/o function evaluations)   =      7.412\nTotal CPU secs in NLP function evaluations           =      2.083","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For Ipopt in particular, one can improve the performance by installing advanced sparse linear algebra packages, see Installation Guide. For other solvers, see their respective documentation for performance tips.","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The function evaluation time, on the other hand, is the responsibility of the modeling language. JuMP computes derivatives by using reverse-mode automatic differentiation with graph coloring methods for exploiting sparsity of the Hessian matrix [1]. As a conservative bound, JuMP's performance here currently may be expected to be within a factor of 5 of AMPL's.","category":"page"},{"location":"nlp/#Querying-derivatives-from-a-JuMP-model-1","page":"Nonlinear Modeling","title":"Querying derivatives from a JuMP model","text":"","category":"section"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For some advanced use cases, one may want to directly query the derivatives of a JuMP model instead of handing the problem off to a solver. Internally, JuMP implements the AbstractNLPEvaluator interface from MathOptInterface. To obtain an NLP evaluator object from a JuMP model, use JuMP.NLPEvaluator. JuMP.index returns the MOI.VariableIndex corresponding to a JuMP variable. MOI.VariableIndex itself is a type-safe wrapper for Int64 (stored in the value field.)","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For example:","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"raw_index(v::MOI.VariableIndex) = v.value\nmodel = Model()\n@variable(model, x)\n@variable(model, y)\n@NLobjective(model, Min, sin(x) + sin(y))\nvalues = zeros(2)\nx_index = raw_index(JuMP.index(x))\ny_index = raw_index(JuMP.index(y))\nvalues[x_index] = 2.0\nvalues[y_index] = 3.0\nd = NLPEvaluator(model)\nMOI.initialize(d, [:Grad])\nMOI.eval_objective(d, values) # == sin(2.0) + sin(3.0)\n\n# output\n1.0504174348855488","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"∇f = zeros(2)\nMOI.eval_objective_gradient(d, ∇f, values)\n(∇f[x_index], ∇f[y_index]) # == (cos(2.0), cos(3.0))\n\n# output\n(-0.4161468365471424, -0.9899924966004454)","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Only nonlinear constraints (those added with @NLconstraint), and nonlinear objectives (added with @NLobjective) exist in the scope of the NLPEvaluator. The NLPEvaluator does not evaluate derivatives of linear or quadratic constraints or objectives. The index method applied to a nonlinear constraint reference object returns its index as a NonlinearConstraintIndex. The value field of NonlinearConstraintIndex stores the raw integer index. For example:","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @NLconstraint(model, cons1, sin(x) <= 1);\n\njulia> @NLconstraint(model, cons2, x + 5 == 10);\n\njulia> typeof(cons1)\nConstraintRef{Model,NonlinearConstraintIndex,ScalarShape}\n\njulia> index(cons1)\nNonlinearConstraintIndex(1)\n\njulia> index(cons2)\nNonlinearConstraintIndex(2)","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"# TODO: Provide a link for how to access the linear and quadratic parts of the\n# model.","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Note that for one-sided nonlinear constraints, JuMP subtracts any values on the right-hand side when computing expressions. In other words, one-sided nonlinear constraints are always transformed to have a right-hand side of zero.","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This method of querying derivatives directly from a JuMP model is convenient for interacting with the model in a structured way, e.g., for accessing derivatives of specific variables. For example, in statistical maximum likelihood estimation problems, one is often interested in the Hessian matrix at the optimal solution, which can be queried using the NLPEvaluator.","category":"page"},{"location":"nlp/#Raw-expression-input-1","page":"Nonlinear Modeling","title":"Raw expression input","text":"","category":"section"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"In addition to the @NLobjective and @NLconstraint macros, it is also possible to provide Julia Expr objects directly by using set_NL_objective and add_NL_constraint. This input form may be useful if the expressions are generated programmatically. JuMP variables should be spliced into the expression object. For example:","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@variable(model, 1 <= x[i = 1:4] <= 5)\nset_NL_objective(model, :Min, :($(x[1])*$(x[4])*($(x[1])+$(x[2])+$(x[3])) + $(x[3])))\nadd_NL_constraint(model, :($(x[1])*$(x[2])*$(x[3])*$(x[4]) >= 25))\n\n# Equivalent form using traditional JuMP macros:\n@NLobjective(model, Min, x[1] * x[4] * (x[1] + x[2] + x[3]) + x[3])\n@NLconstraint(model, x[1] * x[2] * x[3] * x[4] >= 25)","category":"page"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"See the Julia documentation for more examples and description of Julia expressions.","category":"page"},{"location":"nlp/#Reference-1","page":"Nonlinear Modeling","title":"Reference","text":"","category":"section"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLconstraint\n@NLexpression\n@NLobjective","category":"page"},{"location":"nlp/#JuMP.@NLconstraint","page":"Nonlinear Modeling","title":"JuMP.@NLconstraint","text":"@NLconstraint(m::Model, expr)\n\nAdd a constraint described by the nonlinear expression expr. See also @constraint. For example:\n\n@NLconstraint(model, sin(x) <= 1)\n@NLconstraint(model, [i = 1:3], sin(i * x) <= 1 / i)\n\n\n\n\n\n","category":"macro"},{"location":"nlp/#JuMP.@NLexpression","page":"Nonlinear Modeling","title":"JuMP.@NLexpression","text":"@NLexpression(args...)\n\nEfficiently build a nonlinear expression which can then be inserted in other nonlinear constraints and the objective. See also [@expression]. For example:\n\n@NLexpression(model, my_expr, sin(x)^2 + cos(x^2))\n@NLconstraint(model, my_expr + y >= 5)\n@NLobjective(model, Min, my_expr)\n\nIndexing over sets and anonymous expressions are also supported:\n\n@NLexpression(m, my_expr_1[i=1:3], sin(i * x))\nmy_expr_2 = @NLexpression(m, log(1 + sum(exp(x[i])) for i in 1:2))\n\n\n\n\n\n","category":"macro"},{"location":"nlp/#JuMP.@NLobjective","page":"Nonlinear Modeling","title":"JuMP.@NLobjective","text":"@NLobjective(model, sense, expression)\n\nAdd a nonlinear objective to model with optimization sense sense. sense must be Max or Min.\n\nExample\n\n@NLobjective(model, Max, 2x + 1 + sin(x))\n\n\n\n\n\n","category":"macro"},{"location":"nlp/#","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"[1]: Dunning, Huchette, and Lubin, \"JuMP: A Modeling Language for Mathematical Optimization\", SIAM Review, PDF.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"variables/#Variables-1","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"variables/#What-is-a-JuMP-variable?-1","page":"Variables","title":"What is a JuMP variable?","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"The term variable in mathematical optimization has many meanings. Here, we distinguish between the following three types of variables:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"optimization variables, which are the mathematical x in the problem maxf_0(x)  f_i(x) in S_i.\nJulia variables, which are bindings between a name and a value, for example x = 1. (See here for the Julia docs.)\nJuMP variables, which are instances of the VariableRef struct defined by JuMP that contains a reference to an optimization variable in a model. (Extra for experts: the VariableRef struct is a thin wrapper around a MOI.VariableIndex, and also contains a reference to the JuMP model.)","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"To illustrate these three types of variables, consider the following JuMP code (the full syntax is explained below):","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x[1:2])\n2-element Array{VariableRef,1}:\n x[1]\n x[2]","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"This code does three things:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"It adds two optimization variables to model.\nIt creates two JuMP variables that act as references to those optimization variables.\nIt binds those JuMP variables as a vector with two elements to the Julia variable x.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"To reduce confusion, we will attempt, where possible, to always refer to variables with their corresponding prefix.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"JuMP variables can have attributes, such as names or an initial primal start value. We illustrate the name attribute in the following example:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, y, base_name=\"decision variable\")\ndecision variable","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"This code does four things:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"It adds one optimization variable to model.\nIt creates one JuMP variable that acts as a reference to that optimization variable.\nIt binds the JuMP variable to the Julia variable y.\nIt tells JuMP that the name attribute of this JuMP variable is \"decision variable\". JuMP uses the value of base_name when it has to print the variable as a string.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"For example, when we print y at the REPL we get:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> y\ndecision variable","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Because y is a Julia variable, we can bind it to a different value. For example, if we write:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> y = 1\n1","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"y is no longer a binding to a JuMP variable. This does not mean that the JuMP variable has been destroyed. It still exists and is still a reference to the same optimization variable. The binding can be reset by querying the model for the symbol as it was written in the @variable macro. For example:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> model[:y]\ndecision variable","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"This act of looking up the JuMP variable by using the symbol is most useful when composing JuMP models across multiple functions, as illustrated by the following example:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"function add_component_to_model(model::JuMP.Model)\n    x = model[:x]\n    # ... code that uses x\nend\nfunction build_model()\n    model = Model()\n    @variable(model, x)\n    add_component_to_model(model)\nend","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Now that we understand the difference between optimization, JuMP, and Julia variables, we can introduce more of the functionality of the @variable macro.","category":"page"},{"location":"variables/#Variable-bounds-1","page":"Variables","title":"Variable bounds","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"We have already seen the basic usage of the @variable macro. The next extension is to add lower- and upper-bounds to each optimization variable. This can be done as follows:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x_free)\nx_free\n\njulia> @variable(model, x_lower >= 0)\nx_lower\n\njulia> @variable(model, x_upper <= 1)\nx_upper\n\njulia> @variable(model, 2 <= x_interval <= 3)\nx_interval\n\njulia> @variable(model, x_fixed == 4)\nx_fixed","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"In the above examples, x_free represents an unbounded optimization variable, x_lower represents an optimization variable with a lower bound and so forth.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"note: Note\nWhen creating a variable with only a lower-bound or an upper-bound, and the value of the bound is not a numeric literal, the name of the variable must appear on the left-hand side. Putting the name on the right-hand side will result in an error. For example:@variable(model, 1 <= x)  # works\na = 1\n@variable(model, a <= x)  # errors\n@variable(model, x >= a)  # works","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"We can query whether an optimization variable has a lower- or upper-bound via the has_lower_bound and has_upper_bound functions. For example:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> has_lower_bound(x_free)\nfalse\n\njulia> has_upper_bound(x_upper)\ntrue","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"If a variable has a lower or upper bound, we can query the value of it via the lower_bound and upper_bound functions. For example:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> lower_bound(x_interval)\n2.0\n\njulia> upper_bound(x_interval)\n3.0","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Querying the value of a bound that does not exist will result in an error.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Instead of using the <= and >= syntax, we can also use the lower_bound and upper_bound keyword arguments. For example:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x, lower_bound=1, upper_bound=2)\nx\n\njulia> lower_bound(x)\n1.0","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Another option is to use the set_lower_bound and set_upper_bound functions. These can also be used to modify an existing variable bound. For example:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x >= 1)\nx\n\njulia> lower_bound(x)\n1.0\n\njulia> set_lower_bound(x, 2)\n\njulia> lower_bound(x)\n2.0","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"We can delete variable bounds using delete_lower_bound and delete_upper_bound:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, 1 <= x <= 2)\nx\n\njulia> lower_bound(x)\n1.0\n\njulia> delete_lower_bound(x)\n\njulia> has_lower_bound(x)\nfalse\n\njulia> upper_bound(x)\n2.0\n\njulia> delete_upper_bound(x)\n\njulia> has_upper_bound(x)\nfalse","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"In addition to upper and lower bounds, JuMP variables can also be fixed to a value using fix. See also is_fixed, fix_value, and unfix.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x == 1)\nx\n\njulia> is_fixed(x)\ntrue\n\njulia> fix_value(x)\n1.0\n\njulia> unfix(x)\n\njulia> is_fixed(x)\nfalse","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Fixing a variable with existing bounds will throw an error. To delete the bounds prior to fixing, use fix(variable, value; force = true).","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x >= 1)\nx\n\njulia> fix(x, 2)\nERROR: Unable to fix x to 2 because it has existing variable bounds. Consider calling `JuMP.fix(variable, value; force=true)` which will delete existing bounds before fixing the variable.\n\njulia> fix(x, 2; force = true)\n\n\njulia> fix_value(x)\n2.0","category":"page"},{"location":"variables/#Variable-names-1","page":"Variables","title":"Variable names","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"The name, i.e. the value of the MOI.VariableName attribute, of a variable can be obtained by JuMP.name(::JuMP.VariableRef) and set by JuMP.set_name(::JuMP.VariableRef, ::String).","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"name(::JuMP.VariableRef)\nset_name(::JuMP.VariableRef, ::String)","category":"page"},{"location":"variables/#JuMP.name-Tuple{VariableRef}","page":"Variables","title":"JuMP.name","text":"name(v::VariableRef)::String\n\nGet a variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"variables/#JuMP.set_name-Tuple{VariableRef,String}","page":"Variables","title":"JuMP.set_name","text":"set_name(v::VariableRef, s::AbstractString)\n\nSet a variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"variables/#","page":"Variables","title":"Variables","text":"The variable can also be retrieved from its name using JuMP.variable_by_name.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"variable_by_name","category":"page"},{"location":"variables/#JuMP.variable_by_name","page":"Variables","title":"JuMP.variable_by_name","text":"variable_by_name(model::AbstractModel,\n                 name::String)::Union{AbstractVariableRef, Nothing}\n\nReturns the reference of the variable with name attribute name or Nothing if no variable has this name attribute. Throws an error if several variables have name as their name attribute.\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> variable_by_name(model, \"x\")\nx\n\njulia> @variable(model, base_name=\"x\")\nx\n\njulia> variable_by_name(model, \"x\")\nERROR: Multiple variables have the name x.\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] get(::MOIU.Model{Float64}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/model.jl:222\n [3] get at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/universalfallback.jl:201 [inlined]\n [4] get(::MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.AbstractOptimizer,MathOptInterface.Utilities.UniversalFallback{MOIU.Model{Float64}}}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/cachingoptimizer.jl:490\n [5] variable_by_name(::Model, ::String) at /home/blegat/.julia/dev/JuMP/src/variables.jl:268\n [6] top-level scope at none:0\n\njulia> var = @variable(model, base_name=\"y\")\ny\n\njulia> variable_by_name(model, \"y\")\ny\n\njulia> set_name(var, \"z\")\n\njulia> variable_by_name(model, \"y\")\n\njulia> variable_by_name(model, \"z\")\nz\n\njulia> @variable(model, u[1:2])\n2-element Array{VariableRef,1}:\n u[1]\n u[2]\n\njulia> variable_by_name(model, \"u[2]\")\nu[2]\n\n\n\n\n\n","category":"function"},{"location":"variables/#Variable-containers-1","page":"Variables","title":"Variable containers","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"In the examples above, we have mostly created scalar variables. By scalar, we mean that the Julia variable is bound to exactly one JuMP variable. However, it is often useful to create collections of JuMP variables inside more complicated data structures.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"JuMP provides a mechanism for creating three types of these data structures, which we refer to as containers. The three types are Arrays, DenseAxisArrays, and SparseAxisArrays. We explain each of these in the following.","category":"page"},{"location":"variables/#Arrays-1","page":"Variables","title":"Arrays","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"We have already seen the creation of an array of JuMP variables with the x[1:2] syntax. This can naturally be extended to create multi-dimensional arrays of JuMP variables. For example:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2])\n2×2 Array{VariableRef,2}:\n x[1,1]  x[1,2]\n x[2,1]  x[2,2]","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Arrays of JuMP variables can be indexed and sliced as follows:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> x[1, 2]\nx[1,2]\n\njulia> x[2, :]\n2-element Array{VariableRef,1}:\n x[2,1]\n x[2,2]","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Variable bounds can depend upon the indices:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=1:2, j=1:2] >= 2i + j)\n2×2 Array{VariableRef,2}:\n x[1,1]  x[1,2]\n x[2,1]  x[2,2]\n\njulia> lower_bound.(x)\n2×2 Array{Float64,2}:\n 3.0  4.0\n 5.0  6.0","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"JuMP will form an Array of JuMP variables when it can determine at compile time that the indices are one-based integer ranges. Therefore x[1:b] will create an Array of JuMP variables, but x[a:b] will not. If JuMP cannot determine that the indices are one-based integer ranges (e.g., in the case of x[a:b]), JuMP will create a DenseAxisArray instead.","category":"page"},{"location":"variables/#variable_jump_arrays-1","page":"Variables","title":"DenseAxisArrays","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"We often want to create arrays where the indices are not one-based integer ranges. For example, we may want to create a variable indexed by the name of a product or a location. The syntax is the same as that above, except with an arbitrary vector as an index as opposed to a one-based range. The biggest difference is that instead of returning an Array of JuMP variables, JuMP will return a DenseAxisArray. For example:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, [:A,:B]])\n2-dimensional DenseAxisArray{VariableRef,2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, Symbol[:A, :B]\nAnd data, a 2×2 Array{VariableRef,2}:\n x[1,A]  x[1,B]\n x[2,A]  x[2,B]","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"DenseAxisArrays can be indexed and sliced as follows:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> x[1, :A]\nx[1,A]\n\njulia> x[2, :]\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:A, :B]\nAnd data, a 2-element Array{VariableRef,1}:\n x[2,A]\n x[2,B]","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Similarly to the Array case, bounds can depend upon indices. For example:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=2:3, j=1:2:3] >= 0.5i + j)\n2-dimensional DenseAxisArray{VariableRef,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, 1:2:3\nAnd data, a 2×2 Array{VariableRef,2}:\n x[2,1]  x[2,3]\n x[3,1]  x[3,3]\n\njulia> lower_bound.(x)\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, 1:2:3\nAnd data, a 2×2 Array{Float64,2}:\n 2.0  4.0\n 2.5  4.5","category":"page"},{"location":"variables/#variable_sparseaxisarrays-1","page":"Variables","title":"SparseAxisArrays","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"The third container type that JuMP natively supports is SparseAxisArray. These arrays are created when the indices do not form a rectangular set. For example, this applies when indices have a dependence upon previous indices (called triangular indexing). JuMP supports this as follows:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=1:2, j=i:2])\nJuMP.Containers.SparseAxisArray{VariableRef,2,Tuple{Int64,Int64}} with 3 entries:\n  [1, 2]  =  x[1,2]\n  [2, 2]  =  x[2,2]\n  [1, 1]  =  x[1,1]","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"We can also conditionally create variables via a JuMP-specific syntax. This syntax appends a comparison check that depends upon the named indices and is separated from the indices by a semi-colon (;). For example:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=1:4; mod(i, 2)==0])\nJuMP.Containers.SparseAxisArray{VariableRef,1,Tuple{Int64}} with 2 entries:\n  [4]  =  x[4]\n  [2]  =  x[2]","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Note that with many index dimensions and a large amount of sparsity, variable construction may be unnecessarily slow if the semi-colon syntax is naively applied. When using the semi-colon as a filter, JuMP iterates over all indices and evaluates the conditional for each combination. When this is undesired, the recommended work-around is to work directly with a list of tuples or create a dictionary. Consider the following examples:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"# TODO: Reformat the code below as a doctest.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"N = 10\nS = [(1, 1, 1),(N, N, N)]\n# Slow. It evaluates conditional N^3 times.\n@variable(model, x1[i=1:N, j=1:N, k=1:N; (i, j, k) in S])\n# Fast.\n@variable(model, x2[S])\n# Fast. Manually constructs a dictionary and fills it.\nx3 = Dict()\nfor (i, j, k) in S\n    x3[i, j, k] = @variable(model)\n    # Optional, if you care about pretty printing:\n    set_name(x3[i, j, k], \"x[$i,$j,$k]\")\nend","category":"page"},{"location":"variables/#variable_forcing-1","page":"Variables","title":"Forcing the container type","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"When creating a container of JuMP variables, JuMP will attempt to choose the tightest container type that can store the JuMP variables. Thus, it will prefer to create an Array before a DenseAxisArray and a DenseAxisArray before a SparseAxisArray. However, because this happens at compile time, it does not always make the best choice. To illustrate this, consider the following example:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> A = 1:2\n1:2\n\njulia> @variable(model, x[A])\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, 1:2\nAnd data, a 2-element Array{VariableRef,1}:\n x[1]\n x[2]","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Since the value (and type) of A is unknown at parsing time, JuMP is unable to infer that A is a one-based integer range. Therefore, JuMP creates a DenseAxisArray, even though it could store these two variables in a standard one-dimensional Array.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"We can share our knowledge that it is possible to store these JuMP variables as an array by setting the container keyword:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, y[A], container=Array)\n2-element Array{VariableRef,1}:\n y[1]\n y[2]","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"JuMP now creates a vector of JuMP variables instead of a DenseAxisArray. Note that choosing an invalid container type will throw an error.","category":"page"},{"location":"variables/#Integrality-shortcuts-1","page":"Variables","title":"Integrality shortcuts","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Adding integrality constraints to a model such as @constraint(model, x in MOI.ZeroOne()) and @constraint(model, x in MOI.Integer()) is a common operation. Therefore, JuMP supports two shortcuts for adding such constraints.","category":"page"},{"location":"variables/#Binary-(ZeroOne)-constraints-1","page":"Variables","title":"Binary (ZeroOne) constraints","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Binary optimization variables are constrained to the set x in 0 1. (The MOI.ZeroOne set in MathOptInterface.) Binary optimization variables can be created in JuMP by passing Bin as an optional positional argument:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x, Bin)\nx","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"We can check if an optimization variable is binary by calling is_binary on the JuMP variable, and binary constraints can be removed with unset_binary.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> is_binary(x)\ntrue\n\njulia> unset_binary(x)\n\njulia> is_binary(x)\nfalse","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Binary optimization variables can also be created by setting the binary keyword to true.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x, binary=true)\nx","category":"page"},{"location":"variables/#Integer-constraints-1","page":"Variables","title":"Integer constraints","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Integer optimization variables are constrained to the set x in mathbbZ. (The MOI.Integer set in MathOptInterface.) Integer optimization variables can be created in JuMP by passing Int as an optional positional argument:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x, Int)\nx","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Integer optimization variables can also be created by setting the integer keyword to true.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x, integer=true)\nx","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"We can check if an optimization variable is integer by calling is_integer on the JuMP variable, and integer constraints can be removed with unset_integer.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> is_integer(x)\ntrue\n\njulia> unset_integer(x)\n\njulia> is_integer(x)\nfalse","category":"page"},{"location":"variables/#Semidefinite-variables-1","page":"Variables","title":"Semidefinite variables","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"JuMP also supports modeling with semidefinite variables. A square symmetric matrix X is positive semidefinite if all eigenvalues are nonnegative. We can declare a matrix of JuMP variables to be positive semidefinite as follows:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2], PSD)\n2×2 LinearAlgebra.Symmetric{VariableRef,Array{VariableRef,2}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"or using the syntax for Variables constrained on creation:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2] in PSDCone())\n2×2 LinearAlgebra.Symmetric{VariableRef,Array{VariableRef,2}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Note that x must be a square 2-dimensional Array of JuMP variables; it cannot be a DenseAxisArray or a SparseAxisArray. (See Variable containers, above, for more on this.)","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"You can also impose a weaker constraint that the square matrix is only symmetric (instead of positive semidefinite) as follows:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2], Symmetric)\n2×2 LinearAlgebra.Symmetric{VariableRef,Array{VariableRef,2}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"variables/#Anonymous-JuMP-variables-1","page":"Variables","title":"Anonymous JuMP variables","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"In all of the above examples, we have created named JuMP variables. However, it is also possible to create so called anonymous JuMP variables. To create an anonymous JuMP variable, we drop the name of the variable from the macro call. This means dropping the second positional argument if the JuMP variable is a scalar, or dropping the name before the square bracket ([) if a container is being created. For example:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> x = @variable(model)\nnoname","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"This shows how (model, x) is really short for:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> x = model[:x] = @variable(model, base_name=\"x\")\nx","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"An Array of anonymous JuMP variables can be created as follows:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> y = @variable(model, [i=1:2])\n2-element Array{VariableRef,1}:\n noname\n noname","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"If necessary, you can store x in model as follows:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> model[:x] = x","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"The <= and >= short-hand cannot be used to set bounds on anonymous JuMP variables. Instead, you should use the lower_bound and upper_bound keywords.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Passing the Bin and Int variable types are also invalid. Instead, you should use the binary and integer keywords.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Thus, the anonymous variant of @variable(model, x[i=1:2] >= i, Int) is:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> x = @variable(model, [i=1:2], base_name=\"x\", lower_bound=i, integer=true)\n2-element Array{VariableRef,1}:\n x[1]\n x[2]","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"warn: Warn\nCreating two named JuMP variables with the same name results in an error at runtime. Use anonymous variables as an alternative.","category":"page"},{"location":"variables/#Variables-constrained-on-creation-1","page":"Variables","title":"Variables constrained on creation","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"info: Info\nWhen using JuMP in Direct mode, it may be required to constrain variables on creation instead of constraining free variables as the solver may only support variables constrained on creation. In Automatic and Manual modes, both ways of adding constraints on variables are equivalent. Indeed, during the copy of the cache to the optimizer, the choice of the constraints on variables that are copied as variables constrained on creation does not depend on how it was added to the cache.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"All uses of the @variable macro documented so far translate to a separate call for variable creation and adding of constraints.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"For example, @variable(model, x >= 0, Int), is equivalent to:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"@variable(model, x)\nset_lower_bound(x, 0.0)\n@constraint(model, x in MOI.Integer())","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Importantly, the bound and integrality constraints are added after the variable has been created.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"However, some solvers require a constraining set at creation time. We say that these variables are constrained on creation.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Use in within @variable to access the special syntax for constraining variables on creation. For example, the following creates a vector of variables constrained on creation to belong to the SecondOrderCone:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, y[1:3] in SecondOrderCone())\n3-element Array{VariableRef,1}:\n y[1]\n y[2]\n y[3]","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"For contrast, the more standard approach is as follows:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in SecondOrderCone())\n[x[1], x[2], x[3]] ∈ MathOptInterface.SecondOrderCone(3)","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"The technical difference between the former and the latter is that the former calls MOI.add_constrained_variables while the latter calls MOI.add_variables and then MOI.add_constraint. This distinction is important only in Direct mode, depending on the solver being used. It's often not possible to delete the SecondOrderCone constraint if it was specified at variable creation time.","category":"page"},{"location":"variables/#The-set-keyword-1","page":"Variables","title":"The set keyword","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"An alternate syntax to x in Set is to use the set keyword of @variable. This is most useful when creating anonymous variables:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"x = @variable(model, [1:2, 1:2], set = PSDCone())","category":"page"},{"location":"variables/#User-defined-containers-1","page":"Variables","title":"User-defined containers","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"In the section Variable containers, we explained how JuMP supports the efficient creation of collections of JuMP variables in three types of containers. However, users are also free to create collections of JuMP variables in their own datastructures. For example, the following code creates a dictionary with symmetric matrices as the values:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> variables = Dict{Symbol, Array{VariableRef,2}}()\nDict{Symbol,Array{VariableRef,2}} with 0 entries\n\njulia> for key in [:A, :B]\n           global variables[key] = @variable(model, [1:2, 1:2])\n       end\n\njulia> variables\nDict{Symbol,Array{VariableRef,2}} with 2 entries:\n  :A => VariableRef[noname noname; noname noname]\n  :B => VariableRef[noname noname; noname noname]","category":"page"},{"location":"variables/#Deleting-variables-1","page":"Variables","title":"Deleting variables","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"JuMP supports the deletion of optimization variables.  To delete variables, we can use the delete method. We can also check whether x is a valid JuMP variable in model using the is_valid method:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x)\nx\n\njulia> is_valid(model, x)\ntrue\n\njulia> delete(model, x)\n\njulia> is_valid(model, x)\nfalse","category":"page"},{"location":"variables/#Listing-all-variables-1","page":"Variables","title":"Listing all variables","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Use JuMP.all_variables to obtain a list of all variables present in the model. This is useful for performing operations like:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"relaxing all integrality constraints in the model\nsetting the starting values for variables to the result of the last solve","category":"page"},{"location":"variables/#Start-values-1","page":"Variables","title":"Start values","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"There are two ways to provide a primal starting solution (also called MIP-start or a warmstart) for each variable:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"using the start keyword in the @variable macro\nusing set_start_value","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"The starting value of a variable can be queried using start_value. If no start value has been set, start_value will return nothing.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variable(model, x)\nx\n\njulia> start_value(x)\n\njulia> @variable(model, y, start = 1)\ny\n\njulia> start_value(y)\n1.0\n\njulia> set_start_value(y, 2)\n\njulia> start_value(y)\n2.0","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"note: Note\nPrior to JuMP 0.19, the previous solution to a solve was automatically set as the new starting value. JuMP 0.19 no longer does this automatically. To reproduce the functionality, use:set_start_value.(all_variables(model), value.(all_variables(model)))","category":"page"},{"location":"variables/#variables-1","page":"Variables","title":"The @variables macro","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"If you have many @variable calls, JuMP provides the macro @variables that can improve readability:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"julia> @variables(model, begin\n           x\n           y[i=1:2] >= i, (start = i, base_name = \"Y_$i\")\n           z, Bin\n       end)\n\njulia> print(model)\nFeasibility\nSubject to\n Y_1[1] ≥ 1.0\n Y_2[2] ≥ 2.0\n z binary","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"note: Note\nKeyword arguments must be contained within parentheses. (See the example above.)","category":"page"},{"location":"variables/#Reference-1","page":"Variables","title":"Reference","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"@variable\nowner_model\nVariableRef\nall_variables\nnum_variables\n\nhas_lower_bound\nlower_bound\nset_lower_bound\ndelete_lower_bound\n\nhas_upper_bound\nupper_bound\nset_upper_bound\ndelete_upper_bound\n\nis_fixed\nfix_value\nfix\nunfix\n\nis_integer\nset_integer\nunset_integer\nIntegerRef\n\nis_binary\nset_binary\nunset_binary\nBinaryRef\n\nindex(::VariableRef)\noptimizer_index(::VariableRef)\n\nset_start_value\nstart_value","category":"page"},{"location":"variables/#JuMP.@variable","page":"Variables","title":"JuMP.@variable","text":"@variable(model, kw_args...)\n\nAdd an anonymous variable to the model model described by the keyword arguments kw_args and returns the variable.\n\n@variable(model, expr, args..., kw_args...)\n\nAdd a variable to the model model described by the expression expr, the positional arguments args and the keyword arguments kw_args. The expression expr can either be (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥)\n\nof the form varexpr creating variables described by varexpr;\nof the form varexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb);\nof the form varexpr == value creating variables described by varexpr with fixed values given by value; or\nof the form lb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub.\nof the form varexpr in set creating variables described by varexpr constrained to belong to set, see Variables constrained on creation.\n\nThe expression varexpr can either be\n\nof the form varname creating a scalar real variable of name varname;\nof the form varname[...] or [...] creating a container of variables (see Containers in macros).\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\nSymmetric: Only available when creating a square matrix of variables, i.e. when varexpr is of the form varname[1:n,1:n] or varname[i=1:n,j=1:n]. It creates a symmetric matrix of variable, that is, it only creates a new variable for varname[i,j] with i ≤ j and sets varname[j,i] to the same variable as varname[i,j]. It is equivalent to using varexpr in SymMatrixSpace() as expr.\nPSD: The square matrix of variable is both Symmetric and constrained to be positive semidefinite. It is equivalent to using varexpr in PSDCone() as expr.\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes.\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\nvariable_type: See the \"Note for extending the variable macro\" section below.\nset: Equivalent to using varexpr in value as expr where value is the value of the keyword argument.\ncontainer: Specify the container type, see Containers in macros.\n\nExamples\n\nThe following are equivalent ways of creating a variable x of name x with lower bound 0:\n\n# Specify everything in `expr`\n@variable(model, x >= 0)\n# Specify the lower bound using a keyword argument\n@variable(model, x, lower_bound=0)\n# Specify everything in `kw_args`\nx = @variable(model, base_name=\"x\", lower_bound=0)\n\nThe following are equivalent ways of creating a DenseAxisArray of index set [:a, :b] and with respective upper bounds 2 and 3 and names x[a] and x[b]. The upper bound can either be specified in expr:\n\nub = Dict(:a => 2, :b => 3)\n@variable(model, x[i=keys(ub)] <= ub[i])\n\n# output\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{VariableRef,1}:\n x[a]\n x[b]\n\nor it can be specified with the upper_bound keyword argument:\n\n@variable(model, y[i=keys(ub)], upper_bound=ub[i])\n\n# output\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{VariableRef,1}:\n y[a]\n y[b]\n\nNote for extending the variable macro\n\nThe single scalar variable or each scalar variable of the container are created using add_variable(model, build_variable(_error, info, extra_args...; extra_kw_args...)) where\n\nmodel is the model passed to the @variable macro;\n_error is an error function with a single String argument showing the @variable call in addition to the error message given as argument;\ninfo is the VariableInfo struct containing the information gathered in expr, the recognized keyword arguments (except base_name and variable_type) and the recognized positional arguments (except Symmetric and PSD);\nextra_args are the unrecognized positional arguments of args plus the value of the variable_type keyword argument if present. The variable_type keyword argument allows the user to pass a position argument to build_variable without the need to give a positional argument to @variable. In particular, this allows the user to give a positional argument to the build_variable call when using the anonymous single variable syntax @variable(model, kw_args...); and\nextra_kw_args are the unrecognized keyword argument of kw_args.\n\nExamples\n\nThe following creates a variable x of name x with lower_bound 0 as with the first example above but does it without using the @variable macro\n\ninfo = VariableInfo(true, 0, false, NaN, false, NaN, false, NaN, false, false)\nJuMP.add_variable(model, JuMP.build_variable(error, info), \"x\")\n\nThe following creates a DenseAxisArray of index set [:a, :b] and with respective upper bounds 2 and 3 and names x[a] and x[b] as with the second example above but does it without using the @variable macro\n\n# Without the `@variable` macro\nx = JuMP.Containers.container(i -> begin\n        info = VariableInfo(false, NaN, true, ub[i], false, NaN, false, NaN, false, false)\n        x[i] = JuMP.add_variable(model, JuMP.build_variable(error, info), \"x[$i]\")\n    end, JuMP.Containers.vectorized_product(keys(ub)))\n\n# output\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{VariableRef,1}:\n x[a]\n x[b]\n\nThe following are equivalent ways of creating a Matrix of size N x N with variables custom variables created with a JuMP extension using the Poly(X) positional argument to specify its variables:\n\n# Using the `@variable` macro\n@variable(model, x[1:N,1:N], Symmetric, Poly(X))\n# Without the `@variable` macro\nx = Matrix{JuMP.variable_type(model, Poly(X))}(N, N)\ninfo = VariableInfo(false, NaN, false, NaN, false, NaN, false, NaN, false, false)\nfor i in 1:N, j in i:N\n    x[i,j] = x[j,i] = JuMP.add_variable(model, build_variable(error, info, Poly(X)), \"x[$i,$j]\")\nend\n\n\n\n\n\n","category":"macro"},{"location":"variables/#JuMP.owner_model","page":"Variables","title":"JuMP.owner_model","text":"owner_model(s::AbstractJuMPScalar)\n\nReturn the model owning the scalar s.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.VariableRef","page":"Variables","title":"JuMP.VariableRef","text":"VariableRef <: AbstractVariableRef\n\nHolds a reference to the model and the corresponding MOI.VariableIndex.\n\n\n\n\n\n","category":"type"},{"location":"variables/#JuMP.all_variables","page":"Variables","title":"JuMP.all_variables","text":"all_variables(model::Model)::Vector{VariableRef}\n\nReturns a list of all variables currently in the model. The variables are ordered by creation time.\n\nExample\n\nmodel = Model()\n@variable(model, x)\n@variable(model, y)\nall_variables(model)\n\n# output\n\n2-element Array{VariableRef,1}:\n x\n y\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.num_variables","page":"Variables","title":"JuMP.num_variables","text":"num_variables(model::Model)::Int64\n\nReturns number of variables in model.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.has_lower_bound","page":"Variables","title":"JuMP.has_lower_bound","text":"has_lower_bound(v::VariableRef)\n\nReturn true if v has a lower bound. If true, the lower bound can be queried with lower_bound. See also LowerBoundRef.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.lower_bound","page":"Variables","title":"JuMP.lower_bound","text":"lower_bound(v::VariableRef)\n\nReturn the lower bound of a variable. Error if one does not exist. See also has_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.set_lower_bound","page":"Variables","title":"JuMP.set_lower_bound","text":"set_lower_bound(v::VariableRef, lower::Number)\n\nSet the lower bound of a variable. If one does not exist, create a new lower bound constraint. See also delete_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.delete_lower_bound","page":"Variables","title":"JuMP.delete_lower_bound","text":"delete_lower_bound(v::VariableRef)\n\nDelete the lower bound constraint of a variable.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.has_upper_bound","page":"Variables","title":"JuMP.has_upper_bound","text":"has_upper_bound(v::VariableRef)\n\nReturn true if v has a upper bound. If true, the upper bound can be queried with upper_bound. See also UpperBoundRef.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.upper_bound","page":"Variables","title":"JuMP.upper_bound","text":"upper_bound(v::VariableRef)\n\nReturn the upper bound of a variable. Error if one does not exist. See also has_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.set_upper_bound","page":"Variables","title":"JuMP.set_upper_bound","text":"set_upper_bound(v::VariableRef,upper::Number)\n\nSet the upper bound of a variable. If one does not exist, create an upper bound constraint. See also delete_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.delete_upper_bound","page":"Variables","title":"JuMP.delete_upper_bound","text":"delete_upper_bound(v::VariableRef)\n\nDelete the upper bound constraint of a variable.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.is_fixed","page":"Variables","title":"JuMP.is_fixed","text":"is_fixed(v::VariableRef)\n\nReturn true if v is a fixed variable. If true, the fixed value can be queried with fix_value. See also FixRef.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.fix_value","page":"Variables","title":"JuMP.fix_value","text":"fix_value(v::VariableRef)\n\nReturn the value to which a variable is fixed. Error if one does not exist. See also is_fixed.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.fix","page":"Variables","title":"JuMP.fix","text":"fix(v::VariableRef, value::Number; force::Bool = false)\n\nFix a variable to a value. Update the fixing constraint if one exists, otherwise create a new one. See also unfix.\n\nIf the variable already has variable bounds and force=false, calling fix will throw an error. If force=true, existing variable bounds will be deleted, and the fixing constraint will be added. Note a variable will have no bounds after a call to unfix.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.unfix","page":"Variables","title":"JuMP.unfix","text":"unfix(v::VariableRef)\n\nDelete the fixing constraint of a variable.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.is_integer","page":"Variables","title":"JuMP.is_integer","text":"is_integer(v::VariableRef)\n\nReturn true if v is constrained to be integer. See also IntegerRef.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.set_integer","page":"Variables","title":"JuMP.set_integer","text":"set_integer(variable_ref::VariableRef)\n\nAdd an integrality constraint on the variable variable_ref. See also unset_integer.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.unset_integer","page":"Variables","title":"JuMP.unset_integer","text":"unset_integer(variable_ref::VariableRef)\n\nRemove the integrality constraint on the variable variable_ref.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.IntegerRef","page":"Variables","title":"JuMP.IntegerRef","text":"IntegerRef(v::VariableRef)\n\nReturn a constraint reference to the constraint constrainting v to be integer. Errors if one does not exist.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.is_binary","page":"Variables","title":"JuMP.is_binary","text":"is_binary(v::VariableRef)\n\nReturn true if v is constrained to be binary. See also BinaryRef.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.set_binary","page":"Variables","title":"JuMP.set_binary","text":"set_binary(v::VariableRef)\n\nAdd a constraint on the variable v that it must take values in the set 01. See also unset_binary.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.unset_binary","page":"Variables","title":"JuMP.unset_binary","text":"unset_binary(variable_ref::VariableRef)\n\nRemove the binary constraint on the variable variable_ref.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.BinaryRef","page":"Variables","title":"JuMP.BinaryRef","text":"BinaryRef(v::VariableRef)\n\nReturn a constraint reference to the constraint constrainting v to be binary. Errors if one does not exist.\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.index-Tuple{VariableRef}","page":"Variables","title":"JuMP.index","text":"index(v::VariableRef)::MOI.VariableIndex\n\nReturn the index of the variable that corresponds to v in the MOI backend.\n\n\n\n\n\n","category":"method"},{"location":"variables/#JuMP.optimizer_index-Tuple{VariableRef}","page":"Variables","title":"JuMP.optimizer_index","text":"optimizer_index(v::VariableRef)::MOI.VariableIndex\n\nReturn the index of the variable that corresponds to v in the optimizer model. It throws NoOptimizer if no optimizer is set and throws an ErrorException if the optimizer is set but is not attached.\n\n\n\n\n\n","category":"method"},{"location":"variables/#JuMP.set_start_value","page":"Variables","title":"JuMP.set_start_value","text":"set_start_value(variable::VariableRef, value::Number)\n\nSet the start value (MOI attribute VariablePrimalStart) of the variable v to value. See also start_value.\n\nNote: VariablePrimalStarts are sometimes called \"MIP-starts\" or \"warmstarts\".\n\n\n\n\n\n","category":"function"},{"location":"variables/#JuMP.start_value","page":"Variables","title":"JuMP.start_value","text":"start_value(v::VariableRef)\n\nReturn the start value (MOI attribute VariablePrimalStart) of the variable v. See also set_start_value.\n\nNote: VariablePrimalStarts are sometimes called \"MIP-starts\" or \"warmstarts\".\n\n\n\n\n\n","category":"function"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"DocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"expressions/#Expressions-1","page":"Expressions","title":"Expressions","text":"","category":"section"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"JuMP has three types of expressions: affine, quadratic, and nonlinear. These expressions can be inserted into constraints or into the objective. This is particularly useful if an expression is used in multiple places in the model.","category":"page"},{"location":"expressions/#Affine-expressions-1","page":"Expressions","title":"Affine expressions","text":"","category":"section"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"There are four ways of constructing an affine expression in JuMP: with the @expression macro, with operator overloading, with the AffExpr constructor, and with add_to_expression!.","category":"page"},{"location":"expressions/#Macros-1","page":"Expressions","title":"Macros","text":"","category":"section"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"The recommended way to create an affine expression is via the @expression macro.","category":"page"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = @expression(model, 2x + y - 1)\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"This expression can be used in the objective or added to a constraint. For example:","category":"page"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"@objective(model, Min, 2 * ex - 1)\nobjective_function(model)\n\n# output\n\n4 x + 2 y - 3","category":"page"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"Just like variables and constraints, named expressions can also be created. For example","category":"page"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x[i = 1:3])\n@expression(model, expr[i = 1:3], i * sum(x[j] for j in i:3))\nexpr\n\n# output\n\n3-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x[1] + x[2] + x[3]\n 2 x[2] + 2 x[3]\n 3 x[3]","category":"page"},{"location":"expressions/#Operator-overloading-1","page":"Expressions","title":"Operator overloading","text":"","category":"section"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"Expressions can also be created without macros. However, note that in some cases, this can be much slower that constructing an expression using macros.","category":"page"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = 2x + y - 1\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"expressions/#Constructors-1","page":"Expressions","title":"Constructors","text":"","category":"section"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"A third way to create an affine expression is by the AffExpr constructor. The first argument is the constant term, and the remaining arguments are variable-coefficient pairs.","category":"page"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = AffExpr(-1.0, x => 2.0, y => 1.0)\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"expressions/#add_to_expression!-1","page":"Expressions","title":"add_to_expression!","text":"","category":"section"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"The fourth way to create an affine expression is by using add_to_expression!. Compared to the operator overloading method, this approach is faster because it avoids constructing temporary objects. The @expression macro uses add_to_expression! behind-the-scenes.","category":"page"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = AffExpr(-1.0)\nadd_to_expression!(ex, 2.0, x)\nadd_to_expression!(ex, 1.0, y)\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"expressions/#Removing-zero-terms-1","page":"Expressions","title":"Removing zero terms","text":"","category":"section"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"Use drop_zeros! to remove terms from an affine expression with a 0 coefficient.","category":"page"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @expression(model, ex, x + 1 - x)\n0 x + 1\n\njulia> drop_zeros!(ex)\n\njulia> ex\n1","category":"page"},{"location":"expressions/#Quadratic-expressions-1","page":"Expressions","title":"Quadratic expressions","text":"","category":"section"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"Like affine expressions, there are four ways of constructing a quadratic expression in JuMP: macros, operator overloading, constructors, and add_to_expression!.","category":"page"},{"location":"expressions/#Macros-2","page":"Expressions","title":"Macros","text":"","category":"section"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"The @expression macro can be used to create quadratic expressions by including quadratic terms.","category":"page"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = @expression(model, x^2 + 2 * x * y + y^2 + x + y - 1)\n\n# output\n\nx² + 2 y*x + y² + x + y - 1","category":"page"},{"location":"expressions/#Operator-overloading-2","page":"Expressions","title":"Operator overloading","text":"","category":"section"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"Operator overloading can also be used to create quadratic expressions. The same performance warning (discussed in the affine expression section) applies.","category":"page"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = x^2 + 2 * x * y + y^2 + x + y - 1\n\n# output\n\nx² + 2 x*y + y² + x + y - 1","category":"page"},{"location":"expressions/#Constructors-2","page":"Expressions","title":"Constructors","text":"","category":"section"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"Quadratic expressions can also be created using the QuadExpr constructor. The first argument is an affine expression, and the remaining arguments are pairs, where the first term is a JuMP.UnorderedPair and the second term is the coefficient.","category":"page"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\naff_expr = AffExpr(-1.0, x => 1.0, y => 1.0)\nquad_expr = QuadExpr(aff_expr, UnorderedPair(x, x) => 1.0,\n                     UnorderedPair(x, y) => 2.0, UnorderedPair(y, y) => 1.0)\n\n# output\n\nx² + 2 x*y + y² + x + y - 1","category":"page"},{"location":"expressions/#add_to_expression!-2","page":"Expressions","title":"add_to_expression!","text":"","category":"section"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"Finally, add_to_expression! can also be used to add quadratic terms.","category":"page"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = QuadExpr(x + y - 1.0)\nadd_to_expression!(ex, 1.0, x, x)\nadd_to_expression!(ex, 2.0, x, y)\nadd_to_expression!(ex, 1.0, y, y)\n\n# output\n\nx² + 2 x*y + y² + x + y - 1","category":"page"},{"location":"expressions/#Removing-zero-terms-2","page":"Expressions","title":"Removing zero terms","text":"","category":"section"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"Use drop_zeros! to remove terms from a quadratic expression with a 0 coefficient.","category":"page"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @expression(model, ex, x^2 + x + 1 - x^2)\n0 x² + x + 1\n\njulia> drop_zeros!(ex)\n\njulia> ex\nx + 1","category":"page"},{"location":"expressions/#Nonlinear-expressions-1","page":"Expressions","title":"Nonlinear expressions","text":"","category":"section"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"Nonlinear expressions can be constructed only using the @NLexpression macro and can be used only in @NLobjective, @NLconstraint, and other @NLexpressions. Moreover, quadratic and affine expressions cannot be used in the nonlinear macros. For more details, see the Nonlinear Modeling section.","category":"page"},{"location":"expressions/#Reference-1","page":"Expressions","title":"Reference","text":"","category":"section"},{"location":"expressions/#","page":"Expressions","title":"Expressions","text":"@expression\nadd_to_expression!\ndrop_zeros!","category":"page"},{"location":"expressions/#JuMP.@expression","page":"Expressions","title":"JuMP.@expression","text":"@expression(args...)\n\nEfficiently builds a linear or quadratic expression but does not add to model immediately. Instead, returns the expression which can then be inserted in other constraints. For example:\n\n@expression(m, shared, sum(i*x[i] for i=1:5))\n@constraint(m, shared + y >= 5)\n@constraint(m, shared + z <= 10)\n\nThe ref accepts index sets in the same way as @variable, and those indices can be used in the construction of the expressions:\n\n@expression(m, expr[i=1:3], i*sum(x[j] for j=1:3))\n\nAnonymous syntax is also supported:\n\nexpr = @expression(m, [i=1:3], i*sum(x[j] for j=1:3))\n\n\n\n\n\n","category":"macro"},{"location":"expressions/#JuMP.add_to_expression!","page":"Expressions","title":"JuMP.add_to_expression!","text":"add_to_expression!(expression, terms...)\n\nUpdates expression in place to expression + (*)(terms...). This is typically much more efficient than expression += (*)(terms...). For example, add_to_expression!(expression, a, b) produces the same result as expression += a*b, and add_to_expression!(expression, a) produces the same result as expression += a.\n\nOnly a few methods are defined, mostly for internal use, and only for the cases when (1) they can be implemented efficiently and (2) expression is capable of storing the result. For example, add_to_expression!(::AffExpr, ::VariableRef, ::VariableRef) is not defined because a GenericAffExpr cannot store the product of two variables.\n\n\n\n\n\n","category":"function"},{"location":"expressions/#JuMP.drop_zeros!","page":"Expressions","title":"JuMP.drop_zeros!","text":"drop_zeros!(expr::GenericAffExpr)\n\nRemove terms in the affine expression with 0 coefficients.\n\n\n\n\n\ndrop_zeros!(expr::GenericQuadExpr)\n\nRemove terms in the quadratic expression with 0 coefficients.\n\n\n\n\n\n","category":"function"},{"location":"quickstart/#Quick-Start-Guide-1","page":"Quick Start Guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"This quick start guide will introduce the main concepts of JuMP. If you are familiar with another modeling language embedded in a high-level language such as PuLP (Python) or a solver-specific interface you will find most of this familiar. If you are coming from an AMPL or similar background, you may find some of the concepts novel but the general appearance will still be familiar.","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"The example in this guide is deliberately kept simple. There are more complex examples in the JuMP/examples/ folder.","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"Once JuMP is installed, to use JuMP in your programs, you just need to say:","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> using JuMP","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"You also need to include a Julia package which provides an appropriate solver. One such solver is GLPK.Optimizer, which is provided by the GLPK.jl package.","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> using GLPK","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"See Installation Guide for a list of other solvers you can use.","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"Models are created with the Model function. The optimizer can be set either in Model() or by calling set_optimizer:","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> model = Model(GLPK.Optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: GLPK","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"equivalently,","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> model = Model();\njulia> set_optimizer(model, GLPK.Optimizer);\njulia> model\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: GLPK","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"note: Note\nThe term \"solver\" is used as a synonym for \"optimizer\". The convention in code, however, is to always use \"optimizer\", e.g., GLPK.Optimizer.","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"DocTestSetup = quote\n    # Using a mock optimizer removes the need to load a solver such as GLPK for\n    # building the documentation.\n    const MOI = JuMP.MathOptInterface\n    model = Model(() -> MOI.Utilities.MockOptimizer(\n                            MOIU.Model{Float64}(),\n                            eval_objective_value = false,\n                            eval_variable_constraint_dual = false))\nend","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"note: Note\nYour model doesn't have to be called model - it's just a name.","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"The following commands will create two variables, x and y, with both lower and upper bounds. Note the first argument is our model model. These variables (x and y) are associated with this model and cannot be used in another model.","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> @variable(model, 0 <= x <= 2)\nx\n\njulia> @variable(model, 0 <= y <= 30)\ny","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"See the Variables section for more information on creating variables, including the syntax for specifying different combinations of bounds, i.e., only lower bounds, only upper bounds, or no bounds.","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"DocTestSetup = nothing","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"Next we'll set our objective. Note again the model, so we know which model's objective we are setting! The objective sense, Max or Min, should be provided as the second argument. Note also that we don't have a multiplication * symbol between 5 and our variable x - Julia is smart enough to not need it! Feel free to use * if it makes you feel more comfortable, as we have done with 3 * y. (We have been intentionally inconsistent here to demonstrate different syntax; however, it is good practice to pick one way or the other consistently in your code.)","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> @objective(model, Max, 5x + 3 * y)\n5 x + 3 y","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"Adding constraints is a lot like setting the objective. Here we create a less-than-or-equal-to constraint using <=, but we can also create equality constraints using == and greater-than-or-equal-to constraints with >=:","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> @constraint(model, con, 1x + 5y <= 3)\ncon : x + 5 y <= 3.0","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"Note that in a similar manner to the @variable macro, we have named the constraint con. This will bind the constraint to the Julia variable con for later analysis.","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"Models are solved with the JuMP.optimize! function:","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> optimize!(model)","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"DocTestSetup = quote\n    # Now we load in the solution. Using a caching optimizer removes the need to\n    # load a solver such as GLPK for building the documentation.\n    mock = JuMP.backend(model).optimizer.model\n    MOI.set(mock, MOI.TerminationStatus(), MOI.OPTIMAL)\n    MOI.set(mock, MOI.PrimalStatus(), MOI.FEASIBLE_POINT)\n    MOI.set(mock, MOI.DualStatus(), MOI.FEASIBLE_POINT)\n    MOI.set(mock, MOI.ResultCount(), 1)\n    MOI.set(mock, MOI.ObjectiveValue(), 10.6)\n    MOI.set(mock, MOI.VariablePrimal(), JuMP.optimizer_index(x), 2.0)\n    MOI.set(mock, MOI.VariablePrimal(), JuMP.optimizer_index(y), 0.2)\n    MOI.set(mock, MOI.ConstraintDual(), JuMP.optimizer_index(con), -0.6)\n    MOI.set(mock, MOI.ConstraintDual(), JuMP.optimizer_index(UpperBoundRef(x)), -4.4)\n    MOI.set(mock, MOI.ConstraintDual(), JuMP.optimizer_index(LowerBoundRef(y)), 0.0)\nend","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"After the call to JuMP.optimize! has finished, we need to query what happened. The solve could terminate for a number of reasons. First, the solver might have found the optimal solution or proved that the problem is infeasible. However, it might also have run into numerical difficulties or terminated due to a setting such as a time limit. We can ask the solver why it stopped using the JuMP.termination_status function:","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> termination_status(model)\nOPTIMAL::TerminationStatusCode = 1","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"In this case, GLPK returned OPTIMAL, this mean that it has found the optimal solution.","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"DocTestSetup = nothing","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"As the solver found an optimal solution, we expect the solution returned to be a primal-dual pair of feasible solutions with zero duality gap. We can verify the primal and dual status as follows to confirm this:","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> primal_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1\n\njulia> dual_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"Note that the primal and dual status only inform that the primal and dual solutions are feasible and it is only because we verified that the termination status is OPTIMAL that we can conclude that they form an optimal solution.","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"Finally, we can query the result of the optimization. First, we can query the objective value:","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> objective_value(model)\n10.6","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"We can also query the primal result values of the x and y variables:","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> value(x)\n2.0\n\njulia> value(y)\n0.2","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"We can also query the value of the dual variable associated with the constraint con (which we bound to a Julia variable when defining the constraint):","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> dual(con)\n-0.6","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"info: Info\nSee the duality section for a discussion of the convention that JuMP uses for signs of duals.","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"To query the dual variables associated with the variable bounds, things are a little trickier as we first need to obtain a reference to the constraint:","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> x_upper = UpperBoundRef(x)\nx <= 2.0\n\njulia> dual(x_upper)\n-4.4","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"A similar process can be followed to obtain the dual of the lower bound constraint on y:","category":"page"},{"location":"quickstart/#","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> y_lower = LowerBoundRef(y)\ny >= 0.0\n\njulia> dual(y_lower)\n0.0","category":"page"},{"location":"objective/#Objective-1","page":"Objective","title":"Objective","text":"","category":"section"},{"location":"objective/#","page":"Objective","title":"Objective","text":"This page describes macros and functions related to linear and quadratic objective functions only, unless otherwise indicated. For nonlinear objective functions, see Nonlinear Modeling.","category":"page"},{"location":"objective/#","page":"Objective","title":"Objective","text":"Use the @objective macro to set linear and quadratic objective functions in a JuMP model. The functions set_objective_sense and set_objective_function provide an equivalent lower-level interface.","category":"page"},{"location":"objective/#","page":"Objective","title":"Objective","text":"To update a term in the objective function, see set_objective_coefficient. ","category":"page"},{"location":"objective/#","page":"Objective","title":"Objective","text":"To query the objective function from a model, see objective_sense, objective_function, and objective_function_type.","category":"page"},{"location":"objective/#","page":"Objective","title":"Objective","text":"To query the optimal objective value or best known bound after a solve, see objective_value and objective_bound. These two functions apply to nonlinear objectives also. The optimal value of the dual objective can be obtained via dual_objective_value.","category":"page"},{"location":"objective/#Reference-1","page":"Objective","title":"Reference","text":"","category":"section"},{"location":"objective/#","page":"Objective","title":"Objective","text":"@objective\nJuMP.set_objective_sense\nJuMP.set_objective_function\nJuMP.set_objective_coefficient\n\nJuMP.objective_sense\nJuMP.objective_function\nJuMP.objective_function_type\n\nJuMP.objective_bound\nJuMP.objective_value\nJuMP.dual_objective_value","category":"page"},{"location":"objective/#JuMP.@objective","page":"Objective","title":"JuMP.@objective","text":"@objective(model::Model, sense, func)\n\nSet the objective sense to sense and objective function to func. The objective sense can be either Min, Max, MathOptInterface.MIN_SENSE, MathOptInterface.MAX_SENSE or MathOptInterface.FEASIBILITY_SENSE; see MathOptInterface.ObjectiveSense. In order to set the sense programatically, i.e., when sense is a Julia variable whose value is the sense, one of the three MathOptInterface.ObjectiveSense values should be used. The function func can be a single JuMP variable, an affine expression of JuMP variables or a quadratic expression of JuMP variables.\n\nExamples\n\nTo minimize the value of the variable x, do as follows:\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @objective(model, Min, x)\nx\n\nTo maximize the value of the affine expression 2x - 1, do as follows:\n\njulia> @objective(model, Max, 2x - 1)\n2 x - 1\n\nTo set a quadratic objective and set the objective sense programatically, do as follows:\n\njulia> sense = MOI.MIN_SENSE\nMIN_SENSE::OptimizationSense = 0\n\njulia> @objective(model, sense, x^2 - 2x + 1)\nx² - 2 x + 1\n\n\n\n\n\n","category":"macro"},{"location":"objective/#JuMP.set_objective_sense","page":"Objective","title":"JuMP.set_objective_sense","text":"set_objective_sense(model::Model, sense::MathOptInterface.OptimizationSense)\n\nSets the objective sense of the model to the given sense. See set_objective_function to set the objective function. These are low-level functions; the recommended way to set the objective is with the @objective macro.\n\n\n\n\n\n","category":"function"},{"location":"objective/#JuMP.set_objective_function","page":"Objective","title":"JuMP.set_objective_function","text":"set_objective_function(\n    model::Model,\n    func::Union{AbstractJuMPScalar, MathOptInterface.AbstractScalarFunction})\n\nSets the objective function of the model to the given function. See set_objective_sense to set the objective sense. These are low-level functions; the recommended way to set the objective is with the @objective macro.\n\n\n\n\n\n","category":"function"},{"location":"objective/#JuMP.set_objective_coefficient","page":"Objective","title":"JuMP.set_objective_coefficient","text":"set_objective_coefficient(model::Model, variable::VariableRef, coefficient::Real)\n\nSet the linear objective coefficient associated with Variable to coefficient.\n\nNote: this function will throw an error if a nonlinear objective is set.\n\n\n\n\n\n","category":"function"},{"location":"objective/#JuMP.objective_sense","page":"Objective","title":"JuMP.objective_sense","text":"objective_sense(model::Model)::MathOptInterface.OptimizationSense\n\nReturn the objective sense.\n\n\n\n\n\n","category":"function"},{"location":"objective/#JuMP.objective_function","page":"Objective","title":"JuMP.objective_function","text":"objective_function(model::Model,\n               T::Type{<:AbstractJuMPScalar}=objective_function_type(model))\n\nReturn an object of type T representing the objective function. Error if the objective is not convertible to type T.\n\nExamples\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @objective(model, Min, 2x + 1)\n2 x + 1\n\njulia> objective_function(model, AffExpr)\n2 x + 1\n\njulia> objective_function(model, QuadExpr)\n2 x + 1\n\njulia> typeof(objective_function(model, QuadExpr))\nGenericQuadExpr{Float64,VariableRef}\n\nWe see with the last two commands that even if the objective function is affine, as it is convertible to a quadratic function, it can be queried as a quadratic function and the result is quadratic.\n\nHowever, it is not convertible to a variable.\n\njulia> objective_function(model, VariableRef)\nERROR: InexactError: convert(MathOptInterface.SingleVariable, MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 1.0))\n[...]\n\n\n\n\n\n","category":"function"},{"location":"objective/#JuMP.objective_function_type","page":"Objective","title":"JuMP.objective_function_type","text":"objective_function_type(model::Model)::AbstractJuMPScalar\n\nReturn the type of the objective function.\n\n\n\n\n\n","category":"function"},{"location":"objective/#JuMP.objective_bound","page":"Objective","title":"JuMP.objective_bound","text":"objective_bound(model::Model)\n\nReturn the best known bound on the optimal objective value after a call to optimize!(model).\n\n\n\n\n\n","category":"function"},{"location":"objective/#JuMP.objective_value","page":"Objective","title":"JuMP.objective_value","text":"objective_value(model::Model; result::Int = 1)\n\nReturn the objective value associated with result index result of the most-recent solution returned by the solver.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"objective/#JuMP.dual_objective_value","page":"Objective","title":"JuMP.dual_objective_value","text":"dual_objective_value(model::Model; result::Int = 1)\n\nReturn the value of the objective of the dual problem associated with result index result of the most-recent solution returned by the solver.\n\nThrows MOI.UnsupportedAttribute{MOI.DualObjectiveValue} if the solver does not support this attribute.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"callbacks/#Callbacks-1","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"Many mixed-integer (linear, conic, and nonlinear) programming solvers offer the ability to modify the solve process. Examples include changing branching decisions in branch-and-bound, adding custom cutting planes, providing custom heuristics to find feasible solutions, or implementing on-demand separators to add new constraints only when they are violated by the current solution (also known as lazy constraints).","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"While historically this functionality has been limited to solver-specific interfaces, JuMP provides solver-independent support for three types of callbacks:","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"lazy constraints\nuser-cuts\nheuristic solutions","category":"page"},{"location":"callbacks/#Available-solvers-1","page":"Callbacks","title":"Available solvers","text":"","category":"section"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"Callback support is limited to a few solvers. This includes CPLEX, GLPK, and Gurobi.","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"warning: Warning\nWhile JuMP provides a solver-independent way of accessing callbacks, you should not assume that you will see identical behavior when running the same code on different solvers. For example, some solvers may ignore user-cuts for various reasons, while other solvers may add every user-cut. Read the underlying solver's callback documentation to understand details specific to each solver.","category":"page"},{"location":"callbacks/#Information-that-can-be-queried-during-callbacks-1","page":"Callbacks","title":"Information that can be queried during callbacks","text":"","category":"section"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"In a callback, the only thing you may query is the primal value of the variables using callback_value.","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"If you need any other information, use a solver-dependent callback instead.","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"info: Info\nSolver-dependent callbacks are mostly un-documented. Using them will require you to read and understand the source-code of solver's Julia wrapper (i.e., the Solver.jl package).","category":"page"},{"location":"callbacks/#Lazy-constraints-1","page":"Callbacks","title":"Lazy constraints","text":"","category":"section"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"Lazy constraints are useful when the full set of constraints is too large to explicitly include in the initial formulation. When a MIP solver reaches a new solution, for example with a heuristic or by solving a problem at a node in the branch-and-bound tree, it will give the user the chance to provide constraint(s) that would make the current solution infeasible. For some more information about lazy constraints, see this blog post by Paul Rubin.","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"A lazy constraint callback can be set using the following syntax:","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"model = Model(GLPK.Optimizer)\n@variable(model, x <= 10, Int)\n@objective(model, Max, x)\nfunction my_callback_function(cb_data)\n    x_val = callback_value(cb_data, x)\n    if x_val > 2 + 1e-6\n        con = @build_constraint(x <= 2)\n        MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n    end\nend\nMOI.set(model, MOI.LazyConstraintCallback(), my_callback_function)","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"info: Info\nThe lazy constraint callback may be called at fractional or integer nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every feasible primal solution.","category":"page"},{"location":"callbacks/#User-cuts-1","page":"Callbacks","title":"User cuts","text":"","category":"section"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"User cuts, or simply cuts, provide a way for the user to tighten the LP relaxation using problem-specific knowledge that the solver cannot or is unable to infer from the model. Just like with lazy constraints, when a MIP solver reaches a new node in the branch-and-bound tree, it will give the user the chance to provide cuts to make the current relaxed (fractional) solution infeasible in the hopes of obtaining an integer solution. For more details about the difference between user cuts and lazy constraints see the aforementioned blog post.","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"A user-cut callback can be set using the following syntax:","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"model = Model(GLPK.Optimizer)\n@variable(model, x <= 10.5, Int)\n@objective(model, Max, x)\nfunction my_callback_function(cb_data)\n    x_val = callback_value(cb_data, x)\n    con = @build_constraint(x <= floor(x_val))\n    MOI.submit(model, MOI.UserCut(cb_data), con)\nend\nMOI.set(model, MOI.UserCutCallback(), my_callback_function)","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"warning: Warning\nYour user cuts should not change the set of integer feasible solutions. Equivalently, your cuts can only remove fractional solutions. If you add a cut that removes an integer solution, the solver may return an incorrect solution.","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"info: Info\nThe user-cut callback may be called at fractional nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every fractional primal solution.","category":"page"},{"location":"callbacks/#Heuristic-solutions-1","page":"Callbacks","title":"Heuristic solutions","text":"","category":"section"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"Integer programming solvers frequently include heuristics that run at the nodes of the branch-and-bound tree. They aim to find integer solutions quicker than plain branch-and-bound would to tighten the bound, allowing us to fathom nodes quicker and to tighten the integrality gap.","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"Some heuristics take integer solutions and explore their \"local neighborhood\" (e.g., flipping binary variables, fix some variables and solve a smaller MILP) and others take fractional solutions and attempt to round them in an intelligent way.","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"You may want to add a heuristic of your own if you have some special insight into the problem structure that the solver is not aware of, e.g. you can consistently take fractional solutions and intelligently guess integer solutions from them.","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"A heuristic solution callback can be set using the following syntax:","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"model = Model(GLPK.Optimizer)\n@variable(model, x <= 10.5, Int)\n@objective(model, Max, x)\nfunction my_callback_function(cb_data)\n    x_val = callback_value(cb_data, x)\n    status = MOI.submit(\n        model, MOI.HeuristicSolution(cb_data), [x], [floor(Int, x_val)]\n    )\n    println(\"I submitted a heuristic solution, and the status was: \", status)\nend\nMOI.set(model, MOI.HeuristicCallback(), my_callback_function)","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"The third argument to submit should be a vector of JuMP variables, and the fourth argument should be a vector of values corresponding to each variable.","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"MOI.submit returns an enum that depends on whether the solver accepted the solution. The possible return codes are:","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"MOI.HEURISTIC_SOLUTION_ACCEPTED\nMOI.HEURISTIC_SOLUTION_REJECTED\nMOI.HEURISTIC_SOLUTION_UNKNOWN","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"warning: Warning\nSome solvers may accept partial solutions. Others require a feasible integer solution for every variable. If in doubt, provide a complete solution.","category":"page"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"info: Info\nThe heuristic solution callback may be called at fractional nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every fractional primal solution.","category":"page"},{"location":"callbacks/#Reference-1","page":"Callbacks","title":"Reference","text":"","category":"section"},{"location":"callbacks/#","page":"Callbacks","title":"Callbacks","text":"callback_value","category":"page"},{"location":"callbacks/#JuMP.callback_value","page":"Callbacks","title":"JuMP.callback_value","text":"callback_value(cb_data, x::VariableRef)\n\nReturn the primal solution of a variable inside a callback.\n\ncb_data is the argument to the callback function, and the type is dependent on the solver.\n\n\n\n\n\n","category":"function"},{"location":"#![JuMP-logo](assets/jump-logo-with-text.svg)-1","page":"Introduction","title":"(Image: JuMP logo)","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: Powered by NumFOCUS)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"# These comments do not display in the HTML output.\n# See https://github.com/JuliaDocs/Documenter.jl/issues/674.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"warning: Warning\nBetween versions 0.18 and 0.19, JuMP underwent a major transition in its underlying solver abstraction API, from MathProgBase to MathOptInterface. See NEWS.md for a comprehensive list of changes between the two versions, many of which are breaking. This documentation is for JuMP/MathOptInterface. For the documentation of JuMP 0.18, see here.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"JuMP is a domain-specific modeling language for mathematical optimization embedded in Julia. It currently supports a number of open-source and commercial solvers (see below) for a variety of problem classes, including linear programming, mixed-integer programming, second-order conic programming, semidefinite programming, and nonlinear programming. JuMP's features include:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"User friendliness\nSyntax that mimics natural mathematical expressions.\nComplete documentation (WIP!)\nSpeed\nBenchmarking has shown that JuMP can create problems at similar speeds   to special-purpose modeling languages such as   AMPL.\nJuMP communicates with most solvers in memory, avoiding the need to   write intermediary files.\nSolver independence\nJuMP uses a generic solver-independent interface provided by the   MathOptInterface   package, making it easy to change between a number of open-source and   commercial optimization software packages (\"solvers\").\nCurrently supported solvers include   Artelys Knitro,   Bonmin,   Cbc,   Clp,   Couenne,   CPLEX,   ECOS,   FICO Xpress,   GLPK,   Gurobi,   Ipopt,   MOSEK,   NLopt, and   SCS.\nAccess to advanced algorithmic techniques\nIncluding efficient LP re-solves which previously required using   solver-specific and/or low-level C++ libraries.\nEase of embedding\nJuMP itself is written purely in Julia. Solvers are the only binary   dependencies.\nBeing embedded in a general-purpose programming language makes it easy   to solve optimization problems as part of a larger workflow (e.g.,   inside a simulation, behind a web server, or as a subproblem in a   decomposition algorithm).\nAs a trade-off, JuMP's syntax is constrained by the syntax available   in Julia.\nJuMP is MPL licensed, meaning that   it can be embedded in commercial software that complies with the terms   of the license.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Although JuMP has not reached version 1.0 yet, the releases are stable enough for everyday use and are being used in a number of research projects and neat applications by a growing community of users who are early adopters. JuMP remains under active development, and we welcome your feedback, suggestions, and bug reports.","category":"page"},{"location":"#Contents-1","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"installation.md\",\n    \"quickstart.md\",\n    \"variables.md\",\n    \"expressions.md\",\n    \"objective.md\",\n    \"constraints.md\",\n    \"containers.md\",\n    \"solvers.md\",\n    \"solutions.md\",\n    \"nlp.md\",\n    \"style.md\",\n    \"extensions.md\",\n    \"roadmap.md\"\n]\nDepth = 2","category":"page"},{"location":"#Citing-JuMP-1","page":"Introduction","title":"Citing JuMP","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you find JuMP useful in your work, we kindly request that you cite the following paper (pdf):","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"@article{DunningHuchetteLubin2017,\nauthor = {Iain Dunning and Joey Huchette and Miles Lubin},\ntitle = {JuMP: A Modeling Language for Mathematical Optimization},\njournal = {SIAM Review},\nvolume = {59},\nnumber = {2},\npages = {295-320},\nyear = {2017},\ndoi = {10.1137/15M1020575},\n}","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"For an earlier work where we presented a prototype implementation of JuMP, see here:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"@article{LubinDunningIJOC,\nauthor = {Miles Lubin and Iain Dunning},\ntitle = {Computing in Operations Research Using Julia},\njournal = {INFORMS Journal on Computing},\nvolume = {27},\nnumber = {2},\npages = {238-248},\nyear = {2015},\ndoi = {10.1287/ijoc.2014.0623},\n}","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"A preprint of this paper is freely available.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: NumFOCUS logo)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"JuMP is a Sponsored Project of NumFOCUS, a 501(c)(3) nonprofit charity in the  United States. NumFOCUS provides JuMP with fiscal, legal, and administrative  support to help ensure the health and sustainability of the project. Visit  numfocus.org for more information.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"You can support JuMP by donating. ","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Donations to JuMP are managed by NumFOCUS. For donors in the United States,  your gift is tax-deductible to the extent provided by law. As with any donation,  you should consult with your tax adviser about your particular tax situation.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"JuMP's largest expense is the annual JuMP-dev workshop. Donations will help us  provide travel support for JuMP-dev attendees and take advantage of other  opportunities that arise to support JuMP development.","category":"page"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"CurrentModule = JuMP","category":"page"},{"location":"extensions/#Extending-JuMP-1","page":"Extensions","title":"Extending JuMP","text":"","category":"section"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"# TODO: How to extend JuMP: discussion on different ways to build on top of JuMP.\n# How to extend JuMP's macros and how to avoid doing this.","category":"page"},{"location":"extensions/#Extending-MOI-1","page":"Extensions","title":"Extending MOI","text":"","category":"section"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"# TODO: Create new MOI function/sets, how to use it in JuMP","category":"page"},{"location":"extensions/#Adding-a-bridge-1","page":"Extensions","title":"Adding a bridge","text":"","category":"section"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"# TODO: create new bridge","category":"page"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"See the bridge section in the MOI manual.","category":"page"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"add_bridge\nBridgeableConstraint","category":"page"},{"location":"extensions/#JuMP.add_bridge","page":"Extensions","title":"JuMP.add_bridge","text":" add_bridge(model::Model,\n            BridgeType::Type{<:MOI.Bridges.AbstractBridge})\n\nAdd BridgeType to the list of bridges that can be used to transform unsupported constraints into an equivalent formulation using only constraints supported by the optimizer.\n\n\n\n\n\n","category":"function"},{"location":"extensions/#JuMP.BridgeableConstraint","page":"Extensions","title":"JuMP.BridgeableConstraint","text":"struct BridgeableConstraint{C, B} <: AbstractConstraint\n    constraint::C\n    bridge_type::B\nend\n\nConstraint constraint that can be bridged by the bridge of type bridge_type. Adding this constraint to a model is equivalent to\n\nadd_bridge(model, bridge_type)\nadd_constraint(model, constraint)\n\nExamples\n\nGiven a new scalar set type CustomSet with a bridge CustomBridge that can bridge F-in-CustomSet constraints, when the user does\n\nmodel = Model()\n@variable(model, x)\n@constraint(model, x + 1 in CustomSet())\noptimize!(model)\n\nwith an optimizer that does not support F-in-CustomSet constraints, the constraint will not be bridge unless he manually calls add_bridge(model, CustomBridge). In order to automatically add the CustomBridge to any model to which an F-in-CustomSet is added, simply add the following method:\n\nfunction JuMP.build_constraint(_error::Function, func::AbstractJuMPScalar,\n                               set::CustomSet)\n    constraint = ScalarConstraint(func, set)\n    return JuMP.BridgeableConstraint(constraint, CustomBridge)\nend\n\nNote\n\nJuMP extensions should extend JuMP.build_constraint only if they also defined CustomSet, for three reasons:\n\nIt is problematic if multiple extensions overload the same JuMP method.\nA missing method will not inform the users that they forgot to load the extension module defining the build_constraint method.\nDefining a method where neither the function nor any of the argument types are defined in the package is called type piracy and is discouraged in the Julia style guide.\n\n```\n\n\n\n\n\n","category":"type"},{"location":"extensions/#Extending-JuMP-macros-1","page":"Extensions","title":"Extending JuMP macros","text":"","category":"section"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"In order to provide a convenient syntax for the user to create variables, constraints or set the objective of a JuMP extension, it might be required to use macros similar to @variable, @constraint and @objective. It is recommended to first check whether it is possible to extend one of these three macros before creating a new one so as to leverage all their features and provide a more consistent interface to the user.","category":"page"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"### Extending the `@variable` macro\n\n# TODO: parse/build/add","category":"page"},{"location":"extensions/#Extending-the-@constraint-macro-1","page":"Extensions","title":"Extending the @constraint macro","text":"","category":"section"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"The @constraint macro always calls the same three functions:","category":"page"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"parse_constraint: is called at parsing time, it parses the constraint expression and returns a build_constraint call expression;\nbuild_constraint: given the functions and sets involved in the constraints, it returns a AbstractConstraint;\nadd_constraint: given the model, the AbstractConstraint constructed in build_constraint and the constraint name, it stores them in the model and returns a ConstraintRef.","category":"page"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"Adding methods to these functions is the recommended way to extend the @constraint macro.","category":"page"},{"location":"extensions/#Adding-parse_constraint-methods-1","page":"Extensions","title":"Adding parse_constraint methods","text":"","category":"section"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"# TODO(Benoît): Detail how `parse_constraint` works and show how `sense_to_set`\n#               fits into the picture.","category":"page"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"sense_to_set","category":"page"},{"location":"extensions/#JuMP.sense_to_set","page":"Extensions","title":"JuMP.sense_to_set","text":"sense_to_set(_error::Function, ::Val{sense_symbol})\n\nConverts a sense symbol to a set set such that @constraint(model, func sense_symbol 0) is equivalent to@constraint(model, func in set)for anyfunc::AbstractJuMPScalar`.\n\nExample\n\nOnce a custom set is defined you can directly create a JuMP constraint with it:\n\njulia> struct CustomSet{T} <: MOI.AbstractScalarSet\n           value::T\n       end\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> cref = @constraint(model, x in CustomSet(1.0))\nx ∈ CustomSet{Float64}(1.0)\n\nHowever, there might be an appropriate sign that could be used in order to provide a more convenient syntax:\n\njulia> JuMP.sense_to_set(::Function, ::Val{:⊰}) = CustomSet(0.0)\n\njulia> MOIU.shift_constant(set::CustomSet, value) = CustomSet(set.value + value)\n\njulia> cref = @constraint(model, x ⊰ 1)\nx ∈ CustomSet{Float64}(1.0)\n\nNote that the whole function is first moved to the right-hand side, then the sign is transformed into a set with zero constant and finally the constant is moved to the set with MOIU.shift_constant.\n\n\n\n\n\n","category":"function"},{"location":"extensions/#Adding-build_constraint-methods-1","page":"Extensions","title":"Adding build_constraint methods","text":"","category":"section"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"There is typically two choices when creating a build_constraint method, either return an AbstractConstraint already supported by the model, i.e. ScalarConstraint or VectorConstraint, or a custom AbstractConstraint with a corresponding add_constraint method (see Adding add_constraint methods).","category":"page"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"build_constraint","category":"page"},{"location":"extensions/#JuMP.build_constraint","page":"Extensions","title":"JuMP.build_constraint","text":"build_constraint(_error::Function, Q::Symmetric{V, M},\n                 ::PSDCone) where {V <: AbstractJuMPScalar,\n                                   M <: AbstractMatrix{V}}\n\nReturn a VectorConstraint of shape SymmetricMatrixShape constraining the matrix Q to be positive semidefinite.\n\nThis function is used by the @constraint macros as follows:\n\n@constraint(model, Symmetric(Q) in PSDCone())\n\nThe form above is usually used when the entries of Q are affine or quadratic expressions but it can also be used when the entries are variables to get the reference of the semidefinite constraint, e.g.,\n\n@variable model Q[1:2,1:2] Symmetric\n# The type of `Q` is `Symmetric{VariableRef, Matrix{VariableRef}}`\nvar_psd = @constraint model Q in PSDCone()\n# The `var_psd` variable contains a reference to the constraint\n\n\n\n\n\nbuild_constraint(_error::Function,\n                 Q::AbstractMatrix{<:AbstractJuMPScalar},\n                 ::PSDCone)\n\nReturn a VectorConstraint of shape SquareMatrixShape constraining the matrix Q to be symmetric and positive semidefinite.\n\nThis function is used by the @constraint and @SDconstraint macros as follows:\n\n@constraint(model, Q in PSDCone())\n@SDconstraint(model, P ⪰ Q)\n\nThe @constraint call above is usually used when the entries of Q are affine or quadratic expressions but it can also be used when the entries are variables to get the reference of the semidefinite constraint, e.g.,\n\n@variable model Q[1:2,1:2]\n# The type of `Q` is `Matrix{VariableRef}`\nvar_psd = @constraint model Q in PSDCone()\n# The `var_psd` variable contains a reference to the constraint\n\n\n\n\n\n","category":"function"},{"location":"extensions/#Shapes-1","page":"Extensions","title":"Shapes","text":"","category":"section"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"Shapes allow vector constraints, which are represented as flat vectors in MOI, to retain a matrix shape at the JuMP level. There is a shape field in VectorConstraint that can be set in build_constraint and that is used to reshape the result computed in value and dual.","category":"page"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"AbstractShape\nshape\nreshape_vector\nreshape_set\ndual_shape\nScalarShape\nVectorShape\nSquareMatrixShape\nSymmetricMatrixShape","category":"page"},{"location":"extensions/#JuMP.AbstractShape","page":"Extensions","title":"JuMP.AbstractShape","text":"AbstractShape\n\nAbstract vectorizable shape. Given a flat vector form of an object of shape shape, the original object can be obtained by reshape_vector.\n\n\n\n\n\n","category":"type"},{"location":"extensions/#JuMP.shape","page":"Extensions","title":"JuMP.shape","text":"shape(c::AbstractConstraint)::AbstractShape\n\nReturn the shape of the constraint c.\n\n\n\n\n\n","category":"function"},{"location":"extensions/#JuMP.reshape_vector","page":"Extensions","title":"JuMP.reshape_vector","text":"reshape_vector(vectorized_form::Vector, shape::AbstractShape)\n\nReturn an object in its original shape shape given its vectorized form vectorized_form.\n\nExamples\n\nGiven a SymmetricMatrixShape of vectorized form [1, 2, 3], the following code returns the matrix Symmetric(Matrix[1 2; 2 3]):\n\njulia> reshape_vector([1, 2, 3], SymmetricMatrixShape(2))\n2×2 LinearAlgebra.Symmetric{Int64,Array{Int64,2}}:\n 1  2\n 2  3\n\n\n\n\n\n","category":"function"},{"location":"extensions/#JuMP.reshape_set","page":"Extensions","title":"JuMP.reshape_set","text":"reshape_set(vectorized_set::MOI.AbstractSet, shape::AbstractShape)\n\nReturn a set in its original shape shape given its vectorized form vectorized_form.\n\nExamples\n\nGiven a SymmetricMatrixShape of vectorized form [1, 2, 3] in MOI.PositiveSemidefinieConeTriangle(2), the following code returns the set of the original constraint Symmetric(Matrix[1 2; 2 3]) in PSDCone():\n\njulia> reshape_set(MOI.PositiveSemidefiniteConeTriangle(2), SymmetricMatrixShape(2))\nPSDCone()\n\n\n\n\n\n","category":"function"},{"location":"extensions/#JuMP.dual_shape","page":"Extensions","title":"JuMP.dual_shape","text":"dual_shape(shape::AbstractShape)::AbstractShape\n\nReturns the shape of the dual space of the space of objects of shape shape. By default, the dual_shape of a shape is itself. See the examples section below for an example for which this is not the case.\n\nExamples\n\nConsider polynomial constraints for which the dual is moment constraints and moment constraints for which the dual is polynomial constraints. Shapes for polynomials can be defined as follows:\n\nstruct Polynomial\n    coefficients::Vector{Float64}\n    monomials::Vector{Monomial}\nend\nstruct PolynomialShape <: AbstractShape\n    monomials::Vector{Monomial}\nend\nJuMP.reshape_vector(x::Vector, shape::PolynomialShape) = Polynomial(x, shape.monomials)\n\nand a shape for moments can be defined as follows:\n\nstruct Moments\n    coefficients::Vector{Float64}\n    monomials::Vector{Monomial}\nend\nstruct MomentsShape <: AbstractShape\n    monomials::Vector{Monomial}\nend\nJuMP.reshape_vector(x::Vector, shape::MomentsShape) = Moments(x, shape.monomials)\n\nThe dual_shape allows to define the shape of the dual of polynomial and moment constraints:\n\ndual_shape(shape::PolynomialShape) = MomentsShape(shape.monomials)\ndual_shape(shape::MomentsShape) = PolynomialShape(shape.monomials)\n\n\n\n\n\n","category":"function"},{"location":"extensions/#JuMP.ScalarShape","page":"Extensions","title":"JuMP.ScalarShape","text":"ScalarShape\n\nShape of scalar constraints.\n\n\n\n\n\n","category":"type"},{"location":"extensions/#JuMP.VectorShape","page":"Extensions","title":"JuMP.VectorShape","text":"VectorShape\n\nVector for which the vectorized form corresponds exactly to the vector given.\n\n\n\n\n\n","category":"type"},{"location":"extensions/#JuMP.SquareMatrixShape","page":"Extensions","title":"JuMP.SquareMatrixShape","text":"SquareMatrixShape\n\nShape object for a square matrix of side_dimension rows and columns. The vectorized form contains the entries of the the matrix given column by column (or equivalently, the entries of the lower-left triangular part given row by row).\n\n\n\n\n\n","category":"type"},{"location":"extensions/#JuMP.SymmetricMatrixShape","page":"Extensions","title":"JuMP.SymmetricMatrixShape","text":"SymmetricMatrixShape\n\nShape object for a symmetric square matrix of side_dimension rows and columns. The vectorized form contains the entries of the upper-right triangular part of the matrix given column by column (or equivalently, the entries of the lower-left triangular part given row by row).\n\n\n\n\n\n","category":"type"},{"location":"extensions/#Adding-add_constraint-methods-1","page":"Extensions","title":"Adding add_constraint methods","text":"","category":"section"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"# TODO: Introduce `add_constraint`","category":"page"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"add_constraint","category":"page"},{"location":"extensions/#JuMP.add_constraint","page":"Extensions","title":"JuMP.add_constraint","text":"add_constraint(model::Model, con::AbstractConstraint, name::String=\"\")\n\nAdd a constraint con to Model model and sets its name.\n\n\n\n\n\n","category":"function"},{"location":"extensions/#","page":"Extensions","title":"Extensions","text":"### Extending the [`@objective`](@ref) macro\n\n# TODO: Describe how to `@objective` macro by implementing new `JuMP.set_objective_function` methods\n\n## Defining new JuMP models\n\n# TODO: Describe how to create a new JuMP model (similar to `test/JuMPExtension.jl` and StructJuMP).","category":"page"}]
}
