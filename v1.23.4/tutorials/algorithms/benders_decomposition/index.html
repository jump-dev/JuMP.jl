<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Benders decomposition · JuMP</title><meta name="title" content="Benders decomposition · JuMP"/><meta property="og:title" content="Benders decomposition · JuMP"/><meta property="twitter:title" content="Benders decomposition · JuMP"/><meta name="description" content="Documentation for JuMP."/><meta property="og:description" content="Documentation for JuMP."/><meta property="twitter:description" content="Documentation for JuMP."/><script async src="https://www.googletagmanager.com/gtag/js?id=G-0RZ8X3D3D0"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-0RZ8X3D3D0', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/extra_styles.css" rel="stylesheet" type="text/css"/><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img class="docs-light-only" src="../../../assets/logo.svg" alt="JuMP logo"/><img class="docs-dark-only" src="../../../assets/logo-dark.svg" alt="JuMP logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../">Introduction</a></li><li><a class="tocitem" href="../../../should_i_use/">Should you use JuMP?</a></li><li><a class="tocitem" href="../../../installation/">Installation Guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../getting_started/introduction/">Introduction</a></li><li><a class="tocitem" href="../../getting_started/getting_started_with_julia/">Getting started with Julia</a></li><li><a class="tocitem" href="../../getting_started/getting_started_with_JuMP/">Getting started with JuMP</a></li><li><a class="tocitem" href="../../getting_started/getting_started_with_sets_and_indexing/">Getting started with sets and indexing</a></li><li><a class="tocitem" href="../../getting_started/getting_started_with_data_and_plotting/">Getting started with data and plotting</a></li><li><a class="tocitem" href="../../getting_started/debugging/">Debugging</a></li><li><a class="tocitem" href="../../getting_started/tolerances/">Tolerances and numerical issues</a></li><li><a class="tocitem" href="../../getting_started/design_patterns_for_larger_models/">Design patterns for larger models</a></li><li><a class="tocitem" href="../../getting_started/performance_tips/">Performance tips</a></li><li><a class="tocitem" href="../../getting_started/sum_if/">Performance problems with sum-if formulations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Transitioning</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../transitioning/transitioning_from_matlab/">Transitioning from MATLAB</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Linear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../linear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../linear/knapsack/">The knapsack problem example</a></li><li><a class="tocitem" href="../../linear/diet/">The diet problem</a></li><li><a class="tocitem" href="../../linear/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../../linear/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../../linear/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../../linear/multi_commodity_network/">The network multi-commodity flow problem</a></li><li><a class="tocitem" href="../../linear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../linear/piecewise_linear/">Approximating nonlinear functions</a></li><li><a class="tocitem" href="../../linear/facility_location/">The facility location problem</a></li><li><a class="tocitem" href="../../linear/finance/">Financial modeling problems</a></li><li><a class="tocitem" href="../../linear/geographic_clustering/">Geographical clustering</a></li><li><a class="tocitem" href="../../linear/network_flows/">Network flow problems</a></li><li><a class="tocitem" href="../../linear/transp/">The transportation problem</a></li><li><a class="tocitem" href="../../linear/multi_objective_knapsack/">Multi-objective knapsack</a></li><li><a class="tocitem" href="../../linear/multi_objective_examples/">Simple multi-objective examples</a></li><li><a class="tocitem" href="../../linear/sudoku/">Sudoku</a></li><li><a class="tocitem" href="../../linear/n-queens/">N-Queens</a></li><li><a class="tocitem" href="../../linear/constraint_programming/">Constraint programming</a></li><li><a class="tocitem" href="../../linear/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../linear/lp_sensitivity/">Sensitivity analysis of a linear program</a></li><li><a class="tocitem" href="../../linear/basis/">Basis matrices</a></li><li><a class="tocitem" href="../../linear/mip_duality/">Computing the duals of a mixed-integer program</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Nonlinear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../nonlinear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../nonlinear/simple_examples/">Simple examples</a></li><li><a class="tocitem" href="../../nonlinear/tips_and_tricks/">User-defined operators with vector outputs</a></li><li><a class="tocitem" href="../../nonlinear/operator_ad/">Automatic differentiation of user-defined operators</a></li><li><a class="tocitem" href="../../nonlinear/user_defined_hessians/">User-defined Hessians</a></li><li><a class="tocitem" href="../../nonlinear/nested_problems/">Nested optimization problems</a></li><li><a class="tocitem" href="../../nonlinear/querying_hessians/">Computing Hessians</a></li><li><a class="tocitem" href="../../nonlinear/complementarity/">Example: mixed complementarity problems</a></li><li><a class="tocitem" href="../../nonlinear/classifiers/">Example: classification problems</a></li><li><a class="tocitem" href="../../nonlinear/portfolio/">Example: portfolio optimization</a></li><li><a class="tocitem" href="../../nonlinear/rocket_control/">Example: nonlinear optimal control of a rocket</a></li><li><a class="tocitem" href="../../nonlinear/space_shuttle_reentry_trajectory/">Example: optimal control for a Space Shuttle reentry trajectory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Conic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../conic/introduction/">Introduction</a></li><li><a class="tocitem" href="../../conic/tips_and_tricks/">Modeling with cones</a></li><li><a class="tocitem" href="../../conic/dualization/">Dualization</a></li><li><a class="tocitem" href="../../conic/arbitrary_precision/">Arbitrary precision arithmetic</a></li><li><a class="tocitem" href="../../conic/start_values/">Primal and dual warm-starts</a></li><li><a class="tocitem" href="../../conic/simple_examples/">Simple semidefinite programming examples</a></li><li><a class="tocitem" href="../../conic/logistic_regression/">Example: logistic regression</a></li><li><a class="tocitem" href="../../conic/experiment_design/">Example: experiment design</a></li><li><a class="tocitem" href="../../conic/min_ellipse/">Example: minimal ellipses</a></li><li><a class="tocitem" href="../../conic/ellipse_approx/">Example: ellipsoid approximation</a></li><li><a class="tocitem" href="../../conic/quantum_discrimination/">Example: quantum state discrimination</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox" checked/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Benders decomposition</a><ul class="internal"><li><a class="tocitem" href="#Theory"><span>Theory</span></a></li><li><a class="tocitem" href="#Monolithic-problem"><span>Monolithic problem</span></a></li><li><a class="tocitem" href="#benders_iterative"><span>Iterative method</span></a></li><li><a class="tocitem" href="#Callback-method"><span>Callback method</span></a></li><li><a class="tocitem" href="#In-place-iterative-method"><span>In-place iterative method</span></a></li><li><a class="tocitem" href="#Feasibility-cuts"><span>Feasibility cuts</span></a></li></ul></li><li><a class="tocitem" href="../cutting_stock_column_generation/">Column generation</a></li><li><a class="tocitem" href="../tsp_lazy_constraints/">Traveling Salesperson Problem</a></li><li><a class="tocitem" href="../rolling_horizon/">Rolling horizon problems</a></li><li><a class="tocitem" href="../parallelism/">Parallelism</a></li><li><a class="tocitem" href="../pdhg/">Writing a solver interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-7" type="checkbox"/><label class="tocitem" for="menuitem-2-7"><span class="docs-label">Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/power_systems/">Power Systems</a></li><li><a class="tocitem" href="../../applications/optimal_power_flow/">Optimal power flow</a></li><li><a class="tocitem" href="../../applications/web_app/">Serving web apps</a></li><li><a class="tocitem" href="../../applications/two_stage_stochastic/">Two-stage stochastic programs</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../manual/models/">Models</a></li><li><a class="tocitem" href="../../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../manual/expressions/">Expressions</a></li><li><a class="tocitem" href="../../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../../manual/containers/">Containers</a></li><li><a class="tocitem" href="../../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../manual/callbacks/">Solver-independent Callbacks</a></li><li><a class="tocitem" href="../../../manual/complex/">Complex number support</a></li><li><a class="tocitem" href="../../../manual/nonlinear/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../../manual/nlp/">Nonlinear Modeling (Legacy)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../api/JuMP/">JuMP</a></li><li><a class="tocitem" href="../../../api/JuMP.Containers/">JuMP.Containers</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Background Information</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../background/algebraic_modeling_languages/">Algebraic modeling languages</a></li><li><a class="tocitem" href="../../../background/bibliography/">Bibliography</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../developers/contributing/">Contributing</a></li><li><a class="tocitem" href="../../../developers/extensions/">Extensions</a></li><li><a class="tocitem" href="../../../developers/custom_solver_binaries/">Custom binaries</a></li><li><a class="tocitem" href="../../../developers/style/">Style Guide</a></li><li><a class="tocitem" href="../../../developers/roadmap/">Roadmap</a></li><li><a class="tocitem" href="../../../developers/checklists/">Checklists</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../packages/solvers/">Introduction</a></li><li><a class="tocitem" href="../../../packages/AmplNLWriter/">jump-dev/AmplNLWriter.jl</a></li><li><a class="tocitem" href="../../../packages/BARON/">jump-dev/BARON.jl</a></li><li><a class="tocitem" href="../../../packages/CPLEX/">jump-dev/CPLEX.jl</a></li><li><a class="tocitem" href="../../../packages/CSDP/">jump-dev/CSDP.jl</a></li><li><a class="tocitem" href="../../../packages/Cbc/">jump-dev/Cbc.jl</a></li><li><a class="tocitem" href="../../../packages/Clp/">jump-dev/Clp.jl</a></li><li><a class="tocitem" href="../../../packages/DSDP/">jump-dev/DSDP.jl</a></li><li><a class="tocitem" href="../../../packages/Dualization/">jump-dev/Dualization.jl</a></li><li><a class="tocitem" href="../../../packages/ECOS/">jump-dev/ECOS.jl</a></li><li><a class="tocitem" href="../../../packages/GLPK/">jump-dev/GLPK.jl</a></li><li><a class="tocitem" href="../../../packages/Gurobi/">jump-dev/Gurobi.jl</a></li><li><a class="tocitem" href="../../../packages/HiGHS/">jump-dev/HiGHS.jl</a></li><li><a class="tocitem" href="../../../packages/Hypatia/">jump-dev/Hypatia.jl</a></li><li><a class="tocitem" href="../../../packages/Ipopt/">jump-dev/Ipopt.jl</a></li><li><a class="tocitem" href="../../../packages/KNITRO/">jump-dev/KNITRO.jl</a></li><li><a class="tocitem" href="../../../packages/MiniZinc/">jump-dev/MiniZinc.jl</a></li><li><a class="tocitem" href="../../../packages/MosekTools/">jump-dev/MosekTools.jl</a></li><li><a class="tocitem" href="../../../packages/MultiObjectiveAlgorithms/">jump-dev/MultiObjectiveAlgorithms.jl</a></li><li><a class="tocitem" href="../../../packages/NEOSServer/">jump-dev/NEOSServer.jl</a></li><li><a class="tocitem" href="../../../packages/NLopt/">jump-dev/NLopt.jl</a></li><li><a class="tocitem" href="../../../packages/Pajarito/">jump-dev/Pajarito.jl</a></li><li><a class="tocitem" href="../../../packages/Pavito/">jump-dev/Pavito.jl</a></li><li><a class="tocitem" href="../../../packages/SCS/">jump-dev/SCS.jl</a></li><li><a class="tocitem" href="../../../packages/SDPA/">jump-dev/SDPA.jl</a></li><li><a class="tocitem" href="../../../packages/SDPLR/">jump-dev/SDPLR.jl</a></li><li><a class="tocitem" href="../../../packages/SDPNAL/">jump-dev/SDPNAL.jl</a></li><li><a class="tocitem" href="../../../packages/SDPT3/">jump-dev/SDPT3.jl</a></li><li><a class="tocitem" href="../../../packages/SeDuMi/">jump-dev/SeDuMi.jl</a></li><li><a class="tocitem" href="../../../packages/Xpress/">jump-dev/Xpress.jl</a></li><li><a class="tocitem" href="../../../packages/COPT/">COPT-Public/COPT.jl</a></li><li><a class="tocitem" href="../../../packages/GAMS/">GAMS-dev/GAMS.jl</a></li><li><a class="tocitem" href="../../../packages/Manopt/">JuliaManifolds/Manopt.jl</a></li><li><a class="tocitem" href="../../../packages/Optim/">JuliaNLSolvers/Optim.jl</a></li><li><a class="tocitem" href="../../../packages/CDDLib/">JuliaPolyhedra/CDDLib.jl</a></li><li><a class="tocitem" href="../../../packages/Percival/">JuliaSmoothOptimizers/Percival.jl</a></li><li><a class="tocitem" href="../../../packages/MAiNGO/">MAiNGO-github/MAiNGO.jl</a></li><li><a class="tocitem" href="../../../packages/MadNLP/">MadNLP/MadNLP.jl</a></li><li><a class="tocitem" href="../../../packages/EAGO/">PSORLab/EAGO.jl</a></li><li><a class="tocitem" href="../../../packages/PATHSolver/">chkwon/PATHSolver.jl</a></li><li><a class="tocitem" href="../../../packages/DAQP/">darnstrom/DAQP.jl</a></li><li><a class="tocitem" href="../../../packages/Tulip/">ds4dm/Tulip.jl</a></li><li><a class="tocitem" href="../../../packages/Loraine/">kocvara/Loraine.jl</a></li><li><a class="tocitem" href="../../../packages/Alpine/">lanl-ansi/Alpine.jl</a></li><li><a class="tocitem" href="../../../packages/Juniper/">lanl-ansi/Juniper.jl</a></li><li><a class="tocitem" href="../../../packages/ProxSDP/">mariohsouto/ProxSDP.jl</a></li><li><a class="tocitem" href="../../../packages/OSQP/">osqp/OSQP.jl</a></li><li><a class="tocitem" href="../../../packages/CDCS/">oxfordcontrol/CDCS.jl</a></li><li><a class="tocitem" href="../../../packages/COSMO/">oxfordcontrol/COSMO.jl</a></li><li><a class="tocitem" href="../../../packages/Clarabel/">oxfordcontrol/Clarabel.jl</a></li><li><a class="tocitem" href="../../../packages/SCIP/">scipopt/SCIP.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Extensions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../extensions/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../packages/DiffOpt/">jump-dev/DiffOpt.jl</a></li><li><a class="tocitem" href="../../../packages/ParametricOptInterface/">jump-dev/ParametricOptInterface.jl</a></li><li><a class="tocitem" href="../../../packages/PiecewiseLinearOpt/">jump-dev/PiecewiseLinearOpt.jl</a></li><li><a class="tocitem" href="../../../packages/PolyJuMP/">jump-dev/PolyJuMP.jl</a></li><li><a class="tocitem" href="../../../packages/SumOfSquares/">jump-dev/SumOfSquares.jl</a></li><li><a class="tocitem" href="../../../packages/DisjunctiveProgramming/">hdavid16/DisjunctiveProgramming.jl</a></li><li><a class="tocitem" href="../../../packages/InfiniteOpt/">infiniteopt/InfiniteOpt.jl</a></li><li><a class="tocitem" href="../../../packages/BilevelJuMP/">joaquimg/BilevelJuMP.jl</a></li><li><a class="tocitem" href="../../../packages/MathOptAI/">lanl-ansi/MathOptAI.jl</a></li><li><a class="tocitem" href="../../../packages/MathOptSymbolicAD/">lanl-ansi/MathOptSymbolicAD.jl</a></li><li><a class="tocitem" href="../../../packages/SDDP/">odow/SDDP.jl</a></li><li><a class="tocitem" href="../../../packages/Plasmo/">plasmo-dev/Plasmo.jl</a></li><li><a class="tocitem" href="../../../extensions/DimensionalData/">rafaqz/DimensionalData.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">MathOptInterface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-1" type="checkbox"/><label class="tocitem" for="menuitem-9-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/">Introduction</a></li><li><a class="tocitem" href="../../../moi/background/motivation/">Motivation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-2" type="checkbox"/><label class="tocitem" for="menuitem-9-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/tutorials/example/">Solving a problem using MathOptInterface</a></li><li><a class="tocitem" href="../../../moi/tutorials/implementing/">Implementing a solver interface</a></li><li><a class="tocitem" href="../../../moi/tutorials/mathprogbase/">Transitioning from MathProgBase</a></li><li><a class="tocitem" href="../../../moi/tutorials/bridging_constraint/">Implementing a constraint bridge</a></li><li><a class="tocitem" href="../../../moi/tutorials/manipulating_expressions/">Manipulating expressions</a></li><li><a class="tocitem" href="../../../moi/tutorials/latency/">Latency</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-3" type="checkbox"/><label class="tocitem" for="menuitem-9-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/manual/standard_form/">Standard form problem</a></li><li><a class="tocitem" href="../../../moi/manual/models/">Models</a></li><li><a class="tocitem" href="../../../moi/manual/variables/">Variables</a></li><li><a class="tocitem" href="../../../moi/manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../moi/manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../moi/manual/modification/">Problem modification</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-4" type="checkbox"/><label class="tocitem" for="menuitem-9-4"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/background/duality/">Duality</a></li><li><a class="tocitem" href="../../../moi/background/infeasibility_certificates/">Infeasibility certificates</a></li><li><a class="tocitem" href="../../../moi/background/naming_conventions/">Naming conventions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-5" type="checkbox"/><label class="tocitem" for="menuitem-9-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/reference/standard_form/">Standard form</a></li><li><a class="tocitem" href="../../../moi/reference/models/">Models</a></li><li><a class="tocitem" href="../../../moi/reference/variables/">Variables</a></li><li><a class="tocitem" href="../../../moi/reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../moi/reference/modification/">Modifications</a></li><li><a class="tocitem" href="../../../moi/reference/nonlinear/">Nonlinear programming</a></li><li><a class="tocitem" href="../../../moi/reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../moi/reference/errors/">Errors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-6-1" type="checkbox"/><label class="tocitem" for="menuitem-9-6-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/submodules/Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../../moi/submodules/Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-2" type="checkbox"/><label class="tocitem" for="menuitem-9-6-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/submodules/Bridges/overview/">Overview</a></li><li><a class="tocitem" href="../../../moi/submodules/Bridges/implementation/">Implementation</a></li><li><a class="tocitem" href="../../../moi/submodules/Bridges/list_of_bridges/">List of bridges</a></li><li><a class="tocitem" href="../../../moi/submodules/Bridges/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-3" type="checkbox"/><label class="tocitem" for="menuitem-9-6-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/submodules/FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../../moi/submodules/FileFormats/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-4" type="checkbox"/><label class="tocitem" for="menuitem-9-6-4"><span class="docs-label">Nonlinear</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/submodules/Nonlinear/overview/">Overview</a></li><li><a class="tocitem" href="../../../moi/submodules/Nonlinear/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-5" type="checkbox"/><label class="tocitem" for="menuitem-9-6-5"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/submodules/Utilities/overview/">Overview</a></li><li><a class="tocitem" href="../../../moi/submodules/Utilities/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6-6"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/submodules/Test/overview/">Overview</a></li><li><a class="tocitem" href="../../../moi/submodules/Test/reference/">API Reference</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/developer/checklists/">Checklists</a></li></ul></li><li><a class="tocitem" href="../../../moi/release_notes/">Release notes</a></li></ul></li><li><a class="tocitem" href="../../../release_notes/">Release notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li><a class="is-disabled">Algorithms</a></li><li class="is-active"><a href>Benders decomposition</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Benders decomposition</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/algorithms/benders_decomposition.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="benders_decomposition_classical"><a class="docs-heading-anchor" href="#benders_decomposition_classical">Benders decomposition</a><a id="benders_decomposition_classical-1"></a><a class="docs-heading-anchor-permalink" href="#benders_decomposition_classical" title="Permalink"></a></h1><p><em>This tutorial was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em> <a href="../benders_decomposition.jl"><em>Download the source as a <code>.jl</code> file</em></a>.</p><p><strong>This tutorial was originally contributed by Shuvomoy Das Gupta.</strong></p><p>This tutorial describes how to implement <a href="https://en.wikipedia.org/wiki/Benders_decomposition">Benders decomposition</a> in JuMP. It uses the following packages:</p><pre><code class="language-julia hljs">using JuMP
import GLPK
import HiGHS
import Printf</code></pre><h2 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h2><p>Benders decomposition is a useful algorithm for solving convex optimization problems with a large number of variables. It works best when a larger problem can be decomposed into two (or more) smaller problems that are individually much easier to solve.</p><p>This tutorial demonstrates Benders decomposition on the following mixed-integer linear program:</p><p class="math-container">\[\begin{aligned}
\text{min}        \ &amp; c_1(x) + c_2(y) \\
\text{subject to} \ &amp; f_1(x) \in S_1 \\
                    &amp; f_2(y) \in S_2 \\
                    &amp; f_3(x, y) \in S_3 \\
                    &amp; x \in \mathbb{Z}^m \\
                    &amp; y \in \mathbb{R}^n \\
\end{aligned}\]</p><p>where the functions <span>$f$</span> and <span>$c$</span> are linear, and the sets <span>$S$</span> are inequality sets like <span>$\ge l$</span>, <span>$\le u$</span>, or <span>$= b$</span>.</p><p>Any mixed integer programming problem can be written in the form above.</p><p>If there are relatively few integer variables, and many more continuous variables, then it may be beneficial to decompose the problem into a small problem containing only integer variables and a linear program containing only continuous variables. Hopefully, the linear program will be much easier to solve in isolation than in the full mixed-integer linear program.</p><p>For example, if we knew a feasible solution for <span>$\bar{x}$</span>, we could obtain a solution for <span>$y$</span> by solving:</p><p class="math-container">\[\begin{aligned}
V_2(\bar{x}) = &amp; \text{min}  \ &amp; c_2(y)\\
         &amp; \text{subject to} \ &amp; f_2(y) \in S_2 \\
         &amp;                     &amp; f_3(x, y) \in S_3 \\
         &amp;                     &amp; x = \bar{x} &amp; \ [\pi] \\
         &amp;                     &amp; y \in \mathbb{R}^n \\
\end{aligned}\]</p><p>Note that we have included a &quot;copy&quot; of the <code>x</code> variable to simplify computing <span>$\pi$</span>, which is the dual of <span>$V_2$</span> with respect to <span>$\bar{x}$</span>.</p><p>Because this model is a linear program, it is easy to solve.</p><p>Replacing the <span>$c_2(y)$</span> component of the objective in our original problem with <span>$V_2$</span> yields:</p><p class="math-container">\[\begin{aligned}
V_1 = &amp; \text{min}        \ &amp; c_1(x) + V_2(x) \\
&amp; \text{subject to} \ &amp; f_1(x) \in S_1 \\
&amp;                     &amp; x \in \mathbb{Z}^m.
\end{aligned}\]</p><p>This problem looks a lot simpler to solve because it involves only <span>$x$</span> and a subset of the constraints, but we need to do something else with <span>$V_2$</span> first.</p><p>Because <span>$\bar{x}$</span> is a constant that appears on the right-hand side of the constraints, <span>$V_2$</span> is a convex function with respect to <span>$\bar{x}$</span>, and the dual variable <span>$\pi$</span> is a subgradient of <span>$V_2(x)$</span> with respect to <span>$x$</span>. Therefore, if we have a candidate solution <span>$x_k$</span>, then we can solve <span>$V_2(x_k)$</span> and obtain a feasible dual vector <span>$\pi_k$</span>. Using these values, we can construct a first-order Taylor-series approximation of <span>$V_2$</span> about the point <span>$x_k$</span>:</p><p class="math-container">\[V_2(x) \ge V_2(x_k) + \pi_k^\top (x - x_k).\]</p><p>By convexity, we know that this inequality holds for all <span>$x$</span>, and we call these inequalities <em>cuts</em>.</p><p>Benders decomposition is an iterative technique that replaces <span>$V_2(x)$</span> with a new decision variable <span>$\theta$</span>, and approximates it from below using cuts:</p><p class="math-container">\[\begin{aligned}
V_1^K = &amp; \text{min}        \ &amp; c_1(x) + \theta      \\
        &amp; \text{subject to} \ &amp; f_1(x) \in S_1       \\
        &amp;                     &amp; x \in \mathbb{Z}^m   \\
        &amp;                     &amp; \theta \ge M         \\
        &amp;                     &amp; \theta \ge V_2(x_k) + \pi_k^\top(x - x_k) &amp; \quad \forall k = 1,\ldots,K.
\end{aligned}\]</p><p>This integer program is called the <em>first-stage</em> subproblem.</p><p>To generate cuts, we solve <span>$V_1^K$</span> to obtain a candidate first-stage solution <span>$x_k$</span>, then we use that solution to solve <span>$V_2(x_k)$</span>. Then, using the optimal objective value and dual solution from <span>$V_2$</span>, we add a new cut to form <span>$V_1^{K+1}$</span> and repeat.</p><h3 id="Bounds"><a class="docs-heading-anchor" href="#Bounds">Bounds</a><a id="Bounds-1"></a><a class="docs-heading-anchor-permalink" href="#Bounds" title="Permalink"></a></h3><p>Due to convexity, we know that <span>$V_2(x) \ge \theta$</span> for all <span>$x$</span>. Therefore, the optimal objective value of <span>$V_1^K$</span> provides a valid <em>lower</em> bound on the objective value of the full problem. In addition, if we take a feasible solution for <span>$x$</span> from the first-stage problem, then <span>$c_1(x) + V_2(x)$</span> is a valid <em>upper</em> bound on the objective value of the full problem.</p><p>Benders decomposition uses the lower and upper bounds to determine when it has found the global optimal solution.</p><h2 id="Monolithic-problem"><a class="docs-heading-anchor" href="#Monolithic-problem">Monolithic problem</a><a id="Monolithic-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Monolithic-problem" title="Permalink"></a></h2><p>As an example problem, we consider the following variant of <a href="../../linear/network_flows/#The-max-flow-problem">The max-flow problem</a>, in which there is a binary variable to decide whether to open each arc for a cost of 0.1 unit, and we can open at most 11 arcs:</p><pre><code class="language-julia hljs">G = [
    0 3 2 2 0 0 0 0
    0 0 0 0 5 1 0 0
    0 0 0 0 1 3 1 0
    0 0 0 0 0 1 0 0
    0 0 0 0 0 0 0 4
    0 0 0 0 0 0 0 2
    0 0 0 0 0 0 0 4
    0 0 0 0 0 0 0 0
]
n = size(G, 1)
model = Model(HiGHS.Optimizer)
set_silent(model)
@variable(model, x[1:n, 1:n], Bin)
@variable(model, y[1:n, 1:n] &gt;= 0)
@constraint(model, sum(x) &lt;= 11)
@constraint(model, [i = 1:n, j = 1:n], y[i, j] &lt;= G[i, j] * x[i, j])
@constraint(model, [i = 2:n-1], sum(y[i, :]) == sum(y[:, i]))
@objective(model, Min, 0.1 * sum(x) - sum(y[1, :]))
optimize!(model)
solution_summary(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">* Solver : HiGHS

* Status
  Result count       : 1
  Termination status : OPTIMAL
  Message from the solver:
  &quot;kHighsModelStatusOptimal&quot;

* Candidate solution (result #1)
  Primal status      : FEASIBLE_POINT
  Dual status        : NO_SOLUTION
  Objective value    : -5.10000e+00
  Objective bound    : -5.10000e+00
  Relative gap       : 0.00000e+00
  Dual objective value : NaN

* Work counters
  Solve time (sec)   : 1.49679e-03
  Simplex iterations : 15
  Barrier iterations : -1
  Node count         : 1
</code></pre><p>The optimal objective value is -5.1:</p><pre><code class="language-julia hljs">objective_value(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-5.1</code></pre><p>and the optimal flows are:</p><pre><code class="language-julia hljs">function optimal_flows(x)
    return [(i, j) =&gt; x[i, j] for i in 1:n for j in 1:n if x[i, j] &gt; 0]
end

monolithic_solution = optimal_flows(value.(y))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Pair{Tuple{Int64, Int64}, Float64}}:
 (1, 2) =&gt; 3.0
 (1, 3) =&gt; 2.0
 (1, 4) =&gt; 1.0
 (2, 5) =&gt; 3.0
 (3, 5) =&gt; 1.0
 (3, 6) =&gt; 1.0
 (4, 6) =&gt; 1.0
 (5, 8) =&gt; 4.0
 (6, 8) =&gt; 2.0</code></pre><h2 id="benders_iterative"><a class="docs-heading-anchor" href="#benders_iterative">Iterative method</a><a id="benders_iterative-1"></a><a class="docs-heading-anchor-permalink" href="#benders_iterative" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This is a basic implementation for pedagogical purposes. We haven&#39;t discussed any of the computational tricks that are required to build a performant implementation for large-scale problems. See <a href="#In-place-iterative-method">In-place iterative method</a> for one improvement that helps computation time.</p></div></div><p>We start by formulating the first-stage subproblem. It includes the <code>x</code> variables, and the constraints involving only <code>x</code>, and the terms in the objective containing only <code>x</code>. We also need an initial lower bound on the cost-to-go variable <code>θ</code>. One valid lower bound is to assume that we do not pay for opening arcs, and there is flow all the arcs.</p><pre><code class="language-julia hljs">M = -sum(G)
model = Model(HiGHS.Optimizer)
set_silent(model)
@variable(model, x[1:n, 1:n], Bin)
@variable(model, θ &gt;= M)
@constraint(model, sum(x) &lt;= 11)
@objective(model, Min, 0.1 * sum(x) + θ)
model</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">A JuMP Model
├ solver: HiGHS
├ objective_sense: MIN_SENSE
│ └ objective_function_type: AffExpr
├ num_variables: 65
├ num_constraints: 66
│ ├ AffExpr in MOI.LessThan{Float64}: 1
│ ├ VariableRef in MOI.GreaterThan{Float64}: 1
│ └ VariableRef in MOI.ZeroOne: 64
└ Names registered in the model
  └ :x, :θ</code></pre><p>For the next step, we need a function that takes a first-stage candidate solution <code>x</code> and returns the optimal solution from the second-stage subproblem:</p><pre><code class="language-julia hljs">function solve_subproblem(x_bar)
    model = Model(HiGHS.Optimizer)
    set_silent(model)
    @variable(model, x[i in 1:n, j in 1:n] == x_bar[i, j])
    @variable(model, y[1:n, 1:n] &gt;= 0)
    @constraint(model, [i = 1:n, j = 1:n], y[i, j] &lt;= G[i, j] * x[i, j])
    @constraint(model, [i = 2:n-1], sum(y[i, :]) == sum(y[:, i]))
    @objective(model, Min, -sum(y[1, :]))
    optimize!(model)
    @assert is_solved_and_feasible(model; dual = true)
    return (obj = objective_value(model), y = value.(y), π = reduced_cost.(x))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">solve_subproblem (generic function with 1 method)</code></pre><p>Note that <code>solve_subproblem</code> returns a <code>NamedTuple</code> of the objective value, the optimal primal solution for <code>y</code>, and the optimal dual solution for <code>π</code>, which we obtained from the <a href="../../../api/JuMP/#reduced_cost"><code>reduced_cost</code></a> of the <code>x</code> variables.</p><p>We&#39;re almost ready for our optimization loop, but first, here&#39;s a helpful function for logging:</p><pre><code class="language-julia hljs">function print_iteration(k, args...)
    f(x) = Printf.@sprintf(&quot;%12.4e&quot;, x)
    println(lpad(k, 9), &quot; &quot;, join(f.(args), &quot; &quot;))
    return
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">print_iteration (generic function with 1 method)</code></pre><p>We also need to put a limit on the number of iterations before termination:</p><pre><code class="language-julia hljs">MAXIMUM_ITERATIONS = 100</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100</code></pre><p>And a way to check if the lower and upper bounds are close-enough to terminate:</p><pre><code class="language-julia hljs">ABSOLUTE_OPTIMALITY_GAP = 1e-6</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0e-6</code></pre><p>Now we&#39;re ready to iterate Benders decomposition:</p><pre><code class="language-julia hljs">println(&quot;Iteration  Lower Bound  Upper Bound          Gap&quot;)
for k in 1:MAXIMUM_ITERATIONS
    optimize!(model)
    @assert is_solved_and_feasible(model)
    lower_bound = objective_value(model)
    x_k = value.(x)
    ret = solve_subproblem(x_k)
    upper_bound = (objective_value(model) - value(θ)) + ret.obj
    gap = abs(upper_bound - lower_bound) / abs(upper_bound)
    print_iteration(k, lower_bound, upper_bound, gap)
    if gap &lt; ABSOLUTE_OPTIMALITY_GAP
        println(&quot;Terminating with the optimal solution&quot;)
        break
    end
    cut = @constraint(model, θ &gt;= ret.obj + sum(ret.π .* (x .- x_k)))
    @info &quot;Adding the cut $(cut)&quot;
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Iteration  Lower Bound  Upper Bound          Gap
        1  -2.9000e+01   0.0000e+00          Inf
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the cut 3 x[1,2] + 2 x[1,3] + 2 x[1,4] + θ ≥ 0
        2  -6.7000e+00   3.0000e-01   2.3333e+01
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the cut 5 x[2,5] + x[3,5] + x[2,6] + 3 x[3,6] + x[4,6] + x[3,7] + θ ≥ 0
        3  -6.5000e+00   5.0000e-01   1.4000e+01
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the cut x[3,7] + 4 x[5,8] + 2 x[6,8] + θ ≥ 0
        4  -6.2000e+00  -4.2000e+00   4.7619e-01
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the cut 3 x[1,2] + x[3,5] + 2 x[6,8] + 4 x[7,8] + θ ≥ 0
        5  -6.1000e+00  -4.1000e+00   4.8780e-01
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the cut 3 x[1,2] + x[3,5] + 3 x[3,6] + x[4,6] + x[3,7] + θ ≥ 0
        6  -6.1000e+00  -4.1000e+00   4.8780e-01
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the cut 3 x[1,2] + 2 x[1,3] + x[4,6] + θ ≥ 0
        7  -5.1000e+00  -5.1000e+00   0.0000e+00
Terminating with the optimal solution</code></pre><p>Finally, we can obtain the optimal solution:</p><pre><code class="language-julia hljs">optimize!(model)
@assert is_solved_and_feasible(model)
x_optimal = value.(x)
optimal_ret = solve_subproblem(x_optimal)
iterative_solution = optimal_flows(optimal_ret.y)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Pair{Tuple{Int64, Int64}, Float64}}:
 (1, 2) =&gt; 3.0
 (1, 3) =&gt; 2.0
 (1, 4) =&gt; 1.0
 (2, 5) =&gt; 3.0
 (3, 5) =&gt; 1.0
 (3, 6) =&gt; 1.0
 (4, 6) =&gt; 1.0
 (5, 8) =&gt; 4.0
 (6, 8) =&gt; 2.0</code></pre><p>which is the same as the monolithic solution:</p><pre><code class="language-julia hljs">iterative_solution == monolithic_solution</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>and it has the same objective value:</p><pre><code class="language-julia hljs">objective_value(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-5.1</code></pre><h2 id="Callback-method"><a class="docs-heading-anchor" href="#Callback-method">Callback method</a><a id="Callback-method-1"></a><a class="docs-heading-anchor-permalink" href="#Callback-method" title="Permalink"></a></h2><p>The <a href="#benders_iterative">Iterative method</a> section implemented Benders decomposition using a loop. In each iteration, we re-solved the first-stage subproblem to generate a candidate solution. However, modern MILP solvers such as CPLEX, Gurobi, and GLPK provide lazy constraint callbacks which allow us to add new cuts <em>while the solver is running</em>. This can be more efficient than an iterative method because we can avoid repeating work such as solving the root node of the first-stage MILP at each iteration.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>We use GLPK for this model because HiGHS does not support lazy constraints. For more information on callbacks, read the page <a href="../../../manual/callbacks/#callbacks_manual">Solver-independent callbacks</a>.</p></div></div><p>As before, we construct the same first-stage subproblem:</p><pre><code class="language-julia hljs">lazy_model = Model(GLPK.Optimizer)
set_silent(lazy_model)
@variable(lazy_model, x[1:n, 1:n], Bin)
@variable(lazy_model, θ &gt;= M)
@constraint(lazy_model, sum(x) &lt;= 11)
@objective(lazy_model, Min, 0.1 * sum(x) + θ)
lazy_model</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">A JuMP Model
├ solver: GLPK
├ objective_sense: MIN_SENSE
│ └ objective_function_type: AffExpr
├ num_variables: 65
├ num_constraints: 66
│ ├ AffExpr in MOI.LessThan{Float64}: 1
│ ├ VariableRef in MOI.GreaterThan{Float64}: 1
│ └ VariableRef in MOI.ZeroOne: 64
└ Names registered in the model
  └ :x, :θ</code></pre><p>What differs is that we write a callback function instead of a loop:</p><pre><code class="language-julia hljs">number_of_subproblem_solves = 0
function my_callback(cb_data)
    status = callback_node_status(cb_data, lazy_model)
    if status != MOI.CALLBACK_NODE_STATUS_INTEGER
        # Only add the constraint if `x` is an integer feasible solution
        return
    end
    x_k = callback_value.(cb_data, x)
    θ_k = callback_value(cb_data, θ)
    global number_of_subproblem_solves += 1
    ret = solve_subproblem(x_k)
    if θ_k &lt; (ret.obj - 1e-6)
        # Only add the constraint if θ_k violates the constraint
        cut = @build_constraint(θ &gt;= ret.obj + sum(ret.π .* (x .- x_k)))
        MOI.submit(lazy_model, MOI.LazyConstraint(cb_data), cut)
    end
    return
end

set_attribute(lazy_model, MOI.LazyConstraintCallback(), my_callback)</code></pre><p>Now when we optimize!, our callback is run:</p><pre><code class="language-julia hljs">optimize!(lazy_model)
@assert is_solved_and_feasible(lazy_model)</code></pre><p>For this model, the callback algorithm required more solves of the subproblem:</p><pre><code class="language-julia hljs">number_of_subproblem_solves</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">14</code></pre><p>But for larger problems, you can expect the callback algorithm to be more efficient than the iterative algorithm.</p><p>Finally, we can obtain the optimal solution:</p><pre><code class="language-julia hljs">x_optimal = value.(x)
optimal_ret = solve_subproblem(x_optimal)
callback_solution = optimal_flows(optimal_ret.y)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Pair{Tuple{Int64, Int64}, Float64}}:
 (1, 2) =&gt; 3.0
 (1, 3) =&gt; 2.0
 (1, 4) =&gt; 1.0
 (2, 5) =&gt; 3.0
 (3, 5) =&gt; 1.0
 (3, 6) =&gt; 1.0
 (4, 6) =&gt; 1.0
 (5, 8) =&gt; 4.0
 (6, 8) =&gt; 2.0</code></pre><p>which is the same as the monolithic solution:</p><pre><code class="language-julia hljs">callback_solution == monolithic_solution</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h2 id="In-place-iterative-method"><a class="docs-heading-anchor" href="#In-place-iterative-method">In-place iterative method</a><a id="In-place-iterative-method-1"></a><a class="docs-heading-anchor-permalink" href="#In-place-iterative-method" title="Permalink"></a></h2><p>Our implementation of the iterative method has a problem: every time we need to solve the subproblem, we must rebuild it from scratch. This is expensive, and it can be the bottleneck in the solution process. We can improve our implementation by using re-using the subproblem between solves.</p><p>First, we create our first-stage problem as usual:</p><pre><code class="language-julia hljs">model = Model(HiGHS.Optimizer)
set_silent(model)
@variable(model, x[1:n, 1:n], Bin)
@variable(model, θ &gt;= M)
@constraint(model, sum(x) &lt;= 11)
@objective(model, Min, 0.1 * sum(x) + θ)
model</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">A JuMP Model
├ solver: HiGHS
├ objective_sense: MIN_SENSE
│ └ objective_function_type: AffExpr
├ num_variables: 65
├ num_constraints: 66
│ ├ AffExpr in MOI.LessThan{Float64}: 1
│ ├ VariableRef in MOI.GreaterThan{Float64}: 1
│ └ VariableRef in MOI.ZeroOne: 64
└ Names registered in the model
  └ :x, :θ</code></pre><p>Then, instead of building the subproblem in a function, we build it once here:</p><pre><code class="language-julia hljs">subproblem = Model(HiGHS.Optimizer)
set_silent(subproblem)
@variable(subproblem, x_copy[i in 1:n, j in 1:n])
@variable(subproblem, y[1:n, 1:n] &gt;= 0)
@constraint(subproblem, [i = 1:n, j = 1:n], y[i, j] &lt;= G[i, j] * x_copy[i, j])
@constraint(subproblem, [i = 2:n-1], sum(y[i, :]) == sum(y[:, i]))
@objective(subproblem, Min, -sum(y[1, :]))
subproblem</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">A JuMP Model
├ solver: HiGHS
├ objective_sense: MIN_SENSE
│ └ objective_function_type: AffExpr
├ num_variables: 128
├ num_constraints: 134
│ ├ AffExpr in MOI.EqualTo{Float64}: 6
│ ├ AffExpr in MOI.LessThan{Float64}: 64
│ └ VariableRef in MOI.GreaterThan{Float64}: 64
└ Names registered in the model
  └ :x_copy, :y</code></pre><p>Our function to solve the subproblem is also slightly different because we need to fix the value of the <code>x_copy</code> variables to the value of <code>x</code> from the first-stage problem:</p><pre><code class="language-julia hljs">function solve_subproblem(model, x)
    fix.(model[:x_copy], x)
    optimize!(model)
    @assert is_solved_and_feasible(model; dual = true)
    return (
        obj = objective_value(model),
        y = value.(model[:y]),
        π = reduced_cost.(model[:x_copy]),
    )
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">solve_subproblem (generic function with 2 methods)</code></pre><p>Now we&#39;re ready to iterate our in-place Benders decomposition:</p><pre><code class="language-julia hljs">println(&quot;Iteration  Lower Bound  Upper Bound          Gap&quot;)
for k in 1:MAXIMUM_ITERATIONS
    optimize!(model)
    @assert is_solved_and_feasible(model)
    lower_bound = objective_value(model)
    x_k = value.(x)
    ret = solve_subproblem(subproblem, x_k)
    upper_bound = (objective_value(model) - value(θ)) + ret.obj
    gap = abs(upper_bound - lower_bound) / abs(upper_bound)
    print_iteration(k, lower_bound, upper_bound, gap)
    if gap &lt; ABSOLUTE_OPTIMALITY_GAP
        println(&quot;Terminating with the optimal solution&quot;)
        break
    end
    cut = @constraint(model, θ &gt;= ret.obj + sum(ret.π .* (x .- x_k)))
    @info &quot;Adding the cut $(cut)&quot;
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Iteration  Lower Bound  Upper Bound          Gap
        1  -2.9000e+01   0.0000e+00          Inf
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the cut 3 x[1,2] + 2 x[1,3] + 2 x[1,4] + θ ≥ 0
        2  -6.7000e+00   3.0000e-01   2.3333e+01
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the cut 5 x[2,5] + x[3,5] + x[2,6] + 3 x[3,6] + x[4,6] + x[3,7] + θ ≥ 0
        3  -6.5000e+00   5.0000e-01   1.4000e+01
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the cut x[3,7] + 4 x[5,8] + 2 x[6,8] + θ ≥ 0
        4  -6.2000e+00  -4.2000e+00   4.7619e-01
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the cut 3 x[1,2] + x[3,5] + 2 x[6,8] + 4 x[7,8] + θ ≥ 0
        5  -6.1000e+00  -4.1000e+00   4.8780e-01
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the cut 3 x[1,2] + x[3,5] + 3 x[3,6] + x[4,6] + x[3,7] + θ ≥ 0
        6  -6.1000e+00  -4.1000e+00   4.8780e-01
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the cut 3 x[1,2] + 2 x[1,3] + x[4,6] + θ ≥ 0
        7  -5.1000e+00  -5.1000e+00   0.0000e+00
Terminating with the optimal solution</code></pre><p>Finally, we can obtain the optimal solution:</p><pre><code class="language-julia hljs">optimize!(model)
@assert is_solved_and_feasible(model)
x_optimal = value.(x)
optimal_ret = solve_subproblem(subproblem, x_optimal)
inplace_solution = optimal_flows(optimal_ret.y)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Pair{Tuple{Int64, Int64}, Float64}}:
 (1, 2) =&gt; 3.0
 (1, 3) =&gt; 2.0
 (1, 4) =&gt; 1.0
 (2, 5) =&gt; 3.0
 (3, 5) =&gt; 1.0
 (3, 6) =&gt; 1.0
 (4, 6) =&gt; 1.0
 (5, 8) =&gt; 4.0
 (6, 8) =&gt; 2.0</code></pre><p>which is the same as the monolithic solution:</p><pre><code class="language-julia hljs">inplace_solution == monolithic_solution</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h2 id="Feasibility-cuts"><a class="docs-heading-anchor" href="#Feasibility-cuts">Feasibility cuts</a><a id="Feasibility-cuts-1"></a><a class="docs-heading-anchor-permalink" href="#Feasibility-cuts" title="Permalink"></a></h2><p>So far, we have discussed only Benders optimality cuts. However, for some first-stage values of <code>x</code>, the subproblem might be infeasible. The solution is to add a Benders feasibility cut:</p><p class="math-container">\[v_k + u_k^\top (x - x_k) \le 0\]</p><p>where <span>$u_k$</span> is a dual unbounded ray of the subproblem and <span>$v_k$</span> is the intercept of the unbounded ray.</p><p>As a variation of our example which leads to infeasibilities, we add a constraint that <code>sum(y) &gt;= 1</code>. This means we need a choice of first-stage <code>x</code> for which at least one unit can flow.</p><p>The first-stage problem remains the same:</p><pre><code class="language-julia hljs">model = Model(HiGHS.Optimizer)
set_silent(model)
@variable(model, x[1:n, 1:n], Bin)
@variable(model, θ &gt;= M)
@constraint(model, sum(x) &lt;= 11)
@objective(model, Min, 0.1 * sum(x) + θ)
model</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">A JuMP Model
├ solver: HiGHS
├ objective_sense: MIN_SENSE
│ └ objective_function_type: AffExpr
├ num_variables: 65
├ num_constraints: 66
│ ├ AffExpr in MOI.LessThan{Float64}: 1
│ ├ VariableRef in MOI.GreaterThan{Float64}: 1
│ └ VariableRef in MOI.ZeroOne: 64
└ Names registered in the model
  └ :x, :θ</code></pre><p>But the subproblem has a new constraint that <code>sum(y) &gt;= 1</code>:</p><pre><code class="language-julia hljs">subproblem = Model(HiGHS.Optimizer)
set_silent(subproblem)
# We need to turn presolve off so that HiGHS will return an infeasibility
# certificate.
set_attribute(subproblem, &quot;presolve&quot;, &quot;off&quot;)
@variable(subproblem, x_copy[i in 1:n, j in 1:n])
@variable(subproblem, y[1:n, 1:n] &gt;= 0)
@constraint(subproblem, sum(y) &gt;= 1)  # &lt;--- THIS IS NEW
@constraint(subproblem, [i = 1:n, j = 1:n], y[i, j] &lt;= G[i, j] * x_copy[i, j])
@constraint(subproblem, [i = 2:n-1], sum(y[i, :]) == sum(y[:, i]))
@objective(subproblem, Min, -sum(y[1, :]))
subproblem</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">A JuMP Model
├ solver: HiGHS
├ objective_sense: MIN_SENSE
│ └ objective_function_type: AffExpr
├ num_variables: 128
├ num_constraints: 135
│ ├ AffExpr in MOI.EqualTo{Float64}: 6
│ ├ AffExpr in MOI.GreaterThan{Float64}: 1
│ ├ AffExpr in MOI.LessThan{Float64}: 64
│ └ VariableRef in MOI.GreaterThan{Float64}: 64
└ Names registered in the model
  └ :x_copy, :y</code></pre><p>The function to solve the subproblem now checks for feasibility, and returns the dual objective value and an dual unbounded ray if the subproblem is infeasible:</p><pre><code class="language-julia hljs">function solve_subproblem_with_feasibility(model, x)
    fix.(model[:x_copy], x)
    optimize!(model)
    if is_solved_and_feasible(model; dual = true)
        return (
            is_feasible = true,
            obj = objective_value(model),
            y = value.(model[:y]),
            π = reduced_cost.(model[:x_copy]),
        )
    end
    return (
        is_feasible = false,
        v = dual_objective_value(model),
        u = reduced_cost.(model[:x_copy]),
    )
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">solve_subproblem_with_feasibility (generic function with 1 method)</code></pre><p>Now we&#39;re ready to iterate our in-place Benders decomposition:</p><pre><code class="language-julia hljs">println(&quot;Iteration  Lower Bound  Upper Bound          Gap&quot;)
for k in 1:MAXIMUM_ITERATIONS
    optimize!(model)
    @assert is_solved_and_feasible(model)
    lower_bound = objective_value(model)
    x_k = value.(x)
    ret = solve_subproblem_with_feasibility(subproblem, x_k)
    if ret.is_feasible
        # Benders Optimality Cuts
        upper_bound = (objective_value(model) - value(θ)) + ret.obj
        gap = abs(upper_bound - lower_bound) / abs(upper_bound)
        print_iteration(k, lower_bound, upper_bound, gap)
        if gap &lt; ABSOLUTE_OPTIMALITY_GAP
            println(&quot;Terminating with the optimal solution&quot;)
            break
        end
        @constraint(model, θ &gt;= ret.obj + sum(ret.π .* (x .- x_k)))
    else
        # Benders Feasibility Cuts
        cut = @constraint(model, ret.v + sum(ret.u .* (x .- x_k)) &lt;= 0)
        @info &quot;Adding the feasibility cut $(cut)&quot;
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Iteration  Lower Bound  Upper Bound          Gap
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -3 x[1,2] - 2 x[1,3] - 2 x[1,4] - 5.000000000000002 x[2,5] - x[3,5] - 2 x[2,6] - 6 x[3,6] - 2 x[4,6] - 2.0000000000000004 x[3,7] - 4 x[5,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -2.999999999999999 x[1,2] - 1.9999999999999996 x[1,3] - 1.9999999999999996 x[1,4] - 10 x[2,5] - 2 x[3,5] - 1.9999999999999996 x[2,6] - 5.999999999999998 x[3,6] - 1.9999999999999996 x[4,6] - 1.9999999999999998 x[3,7] ≤ -0.9999999999999998
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -2.9999999999999987 x[1,2] - 5.999999999999998 x[1,3] - 1.9999999999999991 x[1,4] - 10 x[2,5] - 1.9999999999999991 x[2,6] - 1.9999999999999991 x[4,6] ≤ -0.9999999999999996
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -4 x[1,3] - 3.9999999999999982 x[1,4] - 9.999999999999998 x[2,5] - 2 x[2,6] - 4 x[5,8] - 1.9999999999999996 x[6,8] - 4 x[7,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -3 x[1,2] - 4 x[1,3] - 2 x[1,4] - 10 x[2,5] - x[3,5] - 4 x[6,8] - 4 x[7,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -6 x[1,2] - 6 x[1,3] - 4 x[1,4] - 4 x[5,8] - 2 x[6,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -6 x[1,2] - 6 x[1,3] - 2 x[4,6] - 4 x[5,8] - 2 x[6,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -6 x[1,2] - 2 x[1,4] - 2 x[3,5] - 6 x[3,6] - x[4,6] - 2 x[3,7] - 4 x[5,8] - 2 x[6,8] - 4 x[7,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -6 x[1,2] - 2 x[3,5] - 6 x[3,6] - 2 x[4,6] - 2 x[3,7] - 4 x[5,8] - 2 x[6,8] - 4 x[7,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -5 x[2,5] - x[3,5] - x[2,6] - 3 x[3,6] - x[4,6] - x[3,7] - 8 x[5,8] - 4 x[6,8] - 8 x[7,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -2 x[1,3] - 6 x[1,4] - 9.999999999999998 x[2,5] - x[3,5] - 3 x[2,6] - 6.000000000000002 x[3,6] - x[3,7] - 3.999999999999999 x[5,8] - 3.999999999999999 x[7,8] ≤ -0.9999999999999998
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -1.9999999999999987 x[1,3] - 5.999999999999997 x[1,4] - 14.999999999999996 x[2,5] - 1.9999999999999991 x[3,5] - 2.9999999999999987 x[2,6] - 5.9999999999999964 x[3,6] - x[3,7] - 3.999999999999999 x[7,8] ≤ -0.9999999999999998
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -3 x[1,2] - 5.999999999999997 x[1,4] - 9.999999999999996 x[2,5] - 2.999999999999999 x[3,5] - 1.999999999999999 x[2,6] - 8.999999999999996 x[3,6] - 1.9999999999999996 x[3,7] - 3.999999999999999 x[7,8] ≤ -0.9999999999999998
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -3 x[1,2] - 6 x[1,4] - 2 x[2,6] - 9 x[3,6] - 2 x[3,7] - 12 x[5,8] - 4 x[7,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -3 x[1,2] - 6 x[1,4] - 2 x[2,6] - 9 x[3,6] - 3 x[3,7] - 12 x[5,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -2 x[1,4] - 3 x[3,7] - 12 x[5,8] - 6 x[6,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -3 x[3,7] - 12 x[5,8] - 6 x[6,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -3 x[2,6] - 9 x[3,6] - 3.0000000000000004 x[4,6] - x[3,7] - 12 x[5,8] - 8 x[7,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -15 x[2,5] - 3 x[3,5] - 3 x[2,6] - 9 x[3,6] - 3 x[4,6] - 2 x[3,7] - 4 x[7,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -9 x[1,2] - 3 x[3,5] - 9 x[3,6] - 3 x[4,6] - 2 x[3,7] - 4 x[7,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -6 x[1,2] - 2 x[3,5] - 6 x[3,6] - 2 x[4,6] - 4 x[5,8] - 2 x[6,8] - 12 x[7,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -3 x[1,2] - 5 x[2,5] - 2 x[3,5] - 2 x[2,6] - 9 x[3,6] - 3 x[4,6] - 4 x[5,8] - 12 x[7,8] ≤ -1
       23  -2.8700e+01  -7.0000e-01   4.0000e+01
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -4 x[1,3] - 4 x[1,4] - 15 x[2,5] - x[3,5] - 2 x[2,6] - x[3,7] - 2 x[6,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -6 x[1,3] - 4 x[1,4] - 15 x[2,5] - 2 x[2,6] - 2 x[6,8] ≤ -1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -x[1,4] - 7.5 x[2,5] - 1.5 x[3,5] - 1.5 x[3,7] - 3 x[6,8] ≤ -0.5
       27  -1.4400e+01  -2.4000e+00   5.0000e+00
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Adding the feasibility cut -6 x[1,3] - 15 x[2,5] - 3 x[2,6] - 3 x[4,6] ≤ -1
       29  -8.2000e+00  -2.0000e-01   4.0000e+01
       30  -7.9000e+00  -4.9000e+00   6.1224e-01
       31  -5.3000e+00  -3.3000e+00   6.0606e-01
       32  -5.3000e+00  -1.3000e+00   3.0769e+00
       33  -5.2000e+00  -4.2000e+00   2.3810e-01
       34  -5.2000e+00  -4.2000e+00   2.3810e-01
       35  -5.1000e+00  -4.1000e+00   2.4390e-01
       36  -5.1000e+00  -4.1000e+00   2.4390e-01
       37  -5.1000e+00  -5.1000e+00   0.0000e+00
Terminating with the optimal solution</code></pre><p>Finally, we can obtain the optimal solution:</p><pre><code class="language-julia hljs">optimize!(model)
@assert is_solved_and_feasible(model)
x_optimal = value.(x)
optimal_ret = solve_subproblem(subproblem, x_optimal)
feasible_inplace_solution = optimal_flows(optimal_ret.y)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Pair{Tuple{Int64, Int64}, Float64}}:
 (1, 2) =&gt; 3.0
 (1, 3) =&gt; 2.0
 (1, 4) =&gt; 1.0
 (2, 5) =&gt; 3.0
 (3, 5) =&gt; 1.0
 (3, 6) =&gt; 1.0
 (4, 6) =&gt; 1.0
 (5, 8) =&gt; 4.0
 (6, 8) =&gt; 2.0</code></pre><p>which is the same as the monolithic solution (because <code>sum(y) &gt;= 1</code> in the monolithic solution):</p><pre><code class="language-julia hljs">feasible_inplace_solution == monolithic_solution</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../conic/quantum_discrimination/">« Example: quantum state discrimination</a><a class="docs-footer-nextpage" href="../cutting_stock_column_generation/">Column generation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 8 November 2024 19:04">Friday 8 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
