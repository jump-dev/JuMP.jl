<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Variables · JuMP</title><meta name="title" content="Variables · JuMP"/><meta property="og:title" content="Variables · JuMP"/><meta property="twitter:title" content="Variables · JuMP"/><meta name="description" content="Documentation for JuMP."/><meta property="og:description" content="Documentation for JuMP."/><meta property="twitter:description" content="Documentation for JuMP."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-44252521-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-44252521-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="JuMP logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="JuMP logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../should_i_use/">Should I use JuMP?</a></li><li><a class="tocitem" href="../../installation/">Installation Guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/getting_started/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/getting_started/getting_started_with_julia/">Getting started with Julia</a></li><li><a class="tocitem" href="../../tutorials/getting_started/getting_started_with_JuMP/">Getting started with JuMP</a></li><li><a class="tocitem" href="../../tutorials/getting_started/getting_started_with_sets_and_indexing/">Getting started with sets and indexing</a></li><li><a class="tocitem" href="../../tutorials/getting_started/getting_started_with_data_and_plotting/">Getting started with data and plotting</a></li><li><a class="tocitem" href="../../tutorials/getting_started/debugging/">Debugging</a></li><li><a class="tocitem" href="../../tutorials/getting_started/design_patterns_for_larger_models/">Design patterns for larger models</a></li><li><a class="tocitem" href="../../tutorials/getting_started/performance_tips/">Performance tips</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Linear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/linear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/linear/diet/">The diet problem</a></li><li><a class="tocitem" href="../../tutorials/linear/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../../tutorials/linear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../tutorials/linear/facility_location/">The facility location problem</a></li><li><a class="tocitem" href="../../tutorials/linear/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../../tutorials/linear/finance/">Financial modeling problems</a></li><li><a class="tocitem" href="../../tutorials/linear/geographic_clustering/">Geographical clustering</a></li><li><a class="tocitem" href="../../tutorials/linear/multi_objective_knapsack/">Multi-objective knapsack</a></li><li><a class="tocitem" href="../../tutorials/linear/multi_objective_examples/">Simple multi-objective examples</a></li><li><a class="tocitem" href="../../tutorials/linear/knapsack/">The knapsack problem example</a></li><li><a class="tocitem" href="../../tutorials/linear/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../../tutorials/linear/n-queens/">N-Queens</a></li><li><a class="tocitem" href="../../tutorials/linear/lp_sensitivity/">Sensitivity analysis of a linear program</a></li><li><a class="tocitem" href="../../tutorials/linear/network_flows/">Network flow problems</a></li><li><a class="tocitem" href="../../tutorials/linear/sudoku/">Sudoku</a></li><li><a class="tocitem" href="../../tutorials/linear/transp/">The transportation problem</a></li><li><a class="tocitem" href="../../tutorials/linear/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../tutorials/linear/constraint_programming/">Constraint programming</a></li><li><a class="tocitem" href="../../tutorials/linear/mip_duality/">Computing the duals of a mixed-integer program</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Nonlinear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/nonlinear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/simple_examples/">Simple examples</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/portfolio/">Portfolio optimization</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/rocket_control/">Rocket Control</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/space_shuttle_reentry_trajectory/">Optimal control for a Space Shuttle reentry trajectory</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/user_defined_hessians/">User-defined Hessians</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/querying_hessians/">Computing Hessians</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Conic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/conic/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/conic/start_values/">Primal and dual warm-starts</a></li><li><a class="tocitem" href="../../tutorials/conic/tips_and_tricks/">Tips and Tricks</a></li><li><a class="tocitem" href="../../tutorials/conic/simple_examples/">Simple examples</a></li><li><a class="tocitem" href="../../tutorials/conic/logistic_regression/">Logistic regression</a></li><li><a class="tocitem" href="../../tutorials/conic/experiment_design/">Experiment design</a></li><li><a class="tocitem" href="../../tutorials/conic/min_ellipse/">Minimal ellipses</a></li><li><a class="tocitem" href="../../tutorials/conic/ellipse_approx/">Ellipsoid approximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/algorithms/benders_decomposition/">Benders decomposition</a></li><li><a class="tocitem" href="../../tutorials/algorithms/cutting_stock_column_generation/">Column generation</a></li><li><a class="tocitem" href="../../tutorials/algorithms/tsp_lazy_constraints/">Traveling Salesperson Problem</a></li><li><a class="tocitem" href="../../tutorials/algorithms/parallelism/">Parallelism</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/applications/power_systems/">Power Systems</a></li><li><a class="tocitem" href="../../tutorials/applications/web_app/">Serving web apps</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../models/">Models</a></li><li class="is-active"><a class="tocitem" href>Variables</a><ul class="internal"><li><a class="tocitem" href="#Create-a-variable"><span>Create a variable</span></a></li><li><a class="tocitem" href="#Registered-variables"><span>Registered variables</span></a></li><li><a class="tocitem" href="#anonymous_variables"><span>Anonymous variables</span></a></li><li><a class="tocitem" href="#Variable-names"><span>Variable names</span></a></li><li><a class="tocitem" href="#variable_names_and_bindings"><span>String names, symbolic names, and bindings</span></a></li><li><a class="tocitem" href="#Create,-delete,-and-modify-variable-bounds"><span>Create, delete, and modify variable bounds</span></a></li><li><a class="tocitem" href="#Binary-variables"><span>Binary variables</span></a></li><li><a class="tocitem" href="#Integer-variables"><span>Integer variables</span></a></li><li><a class="tocitem" href="#Start-values"><span>Start values</span></a></li><li><a class="tocitem" href="#delete_a_variable"><span>Delete a variable</span></a></li><li><a class="tocitem" href="#Variable-containers"><span>Variable containers</span></a></li><li><a class="tocitem" href="#Semidefinite-variables"><span>Semidefinite variables</span></a></li><li><a class="tocitem" href="#Symmetric-variables"><span>Symmetric variables</span></a></li><li><a class="tocitem" href="#variables"><span>The <code>@variables</code> macro</span></a></li><li><a class="tocitem" href="#jump_variables_on_creation"><span>Variables constrained on creation</span></a></li></ul></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../expressions/">Expressions</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../containers/">Containers</a></li><li><a class="tocitem" href="../solutions/">Solutions</a></li><li><a class="tocitem" href="../nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../callbacks/">Solver-independent Callbacks</a></li><li><a class="tocitem" href="../complex/">Complex number support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/models/">Models</a></li><li><a class="tocitem" href="../../reference/variables/">Variables</a></li><li><a class="tocitem" href="../../reference/expressions/">Expressions</a></li><li><a class="tocitem" href="../../reference/objectives/">Objectives</a></li><li><a class="tocitem" href="../../reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../reference/containers/">Containers</a></li><li><a class="tocitem" href="../../reference/solutions/">Solutions</a></li><li><a class="tocitem" href="../../reference/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../reference/extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Background Information</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/algebraic_modeling_languages/">Algebraic modeling languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../developers/contributing/">Contributing</a></li><li><a class="tocitem" href="../../developers/extensions/">Extensions</a></li><li><a class="tocitem" href="../../developers/custom_solver_binaries/">Custom binaries</a></li><li><a class="tocitem" href="../../developers/style/">Style Guide</a></li><li><a class="tocitem" href="../../developers/roadmap/">Roadmap</a></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release notes</a></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">MathOptInterface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/">Introduction</a></li><li><a class="tocitem" href="../../moi/background/motivation/">Motivation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/tutorials/example/">Solving a problem using MathOptInterface</a></li><li><a class="tocitem" href="../../moi/tutorials/implementing/">Implementing a solver interface</a></li><li><a class="tocitem" href="../../moi/tutorials/mathprogbase/">Transitioning from MathProgBase</a></li><li><a class="tocitem" href="../../moi/tutorials/bridging_constraint/">Implementing a constraint bridge</a></li><li><a class="tocitem" href="../../moi/tutorials/manipulating_expressions/">Manipulating expressions</a></li><li><a class="tocitem" href="../../moi/tutorials/latency/">Latency</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/manual/standard_form/">Standard form problem</a></li><li><a class="tocitem" href="../../moi/manual/models/">Models</a></li><li><a class="tocitem" href="../../moi/manual/variables/">Variables</a></li><li><a class="tocitem" href="../../moi/manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../moi/manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../moi/manual/modification/">Problem modification</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox"/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/background/duality/">Duality</a></li><li><a class="tocitem" href="../../moi/background/infeasibility_certificates/">Infeasibility certificates</a></li><li><a class="tocitem" href="../../moi/background/naming_conventions/">Naming conventions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox"/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/reference/standard_form/">Standard form</a></li><li><a class="tocitem" href="../../moi/reference/models/">Models</a></li><li><a class="tocitem" href="../../moi/reference/variables/">Variables</a></li><li><a class="tocitem" href="../../moi/reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../moi/reference/modification/">Modifications</a></li><li><a class="tocitem" href="../../moi/reference/nonlinear/">Nonlinear programming</a></li><li><a class="tocitem" href="../../moi/reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../moi/reference/errors/">Errors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6" type="checkbox"/><label class="tocitem" for="menuitem-8-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-6-1" type="checkbox"/><label class="tocitem" for="menuitem-8-6-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-2" type="checkbox"/><label class="tocitem" for="menuitem-8-6-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Bridges/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Bridges/list_of_bridges/">List of bridges</a></li><li><a class="tocitem" href="../../moi/submodules/Bridges/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-3" type="checkbox"/><label class="tocitem" for="menuitem-8-6-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/FileFormats/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-4" type="checkbox"/><label class="tocitem" for="menuitem-8-6-4"><span class="docs-label">Nonlinear</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Nonlinear/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Nonlinear/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-5" type="checkbox"/><label class="tocitem" for="menuitem-8-6-5"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Utilities/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Utilities/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-6" type="checkbox"/><label class="tocitem" for="menuitem-8-6-6"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Test/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Test/reference/">API Reference</a></li></ul></li></ul></li><li><a class="tocitem" href="../../moi/release_notes/">Release notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Variables</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Variables</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl" title="View the repository on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/manual/variables.md" title="Edit source on GitHub"><span class="docs-icon fas"></span></a><a class="docs-settings-button docs-navbar-link fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="jump_variables"><a class="docs-heading-anchor" href="#jump_variables">Variables</a><a id="jump_variables-1"></a><a class="docs-heading-anchor-permalink" href="#jump_variables" title="Permalink"></a></h1><p>The term <em>variable</em> in mathematical optimization has many meanings. For example, <em>optimization</em> variables (also called decision variables) are the unknowns <span>$x$</span> that we are solving for in the problem:</p><p class="math-container">\[\begin{align}
    &amp; \min_{x \in \mathbb{R}^n} &amp; f_0(x)
    \\
    &amp; \;\;\text{s.t.} &amp; f_i(x) &amp; \in \mathcal{S}_i &amp; i = 1 \ldots m
\end{align}\]</p><p>To complicate things, Julia uses <em>variable</em> to mean a binding between a name and a value. For example, in the statement:</p><pre><code class="language-julia-repl hljs">julia&gt; x = 1
1</code></pre><p><code>x</code> is a variable that stores the value <code>1</code>.</p><p>JuMP uses <em>variable</em> in a third way, to mean an instance of the <a href="../../reference/variables/#JuMP.VariableRef"><code>VariableRef</code></a> struct. JuMP variables are the link between Julia and the optimization variables inside a JuMP model.</p><p>This page explains how to create and manage JuMP variables in a variety of contexts.</p><h2 id="Create-a-variable"><a class="docs-heading-anchor" href="#Create-a-variable">Create a variable</a><a id="Create-a-variable-1"></a><a class="docs-heading-anchor-permalink" href="#Create-a-variable" title="Permalink"></a></h2><p>Create variables using the <a href="../../reference/variables/#JuMP.@variable"><code>@variable</code></a> macro. When creating a variable, you can also specify variable bounds:</p><pre><code class="language-julia hljs">model = Model()
@variable(model, x_free)
@variable(model, x_lower &gt;= 0)
@variable(model, x_upper &lt;= 1)
@variable(model, 2 &lt;= x_interval &lt;= 3)
@variable(model, x_fixed == 4)
print(model)

# output

Feasibility
Subject to
 x_fixed = 4.0
 x_lower ≥ 0.0
 x_interval ≥ 2.0
 x_upper ≤ 1.0
 x_interval ≤ 3.0</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When creating a variable with a single lower- or upper-bound, and the value of the bound is not a numeric literal (for example, <code>1</code> or <code>1.0</code>), the name of the variable <em>must</em> appear on the left-hand side. Putting the name on the right-hand side is an error. For example, to create a variable <code>x</code>:</p><pre><code class="language-julia hljs">a = 1
@variable(model, x &gt;= 1)      # ✓ Okay
@variable(model, 1.0 &lt;= x)    # ✓ Okay
@variable(model, x &gt;= a)      # ✓ Okay
@variable(model, a &lt;= x)      # × Not okay
@variable(model, x &gt;= 1 / 2)  # ✓ Okay
@variable(model, 1 / 2 &lt;= x)  # × Not okay</code></pre></div></div><h3 id="Containers-of-variables"><a class="docs-heading-anchor" href="#Containers-of-variables">Containers of variables</a><a id="Containers-of-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Containers-of-variables" title="Permalink"></a></h3><p>The <a href="../../reference/variables/#JuMP.@variable"><code>@variable</code></a> macro also supports creating collections of JuMP variables. We&#39;ll cover some brief syntax here; read the <a href="#Variable-containers">Variable containers</a> section for more details.</p><p>You can create arrays of JuMP variables:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x[1:2, 1:2])
2×2 Matrix{VariableRef}:
 x[1,1]  x[1,2]
 x[2,1]  x[2,2]

julia&gt; x[1, 2]
x[1,2]</code></pre><p>Index sets can be named, and bounds can depend on those names:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, sqrt(i) &lt;= x[i = 1:3] &lt;= i^2)
3-element Vector{VariableRef}:
 x[1]
 x[2]
 x[3]

julia&gt; x[2]
x[2]</code></pre><p>Sets can be any Julia type that supports iteration:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x[i = 2:3, j = 1:2:3, [&quot;red&quot;, &quot;blue&quot;]] &gt;= 0)
3-dimensional DenseAxisArray{VariableRef,3,...} with index sets:
    Dimension 1, 2:3
    Dimension 2, 1:2:3
    Dimension 3, [&quot;red&quot;, &quot;blue&quot;]
And data, a 2×2×2 Array{VariableRef, 3}:
[:, :, &quot;red&quot;] =
 x[2,1,red]  x[2,3,red]
 x[3,1,red]  x[3,3,red]

[:, :, &quot;blue&quot;] =
 x[2,1,blue]  x[2,3,blue]
 x[3,1,blue]  x[3,3,blue]

julia&gt; x[2, 1, &quot;red&quot;]
x[2,1,red]</code></pre><p>Sets can depend upon previous indices:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, u[i = 1:2, j = i:3])
JuMP.Containers.SparseAxisArray{VariableRef, 2, Tuple{Int64, Int64}} with 5 entries:
  [1, 1]  =  u[1,1]
  [1, 2]  =  u[1,2]
  [1, 3]  =  u[1,3]
  [2, 2]  =  u[2,2]
  [2, 3]  =  u[2,3]</code></pre><p>and we can filter elements in the sets using the <code>;</code> syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, v[i = 1:9; mod(i, 3) == 0])
JuMP.Containers.SparseAxisArray{VariableRef, 1, Tuple{Int64}} with 3 entries:
  [3]  =  v[3]
  [6]  =  v[6]
  [9]  =  v[9]</code></pre><h2 id="Registered-variables"><a class="docs-heading-anchor" href="#Registered-variables">Registered variables</a><a id="Registered-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Registered-variables" title="Permalink"></a></h2><p>When you create variables, JuMP registers them inside the model using their corresponding symbol. Get a registered name using <code>model[:key]</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model()
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.

julia&gt; @variable(model, x)
x

julia&gt; model
A JuMP Model
Feasibility problem with:
Variable: 1
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.
Names registered in the model: x

julia&gt; model[:x] === x
true</code></pre><p>Registered names are most useful when you start to write larger models and want to break up the model construction into functions:</p><pre><code class="language-julia-repl hljs">julia&gt; function set_objective(model::Model)
           @objective(model, Min, 2 * model[:my_x] + 1)
           return
       end
set_objective (generic function with 1 method)

julia&gt; model = Model();

julia&gt; @variable(model, my_x);

julia&gt; set_objective(model)

julia&gt; print(model)
Min 2 my_x + 1
Subject to</code></pre><h2 id="anonymous_variables"><a class="docs-heading-anchor" href="#anonymous_variables">Anonymous variables</a><a id="anonymous_variables-1"></a><a class="docs-heading-anchor-permalink" href="#anonymous_variables" title="Permalink"></a></h2><p>To reduce the likelihood of accidental bugs, and because JuMP registers variables inside a model, creating two variables with the same name is an error:</p><pre><code class="language-julia hljs">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @variable(model, x)
ERROR: An object of name x is already attached to this model. If this
    is intended, consider using the anonymous construction syntax, e.g.,
    `x = @variable(model, [1:N], ...)` where the name of the object does
    not appear inside the macro.

    Alternatively, use `unregister(model, :x)` to first unregister
    the existing name from the model. Note that this will not delete the
    object; it will just remove the reference at `model[:x]`.
[...]</code></pre><p>A common reason for encountering this error is adding variables in a loop.</p><p>As a work-around, JuMP provides <em>anonymous</em> variables. Create a scalar valued anonymous variable by omitting the name argument:</p><pre><code class="language-julia-repl hljs">julia&gt; x = @variable(model)
_[1]</code></pre><p>Anonymous variables get printed as an underscore followed by a unique index of the variable.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The index of the variable may not correspond to the column of the variable in the solver!</p></div></div><p>Create a container of anonymous JuMP variables by dropping the name in front of the <code>[</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; y = @variable(model, [1:2])
2-element Vector{VariableRef}:
 _[1]
 _[2]</code></pre><p>The <code>&lt;=</code> and <code>&gt;=</code> short-hand cannot be used to set bounds on scalar-valued anonymous JuMP variables. Instead, use the <code>lower_bound</code> and <code>upper_bound</code> keywords:</p><pre><code class="language-julia-repl hljs">julia&gt; x_lower = @variable(model, lower_bound = 1.0)
_[1]

julia&gt; x_upper = @variable(model, upper_bound = 2.0)
_[2]

julia&gt; x_interval = @variable(model, lower_bound = 3.0, upper_bound = 4.0)
_[3]</code></pre><h2 id="Variable-names"><a class="docs-heading-anchor" href="#Variable-names">Variable names</a><a id="Variable-names-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-names" title="Permalink"></a></h2><p>In addition to the symbol that variables are registered with, JuMP variables have a <code>String</code> name that is used for printing and writing to file formats.</p><p>Get and set the name of a variable using <a href="../../reference/constraints/#JuMP.name-Tuple{ConstraintRef{Model, var&quot;#s1272&quot;, Shape} where {var&quot;#s1272&quot;&lt;:MathOptInterface.ConstraintIndex, Shape&lt;:AbstractShape}}"><code>name</code></a> and <a href="../../reference/constraints/#JuMP.set_name-Tuple{ConstraintRef{Model, var&quot;#s1272&quot;, Shape} where {var&quot;#s1272&quot;&lt;:MathOptInterface.ConstraintIndex, Shape&lt;:AbstractShape}, String}"><code>set_name</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; name(x)
&quot;x&quot;

julia&gt; set_name(x, &quot;my_x_name&quot;)

julia&gt; x
my_x_name</code></pre><p>Override the default choice of name using the <code>base_name</code> keyword:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[i=1:2], base_name = &quot;my_var&quot;)
2-element Vector{VariableRef}:
 my_var[1]
 my_var[2]</code></pre><p>Note that names apply to each element of the container, not to the container of variables:</p><pre><code class="language-julia-repl hljs">julia&gt; name(x[1])
&quot;my_var[1]&quot;

julia&gt; set_name(x[1], &quot;my_x&quot;)

julia&gt; x
2-element Vector{VariableRef}:
 my_x
 my_var[2]</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>For some models, setting the string name of each variable can take a non-trivial portion of the total time required to build the model. Turn off <code>String</code> names by passing <code>set_string_name = false</code> to <a href="../../reference/variables/#JuMP.@variable"><code>@variable</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x, set_string_name = false)
_[1]</code></pre><p>See <a href="../../tutorials/getting_started/performance_tips/#Disable-string-names">Disable string names</a> for more information.</p></div></div><h3 id="Retrieve-a-variable-by-name"><a class="docs-heading-anchor" href="#Retrieve-a-variable-by-name">Retrieve a variable by name</a><a id="Retrieve-a-variable-by-name-1"></a><a class="docs-heading-anchor-permalink" href="#Retrieve-a-variable-by-name" title="Permalink"></a></h3><p>Retrieve a variable from a model using <a href="../../reference/variables/#JuMP.variable_by_name"><code>variable_by_name</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; variable_by_name(model, &quot;my_x&quot;)
my_x</code></pre><p>If the name is not present, <code>nothing</code> will be returned:</p><pre><code class="language-julia-repl hljs">julia&gt; variable_by_name(model, &quot;bad_name&quot;)</code></pre><p>You can only look up individual variables using <a href="../../reference/variables/#JuMP.variable_by_name"><code>variable_by_name</code></a>. Something like this will not work:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, [i = 1:2], base_name = &quot;my_var&quot;)
2-element Vector{VariableRef}:
 my_var[1]
 my_var[2]

julia&gt; variable_by_name(model, &quot;my_var&quot;)</code></pre><p>To look up a collection of variables, do not use <a href="../../reference/variables/#JuMP.variable_by_name"><code>variable_by_name</code></a>. Instead, register them using the <code>model[:key] = value</code> syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; model[:x] = @variable(model, [i = 1:2], base_name = &quot;my_var&quot;)
2-element Vector{VariableRef}:
 my_var[1]
 my_var[2]

julia&gt; model[:x]
2-element Vector{VariableRef}:
 my_var[1]
 my_var[2]</code></pre><h2 id="variable_names_and_bindings"><a class="docs-heading-anchor" href="#variable_names_and_bindings">String names, symbolic names, and bindings</a><a id="variable_names_and_bindings-1"></a><a class="docs-heading-anchor-permalink" href="#variable_names_and_bindings" title="Permalink"></a></h2><p>It&#39;s common for new users to experience confusion relating to JuMP variables. Part of the problem is the overloaded use of &quot;variable&quot; in mathematical optimization, along with the difference between the name that a variable is registered under and the <code>String</code> name used for printing.</p><p>Here&#39;s a summary of the differences:</p><ul><li>JuMP variables are created using <a href="../../reference/variables/#JuMP.@variable"><code>@variable</code></a>.</li><li>JuMP variables can be named or anonymous.</li><li>Named JuMP variables have the form <code>@variable(model, x)</code>. For named variables:<ul><li>The <code>String</code> name of the variable is set to <code>&quot;x&quot;</code>.</li><li>A Julia variable <code>x</code> is created that binds <code>x</code> to  the JuMP variable.</li><li>The name <code>:x</code> is registered as a key in the model with the value <code>x</code>.</li></ul></li><li>Anonymous JuMP variables have the form <code>x = @variable(model)</code>. For anonymous variables:<ul><li>The <code>String</code> name of the variable is set to <code>&quot;&quot;</code>. When printed, this is replaced with <code>&quot;_[i]&quot;</code> where <code>i</code> is the index of the variable.</li><li>You control the name of the Julia variable used as the binding.</li><li>No name is registered as a key in the model.</li></ul></li><li>The <code>base_name</code> keyword can override the <code>String</code> name of the variable.</li><li>You can manually register names in the model via <code>model[:key] = value</code></li></ul><p>Here&#39;s an example that should make things clearer:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; x_binding = @variable(model, base_name = &quot;x&quot;)
x

julia&gt; model
A JuMP Model
Feasibility problem with:
Variable: 1
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.

julia&gt; x
ERROR: UndefVarError: x not defined

julia&gt; x_binding
x

julia&gt; name(x_binding)
&quot;x&quot;

julia&gt; model[:x_register] = x_binding
x

julia&gt; model
A JuMP Model
Feasibility problem with:
Variable: 1
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.
Names registered in the model: x_register

julia&gt; model[:x_register]
x

julia&gt; model[:x_register] === x_binding
true

julia&gt; x
ERROR: UndefVarError: x not defined</code></pre><h2 id="Create,-delete,-and-modify-variable-bounds"><a class="docs-heading-anchor" href="#Create,-delete,-and-modify-variable-bounds">Create, delete, and modify variable bounds</a><a id="Create,-delete,-and-modify-variable-bounds-1"></a><a class="docs-heading-anchor-permalink" href="#Create,-delete,-and-modify-variable-bounds" title="Permalink"></a></h2><p>Query whether a variable has a bound using <a href="../../reference/variables/#JuMP.has_lower_bound"><code>has_lower_bound</code></a>, <a href="../../reference/variables/#JuMP.has_upper_bound"><code>has_upper_bound</code></a>, and <a href="../../reference/variables/#JuMP.is_fixed"><code>is_fixed</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; has_lower_bound(x_free)
false

julia&gt; has_upper_bound(x_upper)
true

julia&gt; is_fixed(x_fixed)
true</code></pre><p>If a variable has a particular bound, query the value of it using <a href="../../reference/variables/#JuMP.lower_bound"><code>lower_bound</code></a>, <a href="../../reference/variables/#JuMP.upper_bound"><code>upper_bound</code></a>, and <a href="../../reference/variables/#JuMP.fix_value"><code>fix_value</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; lower_bound(x_interval)
2.0

julia&gt; upper_bound(x_interval)
3.0

julia&gt; fix_value(x_fixed)
4.0</code></pre><p>Querying the value of a bound that does not exist will result in an error.</p><p>Delete variable bounds using <a href="../../reference/variables/#JuMP.delete_lower_bound"><code>delete_lower_bound</code></a>, <a href="../../reference/variables/#JuMP.delete_upper_bound"><code>delete_upper_bound</code></a>, and <a href="../../reference/variables/#JuMP.unfix"><code>unfix</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; delete_lower_bound(x_lower)

julia&gt; has_lower_bound(x_lower)
false

julia&gt; delete_upper_bound(x_upper)

julia&gt; has_upper_bound(x_upper)
false

julia&gt; unfix(x_fixed)

julia&gt; is_fixed(x_fixed)
false</code></pre><p>Set or update variable bounds using <a href="../../reference/variables/#JuMP.set_lower_bound"><code>set_lower_bound</code></a>, <a href="../../reference/variables/#JuMP.set_upper_bound"><code>set_upper_bound</code></a>, and <a href="../../reference/variables/#JuMP.fix"><code>fix</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; set_lower_bound(x_lower, 1.1)

julia&gt; set_upper_bound(x_upper, 2.1)

julia&gt; fix(x_fixed, 4.1)</code></pre><p>Fixing a variable with existing bounds will throw an error. To delete the bounds prior to fixing, use <code>fix(variable, value; force = true)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x &gt;= 1)
x

julia&gt; fix(x, 2)
ERROR: Unable to fix x to 2 because it has existing variable bounds. Consider calling `JuMP.fix(variable, value; force=true)` which will delete existing bounds before fixing the variable.

julia&gt; fix(x, 2; force = true)


julia&gt; fix_value(x)
2.0</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Use <a href="../../reference/variables/#JuMP.fix"><code>fix</code></a> instead of <code>@constraint(model, x == 2)</code>. The former modifies variable bounds, while the latter adds a new linear constraint to the problem.</p></div></div><h2 id="Binary-variables"><a class="docs-heading-anchor" href="#Binary-variables">Binary variables</a><a id="Binary-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-variables" title="Permalink"></a></h2><p>Binary variables are constrained to the set <span>$x \in \{0, 1\}$</span>.</p><p>Create a binary variable by passing <code>Bin</code> as an optional positional argument:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x, Bin)
x</code></pre><p>Check if a variable is binary using <a href="../../reference/variables/#JuMP.is_binary"><code>is_binary</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; is_binary(x)
true</code></pre><p>Delete a binary constraint using <a href="../../reference/variables/#JuMP.unset_binary"><code>unset_binary</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; unset_binary(x)

julia&gt; is_binary(x)
false</code></pre><p>Binary variables can also be created by setting the <code>binary</code> keyword to <code>true</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x, binary=true)
x</code></pre><p>or by using <a href="../../reference/variables/#JuMP.set_binary"><code>set_binary</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x)
x

julia&gt; set_binary(x)</code></pre><h2 id="Integer-variables"><a class="docs-heading-anchor" href="#Integer-variables">Integer variables</a><a id="Integer-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Integer-variables" title="Permalink"></a></h2><p>Integer variables are constrained to the set <span>$x \in \mathbb{Z}$</span>.</p><p>Create an integer variable by passing <code>Int</code> as an optional positional argument:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x, Int)
x</code></pre><p>Check if a variable is integer using <a href="../../reference/variables/#JuMP.is_integer"><code>is_integer</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; is_integer(x)
true</code></pre><p>Delete an integer constraint using <a href="../../reference/variables/#JuMP.unset_integer"><code>unset_integer</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; unset_integer(x)

julia&gt; is_integer(x)
false</code></pre><p>Integer variables can also be created by setting the <code>integer</code> keyword to <code>true</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x, integer=true)
x</code></pre><p>or by using <a href="../../reference/variables/#JuMP.set_integer"><code>set_integer</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x)
x

julia&gt; set_integer(x)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The <a href="../../reference/variables/#JuMP.relax_integrality"><code>relax_integrality</code></a> function relaxes all integrality constraints in the model, returning a function that can be called to undo the operation later on.</p></div></div><h2 id="Start-values"><a class="docs-heading-anchor" href="#Start-values">Start values</a><a id="Start-values-1"></a><a class="docs-heading-anchor-permalink" href="#Start-values" title="Permalink"></a></h2><p>There are two ways to provide a primal starting solution (also called MIP-start or a warmstart) for each variable:</p><ul><li>using the <code>start</code> keyword in the <a href="../../reference/variables/#JuMP.@variable"><code>@variable</code></a> macro</li><li>using <a href="../../reference/variables/#JuMP.set_start_value"><code>set_start_value</code></a></li></ul><p>The starting value of a variable can be queried using <a href="../../reference/variables/#JuMP.start_value"><code>start_value</code></a>. If no start value has been set, <a href="../../reference/variables/#JuMP.start_value"><code>start_value</code></a> will return <code>nothing</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x)
x

julia&gt; start_value(x)

julia&gt; @variable(model, y, start = 1)
y

julia&gt; start_value(y)
1.0

julia&gt; set_start_value(y, 2)

julia&gt; start_value(y)
2.0</code></pre><p>The <code>start</code> keyword argument can depend on the indices of a variable container:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, z[i = 1:2], start = i^2)
2-element Vector{VariableRef}:
 z[1]
 z[2]

julia&gt; start_value.(z)
2-element Vector{Float64}:
 1.0
 4.0</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Some solvers do not support start values. If a solver does not support start values, an <code>MathOptInterface.UnsupportedAttribute{MathOptInterface.VariablePrimalStart}</code> error will be thrown.</p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>To set the optimal solution from a previous solve as a new starting value, use <a href="../../reference/variables/#JuMP.all_variables"><code>all_variables</code></a> to get a vector of all the variables in the model, then run:</p><pre><code class="language-julia hljs">x = all_variables(model)
x_solution = value.(x)
set_start_value.(x, x_solution)</code></pre></div></div><h2 id="delete_a_variable"><a class="docs-heading-anchor" href="#delete_a_variable">Delete a variable</a><a id="delete_a_variable-1"></a><a class="docs-heading-anchor-permalink" href="#delete_a_variable" title="Permalink"></a></h2><p>Use <a href="../../reference/constraints/#JuMP.delete"><code>delete</code></a> to delete a variable from a model. Use <a href="../../reference/constraints/#JuMP.is_valid"><code>is_valid</code></a> to check if a variable belongs to a model and has not been deleted.</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x)
x

julia&gt; is_valid(model, x)
true

julia&gt; delete(model, x)

julia&gt; is_valid(model, x)
false</code></pre><p>Deleting a variable does not unregister the corresponding name from the model. Therefore, creating a new variable of the same name will throw an error:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x)
ERROR: An object of name x is already attached to this model. If this
    is intended, consider using the anonymous construction syntax, e.g.,
    `x = @variable(model, [1:N], ...)` where the name of the object does
    not appear inside the macro.

    Alternatively, use `unregister(model, :x)` to first unregister
    the existing name from the model. Note that this will not delete the
    object; it will just remove the reference at `model[:x]`.
[...]</code></pre><p>After calling <a href="../../reference/constraints/#JuMP.delete"><code>delete</code></a>, call <a href="../../reference/models/#JuMP.unregister"><code>unregister</code></a> to remove the symbolic reference:</p><pre><code class="language-julia-repl hljs">julia&gt; unregister(model, :x)

julia&gt; @variable(model, x)
x</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p><a href="../../reference/constraints/#JuMP.delete"><code>delete</code></a> does not automatically <a href="../../reference/models/#JuMP.unregister"><code>unregister</code></a> because we do not distinguish between names that are automatically registered by JuMP macros and names that are manually registered by the user by setting values in <a href="../../reference/models/#JuMP.object_dictionary"><code>object_dictionary</code></a>. In addition, deleting a variable and then adding a new variable of the same name is an easy way to introduce bugs into your code.</p></div></div><h2 id="Variable-containers"><a class="docs-heading-anchor" href="#Variable-containers">Variable containers</a><a id="Variable-containers-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-containers" title="Permalink"></a></h2><p>JuMP provides a mechanism for creating collections of variables in three types of data structures, which we refer to as <em>containers</em>.</p><p>The three types are <code>Array</code>s, <code>DenseAxisArray</code>s, and <code>SparseAxisArray</code>s. We explain each of these in the following.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>You can read more about containers in the <a href="../containers/#Containers">Containers</a> section.</p></div></div><h3 id="Arrays"><a class="docs-heading-anchor" href="#Arrays">Arrays</a><a id="Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Arrays" title="Permalink"></a></h3><p>We have already seen the creation of an array of JuMP variables with the <code>x[1:2]</code> syntax. This can be extended to create multi-dimensional arrays of JuMP variables. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x[1:2, 1:2])
2×2 Matrix{VariableRef}:
 x[1,1]  x[1,2]
 x[2,1]  x[2,2]</code></pre><p>Arrays of JuMP variables can be indexed and sliced as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; x[1, 2]
x[1,2]

julia&gt; x[2, :]
2-element Vector{VariableRef}:
 x[2,1]
 x[2,2]</code></pre><p>Variable bounds can depend upon the indices:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x[i=1:2, j=1:2] &gt;= 2i + j)
2×2 Matrix{VariableRef}:
 x[1,1]  x[1,2]
 x[2,1]  x[2,2]

julia&gt; lower_bound.(x)
2×2 Matrix{Float64}:
 3.0  4.0
 5.0  6.0</code></pre><p>JuMP will form an <code>Array</code> of JuMP variables when it can determine at compile time that the indices are one-based integer ranges. Therefore <code>x[1:b]</code> will create an <code>Array</code> of JuMP variables, but <code>x[a:b]</code> will not. If JuMP cannot determine that the indices are one-based integer ranges (for example, in the case of <code>x[a:b]</code>), JuMP will create a <code>DenseAxisArray</code> instead.</p><h3 id="variable_jump_arrays"><a class="docs-heading-anchor" href="#variable_jump_arrays">DenseAxisArrays</a><a id="variable_jump_arrays-1"></a><a class="docs-heading-anchor-permalink" href="#variable_jump_arrays" title="Permalink"></a></h3><p>We often want to create arrays where the indices are not one-based integer ranges. For example, we may want to create a variable indexed by the name of a product or a location. The syntax is the same as that above, except with an arbitrary vector as an index as opposed to a one-based range. The biggest difference is that instead of returning an <code>Array</code> of JuMP variables, JuMP will return a <code>DenseAxisArray</code>. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x[1:2, [:A,:B]])
2-dimensional DenseAxisArray{VariableRef,2,...} with index sets:
    Dimension 1, Base.OneTo(2)
    Dimension 2, [:A, :B]
And data, a 2×2 Matrix{VariableRef}:
 x[1,A]  x[1,B]
 x[2,A]  x[2,B]</code></pre><p>DenseAxisArrays can be indexed and sliced as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; x[1, :A]
x[1,A]

julia&gt; x[2, :]
1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:
    Dimension 1, [:A, :B]
And data, a 2-element Vector{VariableRef}:
 x[2,A]
 x[2,B]</code></pre><p>Bounds can depend upon indices:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x[i=2:3, j=1:2:3] &gt;= 0.5i + j)
2-dimensional DenseAxisArray{VariableRef,2,...} with index sets:
    Dimension 1, 2:3
    Dimension 2, 1:2:3
And data, a 2×2 Matrix{VariableRef}:
 x[2,1]  x[2,3]
 x[3,1]  x[3,3]

julia&gt; lower_bound.(x)
2-dimensional DenseAxisArray{Float64,2,...} with index sets:
    Dimension 1, 2:3
    Dimension 2, 1:2:3
And data, a 2×2 Matrix{Float64}:
 2.0  4.0
 2.5  4.5</code></pre><h3 id="variable_sparseaxisarrays"><a class="docs-heading-anchor" href="#variable_sparseaxisarrays">SparseAxisArrays</a><a id="variable_sparseaxisarrays-1"></a><a class="docs-heading-anchor-permalink" href="#variable_sparseaxisarrays" title="Permalink"></a></h3><p>The third container type that JuMP natively supports is <code>SparseAxisArray</code>. These arrays are created when the indices do not form a rectangular set. For example, this applies when indices have a dependence upon previous indices (called <em>triangular indexing</em>). JuMP supports this as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x[i=1:2, j=i:2])
JuMP.Containers.SparseAxisArray{VariableRef, 2, Tuple{Int64, Int64}} with 3 entries:
  [1, 1]  =  x[1,1]
  [1, 2]  =  x[1,2]
  [2, 2]  =  x[2,2]</code></pre><p>We can also conditionally create variables via a JuMP-specific syntax. This syntax appends a comparison check that depends upon the named indices and is separated from the indices by a semi-colon (<code>;</code>). For example:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x[i=1:4; mod(i, 2)==0])
JuMP.Containers.SparseAxisArray{VariableRef, 1, Tuple{Int64}} with 2 entries:
  [2]  =  x[2]
  [4]  =  x[4]</code></pre><h4 id="Performance-considerations"><a class="docs-heading-anchor" href="#Performance-considerations">Performance considerations</a><a id="Performance-considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-considerations" title="Permalink"></a></h4><p>When using the semi-colon as a filter, JuMP iterates over <em>all</em> indices and evaluates the conditional for each combination. If there are many index dimensions and a large amount of sparsity, this can be inefficient.</p><p>For example:</p><pre><code class="language-julia-repl hljs">julia&gt; N = 10
10

julia&gt; S = [(1, 1, 1), (N, N, N)]
2-element Vector{Tuple{Int64, Int64, Int64}}:
 (1, 1, 1)
 (10, 10, 10)

julia&gt; @time @variable(model, x1[i=1:N, j=1:N, k=1:N; (i, j, k) in S])
  0.203861 seconds (392.22 k allocations: 23.977 MiB, 99.10% compilation time)
JuMP.Containers.SparseAxisArray{VariableRef, 3, Tuple{Int64, Int64, Int64}} with 2 entries:
  [1, 1, 1   ]  =  x1[1,1,1]
  [10, 10, 10]  =  x1[10,10,10]

julia&gt; @time @variable(model, x2[S])
  0.045407 seconds (65.24 k allocations: 3.771 MiB, 99.15% compilation time)
1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:
    Dimension 1, [(1, 1, 1), (10, 10, 10)]
And data, a 2-element Vector{VariableRef}:
 x2[(1, 1, 1)]
 x2[(10, 10, 10)]</code></pre><p>The first option is slower because it is equivalent to:</p><pre><code class="language-julia hljs">x1 = Dict()
for i in 1:N
    for j in 1:N
        for k in 1:N
            if (i, j, k) in S
                x1[i, j, k] = @variable(model)
            end
        end
    end
end</code></pre><p>If performance is a concern, explicitly construct the set of indices instead of using the filtering syntax.</p><h3 id="variable_forcing"><a class="docs-heading-anchor" href="#variable_forcing">Forcing the container type</a><a id="variable_forcing-1"></a><a class="docs-heading-anchor-permalink" href="#variable_forcing" title="Permalink"></a></h3><p>When creating a container of JuMP variables, JuMP will attempt to choose the tightest container type that can store the JuMP variables. Thus, it will prefer to create an Array before a DenseAxisArray and a DenseAxisArray before a SparseAxisArray. However, because this happens at compile time, JuMP does not always make the best choice. To illustrate this, consider the following example:</p><pre><code class="language-julia-repl hljs">julia&gt; A = 1:2
1:2

julia&gt; @variable(model, x[A])
1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:
    Dimension 1, 1:2
And data, a 2-element Vector{VariableRef}:
 x[1]
 x[2]</code></pre><p>Since the value (and type) of <code>A</code> is unknown at parsing time, JuMP is unable to infer that <code>A</code> is a one-based integer range. Therefore, JuMP creates a <code>DenseAxisArray</code>, even though it could store these two variables in a standard one-dimensional <code>Array</code>.</p><p>We can share our knowledge that it is possible to store these JuMP variables as an array by setting the <code>container</code> keyword:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, y[A], container=Array)
2-element Vector{VariableRef}:
 y[1]
 y[2]</code></pre><p>JuMP now creates a vector of JuMP variables instead of a DenseAxisArray. Choosing an invalid container type will throw an error.</p><h3 id="User-defined-containers"><a class="docs-heading-anchor" href="#User-defined-containers">User-defined containers</a><a id="User-defined-containers-1"></a><a class="docs-heading-anchor-permalink" href="#User-defined-containers" title="Permalink"></a></h3><p>In addition to the built-in container types, you can create your own collections of JuMP variables.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>This is a point that users often overlook: you are not restricted to the built-in container types in JuMP.</p></div></div><p>For example, the following code creates a dictionary with symmetric matrices as the values:</p><pre><code class="language-julia-repl hljs">julia&gt; variables = Dict{Symbol,Array{VariableRef,2}}(
           key =&gt; @variable(model, [1:2, 1:2], Symmetric, base_name = &quot;$(key)&quot;)
           for key in [:A, :B]
       )
Dict{Symbol, Matrix{VariableRef}} with 2 entries:
  :A =&gt; [A[1,1] A[1,2]; A[1,2] A[2,2]]
  :B =&gt; [B[1,1] B[1,2]; B[1,2] B[2,2]]</code></pre><p>Another common scenario is a request to add variables to existing containers, for example:</p><pre><code class="language-julia hljs">using JuMP
model = Model()
@variable(model, x[1:2] &gt;= 0)
# Later I want to add
@variable(model, x[3:4] &gt;= 0)</code></pre><p>This is not possible with the built-in JuMP container types. However, you can use regular Julia types instead:</p><pre><code class="language-julia hljs">model = Model()
x = model[:x] = @variable(model, [1:2], lower_bound = 0, base_name = &quot;x&quot;)
append!(x, @variable(model, [1:2], lower_bound = 0, base_name = &quot;y&quot;))
model[:x]

# output

4-element Vector{VariableRef}:
 x[1]
 x[2]
 y[1]
 y[2]</code></pre><h2 id="Semidefinite-variables"><a class="docs-heading-anchor" href="#Semidefinite-variables">Semidefinite variables</a><a id="Semidefinite-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Semidefinite-variables" title="Permalink"></a></h2><p>Declare a square matrix of JuMP variables to be positive semidefinite by passing <code>PSD</code> as an optional positional argument:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x[1:2, 1:2], PSD)
2×2 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:
 x[1,1]  x[1,2]
 x[1,2]  x[2,2]</code></pre><p>This will ensure that <code>x</code> is symmetric, and that all of its eigenvalues are nonnegative.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>x</code> must be a square 2-dimensional <code>Array</code> of JuMP variables; it cannot be a DenseAxisArray or a SparseAxisArray.</p></div></div><h2 id="Symmetric-variables"><a class="docs-heading-anchor" href="#Symmetric-variables">Symmetric variables</a><a id="Symmetric-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetric-variables" title="Permalink"></a></h2><p>Declare a square matrix of JuMP variables to be symmetric (but not necessarily positive semidefinite) by passing <code>Symmetric</code>  as an optional positional argument:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x[1:2, 1:2], Symmetric)
2×2 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:
 x[1,1]  x[1,2]
 x[1,2]  x[2,2]</code></pre><h2 id="variables"><a class="docs-heading-anchor" href="#variables">The <code>@variables</code> macro</a><a id="variables-1"></a><a class="docs-heading-anchor-permalink" href="#variables" title="Permalink"></a></h2><p>If you have many <a href="../../reference/variables/#JuMP.@variable"><code>@variable</code></a> calls, JuMP provides the macro <a href="../../reference/variables/#JuMP.@variables"><code>@variables</code></a> that can improve readability:</p><pre><code class="language-julia-repl hljs">julia&gt; @variables(model, begin
           x
           y[i=1:2] &gt;= i, (start = i, base_name = &quot;Y_$i&quot;)
           z, Bin
       end)
(x, VariableRef[Y_1[1], Y_2[2]], z)

julia&gt; print(model)
Feasibility
Subject to
 Y_1[1] ≥ 1.0
 Y_2[2] ≥ 2.0
 z binary</code></pre><p>The <a href="../../reference/variables/#JuMP.@variables"><code>@variables</code></a> macro returns a tuple of the variables that were defined.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Keyword arguments must be contained within parentheses.</p></div></div><h2 id="jump_variables_on_creation"><a class="docs-heading-anchor" href="#jump_variables_on_creation">Variables constrained on creation</a><a id="jump_variables_on_creation-1"></a><a class="docs-heading-anchor-permalink" href="#jump_variables_on_creation" title="Permalink"></a></h2><p>All uses of the <a href="../../reference/variables/#JuMP.@variable"><code>@variable</code></a> macro documented so far translate into separate calls for variable creation and the adding of any bound or integrality constraints.</p><p>For example, <code>@variable(model, x &gt;= 0, Int)</code>, is equivalent to:</p><pre><code class="language-julia hljs">@variable(model, x)
set_lower_bound(x, 0.0)
set_integer(x)</code></pre><p>Importantly, the bound and integrality constraints are added <em>after</em> the variable has been created.</p><p>However, some solvers require a set specifying the variable domain to be given when the variable is first created. We say that these variables are <em>constrained on creation</em>.</p><p>Use <code>in</code> within <a href="../../reference/variables/#JuMP.@variable"><code>@variable</code></a> to access the special syntax for constraining variables on creation.</p><p>For example, the following creates a vector of variables that belong to the <a href="../../reference/constraints/#JuMP.SecondOrderCone"><code>SecondOrderCone</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, y[1:3] in SecondOrderCone())
3-element Vector{VariableRef}:
 y[1]
 y[2]
 y[3]</code></pre><p>For contrast, the standard syntax is as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x[1:3])
3-element Vector{VariableRef}:
 x[1]
 x[2]
 x[3]

julia&gt; @constraint(model, x in SecondOrderCone())
[x[1], x[2], x[3]] ∈ MathOptInterface.SecondOrderCone(3)</code></pre><p>An alternate syntax to <code>x in Set</code> is to use the <code>set</code> keyword of <a href="../../reference/variables/#JuMP.@variable"><code>@variable</code></a>. This is most useful when creating anonymous variables:</p><pre><code class="language-julia hljs">x = @variable(model, [1:3], set = SecondOrderCone())</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You cannot delete the constraint associated with a variable constrained on creation.</p></div></div><h3 id="Example:-positive-semidefinite-variables"><a class="docs-heading-anchor" href="#Example:-positive-semidefinite-variables">Example: positive semidefinite variables</a><a id="Example:-positive-semidefinite-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-positive-semidefinite-variables" title="Permalink"></a></h3><p>An alternative to the syntax in <a href="#Semidefinite-variables">Semidefinite variables</a>, declare a matrix of JuMP variables to be positive semidefinite using <a href="../../reference/constraints/#JuMP.PSDCone"><code>PSDCone</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x[1:2, 1:2] in PSDCone())
2×2 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:
 x[1,1]  x[1,2]
 x[1,2]  x[2,2]</code></pre><h3 id="Example:-symmetric-variables"><a class="docs-heading-anchor" href="#Example:-symmetric-variables">Example: symmetric variables</a><a id="Example:-symmetric-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-symmetric-variables" title="Permalink"></a></h3><p>As an alternative to the syntax in <a href="#Symmetric-variables">Symmetric variables</a>, declare a matrix of JuMP variables to be symmetric using <a href="../../reference/constraints/#JuMP.SymmetricMatrixSpace"><code>SymmetricMatrixSpace</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x[1:2, 1:2] in SymmetricMatrixSpace())
2×2 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:
 x[1,1]  x[1,2]
 x[1,2]  x[2,2]</code></pre><h3 id="Example:-skew-symmetric-variables"><a class="docs-heading-anchor" href="#Example:-skew-symmetric-variables">Example: skew-symmetric variables</a><a id="Example:-skew-symmetric-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-skew-symmetric-variables" title="Permalink"></a></h3><p>Declare a matrix of JuMP variables to be skew-symmetric using <a href="../../reference/constraints/#JuMP.SkewSymmetricMatrixSpace"><code>SkewSymmetricMatrixSpace</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x[1:2, 1:2] in SkewSymmetricMatrixSpace())
2×2 Matrix{AffExpr}:
 0        x[1,2]
 -x[1,2]  0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Even though <code>x</code> is a 2 by 2 matrix, only one decision variable is added to <code>model</code>; the remaining elements in <code>x</code> are linear transformations of the single variable.</p></div></div><p>Because the returned matrix <code>x</code> is <code>Matrix{AffExpr}</code>, you cannot use variable-related functions on its elements:</p><pre><code class="language-julia-repl hljs">julia&gt; set_lower_bound(x[1, 2], 0.0)
ERROR: MethodError: no method matching set_lower_bound(::AffExpr, ::Float64)
[...]</code></pre><p>However, you can convert the matrix into one in which the upper triangular elements are <code>VariableRef</code> and the lower triangular elements are <code>AffExpr</code> as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; y = Union{VariableRef,AffExpr}[
           j &gt; i ? first(keys(x[i, j].terms)) : x[i, j]
           for i in 1:size(x, 1), j in 1:size(x, 2)
       ]
2×2 Matrix{Union{VariableRef, AffExpr}}:
 0        x[1,2]
 -x[1,2]  0

julia&gt; set_lower_bound(y[1, 2], 0.0)</code></pre><h3 id="Why-use-variables-constrained-on-creation?"><a class="docs-heading-anchor" href="#Why-use-variables-constrained-on-creation?">Why use variables constrained on creation?</a><a id="Why-use-variables-constrained-on-creation?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-use-variables-constrained-on-creation?" title="Permalink"></a></h3><p>For most users, it does not matter if you use the constrained on creation syntax. Therefore, use whatever syntax you find most convenient.</p><p>However, if you use <a href="../../reference/models/#JuMP.direct_model"><code>direct_model</code></a>, you may be forced to use the constrained on creation syntax.</p><p>The technical difference between variables constrained on creation and the standard JuMP syntax is that variables constrained on creation calls <code>MOI.add_constrained_variables</code>, while the standard JuMP syntax calls <code>MOI.add_variables</code> and then <code>MOI.add_constraint</code>.</p><p>Consult the implementation of solver package you are using to see if your solver requires <code>MOI.add_constrained_variables</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../models/">« Models</a><a class="docs-footer-nextpage" href="../constraints/">Constraints »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Wednesday 22 February 2023 23:55">Wednesday 22 February 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
