<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solutions Â· JuMP</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuMP logo"/></a><div class="docs-package-name"><span class="docs-autofit">JuMP</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../installation/">Installation Guide</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/Getting started/an_introduction_to_julia/">Getting started with Julia</a></li><li><a class="tocitem" href="../../tutorials/Getting started/getting_started_with_JuMP/">Getting started with JuMP</a></li><li><a class="tocitem" href="../../tutorials/Getting started/performance_tips/">Performance tips</a></li><li><a class="tocitem" href="../../tutorials/Getting started/solvers_and_solutions/">Solvers and Solutions</a></li><li><a class="tocitem" href="../../tutorials/Getting started/variables_constraints_objective/">Variables, constraints, and objective functions</a></li><li><a class="tocitem" href="../../tutorials/Getting started/working_with_data_files/">Working with Data Files</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Mixed-integer linear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/cutting_stock_column_generation/">Cutting stock</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/diet/">The diet problem</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/finance/">Finance</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/geographic_clustering/">Geographical Clustering</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/knapsack/">The knapsack problem</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/n-queens/">N-Queens</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/network_flows/">Network Flows</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/power_systems/">Power Systems</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/prod/">The workforce scheduling problem</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/steelT3/">The SteelT3 problem</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/sudoku/">Sudoku</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/transp/">The transportation problem</a></li><li><a class="tocitem" href="../../tutorials/Mixed-integer linear programs/urban_plan/">The urban planning problem</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Nonlinear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/Nonlinear programs/clnlbeam/">The clnlbeam problem</a></li><li><a class="tocitem" href="../../tutorials/Nonlinear programs/mle/">Maximum likelihood estimation</a></li><li><a class="tocitem" href="../../tutorials/Nonlinear programs/nlp_tricks/">Nonlinear tips and tricks</a></li><li><a class="tocitem" href="../../tutorials/Nonlinear programs/rocket_control/">Rocket Control</a></li><li><a class="tocitem" href="../../tutorials/Nonlinear programs/rosenbrock/">The Rosenbrock function</a></li><li><a class="tocitem" href="../../tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/">Space Shuttle Reentry Trajectory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Quadratic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/Quadratic programs/portfolio/">Portfolio Optimization</a></li><li><a class="tocitem" href="../../tutorials/Quadratic programs/qcp/">Quadratically constrained programs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Conic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/Conic programs/logistic_regression/">Logistic Regression</a></li><li><a class="tocitem" href="../../tutorials/Conic programs/tips_and_tricks/">Tips and Tricks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-6" type="checkbox"/><label class="tocitem" for="menuitem-3-6"><span class="docs-label">Semidefinite programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/Semidefinite programs/cluster/">K-means clustering via SDP</a></li><li><a class="tocitem" href="../../tutorials/Semidefinite programs/corr_sdp/">The correlation problem</a></li><li><a class="tocitem" href="../../tutorials/Semidefinite programs/experiment_design/">Experiment Design</a></li><li><a class="tocitem" href="../../tutorials/Semidefinite programs/max_cut_sdp/">SDP relaxations: max-cut</a></li><li><a class="tocitem" href="../../tutorials/Semidefinite programs/min_distortion/">The minimum distortion problem</a></li><li><a class="tocitem" href="../../tutorials/Semidefinite programs/min_ellipse/">Minimum ellipses</a></li><li><a class="tocitem" href="../../tutorials/Semidefinite programs/robust_uncertainty/">Robust uncertainty sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Optimization concepts</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/Optimization concepts/benders_decomposition/">Benders Decomposition</a></li><li><a class="tocitem" href="../../tutorials/Optimization concepts/benders_lazy_constraints/">Benders Decomposition (Lazy Constraints)</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/models/">Models</a></li><li><a class="tocitem" href="../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../manual/expressions/">Expressions</a></li><li><a class="tocitem" href="../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../manual/containers/">Containers</a></li><li><a class="tocitem" href="../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../manual/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../manual/callbacks/">Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../variables/">Variables</a></li><li><a class="tocitem" href="../expressions/">Expressions</a></li><li><a class="tocitem" href="../objectives/">Objectives</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../containers/">Containers</a></li><li class="is-active"><a class="tocitem" href>Solutions</a><ul class="internal"><li><a class="tocitem" href="#Basic-utilities"><span>Basic utilities</span></a></li><li><a class="tocitem" href="#Termination-status"><span>Termination status</span></a></li><li><a class="tocitem" href="#Primal-solutions"><span>Primal solutions</span></a></li><li><a class="tocitem" href="#Dual-solutions"><span>Dual solutions</span></a></li><li><a class="tocitem" href="#Basic-attributes"><span>Basic attributes</span></a></li><li><a class="tocitem" href="#ref_conflicts"><span>Conflicts</span></a></li><li><a class="tocitem" href="#Sensitivity"><span>Sensitivity</span></a></li><li><a class="tocitem" href="#Feasibility"><span>Feasibility</span></a></li></ul></li><li><a class="tocitem" href="../nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../moi/">MathOptInterface</a></li><li><a class="tocitem" href="../extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background information</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/should_i_use/">Should I use JuMP?</a></li><li><a class="tocitem" href="../../background/algebraic_modeling_languages/">Algebraic modeling languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../developers/extensions/">Extensions</a></li><li><a class="tocitem" href="../../developers/style/">Style Guide</a></li><li><a class="tocitem" href="../../developers/roadmap/">Roadmap</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Solutions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solutions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/reference/solutions.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SolutionAPI"><a class="docs-heading-anchor" href="#SolutionAPI">Solutions</a><a id="SolutionAPI-1"></a><a class="docs-heading-anchor-permalink" href="#SolutionAPI" title="Permalink"></a></h1><p>More information can be found in the <a href="../../manual/solutions/#Solutions">Solutions</a> section of the manual.</p><h2 id="Basic-utilities"><a class="docs-heading-anchor" href="#Basic-utilities">Basic utilities</a><a id="Basic-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.optimize!" href="#JuMP.optimize!"><code>JuMP.optimize!</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">optimize!(model::Model;
          ignore_optimize_hook=(model.optimize_hook === nothing),
          kwargs...)</code></pre><p>Optimize the model. If an optimizer has not been set yet (see <a href="../models/#JuMP.set_optimizer"><code>set_optimizer</code></a>), a <a href="#JuMP.NoOptimizer"><code>NoOptimizer</code></a> error is thrown.</p><p>Keyword arguments <code>kwargs</code> are passed to the <code>optimize_hook</code>. An error is thrown if <code>optimize_hook</code> is <code>nothing</code> and keyword arguments are provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/optimizer_interface.jl#L135-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.NoOptimizer" href="#JuMP.NoOptimizer"><code>JuMP.NoOptimizer</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct NoOptimizer &lt;: Exception end</code></pre><p>No optimizer is set. The optimizer can be provided to the <a href="../models/#JuMP.Model"><code>Model</code></a> constructor or by calling <a href="../models/#JuMP.set_optimizer"><code>set_optimizer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/JuMP.jl#L1065-L1070">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.OptimizeNotCalled" href="#JuMP.OptimizeNotCalled"><code>JuMP.OptimizeNotCalled</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct OptimizeNotCalled &lt;: Exception end</code></pre><p>A result attribute cannot be queried before <a href="#JuMP.optimize!"><code>optimize!</code></a> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/JuMP.jl#L1058-L1062">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.solution_summary" href="#JuMP.solution_summary"><code>JuMP.solution_summary</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solution_summary(model::Model; verbose::Bool = false)</code></pre><p>Return a struct that can be used print a summary of the solution.</p><p>If <code>verbose=true</code>, write out the primal solution for every variable and the dual solution for every constraint, excluding those with empty names.</p><p><strong>Examples</strong></p><p>When called at the REPL, the summary is automatically printed:</p><pre><code class="language-julia">julia&gt; solution_summary(model)
[...]</code></pre><p>Use <code>print</code> to force the printing of the summary from inside a function:</p><pre><code class="language-julia">function foo(model)
    print(solution_summary(model))
    return
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/print.jl#L438-L461">source</a></section></article><h2 id="Termination-status"><a class="docs-heading-anchor" href="#Termination-status">Termination status</a><a id="Termination-status-1"></a><a class="docs-heading-anchor-permalink" href="#Termination-status" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.termination_status" href="#JuMP.termination_status"><code>JuMP.termination_status</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">termination_status(model::Model)</code></pre><p>Return the reason why the solver stopped (i.e., the MathOptInterface model attribute <code>TerminationStatus</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/JuMP.jl#L637-L642">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.TerminationStatusCode" href="#MathOptInterface.TerminationStatusCode"><code>MathOptInterface.TerminationStatusCode</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TerminationStatusCode</code></pre><p>An Enum of possible values for the <code>TerminationStatus</code> attribute. This attribute is meant to explain the reason why the optimizer stopped executing in the most recent call to <a href="../moi/#MathOptInterface.optimize!"><code>optimize!</code></a>.</p><p>If no call has been made to <a href="../moi/#MathOptInterface.optimize!"><code>optimize!</code></a>, then the <code>TerminationStatus</code> is:</p><ul><li><code>OPTIMIZE_NOT_CALLED</code>: The algorithm has not started.</li></ul><p><strong>OK</strong></p><p>These are generally OK statuses, i.e., the algorithm ran to completion normally.</p><ul><li><code>OPTIMAL</code>: The algorithm found a globally optimal solution.</li><li><code>INFEASIBLE</code>: The algorithm concluded that no feasible solution exists.</li><li><code>DUAL_INFEASIBLE</code>: The algorithm concluded that no dual bound exists for the problem. If, additionally, a feasible (primal) solution is known to exist, this status typically implies that the problem is unbounded, with some technical exceptions.</li><li><code>LOCALLY_SOLVED</code>: The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.</li><li><code>LOCALLY_INFEASIBLE</code>: The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.</li><li><code>INFEASIBLE_OR_UNBOUNDED</code>: The algorithm stopped because it decided that the problem is infeasible or unbounded; this occasionally happens during MIP presolve.</li></ul><p><strong>Solved to relaxed tolerances</strong></p><ul><li><code>ALMOST_OPTIMAL</code>: The algorithm found a globally optimal solution to relaxed tolerances.</li><li><code>ALMOST_INFEASIBLE</code>: The algorithm concluded that no feasible solution exists within relaxed tolerances.</li><li><code>ALMOST_DUAL_INFEASIBLE</code>: The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.</li><li><code>ALMOST_LOCALLY_SOLVED</code>: The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.</li></ul><p><strong>Limits</strong></p><p>The optimizer stopped because of some user-defined limit.</p><ul><li><code>ITERATION_LIMIT</code>: An iterative algorithm stopped after conducting the maximum number of iterations.</li><li><code>TIME_LIMIT</code>: The algorithm stopped after a user-specified computation time.</li><li><code>NODE_LIMIT</code>: A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.</li><li><code>SOLUTION_LIMIT</code>: The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.</li><li><code>MEMORY_LIMIT</code>: The algorithm stopped because it ran out of memory.</li><li><code>OBJECTIVE_LIMIT</code>: The algorithm stopped because it found a solution better than a minimum limit set by the user.</li><li><code>NORM_LIMIT</code>: The algorithm stopped because the norm of an iterate became too large.</li><li><code>OTHER_LIMIT</code>: The algorithm stopped due to a limit not covered by one of the above.</li></ul><p><strong>Problematic</strong></p><p>This group of statuses means that something unexpected or problematic happened.</p><ul><li><code>SLOW_PROGRESS</code>: The algorithm stopped because it was unable to continue making progress towards the solution.</li><li><code>NUMERICAL_ERROR</code>: The algorithm stopped because it encountered unrecoverable numerical error.</li><li><code>INVALID_MODEL</code>: The algorithm stopped because the model is invalid.</li><li><code>INVALID_OPTION</code>: The algorithm stopped because it was provided an invalid option.</li><li><code>INTERRUPTED</code>: The algorithm stopped because of an interrupt signal.</li><li><code>OTHER_ERROR</code>: The algorithm stopped because of an error not covered by one of the statuses defined above.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.raw_status" href="#JuMP.raw_status"><code>JuMP.raw_status</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">raw_status(model::Model)</code></pre><p>Return the reason why the solver stopped in its own words (i.e., the MathOptInterface model attribute <code>RawStatusString</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/JuMP.jl#L647-L652">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.result_count" href="#JuMP.result_count"><code>JuMP.result_count</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">result_count(model::Model)</code></pre><p>Return the number of results available to query after a call to <a href="#JuMP.optimize!"><code>optimize!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/optimizer_interface.jl#L222-L227">source</a></section></article><h2 id="Primal-solutions"><a class="docs-heading-anchor" href="#Primal-solutions">Primal solutions</a><a id="Primal-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Primal-solutions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.primal_status" href="#JuMP.primal_status"><code>JuMP.primal_status</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">primal_status(model::Model; result::Int = 1)</code></pre><p>Return the status of the most recent primal solution of the solver (i.e., the MathOptInterface model attribute <code>PrimalStatus</code>) associated with the result index <code>result</code>.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/JuMP.jl#L657-L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_values" href="#JuMP.has_values"><code>JuMP.has_values</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">has_values(model::Model; result::Int = 1)</code></pre><p>Return <code>true</code> if the solver has a primal solution in result index <code>result</code> available to query, otherwise return <code>false</code>.</p><p>See also <a href="#JuMP.value"><code>value</code></a> and <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/variables.jl#L941-L948">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.value" href="#JuMP.value"><code>JuMP.value</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">value(con_ref::ConstraintRef; result::Int = 1)</code></pre><p>Return the primal value of constraint <code>con_ref</code> associated with result index <code>result</code> of the most-recent solution returned by the solver.</p><p>That is, if <code>con_ref</code> is the reference of a constraint <code>func</code>-in-<code>set</code>, it returns the value of <code>func</code> evaluated at the value of the variables (given by <a href="../nlp/#JuMP.value-Tuple{NonlinearParameter}"><code>value(::VariableRef)</code></a>).</p><p>Use <a href="#JuMP.has_values"><code>has_values</code></a> to check if a result exists before asking for values.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>.</p><p><strong>Note</strong></p><p>For scalar constraints, the constant is moved to the <code>set</code> so it is not taken into account in the primal value of the constraint. For instance, the constraint <code>@constraint(model, 2x + 3y + 1 == 5)</code> is transformed into <code>2x + 3y</code>-in-<code>MOI.EqualTo(4)</code> so the value returned by this function is the evaluation of <code>2x + 3y</code>. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/constraints.jl#L745-L767">source</a></section><section><div><pre><code class="language-none">value(con_ref::ConstraintRef, var_value::Function)</code></pre><p>Evaluate the primal value of the constraint <code>con_ref</code> using <code>var_value(v)</code> as the value for each variable <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/constraints.jl#L775-L780">source</a></section><section><div><pre><code class="language-none">value(v::VariableRef; result = 1)</code></pre><p>Return the value of variable <code>v</code> associated with result index <code>result</code> of the most-recent returned by the solver.</p><p>Use <a href="#JuMP.has_values"><code>has_values</code></a> to check if a result exists before asking for values.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/variables.jl#L918-L927">source</a></section><section><div><pre><code class="language-none">value(v::VariableRef, var_value::Function)</code></pre><p>Evaluate the value of the variable <code>v</code> as <code>var_value(v)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/variables.jl#L932-L936">source</a></section><section><div><pre><code class="language-none">value(ex::GenericAffExpr, var_value::Function)</code></pre><p>Evaluate <code>ex</code> using <code>var_value(v)</code> as the value for each variable <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/aff_expr.jl#L270-L274">source</a></section><section><div><pre><code class="language-none">value(v::GenericAffExpr; result::Int = 1)</code></pre><p>Return the value of the <code>GenericAffExpr</code> <code>v</code> associated with result index <code>result</code> of the most-recent solution returned by the solver.</p><p>Replaces <code>getvalue</code> for most use cases.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/aff_expr.jl#L483-L492">source</a></section><section><div><pre><code class="language-none">value(v::GenericQuadExpr; result::Int = 1)</code></pre><p>Return the value of the <code>GenericQuadExpr</code> <code>v</code> associated with result index <code>result</code> of the most-recent solution returned by the solver.</p><p>Replaces <code>getvalue</code> for most use cases.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/quad_expr.jl#L632-L641">source</a></section><section><div><pre><code class="language-julia">value(p::NonlinearParameter)</code></pre><p>Return the current value stored in the nonlinear parameter <code>p</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">model = Model()
@NLparameter(model, p == 10)
value(p)

# output
10.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/nlp.jl#L121-L135">source</a></section><section><div><pre><code class="language-none">value(ex::NonlinearExpression, var_value::Function)</code></pre><p>Evaluate <code>ex</code> using <code>var_value(v)</code> as the value for each variable <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/nlp.jl#L1667-L1671">source</a></section><section><div><pre><code class="language-none">value(ex::NonlinearExpression; result::Int = 1)</code></pre><p>Return the value of the <code>NonlinearExpression</code> <code>ex</code> associated with result index <code>result</code> of the most-recent solution returned by the solver.</p><p>Replaces <code>getvalue</code> for most use cases.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/nlp.jl#L1720-L1729">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ResultStatusCode" href="#MathOptInterface.ResultStatusCode"><code>MathOptInterface.ResultStatusCode</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ResultStatusCode</code></pre><p>An Enum of possible values for the <code>PrimalStatus</code> and <code>DualStatus</code> attributes. The values indicate how to interpret the result vector.</p><ul><li><code>NO_SOLUTION</code>: the result vector is empty.</li><li><code>FEASIBLE_POINT</code>: the result vector is a feasible point.</li><li><code>NEARLY_FEASIBLE_POINT</code>: the result vector is feasible if some constraint tolerances are relaxed.</li><li><code>INFEASIBLE_POINT</code>: the result vector is an infeasible point.</li><li><code>INFEASIBILITY_CERTIFICATE</code>: the result vector is an infeasibility certificate. If the <code>PrimalStatus</code> is <code>INFEASIBILITY_CERTIFICATE</code>, then the primal result vector is a certificate of dual infeasibility. If the <code>DualStatus</code> is <code>INFEASIBILITY_CERTIFICATE</code>, then the dual result vector is a proof of primal infeasibility.</li><li><code>NEARLY_INFEASIBILITY_CERTIFICATE</code>: the result satisfies a relaxed criterion for a certificate of infeasibility.</li><li><code>REDUCTION_CERTIFICATE</code>: the result vector is an ill-posed certificate; see <a href="https://arxiv.org/abs/1408.4685">this article</a> for details. If the <code>PrimalStatus</code> is <code>REDUCTION_CERTIFICATE</code>, then the primal result vector is a proof that the dual problem is ill-posed. If the <code>DualStatus</code> is <code>REDUCTION_CERTIFICATE</code>, then the dual result vector is a proof that the primal is ill-posed.</li><li><code>NEARLY_REDUCTION_CERTIFICATE</code>: the result satisfies a relaxed criterion for an ill-posed certificate.</li><li><code>UNKNOWN_RESULT_STATUS</code>: the result vector contains a solution with an unknown interpretation.</li><li><code>OTHER_RESULT_STATUS</code>: the result vector contains a solution with an interpretation not covered by one of the statuses defined above.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L30">source</a></section></article><h2 id="Dual-solutions"><a class="docs-heading-anchor" href="#Dual-solutions">Dual solutions</a><a id="Dual-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Dual-solutions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual_status" href="#JuMP.dual_status"><code>JuMP.dual_status</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dual_status(model::Model; result::Int = 1)</code></pre><p>Return the status of the most recent dual solution of the solver (i.e., the MathOptInterface model attribute <code>DualStatus</code>) associated with the result index <code>result</code>.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/JuMP.jl#L670-L678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_duals" href="#JuMP.has_duals"><code>JuMP.has_duals</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">has_duals(model::Model; result::Int = 1)</code></pre><p>Return <code>true</code> if the solver has a dual solution in result index <code>result</code> available to query, otherwise return <code>false</code>.</p><p>See also <a href="#JuMP.dual"><code>dual</code></a>, <a href="#JuMP.shadow_price"><code>shadow_price</code></a>, and <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/constraints.jl#L809-L816">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual" href="#JuMP.dual"><code>JuMP.dual</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dual(con_ref::ConstraintRef; result::Int = 1)</code></pre><p>Return the dual value of constraint <code>con_ref</code> associated with result index <code>result</code> of the most-recent solution returned by the solver.</p><p>Use <code>has_dual</code> to check if a result exists before asking for values.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>, <a href="#JuMP.shadow_price"><code>shadow_price</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/constraints.jl#L821-L830">source</a></section><section><div><pre><code class="language-none">dual(c::ConstraintRef{Model,NonlinearConstraintIndex})</code></pre><p>Return the dual of the nonlinear constraint <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/nlp.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.shadow_price" href="#JuMP.shadow_price"><code>JuMP.shadow_price</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">shadow_price(con_ref::ConstraintRef)</code></pre><p>Return the change in the objective from an infinitesimal relaxation of the constraint.</p><p>This value is computed from <a href="#JuMP.dual"><code>dual</code></a> and can be queried only when <code>has_duals</code> is <code>true</code> and the objective sense is <code>MIN_SENSE</code> or <code>MAX_SENSE</code> (not <code>FEASIBILITY_SENSE</code>). For linear constraints, the shadow prices differ at most in sign from the <code>dual</code> value depending on the objective sense.</p><p>See also <a href="#JuMP.reduced_cost"><code>reduced_cost</code></a>.</p><p><strong>Notes</strong></p><ul><li>The function simply translates signs from <code>dual</code> and does not validate the conditions needed to guarantee the sensitivity interpretation of the shadow price. The caller is responsible, e.g., for checking whether the solver converged to an optimal primal-dual pair or a proof of infeasibility.</li><li>The computation is based on the current objective sense of the model. If this has changed since the last solve, the results will be incorrect.</li><li>Relaxation of equality constraints (and hence the shadow price) is defined based on which sense of the equality constraint is active.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/constraints.jl#L861-L884">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.reduced_cost" href="#JuMP.reduced_cost"><code>JuMP.reduced_cost</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reduced_cost(x::VariableRef)::Float64</code></pre><p>Return the reduced cost associated with variable <code>x</code>.</p><p>Equivalent to querying the shadow price of the active variable bound (if one exists and is active).</p><p>See also: <a href="#JuMP.shadow_price"><code>shadow_price</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/variables.jl#L1136-L1145">source</a></section></article><h2 id="Basic-attributes"><a class="docs-heading-anchor" href="#Basic-attributes">Basic attributes</a><a id="Basic-attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-attributes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.objective_value" href="#JuMP.objective_value"><code>JuMP.objective_value</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">objective_value(model::Model; result::Int = 1)</code></pre><p>Return the objective value associated with result index <code>result</code> of the most-recent solution returned by the solver.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/objective.jl#L33-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.objective_bound" href="#JuMP.objective_bound"><code>JuMP.objective_bound</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">objective_bound(model::Model)</code></pre><p>Return the best known bound on the optimal objective value after a call to <code>optimize!(model)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/objective.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual_objective_value" href="#JuMP.dual_objective_value"><code>JuMP.dual_objective_value</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dual_objective_value(model::Model; result::Int = 1)</code></pre><p>Return the value of the objective of the dual problem associated with result index <code>result</code> of the most-recent solution returned by the solver.</p><p>Throws <code>MOI.UnsupportedAttribute{MOI.DualObjectiveValue}</code> if the solver does not support this attribute.</p><p>See also: <a href="#JuMP.result_count"><code>result_count</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/objective.jl#L45-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.solve_time" href="#JuMP.solve_time"><code>JuMP.solve_time</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solve_time(model::Model)</code></pre><p>If available, returns the solve time reported by the solver. Returns &quot;ArgumentError: ModelLike of type <code>Solver.Optimizer</code> does not support accessing the attribute MathOptInterface.SolveTime()&quot; if the attribute is not implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/JuMP.jl#L712-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.relative_gap" href="#JuMP.relative_gap"><code>JuMP.relative_gap</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">relative_gap(model::Model)</code></pre><p>Return the final relative optimality gap after a call to <code>optimize!(model)</code>. Exact value depends upon implementation of MathOptInterface.RelativeGap() by the particular solver used for optimization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/objective.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.simplex_iterations" href="#JuMP.simplex_iterations"><code>JuMP.simplex_iterations</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simplex_iterations(model::Model)</code></pre><p>Gets the cumulative number of simplex iterations during the most-recent optimization.</p><p>Solvers must implement <code>MOI.SimplexIterations()</code> to use this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/JuMP.jl#L902-L908">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.barrier_iterations" href="#JuMP.barrier_iterations"><code>JuMP.barrier_iterations</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">barrier_iterations(model::Model)</code></pre><p>Gets the cumulative number of barrier iterations during the most recent optimization.</p><p>Solvers must implement <code>MOI.BarrierIterations()</code> to use this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/JuMP.jl#L913-L919">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.node_count" href="#JuMP.node_count"><code>JuMP.node_count</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">node_count(model::Model)</code></pre><p>Gets the total number of branch-and-bound nodes explored during the most recent optimization in a Mixed Integer Program.</p><p>Solvers must implement <code>MOI.NodeCount()</code> to use this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/JuMP.jl#L924-L931">source</a></section></article><h2 id="ref_conflicts"><a class="docs-heading-anchor" href="#ref_conflicts">Conflicts</a><a id="ref_conflicts-1"></a><a class="docs-heading-anchor-permalink" href="#ref_conflicts" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.compute_conflict!" href="#JuMP.compute_conflict!"><code>JuMP.compute_conflict!</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_conflict!(model::Model)</code></pre><p>Compute a conflict if the model is infeasible. If an optimizer has not been set yet (see <a href="../models/#JuMP.set_optimizer"><code>set_optimizer</code></a>), a <a href="#JuMP.NoOptimizer"><code>NoOptimizer</code></a> error is thrown.</p><p>The status of the conflict can be checked with the <code>MOI.ConflictStatus</code> model attribute. Then, the status for each constraint can be queried with the <code>MOI.ConstraintConflictStatus</code> attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/optimizer_interface.jl#L203-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.compute_conflict!" href="#MathOptInterface.compute_conflict!"><code>MathOptInterface.compute_conflict!</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_conflict!(optimizer::AbstractOptimizer)</code></pre><p>Computes a minimal subset of constraints such that the model with the other constraint removed is still infeasible.</p><p>Some solvers call a set of conflicting constraints an Irreducible Inconsistent Subsystem (IIS).</p><p>See also <a href="#MathOptInterface.ConflictStatus"><code>ConflictStatus</code></a> and <a href="#MathOptInterface.ConstraintConflictStatus"><code>ConstraintConflictStatus</code></a>.</p><p><strong>Note</strong></p><p>If the model is modified after a call to <code>compute_conflict!</code>, the implementor is not obliged to purge the conflict. Any calls to the above attributes may return values for the original conflict without a warning. Similarly, when modifying the model, the conflict can be discarded.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictStatus" href="#MathOptInterface.ConflictStatus"><code>MathOptInterface.ConflictStatus</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConflictStatus()</code></pre><p>A model attribute for the <a href="#MathOptInterface.ConflictStatusCode"><code>ConflictStatusCode</code></a> explaining why the conflict refiner stopped when computing the conflict.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictStatusCode" href="#MathOptInterface.ConflictStatusCode"><code>MathOptInterface.ConflictStatusCode</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConflictStatusCode</code></pre><p>An Enum of possible values for the <code>ConflictStatus</code> attribute. This attribute is meant to explain the reason why the conflict finder stopped executing in the most recent call to <a href="#MathOptInterface.compute_conflict!"><code>compute_conflict!</code></a>.</p><p>Possible values are:</p><ul><li><code>COMPUTE_CONFLICT_NOT_CALLED</code>: the function <a href="#MathOptInterface.compute_conflict!"><code>compute_conflict!</code></a> has not yet been called</li><li><code>NO_CONFLICT_EXISTS</code>: there is no conflict because the problem is feasible</li><li><code>NO_CONFLICT_FOUND</code>: the solver could not find a conflict</li><li><code>CONFLICT_FOUND</code>: at least one conflict could be found</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConstraintConflictStatus" href="#MathOptInterface.ConstraintConflictStatus"><code>MathOptInterface.ConstraintConflictStatus</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstraintConflictStatus()</code></pre><p>A constraint attribute indicating whether the constraint participates in the conflict. Its type is <a href="#MathOptInterface.ConflictParticipationStatusCode"><code>ConflictParticipationStatusCode</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictParticipationStatusCode" href="#MathOptInterface.ConflictParticipationStatusCode"><code>MathOptInterface.ConflictParticipationStatusCode</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConflictParticipationStatusCode</code></pre><p>An Enum of possible values for the <a href="#MathOptInterface.ConstraintConflictStatus"><code>ConstraintConflictStatus</code></a> attribute. This attribute is meant to indicate whether a given constraint participates or not in the last computed conflict.</p><p>Possible values are:</p><ul><li><code>NOT_IN_CONFLICT</code>: the constraint does not participate in the conflict</li><li><code>IN_CONFLICT</code>: the constraint participates in the conflict</li><li><code>MAYBE_IN_CONFLICT</code>: the constraint may participate in the conflict, the solver was not able to prove that the constraint can be excluded from the conflict</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.copy_conflict" href="#JuMP.copy_conflict"><code>JuMP.copy_conflict</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">copy_conflict(model::Model)</code></pre><p>Return a copy of the current conflict for the model <code>model</code> and a <a href="../models/#JuMP.ReferenceMap"><code>ReferenceMap</code></a> that can be used to obtain the variable and constraint reference of the new model corresponding to a given <code>model</code>&#39;s reference.</p><p>This is a convenience function that provides a filtering function for <a href="../models/#JuMP.copy_model"><code>copy_model</code></a>.</p><p><strong>Note</strong></p><p>Model copy is not supported in <code>DIRECT</code> mode, i.e. when a model is constructed using the <a href="../models/#JuMP.direct_model"><code>direct_model</code></a> constructor instead of the <a href="../models/#JuMP.Model"><code>Model</code></a> constructor. Moreover, independently on whether an optimizer was provided at model construction, the new model will have no optimizer, i.e., an optimizer will have to be provided to the new model in the <a href="#JuMP.optimize!"><code>optimize!</code></a> call.</p><p><strong>Examples</strong></p><p>In the following example, a model <code>model</code> is constructed with a variable <code>x</code> and two constraints <code>cref</code> and <code>cref2</code>. This model has no solution, as the two constraints are mutually exclusive. The solver is asked to compute a conflict with <a href="#JuMP.compute_conflict!"><code>compute_conflict!</code></a>. The parts of <code>model</code> participating in the conflict are then copied into a model <code>new_model</code>.</p><pre><code class="language-julia">model = Model() # You must use a solver that supports conflict refining/IIS
# computation, like CPLEX or Gurobi
@variable(model, x)
@constraint(model, cref, x &gt;= 2)
@constraint(model, cref2, x &lt;= 1)

compute_conflict!(model)
if MOI.get(model, MOI.ConflictStatus()) != MOI.CONFLICT_FOUND
    error(&quot;No conflict could be found for an infeasible model.&quot;)
end

new_model, reference_map = copy_conflict(model)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/copy.jl#L212-L251">source</a></section></article><h2 id="Sensitivity"><a class="docs-heading-anchor" href="#Sensitivity">Sensitivity</a><a id="Sensitivity-1"></a><a class="docs-heading-anchor-permalink" href="#Sensitivity" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.lp_sensitivity_report" href="#JuMP.lp_sensitivity_report"><code>JuMP.lp_sensitivity_report</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lp_sensitivity_report(model::Model; atol::Float64 = 1e-8)::SensitivityReport</code></pre><p>Given a linear program <code>model</code> with a current optimal basis, return a <a href="#JuMP.SensitivityReport"><code>SensitivityReport</code></a> object, which maps:</p><ul><li>Every variable reference to a tuple <code>(d_lo, d_hi)::Tuple{Float64,Float64}</code>, explaining how much the objective coefficient of the corresponding variable can change by, such that the original basis remains optimal.</li><li>Every constraint reference to a tuple <code>(d_lo, d_hi)::Tuple{Float64,Float64}</code>, explaining how much the right-hand side of the corresponding constraint can change by, such that the basis remains optimal.</li></ul><p>Both tuples are relative, rather than absolute. So given a objective coefficient of <code>1.0</code> and a tuple <code>(-0.5, 0.5)</code>, the objective coefficient can range between <code>1.0 - 0.5</code> an <code>1.0 + 0.5</code>.</p><p><code>atol</code> is the primal/dual optimality tolerance, and should match the tolerance of the solver used to compute the basis.</p><p>Note: interval constraints are NOT supported.</p><p><strong>Example</strong></p><pre><code class="language-none">model = Model(GLPK.Optimizer)
@variable(model, -1 &lt;= x &lt;= 2)
@objective(model, Min, x)
optimize!(model)
report = lp_sensitivity_report(model; atol = 1e-7)
dx_lo, dx_hi = report[x]
println(
    &quot;The objective coefficient of `x` can decrease by $dx_lo or &quot; *
    &quot;increase by $dx_hi.&quot;
)
c = LowerBoundRef(x)
dRHS_lo, dRHS_hi = report[c]
println(
    &quot;The lower bound of `x` can decrease by $dRHS_lo or increase &quot; *
    &quot;by $dRHS_hi.&quot;
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/lp_sensitivity2.jl#L22-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.SensitivityReport" href="#JuMP.SensitivityReport"><code>JuMP.SensitivityReport</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SensitivityReport</code></pre><p>See <a href="#JuMP.lp_sensitivity_report"><code>lp_sensitivity_report</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/lp_sensitivity2.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lp_objective_perturbation_range" href="#JuMP.lp_objective_perturbation_range"><code>JuMP.lp_objective_perturbation_range</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lp_objective_perturbation_range(var::VariableRef;
                                optimality_tolerance::Float64)
                                ::Tuple{Float64, Float64}</code></pre><p>Gives the range by which the cost coefficient can change and the current LP basis remains optimal, i.e., the reduced costs remain valid.</p><p><strong>Notes</strong></p><ul><li>The range denotes valid changes, Î â [l, u], for which cost[var] += Î do not violate the current optimality conditions.</li><li><code>optimality_tolerance</code> is the dual feasibility tolerance, this should preferably match the tolerance used by the solver. The default tolerance should however apply in most situations (c.f. &quot;Computational Techniques of the Simplex Method&quot; by IstvÃ¡n Maros, section 9.3.4).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/lp_sensitivity.jl#L314-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lp_rhs_perturbation_range" href="#JuMP.lp_rhs_perturbation_range"><code>JuMP.lp_rhs_perturbation_range</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lp_rhs_perturbation_range(constraint::ConstraintRef;
                          feasibility_tolerance::Float64)
                          ::Tuple{Float64, Float64}</code></pre><p>Gives the range by which the rhs coefficient can change and the current LP basis remains feasible, i.e., where the shadow prices apply.</p><p><strong>Notes</strong></p><ul><li>The rhs coefficient is the value right of the relation, i.e., b for the constraint when of the form a*x â¡ b, where â¡ is â¤, =, or â¥.</li><li>The range denotes valid changes, e.g., for a*x &lt;= b + Î, the LP basis remains feasible for all Î â [l, u].</li><li><code>feasibility_tolerance</code> is the primal feasibility tolerance, this should preferably match the tolerance used by the solver. The default tolerance should however apply in most situations (c.f. &quot;Computational Techniques of the Simplex Method&quot; by IstvÃ¡n Maros, section 9.3.4).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/lp_sensitivity.jl#L11-L26">source</a></section></article><h2 id="Feasibility"><a class="docs-heading-anchor" href="#Feasibility">Feasibility</a><a id="Feasibility-1"></a><a class="docs-heading-anchor-permalink" href="#Feasibility" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.primal_feasibility_report" href="#JuMP.primal_feasibility_report"><code>JuMP.primal_feasibility_report</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">primal_feasibility_report(
    model::Model,
    point::AbstractDict{VariableRef,Float64} = _last_primal_solution(model),
    atol::Float64 = 0.0,
    skip_missing::Bool = false,
)::Dict{Any,Float64}</code></pre><p>Given a dictionary <code>point</code>, which maps variables to primal values, return a dictionary whose keys are the constraints with an infeasibility greater than the supplied tolerance <code>atol</code>. The value corresponding to each key is the respective infeasibility. Infeasibility is defined as the distance between the primal value of the constraint (see <code>MOI.ConstraintPrimal</code>) and the nearest point by Euclidean distance in the corresponding set.</p><p><strong>Notes</strong></p><ul><li>If <code>skip_missing = true</code>, constraints containing variables that are not in <code>point</code> will be ignored.</li><li>If <code>skip_missing = false</code> and a partial primal solution is provided, an error will be thrown.</li><li>If no point is provided, the primal solution from the last time the model was solved is used.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, 0.5 &lt;= x &lt;= 1);

julia&gt; primal_feasibility_report(model, Dict(x =&gt; 0.2))
Dict{Any,Float64} with 1 entry:
  x â¥ 0.5 =&gt; 0.3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/JuMP.jl/blob/4f6abf80016fc5e07e4e85da84ae2f93396fa4a2/src/feasibility_checker.jl#L18-L53">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../containers/">Â« Containers</a><a class="docs-footer-nextpage" href="../nlp/">Nonlinear Modeling Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 8 May 2021 23:27">Saturday 8 May 2021</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
