<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Transitioning from MATLAB · JuMP</title><meta name="title" content="Transitioning from MATLAB · JuMP"/><meta property="og:title" content="Transitioning from MATLAB · JuMP"/><meta property="twitter:title" content="Transitioning from MATLAB · JuMP"/><meta name="description" content="Documentation for JuMP."/><meta property="og:description" content="Documentation for JuMP."/><meta property="twitter:description" content="Documentation for JuMP."/><script async src="https://www.googletagmanager.com/gtag/js?id=G-0RZ8X3D3D0"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-0RZ8X3D3D0', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/extra_styles.css" rel="stylesheet" type="text/css"/><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img class="docs-light-only" src="../../../assets/logo.svg" alt="JuMP logo"/><img class="docs-dark-only" src="../../../assets/logo-dark.svg" alt="JuMP logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../">Introduction</a></li><li><a class="tocitem" href="../../../should_i_use/">Should you use JuMP?</a></li><li><a class="tocitem" href="../../../installation/">Installation Guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../getting_started/introduction/">Introduction</a></li><li><a class="tocitem" href="../../getting_started/getting_started_with_julia/">Getting started with Julia</a></li><li><a class="tocitem" href="../../getting_started/getting_started_with_JuMP/">Getting started with JuMP</a></li><li><a class="tocitem" href="../../getting_started/getting_started_with_sets_and_indexing/">Getting started with sets and indexing</a></li><li><a class="tocitem" href="../../getting_started/getting_started_with_data_and_plotting/">Getting started with data and plotting</a></li><li><a class="tocitem" href="../../getting_started/debugging/">Debugging</a></li><li><a class="tocitem" href="../../getting_started/design_patterns_for_larger_models/">Design patterns for larger models</a></li><li><a class="tocitem" href="../../getting_started/performance_tips/">Performance tips</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Transitioning</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Transitioning from MATLAB</a><ul class="internal"><li><a class="tocitem" href="#Namespaces"><span>Namespaces</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Variables"><span>Variables</span></a></li><li><a class="tocitem" href="#matlab_constraints"><span>Constraints</span></a></li><li><a class="tocitem" href="#Setting-the-objective"><span>Setting the objective</span></a></li><li><a class="tocitem" href="#Setting-solver-and-options"><span>Setting solver and options</span></a></li><li><a class="tocitem" href="#Optimizing"><span>Optimizing</span></a></li><li><a class="tocitem" href="#Querying-solution-status"><span>Querying solution status</span></a></li><li><a class="tocitem" href="#Extracting-variables"><span>Extracting variables</span></a></li><li><a class="tocitem" href="#Dual-variables"><span>Dual variables</span></a></li><li><a class="tocitem" href="#Reformulating-problems"><span>Reformulating problems</span></a></li><li><a class="tocitem" href="#Vectorization"><span>Vectorization</span></a></li><li><a class="tocitem" href="#Symmetric-and-Hermitian-matrices"><span>Symmetric and Hermitian matrices</span></a></li><li><a class="tocitem" href="#Primal-versus-dual-form"><span>Primal versus dual form</span></a></li><li><a class="tocitem" href="#Rosetta-stone"><span>Rosetta stone</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Linear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../linear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../linear/knapsack/">The knapsack problem example</a></li><li><a class="tocitem" href="../../linear/diet/">The diet problem</a></li><li><a class="tocitem" href="../../linear/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../../linear/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../../linear/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../../linear/multi_commodity_network/">The network multi-commodity flow problem</a></li><li><a class="tocitem" href="../../linear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../linear/piecewise_linear/">Approximating nonlinear functions</a></li><li><a class="tocitem" href="../../linear/facility_location/">The facility location problem</a></li><li><a class="tocitem" href="../../linear/finance/">Financial modeling problems</a></li><li><a class="tocitem" href="../../linear/geographic_clustering/">Geographical clustering</a></li><li><a class="tocitem" href="../../linear/network_flows/">Network flow problems</a></li><li><a class="tocitem" href="../../linear/transp/">The transportation problem</a></li><li><a class="tocitem" href="../../linear/multi_objective_knapsack/">Multi-objective knapsack</a></li><li><a class="tocitem" href="../../linear/multi_objective_examples/">Simple multi-objective examples</a></li><li><a class="tocitem" href="../../linear/sudoku/">Sudoku</a></li><li><a class="tocitem" href="../../linear/n-queens/">N-Queens</a></li><li><a class="tocitem" href="../../linear/constraint_programming/">Constraint programming</a></li><li><a class="tocitem" href="../../linear/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../linear/lp_sensitivity/">Sensitivity analysis of a linear program</a></li><li><a class="tocitem" href="../../linear/basis/">Basis matrices</a></li><li><a class="tocitem" href="../../linear/mip_duality/">Computing the duals of a mixed-integer program</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Nonlinear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../nonlinear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../nonlinear/simple_examples/">Simple examples</a></li><li><a class="tocitem" href="../../nonlinear/portfolio/">Portfolio optimization</a></li><li><a class="tocitem" href="../../nonlinear/rocket_control/">Rocket Control</a></li><li><a class="tocitem" href="../../nonlinear/space_shuttle_reentry_trajectory/">Optimal control for a Space Shuttle reentry trajectory</a></li><li><a class="tocitem" href="../../nonlinear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../nonlinear/user_defined_hessians/">User-defined Hessians</a></li><li><a class="tocitem" href="../../nonlinear/nested_problems/">Nested optimization problems</a></li><li><a class="tocitem" href="../../nonlinear/querying_hessians/">Computing Hessians</a></li><li><a class="tocitem" href="../../nonlinear/complementarity/">Mixed complementarity problems</a></li><li><a class="tocitem" href="../../nonlinear/classifiers/">Classifiers</a></li><li><a class="tocitem" href="../../nonlinear/operator_ad/">Automatic differentiation of user-defined operators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Conic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../conic/introduction/">Introduction</a></li><li><a class="tocitem" href="../../conic/start_values/">Primal and dual warm-starts</a></li><li><a class="tocitem" href="../../conic/tips_and_tricks/">Tips and Tricks</a></li><li><a class="tocitem" href="../../conic/simple_examples/">Simple semidefinite programming examples</a></li><li><a class="tocitem" href="../../conic/dualization/">Dualization</a></li><li><a class="tocitem" href="../../conic/arbitrary_precision/">Arbitrary precision arithmetic</a></li><li><a class="tocitem" href="../../conic/logistic_regression/">Logistic regression</a></li><li><a class="tocitem" href="../../conic/experiment_design/">Experiment design</a></li><li><a class="tocitem" href="../../conic/min_ellipse/">Minimal ellipses</a></li><li><a class="tocitem" href="../../conic/ellipse_approx/">Ellipsoid approximation</a></li><li><a class="tocitem" href="../../conic/quantum_discrimination/">Quantum state discrimination</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../algorithms/benders_decomposition/">Benders decomposition</a></li><li><a class="tocitem" href="../../algorithms/cutting_stock_column_generation/">Column generation</a></li><li><a class="tocitem" href="../../algorithms/tsp_lazy_constraints/">Traveling Salesperson Problem</a></li><li><a class="tocitem" href="../../algorithms/parallelism/">Parallelism</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-7" type="checkbox"/><label class="tocitem" for="menuitem-2-7"><span class="docs-label">Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/power_systems/">Power Systems</a></li><li><a class="tocitem" href="../../applications/optimal_power_flow/">Optimal power flow</a></li><li><a class="tocitem" href="../../applications/web_app/">Serving web apps</a></li><li><a class="tocitem" href="../../applications/two_stage_stochastic/">Two-stage stochastic programs</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../manual/models/">Models</a></li><li><a class="tocitem" href="../../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../manual/expressions/">Expressions</a></li><li><a class="tocitem" href="../../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../../manual/containers/">Containers</a></li><li><a class="tocitem" href="../../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../manual/callbacks/">Solver-independent Callbacks</a></li><li><a class="tocitem" href="../../../manual/complex/">Complex number support</a></li><li><a class="tocitem" href="../../../manual/nonlinear/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../../manual/nlp/">Nonlinear Modeling (Legacy)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../api/JuMP/">JuMP</a></li><li><a class="tocitem" href="../../../api/JuMP.Containers/">JuMP.Containers</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Background Information</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../background/algebraic_modeling_languages/">Algebraic modeling languages</a></li><li><a class="tocitem" href="../../../background/bibliography/">Bibliography</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../developers/contributing/">Contributing</a></li><li><a class="tocitem" href="../../../developers/extensions/">Extensions</a></li><li><a class="tocitem" href="../../../developers/custom_solver_binaries/">Custom binaries</a></li><li><a class="tocitem" href="../../../developers/style/">Style Guide</a></li><li><a class="tocitem" href="../../../developers/roadmap/">Roadmap</a></li><li><a class="tocitem" href="../../../developers/checklists/">Checklists</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../packages/solvers/">Introduction</a></li><li><a class="tocitem" href="../../../packages/AmplNLWriter/">jump-dev/AmplNLWriter.jl</a></li><li><a class="tocitem" href="../../../packages/BARON/">jump-dev/BARON.jl</a></li><li><a class="tocitem" href="../../../packages/CPLEX/">jump-dev/CPLEX.jl</a></li><li><a class="tocitem" href="../../../packages/CSDP/">jump-dev/CSDP.jl</a></li><li><a class="tocitem" href="../../../packages/Cbc/">jump-dev/Cbc.jl</a></li><li><a class="tocitem" href="../../../packages/Clp/">jump-dev/Clp.jl</a></li><li><a class="tocitem" href="../../../packages/Dualization/">jump-dev/Dualization.jl</a></li><li><a class="tocitem" href="../../../packages/ECOS/">jump-dev/ECOS.jl</a></li><li><a class="tocitem" href="../../../packages/GLPK/">jump-dev/GLPK.jl</a></li><li><a class="tocitem" href="../../../packages/Gurobi/">jump-dev/Gurobi.jl</a></li><li><a class="tocitem" href="../../../packages/HiGHS/">jump-dev/HiGHS.jl</a></li><li><a class="tocitem" href="../../../packages/Hypatia/">jump-dev/Hypatia.jl</a></li><li><a class="tocitem" href="../../../packages/Ipopt/">jump-dev/Ipopt.jl</a></li><li><a class="tocitem" href="../../../packages/KNITRO/">jump-dev/KNITRO.jl</a></li><li><a class="tocitem" href="../../../packages/MiniZinc/">jump-dev/MiniZinc.jl</a></li><li><a class="tocitem" href="../../../packages/MosekTools/">jump-dev/MosekTools.jl</a></li><li><a class="tocitem" href="../../../packages/MultiObjectiveAlgorithms/">jump-dev/MultiObjectiveAlgorithms.jl</a></li><li><a class="tocitem" href="../../../packages/Pajarito/">jump-dev/Pajarito.jl</a></li><li><a class="tocitem" href="../../../packages/Pavito/">jump-dev/Pavito.jl</a></li><li><a class="tocitem" href="../../../packages/SCS/">jump-dev/SCS.jl</a></li><li><a class="tocitem" href="../../../packages/SDPA/">jump-dev/SDPA.jl</a></li><li><a class="tocitem" href="../../../packages/SDPLR/">jump-dev/SDPLR.jl</a></li><li><a class="tocitem" href="../../../packages/SDPNAL/">jump-dev/SDPNAL.jl</a></li><li><a class="tocitem" href="../../../packages/SDPT3/">jump-dev/SDPT3.jl</a></li><li><a class="tocitem" href="../../../packages/SeDuMi/">jump-dev/SeDuMi.jl</a></li><li><a class="tocitem" href="../../../packages/Xpress/">jump-dev/Xpress.jl</a></li><li><a class="tocitem" href="../../../packages/COPT/">COPT-Public/COPT.jl</a></li><li><a class="tocitem" href="../../../packages/GAMS/">GAMS-dev/GAMS.jl</a></li><li><a class="tocitem" href="../../../packages/Manopt/">JuliaManifolds/Manopt.jl</a></li><li><a class="tocitem" href="../../../packages/Optim/">JuliaNLSolvers/Optim.jl</a></li><li><a class="tocitem" href="../../../packages/NLopt/">JuliaOpt/NLopt.jl</a></li><li><a class="tocitem" href="../../../packages/CDDLib/">JuliaPolyhedra/CDDLib.jl</a></li><li><a class="tocitem" href="../../../packages/Percival/">JuliaSmoothOptimizers/Percival.jl</a></li><li><a class="tocitem" href="../../../packages/MAiNGO/">MAiNGO-github/MAiNGO.jl</a></li><li><a class="tocitem" href="../../../packages/MadNLP/">MadNLP/MadNLP.jl</a></li><li><a class="tocitem" href="../../../packages/EAGO/">PSORLab/EAGO.jl</a></li><li><a class="tocitem" href="../../../packages/PATHSolver/">chkwon/PATHSolver.jl</a></li><li><a class="tocitem" href="../../../packages/DAQP/">darnstrom/DAQP.jl</a></li><li><a class="tocitem" href="../../../packages/Tulip/">ds4dm/Tulip.jl</a></li><li><a class="tocitem" href="../../../packages/Loraine/">kocvara/Loraine.jl</a></li><li><a class="tocitem" href="../../../packages/Alpine/">lanl-ansi/Alpine.jl</a></li><li><a class="tocitem" href="../../../packages/Juniper/">lanl-ansi/Juniper.jl</a></li><li><a class="tocitem" href="../../../packages/ProxSDP/">mariohsouto/ProxSDP.jl</a></li><li><a class="tocitem" href="../../../packages/NEOSServer/">odow/NEOSServer.jl</a></li><li><a class="tocitem" href="../../../packages/OSQP/">osqp/OSQP.jl</a></li><li><a class="tocitem" href="../../../packages/CDCS/">oxfordcontrol/CDCS.jl</a></li><li><a class="tocitem" href="../../../packages/COSMO/">oxfordcontrol/COSMO.jl</a></li><li><a class="tocitem" href="../../../packages/Clarabel/">oxfordcontrol/Clarabel.jl</a></li><li><a class="tocitem" href="../../../packages/SCIP/">scipopt/SCIP.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Extensions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../extensions/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../packages/DiffOpt/">jump-dev/DiffOpt.jl</a></li><li><a class="tocitem" href="../../../packages/ParametricOptInterface/">jump-dev/ParametricOptInterface.jl</a></li><li><a class="tocitem" href="../../../packages/PolyJuMP/">jump-dev/PolyJuMP.jl</a></li><li><a class="tocitem" href="../../../packages/SumOfSquares/">jump-dev/SumOfSquares.jl</a></li><li><a class="tocitem" href="../../../packages/DisjunctiveProgramming/">hdavid16/DisjunctiveProgramming.jl</a></li><li><a class="tocitem" href="../../../packages/InfiniteOpt/">infiniteopt/InfiniteOpt.jl</a></li><li><a class="tocitem" href="../../../packages/BilevelJuMP/">joaquimg/BilevelJuMP.jl</a></li><li><a class="tocitem" href="../../../packages/SDDP/">odow/SDDP.jl</a></li><li><a class="tocitem" href="../../../packages/Plasmo/">plasmo-dev/Plasmo.jl</a></li><li><a class="tocitem" href="../../../extensions/DimensionalData/">rafaqz/DimensionalData.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">MathOptInterface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-1" type="checkbox"/><label class="tocitem" for="menuitem-9-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/">Introduction</a></li><li><a class="tocitem" href="../../../moi/background/motivation/">Motivation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-2" type="checkbox"/><label class="tocitem" for="menuitem-9-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/tutorials/example/">Solving a problem using MathOptInterface</a></li><li><a class="tocitem" href="../../../moi/tutorials/implementing/">Implementing a solver interface</a></li><li><a class="tocitem" href="../../../moi/tutorials/mathprogbase/">Transitioning from MathProgBase</a></li><li><a class="tocitem" href="../../../moi/tutorials/bridging_constraint/">Implementing a constraint bridge</a></li><li><a class="tocitem" href="../../../moi/tutorials/manipulating_expressions/">Manipulating expressions</a></li><li><a class="tocitem" href="../../../moi/tutorials/latency/">Latency</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-3" type="checkbox"/><label class="tocitem" for="menuitem-9-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/manual/standard_form/">Standard form problem</a></li><li><a class="tocitem" href="../../../moi/manual/models/">Models</a></li><li><a class="tocitem" href="../../../moi/manual/variables/">Variables</a></li><li><a class="tocitem" href="../../../moi/manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../moi/manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../moi/manual/modification/">Problem modification</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-4" type="checkbox"/><label class="tocitem" for="menuitem-9-4"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/background/duality/">Duality</a></li><li><a class="tocitem" href="../../../moi/background/infeasibility_certificates/">Infeasibility certificates</a></li><li><a class="tocitem" href="../../../moi/background/naming_conventions/">Naming conventions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-5" type="checkbox"/><label class="tocitem" for="menuitem-9-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/reference/standard_form/">Standard form</a></li><li><a class="tocitem" href="../../../moi/reference/models/">Models</a></li><li><a class="tocitem" href="../../../moi/reference/variables/">Variables</a></li><li><a class="tocitem" href="../../../moi/reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../moi/reference/modification/">Modifications</a></li><li><a class="tocitem" href="../../../moi/reference/nonlinear/">Nonlinear programming</a></li><li><a class="tocitem" href="../../../moi/reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../moi/reference/errors/">Errors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-6-1" type="checkbox"/><label class="tocitem" for="menuitem-9-6-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/submodules/Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../../moi/submodules/Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-2" type="checkbox"/><label class="tocitem" for="menuitem-9-6-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/submodules/Bridges/overview/">Overview</a></li><li><a class="tocitem" href="../../../moi/submodules/Bridges/implementation/">Implementation</a></li><li><a class="tocitem" href="../../../moi/submodules/Bridges/list_of_bridges/">List of bridges</a></li><li><a class="tocitem" href="../../../moi/submodules/Bridges/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-3" type="checkbox"/><label class="tocitem" for="menuitem-9-6-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/submodules/FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../../moi/submodules/FileFormats/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-4" type="checkbox"/><label class="tocitem" for="menuitem-9-6-4"><span class="docs-label">Nonlinear</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/submodules/Nonlinear/overview/">Overview</a></li><li><a class="tocitem" href="../../../moi/submodules/Nonlinear/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-5" type="checkbox"/><label class="tocitem" for="menuitem-9-6-5"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/submodules/Utilities/overview/">Overview</a></li><li><a class="tocitem" href="../../../moi/submodules/Utilities/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6-6"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/submodules/Test/overview/">Overview</a></li><li><a class="tocitem" href="../../../moi/submodules/Test/reference/">API Reference</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../moi/developer/checklists/">Checklists</a></li></ul></li><li><a class="tocitem" href="../../../moi/release_notes/">Release notes</a></li></ul></li><li><a class="tocitem" href="../../../release_notes/">Release notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li><a class="is-disabled">Transitioning</a></li><li class="is-active"><a href>Transitioning from MATLAB</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Transitioning from MATLAB</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/transitioning/transitioning_from_matlab.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Transitioning-from-MATLAB"><a class="docs-heading-anchor" href="#Transitioning-from-MATLAB">Transitioning from MATLAB</a><a id="Transitioning-from-MATLAB-1"></a><a class="docs-heading-anchor-permalink" href="#Transitioning-from-MATLAB" title="Permalink"></a></h1><p><em>This tutorial was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em> <a href="../transitioning_from_matlab.jl"><em>Download the source as a <code>.jl</code> file</em></a>.</p><p><a href="https://yalmip.github.io/">YALMIP</a> and <a href="https://cvxr.com/cvx/">CVX</a> are two packages for mathematical optimization in <a href="https://mathworks.com/products/matlab.html">MATLAB®</a>. They are independently developed and are in no way affiliated with JuMP.</p><p>The purpose of this tutorial is to help new users to JuMP who have previously used YALMIP or CVX by comparing and contrasting their different features.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If you have not used Julia before, read the <a href="../../getting_started/getting_started_with_julia/#Getting-started-with-Julia">Getting started with Julia</a> tutorial.</p></div></div><h2 id="Namespaces"><a class="docs-heading-anchor" href="#Namespaces">Namespaces</a><a id="Namespaces-1"></a><a class="docs-heading-anchor-permalink" href="#Namespaces" title="Permalink"></a></h2><p>Julia has namespaces, which MATLAB lacks. Therefore one needs to either use the command:</p><pre><code class="language-julia hljs">using JuMP</code></pre><p>in order bring all names exported by JuMP into scope, or:</p><pre><code class="language-julia hljs">import JuMP</code></pre><p>in order to merely make the JuMP package available. <code>import</code> requires prefixing everything you use from JuMP with <code>JuMP.</code>. In this tutorial we use the former.</p><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><p>YALMIP and CVX have a single, implicit optimization model that you build by defining variables and constraints.</p><p>In JuMP, we create an explicit model first, and then, when you declare variables, constraints, or the objective function, you specify to which model they are being added.</p><p>Create a new JuMP model with the command:</p><pre><code class="language-julia hljs">model = Model()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre><h2 id="Variables"><a class="docs-heading-anchor" href="#Variables">Variables</a><a id="Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Variables" title="Permalink"></a></h2><p>In most cases there is a direct translation between variable declarations. The following table shows some common examples:</p><table><tr><th style="text-align: left">JuMP</th><th style="text-align: left">YALMIP</th><th style="text-align: left">CVX</th></tr><tr><td style="text-align: left"><code>@variable(model, x)</code></td><td style="text-align: left"><code>x = sdpvar</code></td><td style="text-align: left"><code>variable x</code></td></tr><tr><td style="text-align: left"><code>@variable(model, x, Int)</code></td><td style="text-align: left"><code>x = intvar</code></td><td style="text-align: left"><code>variable x integer</code></td></tr><tr><td style="text-align: left"><code>@variable(model, x, Bin)</code></td><td style="text-align: left"><code>x = binvar</code></td><td style="text-align: left"><code>variable x binary</code></td></tr><tr><td style="text-align: left"><code>@variable(model, v[1:d])</code></td><td style="text-align: left"><code>v = sdpvar(d, 1)</code></td><td style="text-align: left"><code>variable v(d)</code></td></tr><tr><td style="text-align: left"><code>@variable(model, m[1:d, 1:d])</code></td><td style="text-align: left"><code>m = sdpvar(d,d,&#39;full&#39;)</code></td><td style="text-align: left"><code>variable m(d, d)</code></td></tr><tr><td style="text-align: left"><code>@variable(model, m[1:d, 1:d] in ComplexPlane())</code></td><td style="text-align: left"><code>m = sdpvar(d,d,&#39;full&#39;,&#39;complex&#39;)</code></td><td style="text-align: left"><code>variable m(d,d) complex</code></td></tr><tr><td style="text-align: left"><code>@variable(model, m[1:d, 1:d], Symmetric)</code></td><td style="text-align: left"><code>m = sdpvar(d)</code></td><td style="text-align: left"><code>variable m(d,d) symmetric</code></td></tr><tr><td style="text-align: left"><code>@variable(model, m[1:d, 1:d], Hermitian)</code></td><td style="text-align: left"><code>m = sdpvar(d,d,&#39;hermitian&#39;,&#39;complex&#39;)</code></td><td style="text-align: left"><code>variable m(d,d) hermitian</code></td></tr></table><p>Like CVX, but unlike YALMIP, JuMP can also constrain variables upon creation:</p><table><tr><th style="text-align: left">JuMP</th><th style="text-align: left">CVX</th></tr><tr><td style="text-align: left"><code>@variable(model, v[1:d] &gt;= 0)</code></td><td style="text-align: left"><code>variable v(d) nonnegative</code></td></tr><tr><td style="text-align: left"><code>@variable(model, m[1:d, 1:d], PSD)</code></td><td style="text-align: left"><code>variable m(d,d) semidefinite</code></td></tr><tr><td style="text-align: left"><code>@variable(model, m[1:d, 1:d] in PSDCone())</code></td><td style="text-align: left"><code>variable m(d,d) semidefinite</code></td></tr><tr><td style="text-align: left"><code>@variable(model, m[1:d, 1:d] in HermitianPSDCone())</code></td><td style="text-align: left"><code>variable m(d,d) complex semidefinite</code></td></tr></table><p>JuMP can additionally set variable bounds, which may be handled more efficiently by a solver than an equivalent linear constraint. For example:</p><pre><code class="language-julia hljs">@variable(model, -1 &lt;= x[i in 1:3] &lt;= i)
upper_bound.(x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
 1.0
 2.0
 3.0</code></pre><p>A more interesting case is when you want to declare, for example, <code>n</code> real symmetric matrices. Both YALMIP and CVX allow you to put the matrices as the slices of a 3-dimensional array, via the commands <code>m = sdpvar(d, d, n)</code> and <code>variable m(d, d, n) symmetric</code>, respectively. With JuMP this is not possible. Instead, to achieve the same result one needs to declare a vector of <code>n</code> matrices:</p><pre><code class="language-julia hljs">d, n = 3, 2
m = [@variable(model, [1:d, 1:d], Symmetric) for _ in 1:n]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}}:
 [_[4] _[5] _[7]; _[5] _[6] _[8]; _[7] _[8] _[9]]
 [_[10] _[11] _[13]; _[11] _[12] _[14]; _[13] _[14] _[15]]</code></pre><pre><code class="language-julia hljs">m[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:
 _[4]  _[5]  _[7]
 _[5]  _[6]  _[8]
 _[7]  _[8]  _[9]</code></pre><pre><code class="language-julia hljs">m[2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 LinearAlgebra.Symmetric{VariableRef, Matrix{VariableRef}}:
 _[10]  _[11]  _[13]
 _[11]  _[12]  _[14]
 _[13]  _[14]  _[15]</code></pre><p>The analogous construct in MATLAB would be a cell array containing the optimization variables, which every discerning programmer avoids as cell arrays are rather slow. This is not a problem in Julia: a vector of matrices is almost as fast as a 3-dimensional array.</p><h2 id="matlab_constraints"><a class="docs-heading-anchor" href="#matlab_constraints">Constraints</a><a id="matlab_constraints-1"></a><a class="docs-heading-anchor-permalink" href="#matlab_constraints" title="Permalink"></a></h2><p>As in the case of variables, in most cases there is a direct translation between the packages:</p><table><tr><th style="text-align: left">JuMP</th><th style="text-align: left">YALMIP</th><th style="text-align: left">CVX</th></tr><tr><td style="text-align: left"><code>@constraint(model, v == c)</code></td><td style="text-align: left"><code>v == c</code></td><td style="text-align: left"><code>v == c</code></td></tr><tr><td style="text-align: left"><code>@constraint(model, v &gt;= 0)</code></td><td style="text-align: left"><code>v &gt;= 0</code></td><td style="text-align: left"><code>v &gt;= 0</code></td></tr><tr><td style="text-align: left"><code>@constraint(model, m &gt;= 0, PSDCone())</code></td><td style="text-align: left"><code>m &gt;= 0</code></td><td style="text-align: left"><code>m == semidefinite(length(m))</code></td></tr><tr><td style="text-align: left"><code>@constraint(model, m &gt;= 0, HermitianPSDCone())</code></td><td style="text-align: left"><code>m &gt;= 0</code></td><td style="text-align: left"><code>m == hermitian_semidefinite(length(m))</code></td></tr><tr><td style="text-align: left"><code>@constraint(model, [t; v] in SecondOrderCone())</code></td><td style="text-align: left"><code>cone(v, t)</code></td><td style="text-align: left"><code>{v, t} == lorentz(length(v))</code></td></tr><tr><td style="text-align: left"><code>@constraint(model, [x, y, z] in MOI.ExponentialCone())</code></td><td style="text-align: left"><code>expcone([x, y, z])</code></td><td style="text-align: left"><code>{x, y, z} == exponential(1)</code></td></tr></table><p>A subtlety appears when declaring equality constraints for matrices. In general, JuMP uses <code>@constraint(model, m .== c)</code>, with the dot meaning broadcasting in Julia, except when <code>m</code> is <code>Symmetric</code> or <code>Hermitian</code>: in this case <code>@constraint(model, m == c)</code> is allowed, and is much better, as JuMP is smart enough to not generate redundant constraints for the lower diagonal and the imaginary part of the diagonal (in the complex case). Both YALMIP and CVX are also smart enough to do this and the syntax is always just <code>m == c</code>.</p><p>Experienced YALMIP users will probably be relieved to see that you must pass <code>PSDCone()</code> or <code>HermitianPSDCone()</code> to make a matrix positive semidefinite, as the <code>&gt;=</code> ambiguity in YALMIP is common source of bugs.</p><h2 id="Setting-the-objective"><a class="docs-heading-anchor" href="#Setting-the-objective">Setting the objective</a><a id="Setting-the-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-the-objective" title="Permalink"></a></h2><p>Like CVX, but unlike YALMIP, JuMP has a specific command for setting an objective function:</p><pre><code class="language-julia hljs">@objective(model, Min, sum(i * x[i] for i in 1:3))</code></pre><p class="math-container">\[ x_{1} + 2 x_{2} + 3 x_{3} \]</p><p>Here the third argument is any expression you want to optimize, and <code>Min</code> is an objective sense (the other possibility is <code>Max</code>).</p><h2 id="Setting-solver-and-options"><a class="docs-heading-anchor" href="#Setting-solver-and-options">Setting solver and options</a><a id="Setting-solver-and-options-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-solver-and-options" title="Permalink"></a></h2><p>In order to set an optimizer with JuMP, do:</p><pre><code class="language-julia hljs">import Clarabel
set_optimizer(model, Clarabel.Optimizer)</code></pre><p>where &quot;Clarabel&quot; is an example solver. See the list of <a href="../../../installation/#Supported-solvers">Supported solvers</a> for other choices.</p><p>To configure the solver options you use the command:</p><pre><code class="language-julia hljs">set_attribute(model, &quot;verbose&quot;, true)</code></pre><p>where <code>verbose</code> is an option specific to Clarabel.</p><p>A crucial difference is that with JuMP you must explicitly choose a solver before optimizing. Both YALMIP and CVX allow you to leave it empty and will try to guess an appropriate solver for the problem.</p><h2 id="Optimizing"><a class="docs-heading-anchor" href="#Optimizing">Optimizing</a><a id="Optimizing-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing" title="Permalink"></a></h2><p>Like YALMIP, but unlike CVX, with JuMP you need to explicitly start the optimization, with the command:</p><pre><code class="language-julia hljs">optimize!(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-------------------------------------------------------------
           Clarabel.jl v0.7.1  -  Clever Acronym
                   (c) Paul Goulart
                University of Oxford, 2022
-------------------------------------------------------------

problem:
  variables     = 15
  constraints   = 6
  nnz(P)        = 0
  nnz(A)        = 6
  cones (total) = 1
    : Nonnegative = 1,  numel = 6

settings:
  linear algebra: direct / qdldl, precision: Float64
  max iter = 200, time limit = Inf,  max step = 0.990
  tol_feas = 1.0e-08, tol_gap_abs = 1.0e-08, tol_gap_rel = 1.0e-08,
  static reg : on, ϵ1 = 1.0e-08, ϵ2 = 4.9e-32
  dynamic reg: on, ϵ = 1.0e-13, δ = 2.0e-07
  iter refine: on, reltol = 1.0e-13, abstol = 1.0e-12,
               max iter = 10, stop ratio = 5.0
  equilibrate: on, min_scale = 1.0e-05, max_scale = 1.0e+05
               max iter = 10

iter    pcost        dcost       gap       pres      dres      k/t        μ       step
---------------------------------------------------------------------------------------------
  0   1.0000e+01  -1.2500e+01  2.25e+00  0.00e+00  0.00e+00  1.00e+00  3.36e+00   ------
  1   3.9744e+00  -5.5968e-01  4.53e+00  1.43e-16  1.27e-16  3.10e-01  6.92e-01  8.38e-01
  2   1.1590e-01  -1.2437e-01  2.40e-01  4.88e-17  3.27e-17  2.81e-02  3.83e-02  9.73e-01
  3   1.1746e-03  -1.2507e-03  2.43e-03  1.06e-16  7.36e-17  2.83e-04  3.87e-04  9.90e-01
  4   1.1746e-05  -1.2507e-05  2.43e-05  1.44e-16  3.68e-17  2.83e-06  3.87e-06  9.90e-01
  5   1.1746e-07  -1.2507e-07  2.43e-07  5.05e-15  4.78e-15  2.83e-08  3.87e-08  9.90e-01
  6   1.1746e-09  -1.2507e-09  2.43e-09  1.59e-16  6.59e-17  2.83e-10  3.87e-10  9.90e-01
---------------------------------------------------------------------------------------------
Terminated with status = solved
solve time = 1.25ms</code></pre><p>The exclamation mark here is a Julia-ism that means the function is modifying its argument, <code>model</code>.</p><h2 id="Querying-solution-status"><a class="docs-heading-anchor" href="#Querying-solution-status">Querying solution status</a><a id="Querying-solution-status-1"></a><a class="docs-heading-anchor-permalink" href="#Querying-solution-status" title="Permalink"></a></h2><p>After the optimization is done, you should check for the solution status to see what solution (if any) the solver found.</p><p>Like YALMIP and CVX, JuMP provides a solver-independent way to check it, via the command:</p><pre><code class="language-julia hljs">is_solved_and_feasible(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>If the return value is <code>false</code>, you should investigate with <a href="../../../api/JuMP/#termination_status"><code>termination_status</code></a>, <a href="../../../api/JuMP/#primal_status"><code>primal_status</code></a>, and <a href="../../../api/JuMP/#raw_status"><code>raw_status</code></a>, See <a href="../../../manual/solutions/#jump_solutions">Solutions</a> for more details on how to query and interpret solution statuses.</p><h2 id="Extracting-variables"><a class="docs-heading-anchor" href="#Extracting-variables">Extracting variables</a><a id="Extracting-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-variables" title="Permalink"></a></h2><p>Like YALMIP, but unlike CVX, with JuMP you need to explicitly ask for the value of your variables after optimization is done, with the function call <code>value(x)</code> to obtain the value of variable <code>x</code>.</p><pre><code class="language-julia hljs">value.(m[1][1, 1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0</code></pre><p>A subtlety is that, unlike YALMIP, the function <code>value</code> is only defined for scalars. For vectors and matrices you need to use Julia broadcasting: <code>value.(v)</code>.</p><pre><code class="language-julia hljs">value.(m[1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 Matrix{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre><p>There is also a specialized function for extracting the value of the objective, <code>objective_value(model)</code>, which is useful if your objective doesn&#39;t have a convenient expression.</p><pre><code class="language-julia hljs">objective_value(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-5.999999998825352</code></pre><h2 id="Dual-variables"><a class="docs-heading-anchor" href="#Dual-variables">Dual variables</a><a id="Dual-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Dual-variables" title="Permalink"></a></h2><p>Like YALMIP and CVX, JuMP allows you to recover the dual variables. In order to do that, the simplest method is to name the constraint you&#39;re interested in, for example, <code>@constraint(model, bob, sum(v) == 1)</code> and then, after the optimzation is done, call <code>dual(bob)</code>. See <a href="../../../moi/background/duality/#Duality">Duality</a> for more details.</p><h2 id="Reformulating-problems"><a class="docs-heading-anchor" href="#Reformulating-problems">Reformulating problems</a><a id="Reformulating-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Reformulating-problems" title="Permalink"></a></h2><p>Perhaps the biggest difference between JuMP and YALMIP and CVX is how far the package is willing to go in reformulating the problems you give to it.</p><p>CVX is happy to reformulate anything it can, even using approximations if your solver cannot handle the problem.</p><p>YALMIP will only do exact reformulations, but is still fairly adventurous, for example, being willing to reformulate a nonlinear objective in terms of conic constraints.</p><p>JuMP does no such thing: it only reformulates objectives into objectives, and constraints into constraints, and is fairly conservative at that. As a result, you might need to do some reformulations manually, for which a good guide is the <a href="../../conic/tips_and_tricks/#conic_tips_and_tricks">Tips and tricks</a> tutorial.</p><h2 id="Vectorization"><a class="docs-heading-anchor" href="#Vectorization">Vectorization</a><a id="Vectorization-1"></a><a class="docs-heading-anchor-permalink" href="#Vectorization" title="Permalink"></a></h2><p>In MATLAB, it is absolutely essential to &quot;vectorize&quot; your code to obtain acceptable performance. This is because MATLAB is a slow interpreted language, which sends your commands to fast libraries. When you &quot;vectorize&quot; your code you are minimizing the MATLAB part of the work and sending it to the fast libraries instead.</p><p>There&#39;s no such duality with Julia.</p><p>Everything you write and most libraries you use will compile down to LLVM, so &quot;vectorization&quot; has no effect.</p><p>For example, if you are writing a linear program in MATLAB and instead of the usual <code>constraints = [v &gt;= 0]</code> you write:</p><pre><code class="language-matlab hljs">for i = 1:n
   constraints = [constraints, v(i) &gt;= 0];
end</code></pre><p>performance will be poor.</p><p>With Julia, on the other hand, there is hardly any difference between</p><pre><code class="language-julia hljs">@constraint(model, v &gt;= 0)</code></pre><p>and</p><pre><code class="language-julia hljs">for i in 1:n
    @constraint(model, v[i] &gt;= 0)
end</code></pre><h2 id="Symmetric-and-Hermitian-matrices"><a class="docs-heading-anchor" href="#Symmetric-and-Hermitian-matrices">Symmetric and Hermitian matrices</a><a id="Symmetric-and-Hermitian-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetric-and-Hermitian-matrices" title="Permalink"></a></h2><p>Julia has specialized support for symmetric and Hermitian matrices in the <code>LinearAlgebra</code> package:</p><pre><code class="language-julia hljs">import LinearAlgebra</code></pre><p>If you have a matrix that is numerically symmetric:</p><pre><code class="language-julia hljs">x = [1 2; 2 3]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Int64}:
 1  2
 2  3</code></pre><pre><code class="language-julia hljs">LinearAlgebra.issymmetric(x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>then you can wrap it in a <code>LinearAlgebra.Symmetric</code> matrix to tell Julia&#39;s type system that the matrix is symmetric.</p><pre><code class="language-julia hljs">LinearAlgebra.Symmetric(x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 LinearAlgebra.Symmetric{Int64, Matrix{Int64}}:
 1  2
 2  3</code></pre><p>Using a <code>Symmetric</code> matrix lets Julia and JuMP use more efficient algorithms when they are working with symmetric matrices.</p><p>If you have a matrix that is nearly but not exactly symmetric:</p><pre><code class="language-julia hljs">x = [1.0 2.0; 2.001 3.0]
LinearAlgebra.issymmetric(x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><p>then you could, as you might do in MATLAB, make it numerically symmetric as follows:</p><pre><code class="language-julia hljs">x_sym = 0.5 * (x + x&#39;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 1.0     2.0005
 2.0005  3.0</code></pre><p>In Julia, you can explicitly choose whether to use the lower or upper triangle of the matrix:</p><pre><code class="language-julia hljs">x_sym = LinearAlgebra.Symmetric(x, :L)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 LinearAlgebra.Symmetric{Float64, Matrix{Float64}}:
 1.0    2.001
 2.001  3.0</code></pre><pre><code class="language-julia hljs">x_sym = LinearAlgebra.Symmetric(x, :U)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 LinearAlgebra.Symmetric{Float64, Matrix{Float64}}:
 1.0  2.0
 2.0  3.0</code></pre><p>The same applies for Hermitian matrices, using <code>LinearAlgebra.Hermitian</code> and <code>LinearAlgebra.ishermitian</code>.</p><h2 id="Primal-versus-dual-form"><a class="docs-heading-anchor" href="#Primal-versus-dual-form">Primal versus dual form</a><a id="Primal-versus-dual-form-1"></a><a class="docs-heading-anchor-permalink" href="#Primal-versus-dual-form" title="Permalink"></a></h2><p>When you translate some optimization problems from YALMIP or CVX to JuMP, you might be surprised to see it get much faster or much slower, even if you&#39;re using exactly the same solver. The most likely reason is that YALMIP will always interpret the problem as the dual form, whereas CVX and JuMP will try to interpret the problem in the form most appropriate to the solver. If the problem is more naturally formulated in the primal form it is likely that YALMIP&#39;s performance will suffer, or if JuMP gets it wrong, its performance will suffer. It might be worth trying both primal and dual forms if you&#39;re having trouble, which can be done automatically with the package <a href="../../../packages/Dualization/#Dualization.jl">Dualization.jl</a>.</p><p>For an in-depth explanation of this issue, see the <a href="../../conic/dualization/#Dualization">Dualization</a> tutorial.</p><h2 id="Rosetta-stone"><a class="docs-heading-anchor" href="#Rosetta-stone">Rosetta stone</a><a id="Rosetta-stone-1"></a><a class="docs-heading-anchor-permalink" href="#Rosetta-stone" title="Permalink"></a></h2><p>In this section, we show a complete example of the same optimization problem being solved with JuMP, YALMIP, and CVX. It is a semidefinite program that computes a lower bound on the random robustness of entanglement using the partial transposition criterion.</p><p>The code is complete, apart from the function that does partial transposition. With both YALMIP and CVX we use the function <code>PartialTranspose</code> from <a href="https://github.com/nathanieljohnston/QETLAB">QETLAB</a>. With JuMP, we could use the function <code>Convex.partialtranspose</code> from <a href="https://jump.dev/Convex.jl/stable/">Convex.jl</a>, but we reproduce it here for simplicity:</p><pre><code class="language-julia hljs">function partial_transpose(x::AbstractMatrix, sys::Int, dims::Vector)
    @assert size(x, 1) == size(x, 2) == prod(dims)
    @assert 1 &lt;= sys &lt;= length(dims)
    n = length(dims)
    s = n - sys + 1
    p = collect(1:2n)
    p[s], p[n+s] = n + s, s
    r = reshape(x, (reverse(dims)..., reverse(dims)...))
    return reshape(permutedims(r, p), size(x))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">partial_transpose (generic function with 1 method)</code></pre><h3 id="JuMP"><a class="docs-heading-anchor" href="#JuMP">JuMP</a><a id="JuMP-1"></a><a class="docs-heading-anchor-permalink" href="#JuMP" title="Permalink"></a></h3><p>The JuMP code to solve this problem is:</p><pre><code class="language-julia hljs">using JuMP
import Clarabel
import LinearAlgebra

function random_state_pure(d)
    x = randn(Complex{Float64}, d)
    y = x * x&#39;
    return LinearAlgebra.Hermitian(y / LinearAlgebra.tr(y))
end

function robustness_jump(d)
    rho = random_state_pure(d^2)
    id = LinearAlgebra.Hermitian(LinearAlgebra.I(d^2))
    rhoT = LinearAlgebra.Hermitian(partial_transpose(rho, 1, [d, d]))
    model = Model()
    @variable(model, λ)
    @constraint(model, PPT, rhoT + λ * id in HermitianPSDCone())
    @objective(model, Min, λ)
    set_optimizer(model, Clarabel.Optimizer)
    set_attribute(model, &quot;verbose&quot;, true)
    optimize!(model)
    if is_solved_and_feasible(model)
        WT = dual(PPT)
        return value(λ), real(LinearAlgebra.dot(WT, rhoT))
    else
        return &quot;Something went wrong: $(raw_status(model))&quot;
    end
end

robustness_jump(3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.4317497878154882, -0.4317497873162501)</code></pre><h3 id="YALMIP"><a class="docs-heading-anchor" href="#YALMIP">YALMIP</a><a id="YALMIP-1"></a><a class="docs-heading-anchor-permalink" href="#YALMIP" title="Permalink"></a></h3><p>The corresponding YALMIP code is:</p><pre><code class="language-matlab hljs">function robustness_yalmip(d)
    rho = random_state_pure(d^2);
    # PartialTranspose from https://github.com/nathanieljohnston/QETLAB
    rhoT = PartialTranspose(rho, 1, [d d]);
    lambda = sdpvar;
    constraints = [(rhoT + lambda*eye(d^2) &gt;= 0):&#39;PPT&#39;];
    ops = sdpsettings(sdpsettings, &#39;verbose&#39;, 1, &#39;solver&#39;, &#39;sedumi&#39;);
    sol = optimize(constraints, lambda, ops);
    if sol.problem == 0
        WT = dual(constraints(&#39;PPT&#39;));
        value(lambda)
        real(WT(:).&#39; * rhoT(:))
    else
        display([&#39;Something went wrong: &#39;, sol.info])
    end
end

function rho = random_state_pure(d)
    x = randn(d, 1) + 1i * randn(d, 1);
    y = x * x&#39;;
    rho = y / trace(y);
end</code></pre><h3 id="CVX"><a class="docs-heading-anchor" href="#CVX">CVX</a><a id="CVX-1"></a><a class="docs-heading-anchor-permalink" href="#CVX" title="Permalink"></a></h3><p>The corresponding CVX code is:</p><pre><code class="language-matlab hljs">function robustness_cvx(d)
    rho = random_state_pure(d^2);
    # PartialTranspose from https://github.com/nathanieljohnston/QETLAB
    rhoT = PartialTranspose(rho, 1, [d d]);
    cvx_begin
        variable lambda
        dual variable WT
        WT : rhoT + lambda * eye(d^2) == hermitian_semidefinite(d^2)
        minimise lambda
    cvx_end
    if strcmp(cvx_status, &#39;Solved&#39;)
        lambda
        real(WT(:)&#39; * rhoT(:))
    else
        display(&#39;Something went wrong.&#39;)
    end
end

function rho = random_state_pure(d)
    x = randn(d, 1) + 1i * randn(d, 1);
    y = x * x&#39;;
    rho = y / trace(y);
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../getting_started/performance_tips/">« Performance tips</a><a class="docs-footer-nextpage" href="../../linear/introduction/">Introduction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Thursday 11 April 2024 08:49">Thursday 11 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
