<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constraints · JuMP</title><meta name="title" content="Constraints · JuMP"/><meta property="og:title" content="Constraints · JuMP"/><meta property="twitter:title" content="Constraints · JuMP"/><meta name="description" content="Documentation for JuMP."/><meta property="og:description" content="Documentation for JuMP."/><meta property="twitter:description" content="Documentation for JuMP."/><script async src="https://www.googletagmanager.com/gtag/js?id=G-0RZ8X3D3D0"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-0RZ8X3D3D0', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="JuMP logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="JuMP logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../should_i_use/">Should you use JuMP?</a></li><li><a class="tocitem" href="../../installation/">Installation Guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/getting_started/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/getting_started/getting_started_with_julia/">Getting started with Julia</a></li><li><a class="tocitem" href="../../tutorials/getting_started/getting_started_with_JuMP/">Getting started with JuMP</a></li><li><a class="tocitem" href="../../tutorials/getting_started/getting_started_with_sets_and_indexing/">Getting started with sets and indexing</a></li><li><a class="tocitem" href="../../tutorials/getting_started/getting_started_with_data_and_plotting/">Getting started with data and plotting</a></li><li><a class="tocitem" href="../../tutorials/getting_started/debugging/">Debugging</a></li><li><a class="tocitem" href="../../tutorials/getting_started/design_patterns_for_larger_models/">Design patterns for larger models</a></li><li><a class="tocitem" href="../../tutorials/getting_started/performance_tips/">Performance tips</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Linear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/linear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/linear/knapsack/">The knapsack problem example</a></li><li><a class="tocitem" href="../../tutorials/linear/diet/">The diet problem</a></li><li><a class="tocitem" href="../../tutorials/linear/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../../tutorials/linear/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../../tutorials/linear/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../../tutorials/linear/multi_commodity_network/">The network multi-commodity flow problem</a></li><li><a class="tocitem" href="../../tutorials/linear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../tutorials/linear/piecewise_linear/">Approximating nonlinear functions</a></li><li><a class="tocitem" href="../../tutorials/linear/facility_location/">The facility location problem</a></li><li><a class="tocitem" href="../../tutorials/linear/finance/">Financial modeling problems</a></li><li><a class="tocitem" href="../../tutorials/linear/geographic_clustering/">Geographical clustering</a></li><li><a class="tocitem" href="../../tutorials/linear/network_flows/">Network flow problems</a></li><li><a class="tocitem" href="../../tutorials/linear/transp/">The transportation problem</a></li><li><a class="tocitem" href="../../tutorials/linear/multi_objective_knapsack/">Multi-objective knapsack</a></li><li><a class="tocitem" href="../../tutorials/linear/multi_objective_examples/">Simple multi-objective examples</a></li><li><a class="tocitem" href="../../tutorials/linear/sudoku/">Sudoku</a></li><li><a class="tocitem" href="../../tutorials/linear/n-queens/">N-Queens</a></li><li><a class="tocitem" href="../../tutorials/linear/constraint_programming/">Constraint programming</a></li><li><a class="tocitem" href="../../tutorials/linear/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../tutorials/linear/lp_sensitivity/">Sensitivity analysis of a linear program</a></li><li><a class="tocitem" href="../../tutorials/linear/mip_duality/">Computing the duals of a mixed-integer program</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Nonlinear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/nonlinear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/simple_examples/">Simple examples</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/portfolio/">Portfolio optimization</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/rocket_control/">Rocket Control</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/space_shuttle_reentry_trajectory/">Optimal control for a Space Shuttle reentry trajectory</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/user_defined_hessians/">User-defined Hessians</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/nested_problems/">Nested optimization problems</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/querying_hessians/">Computing Hessians</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/complementarity/">Mixed complementarity problems</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/classifiers/">Classifiers</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Conic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/conic/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/conic/start_values/">Primal and dual warm-starts</a></li><li><a class="tocitem" href="../../tutorials/conic/tips_and_tricks/">Tips and Tricks</a></li><li><a class="tocitem" href="../../tutorials/conic/simple_examples/">Simple semidefinite programming examples</a></li><li><a class="tocitem" href="../../tutorials/conic/dualization/">Dualization</a></li><li><a class="tocitem" href="../../tutorials/conic/arbitrary_precision/">Arbitrary precision arithmetic</a></li><li><a class="tocitem" href="../../tutorials/conic/logistic_regression/">Logistic regression</a></li><li><a class="tocitem" href="../../tutorials/conic/experiment_design/">Experiment design</a></li><li><a class="tocitem" href="../../tutorials/conic/min_ellipse/">Minimal ellipses</a></li><li><a class="tocitem" href="../../tutorials/conic/ellipse_approx/">Ellipsoid approximation</a></li><li><a class="tocitem" href="../../tutorials/conic/quantum_discrimination/">Quantum state discrimination</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/algorithms/benders_decomposition/">Benders decomposition</a></li><li><a class="tocitem" href="../../tutorials/algorithms/cutting_stock_column_generation/">Column generation</a></li><li><a class="tocitem" href="../../tutorials/algorithms/tsp_lazy_constraints/">Traveling Salesperson Problem</a></li><li><a class="tocitem" href="../../tutorials/algorithms/parallelism/">Parallelism</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/applications/power_systems/">Power Systems</a></li><li><a class="tocitem" href="../../tutorials/applications/optimal_power_flow/">Optimal power flow</a></li><li><a class="tocitem" href="../../tutorials/applications/web_app/">Serving web apps</a></li><li><a class="tocitem" href="../../tutorials/applications/two_stage_stochastic/">Two-stage stochastic programs</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../variables/">Variables</a></li><li class="is-active"><a class="tocitem" href>Constraints</a><ul class="internal"><li><a class="tocitem" href="#Add-a-constraint"><span>Add a constraint</span></a></li><li><a class="tocitem" href="#Vectorized-constraints"><span>Vectorized constraints</span></a></li><li><a class="tocitem" href="#Containers-of-constraints"><span>Containers of constraints</span></a></li><li><a class="tocitem" href="#Registered-constraints"><span>Registered constraints</span></a></li><li><a class="tocitem" href="#Anonymous-constraints"><span>Anonymous constraints</span></a></li><li><a class="tocitem" href="#Constraint-names"><span>Constraint names</span></a></li><li><a class="tocitem" href="#String-names,-symbolic-names,-and-bindings"><span>String names, symbolic names, and bindings</span></a></li><li><a class="tocitem" href="#The-@constraints-macro"><span>The <code>@constraints</code> macro</span></a></li><li><a class="tocitem" href="#constraint_duality"><span>Duality</span></a></li><li><a class="tocitem" href="#Modify-a-constant-term"><span>Modify a constant term</span></a></li><li><a class="tocitem" href="#Modify-a-variable-coefficient"><span>Modify a variable coefficient</span></a></li><li><a class="tocitem" href="#Delete-a-constraint"><span>Delete a constraint</span></a></li><li><a class="tocitem" href="#Start-values"><span>Start values</span></a></li><li><a class="tocitem" href="#Constraint-containers"><span>Constraint containers</span></a></li><li><a class="tocitem" href="#Accessing-constraints-from-a-model"><span>Accessing constraints from a model</span></a></li><li><a class="tocitem" href="#MathOptInterface-constraints"><span>MathOptInterface constraints</span></a></li><li><a class="tocitem" href="#Set-inequality-syntax"><span>Set inequality syntax</span></a></li><li><a class="tocitem" href="#Second-order-cone-constraints"><span>Second-order cone constraints</span></a></li><li><a class="tocitem" href="#Rotated-second-order-cone-constraints"><span>Rotated second-order cone constraints</span></a></li><li><a class="tocitem" href="#Special-Ordered-Sets-of-Type-1"><span>Special Ordered Sets of Type 1</span></a></li><li><a class="tocitem" href="#Special-Ordered-Sets-of-Type-2"><span>Special Ordered Sets of Type 2</span></a></li><li><a class="tocitem" href="#Indicator-constraints"><span>Indicator constraints</span></a></li><li><a class="tocitem" href="#Semidefinite-constraints"><span>Semidefinite constraints</span></a></li><li><a class="tocitem" href="#Complementarity-constraints"><span>Complementarity constraints</span></a></li><li><a class="tocitem" href="#Boolean-constraints"><span>Boolean constraints</span></a></li></ul></li><li><a class="tocitem" href="../expressions/">Expressions</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../containers/">Containers</a></li><li><a class="tocitem" href="../solutions/">Solutions</a></li><li><a class="tocitem" href="../callbacks/">Solver-independent Callbacks</a></li><li><a class="tocitem" href="../complex/">Complex number support</a></li><li><a class="tocitem" href="../nonlinear/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../nlp/">Nonlinear Modeling (Legacy)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/JuMP/">JuMP</a></li><li><a class="tocitem" href="../../api/JuMP.Containers/">JuMP.Containers</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Background Information</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/algebraic_modeling_languages/">Algebraic modeling languages</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../developers/contributing/">Contributing</a></li><li><a class="tocitem" href="../../developers/extensions/">Extensions</a></li><li><a class="tocitem" href="../../developers/custom_solver_binaries/">Custom binaries</a></li><li><a class="tocitem" href="../../developers/style/">Style Guide</a></li><li><a class="tocitem" href="../../developers/roadmap/">Roadmap</a></li><li><a class="tocitem" href="../../developers/checklists/">Checklists</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../packages/solvers/">Introduction</a></li><li><a class="tocitem" href="../../packages/AmplNLWriter/">jump-dev/AmplNLWriter.jl</a></li><li><a class="tocitem" href="../../packages/BARON/">jump-dev/BARON.jl</a></li><li><a class="tocitem" href="../../packages/CPLEX/">jump-dev/CPLEX.jl</a></li><li><a class="tocitem" href="../../packages/CSDP/">jump-dev/CSDP.jl</a></li><li><a class="tocitem" href="../../packages/Cbc/">jump-dev/Cbc.jl</a></li><li><a class="tocitem" href="../../packages/Clp/">jump-dev/Clp.jl</a></li><li><a class="tocitem" href="../../packages/Dualization/">jump-dev/Dualization.jl</a></li><li><a class="tocitem" href="../../packages/ECOS/">jump-dev/ECOS.jl</a></li><li><a class="tocitem" href="../../packages/GLPK/">jump-dev/GLPK.jl</a></li><li><a class="tocitem" href="../../packages/Gurobi/">jump-dev/Gurobi.jl</a></li><li><a class="tocitem" href="../../packages/HiGHS/">jump-dev/HiGHS.jl</a></li><li><a class="tocitem" href="../../packages/Hypatia/">jump-dev/Hypatia.jl</a></li><li><a class="tocitem" href="../../packages/Ipopt/">jump-dev/Ipopt.jl</a></li><li><a class="tocitem" href="../../packages/KNITRO/">jump-dev/KNITRO.jl</a></li><li><a class="tocitem" href="../../packages/MiniZinc/">jump-dev/MiniZinc.jl</a></li><li><a class="tocitem" href="../../packages/MosekTools/">jump-dev/MosekTools.jl</a></li><li><a class="tocitem" href="../../packages/MultiObjectiveAlgorithms/">jump-dev/MultiObjectiveAlgorithms.jl</a></li><li><a class="tocitem" href="../../packages/Pajarito/">jump-dev/Pajarito.jl</a></li><li><a class="tocitem" href="../../packages/Pavito/">jump-dev/Pavito.jl</a></li><li><a class="tocitem" href="../../packages/SCS/">jump-dev/SCS.jl</a></li><li><a class="tocitem" href="../../packages/SDPA/">jump-dev/SDPA.jl</a></li><li><a class="tocitem" href="../../packages/SDPLR/">jump-dev/SDPLR.jl</a></li><li><a class="tocitem" href="../../packages/SDPNAL/">jump-dev/SDPNAL.jl</a></li><li><a class="tocitem" href="../../packages/SDPT3/">jump-dev/SDPT3.jl</a></li><li><a class="tocitem" href="../../packages/SeDuMi/">jump-dev/SeDuMi.jl</a></li><li><a class="tocitem" href="../../packages/Xpress/">jump-dev/Xpress.jl</a></li><li><a class="tocitem" href="../../packages/COPT/">COPT-Public/COPT.jl</a></li><li><a class="tocitem" href="../../packages/GAMS/">GAMS-dev/GAMS.jl</a></li><li><a class="tocitem" href="../../packages/Manopt/">JuliaManifolds/Manopt.jl</a></li><li><a class="tocitem" href="../../packages/NLopt/">JuliaOpt/NLopt.jl</a></li><li><a class="tocitem" href="../../packages/CDDLib/">JuliaPolyhedra/CDDLib.jl</a></li><li><a class="tocitem" href="../../packages/Percival/">JuliaSmoothOptimizers/Percival.jl</a></li><li><a class="tocitem" href="../../packages/MadNLP/">MadNLP/MadNLP.jl</a></li><li><a class="tocitem" href="../../packages/EAGO/">PSORLab/EAGO.jl</a></li><li><a class="tocitem" href="../../packages/PATHSolver/">chkwon/PATHSolver.jl</a></li><li><a class="tocitem" href="../../packages/DAQP/">darnstrom/DAQP.jl</a></li><li><a class="tocitem" href="../../packages/Tulip/">ds4dm/Tulip.jl</a></li><li><a class="tocitem" href="../../packages/Loraine/">kocvara/Loraine.jl</a></li><li><a class="tocitem" href="../../packages/Alpine/">lanl-ansi/Alpine.jl</a></li><li><a class="tocitem" href="../../packages/Juniper/">lanl-ansi/Juniper.jl</a></li><li><a class="tocitem" href="../../packages/ProxSDP/">mariohsouto/ProxSDP.jl</a></li><li><a class="tocitem" href="../../packages/NEOSServer/">odow/NEOSServer.jl</a></li><li><a class="tocitem" href="../../packages/OSQP/">osqp/OSQP.jl</a></li><li><a class="tocitem" href="../../packages/CDCS/">oxfordcontrol/CDCS.jl</a></li><li><a class="tocitem" href="../../packages/COSMO/">oxfordcontrol/COSMO.jl</a></li><li><a class="tocitem" href="../../packages/Clarabel/">oxfordcontrol/Clarabel.jl</a></li><li><a class="tocitem" href="../../packages/SCIP/">scipopt/SCIP.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Extensions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../extensions/introduction/">Introduction</a></li><li><a class="tocitem" href="../../packages/DiffOpt/">jump-dev/DiffOpt.jl</a></li><li><a class="tocitem" href="../../packages/ParametricOptInterface/">jump-dev/ParametricOptInterface.jl</a></li><li><a class="tocitem" href="../../packages/PolyJuMP/">jump-dev/PolyJuMP.jl</a></li><li><a class="tocitem" href="../../packages/SumOfSquares/">jump-dev/SumOfSquares.jl</a></li><li><a class="tocitem" href="../../packages/DisjunctiveProgramming/">hdavid16/DisjunctiveProgramming.jl</a></li><li><a class="tocitem" href="../../packages/InfiniteOpt/">infiniteopt/InfiniteOpt.jl</a></li><li><a class="tocitem" href="../../packages/BilevelJuMP/">joaquimg/BilevelJuMP.jl</a></li><li><a class="tocitem" href="../../packages/SDDP/">odow/SDDP.jl</a></li><li><a class="tocitem" href="../../packages/Plasmo/">plasmo-dev/Plasmo.jl</a></li><li><a class="tocitem" href="../../extensions/DimensionalData/">rafaqz/DimensionalData.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">MathOptInterface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-1" type="checkbox"/><label class="tocitem" for="menuitem-9-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/">Introduction</a></li><li><a class="tocitem" href="../../moi/background/motivation/">Motivation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-2" type="checkbox"/><label class="tocitem" for="menuitem-9-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/tutorials/example/">Solving a problem using MathOptInterface</a></li><li><a class="tocitem" href="../../moi/tutorials/implementing/">Implementing a solver interface</a></li><li><a class="tocitem" href="../../moi/tutorials/mathprogbase/">Transitioning from MathProgBase</a></li><li><a class="tocitem" href="../../moi/tutorials/bridging_constraint/">Implementing a constraint bridge</a></li><li><a class="tocitem" href="../../moi/tutorials/manipulating_expressions/">Manipulating expressions</a></li><li><a class="tocitem" href="../../moi/tutorials/latency/">Latency</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-3" type="checkbox"/><label class="tocitem" for="menuitem-9-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/manual/standard_form/">Standard form problem</a></li><li><a class="tocitem" href="../../moi/manual/models/">Models</a></li><li><a class="tocitem" href="../../moi/manual/variables/">Variables</a></li><li><a class="tocitem" href="../../moi/manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../moi/manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../moi/manual/modification/">Problem modification</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-4" type="checkbox"/><label class="tocitem" for="menuitem-9-4"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/background/duality/">Duality</a></li><li><a class="tocitem" href="../../moi/background/infeasibility_certificates/">Infeasibility certificates</a></li><li><a class="tocitem" href="../../moi/background/naming_conventions/">Naming conventions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-5" type="checkbox"/><label class="tocitem" for="menuitem-9-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/reference/standard_form/">Standard form</a></li><li><a class="tocitem" href="../../moi/reference/models/">Models</a></li><li><a class="tocitem" href="../../moi/reference/variables/">Variables</a></li><li><a class="tocitem" href="../../moi/reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../moi/reference/modification/">Modifications</a></li><li><a class="tocitem" href="../../moi/reference/nonlinear/">Nonlinear programming</a></li><li><a class="tocitem" href="../../moi/reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../moi/reference/errors/">Errors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-6-1" type="checkbox"/><label class="tocitem" for="menuitem-9-6-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-2" type="checkbox"/><label class="tocitem" for="menuitem-9-6-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Bridges/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Bridges/implementation/">Implementation</a></li><li><a class="tocitem" href="../../moi/submodules/Bridges/list_of_bridges/">List of bridges</a></li><li><a class="tocitem" href="../../moi/submodules/Bridges/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-3" type="checkbox"/><label class="tocitem" for="menuitem-9-6-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/FileFormats/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-4" type="checkbox"/><label class="tocitem" for="menuitem-9-6-4"><span class="docs-label">Nonlinear</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Nonlinear/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Nonlinear/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-5" type="checkbox"/><label class="tocitem" for="menuitem-9-6-5"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Utilities/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Utilities/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-6-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6-6"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/submodules/Test/overview/">Overview</a></li><li><a class="tocitem" href="../../moi/submodules/Test/reference/">API Reference</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../moi/developer/checklists/">Checklists</a></li></ul></li><li><a class="tocitem" href="../../moi/release_notes/">Release notes</a></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Constraints</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Constraints</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/manual/constraints.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="jump_constraints"><a class="docs-heading-anchor" href="#jump_constraints">Constraints</a><a id="jump_constraints-1"></a><a class="docs-heading-anchor-permalink" href="#jump_constraints" title="Permalink"></a></h1><p>JuMP is based on the <a href="../../moi/#moi_documentation">MathOptInterface (MOI) API</a>. Because of this, JuMP uses the following standard form to represent problems:</p><p class="math-container">\[\begin{align}
    &amp; \min_{x \in \mathbb{R}^n} &amp; f_0(x)
    \\
    &amp; \;\;\text{s.t.} &amp; f_i(x) &amp; \in \mathcal{S}_i &amp; i = 1 \ldots m
\end{align}\]</p><p>Each constraint, <span>$f_i(x) \in \mathcal{S}_i$</span>, is composed of a function and a set. For example, instead of calling <span>$a^\top x \le b$</span> a <em>less-than-or-equal-to</em> constraint, we say that it is a <em>scalar-affine-in-less-than</em> constraint, where the function <span>$a^\top x$</span> belongs to the <em>less-than</em> set <span>$(-\infty, b]$</span>. We use the shorthand <em>function-in-set</em> to refer to constraints composed of different types of functions and sets.</p><p>This page explains how to write various types of constraints in JuMP. For nonlinear constraints, see <a href="../nonlinear/#Nonlinear-Modeling">Nonlinear Modeling</a> instead.</p><h2 id="Add-a-constraint"><a class="docs-heading-anchor" href="#Add-a-constraint">Add a constraint</a><a id="Add-a-constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Add-a-constraint" title="Permalink"></a></h2><p>Add a constraint to a JuMP model using the <a href="../../api/JuMP/#JuMP.@constraint"><code>@constraint</code></a> macro. The syntax to use depends on the type of constraint you wish to add.</p><h3 id="Add-a-linear-constraint"><a class="docs-heading-anchor" href="#Add-a-linear-constraint">Add a linear constraint</a><a id="Add-a-linear-constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Add-a-linear-constraint" title="Permalink"></a></h3><p>Create linear constraints using the <a href="../../api/JuMP/#JuMP.@constraint"><code>@constraint</code></a> macro:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:3]);

julia&gt; @constraint(model, c1, sum(x) &lt;= 1)
c1 : x[1] + x[2] + x[3] ≤ 1

julia&gt; @constraint(model, c2, x[1] + 2 * x[3] &gt;= 2)
c2 : x[1] + 2 x[3] ≥ 2

julia&gt; @constraint(model, c3, sum(i * x[i] for i in 1:3) == 3)
c3 : x[1] + 2 x[2] + 3 x[3] = 3

julia&gt; @constraint(model, c4, 4 &lt;= 2 * x[2] &lt;= 5)
c4 : 2 x[2] ∈ [4, 5]</code></pre><h3 id="Normalization"><a class="docs-heading-anchor" href="#Normalization">Normalization</a><a id="Normalization-1"></a><a class="docs-heading-anchor-permalink" href="#Normalization" title="Permalink"></a></h3><p>JuMP normalizes constraints by moving all of the terms containing variables to the left-hand side and all of the constant terms to the right-hand side. Thus, we get:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; @constraint(model, c, 2x + 1 &lt;= 4x + 4)
c : -2 x ≤ 3</code></pre><h3 id="quad_constraints"><a class="docs-heading-anchor" href="#quad_constraints">Add a quadratic constraint</a><a id="quad_constraints-1"></a><a class="docs-heading-anchor-permalink" href="#quad_constraints" title="Permalink"></a></h3><p>In addition to affine functions, JuMP also supports constraints with quadratic terms. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[i=1:2])
2-element Vector{VariableRef}:
 x[1]
 x[2]

julia&gt; @variable(model, t &gt;= 0)
t

julia&gt; @constraint(model, my_q, x[1]^2 + x[2]^2 &lt;= t^2)
my_q : x[1]² + x[2]² - t² ≤ 0</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Because solvers can take advantage of the knowledge that a constraint is quadratic, prefer adding quadratic constraints using <a href="../../api/JuMP/#JuMP.@constraint"><code>@constraint</code></a>, rather than <a href="../../api/JuMP/#JuMP.@NLconstraint"><code>@NLconstraint</code></a>.</p></div></div><h2 id="Vectorized-constraints"><a class="docs-heading-anchor" href="#Vectorized-constraints">Vectorized constraints</a><a id="Vectorized-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Vectorized-constraints" title="Permalink"></a></h2><p>You can also add constraints to JuMP using vectorized linear algebra. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[i=1:2])
2-element Vector{VariableRef}:
 x[1]
 x[2]

julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; b = [5, 6]
2-element Vector{Int64}:
 5
 6

julia&gt; @constraint(model, con_vector, A * x == b)
con_vector : [x[1] + 2 x[2] - 5, 3 x[1] + 4 x[2] - 6] ∈ MathOptInterface.Zeros(2)

julia&gt; @constraint(model, con_scalar, A * x .== b)
2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}, ScalarShape}}:
 con_scalar : x[1] + 2 x[2] = 5
 con_scalar : 3 x[1] + 4 x[2] = 6</code></pre><p>The two constraints, <code>==</code> and <code>.==</code> are similar, but subtly different. The first creates a single constraint that is a <a href="../../moi/reference/standard_form/#MathOptInterface.VectorAffineFunction"><code>MOI.VectorAffineFunction</code></a> in <a href="../../moi/reference/standard_form/#MathOptInterface.Zeros"><code>MOI.Zeros</code></a> constraint. The second creates a vector of <a href="../../moi/reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction</code></a> in <a href="../../moi/reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo</code></a> constraints.</p><p>Which formulation to choose depends on the solver, and what you want to do with the constraint object <code>con_vector</code> or <code>con_scalar</code>.</p><ul><li>If you are using a conic solver, expect the dual of <code>con_vector</code> to be a <code>Vector{Float64}</code>, and do not intend to delete a row in the constraint, choose the <code>==</code> formulation.</li><li>If you are using a solver that expects a list of scalar constraints, for example HiGHS, or you wish to delete part of the constraint or access a single row of the constraint, for example, <code>dual(con_scalar[2])</code>, then use the broadcast <code>.==</code>.</li></ul><p>JuMP reformulates both constraints into the other form if needed by the solver, but choosing the right format for a particular solver is more efficient.</p><p>You can also use <code>&lt;=</code>, <code>.&lt;=</code> , <code>&gt;=</code>, and <code>.&gt;=</code> as comparison operators in the constraint.</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, A * x &lt;= b)
[x[1] + 2 x[2] - 5, 3 x[1] + 4 x[2] - 6] ∈ MathOptInterface.Nonpositives(2)

julia&gt; @constraint(model, A * x .&lt;= b)
2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:
 x[1] + 2 x[2] ≤ 5
 3 x[1] + 4 x[2] ≤ 6

julia&gt; @constraint(model, A * x &gt;= b)
[x[1] + 2 x[2] - 5, 3 x[1] + 4 x[2] - 6] ∈ MathOptInterface.Nonnegatives(2)

julia&gt; @constraint(model, A * x .&gt;= b)
2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}, ScalarShape}}:
 x[1] + 2 x[2] ≥ 5
 3 x[1] + 4 x[2] ≥ 6</code></pre><h3 id="Vectorized-matrix-constraints"><a class="docs-heading-anchor" href="#Vectorized-matrix-constraints">Vectorized matrix constraints</a><a id="Vectorized-matrix-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Vectorized-matrix-constraints" title="Permalink"></a></h3><p>In most cases, you cannot use the non-broadcasting syntax for general matrices. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, X[1:2, 1:2])
2×2 Matrix{VariableRef}:
 X[1,1]  X[1,2]
 X[2,1]  X[2,2]

julia&gt; @constraint(model, X &gt;= 0)
ERROR: At none:1: `@constraint(model, X &gt;= 0)`: Unsupported matrix in vector-valued set. Did you mean to use the broadcasting syntax `.&gt;=` instead? Alternatively, perhaps you are missing a set argument like `@constraint(model, X &gt;= 0, PSDCone())` or `@constraint(model, X &gt;= 0, HermmitianPSDCone())`.
Stacktrace:
[...]</code></pre><p>Instead, to represent matrix inequalities you must always use the element-wise broadcasting <code>.==</code>, <code>.&gt;=</code>, or <code>.&lt;=</code>, or use the <a href="#Set-inequality-syntax">Set inequality syntax</a>.</p><p>There are two exceptions: if the result of the left-hand side minus the right-hand side is a <code>LinearAlgebra.Symmetric</code> matrix or a <code>LinearAlgebra.Hermitian</code> matrix, you may use the non-broadcasting equality syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra

julia&gt; model = Model();

julia&gt; @variable(model, X[1:2, 1:2], Symmetric)
2×2 Symmetric{VariableRef, Matrix{VariableRef}}:
 X[1,1]  X[1,2]
 X[1,2]  X[2,2]

julia&gt; @constraint(model, X == LinearAlgebra.I)
[X[1,1] - 1  X[1,2];
 X[1,2]      X[2,2] - 1] ∈ Zeros()</code></pre><p>Despite the model showing the matrix in <a href="../../api/JuMP/#JuMP.Zeros"><code>Zeros</code></a>, this will add only three rows to the constraint matrix because the symmetric constraints are redundant. In contrast, the broadcasting syntax adds four linear constraints:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, X .== LinearAlgebra.I)
2×2 Matrix{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}, ScalarShape}}:
 X[1,1] = 1  X[1,2] = 0
 X[1,2] = 0  X[2,2] = 1</code></pre><p>The same holds for <code>LinearAlgebra.Hermitian</code> matrices:</p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra

julia&gt; model = Model();

julia&gt; @variable(model, X[1:2, 1:2] in HermitianPSDCone())
2×2 Hermitian{GenericAffExpr{ComplexF64, VariableRef}, Matrix{GenericAffExpr{ComplexF64, VariableRef}}}:
 real(X[1,1])                    real(X[1,2]) + imag(X[1,2]) im
 real(X[1,2]) - imag(X[1,2]) im  real(X[2,2])

julia&gt; @constraint(model, X == LinearAlgebra.I)
[real(X[1,1]) - 1                real(X[1,2]) + imag(X[1,2]) im;
 real(X[1,2]) - imag(X[1,2]) im  real(X[2,2]) - 1] ∈ Zeros()

julia&gt; @constraint(model, X .== LinearAlgebra.I)
2×2 Matrix{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{ComplexF64}, MathOptInterface.EqualTo{ComplexF64}}, ScalarShape}}:
 real(X[1,1]) = 1                    real(X[1,2]) + imag(X[1,2]) im = 0
 real(X[1,2]) - imag(X[1,2]) im = 0  real(X[2,2]) = 1</code></pre><h2 id="Containers-of-constraints"><a class="docs-heading-anchor" href="#Containers-of-constraints">Containers of constraints</a><a id="Containers-of-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Containers-of-constraints" title="Permalink"></a></h2><p>The <a href="../../api/JuMP/#JuMP.@constraint"><code>@constraint</code></a> macro supports creating collections of constraints. We&#39;ll cover some brief syntax here; read the <a href="#Constraint-containers">Constraint containers</a> section for more details:</p><p>Create arrays of constraints:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:3]);

julia&gt; @constraint(model, c[i=1:3], x[i] &lt;= i^2)
3-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:
 c[1] : x[1] ≤ 1
 c[2] : x[2] ≤ 4
 c[3] : x[3] ≤ 9

julia&gt; c[2]
c[2] : x[2] ≤ 4</code></pre><p>Sets can be any Julia type that supports iteration:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:3]);

julia&gt; @constraint(model, c[i=2:3, [&quot;red&quot;, &quot;blue&quot;]], x[i] &lt;= i^2)
2-dimensional DenseAxisArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape},2,...} with index sets:
    Dimension 1, 2:3
    Dimension 2, [&quot;red&quot;, &quot;blue&quot;]
And data, a 2×2 Matrix{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:
 c[2,red] : x[2] ≤ 4  c[2,blue] : x[2] ≤ 4
 c[3,red] : x[3] ≤ 9  c[3,blue] : x[3] ≤ 9

julia&gt; c[2, &quot;red&quot;]
c[2,red] : x[2] ≤ 4</code></pre><p>Sets can depend upon previous indices:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:3]);

julia&gt; @constraint(model, c[i=1:3, j=i:3], x[i] &lt;= j)
JuMP.Containers.SparseAxisArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}, 2, Tuple{Int64, Int64}} with 6 entries:
  [1, 1]  =  c[1,1] : x[1] ≤ 1
  [1, 2]  =  c[1,2] : x[1] ≤ 2
  [1, 3]  =  c[1,3] : x[1] ≤ 3
  [2, 2]  =  c[2,2] : x[2] ≤ 2
  [2, 3]  =  c[2,3] : x[2] ≤ 3
  [3, 3]  =  c[3,3] : x[3] ≤ 3</code></pre><p>and you can filter elements in the sets using the <code>;</code> syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:9]);

julia&gt; @constraint(model, c[i=1:9; mod(i, 3) == 0], x[i] &lt;= i)
JuMP.Containers.SparseAxisArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}, 1, Tuple{Int64}} with 3 entries:
  [3]  =  c[3] : x[3] ≤ 3
  [6]  =  c[6] : x[6] ≤ 6
  [9]  =  c[9] : x[9] ≤ 9</code></pre><h2 id="Registered-constraints"><a class="docs-heading-anchor" href="#Registered-constraints">Registered constraints</a><a id="Registered-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Registered-constraints" title="Permalink"></a></h2><p>When you create constraints, JuMP registers them inside the model using their corresponding symbol. Get a registered name using <code>model[:key]</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model()
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.

julia&gt; @variable(model, x)
x

julia&gt; @constraint(model, my_c, 2x &lt;= 1)
my_c : 2 x ≤ 1

julia&gt; model
A JuMP Model
Feasibility problem with:
Variable: 1
`AffExpr`-in-`MathOptInterface.LessThan{Float64}`: 1 constraint
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.
Names registered in the model: my_c, x

julia&gt; model[:my_c] === my_c
true</code></pre><h2 id="Anonymous-constraints"><a class="docs-heading-anchor" href="#Anonymous-constraints">Anonymous constraints</a><a id="Anonymous-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Anonymous-constraints" title="Permalink"></a></h2><p>To reduce the likelihood of accidental bugs, and because JuMP registers constraints inside a model, creating two constraints with the same name is an error:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @constraint(model, c, 2x &lt;= 1)
c : 2 x ≤ 1

julia&gt; @constraint(model, c, 2x &lt;= 1)
ERROR: An object of name c is already attached to this model. If this
    is intended, consider using the anonymous construction syntax, e.g.,
    `x = @variable(model, [1:N], ...)` where the name of the object does
    not appear inside the macro.

    Alternatively, use `unregister(model, :c)` to first unregister
    the existing name from the model. Note that this will not delete the
    object; it will just remove the reference at `model[:c]`.
[...]</code></pre><p>A common reason for encountering this error is adding constraints in a loop.</p><p>As a work-around, JuMP provides <em>anonymous</em> constraints. Create an anonymous constraint by omitting the name argument:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; c = @constraint(model, 2x &lt;= 1)
2 x ≤ 1</code></pre><p>Create a container of anonymous constraints by dropping the name in front of the <code>[</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:3]);

julia&gt; c = @constraint(model, [i = 1:3], x[i] &lt;= i)
3-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:
 x[1] ≤ 1
 x[2] ≤ 2
 x[3] ≤ 3</code></pre><h2 id="Constraint-names"><a class="docs-heading-anchor" href="#Constraint-names">Constraint names</a><a id="Constraint-names-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-names" title="Permalink"></a></h2><p>In addition to the symbol that constraints are registered with, constraints have a <code>String</code> name that is used for printing and writing to file formats.</p><p>Get and set the name of a constraint using <a href="../../api/JuMP/#JuMP.name"><code>name(::JuMP.ConstraintRef)</code></a> and <a href="../../api/JuMP/#JuMP.set_name"><code>set_name(::JuMP.ConstraintRef, ::String)</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model(); @variable(model, x);

julia&gt; @constraint(model, con, x &lt;= 1)
con : x ≤ 1

julia&gt; name(con)
&quot;con&quot;

julia&gt; set_name(con, &quot;my_con_name&quot;)

julia&gt; con
my_con_name : x ≤ 1</code></pre><p>Override the default choice of name using the <code>base_name</code> keyword:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model(); @variable(model, x);

julia&gt; con = @constraint(model, [i=1:2], x &lt;= i, base_name = &quot;my_con&quot;)
2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:
 my_con[1] : x ≤ 1
 my_con[2] : x ≤ 2</code></pre><p>Note that names apply to each element of the container, not to the container of constraints:</p><pre><code class="language-julia-repl hljs">julia&gt; name(con[1])
&quot;my_con[1]&quot;

julia&gt; set_name(con[1], &quot;c&quot;)

julia&gt; con
2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:
 c : x ≤ 1
 my_con[2] : x ≤ 2</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>For some models, setting the string name of each constraint can take a non-trivial portion of the total time required to build the model. Turn off <code>String</code> names by passing <code>set_string_name = false</code> to <a href="../../api/JuMP/#JuMP.@constraint"><code>@constraint</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; @constraint(model, con, x &lt;= 2, set_string_name = false)
x ≤ 2</code></pre><p>See <a href="../../tutorials/getting_started/performance_tips/#Disable-string-names">Disable string names</a> for more information.</p></div></div><h3 id="Retrieve-a-constraint-by-name"><a class="docs-heading-anchor" href="#Retrieve-a-constraint-by-name">Retrieve a constraint by name</a><a id="Retrieve-a-constraint-by-name-1"></a><a class="docs-heading-anchor-permalink" href="#Retrieve-a-constraint-by-name" title="Permalink"></a></h3><p>Retrieve a constraint from a model using <a href="../../api/JuMP/#JuMP.constraint_by_name"><code>constraint_by_name</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; constraint_by_name(model, &quot;c&quot;)
c : x ≤ 1</code></pre><p>If the name is not present, <code>nothing</code> will be returned:</p><pre><code class="language-julia-repl hljs">julia&gt; constraint_by_name(model, &quot;bad_name&quot;)</code></pre><p>You can only look up individual constraints using <a href="../../api/JuMP/#JuMP.constraint_by_name"><code>constraint_by_name</code></a>. Something like this will not work:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model(); @variable(model, x);

julia&gt; con = @constraint(model, [i=1:2], x &lt;= i, base_name = &quot;my_con&quot;)
2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:
 my_con[1] : x ≤ 1
 my_con[2] : x ≤ 2

julia&gt; constraint_by_name(model, &quot;my_con&quot;)</code></pre><p>To look up a collection of constraints, do not use <a href="../../api/JuMP/#JuMP.constraint_by_name"><code>constraint_by_name</code></a>. Instead, register them using the <code>model[:key] = value</code> syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model(); @variable(model, x);

julia&gt; model[:con] = @constraint(model, [i=1:2], x &lt;= i, base_name = &quot;my_con&quot;)
2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:
 my_con[1] : x ≤ 1
 my_con[2] : x ≤ 2

julia&gt; model[:con]
2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:
 my_con[1] : x ≤ 1
 my_con[2] : x ≤ 2</code></pre><h2 id="String-names,-symbolic-names,-and-bindings"><a class="docs-heading-anchor" href="#String-names,-symbolic-names,-and-bindings">String names, symbolic names, and bindings</a><a id="String-names,-symbolic-names,-and-bindings-1"></a><a class="docs-heading-anchor-permalink" href="#String-names,-symbolic-names,-and-bindings" title="Permalink"></a></h2><p>It&#39;s common for new users to experience confusion relating to constraints. Part of the problem is the difference between the name that a constraint is registered under and the <code>String</code> name used for printing.</p><p>Here&#39;s a summary of the differences:</p><ul><li>Constraints are created using <a href="../../api/JuMP/#JuMP.@constraint"><code>@constraint</code></a>.</li><li>Constraints can be named or anonymous.</li><li>Named constraints have the form <code>@constraint(model, c, expr)</code>. For named constraints:<ul><li>The <code>String</code> name of the constraint is set to <code>&quot;c&quot;</code>.</li><li>A Julia variable <code>c</code> is created that binds <code>c</code> to  the JuMP constraint.</li><li>The name <code>:c</code> is registered as a key in the model with the value <code>c</code>.</li></ul></li><li>Anonymous constraints have the form <code>c = @constraint(model, expr)</code>. For anonymous constraints:<ul><li>The <code>String</code> name of the constraint is set to <code>&quot;&quot;</code>.</li><li>You control the name of the Julia variable used as the binding.</li><li>No name is registered as a key in the model.</li></ul></li><li>The <code>base_name</code> keyword can override the <code>String</code> name of the constraint.</li><li>You can manually register names in the model via <code>model[:key] = value</code>.</li></ul><p>Here&#39;s an example of the differences:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; c_binding = @constraint(model, 2x &lt;= 1, base_name = &quot;c&quot;)
c : 2 x ≤ 1

julia&gt; model
A JuMP Model
Feasibility problem with:
Variable: 1
`AffExpr`-in-`MathOptInterface.LessThan{Float64}`: 1 constraint
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.
Names registered in the model: x

julia&gt; c
ERROR: UndefVarError: `c` not defined

julia&gt; c_binding
c : 2 x ≤ 1

julia&gt; name(c_binding)
&quot;c&quot;

julia&gt; model[:c_register] = c_binding
c : 2 x ≤ 1

julia&gt; model
A JuMP Model
Feasibility problem with:
Variable: 1
`AffExpr`-in-`MathOptInterface.LessThan{Float64}`: 1 constraint
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.
Names registered in the model: c_register, x

julia&gt; model[:c_register]
c : 2 x ≤ 1

julia&gt; model[:c_register] === c_binding
true

julia&gt; c
ERROR: UndefVarError: `c` not defined</code></pre><h2 id="The-@constraints-macro"><a class="docs-heading-anchor" href="#The-@constraints-macro">The <code>@constraints</code> macro</a><a id="The-@constraints-macro-1"></a><a class="docs-heading-anchor-permalink" href="#The-@constraints-macro" title="Permalink"></a></h2><p>If you have many <a href="../../api/JuMP/#JuMP.@constraint"><code>@constraint</code></a> calls, use the <a href="../../api/JuMP/#JuMP.@constraints"><code>@constraints</code></a> macro to improve readability:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; @constraints(model, begin
           2x &lt;= 1
           c, x &gt;= -1
       end)
(2 x ≤ 1, c : x ≥ -1)

julia&gt; print(model)
Feasibility
Subject to
 c : x ≥ -1
 2 x ≤ 1</code></pre><p>The <a href="../../api/JuMP/#JuMP.@constraints"><code>@constraints</code></a> macro returns a tuple of the constraints that were defined.</p><h2 id="constraint_duality"><a class="docs-heading-anchor" href="#constraint_duality">Duality</a><a id="constraint_duality-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_duality" title="Permalink"></a></h2><p>JuMP adopts the notion of <a href="../../moi/background/duality/#Duality">conic duality from MathOptInterface</a>. For linear programs, a feasible dual on a <code>&gt;=</code> constraint is nonnegative and a feasible dual on a <code>&lt;=</code> constraint is nonpositive. If the constraint is an equality constraint, it depends on which direction is binding.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>JuMP&#39;s definition of duality is independent of the objective sense. That is, the sign of feasible duals associated with a constraint depends on the direction of the constraint and not whether the problem is maximization or minimization. <strong>This is a different convention from linear programming duality in some common textbooks.</strong> If you have a linear program, and you want the textbook definition, you probably want to use <a href="../../api/JuMP/#JuMP.shadow_price"><code>shadow_price</code></a> and <a href="../../api/JuMP/#JuMP.reduced_cost"><code>reduced_cost</code></a> instead.</p></div></div><p>The dual value associated with a constraint in the most recent solution can be accessed using the <a href="../../api/JuMP/#JuMP.dual"><code>dual</code></a> function. Use <a href="../../api/JuMP/#JuMP.has_duals"><code>has_duals</code></a> to check if the model has a dual solution available to query. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model(HiGHS.Optimizer);

julia&gt; set_silent(model)

julia&gt; @variable(model, x)
x

julia&gt; @constraint(model, con, x &lt;= 1)
con : x ≤ 1

julia&gt; @objective(model, Min, -2x)
-2 x

julia&gt; has_duals(model)
false

julia&gt; optimize!(model)

julia&gt; has_duals(model)
true

julia&gt; dual(con)
-2.0

julia&gt; @objective(model, Max, 2x)
2 x

julia&gt; optimize!(model)

julia&gt; dual(con)
-2.0</code></pre><p>To help users who may be less familiar with conic duality, JuMP provides <a href="../../api/JuMP/#JuMP.shadow_price"><code>shadow_price</code></a>, which returns a value that can be interpreted as the improvement in the objective in response to an infinitesimal relaxation (on the scale of one unit) in the right-hand side of the constraint. <a href="../../api/JuMP/#JuMP.shadow_price"><code>shadow_price</code></a> can be used only on linear constraints with a <code>&lt;=</code>, <code>&gt;=</code>, or <code>==</code> comparison operator.</p><p>In the example above, <code>dual(con)</code> returned <code>-2.0</code> regardless of the optimization sense. However, in the second case when the optimization sense is <code>Max</code>, <a href="../../api/JuMP/#JuMP.shadow_price"><code>shadow_price</code></a> returns:</p><pre><code class="language-julia-repl hljs">julia&gt; shadow_price(con)
2.0</code></pre><h3 id="Duals-of-variable-bounds"><a class="docs-heading-anchor" href="#Duals-of-variable-bounds">Duals of variable bounds</a><a id="Duals-of-variable-bounds-1"></a><a class="docs-heading-anchor-permalink" href="#Duals-of-variable-bounds" title="Permalink"></a></h3><p>To query the dual variables associated with a variable bound, first obtain a constraint reference using one of <a href="../../api/JuMP/#JuMP.UpperBoundRef"><code>UpperBoundRef</code></a>, <a href="../../api/JuMP/#JuMP.LowerBoundRef"><code>LowerBoundRef</code></a>, or <a href="../../api/JuMP/#JuMP.FixRef"><code>FixRef</code></a>, and then call <a href="../../api/JuMP/#JuMP.dual"><code>dual</code></a> on the returned constraint reference. The <a href="../../api/JuMP/#JuMP.reduced_cost"><code>reduced_cost</code></a> function may simplify this process as it returns the shadow price of an active bound of a variable (or zero, if no active bound exists).</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model(HiGHS.Optimizer);

julia&gt; set_silent(model)

julia&gt; @variable(model, x &lt;= 1)
x

julia&gt; @objective(model, Min, -2x)
-2 x

julia&gt; optimize!(model)

julia&gt; dual(UpperBoundRef(x))
-2.0

julia&gt; reduced_cost(x)
-2.0</code></pre><h2 id="Modify-a-constant-term"><a class="docs-heading-anchor" href="#Modify-a-constant-term">Modify a constant term</a><a id="Modify-a-constant-term-1"></a><a class="docs-heading-anchor-permalink" href="#Modify-a-constant-term" title="Permalink"></a></h2><p>This section explains how to modify the constant term in a constraint. There are multiple ways to achieve this goal; we explain three options.</p><h3 id="Option-1:-change-the-right-hand-side"><a class="docs-heading-anchor" href="#Option-1:-change-the-right-hand-side">Option 1: change the right-hand side</a><a id="Option-1:-change-the-right-hand-side-1"></a><a class="docs-heading-anchor-permalink" href="#Option-1:-change-the-right-hand-side" title="Permalink"></a></h3><p>Use <a href="../../api/JuMP/#JuMP.set_normalized_rhs"><code>set_normalized_rhs</code></a> to modify the right-hand side (constant) term of a linear or quadratic  constraint. Use <a href="../../api/JuMP/#JuMP.normalized_rhs"><code>normalized_rhs</code></a> to query the right-hand side term.</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; @constraint(model, con, 2x &lt;= 1)
con : 2 x ≤ 1

julia&gt; set_normalized_rhs(con, 3)

julia&gt; con
con : 2 x ≤ 3

julia&gt; normalized_rhs(con)
3.0</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><a href="../../api/JuMP/#JuMP.set_normalized_rhs"><code>set_normalized_rhs</code></a> sets the right-hand side term of the normalized constraint. See <a href="#Normalization">Normalization</a> for more details.</p></div></div><h3 id="Option-2:-use-fixed-variables"><a class="docs-heading-anchor" href="#Option-2:-use-fixed-variables">Option 2: use fixed variables</a><a id="Option-2:-use-fixed-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Option-2:-use-fixed-variables" title="Permalink"></a></h3><p>If constraints are complicated, for example, they are composed of a number of components, each of which has a constant term, then it may be difficult to calculate what the right-hand side term is in the standard form.</p><p>For this situation, JuMP includes the ability to <em>fix</em> variables to a value using the <a href="../../api/JuMP/#JuMP.fix"><code>fix</code></a> function. Fixing a variable sets its lower and upper bound to the same value. Thus, changes in a constant term can be simulated by adding a new variable and fixing it to different values. Here is an example:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; @variable(model, const_term)
const_term

julia&gt; @constraint(model, con, 2x &lt;= const_term + 1)
con : 2 x - const_term ≤ 1

julia&gt; fix(const_term, 1.0)</code></pre><p>The constraint <code>con</code> is now equivalent to <code>2x &lt;= 2</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Fixed variables are not replaced with constants when communicating the problem to a solver. Therefore, even though <code>const_term</code> is fixed, it is still a decision variable, and so <code>const_term * x</code> is bilinear.</p></div></div><h3 id="Option-3:-modify-the-function&#39;s-constant-term"><a class="docs-heading-anchor" href="#Option-3:-modify-the-function&#39;s-constant-term">Option 3: modify the function&#39;s constant term</a><a id="Option-3:-modify-the-function&#39;s-constant-term-1"></a><a class="docs-heading-anchor-permalink" href="#Option-3:-modify-the-function&#39;s-constant-term" title="Permalink"></a></h3><p>The third option is to use <a href="../../api/JuMP/#JuMP.add_to_function_constant"><code>add_to_function_constant</code></a>. The constant given is added to the function of a <code>func</code>-in-<code>set</code> constraint. In the following example, adding <code>2</code> to the function has the effect of removing <code>2</code> to the right-hand side:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; @constraint(model, con, 2x &lt;= 1)
con : 2 x ≤ 1

julia&gt; add_to_function_constant(con, 2)

julia&gt; con
con : 2 x ≤ -1

julia&gt; normalized_rhs(con)
-1.0</code></pre><p>In the case of interval constraints, the constant is removed from each bound:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; @constraint(model, con, 0 &lt;= 2x + 1 &lt;= 2)
con : 2 x ∈ [-1, 1]

julia&gt; add_to_function_constant(con, 3)

julia&gt; con
con : 2 x ∈ [-4, -2]</code></pre><h2 id="Modify-a-variable-coefficient"><a class="docs-heading-anchor" href="#Modify-a-variable-coefficient">Modify a variable coefficient</a><a id="Modify-a-variable-coefficient-1"></a><a class="docs-heading-anchor-permalink" href="#Modify-a-variable-coefficient" title="Permalink"></a></h2><h3 id="Scalar-constraints"><a class="docs-heading-anchor" href="#Scalar-constraints">Scalar constraints</a><a id="Scalar-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-constraints" title="Permalink"></a></h3><p>To modify the coefficients for a linear term in a constraint, use <a href="../../api/JuMP/#JuMP.set_normalized_coefficient"><code>set_normalized_coefficient</code></a>. To query the current coefficient, use <a href="../../api/JuMP/#JuMP.normalized_coefficient"><code>normalized_coefficient</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; @constraint(model, con, 2x[1] + x[2] &lt;= 1)
con : 2 x[1] + x[2] ≤ 1

julia&gt; set_normalized_coefficient(con, x[2], 0)

julia&gt; con
con : 2 x[1] ≤ 1

julia&gt; normalized_coefficient(con, x[2])
0.0</code></pre><p>To modify quadratic terms, pass two variables:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; @constraint(model, con, x[1]^2 + x[1] * x[2] &lt;= 1)
con : x[1]² + x[1]*x[2] ≤ 1

julia&gt; set_normalized_coefficient(con, x[1], x[1], 2)

julia&gt; set_normalized_coefficient(con, x[1], x[2], 3)

julia&gt; con
con : 2 x[1]² + 3 x[1]*x[2] ≤ 1

julia&gt; normalized_coefficient(con, x[1], x[1])
2.0

julia&gt; normalized_coefficient(con, x[1], x[2])
3.0</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><a href="../../api/JuMP/#JuMP.set_normalized_coefficient"><code>set_normalized_coefficient</code></a> sets the coefficient of the normalized constraint. See <a href="#Normalization">Normalization</a> for more details.</p></div></div><h3 id="Vector-constraints"><a class="docs-heading-anchor" href="#Vector-constraints">Vector constraints</a><a id="Vector-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-constraints" title="Permalink"></a></h3><p>To modify the coefficients of a vector-valued constraint, use <a href="../../api/JuMP/#JuMP.set_normalized_coefficients"><code>set_normalized_coefficients</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @constraint(model, con, [2x + 3x, 4x] in MOI.Nonnegatives(2))
con : [5 x, 4 x] ∈ MathOptInterface.Nonnegatives(2)

julia&gt; set_normalized_coefficients(con, x, [(1, 3.0)])

julia&gt; con
con : [3 x, 4 x] ∈ MathOptInterface.Nonnegatives(2)

julia&gt; set_normalized_coefficients(con, x, [(1, 2.0), (2, 5.0)])

julia&gt; con
con : [2 x, 5 x] ∈ MathOptInterface.Nonnegatives(2)</code></pre><h2 id="Delete-a-constraint"><a class="docs-heading-anchor" href="#Delete-a-constraint">Delete a constraint</a><a id="Delete-a-constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Delete-a-constraint" title="Permalink"></a></h2><p>Use <a href="../../api/JuMP/#JuMP.delete"><code>delete</code></a> to delete a constraint from a model. Use <a href="../../api/JuMP/#JuMP.is_valid"><code>is_valid</code></a> to check if a constraint belongs to a model and has not been deleted.</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; @constraint(model, con, 2x &lt;= 1)
con : 2 x ≤ 1

julia&gt; is_valid(model, con)
true

julia&gt; delete(model, con)

julia&gt; is_valid(model, con)
false</code></pre><p>Deleting a constraint does not unregister the symbolic reference from the model. Therefore, creating a new constraint of the same name will throw an error:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, con, 2x &lt;= 1)
ERROR: An object of name con is already attached to this model. If this
    is intended, consider using the anonymous construction syntax, e.g.,
    `x = @variable(model, [1:N], ...)` where the name of the object does
    not appear inside the macro.

    Alternatively, use `unregister(model, :con)` to first unregister
    the existing name from the model. Note that this will not delete the
    object; it will just remove the reference at `model[:con]`.
[...]</code></pre><p>After calling <a href="../../api/JuMP/#JuMP.delete"><code>delete</code></a>, call <a href="../../api/JuMP/#JuMP.unregister"><code>unregister</code></a> to remove the symbolic reference:</p><pre><code class="language-julia-repl hljs">julia&gt; unregister(model, :con)

julia&gt; @constraint(model, con, 2x &lt;= 1)
con : 2 x ≤ 1</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p><a href="../../api/JuMP/#JuMP.delete"><code>delete</code></a> does not automatically <a href="../../api/JuMP/#JuMP.unregister"><code>unregister</code></a> because we do not distinguish between names that are automatically registered by JuMP macros, and names that are manually registered by the user by setting values in <a href="../../api/JuMP/#JuMP.object_dictionary"><code>object_dictionary</code></a>. In addition, deleting a constraint and then adding a new constraint of the same name is an easy way to introduce bugs into your code.</p></div></div><h2 id="Start-values"><a class="docs-heading-anchor" href="#Start-values">Start values</a><a id="Start-values-1"></a><a class="docs-heading-anchor-permalink" href="#Start-values" title="Permalink"></a></h2><p>Provide a starting value (also called warmstart) for a constraint&#39;s primal and dual solutions using <a href="../../api/JuMP/#JuMP.set_start_value"><code>set_start_value</code></a> and <a href="../../api/JuMP/#JuMP.set_dual_start_value"><code>set_dual_start_value</code></a>.</p><p>Query the starting value for a constraint&#39;s primal and dual solution using <a href="../../api/JuMP/#JuMP.start_value"><code>start_value</code></a> and <a href="../../api/JuMP/#JuMP.dual_start_value"><code>dual_start_value</code></a>. If no start value has been set, the methods will return <code>nothing</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @constraint(model, con, x &gt;= 10)
con : x ≥ 10

julia&gt; start_value(con)

julia&gt; set_start_value(con, 10.0)

julia&gt; start_value(con)
10.0

julia&gt; dual_start_value(con)

julia&gt; set_dual_start_value(con, 2)

julia&gt; dual_start_value(con)
2.0</code></pre><p>Vector-valued constraints require a vector:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:3])
3-element Vector{VariableRef}:
 x[1]
 x[2]
 x[3]

julia&gt; @constraint(model, con, x in SecondOrderCone())
con : [x[1], x[2], x[3]] in MathOptInterface.SecondOrderCone(3)

julia&gt; dual_start_value(con)

julia&gt; set_dual_start_value(con, [1.0, 2.0, 3.0])

julia&gt; dual_start_value(con)
3-element Vector{Float64}:
 1.0
 2.0
 3.0</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>To simplify setting start values for all variables and constraints in a model, see <a href="../../api/JuMP/#JuMP.set_start_values"><code>set_start_values</code></a>. The <a href="../../tutorials/conic/start_values/#Primal-and-dual-warm-starts">Primal and dual warm-starts</a> tutorial also gives a detailed description of how to iterate over constraints in the model to set custom start values.</p></div></div><h2 id="Constraint-containers"><a class="docs-heading-anchor" href="#Constraint-containers">Constraint containers</a><a id="Constraint-containers-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-containers" title="Permalink"></a></h2><p>Like <a href="../variables/#Variable-containers">Variable containers</a>, JuMP provides a mechanism for building groups of constraints compactly. References to these groups of constraints are returned in <em>containers</em>. Three types of constraint containers are supported: <code>Array</code>s, <code>DenseAxisArray</code>s, and <code>SparseAxisArray</code>s. We explain each of these in the following.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>You can read more about containers in the <a href="../containers/#Containers">Containers</a> section.</p></div></div><h3 id="constraint_arrays"><a class="docs-heading-anchor" href="#constraint_arrays">Arrays</a><a id="constraint_arrays-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_arrays" title="Permalink"></a></h3><p>One way of adding a group of constraints compactly is the following:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; @constraint(model, con[i = 1:3], i * x &lt;= i + 1)
3-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:
 con[1] : x ≤ 2
 con[2] : 2 x ≤ 3
 con[3] : 3 x ≤ 4</code></pre><p>JuMP returns references to the three constraints in an <code>Array</code> that is bound to the Julia variable <code>con</code>. This array can be accessed and sliced as you would with any Julia array:</p><pre><code class="language-julia-repl hljs">julia&gt; con[1]
con[1] : x ≤ 2

julia&gt; con[2:3]
2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:
 con[2] : 2 x ≤ 3
 con[3] : 3 x ≤ 4</code></pre><p>Anonymous containers can also be constructed by dropping the name (for example, <code>con</code>) before the square brackets:</p><pre><code class="language-julia-repl hljs">julia&gt; con = @constraint(model, [i = 1:2], i * x &lt;= i + 1)
2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:
 x ≤ 2
 2 x ≤ 3</code></pre><p>Just like <a href="../../api/JuMP/#JuMP.@variable"><code>@variable</code></a>, JuMP will form an <code>Array</code> of constraints when it can determine at parse time that the indices are one-based integer ranges. Therefore <code>con[1:b]</code> will create an <code>Array</code>, but <code>con[a:b]</code> will not. A special case is <code>con[Base.OneTo(n)]</code> which will produce an <code>Array</code>. If JuMP cannot determine that the indices are one-based integer ranges (for example, in the case of <code>con[a:b]</code>), JuMP will create a <code>DenseAxisArray</code> instead.</p><h3 id="DenseAxisArrays"><a class="docs-heading-anchor" href="#DenseAxisArrays">DenseAxisArrays</a><a id="DenseAxisArrays-1"></a><a class="docs-heading-anchor-permalink" href="#DenseAxisArrays" title="Permalink"></a></h3><p>The syntax for constructing a <a href="../../api/JuMP.Containers/#JuMP.Containers.DenseAxisArray"><code>DenseAxisArray</code></a> of constraints is very similar to the <a href="../variables/#variable_jump_arrays">syntax for constructing</a> a <code>DenseAxisArray</code> of variables.</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; @constraint(model, con[i = 1:2, j = 2:3], i * x &lt;= j + 1)
2-dimensional DenseAxisArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape},2,...} with index sets:
    Dimension 1, Base.OneTo(2)
    Dimension 2, 2:3
And data, a 2×2 Matrix{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:
 con[1,2] : x ≤ 3    con[1,3] : x ≤ 4
 con[2,2] : 2 x ≤ 3  con[2,3] : 2 x ≤ 4</code></pre><h3 id="SparseAxisArrays"><a class="docs-heading-anchor" href="#SparseAxisArrays">SparseAxisArrays</a><a id="SparseAxisArrays-1"></a><a class="docs-heading-anchor-permalink" href="#SparseAxisArrays" title="Permalink"></a></h3><p>The syntax for constructing a <a href="../../api/JuMP.Containers/#JuMP.Containers.SparseAxisArray"><code>SparseAxisArray</code></a> of constraints is very similar to the <a href="../variables/#variable_sparseaxisarrays">syntax for constructing</a> a <code>SparseAxisArray</code> of variables.</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x);

julia&gt; @constraint(model, con[i = 1:2, j = 1:2; i != j], i * x &lt;= j + 1)
JuMP.Containers.SparseAxisArray{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}, 2, Tuple{Int64, Int64}} with 2 entries:
  [1, 2]  =  con[1,2] : x ≤ 3
  [2, 1]  =  con[2,1] : 2 x ≤ 2</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If you have many index dimensions and a large amount of sparsity, read <a href="../variables/#Performance-considerations">Performance considerations</a>.</p></div></div><h3 id="Forcing-the-container-type"><a class="docs-heading-anchor" href="#Forcing-the-container-type">Forcing the container type</a><a id="Forcing-the-container-type-1"></a><a class="docs-heading-anchor-permalink" href="#Forcing-the-container-type" title="Permalink"></a></h3><p>When creating a container of constraints, JuMP will attempt to choose the tightest container type that can store the constraints. However, because this happens at parse time, it does not always make the best choice. Just like in <a href="../../api/JuMP/#JuMP.@variable"><code>@variable</code></a>, you can force the type of container using the <code>container</code> keyword. For syntax and the reason behind this, take a look at the <a href="../variables/#variable_forcing">variable docs</a>.</p><h3 id="Constraints-with-similar-indices"><a class="docs-heading-anchor" href="#Constraints-with-similar-indices">Constraints with similar indices</a><a id="Constraints-with-similar-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints-with-similar-indices" title="Permalink"></a></h3><p>Containers are often used to create constraints over a set of indices. However, you&#39;ll often have cases in which you are repeating the indices:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; @variable(model, y[1:2]);

julia&gt; @constraints(model, begin
           [i=1:2, j=1:2, k=1:2], i * x[j] &lt;= k
           [i=1:2, j=1:2, k=1:2], i * y[j] &lt;= k
       end);</code></pre><p>This is hard to read and leads to a lot of copy-paste. A more readable way is to use a for-loop:</p><pre><code class="language-julia-repl hljs">julia&gt; for i=1:2, j=1:2, k=1:2
           @constraints(model, begin
               i * x[j] &lt;= k
               i * y[j] &lt;= k
           end)
       end</code></pre><h2 id="Accessing-constraints-from-a-model"><a class="docs-heading-anchor" href="#Accessing-constraints-from-a-model">Accessing constraints from a model</a><a id="Accessing-constraints-from-a-model-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-constraints-from-a-model" title="Permalink"></a></h2><p>Query the types of function-in-set constraints in a model using <a href="../../api/JuMP/#JuMP.list_of_constraint_types"><code>list_of_constraint_types</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[i=1:2] &gt;= i, Int);

julia&gt; @constraint(model, x[1] + x[2] &lt;= 1);

julia&gt; list_of_constraint_types(model)
3-element Vector{Tuple{Type, Type}}:
 (AffExpr, MathOptInterface.LessThan{Float64})
 (VariableRef, MathOptInterface.GreaterThan{Float64})
 (VariableRef, MathOptInterface.Integer)</code></pre><p>For a given combination of function and set type, use <a href="../../api/JuMP/#JuMP.num_constraints"><code>num_constraints</code></a> to access the number of constraints and <a href="../../api/JuMP/#JuMP.all_constraints"><code>all_constraints</code></a> to access a list of their references:</p><pre><code class="language-julia-repl hljs">julia&gt; num_constraints(model, VariableRef, MOI.Integer)
2

julia&gt; cons = all_constraints(model, VariableRef, MOI.Integer)
2-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}, ScalarShape}}:
 x[1] integer
 x[2] integer</code></pre><p>You can also count the total number of constraints in the model, but you must explicitly choose whether to count <code>VariableRef</code> constraints such as bound and integrality constraints:</p><pre><code class="language-julia-repl hljs">julia&gt; num_constraints(model; count_variable_in_set_constraints = true)
5

julia&gt; num_constraints(model; count_variable_in_set_constraints = false)
1</code></pre><p>The same also applies for <a href="../../api/JuMP/#JuMP.all_constraints"><code>all_constraints</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; all_constraints(model; include_variable_in_set_constraints = true)
5-element Vector{ConstraintRef}:
 x[1] + x[2] ≤ 1
 x[1] ≥ 1
 x[2] ≥ 2
 x[1] integer
 x[2] integer

julia&gt; all_constraints(model; include_variable_in_set_constraints = false)
1-element Vector{ConstraintRef}:
 x[1] + x[2] ≤ 1</code></pre><p>If you need finer-grained control on which constraints to include, use a variant of:</p><pre><code class="language-julia-repl hljs">julia&gt; sum(
           num_constraints(model, F, S) for
           (F, S) in list_of_constraint_types(model) if F != VariableRef
       )
1</code></pre><p>Use <a href="../../api/JuMP/#JuMP.constraint_object"><code>constraint_object</code></a> to get an instance of an <a href="../../api/JuMP/#JuMP.AbstractConstraint"><code>AbstractConstraint</code></a> object that stores the constraint data:</p><pre><code class="language-julia-repl hljs">julia&gt; con = constraint_object(cons[1])
ScalarConstraint{VariableRef, MathOptInterface.Integer}(x[1], MathOptInterface.Integer())

julia&gt; con.func
x[1]

julia&gt; con.set
MathOptInterface.Integer()</code></pre><h2 id="MathOptInterface-constraints"><a class="docs-heading-anchor" href="#MathOptInterface-constraints">MathOptInterface constraints</a><a id="MathOptInterface-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#MathOptInterface-constraints" title="Permalink"></a></h2><p>Because JuMP is based on MathOptInterface, you can add any constraints supported by MathOptInterface using the function-in-set syntax. For a list of supported functions and sets, read <a href="../../moi/manual/standard_form/#Standard-form-problem">Standard form problem</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We use <code>MOI</code> as an alias for the <code>MathOptInterface</code> module. This alias is defined by <code>using JuMP</code>. You may also define it in your code as follows:</p><pre><code class="language-julia hljs">import MathOptInterface as MOI</code></pre></div></div><p>For example, the following two constraints are equivalent:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:3]);

julia&gt; @constraint(model, 2 * x[1] &lt;= 1)
2 x[1] ≤ 1

julia&gt; @constraint(model, 2 * x[1] in MOI.LessThan(1.0))
2 x[1] ≤ 1</code></pre><p>You can also use any set defined by MathOptInterface:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, x - [1; 2; 3] in MOI.Nonnegatives(3))
[x[1] - 1, x[2] - 2, x[3] - 3] ∈ MathOptInterface.Nonnegatives(3)

julia&gt; @constraint(model, x in MOI.ExponentialCone())
[x[1], x[2], x[3]] ∈ MathOptInterface.ExponentialCone()</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Similar to how JuMP defines the <code>&lt;=</code> and <code>&gt;=</code> syntax as a convenience way to specify <a href="../../moi/reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan</code></a> and <a href="../../moi/reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan</code></a> constraints, the remaining sections in this page describe functions and syntax that have been added for the convenience of common modeling situations.</p></div></div><h2 id="Set-inequality-syntax"><a class="docs-heading-anchor" href="#Set-inequality-syntax">Set inequality syntax</a><a id="Set-inequality-syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Set-inequality-syntax" title="Permalink"></a></h2><p>For modeling convenience, the syntax <code>@constraint(model, x &gt;= y, Set())</code> is short-hand for <code>@constraint(model, x - y in Set())</code>. Therefore, the following calls are equivalent:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; y = [0.5, 0.75];

julia&gt; @constraint(model, x &gt;= y, MOI.Nonnegatives(2))
[x[1] - 0.5, x[2] - 0.75] ∈ MathOptInterface.Nonnegatives(2)

julia&gt; @constraint(model, y &lt;= x, MOI.Nonnegatives(2))
[x[1] - 0.5, x[2] - 0.75] ∈ MathOptInterface.Nonnegatives(2)

julia&gt; @constraint(model, x - y in MOI.Nonnegatives(2))
[x[1] - 0.5, x[2] - 0.75] ∈ MathOptInterface.Nonnegatives(2)</code></pre><p>Non-zero constants are not supported in this syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, x &gt;= 1, MOI.Nonnegatives(2))
ERROR: Operation `sub_mul` between `Vector{VariableRef}` and `Int64` is not allowed. This most often happens when you write a constraint like `x &gt;= y` where `x` is an array and `y` is a constant. Use the broadcast syntax `x .- y &gt;= 0` instead.
Stacktrace:
[...]</code></pre><p>Use instead:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, x .- 1 &gt;= 0, MOI.Nonnegatives(2))
[x[1] - 1, x[2] - 1] ∈ MathOptInterface.Nonnegatives(2)</code></pre><h2 id="Second-order-cone-constraints"><a class="docs-heading-anchor" href="#Second-order-cone-constraints">Second-order cone constraints</a><a id="Second-order-cone-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Second-order-cone-constraints" title="Permalink"></a></h2><p>A <a href="../../api/JuMP/#JuMP.SecondOrderCone"><code>SecondOrderCone</code></a> constrains the variables <code>t</code> and <code>x</code> to the set:</p><p class="math-container">\[||x||_2 \le t,\]</p><p>and <span>$t \ge 0$</span>. It can be added as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, t)
t

julia&gt; @variable(model, x[1:2])
2-element Vector{VariableRef}:
 x[1]
 x[2]

julia&gt; @constraint(model, [t; x] in SecondOrderCone())
[t, x[1], x[2]] ∈ MathOptInterface.SecondOrderCone(3)</code></pre><h2 id="Rotated-second-order-cone-constraints"><a class="docs-heading-anchor" href="#Rotated-second-order-cone-constraints">Rotated second-order cone constraints</a><a id="Rotated-second-order-cone-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Rotated-second-order-cone-constraints" title="Permalink"></a></h2><p>A <a href="../../api/JuMP/#JuMP.RotatedSecondOrderCone"><code>RotatedSecondOrderCone</code></a> constrains the variables <code>t</code>, <code>u</code>, and <code>x</code> to the set:</p><p class="math-container">\[||x||_2^2 \le 2 t \cdot u\]</p><p>and <span>$t, u \ge 0$</span>. It can be added as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, t)
t

julia&gt; @variable(model, u)
u

julia&gt; @variable(model, x[1:2])
2-element Vector{VariableRef}:
 x[1]
 x[2]

julia&gt; @constraint(model, [t; u; x] in RotatedSecondOrderCone())
[t, u, x[1], x[2]] ∈ MathOptInterface.RotatedSecondOrderCone(4)</code></pre><h2 id="Special-Ordered-Sets-of-Type-1"><a class="docs-heading-anchor" href="#Special-Ordered-Sets-of-Type-1">Special Ordered Sets of Type 1</a><a id="Special-Ordered-Sets-of-Type-1-1"></a><a class="docs-heading-anchor-permalink" href="#Special-Ordered-Sets-of-Type-1" title="Permalink"></a></h2><p>In a Special Ordered Set of Type 1 (often denoted SOS-I or SOS1), at most one element can take a non-zero value.</p><p>Construct SOS-I constraints using the <a href="../../api/JuMP/#JuMP.SOS1"><code>SOS1</code></a> set:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:3])
3-element Vector{VariableRef}:
 x[1]
 x[2]
 x[3]

julia&gt; @constraint(model, x in SOS1())
[x[1], x[2], x[3]] in MathOptInterface.SOS1{Float64}([1.0, 2.0, 3.0])</code></pre><p>Although not required for feasibility, solvers can benefit from an ordering of the variables (for example, the variables represent different factories to build, at most one factory can be built, and the factories can be ordered according to cost). To induce an ordering, a vector of weights can be provided, and the variables are ordered according to their corresponding weight.</p><p>For example, in the constraint:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, x in SOS1([3.1, 1.2, 2.3]))
[x[1], x[2], x[3]] in MathOptInterface.SOS1{Float64}([3.1, 1.2, 2.3])</code></pre><p>the variables <code>x</code> have precedence <code>x[2]</code>, <code>x[3]</code>, <code>x[1]</code>.</p><h2 id="Special-Ordered-Sets-of-Type-2"><a class="docs-heading-anchor" href="#Special-Ordered-Sets-of-Type-2">Special Ordered Sets of Type 2</a><a id="Special-Ordered-Sets-of-Type-2-1"></a><a class="docs-heading-anchor-permalink" href="#Special-Ordered-Sets-of-Type-2" title="Permalink"></a></h2><p>In a Special Ordered Set of Type 2 (SOS-II), at most two elements can be non-zero, and if there are two non-zeros, they must be consecutive according to the ordering induced by a weight vector.</p><p>Construct SOS-II constraints using the <a href="../../api/JuMP/#JuMP.SOS2"><code>SOS2</code></a> set:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, x in SOS2([3.0, 1.0, 2.0]))
[x[1], x[2], x[3]] in MathOptInterface.SOS2{Float64}([3.0, 1.0, 2.0])</code></pre><p>The possible non-zero pairs are (<code>x[1]</code>, <code>x[3]</code>) and (<code>x[2]</code>, <code>x[3]</code>):</p><p>If the weight vector is omitted, JuMP induces an ordering from <code>1:length(x)</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, x in SOS2())
[x[1], x[2], x[3]] in MathOptInterface.SOS2{Float64}([1.0, 2.0, 3.0])</code></pre><h2 id="Indicator-constraints"><a class="docs-heading-anchor" href="#Indicator-constraints">Indicator constraints</a><a id="Indicator-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Indicator-constraints" title="Permalink"></a></h2><p>Indicator constraints consist of a binary variable and a linear constraint. The constraint holds when the binary variable takes the value <code>1</code>. The constraint may or may not hold when the binary variable takes the value <code>0</code>.</p><p>To enforce the constraint <code>x + y &lt;= 1</code> when the binary variable <code>a</code> is <code>1</code>, use:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @variable(model, y)
y

julia&gt; @variable(model, a, Bin)
a

julia&gt; @constraint(model, a --&gt; {x + y &lt;= 1})
a --&gt; {x + y ≤ 1}</code></pre><p>If the constraint must hold when <code>a</code> is zero, add <code>!</code> or <code>¬</code> before the binary variable;</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, !a --&gt; {x + y &lt;= 1})
!a --&gt; {x + y ≤ 1}</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>You cannot use an expression for the left-hand side of an indicator constraint.</p></div></div><h2 id="Semidefinite-constraints"><a class="docs-heading-anchor" href="#Semidefinite-constraints">Semidefinite constraints</a><a id="Semidefinite-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Semidefinite-constraints" title="Permalink"></a></h2><p>To constrain a matrix to be positive semidefinite (PSD), use <a href="../../api/JuMP/#JuMP.PSDCone"><code>PSDCone</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, X[1:2, 1:2])
2×2 Matrix{VariableRef}:
 X[1,1]  X[1,2]
 X[2,1]  X[2,2]

julia&gt; @constraint(model, X &gt;= 0, PSDCone())
[X[1,1]  X[1,2];
 X[2,1]  X[2,2]] ∈ PSDCone()</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Where possible, prefer constructing a matrix of <a href="../variables/#Semidefinite-variables">Semidefinite variables</a> using the <a href="../../api/JuMP/#JuMP.@variable"><code>@variable</code></a> macro, rather than adding a constraint like <code>@constraint(model, X &gt;= 0, PSDCone())</code>. In some solvers, adding the constraint via <a href="../../api/JuMP/#JuMP.@constraint"><code>@constraint</code></a> is less efficient, and can result in additional intermediate variables and constraints being added to the model.</p></div></div><p>The inequality <code>X &gt;= Y</code> between two square matrices <code>X</code> and <code>Y</code> is understood as constraining <code>X - Y</code> to be positive semidefinite.</p><pre><code class="language-julia-repl hljs">julia&gt; Y = [1 2; 2 1]
2×2 Matrix{Int64}:
 1  2
 2  1

julia&gt; @constraint(model, X &gt;= Y, PSDCone())
[X[1,1] - 1  X[1,2] - 2;
 X[2,1] - 2  X[2,2] - 1] ∈ PSDCone()</code></pre><h3 id="Symmetry"><a class="docs-heading-anchor" href="#Symmetry">Symmetry</a><a id="Symmetry-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetry" title="Permalink"></a></h3><p>Solvers supporting PSD constraints usually expect to be given a matrix that is <em>symbolically</em> symmetric, that is, for which the expression in corresponding off-diagonal entries are the same. In our example, the expressions of entries <code>(1, 2)</code> and <code>(2, 1)</code> are respectively <code>X[1,2] - 2</code> and <code>X[2,1] - 2</code> which are different.</p><p>To bridge the gap between the constraint modeled and what the solver expects, solvers may add an equality constraint <code>X[1,2] - 2 == X[2,1] - 2</code> to force symmetry. Use <code>LinearAlgebra.Symmetric</code> to explicitly tell the solver that the matrix is symmetric:</p><pre><code class="language-julia-repl hljs">julia&gt; import LinearAlgebra

julia&gt; Z = [X[1, 1] X[1, 2]; X[1, 2] X[2, 2]]
2×2 Matrix{VariableRef}:
 X[1,1]  X[1,2]
 X[1,2]  X[2,2]

julia&gt; @constraint(model, LinearAlgebra.Symmetric(Z) &gt;= 0, PSDCone())
[X[1,1]  X[1,2];
 X[1,2]  X[2,2]] ∈ PSDCone()</code></pre><p>Note that the lower triangular entries are ignored even if they are different so use it with caution:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, LinearAlgebra.Symmetric(X) &gt;= 0, PSDCone())
[X[1,1]  X[1,2];
 X[1,2]  X[2,2]] ∈ PSDCone()</code></pre><p>(Note the <code>(2, 1)</code> element of the constraint is <code>X[1,2]</code>, not <code>X[2,1]</code>.)</p><h2 id="Complementarity-constraints"><a class="docs-heading-anchor" href="#Complementarity-constraints">Complementarity constraints</a><a id="Complementarity-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Complementarity-constraints" title="Permalink"></a></h2><p>A mixed complementarity constraint <code>F(x) ⟂ x</code> consists of finding <code>x</code> in the interval <code>[lb, ub]</code>, such that the following holds:</p><ul><li><code>F(x) == 0</code> if <code>lb &lt; x &lt; ub</code></li><li><code>F(x) &gt;= 0</code> if <code>lb == x</code></li><li><code>F(x) &lt;= 0</code> if <code>x == ub</code></li></ul><p>JuMP supports mixed complementarity constraints via <code>complements(F(x), x)</code> or <code>F(x) ⟂ x</code> in the <a href="../../api/JuMP/#JuMP.@constraint"><code>@constraint</code></a> macro. The interval set <code>[lb, ub]</code> is obtained from the variable bounds on <code>x</code>.</p><p>For example, to define the problem <code>2x - 1 ⟂ x</code> with <code>x ∈ [0, ∞)</code>, do:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x &gt;= 0)
x

julia&gt; @constraint(model, 2x - 1 ⟂ x)
[2 x - 1, x] ∈ MathOptInterface.Complements(2)</code></pre><p>This problem has a unique solution at <code>x = 0.5</code>.</p><p>The perp operator <code>⟂</code> can be entered in most editors (and the Julia REPL) by typing <code>\perp&lt;tab&gt;</code>.</p><p>An alternative approach that does not require the <code>⟂</code> symbol uses the <code>complements</code> function as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, complements(2x - 1, x))
[2 x - 1, x] ∈ MathOptInterface.Complements(2)</code></pre><p>In both cases, the mapping <code>F(x)</code> is supplied as the first argument, and the matching variable <code>x</code> is supplied as the second.</p><p>Vector-valued complementarity constraints are also supported:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, -2 &lt;= y[1:2] &lt;= 2)
2-element Vector{VariableRef}:
 y[1]
 y[2]

julia&gt; M = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; q = [5, 6]
2-element Vector{Int64}:
 5
 6

julia&gt; @constraint(model, M * y + q ⟂ y)
[y[1] + 2 y[2] + 5, 3 y[1] + 4 y[2] + 6, y[1], y[2]] ∈ MathOptInterface.Complements(4)</code></pre><h2 id="Boolean-constraints"><a class="docs-heading-anchor" href="#Boolean-constraints">Boolean constraints</a><a id="Boolean-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Boolean-constraints" title="Permalink"></a></h2><p>Add a Boolean constraint (a <a href="../../moi/reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{Bool}</code></a> set) using the <code>:=</code> operator with a <code>Bool</code> right-hand side term:</p><pre><code class="language-julia-repl hljs">julia&gt; model = GenericModel{Bool}();

julia&gt; @variable(model, x[1:2]);

julia&gt; @constraint(model, x[1] || x[2] := true)
x[1] || x[2] = true

julia&gt; @constraint(model, x[1] &amp;&amp; x[2] := false)
x[1] &amp;&amp; x[2] = false

julia&gt; model
A JuMP Model
Feasibility problem with:
Variables: 2
`GenericNonlinearExpr{GenericVariableRef{Bool}}`-in-`MathOptInterface.EqualTo{Bool}`: 2 constraints
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.
Names registered in the model: x</code></pre><p>Boolean constraints should not be added using the <code>==</code> operator because JuMP will rewrite the constraint as <code>lhs - rhs = 0</code>, and because constraints like <code>a == b == c</code> require parentheses to disambiguate between <code>(a == b) == c</code> and <code>a == (b == c)</code>. In contrast, <code>a == b := c</code> is equivalent to <code>(a == b) := c</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; model = Model();

julia&gt; @variable(model, x[1:2]);

julia&gt; rhs = false
false

julia&gt; @constraint(model, (x[1] == x[2]) == rhs)
(x[1] == x[2]) - 0.0 = 0

julia&gt; @constraint(model, x[1] == x[2] := rhs)
x[1] == x[2] = false</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../variables/">« Variables</a><a class="docs-footer-nextpage" href="../expressions/">Expressions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 1 February 2024 23:47">Thursday 1 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
