<!DOCTYPE html><HTML class="no-js" lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Solver Callbacks — JuMP -- Julia for Mathematical Optimization 0.15 documentation</title><link href="_static/css/theme.css" rel="stylesheet" type="text/css"/><link href="index.html" rel="top" title="JuMP -- Julia for Mathematical Optimization 0.15 documentation"/><link href="nlp.html" rel="next" title="Nonlinear Modeling"/><link href="probmod.html" rel="prev" title="Problem Modification"/><script src="_static/js/modernizr.min.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body class="wy-body-for-nav" role="document"><div class="wy-grid-for-nav"><nav class="wy-nav-side" data-toggle="wy-nav-shift"><div class="wy-side-scroll"><div class="wy-side-nav-search"><a class="icon icon-home" href="index.html"> JuMP -- Julia for Mathematical Optimization
          

          
          </a><div class="version">
                0.15
              </div><div role="search"><form action="search.html" class="wy-form" id="rtd-search-form" method="get"><input name="q" placeholder="Search docs" type="text"/><input name="check_keywords" type="hidden" value="yes"/><input name="area" type="hidden" value="default"/></form></div></div><div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation"><ul class="current"><li class="toctree-l1"><a class="reference internal" href="installation.html">Installation Guide</a></li><li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quick Start Guide</a></li><li class="toctree-l1"><a class="reference internal" href="refmodel.html">Models</a></li><li class="toctree-l1"><a class="reference internal" href="refvariable.html">Variables</a></li><li class="toctree-l1"><a class="reference internal" href="refexpr.html">Expressions and Constraints</a></li><li class="toctree-l1"><a class="reference internal" href="probmod.html">Problem Modification</a></li><li class="toctree-l1 current"><a class="current reference internal" href="">Solver Callbacks</a><ul><li class="toctree-l2"><a class="reference internal" href="#lazy-constraints">Lazy Constraints</a></li><li class="toctree-l2"><a class="reference internal" href="#user-cuts">User Cuts</a></li><li class="toctree-l2"><a class="reference internal" href="#user-heuristics">User Heuristics</a></li><li class="toctree-l2"><a class="reference internal" href="#querying-solver-progress">Querying Solver Progress</a></li><li class="toctree-l2"><a class="reference internal" href="#informational-callbacks">Informational Callbacks</a></li><li class="toctree-l2"><a class="reference internal" href="#code-design-considerations">Code Design Considerations</a></li><li class="toctree-l2"><a class="reference internal" href="#exiting-a-callback-early">Exiting a callback early</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="nlp.html">Nonlinear Modeling</a></li></ul></div></div></nav><section class="wy-nav-content-wrap" data-toggle="wy-nav-shift"><nav aria-label="top navigation" class="wy-nav-top" role="navigation"><i class="fa fa-bars" data-toggle="wy-nav-top"></i><a href="index.html">JuMP -- Julia for Mathematical Optimization</a></nav><div class="wy-nav-content"><div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation"><ul class="wy-breadcrumbs"><li><a href="index.html">Docs</a> »</li><li>Solver Callbacks</li><li class="wy-breadcrumbs-aside"><a href="_sources/callbacks.txt" rel="nofollow"> View page source</a></li></ul><hr/></div><div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main"><div itemprop="articleBody"><div class="admonition warning" id="officialwarn"><p class="first admonition-title">Warning</p><p class="last">This documentation tracks the development branch of JuMP. For the documentation of the latest JuMP release, see <a href="http://www.juliaopt.org/JuMP.jl/0.14/">here</a>.</p></div><script type="text/javascript">
if(!(location.hostname.match('readthedocs') || location.hostname.match('rtfd'))){
    document.getElementById("officialwarn").style.display = 'none';
}
</script><div class="section" id="solver-callbacks"><h1>Solver Callbacks<a class="headerlink" href="#solver-callbacks" title="Permalink to this headline">¶</a></h1><p>Many mixed-integer (linear, conic, and nonlinear) programming solvers offer the ability to modify the solve process.
Examples include changing branching decisions in branch-and-bound, adding custom cutting planes, providing custom heuristics to find feasible solutions, or implementing on-demand separators to add new constraints only when they are violated by the current solution (also known as lazy constraints).</p><p>While historically this functionality has been limited to solver-specific interfaces,
JuMP provides <em>solver-independent</em> support for a number of commonly used solver callbacks. Currently, we support lazy constraints, user-provided cuts, and user-provided
heuristics for the Gurobi, CPLEX, GLPK, and SCIP solvers. We do not yet support any
other class of callbacks, but they may be accessible by using the solver’s
low-level interface.</p><div class="section" id="lazy-constraints"><h2>Lazy Constraints<a class="headerlink" href="#lazy-constraints" title="Permalink to this headline">¶</a></h2><p>Lazy constraints are useful when the full set of constraints is too large to
explicitly include in the initial formulation. When a MIP solver reaches a new
solution, for example with a heuristic or by solving a problem at a node in the
branch-and-bound tree, it will give the user the chance to provide constraint(s)
that would make the current solution infeasible. For some more information about
lazy constraints, see this blog post by <a class="reference external" href="http://orinanobworld.blogspot.com/2012/08/user-cuts-versus-lazy-constraints.html">Paul Rubin</a>.</p><p>There are three important steps to providing a lazy constraint callback. First we
must write a function that will analyze the current solution that takes a
single argument, e.g. <code class="docutils literal"><span class="pre">function</span><span class="pre">myLazyConGenerator(cb)</span></code>, where cb is a reference
to the callback management code inside JuMP. Next you will do whatever
analysis of the solution you need to inside your function to generate the new
constraint before adding it to the model with
<code class="docutils literal"><span class="pre">@lazyconstraint(cb,</span><span class="pre">myconstraint)</span></code>.
There is an optional keyword option <code class="docutils literal"><span class="pre">localcut</span></code> to <code class="docutils literal"><span class="pre">@lazyconstraint</span></code>, which indicates if the lazy constraint that will be added will only apply at the current node and the tree rooted at that node.
For example, <code class="docutils literal"><span class="pre">@lazyconstraint(cb,</span><span class="pre">myconstraint,</span><span class="pre">localcut=true)</span></code>. By default, <code class="docutils literal"><span class="pre">localcut</span></code> is set to <code class="docutils literal"><span class="pre">false</span></code>.
Finally we notify JuMP that this function should be used for lazy constraint
generation using the <code class="docutils literal"><span class="pre">addlazycallback(m,</span><span class="pre">myLazyConGenerator)</span></code> function
before we call <code class="docutils literal"><span class="pre">solve(m)</span></code>.</p><p>The following is a simple example to make this more clear. In this two-dimensional
problem we have a set of box constraints explicitly provided and a set of two
lazy constraints we can add on the fly. The solution without the lazy constraints
will be either (0,2) or (2,2), and the final solution will be (1,2):</p><div class="highlight-julia"><div class="highlight"><pre><span class="k">using</span><span class="n">JuMP</span><span class="k">using</span><span class="n">Gurobi</span><span class="c"># We will use Gurobi</span><span class="n">m</span><span class="o">=</span><span class="n">Model</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="n">GurobiSolver</span><span class="p">())</span><span class="c"># Define our variables to be inside a box, and integer</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span><span class="p">@</span><span class="n">objective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">Max</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="c"># We now define our callback function that takes one argument,</span><span class="c"># the callback handle. Note that we can access m, x, and y because</span><span class="c"># this function is defined inside the same scope</span><span class="k">function</span><span class="nf"> corners</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span><span class="n">x_val</span><span class="o">=</span><span class="n">getvalue</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="n">y_val</span><span class="o">=</span><span class="n">getvalue</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="n">println</span><span class="p">(</span><span class="s">"In callback function, x=</span><span class="si">$</span><span class="s">x_val, y=</span><span class="si">$</span><span class="s">y_val"</span><span class="p">)</span><span class="c"># We have two constraints, one cutting off the top</span><span class="c"># left corner and one cutting off the top right corner, e.g.</span><span class="c"># (0,2) +---+---+ (2,2)</span><span class="c">#       |xx/ \xx|</span><span class="c">#       |x/   \x|</span><span class="c">#       |/     \|</span><span class="c">#       +       +</span><span class="c">#       |       |</span><span class="c">#       |       |</span><span class="c">#       |       |</span><span class="c"># (0,0) +---+---+ (2,0)</span><span class="c"># Allow for some impreciseness in the solution</span><span class="n">TOL</span><span class="o">=</span><span class="mf">1e-6</span><span class="c"># Check top left, allowing some tolerance</span><span class="k">if</span><span class="n">y_val</span><span class="o">-</span><span class="n">x_val</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">+</span><span class="n">TOL</span><span class="c"># Cut off this solution</span><span class="n">println</span><span class="p">(</span><span class="s">"Solution was in top left, cut it off"</span><span class="p">)</span><span class="c"># Use the original variables, but not m - cb instead</span><span class="p">@</span><span class="n">lazyconstraint</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span><span class="n">y</span><span class="o">-</span><span class="n">x</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">)</span><span class="c"># Check top right</span><span class="k">elseif</span><span class="n">y_val</span><span class="o">+</span><span class="n">x_val</span><span class="o">&gt;</span><span class="mi">3</span><span class="o">+</span><span class="n">TOL</span><span class="c"># Cut off this solution</span><span class="n">println</span><span class="p">(</span><span class="s">"Solution was in top right, cut it off"</span><span class="p">)</span><span class="c"># Use the original variables, but not m - cb instead</span><span class="p">@</span><span class="n">lazyconstraint</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="n">x</span><span class="o">&lt;=</span><span class="mi">3</span><span class="p">)</span><span class="k">end</span><span class="k">end</span><span class="c"># End of callback function</span><span class="c"># Tell JuMP/Gurobi to use our callback function</span><span class="n">addlazycallback</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">corners</span><span class="p">)</span><span class="c"># Solve the problem</span><span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="c"># Print our final solution</span><span class="n">println</span><span class="p">(</span><span class="s">"Final solution: [ </span><span class="si">$</span><span class="s">(getvalue(x)), </span><span class="si">$</span><span class="s">(getvalue(y)) ]"</span><span class="p">)</span></pre></div></div><p>The code should print something like (amongst the output from Gurobi):</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">In</span><span class="n">callback</span><span class="n">function</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="mf">2.0</span><span class="n">Solution</span><span class="n">was</span><span class="k">in</span><span class="n">top</span><span class="n">right</span><span class="p">,</span><span class="n">cut</span><span class="n">it</span><span class="n">off</span><span class="n">In</span><span class="n">callback</span><span class="n">function</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="mf">2.0</span><span class="n">Solution</span><span class="n">was</span><span class="k">in</span><span class="n">top</span><span class="n">left</span><span class="p">,</span><span class="n">cut</span><span class="n">it</span><span class="n">off</span><span class="n">In</span><span class="n">callback</span><span class="n">function</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="mf">2.0</span><span class="n">Final</span><span class="n">solution</span><span class="p">:</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">]</span></pre></div></div><p>This code can also be found in <code class="docutils literal"><span class="pre">/JuMP/examples/simplelazy.jl</span></code>.</p><p>There is an optional <code class="docutils literal"><span class="pre">fractional</span></code> keyword option to <code class="docutils literal"><span class="pre">addlazycallback</span></code> which
indicates that the callback may be called at solutions that do not satisfy
integrality constraints. For example, <code class="docutils literal"><span class="pre">addlazycallback(m,</span><span class="pre">myLazyConGenerator,</span><span class="pre">fractional=true)</span></code>. Depending on the solver, this may invoke the callback
after solving each LP relaxation in the Branch and Bound tree. By default, <code class="docutils literal"><span class="pre">fractional</span></code> is set to <code class="docutils literal"><span class="pre">false</span></code>.</p></div><div class="section" id="user-cuts"><h2>User Cuts<a class="headerlink" href="#user-cuts" title="Permalink to this headline">¶</a></h2><p>User cuts, or simply cuts, provide a way for the user to tighten the LP relaxation using problem-specific knowledge that the solver cannot or is unable to infer from the model. Just like with lazy constraints, when a MIP solver reaches a new node in the branch-and-bound tree, it will give the user the chance to provide cuts to make the current relaxed (fractional) solution infeasible in the hopes of obtaining an integer solution. For more details about the difference between user cuts and lazy constraints see the aforementioned <a class="reference external" href="http://orinanobworld.blogspot.com/2012/08/user-cuts-versus-lazy-constraints.html">blog post</a>.</p><p>Your user cuts should not change the set of integer feasible solutions. Equivalently, your cuts can only remove fractional solutions - that is, “tighten” the LP relaxation of the MILP. If you add a cut that removes an integer solution, the solver may return an incorrect solution.</p><p>Adding a user cut callback is similar to adding a lazy constraint callback. First we
must write a function that will analyze the current solution that takes a
single argument, e.g. <code class="docutils literal"><span class="pre">function</span><span class="pre">myUserCutGenerator(cb)</span></code>, where cb is a reference
to the callback management code inside JuMP. Next you will do whatever
analysis of the solution you need to inside your function to generate the new
constraint before adding it to the model with the JuMP macro
<code class="docutils literal"><span class="pre">@usercut(cb,</span><span class="pre">myconstraint)</span></code> (same limitations as addConstraint).
There is an optional keyword option <code class="docutils literal"><span class="pre">localcut</span></code> to <code class="docutils literal"><span class="pre">@usercut</span></code>, which indicates if the user cut that will be added will only apply at the current node and the tree rooted at that node.
For example, <code class="docutils literal"><span class="pre">@usercut(cb,</span><span class="pre">myconstraint,</span><span class="pre">localcut=true)</span></code>. By default, <code class="docutils literal"><span class="pre">localcut</span></code> is set to <code class="docutils literal"><span class="pre">false</span></code>.
Finally we notify JuMP that this function should be used for user cut
generation using the <code class="docutils literal"><span class="pre">addcutcallback(m,</span><span class="pre">myUserCutGenerator)</span></code> function
before we call <code class="docutils literal"><span class="pre">solve(m)</span></code>.</p><p>Consider the following example which is related to the lazy constraint example. The problem is two-dimensional, and the objective sense prefers solution in the top-right of a 2-by-2 square. There is a single constraint that cuts off the top-right corner to make the LP relaxation solution fractional. We will exploit our knowledge of the problem structure to add a user cut that will make the LP relaxation integer, and thus solve the problem at the root node:</p><div class="highlight-julia"><div class="highlight"><pre><span class="k">using</span><span class="n">JuMP</span><span class="k">using</span><span class="n">Gurobi</span><span class="c"># We will use Gurobi, which requires that we manually set the attribute</span><span class="c"># PreCrush to 1 if we have user cuts. We will also disable PreSolve, Cuts,</span><span class="c"># and Heuristics so only our cut will be used</span><span class="n">m</span><span class="o">=</span><span class="n">Model</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="n">GurobiSolver</span><span class="p">(</span><span class="n">PreCrush</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">Cuts</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">Presolve</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">Heuristics</span><span class="o">=</span><span class="mf">0.0</span><span class="p">))</span><span class="c"># Define our variables to be inside a box, and integer</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span><span class="c"># Optimal solution is trying to go towards top-right corner (2.0, 2.0)</span><span class="p">@</span><span class="n">objective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">Max</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="n">y</span><span class="p">)</span><span class="c"># We have one constraint that cuts off the top right corner</span><span class="p">@</span><span class="n">constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="n">x</span><span class="o">&lt;=</span><span class="mf">3.5</span><span class="p">)</span><span class="c"># Optimal solution of relaxed problem will be (1.5, 2.0)</span><span class="c"># We can add a user cut that will cut of this fractional solution.</span><span class="c"># We now define our callback function that takes one argument,</span><span class="c"># the callback handle. Note that we can access m, x, and y because</span><span class="c"># this function is defined inside the same scope</span><span class="k">function</span><span class="nf"> mycutgenerator</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span><span class="n">x_val</span><span class="o">=</span><span class="n">getvalue</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="n">y_val</span><span class="o">=</span><span class="n">getvalue</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="n">println</span><span class="p">(</span><span class="s">"In callback function, x=</span><span class="si">$</span><span class="s">x_val, y=</span><span class="si">$</span><span class="s">y_val"</span><span class="p">)</span><span class="c"># Allow for some impreciseness in the solution</span><span class="n">TOL</span><span class="o">=</span><span class="mf">1e-6</span><span class="c"># Check top right</span><span class="k">if</span><span class="n">y_val</span><span class="o">+</span><span class="n">x_val</span><span class="o">&gt;</span><span class="mi">3</span><span class="o">+</span><span class="n">TOL</span><span class="c"># Cut off this solution</span><span class="n">println</span><span class="p">(</span><span class="s">"Fractional solution was in top right, cut it off"</span><span class="p">)</span><span class="c"># Use the original variables</span><span class="p">@</span><span class="n">usercut</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="n">x</span><span class="o">&lt;=</span><span class="mi">3</span><span class="p">)</span><span class="k">end</span><span class="k">end</span><span class="c"># End of callback function</span><span class="c"># Tell JuMP/Gurobi to use our callback function</span><span class="n">addcutcallback</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">mycutgenerator</span><span class="p">)</span><span class="c"># Solve the problem</span><span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="c"># Print our final solution</span><span class="n">println</span><span class="p">(</span><span class="s">"Final solution: [ </span><span class="si">$</span><span class="s">(getvalue(x)), </span><span class="si">$</span><span class="s">(getvalue(y)) ]"</span><span class="p">)</span></pre></div></div><p>The code should print something like (amongst the output from Gurobi):</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">In</span><span class="n">callback</span><span class="n">function</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="mf">2.0</span><span class="n">Fractional</span><span class="n">solution</span><span class="n">was</span><span class="k">in</span><span class="n">top</span><span class="n">right</span><span class="p">,</span><span class="n">cut</span><span class="n">it</span><span class="n">off</span><span class="n">In</span><span class="n">callback</span><span class="n">function</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="mf">2.0</span><span class="n">Final</span><span class="n">solution</span><span class="p">:</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">]</span></pre></div></div><p>This code can also be found in <code class="docutils literal"><span class="pre">/JuMP/examples/simpleusercut.jl</span></code>.</p></div><div class="section" id="user-heuristics"><h2>User Heuristics<a class="headerlink" href="#user-heuristics" title="Permalink to this headline">¶</a></h2><p>Integer programming solvers frequently include heuristics that run at the nodes of the branch-and-bound tree. They aim to find integer solutions quicker than plain branch-and-bound would to tighten the bound, allowing us to fathom nodes quicker and to tighten the integrality gap. Some heuristics take integer solutions and explore their “local neighborhood” (e.g. flipping binary variables, fix some variables and solve a smaller MILP, ...) and others take fractional solutions and attempt to round them in an intelligent way. You may want to add a heuristic of your own if you have some special insight into the problem structure that the solver is not aware of, e.g. you can consistently take fractional solutions and intelligently guess integer solutions from them.</p><p>The user heuristic callback is somewhat different from the previous two heuristics. The general concept is that we can create multiple partial solutions and submit them back to the solver - each solution must be submitted before a new solution is constructed. As before we provide a function that analyzes the current solution and takes a single argument, e.g. <code class="docutils literal"><span class="pre">function</span><span class="pre">myHeuristic(cb)</span></code>, where cb is a reference to the callback management code inside JuMP. You can build your solutions using <code class="docutils literal"><span class="pre">setsolutionvalue(cb,</span><span class="pre">x,</span><span class="pre">value)</span></code> and submit them with <code class="docutils literal"><span class="pre">addsolution(cb)</span></code>. Note that <code class="docutils literal"><span class="pre">addsolution</span></code> will “wipe” the previous (partial) solution. Notify JuMP that this function should be used as a heuristic using the <code class="docutils literal"><span class="pre">addheuristiccallback(m,</span><span class="pre">myHeuristic)</span></code> function before calling <code class="docutils literal"><span class="pre">solve(m)</span></code>.</p><p>There is some unavoidable (for performance reasons) solver-dependent behavior - you should check your solver documentation for details. For example: GLPK will not check the feasibility of your heuristic solution. If you need to submit many heuristic solutions in one callback, there may be performance impacts from the “wiping” behavior of <code class="docutils literal"><span class="pre">addsolution</span></code> - please file an issue and we can address this issue.</p><p>Consider the following example, which is the same problem as seen in the user cuts section. The heuristic simply rounds the fractional variable to generate integer solutions.:</p><div class="highlight-julia"><div class="highlight"><pre><span class="k">using</span><span class="n">JuMP</span><span class="k">using</span><span class="n">Gurobi</span><span class="c"># We will use Gurobi and disable PreSolve, Cuts, and (in-built) Heuristics so</span><span class="c"># only our heuristic will be used</span><span class="n">m</span><span class="o">=</span><span class="n">Model</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="n">GurobiSolver</span><span class="p">(</span><span class="n">Cuts</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">Presolve</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">Heuristics</span><span class="o">=</span><span class="mf">0.0</span><span class="p">))</span><span class="c"># Define our variables to be inside a box, and integer</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span><span class="c"># Optimal solution is trying to go towards top-right corner (2.0, 2.0)</span><span class="p">@</span><span class="n">objective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">Max</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="n">y</span><span class="p">)</span><span class="c"># We have one constraint that cuts off the top right corner</span><span class="p">@</span><span class="n">constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="n">x</span><span class="o">&lt;=</span><span class="mf">3.5</span><span class="p">)</span><span class="c"># Optimal solution of relaxed problem will be (1.5, 2.0)</span><span class="c"># We now define our callback function that takes one argument,</span><span class="c"># the callback handle. Note that we can access m, x, and y because</span><span class="c"># this function is defined inside the same scope</span><span class="k">function</span><span class="nf"> myheuristic</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span><span class="n">x_val</span><span class="o">=</span><span class="n">getvalue</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="n">y_val</span><span class="o">=</span><span class="n">getvalue</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="n">println</span><span class="p">(</span><span class="s">"In callback function, x=</span><span class="si">$</span><span class="s">x_val, y=</span><span class="si">$</span><span class="s">y_val"</span><span class="p">)</span><span class="n">setsolutionvalue</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">floor</span><span class="p">(</span><span class="n">x_val</span><span class="p">))</span><span class="c"># Leave y undefined - solver should handle as it sees fit. In the case</span><span class="c"># of Gurobi it will try to figure out what it should be.</span><span class="n">addsolution</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span><span class="c"># Submit a second solution</span><span class="n">setsolutionvalue</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">ceil</span><span class="p">(</span><span class="n">x_val</span><span class="p">))</span><span class="n">addsolution</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span><span class="k">end</span><span class="c"># End of callback function</span><span class="c"># Tell JuMP/Gurobi to use our callback function</span><span class="n">addheuristiccallback</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">myheuristic</span><span class="p">)</span><span class="c"># Solve the problem</span><span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="c"># Print our final solution</span><span class="n">println</span><span class="p">(</span><span class="s">"Final solution: [ </span><span class="si">$</span><span class="s">(getvalue(x)), </span><span class="si">$</span><span class="s">(getvalue(y)) ]"</span><span class="p">)</span></pre></div></div><p>The code should print something like:</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">In</span><span class="n">callback</span><span class="n">function</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="mf">2.0</span><span class="mi">0</span><span class="mi">0</span><span class="mf">5.50000</span><span class="mi">0</span><span class="mi">1</span><span class="o">-</span><span class="mf">5.50000</span><span class="o">-</span><span class="o">-</span><span class="mi">0</span><span class="n">s</span><span class="n">H</span><span class="mi">1</span><span class="mi">0</span><span class="mf">5.0000000</span><span class="mf">5.50000</span><span class="mf">10.0</span><span class="o">%</span><span class="mf">0.0</span><span class="mi">0</span><span class="n">s</span></pre></div></div><p>where the <code class="docutils literal"><span class="pre">H</span></code> denotes a solution found with a heuristic - our heuristic in this case. This code can also be found in <code class="docutils literal"><span class="pre">/JuMP/examples/simpleheur.jl</span></code>.</p></div><div class="section" id="querying-solver-progress"><h2>Querying Solver Progress<a class="headerlink" href="#querying-solver-progress" title="Permalink to this headline">¶</a></h2><p>All JuMP callback methods must take a single argument, called <code class="docutils literal"><span class="pre">cb</span></code> by convention.
<code class="docutils literal"><span class="pre">cb</span></code> is a handle to the internal callback system used by the underlying solver, and
allows the user to query solver state. There are a variety of methods available which
are listed in the <a class="reference external" href="http://mathprogbasejl.readthedocs.org/en/latest/lpqcqp.html#mip-callbacks">MathProgBase documentation</a>
including:</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">cbgetobj</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span><span class="n">cbgetbestbound</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span><span class="n">cbgetexplorednodes</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span><span class="n">cbgetstate</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span></pre></div></div></div><div class="section" id="informational-callbacks"><h2>Informational Callbacks<a class="headerlink" href="#informational-callbacks" title="Permalink to this headline">¶</a></h2><p>Sometimes it can be useful to track solver progress without actually changing the algorithm by adding cuts or heuristic solutions. In these cases, informational callbacks can be added, wherein statistics can be tracked via the <code class="docutils literal"><span class="pre">cbget</span></code> functions discussed in the previous section. Informational callbacks are added to a JuMP model with the <code class="docutils literal"><span class="pre">addinfocallback(m::Model,</span><span class="pre">f::Function;</span><span class="pre">when::Symbol)</span></code> function, where the <cite>when</cite> argument should be one of <code class="docutils literal"><span class="pre">:MIPNode</span></code>, <code class="docutils literal"><span class="pre">:MIPSol</span></code> or <code class="docutils literal"><span class="pre">:Intermediate</span></code> (listed under <code class="docutils literal"><span class="pre">cbgetstate()</span></code> in the <a class="reference external" href="https://mathprogbasejl.readthedocs.io/en/latest/lpqcqp.html#cbgetstate">MathProgBase documentation</a>)</p><p>For a simple example, we can add a function that tracks the best bound and incumbent objective value as the solver progresses through the branch-and-bound tree:</p><div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> NodeData</span><span class="n">time</span><span class="p">::</span><span class="kt">Float64</span><span class="c"># in seconds since the epoch</span><span class="n">node</span><span class="p">::</span><span class="kt">Int</span><span class="n">obj</span><span class="p">::</span><span class="kt">Float64</span><span class="n">bestbound</span><span class="p">::</span><span class="kt">Float64</span><span class="k">end</span><span class="c"># build model ``m`` up here</span><span class="n">bbdata</span><span class="o">=</span><span class="n">NodeData</span><span class="p">[]</span><span class="k">function</span><span class="nf"> infocallback</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span><span class="n">node</span><span class="o">=</span><span class="n">MathProgBase</span><span class="o">.</span><span class="n">cbgetexplorednodes</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span><span class="n">obj</span><span class="o">=</span><span class="n">MathProgBase</span><span class="o">.</span><span class="n">cbgetobj</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span><span class="n">bestbound</span><span class="o">=</span><span class="n">MathProgBase</span><span class="o">.</span><span class="n">cbgetbestbound</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span><span class="n">push!</span><span class="p">(</span><span class="n">bbdata</span><span class="p">,</span><span class="n">NodeData</span><span class="p">(</span><span class="n">time</span><span class="p">(),</span><span class="n">node</span><span class="p">,</span><span class="n">obj</span><span class="p">,</span><span class="n">bestbound</span><span class="p">))</span><span class="k">end</span><span class="n">addinfocallback</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">infocallback</span><span class="p">,</span><span class="n">when</span><span class="o">=</span><span class="p">:</span><span class="n">Intermediate</span><span class="p">)</span><span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="c"># Save results to file for analysis later</span><span class="n">open</span><span class="p">(</span><span class="s">"bbtrack.csv"</span><span class="p">,</span><span class="s">"w"</span><span class="p">)</span><span class="k">do</span><span class="n">fp</span><span class="n">println</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span><span class="s">"time,node,obj,bestbound"</span><span class="p">)</span><span class="k">for</span><span class="n">bb</span><span class="k">in</span><span class="n">bbdata</span><span class="n">println</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span><span class="n">bb</span><span class="o">.</span><span class="n">time</span><span class="p">,</span><span class="s">","</span><span class="p">,</span><span class="n">bb</span><span class="o">.</span><span class="n">node</span><span class="p">,</span><span class="s">","</span><span class="p">,</span><span class="n">bb</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="s">","</span><span class="p">,</span><span class="n">bb</span><span class="o">.</span><span class="n">bestbound</span><span class="p">)</span><span class="k">end</span><span class="k">end</span></pre></div></div><p>For a second example, we can add a function that tracks the intermediate solutions at each integer-feasible solution in the Branch-and-Bound tree:</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">solutionvalues</span><span class="o">=</span><span class="n">Vector</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}[]</span><span class="c"># build model ``m`` up here</span><span class="k">function</span><span class="nf"> infocallback</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span><span class="n">push!</span><span class="p">(</span><span class="n">solutionvalues</span><span class="p">,</span><span class="n">JuMP</span><span class="o">.</span><span class="n">getvalue</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="k">end</span><span class="n">addinfocallback</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">infocallback</span><span class="p">,</span><span class="n">when</span><span class="o">=</span><span class="p">:</span><span class="n">MIPSol</span><span class="p">)</span><span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="c"># all the intermediate solutions are now stored in `solutionvalues`</span></pre></div></div></div><div class="section" id="code-design-considerations"><h2>Code Design Considerations<a class="headerlink" href="#code-design-considerations" title="Permalink to this headline">¶</a></h2><p>In the above examples the callback function is defined in the same scope as the model and variable definitions, allowing us to access them. If we defined the function in some other scope, or even file, we would not be able to access them directly. The proposed solution to this design problem is to separate the logic of analyzing the current solution values from the callback itself. This has many benefits, including writing unit tests for the callback function to check its correctness. The callback function passed to JuMP is then simply a stub that extracts the current solution and any other relevant information and passes that to the constraint generation logic. To apply this to our previous lazy constraint example, consider the following code:</p><div class="highlight-julia"><div class="highlight"><pre><span class="k">using</span><span class="n">JuMP</span><span class="k">using</span><span class="n">Gurobi</span><span class="k">using</span><span class="n">Base</span><span class="o">.</span><span class="n">Test</span><span class="k">function</span><span class="nf"> cornerChecker</span><span class="p">(</span><span class="n">x_val</span><span class="p">,</span><span class="n">y_val</span><span class="p">)</span><span class="c"># This function does not depend on the model, and could</span><span class="c"># be written anywhere. Instead, it returns a tuple of</span><span class="c"># values (newcut, x_coeff, y_coeff, rhs) where newcut is a</span><span class="c"># boolean if a cut is needed, x_coeff is the coefficient</span><span class="c"># on the x variable, y_coeff is the coefficient on</span><span class="c"># the y variable, and rhs is the right hand side</span><span class="n">TOL</span><span class="o">=</span><span class="mf">1e-6</span><span class="k">if</span><span class="n">y_val</span><span class="o">-</span><span class="n">x_val</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">+</span><span class="n">TOL</span><span class="k">return</span><span class="p">(</span><span class="n">true</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span><span class="c"># Top left</span><span class="k">elseif</span><span class="n">y_val</span><span class="o">+</span><span class="n">x_val</span><span class="o">&gt;</span><span class="mi">3</span><span class="o">+</span><span class="n">TOL</span><span class="k">return</span><span class="p">(</span><span class="n">true</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">)</span><span class="c"># Top right</span><span class="k">else</span><span class="k">return</span><span class="p">(</span><span class="n">false</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span><span class="c"># No cut</span><span class="k">end</span><span class="k">end</span><span class="c"># A unit test for the cornerChecker function</span><span class="k">function</span><span class="nf"> test_cornerChecker</span><span class="p">()</span><span class="c"># Test the four corners - only two should produce cuts</span><span class="n">newcut</span><span class="p">,</span><span class="n">x_coeff</span><span class="p">,</span><span class="n">y_coeff</span><span class="p">,</span><span class="n">rhs</span><span class="o">=</span><span class="n">cornerChecker</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="p">@</span><span class="n">test</span><span class="o">!</span><span class="n">newcut</span><span class="n">newcut</span><span class="p">,</span><span class="n">x_coeff</span><span class="p">,</span><span class="n">y_coeff</span><span class="p">,</span><span class="n">rhs</span><span class="o">=</span><span class="n">cornerChecker</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="p">@</span><span class="n">test</span><span class="o">!</span><span class="n">newcut</span><span class="n">newcut</span><span class="p">,</span><span class="n">x_coeff</span><span class="p">,</span><span class="n">y_coeff</span><span class="p">,</span><span class="n">rhs</span><span class="o">=</span><span class="n">cornerChecker</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="p">@</span><span class="n">test</span><span class="n">newcut</span><span class="p">@</span><span class="n">test</span><span class="n">x_coeff</span><span class="o">==</span><span class="o">-</span><span class="mf">1.0</span><span class="p">@</span><span class="n">test</span><span class="n">y_coeff</span><span class="o">==</span><span class="mf">1.0</span><span class="p">@</span><span class="n">test</span><span class="n">rhs</span><span class="o">==</span><span class="mf">1.0</span><span class="n">newcut</span><span class="p">,</span><span class="n">x_coeff</span><span class="p">,</span><span class="n">y_coeff</span><span class="p">,</span><span class="n">rhs</span><span class="o">=</span><span class="n">cornerChecker</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="p">@</span><span class="n">test</span><span class="n">newcut</span><span class="p">@</span><span class="n">test</span><span class="n">x_coeff</span><span class="o">==</span><span class="mf">1.0</span><span class="p">@</span><span class="n">test</span><span class="n">y_coeff</span><span class="o">==</span><span class="mf">1.0</span><span class="p">@</span><span class="n">test</span><span class="n">rhs</span><span class="o">==</span><span class="mf">3.0</span><span class="k">end</span><span class="k">function</span><span class="nf"> solveProblem</span><span class="p">()</span><span class="n">m</span><span class="o">=</span><span class="n">Model</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="n">GurobiSolver</span><span class="p">())</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span><span class="p">@</span><span class="n">objective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">Max</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="c"># Note that the callback is now a stub that passes off</span><span class="c"># the work to the "algorithm"</span><span class="k">function</span><span class="nf"> corners</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span><span class="n">x_val</span><span class="o">=</span><span class="n">getvalue</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="n">y_val</span><span class="o">=</span><span class="n">getvalue</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="n">println</span><span class="p">(</span><span class="s">"In callback function, x=</span><span class="si">$</span><span class="s">x_val, y=</span><span class="si">$</span><span class="s">y_val"</span><span class="p">)</span><span class="n">newcut</span><span class="p">,</span><span class="n">x_coeff</span><span class="p">,</span><span class="n">y_coeff</span><span class="p">,</span><span class="n">rhs</span><span class="o">=</span><span class="n">cornerChecker</span><span class="p">(</span><span class="n">x_val</span><span class="p">,</span><span class="n">y_val</span><span class="p">)</span><span class="k">if</span><span class="n">newcut</span><span class="p">@</span><span class="n">lazyconstraint</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span><span class="n">x_coeff</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y_coeff</span><span class="o">*</span><span class="n">y</span><span class="o">&lt;=</span><span class="n">rhs</span><span class="p">)</span><span class="k">end</span><span class="k">end</span><span class="c"># End of callback function</span><span class="n">addlazycallback</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">corners</span><span class="p">)</span><span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="n">println</span><span class="p">(</span><span class="s">"Final solution: [ </span><span class="si">$</span><span class="s">(getvalue(x)), </span><span class="si">$</span><span class="s">(getvalue(y)) ]"</span><span class="p">)</span><span class="k">end</span><span class="c"># Run tests</span><span class="n">test_cornerChecker</span><span class="p">()</span><span class="c"># Solve it</span><span class="n">solveProblem</span><span class="p">()</span></pre></div></div><p>This code can also be found in <code class="docutils literal"><span class="pre">/JuMP/examples/simplelazy2.jl</span></code>.</p></div><div class="section" id="exiting-a-callback-early"><h2>Exiting a callback early<a class="headerlink" href="#exiting-a-callback-early" title="Permalink to this headline">¶</a></h2><p>If you need to exit the optimization process earlier than a solver otherwise would, it is possible to return <code class="docutils literal"><span class="pre">JuMP.StopTheSolver</span></code> from the callback code:</p><div class="highlight-julia"><div class="highlight"><pre><span class="k">return</span><span class="n">JuMP</span><span class="o">.</span><span class="n">StopTheSolver</span></pre></div></div><p>This will trigger the solver to exit immediately and return a <code class="docutils literal"><span class="pre">:UserLimit</span></code> status.</p></div></div></div></div><footer><div aria-label="footer navigation" class="rst-footer-buttons" role="navigation"><a accesskey="n" class="btn btn-neutral float-right" href="nlp.html" title="Nonlinear Modeling">Next <span class="fa fa-arrow-circle-right"></span></a><a accesskey="p" class="btn btn-neutral" href="probmod.html" title="Problem Modification"><span class="fa fa-arrow-circle-left"></span> Previous</a></div><hr/><div role="contentinfo"><p>
        © Copyright 2016, Miles Lubin, Iain Dunning, and Joey Huchette.

    </p></div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer></div></div></section></div><script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.15',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script><script src="_static/jquery.js" type="text/javascript"></script><script src="_static/underscore.js" type="text/javascript"></script><script src="_static/doctools.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script src="_static/js/theme.js" type="text/javascript"></script><script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script><script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview');
</script><script async="" src="https://www.google-analytics.com/analytics.js"></script></body></HTML>