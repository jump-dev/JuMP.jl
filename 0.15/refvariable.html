<!DOCTYPE html><HTML class="no-js" lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Variables — JuMP -- Julia for Mathematical Optimization 0.15 documentation</title><link href="_static/css/theme.css" rel="stylesheet" type="text/css"/><link href="index.html" rel="top" title="JuMP -- Julia for Mathematical Optimization 0.15 documentation"/><link href="refexpr.html" rel="next" title="Expressions and Constraints"/><link href="refmodel.html" rel="prev" title="Models"/><script src="_static/js/modernizr.min.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body class="wy-body-for-nav" role="document"><div class="wy-grid-for-nav"><nav class="wy-nav-side" data-toggle="wy-nav-shift"><div class="wy-side-scroll"><div class="wy-side-nav-search"><a class="icon icon-home" href="index.html"> JuMP -- Julia for Mathematical Optimization
          

          
          </a><div class="version">
                0.15
              </div><div role="search"><form action="search.html" class="wy-form" id="rtd-search-form" method="get"><input name="q" placeholder="Search docs" type="text"/><input name="check_keywords" type="hidden" value="yes"/><input name="area" type="hidden" value="default"/></form></div></div><div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation"><ul class="current"><li class="toctree-l1"><a class="reference internal" href="installation.html">Installation Guide</a></li><li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quick Start Guide</a></li><li class="toctree-l1"><a class="reference internal" href="refmodel.html">Models</a></li><li class="toctree-l1 current"><a class="current reference internal" href="">Variables</a><ul><li class="toctree-l2"><a class="reference internal" href="#constructors">Constructors</a></li><li class="toctree-l2"><a class="reference internal" href="#anonymous-variables">Anonymous variables</a></li><li class="toctree-l2"><a class="reference internal" href="#semidefinite-and-symmetric-variables">Semidefinite and symmetric variables</a></li><li class="toctree-l2"><a class="reference internal" href="#variables-blocks"><code class="docutils literal"><span class="pre">@variables</span></code> blocks</a></li><li class="toctree-l2"><a class="reference internal" href="#methods">Methods</a></li><li class="toctree-l2"><a class="reference internal" href="#fixed-variables">Fixed variables</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="refexpr.html">Expressions and Constraints</a></li><li class="toctree-l1"><a class="reference internal" href="probmod.html">Problem Modification</a></li><li class="toctree-l1"><a class="reference internal" href="callbacks.html">Solver Callbacks</a></li><li class="toctree-l1"><a class="reference internal" href="nlp.html">Nonlinear Modeling</a></li></ul></div></div></nav><section class="wy-nav-content-wrap" data-toggle="wy-nav-shift"><nav aria-label="top navigation" class="wy-nav-top" role="navigation"><i class="fa fa-bars" data-toggle="wy-nav-top"></i><a href="index.html">JuMP -- Julia for Mathematical Optimization</a></nav><div class="wy-nav-content"><div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation"><ul class="wy-breadcrumbs"><li><a href="index.html">Docs</a> »</li><li>Variables</li><li class="wy-breadcrumbs-aside"><a href="_sources/refvariable.txt" rel="nofollow"> View page source</a></li></ul><hr/></div><div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main"><div itemprop="articleBody"><div class="admonition warning" id="officialwarn"><p class="first admonition-title">Warning</p><p class="last">This documentation tracks the development branch of JuMP. For the documentation of the latest JuMP release, see <a href="http://www.juliaopt.org/JuMP.jl/0.14/">here</a>.</p></div><script type="text/javascript">
if(!(location.hostname.match('readthedocs') || location.hostname.match('rtfd'))){
    document.getElementById("officialwarn").style.display = 'none';
}
</script><div class="section" id="variables"><h1>Variables<a class="headerlink" href="#variables" title="Permalink to this headline">¶</a></h1><p>Variables, also known as columns or decision variables, are the results of the optimization.</p><div class="section" id="constructors"><h2>Constructors<a class="headerlink" href="#constructors" title="Permalink to this headline">¶</a></h2><p>The primary way to create variables is with the <code class="docutils literal"><span class="pre">@variable</span></code> macro.
The first argument will always be a <code class="docutils literal"><span class="pre">Model</span></code>. In the examples below we assume
<code class="docutils literal"><span class="pre">m</span></code> is already defined. The second argument is an expression that declares
the variable name and optionally allows specification of lower and upper bounds.
Adding variables “column-wise”, e.g., as in column generation, is supported as well;
see the syntax discussed in the <span class="xref std std-ref">probmod</span> section.</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="c"># No bounds</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">lb</span><span class="p">)</span><span class="c"># Lower bound only (note: 'lb &lt;= x' is not valid)</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">ub</span><span class="p">)</span><span class="c"># Upper bound only</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">lb</span><span class="o">&lt;=</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">ub</span><span class="p">)</span><span class="c"># Lower and upper bounds</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="o">==</span><span class="n">fixedval</span><span class="p">)</span><span class="c"># Fixed to a value (lb == ub)</span></pre></div></div><p>All these variations create a new local variable, in this case <code class="docutils literal"><span class="pre">x</span></code>.
The names of your variables must be valid Julia variable names.
Integer and binary restrictions can optionally be specified with a third argument, <code class="docutils literal"><span class="pre">Int</span></code> or <code class="docutils literal"><span class="pre">Bin</span></code>.
For advanced users, <code class="docutils literal"><span class="pre">SemiCont</span></code> and <code class="docutils literal"><span class="pre">SemiInt</span></code> may be used to create
<a class="reference external" href="http://orinanobworld.blogspot.com/2011/03/semicontinuous-variables.html">semicontinuous</a> or
<a class="reference external" href="http://www.gams.com/help/topic/gams.doc/userguides/mccarl/semi-integer_variables.htm">semi-integer</a> variables,
respectively.</p><p>To create arrays of variables we append brackets to the variable name.</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">M</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span></pre></div></div><p>will create an <code class="docutils literal"><span class="pre">M</span></code> by <code class="docutils literal"><span class="pre">N</span></code> array of variables. Both ranges and arbitrary
iterable sets are supported as index sets. Currently we only support ranges
of the form <code class="docutils literal"><span class="pre">a:b</span></code> where <code class="docutils literal"><span class="pre">a</span></code> is an explicit integer, not a variable. Using
ranges will generally be faster than using arbitrary symbols. You can mix both
ranges and lists of symbols, as in the following example:</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">s</span><span class="o">=</span><span class="p">[</span><span class="s">"Green"</span><span class="p">,</span><span class="s">"Blue"</span><span class="p">]</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="n">s</span><span class="p">]</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="s">"Green"</span><span class="p">]</span></pre></div></div><p>Bounds can depend on variable indices:</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">i</span><span class="p">)</span></pre></div></div><p>And indices can have dependencies on preceding indices (e.g. “triangular indexing”):</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span></pre></div></div><p>Note the dependency must be on preceding indices, going from left to right. That is,
<code class="docutils literal"><span class="pre">@variable(m,</span><span class="pre">x[i=j:10,i=1:10]</span><span class="pre">&gt;=</span><span class="pre">0)</span></code> is not valid JuMP code.</p><p>Conditions can be placed on the index values for which variables are created; the condition follows the statement of the index sets and is separated with a semicolon:</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">;</span><span class="n">isodd</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)]</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span></pre></div></div><p>Note that only one condition can be added, although expressions can be built up by using the usual <code class="docutils literal"><span class="pre">&amp;&amp;</span></code> and <code class="docutils literal"><span class="pre">||</span></code> logical operators. <strong>This condition syntax requires Julia 0.4 or later.</strong></p><p>An initial value of each variable may be provided with the <code class="docutils literal"><span class="pre">start</span></code> keyword to <code class="docutils literal"><span class="pre">@variable</span></code>:</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">],</span><span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span></pre></div></div><p>Is equivalent to:</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span><span class="k">for</span><span class="n">i</span><span class="k">in</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="n">setvalue</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="k">end</span></pre></div></div><p>For more complicated variable bounds, it may be clearer to specify them using the <code class="docutils literal"><span class="pre">lowerbound</span></code> and <code class="docutils literal"><span class="pre">upperbound</span></code> keyword arguments to <code class="docutils literal"><span class="pre">@variable</span></code>:</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="n">lowerbound</span><span class="o">=</span><span class="n">my_complex_function</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="n">lowerbound</span><span class="o">=</span><span class="n">my_complex_function</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">upperbound</span><span class="o">=</span><span class="n">another_function</span><span class="p">(</span><span class="n">i</span><span class="p">))</span></pre></div></div><p>The constructor <code class="docutils literal"><span class="pre">Variable(m::Model,idx::Int)</span></code> may be used to create a variable object corresponding to an <em>existing</em> variable in the model (the constructor does not add a new variable to the model). The variable indices correspond to those of the internal MathProgBase model. The inverse of this operation is <code class="docutils literal"><span class="pre">linearindex(x::Variable)</span></code>, which returns the flattened out (linear) index of a variable as JuMP provides it to a solver. We guarantee that <code class="docutils literal"><span class="pre">Variable(m,linearindex(x))</span></code> returns <code class="docutils literal"><span class="pre">x</span></code> itself. These methods are only useful if you intend to interact with solver properties which are not directly exposed through JuMP.</p><div class="admonition note"><p class="first admonition-title">Note</p><p><code class="docutils literal"><span class="pre">@variable</span></code> is equivalent to a simple assignment <code class="docutils literal"><span class="pre">x</span><span class="pre">=</span><span class="pre">...</span></code> in Julia and therefore redefines variables. The following code will generate a warning and may lead to unexpected results:</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span></pre></div></div><p class="last">After the second line, the Julia variable <code class="docutils literal"><span class="pre">x</span></code> refers to a set of variables indexed
by the range <code class="docutils literal"><span class="pre">1:5</span></code>.
The reference to the first set of variables has been lost, although they will remain
in the model. See also the section on anonymous variables.</p></div></div><div class="section" id="anonymous-variables"><h2>Anonymous variables<a class="headerlink" href="#anonymous-variables" title="Permalink to this headline">¶</a></h2><p>We also provide a syntax for constructing “anonymous” variables.
In <code class="docutils literal"><span class="pre">@variable</span></code>, you may omit the name of the variable
and instead assign the return value as you would like:</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">x</span><span class="o">=</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="c"># Equivalent to @variable(m, x)</span><span class="n">x</span><span class="o">=</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="n">lowerbound</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">upperbound</span><span class="o">=</span><span class="mi">2</span><span class="n">i</span><span class="p">)</span><span class="c"># Equivalent to @variable(m, i &lt;= x[i=1:3] &lt;= 2i)</span></pre></div></div><p>The <code class="docutils literal"><span class="pre">lowerbound</span></code> and <code class="docutils literal"><span class="pre">upperbound</span></code> must be used instead of comparison operators for specifying variable bounds within the anonymous syntax. The <strong>only</strong> differences between anonymous and named variables are:</p><blockquote><div><ol class="arabic simple"><li>For the purposes of printing a model, JuMP will not have a name for anonymous variables and will instead use <code class="docutils literal"><span class="pre">__anon__</span></code>. You may set the name of a variable for printing by using <code class="docutils literal"><span class="pre">setname</span></code> or the <code class="docutils literal"><span class="pre">basename</span></code> keyword argument described below.</li><li>Anonymous variables cannot be retrieved by using <code class="docutils literal"><span class="pre">getvariable</span></code>.</li></ol></div></blockquote><p>If you would like to change the name used when printing a variable or group of variables, you may use the <code class="docutils literal"><span class="pre">basename</span></code> keyword argument:</p><div class="highlight-julia"><div class="highlight"><pre><span class="n">i</span><span class="o">=</span><span class="mi">3</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="n">basename</span><span class="o">=</span><span class="s">"myvariable-</span><span class="si">$</span><span class="s">i"</span><span class="p">)</span><span class="c"># OR:</span><span class="n">x</span><span class="o">=</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="n">basename</span><span class="o">=</span><span class="s">"myvariable-</span><span class="si">$</span><span class="s">i"</span><span class="p">)</span></pre></div></div><p>Printing <code class="docutils literal"><span class="pre">x[2]</span></code> will display <code class="docutils literal"><span class="pre">myvariable-3[2]</span></code>.</p></div><div class="section" id="semidefinite-and-symmetric-variables"><h2>Semidefinite and symmetric variables<a class="headerlink" href="#semidefinite-and-symmetric-variables" title="Permalink to this headline">¶</a></h2><p>JuMP supports modeling with <a class="reference external" href="https://en.wikipedia.org/wiki/Semidefinite_programming">semidefinite variables</a>. A square symmetric matrix <span class="math">\(X\)</span> is positive semidefinite if all eigenvalues are nonnegative; this is typically denoted by <span class="math">\(X \succeq 0\)</span>. You can declare a matrix of variables to be positive semidefinite as follows:</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="n">SDP</span><span class="p">)</span></pre></div></div><p>Note in particular the indexing: 1) exactly two index sets must be specified, 2) they must both be unit ranges starting at 1, 3) no bounds can be provided alongside the <code class="docutils literal"><span class="pre">SDP</span></code> tag. If you wish to impose more complex semidefinite constraints on the variables, e.g. <span class="math">\(X - I \succeq 0\)</span>, you may instead use the <code class="docutils literal"><span class="pre">Symmetric</span></code> tag, along with a semidefinite constraint:</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">],</span><span class="n">Symmetric</span><span class="p">)</span><span class="p">@</span><span class="n">SDconstraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">X</span><span class="o">&gt;=</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">))</span></pre></div></div><p>Bounds can be provided as normal when using the <code class="docutils literal"><span class="pre">Symmetric</span></code> tag, with the stipulation that the bounds are symmetric themselves.</p></div><div class="section" id="variables-blocks"><h2><code class="docutils literal"><span class="pre">@variables</span></code> blocks<a class="headerlink" href="#variables-blocks" title="Permalink to this headline">¶</a></h2><p>JuMP provides a convenient syntax for defining multiple variables
in a single block:</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">variables</span><span class="n">m</span><span class="k">begin</span><span class="n">x</span><span class="n">y</span><span class="o">&gt;=</span><span class="mi">0</span><span class="n">Z</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">],</span><span class="n">Bin</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="n">SDP</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span><span class="p">(</span><span class="n">lowerbound</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">start</span><span class="o">=</span><span class="mi">2</span><span class="n">i</span><span class="p">,</span><span class="n">upperbound</span><span class="o">=</span><span class="mi">3</span><span class="n">i</span><span class="p">)</span><span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="n">start</span><span class="o">=</span><span class="n">j</span><span class="p">)</span><span class="k">end</span><span class="c"># Equivalent to:</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">Z</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">],</span><span class="n">Bin</span><span class="p">)</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="n">SDP</span><span class="p">)</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span><span class="n">lowerbound</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">start</span><span class="o">=</span><span class="mi">2</span><span class="n">i</span><span class="p">,</span><span class="n">upperbound</span><span class="o">=</span><span class="mi">3</span><span class="n">i</span><span class="p">)</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="kt">Int</span><span class="p">,</span><span class="n">start</span><span class="o">=</span><span class="n">j</span><span class="p">)</span></pre></div></div><p>The syntax follows that of <code class="docutils literal"><span class="pre">@variable</span></code> with each declaration separated
by a new line. Note that unlike in <code class="docutils literal"><span class="pre">@variable</span></code>, keyword arguments must be specified within
parentheses.</p></div><div class="section" id="methods"><h2>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h2><p><strong>Bounds</strong></p><ul class="simple"><li><code class="docutils literal"><span class="pre">setlowerbound(x::Variable,</span><span class="pre">lower)</span></code>, <code class="docutils literal"><span class="pre">getlowerbound(x::Variable)</span></code> - Set/get the lower bound of a variable.</li><li><code class="docutils literal"><span class="pre">setupperbound(x::Variable,</span><span class="pre">upper)</span></code>, <code class="docutils literal"><span class="pre">getupperbound(x::Variable)</span></code> - Set/get the upper bound of a variable.</li></ul><p><strong>Variable Category</strong></p><ul class="simple"><li><code class="docutils literal"><span class="pre">setcategory(x::Variable,</span><span class="pre">v_type::Symbol)</span></code> - Set the variable category for <code class="docutils literal"><span class="pre">x</span></code> after construction. Possible categories are listed above.</li><li><code class="docutils literal"><span class="pre">getcategory(x::Variable)</span></code> - Get the variable category for <code class="docutils literal"><span class="pre">x</span></code>.</li></ul><p><strong>Helper functions</strong></p><ul class="simple"><li><code class="docutils literal"><span class="pre">sum(x)</span></code> - Operates on arrays of variables, efficiently produces an affine expression. Available in macros.</li><li><code class="docutils literal"><span class="pre">dot(x,</span><span class="pre">coeffs)</span></code> - Performs a generalized “dot product” for arrays of variables and coefficients up to three dimensions, or equivalently the sum of the elements of the Hadamard product. Available in macros, and also as <code class="docutils literal"><span class="pre">dot(coeffs,</span><span class="pre">x)</span></code>.</li></ul><p><strong>Values</strong></p><ul class="simple"><li><code class="docutils literal"><span class="pre">getvalue(x)</span></code> - Get the value of this variable in the solution. If <code class="docutils literal"><span class="pre">x</span></code> is a single variable, this will simply return a number.
If <code class="docutils literal"><span class="pre">x</span></code> is indexable then it will return an indexable dictionary of values. When the model is unbounded, <code class="docutils literal"><span class="pre">getvalue</span></code> will
instead return the corresponding components of an unbounded ray, if available from the solver.</li><li><code class="docutils literal"><span class="pre">setvalue(x,v)</span></code> - Provide an initial value <code class="docutils literal"><span class="pre">v</span></code> for this variable that can be used by supporting MILP solvers. If <code class="docutils literal"><span class="pre">v</span></code> is <code class="docutils literal"><span class="pre">NaN</span></code>, the solver may attempt to fill in this value to construct a feasible solution.</li><li><code class="docutils literal"><span class="pre">getdual(x)</span></code> - Get the reduced cost of this variable in the solution. Similar behavior to <code class="docutils literal"><span class="pre">getvalue</span></code> for indexable variables.</li></ul><div class="admonition note"><p class="first admonition-title">Note</p><p class="last">The <code class="docutils literal"><span class="pre">getvalue</span></code> function always returns a floating-point value, even when a variable is constrained to take integer values, as most solvers only guarantee integrality up to a particular numerical tolerance. The built-in <code class="docutils literal"><span class="pre">round</span></code> function should be used to obtain integer values, e.g., by calling <code class="docutils literal"><span class="pre">round(Integer,</span><span class="pre">getvalue(x))</span></code>.</p></div><p><strong>Names</strong></p><p>Variables (in the sense of columns) can have internal names (different from the Julia variable name) that can be used for writing models to file. This feature is disabled for performance reasons, but will be added if there is demand or a special use case.</p><ul class="simple"><li><code class="docutils literal"><span class="pre">setname(x::Variable,</span><span class="pre">newName)</span></code>, <code class="docutils literal"><span class="pre">getname(x::Variable)</span></code> - Set/get the variable’s internal name.</li></ul></div><div class="section" id="fixed-variables"><h2>Fixed variables<a class="headerlink" href="#fixed-variables" title="Permalink to this headline">¶</a></h2><p><cite>Fixed</cite> variables, created with the <code class="docutils literal"><span class="pre">x</span><span class="pre">==</span><span class="pre">fixedval</span></code> syntax, have slightly special
semantics. First, it is important to note that fixed variables are considered
optimization variables, not constants, for the purpose of determining the problem
class. For example, in:</p><div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="o">==</span><span class="mi">5</span><span class="p">)</span><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="p">@</span><span class="n">constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">&lt;=</span><span class="mi">10</span><span class="p">)</span></pre></div></div><p>the constraint added is a nonconvex quadratic constraint. For efficiency reasons,
JuMP will <em>not</em> substitute the constant <code class="docutils literal"><span class="pre">5</span></code> for <code class="docutils literal"><span class="pre">x</span></code> and then
provide the resulting <em>linear</em> constraint to the solver.
Two possible uses for fixed variables are:</p><ol class="arabic simple"><li>For computing sensitivities. When available from the solver,
the sensitivity of the objective with respect to the fixed value may be queried with <code class="docutils literal"><span class="pre">getdual(x)</span></code>.</li><li>For solving a sequence of problems with varying parameters.
One may call <code class="docutils literal"><span class="pre">setvalue(x,</span><span class="pre">val)</span></code>
to change the value to which the variable is fixed. For LPs
in particular, most solvers are able to efficiently hot-start when
solving the resulting modified problem.</li></ol></div></div></div></div><footer><div aria-label="footer navigation" class="rst-footer-buttons" role="navigation"><a accesskey="n" class="btn btn-neutral float-right" href="refexpr.html" title="Expressions and Constraints">Next <span class="fa fa-arrow-circle-right"></span></a><a accesskey="p" class="btn btn-neutral" href="refmodel.html" title="Models"><span class="fa fa-arrow-circle-left"></span> Previous</a></div><hr/><div role="contentinfo"><p>
        © Copyright 2016, Miles Lubin, Iain Dunning, and Joey Huchette.

    </p></div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer></div></div></section></div><script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.15',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script><script src="_static/jquery.js" type="text/javascript"></script><script src="_static/underscore.js" type="text/javascript"></script><script src="_static/doctools.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script src="_static/js/theme.js" type="text/javascript"></script><script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script><script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview');
</script><script async="" src="https://www.google-analytics.com/analytics.js"></script></body></HTML>