<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Models · JuMP</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-44252521-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-44252521-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img class="docs-light-only" src="../../../assets/logo.svg" alt="JuMP logo"/><img class="docs-dark-only" src="../../../assets/logo-dark.svg" alt="JuMP logo"/></a><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../">Introduction</a></li><li><a class="tocitem" href="../../../should_i_use/">Should I use JuMP?</a></li><li><a class="tocitem" href="../../../installation/">Installation Guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/getting_started/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/getting_started_with_julia/">Getting started with Julia</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/getting_started_with_JuMP/">Getting started with JuMP</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/getting_started_with_sets_and_indexing/">Getting started with sets and indexing</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/getting_started_with_data_and_plotting/">Getting started with data and plotting</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/performance_tips/">Performance tips</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/design_patterns_for_larger_models/">Design patterns for larger models</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Linear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/linear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../tutorials/linear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../../tutorials/linear/diet/">The diet problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/facility_location/">The facility location problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../../../tutorials/linear/finance/">Financial modeling problems</a></li><li><a class="tocitem" href="../../../tutorials/linear/geographic_clustering/">Geographical clustering</a></li><li><a class="tocitem" href="../../../tutorials/linear/knapsack/">The knapsack problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/n-queens/">N-Queens</a></li><li><a class="tocitem" href="../../../tutorials/linear/network_flows/">Network flow problems</a></li><li><a class="tocitem" href="../../../tutorials/linear/prod/">The workforce scheduling problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/steelT3/">The SteelT3 problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/sudoku/">Sudoku</a></li><li><a class="tocitem" href="../../../tutorials/linear/transp/">The transportation problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/urban_plan/">The urban planning problem</a></li><li><a class="tocitem" href="../../../tutorials/linear/callbacks/">Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Nonlinear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/nonlinear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/portfolio/">Quadratic portfolio optimization</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/qcp/">Quadratically constrained programs</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/space_shuttle_reentry_trajectory/">Optimal control for a Space Shuttle reentry trajectory</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/rocket_control/">Rocket Control</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/rosenbrock/">The Rosenbrock function</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/mle/">Maximum likelihood estimation</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/clnlbeam/">The clnlbeam problem</a></li><li><a class="tocitem" href="../../../tutorials/nonlinear/querying_hessians/">Computing Hessians</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Conic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/conic/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../tutorials/conic/start_values/">Primal and dual warm-starts</a></li><li><a class="tocitem" href="../../../tutorials/conic/tips_and_tricks/">Tips and Tricks</a></li><li><a class="tocitem" href="../../../tutorials/conic/logistic_regression/">Logistic regression</a></li><li><a class="tocitem" href="../../../tutorials/conic/cluster/">K-means clustering via SDP</a></li><li><a class="tocitem" href="../../../tutorials/conic/corr_sdp/">The correlation problem</a></li><li><a class="tocitem" href="../../../tutorials/conic/experiment_design/">Experiment design</a></li><li><a class="tocitem" href="../../../tutorials/conic/max_cut_sdp/">SDP relaxations: max-cut</a></li><li><a class="tocitem" href="../../../tutorials/conic/min_distortion/">The minimum distortion problem</a></li><li><a class="tocitem" href="../../../tutorials/conic/min_ellipse/">Minimum ellipses</a></li><li><a class="tocitem" href="../../../tutorials/conic/robust_uncertainty/">Robust uncertainty sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/algorithms/benders_decomposition/">Benders decomposition</a></li><li><a class="tocitem" href="../../../tutorials/algorithms/cutting_stock_column_generation/">Column generation</a></li><li><a class="tocitem" href="../../../tutorials/algorithms/tsp_lazy_constraints/">Traveling Salesperson Problem</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/applications/power_systems/">Power Systems</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../manual/models/">Models</a></li><li><a class="tocitem" href="../../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../manual/expressions/">Expressions</a></li><li><a class="tocitem" href="../../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../../manual/containers/">Containers</a></li><li><a class="tocitem" href="../../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../manual/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../../manual/callbacks/">Solver-independent Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../reference/models/">Models</a></li><li><a class="tocitem" href="../../../reference/variables/">Variables</a></li><li><a class="tocitem" href="../../../reference/expressions/">Expressions</a></li><li><a class="tocitem" href="../../../reference/objectives/">Objectives</a></li><li><a class="tocitem" href="../../../reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../reference/containers/">Containers</a></li><li><a class="tocitem" href="../../../reference/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../reference/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../../reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../reference/extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Background Information</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../background/algebraic_modeling_languages/">Algebraic modeling languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../developers/contributing/">Contributing</a></li><li><a class="tocitem" href="../../../developers/extensions/">Extensions</a></li><li><a class="tocitem" href="../../../developers/custom_solver_binaries/">Custom binaries</a></li><li><a class="tocitem" href="../../../developers/style/">Style Guide</a></li><li><a class="tocitem" href="../../../developers/roadmap/">Roadmap</a></li></ul></li><li><a class="tocitem" href="../../../release_notes/">Release notes</a></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox" checked/><label class="tocitem" for="menuitem-8"><span class="docs-label">MathOptInterface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../background/motivation/">Motivation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/example/">Solving a problem using MathOptInterface</a></li><li><a class="tocitem" href="../../tutorials/implementing/">Implementing a solver interface</a></li><li><a class="tocitem" href="../../tutorials/mathprogbase/">Transitioning from MathProgBase</a></li><li><a class="tocitem" href="../../tutorials/bridging_constraint/">Implementing a constraint bridge</a></li><li><a class="tocitem" href="../../tutorials/manipulating_expressions/">Manipulating expressions</a></li><li><a class="tocitem" href="../../tutorials/latency/">Latency</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/standard_form/">Standard form problem</a></li><li><a class="tocitem" href="../../manual/models/">Models</a></li><li><a class="tocitem" href="../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../manual/modification/">Problem modification</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox"/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/duality/">Duality</a></li><li><a class="tocitem" href="../../background/infeasibility_certificates/">Infeasibility certificates</a></li><li><a class="tocitem" href="../../background/naming_conventions/">Naming conventions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox" checked/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../standard_form/">Standard form</a></li><li class="is-active"><a class="tocitem" href>Models</a><ul class="internal"><li><a class="tocitem" href="#Attribute-interface"><span>Attribute interface</span></a></li><li><a class="tocitem" href="#Model-interface"><span>Model interface</span></a></li><li><a class="tocitem" href="#Model-attributes"><span>Model attributes</span></a></li><li><a class="tocitem" href="#Optimizer-interface"><span>Optimizer interface</span></a></li><li><a class="tocitem" href="#Optimizer-attributes"><span>Optimizer attributes</span></a></li></ul></li><li><a class="tocitem" href="../variables/">Variables</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../modification/">Modifications</a></li><li><a class="tocitem" href="../nonlinear/">Nonlinear programming</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../errors/">Errors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6" type="checkbox"/><label class="tocitem" for="menuitem-8-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-6-1" type="checkbox"/><label class="tocitem" for="menuitem-8-6-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-2" type="checkbox"/><label class="tocitem" for="menuitem-8-6-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Bridges/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Bridges/implementation/">Implementation</a></li><li><a class="tocitem" href="../../submodules/Bridges/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-3" type="checkbox"/><label class="tocitem" for="menuitem-8-6-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/FileFormats/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-4" type="checkbox"/><label class="tocitem" for="menuitem-8-6-4"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Utilities/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Utilities/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-5" type="checkbox"/><label class="tocitem" for="menuitem-8-6-5"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Test/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Test/reference/">API Reference</a></li></ul></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">MathOptInterface</a></li><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Models</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/moi/reference/models.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h1><h2 id="Attribute-interface"><a class="docs-heading-anchor" href="#Attribute-interface">Attribute interface</a><a id="Attribute-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Attribute-interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.is_set_by_optimize" href="#MathOptInterface.is_set_by_optimize"><code>MathOptInterface.is_set_by_optimize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_set_by_optimize(::AnyAttribute)</code></pre><p>Return a <code>Bool</code> indicating whether the value of the attribute is modified during an <a href="#MathOptInterface.optimize!"><code>optimize!</code></a> call, that is, the attribute is used to query the result of the optimization.</p><p><strong>Important note when defining new attributes</strong></p><p>This function returns <code>false</code> by default so it should be implemented for attributes that are modified by <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.is_copyable" href="#MathOptInterface.is_copyable"><code>MathOptInterface.is_copyable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_copyable(::AnyAttribute)</code></pre><p>Return a <code>Bool</code> indicating whether the value of the attribute may be copied during <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> using <a href="#MathOptInterface.set"><code>set</code></a>.</p><p><strong>Important note when defining new attributes</strong></p><p>By default <code>is_copyable(attr)</code> returns <code>!is_set_by_optimize(attr)</code>. A specific method should be defined for attributes which are copied indirectly during <a href="#MathOptInterface.copy_to"><code>copy_to</code></a>. For instance, both <code>is_copyable</code> and <a href="#MathOptInterface.is_set_by_optimize"><code>is_set_by_optimize</code></a> return <code>false</code> for the following attributes:</p><ul><li><a href="#MathOptInterface.ListOfOptimizerAttributesSet"><code>ListOfOptimizerAttributesSet</code></a>, <a href="#MathOptInterface.ListOfModelAttributesSet"><code>ListOfModelAttributesSet</code></a>, <a href="#MathOptInterface.ListOfConstraintAttributesSet"><code>ListOfConstraintAttributesSet</code></a> and <a href="#MathOptInterface.ListOfVariableAttributesSet"><code>ListOfVariableAttributesSet</code></a>.</li><li><a href="#MathOptInterface.SolverName"><code>SolverName</code></a> and <a href="#MathOptInterface.RawSolver"><code>RawSolver</code></a>: these attributes cannot be set.</li><li><a href="#MathOptInterface.NumberOfVariables"><code>NumberOfVariables</code></a> and <a href="#MathOptInterface.ListOfVariableIndices"><code>ListOfVariableIndices</code></a>: these attributes are set indirectly by <a href="../variables/#MathOptInterface.add_variable"><code>add_variable</code></a> and <a href="../variables/#MathOptInterface.add_variables"><code>add_variables</code></a>.</li><li><a href="#MathOptInterface.ObjectiveFunctionType"><code>ObjectiveFunctionType</code></a>: this attribute is set indirectly when setting the <a href="#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a> attribute.</li><li><a href="#MathOptInterface.NumberOfConstraints"><code>NumberOfConstraints</code></a>, <a href="#MathOptInterface.ListOfConstraintIndices"><code>ListOfConstraintIndices</code></a>, <a href="#MathOptInterface.ListOfConstraintTypesPresent"><code>ListOfConstraintTypesPresent</code></a>, <a href="../constraints/#MathOptInterface.CanonicalConstraintFunction"><code>CanonicalConstraintFunction</code></a>, <a href="../constraints/#MathOptInterface.ConstraintFunction"><code>ConstraintFunction</code></a> and <a href="../constraints/#MathOptInterface.ConstraintSet"><code>ConstraintSet</code></a>: these attributes are set indirectly by <a href="../constraints/#MathOptInterface.add_constraint"><code>add_constraint</code></a> and <a href="../constraints/#MathOptInterface.add_constraints"><code>add_constraints</code></a>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.get" href="#MathOptInterface.get"><code>MathOptInterface.get</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute)</code></pre><p>Return an attribute <code>attr</code> of the optimizer <code>optimizer</code>.</p><pre><code class="nohighlight hljs">get(model::ModelLike, attr::AbstractModelAttribute)</code></pre><p>Return an attribute <code>attr</code> of the model <code>model</code>.</p><pre><code class="nohighlight hljs">get(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex)</code></pre><p>If the attribute <code>attr</code> is set for the variable <code>v</code> in the model <code>model</code>, return its value, return <code>nothing</code> otherwise. If the attribute <code>attr</code> is not supported by <code>model</code> then an error should be thrown instead of returning <code>nothing</code>.</p><pre><code class="nohighlight hljs">get(model::ModelLike, attr::AbstractVariableAttribute, v::Vector{VariableIndex})</code></pre><p>Return a vector of attributes corresponding to each variable in the collection <code>v</code> in the model <code>model</code>.</p><pre><code class="nohighlight hljs">get(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex)</code></pre><p>If the attribute <code>attr</code> is set for the constraint <code>c</code> in the model <code>model</code>, return its value, return <code>nothing</code> otherwise. If the attribute <code>attr</code> is not supported by <code>model</code> then an error should be thrown instead of returning <code>nothing</code>.</p><pre><code class="nohighlight hljs">get(model::ModelLike, attr::AbstractConstraintAttribute, c::Vector{ConstraintIndex{F,S}})</code></pre><p>Return a vector of attributes corresponding to each constraint in the collection <code>c</code> in the model <code>model</code>.</p><pre><code class="nohighlight hljs">get(model::ModelLike, ::Type{VariableIndex}, name::String)</code></pre><p>If a variable with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. Errors if two variables have the same name.</p><pre><code class="nohighlight hljs">get(model::ModelLike, ::Type{ConstraintIndex{F,S}}, name::String) where {F&lt;:AbstractFunction,S&lt;:AbstractSet}</code></pre><p>If an <code>F</code>-in-<code>S</code> constraint with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. Errors if two constraints have the same name.</p><pre><code class="nohighlight hljs">get(model::ModelLike, ::Type{ConstraintIndex}, name::String)</code></pre><p>If <em>any</em> constraint with name <code>name</code> exists in the model <code>model</code>, return the corresponding index, otherwise return <code>nothing</code>. This version is available for convenience but may incur a performance penalty because it is not type stable. Errors if two constraints have the same name.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">get(model, ObjectiveValue())
get(model, VariablePrimal(), ref)
get(model, VariablePrimal(5), [ref1, ref2])
get(model, OtherAttribute(&quot;something specific to cplex&quot;))
get(model, VariableIndex, &quot;var1&quot;)
get(model, ConstraintIndex{ScalarAffineFunction{Float64},LessThan{Float64}}, &quot;con1&quot;)
get(model, ConstraintIndex, &quot;con1&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.get!" href="#MathOptInterface.get!"><code>MathOptInterface.get!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get!(output, model::ModelLike, args...)</code></pre><p>An in-place version of <a href="#MathOptInterface.get"><code>get</code></a>.</p><p>The signature matches that of <a href="#MathOptInterface.get"><code>get</code></a> except that the the result is placed in the vector <code>output</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.set" href="#MathOptInterface.set"><code>MathOptInterface.set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the optimizer <code>optimizer</code>.</p><pre><code class="nohighlight hljs">set(model::ModelLike, attr::AbstractModelAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the model <code>model</code>.</p><pre><code class="nohighlight hljs">set(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of variable <code>v</code> in model <code>model</code>.</p><pre><code class="nohighlight hljs">set(model::ModelLike, attr::AbstractVariableAttribute, v::Vector{VariableIndex}, vector_of_values)</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each variable in the collection <code>v</code> in model <code>model</code>.</p><pre><code class="nohighlight hljs">set(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex, value)</code></pre><p>Assign a value to the attribute <code>attr</code> of constraint <code>c</code> in model <code>model</code>.</p><pre><code class="nohighlight hljs">set(model::ModelLike, attr::AbstractConstraintAttribute, c::Vector{ConstraintIndex{F,S}}, vector_of_values)</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each constraint in the collection <code>c</code> in model <code>model</code>.</p><p>An <a href="../errors/#MathOptInterface.UnsupportedAttribute"><code>UnsupportedAttribute</code></a> error is thrown if <code>model</code> does not support the attribute <code>attr</code> (see <a href="#MathOptInterface.supports"><code>supports</code></a>) and a <a href="../errors/#MathOptInterface.SetAttributeNotAllowed"><code>SetAttributeNotAllowed</code></a> error is thrown if it supports the attribute <code>attr</code> but it cannot be set.</p><p><strong>Replace set in a constraint</strong></p><pre><code class="nohighlight hljs">set(model::ModelLike, ::ConstraintSet, c::ConstraintIndex{F,S}, set::S)</code></pre><p>Change the set of constraint <code>c</code> to the new set <code>set</code> which should be of the same type as the original set.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintIndex{F,Interval}</code></p><pre><code class="language-julia hljs">set(model, ConstraintSet(), c, Interval(0, 5))
set(model, ConstraintSet(), c, GreaterThan(0.0))  # Error</code></pre><p><strong>Replace function in a constraint</strong></p><pre><code class="nohighlight hljs">set(model::ModelLike, ::ConstraintFunction, c::ConstraintIndex{F,S}, func::F)</code></pre><p>Replace the function in constraint <code>c</code> with <code>func</code>. <code>F</code> must match the original function type used to define the constraint.</p><p><strong>Note</strong></p><p>Setting the constraint function is not allowed if <code>F</code> is <a href="../standard_form/#MathOptInterface.VariableIndex"><code>VariableIndex</code></a>, it throws a <a href="../errors/#MathOptInterface.SettingVariableIndexNotAllowed"><code>SettingVariableIndexNotAllowed</code></a> error. Indeed, it would require changing the index <code>c</code> as the index of <code>VariableIndex</code> constraints should be the same as the index of the variable.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintIndex{ScalarAffineFunction,S}</code> and <code>v1</code> and <code>v2</code> are <code>VariableIndex</code> objects,</p><pre><code class="language-julia hljs">set(model, ConstraintFunction(), c,
    ScalarAffineFunction(ScalarAffineTerm.([1.0, 2.0], [v1, v2]), 5.0))
set(model, ConstraintFunction(), c, v1) # Error</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.supports" href="#MathOptInterface.supports"><code>MathOptInterface.supports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">supports(model::ModelLike, sub::AbstractSubmittable)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the submittable <code>sub</code>.</p><pre><code class="nohighlight hljs">supports(model::ModelLike, attr::AbstractOptimizerAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the optimizer attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> shows a warning in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfOptimizerAttributesSet"><code>ListOfOptimizerAttributesSet</code></a> of <code>src</code>; see <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> for more details on how unsupported optimizer attributes are handled in copy.</p><pre><code class="nohighlight hljs">supports(model::ModelLike, attr::AbstractModelAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the model attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfModelAttributesSet"><code>ListOfModelAttributesSet</code></a> of <code>src</code>.</p><pre><code class="nohighlight hljs">supports(model::ModelLike, attr::AbstractVariableAttribute, ::Type{VariableIndex})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the variable attribute <code>attr</code>. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfVariableAttributesSet"><code>ListOfVariableAttributesSet</code></a> of <code>src</code>.</p><pre><code class="nohighlight hljs">supports(model::ModelLike, attr::AbstractConstraintAttribute, ::Type{ConstraintIndex{F,S}})::Bool where {F,S}</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports the constraint attribute <code>attr</code> applied to an <code>F</code>-in-<code>S</code> constraint. That is, it returns <code>false</code> if <code>copy_to(model, src)</code> cannot be performed in case <code>attr</code> is in the <a href="#MathOptInterface.ListOfConstraintAttributesSet"><code>ListOfConstraintAttributesSet</code></a> of <code>src</code>.</p><p>For all five methods, if the attribute is only not supported in specific circumstances, it should still return <code>true</code>.</p><p>Note that <code>supports</code> is only defined for attributes for which <a href="#MathOptInterface.is_copyable"><code>is_copyable</code></a> returns <code>true</code> as other attributes do not appear in the list of attributes set obtained by <code>ListOf...AttributesSet</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.attribute_value_type" href="#MathOptInterface.attribute_value_type"><code>MathOptInterface.attribute_value_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">attribute_value_type(attr::AnyAttribute)</code></pre><p>Given an attribute <code>attr</code>, return the type of value expected by <a href="#MathOptInterface.get"><code>get</code></a>, or returned by <a href="#MathOptInterface.set"><code>set</code></a>.</p><p><strong>Notes</strong></p><ul><li>Only implement this if it make sense to do so. If un-implemented, the default is <code>Any</code>.</li></ul></div></section></article><h2 id="Model-interface"><a class="docs-heading-anchor" href="#Model-interface">Model interface</a><a id="Model-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Model-interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ModelLike" href="#MathOptInterface.ModelLike"><code>MathOptInterface.ModelLike</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModelLike</code></pre><p>Abstract supertype for objects that implement the &quot;Model&quot; interface for defining an optimization problem.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.is_empty" href="#MathOptInterface.is_empty"><code>MathOptInterface.is_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_empty(model::ModelLike)</code></pre><p>Returns <code>false</code> if the <code>model</code> has any model attribute set or has any variables or constraints.</p><p>Note that an empty model can have optimizer attributes set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.empty!" href="#MathOptInterface.empty!"><code>MathOptInterface.empty!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">empty!(model::ModelLike)</code></pre><p>Empty the model, that is, remove all variables, constraints and model attributes but not optimizer attributes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.write_to_file" href="#MathOptInterface.write_to_file"><code>MathOptInterface.write_to_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write_to_file(model::ModelLike, filename::String)</code></pre><p>Writes the current model data to the given file. Supported file types depend on the model type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.read_from_file" href="#MathOptInterface.read_from_file"><code>MathOptInterface.read_from_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_from_file(model::ModelLike, filename::String)</code></pre><p>Read the file <code>filename</code> into the model <code>model</code>. If <code>model</code> is non-empty, this may throw an error.</p><p>Supported file types depend on the model type.</p><p><strong>Note</strong></p><p>Once the contents of the file are loaded into the model, users can query the variables via <code>get(model, ListOfVariableIndices())</code>. However, some filetypes, such as LP files, do not maintain an explicit ordering of the variables. Therefore, the returned list may be in an arbitrary order. To avoid depending on the order of the indices, users should look up each variable index by name: <code>get(model, VariableIndex, &quot;name&quot;)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.supports_incremental_interface" href="#MathOptInterface.supports_incremental_interface"><code>MathOptInterface.supports_incremental_interface</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">supports_incremental_interface(model::ModelLike)</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports building incrementally via <a href="../variables/#MathOptInterface.add_variable"><code>add_variable</code></a> and <a href="../constraints/#MathOptInterface.add_constraint"><code>add_constraint</code></a>.</p><p>The main purpose of this function is to determine whether a model can be loaded into <code>model</code> incrementally or whether it should be cached and copied at once instead.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.copy_to" href="#MathOptInterface.copy_to"><code>MathOptInterface.copy_to</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">copy_to(dest::ModelLike, src::ModelLike)::IndexMap</code></pre><p>Copy the model from <code>src</code> into <code>dest</code>.</p><p>The target <code>dest</code> is emptied, and all previous indices to variables and constraints in <code>dest</code> are invalidated.</p><p>Returns an <a href="#MathOptInterface.IndexMap"><code>IndexMap</code></a> object that translates variable and constraint indices from the <code>src</code> model to the corresponding indices in the <code>dest</code> model.</p><p><strong>Notes</strong></p><ul><li>If a constraint that in <code>src</code> is not supported by <code>dest</code>, then an <a href="../errors/#MathOptInterface.UnsupportedConstraint"><code>UnsupportedConstraint</code></a> error is thrown.</li><li>If an <a href="#MathOptInterface.AbstractModelAttribute"><code>AbstractModelAttribute</code></a>, <a href="../variables/#MathOptInterface.AbstractVariableAttribute"><code>AbstractVariableAttribute</code></a>, or <a href="../constraints/#MathOptInterface.AbstractConstraintAttribute"><code>AbstractConstraintAttribute</code></a> is set in <code>src</code> but not supported by <code>dest</code>, then an <a href="../errors/#MathOptInterface.UnsupportedAttribute"><code>UnsupportedAttribute</code></a> error is thrown.</li></ul><p><a href="#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a>s are <em>not</em> copied  to the <code>dest</code> model.</p><p><strong>IndexMap</strong></p><p>Implementations of <code>copy_to</code> must return an <a href="#MathOptInterface.IndexMap"><code>IndexMap</code></a>. For technical reasons, this type is defined in the Utilities submodule as <code>MOI.Utilities.IndexMap</code>. However, since it is an integral part of the MOI API, we provide <code>MOI.IndexMap</code> as an alias.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Given empty `ModelLike` objects `src` and `dest`.

x = add_variable(src)

is_valid(src, x)   # true
is_valid(dest, x)  # false (`dest` has no variables)

index_map = copy_to(dest, src)
is_valid(dest, x) # false (unless index_map[x] == x)
is_valid(dest, index_map[x]) # true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.IndexMap" href="#MathOptInterface.IndexMap"><code>MathOptInterface.IndexMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndexMap()</code></pre><p>The dictionary-like object returned by <a href="#MathOptInterface.copy_to"><code>copy_to</code></a>.</p><p><strong>IndexMap</strong></p><p>Implementations of <a href="#MathOptInterface.copy_to"><code>copy_to</code></a> must return an <a href="#MathOptInterface.IndexMap"><code>IndexMap</code></a>. For technical reasons, the <code>IndexMap</code> type is defined in the Utilties submodule as <code>MOI.Utilities.IndexMap</code>. However, since it is an integral part of the MOI API, we provide this <code>MOI.IndexMap</code> as an alias.</p></div></section></article><h2 id="Model-attributes"><a class="docs-heading-anchor" href="#Model-attributes">Model attributes</a><a id="Model-attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Model-attributes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractModelAttribute" href="#MathOptInterface.AbstractModelAttribute"><code>MathOptInterface.AbstractModelAttribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractModelAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Name" href="#MathOptInterface.Name"><code>MathOptInterface.Name</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Name()</code></pre><p>A model attribute for the string identifying the model. It has a default value of <code>&quot;&quot;</code> if not set`.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveFunction" href="#MathOptInterface.ObjectiveFunction"><code>MathOptInterface.ObjectiveFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObjectiveFunction{F&lt;:AbstractScalarFunction}()</code></pre><p>A model attribute for the objective function which has a type <code>F&lt;:AbstractScalarFunction</code>. <code>F</code> should be guaranteed to be equivalent but not necessarily identical to the function type provided by the user. Throws an <code>InexactError</code> if the objective function cannot be converted to <code>F</code>, e.g. the objective function is quadratic and <code>F</code> is <code>ScalarAffineFunction{Float64}</code> or it has non-integer coefficient and <code>F</code> is <code>ScalarAffineFunction{Int}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveFunctionType" href="#MathOptInterface.ObjectiveFunctionType"><code>MathOptInterface.ObjectiveFunctionType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObjectiveFunctionType()</code></pre><p>A model attribute for the type <code>F</code> of the objective function set using the <code>ObjectiveFunction{F}</code> attribute.</p><p><strong>Examples</strong></p><p>In the following code, <code>attr</code> should be equal to <code>MOI.VariableIndex</code>:</p><pre><code class="language-julia hljs">x = MOI.add_variable(model)
MOI.set(model, MOI.ObjectiveFunction{MOI.VariableIndex}(),
         x)
attr = MOI.get(model, MOI.ObjectiveFunctionType())</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveSense" href="#MathOptInterface.ObjectiveSense"><code>MathOptInterface.ObjectiveSense</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObjectiveSense()</code></pre><p>A model attribute for the objective sense of the objective function, which must be an <code>OptimizationSense</code>: <code>MIN_SENSE</code>, <code>MAX_SENSE</code>, or <code>FEASIBILITY_SENSE</code>. The default is <code>FEASIBILITY_SENSE</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NumberOfVariables" href="#MathOptInterface.NumberOfVariables"><code>MathOptInterface.NumberOfVariables</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NumberOfVariables()</code></pre><p>A model attribute for the number of variables in the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfVariableIndices" href="#MathOptInterface.ListOfVariableIndices"><code>MathOptInterface.ListOfVariableIndices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ListOfVariableIndices()</code></pre><p>A model attribute for the <code>Vector{VariableIndex}</code> of all variable indices present in the model (i.e., of length equal to the value of <code>NumberOfVariables()</code>) in the order in which they were added.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfConstraintTypesPresent" href="#MathOptInterface.ListOfConstraintTypesPresent"><code>MathOptInterface.ListOfConstraintTypesPresent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ListOfConstraintTypesPresent()</code></pre><p>A model attribute for the list of tuples of the form <code>(F,S)</code>, where <code>F</code> is a function type and <code>S</code> is a set type indicating that the attribute <code>NumberOfConstraints{F,S}()</code> has value greater than zero.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NumberOfConstraints" href="#MathOptInterface.NumberOfConstraints"><code>MathOptInterface.NumberOfConstraints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NumberOfConstraints{F,S}()</code></pre><p>A model attribute for the number of constraints of the type <code>F</code>-in-<code>S</code> present in the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfConstraintIndices" href="#MathOptInterface.ListOfConstraintIndices"><code>MathOptInterface.ListOfConstraintIndices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ListOfConstraintIndices{F,S}()</code></pre><p>A model attribute for the <code>Vector{ConstraintIndex{F,S}}</code> of all constraint indices of type <code>F</code>-in-<code>S</code> in the model (i.e., of length equal to the value of <code>NumberOfConstraints{F,S}()</code>) in the order in which they were added.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfOptimizerAttributesSet" href="#MathOptInterface.ListOfOptimizerAttributesSet"><code>MathOptInterface.ListOfOptimizerAttributesSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ListOfOptimizerAttributesSet()</code></pre><p>An optimizer attribute for the <code>Vector{AbstractOptimizerAttribute}</code> of all optimizer attributes that were set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfModelAttributesSet" href="#MathOptInterface.ListOfModelAttributesSet"><code>MathOptInterface.ListOfModelAttributesSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ListOfModelAttributesSet()</code></pre><p>A model attribute for the <code>Vector{AbstractModelAttribute}</code> of all model attributes <code>attr</code> such that 1) <code>is_copyable(attr)</code> returns <code>true</code> and 2) the attribute was set to the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfVariableAttributesSet" href="#MathOptInterface.ListOfVariableAttributesSet"><code>MathOptInterface.ListOfVariableAttributesSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ListOfVariableAttributesSet()</code></pre><p>A model attribute for the <code>Vector{AbstractVariableAttribute}</code> of all variable attributes <code>attr</code> such that 1) <code>is_copyable(attr)</code> returns <code>true</code> and 2) the attribute was set to variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ListOfConstraintAttributesSet" href="#MathOptInterface.ListOfConstraintAttributesSet"><code>MathOptInterface.ListOfConstraintAttributesSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ListOfConstraintAttributesSet{F, S}()</code></pre><p>A model attribute for the <code>Vector{AbstractConstraintAttribute}</code> of all constraint attributes <code>attr</code> such that 1) <code>is_copyable(attr)</code> returns <code>true</code> and</p><ol><li>the attribute was set to <code>F</code>-in-<code>S</code> constraints.</li></ol><p><strong>Note</strong></p><p>The attributes <a href="../constraints/#MathOptInterface.ConstraintFunction"><code>ConstraintFunction</code></a> and <a href="../constraints/#MathOptInterface.ConstraintSet"><code>ConstraintSet</code></a> should not be included in the list even if then have been set with <a href="#MathOptInterface.set"><code>set</code></a>.</p></div></section></article><h2 id="Optimizer-interface"><a class="docs-heading-anchor" href="#Optimizer-interface">Optimizer interface</a><a id="Optimizer-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizer-interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractOptimizer" href="#MathOptInterface.AbstractOptimizer"><code>MathOptInterface.AbstractOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractOptimizer &lt;: ModelLike</code></pre><p>Abstract supertype for objects representing an instance of an optimization problem tied to a particular solver. This is typically a solver&#39;s in-memory representation. In addition to <code>ModelLike</code>, <code>AbstractOptimizer</code> objects let you solve the model and query the solution.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.OptimizerWithAttributes" href="#MathOptInterface.OptimizerWithAttributes"><code>MathOptInterface.OptimizerWithAttributes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct OptimizerWithAttributes
    optimizer_constructor
    params::Vector{Pair{AbstractOptimizerAttribute,&lt;:Any}}
end</code></pre><p>Object grouping an optimizer constructor and a list of optimizer attributes. Instances are created with <a href="#MathOptInterface.instantiate"><code>instantiate</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.optimize!" href="#MathOptInterface.optimize!"><code>MathOptInterface.optimize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimize!(optimizer::AbstractOptimizer)</code></pre><p>Optimize the problem contained in <code>optimizer</code>.</p><p>Before calling <code>optimize!</code>, the problem should first be constructed using the incremental interface (see <a href="#MathOptInterface.supports_incremental_interface"><code>supports_incremental_interface</code></a>) or <a href="#MathOptInterface.copy_to"><code>copy_to</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.instantiate" href="#MathOptInterface.instantiate"><code>MathOptInterface.instantiate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">instantiate(
    optimizer_constructor,
    with_bridge_type::Union{Nothing, Type} = nothing,
)</code></pre><p>Creates an instance of optimizer by either:</p><ul><li>calling <code>optimizer_constructor.optimizer_constructor()</code> and setting the parameters in <code>optimizer_constructor.params</code> if <code>optimizer_constructor</code> is a <a href="#MathOptInterface.OptimizerWithAttributes"><code>OptimizerWithAttributes</code></a></li><li>calling <code>optimizer_constructor()</code> if <code>optimizer_constructor</code> is callable.</li></ul><p>If <code>with_bridge_type</code> is not <code>nothing</code>, it enables all the bridges defined in the MathOptInterface.Bridges submodule with coefficient type <code>with_bridge_type</code>.</p><p>If the optimizer created by <code>optimizer_constructor</code> does not support loading the problem incrementally (see <a href="#MathOptInterface.supports_incremental_interface"><code>supports_incremental_interface</code></a>), then a <a href="../../submodules/Utilities/reference/#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a> is added to store a cache of the bridged model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.default_cache" href="#MathOptInterface.default_cache"><code>MathOptInterface.default_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default_cache(optimizer::ModelLike, ::Type{T}) where {T}</code></pre><p>Return a new instance of the default model type to be used as cache for <code>optimizer</code> in a <a href="../../submodules/Utilities/reference/#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a> for holding constraints of coefficient type <code>T</code>. By default, this returns <code>Utilities.UniversalFallback(Utilities.Model{T}())</code>. If copying from a instance of a given model type is faster for <code>optimizer</code> then a new method returning an instance of this model type should be defined.</p></div></section></article><h2 id="Optimizer-attributes"><a class="docs-heading-anchor" href="#Optimizer-attributes">Optimizer attributes</a><a id="Optimizer-attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizer-attributes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.AbstractOptimizerAttribute" href="#MathOptInterface.AbstractOptimizerAttribute"><code>MathOptInterface.AbstractOptimizerAttribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractOptimizerAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the optimizer.</p><p><strong>Note</strong></p><p>The difference between <code>AbstractOptimizerAttribute</code> and <code>AbstractModelAttribute</code> lies in the behavior of <code>is_empty</code>, <code>empty!</code> and <code>copy_to</code>. Typically optimizer attributes only affect how the model is solved.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SolverName" href="#MathOptInterface.SolverName"><code>MathOptInterface.SolverName</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolverName()</code></pre><p>An optimizer attribute for the string identifying the solver/optimizer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SolverVersion" href="#MathOptInterface.SolverVersion"><code>MathOptInterface.SolverVersion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolverVersion()</code></pre><p>An optimizer attribute for the string identifying the version of the solver.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For solvers supporting <a href="https://semver.org">semantic versioning</a>, the <code>SolverVersion</code> should be a string of the form &quot;vMAJOR.MINOR.PATCH&quot;, so that it can be converted to a Julia <code>VersionNumber</code> (e.g., `VersionNumber(&quot;v1.2.3&quot;)).</p><p>We do not require Semantic Versioning because some solvers use alternate versioning systems. For example, CPLEX uses Calendar Versioning, so <code>SolverVersion</code> will return a string like <code>&quot;202001&quot;</code>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Silent" href="#MathOptInterface.Silent"><code>MathOptInterface.Silent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Silent()</code></pre><p>An optimizer attribute for silencing the output of an optimizer. When <code>set</code> to <code>true</code>, it takes precedence over any other attribute controlling verbosity and requires the solver to produce no output. The default value is <code>false</code> which has no effect. In this case the verbosity is controlled by other attributes.</p><p><strong>Note</strong></p><p>Every optimizer should have verbosity on by default. For instance, if a solver has a solver-specific log level attribute, the MOI implementation should set it to <code>1</code> by default. If the user sets <code>Silent</code> to <code>true</code>, then the log level should be set to <code>0</code>, even if the user specifically sets a value of log level. If the value of <code>Silent</code> is <code>false</code> then the log level set to the solver is the value given by the user for this solver-specific parameter or <code>1</code> if none is given.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.TimeLimitSec" href="#MathOptInterface.TimeLimitSec"><code>MathOptInterface.TimeLimitSec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeLimitSec()</code></pre><p>An optimizer attribute for setting a time limit for an optimization. When <code>set</code> to <code>nothing</code>, it deactivates the solver time limit. The default value is <code>nothing</code>. The time limit is in seconds.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RawOptimizerAttribute" href="#MathOptInterface.RawOptimizerAttribute"><code>MathOptInterface.RawOptimizerAttribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RawOptimizerAttribute(name::String)</code></pre><p>An optimizer attribute for the solver-specific parameter identified by <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NumberOfThreads" href="#MathOptInterface.NumberOfThreads"><code>MathOptInterface.NumberOfThreads</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NumberOfThreads()</code></pre><p>An optimizer attribute for setting the number of threads used for an optimization. When set to <code>nothing</code> uses solver default. Values are positive integers. The default value is <code>nothing</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RawSolver" href="#MathOptInterface.RawSolver"><code>MathOptInterface.RawSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RawSolver()</code></pre><p>A model attribute for the object that may be used to access a solver-specific API for this optimizer.</p></div></section></article><p>List of attributes useful for optimizers</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.TerminationStatus" href="#MathOptInterface.TerminationStatus"><code>MathOptInterface.TerminationStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TerminationStatus()</code></pre><p>A model attribute for the <code>TerminationStatusCode</code> explaining why the optimizer stopped.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.TerminationStatusCode" href="#MathOptInterface.TerminationStatusCode"><code>MathOptInterface.TerminationStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TerminationStatusCode</code></pre><p>An Enum of possible values for the <code>TerminationStatus</code> attribute. This attribute is meant to explain the reason why the optimizer stopped executing in the most recent call to <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>.</p><p>If no call has been made to <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>, then the <code>TerminationStatus</code> is:</p><ul><li><code>OPTIMIZE_NOT_CALLED</code>: The algorithm has not started.</li></ul><p><strong>OK</strong></p><p>These are generally OK statuses, i.e., the algorithm ran to completion normally.</p><ul><li><code>OPTIMAL</code>: The algorithm found a globally optimal solution.</li><li><code>INFEASIBLE</code>: The algorithm concluded that no feasible solution exists.</li><li><code>DUAL_INFEASIBLE</code>: The algorithm concluded that no dual bound exists for the problem. If, additionally, a feasible (primal) solution is known to exist, this status typically implies that the problem is unbounded, with some technical exceptions.</li><li><code>LOCALLY_SOLVED</code>: The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.</li><li><code>LOCALLY_INFEASIBLE</code>: The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.</li><li><code>INFEASIBLE_OR_UNBOUNDED</code>: The algorithm stopped because it decided that the problem is infeasible or unbounded; this occasionally happens during MIP presolve.</li></ul><p><strong>Solved to relaxed tolerances</strong></p><ul><li><code>ALMOST_OPTIMAL</code>: The algorithm found a globally optimal solution to relaxed tolerances.</li><li><code>ALMOST_INFEASIBLE</code>: The algorithm concluded that no feasible solution exists within relaxed tolerances.</li><li><code>ALMOST_DUAL_INFEASIBLE</code>: The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.</li><li><code>ALMOST_LOCALLY_SOLVED</code>: The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.</li></ul><p><strong>Limits</strong></p><p>The optimizer stopped because of some user-defined limit.</p><ul><li><code>ITERATION_LIMIT</code>: An iterative algorithm stopped after conducting the maximum number of iterations.</li><li><code>TIME_LIMIT</code>: The algorithm stopped after a user-specified computation time.</li><li><code>NODE_LIMIT</code>: A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.</li><li><code>SOLUTION_LIMIT</code>: The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.</li><li><code>MEMORY_LIMIT</code>: The algorithm stopped because it ran out of memory.</li><li><code>OBJECTIVE_LIMIT</code>: The algorithm stopped because it found a solution better than a minimum limit set by the user.</li><li><code>NORM_LIMIT</code>: The algorithm stopped because the norm of an iterate became too large.</li><li><code>OTHER_LIMIT</code>: The algorithm stopped due to a limit not covered by one of the above.</li></ul><p><strong>Problematic</strong></p><p>This group of statuses means that something unexpected or problematic happened.</p><ul><li><code>SLOW_PROGRESS</code>: The algorithm stopped because it was unable to continue making progress towards the solution.</li><li><code>NUMERICAL_ERROR</code>: The algorithm stopped because it encountered unrecoverable numerical error.</li><li><code>INVALID_MODEL</code>: The algorithm stopped because the model is invalid.</li><li><code>INVALID_OPTION</code>: The algorithm stopped because it was provided an invalid option.</li><li><code>INTERRUPTED</code>: The algorithm stopped because of an interrupt signal.</li><li><code>OTHER_ERROR</code>: The algorithm stopped because of an error not covered by one of the statuses defined above.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.PrimalStatus" href="#MathOptInterface.PrimalStatus"><code>MathOptInterface.PrimalStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrimalStatus(result_index::Int = 1)</code></pre><p>A model attribute for the <a href="#MathOptInterface.ResultStatusCode"><code>ResultStatusCode</code></a> of the primal result <code>result_index</code>. If <code>result_index</code> is omitted, it defaults to 1.</p><p>See <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> for information on how the results are ordered.</p><p>If <code>result_index</code> is larger than the value of <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> then <code>NO_SOLUTION</code> is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.DualStatus" href="#MathOptInterface.DualStatus"><code>MathOptInterface.DualStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DualStatus(result_index::Int = 1)</code></pre><p>A model attribute for the <code>ResultStatusCode</code> of the dual result <code>result_index</code>. If <code>result_index</code> is omitted, it defaults to 1.</p><p>See <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> for information on how the results are ordered.</p><p>If <code>result_index</code> is larger than the value of <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> then <code>NO_SOLUTION</code> is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ResultStatusCode" href="#MathOptInterface.ResultStatusCode"><code>MathOptInterface.ResultStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ResultStatusCode</code></pre><p>An Enum of possible values for the <code>PrimalStatus</code> and <code>DualStatus</code> attributes. The values indicate how to interpret the result vector.</p><ul><li><code>NO_SOLUTION</code>: the result vector is empty.</li><li><code>FEASIBLE_POINT</code>: the result vector is a feasible point.</li><li><code>NEARLY_FEASIBLE_POINT</code>: the result vector is feasible if some constraint tolerances are relaxed.</li><li><code>INFEASIBLE_POINT</code>: the result vector is an infeasible point.</li><li><code>INFEASIBILITY_CERTIFICATE</code>: the result vector is an infeasibility certificate. If the <code>PrimalStatus</code> is <code>INFEASIBILITY_CERTIFICATE</code>, then the primal result vector is a certificate of dual infeasibility. If the <code>DualStatus</code> is <code>INFEASIBILITY_CERTIFICATE</code>, then the dual result vector is a proof of primal infeasibility.</li><li><code>NEARLY_INFEASIBILITY_CERTIFICATE</code>: the result satisfies a relaxed criterion for a certificate of infeasibility.</li><li><code>REDUCTION_CERTIFICATE</code>: the result vector is an ill-posed certificate; see <a href="https://arxiv.org/abs/1408.4685">this article</a> for details. If the <code>PrimalStatus</code> is <code>REDUCTION_CERTIFICATE</code>, then the primal result vector is a proof that the dual problem is ill-posed. If the <code>DualStatus</code> is <code>REDUCTION_CERTIFICATE</code>, then the dual result vector is a proof that the primal is ill-posed.</li><li><code>NEARLY_REDUCTION_CERTIFICATE</code>: the result satisfies a relaxed criterion for an ill-posed certificate.</li><li><code>UNKNOWN_RESULT_STATUS</code>: the result vector contains a solution with an unknown interpretation.</li><li><code>OTHER_RESULT_STATUS</code>: the result vector contains a solution with an interpretation not covered by one of the statuses defined above.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RawStatusString" href="#MathOptInterface.RawStatusString"><code>MathOptInterface.RawStatusString</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RawStatusString()</code></pre><p>A model attribute for a solver specific string explaining why the optimizer stopped.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ResultCount" href="#MathOptInterface.ResultCount"><code>MathOptInterface.ResultCount</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ResultCount()</code></pre><p>A model attribute for the number of results available.</p><p><strong>Order of solutions</strong></p><p>A number of attributes contain an index, <code>result_index</code>, which is used to refer to one of the available results. Thus, <code>result_index</code> must be an integer between <code>1</code> and the number of available results.</p><p>As a general rule, the first result (<code>result_index=1</code>) is the most important result (e.g., an optimal solution or an infeasibility certificate). Other results will typically be alternate solutions that the solver found during the search for the first result.</p><p>If a (local) optimal solution is available, i.e., <a href="#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a> is <code>OPTIMAL</code> or <code>LOCALLY_SOLVED</code>, the first result must correspond to the (locally) optimal solution. Other results may be alternative optimal solutions, or they may be other suboptimal solutions; use <a href="#MathOptInterface.ObjectiveValue"><code>ObjectiveValue</code></a> to distingiush between them.</p><p>If a primal or dual infeasibility certificate is available, i.e., <a href="#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a> is <code>INFEASIBLE</code> or <code>DUAL_INFEASIBLE</code> and the corresponding <a href="#MathOptInterface.PrimalStatus"><code>PrimalStatus</code></a> or <a href="#MathOptInterface.DualStatus"><code>DualStatus</code></a> is <code>INFEASIBILITY_CERTIFICATE</code>, then the first result must be a certificate. Other results may be alternate certificates, or infeasible points.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveValue" href="#MathOptInterface.ObjectiveValue"><code>MathOptInterface.ObjectiveValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObjectiveValue(result_index::Int = 1)</code></pre><p>A model attribute for the objective value of the primal solution <code>result_index</code>.</p><p>If the solver does not have a primal value for the objective because the <code>result_index</code> is beyond the available solutions (whose number is indicated by the <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> attribute), getting this attribute must throw a <a href="../errors/#MathOptInterface.ResultIndexBoundsError"><code>ResultIndexBoundsError</code></a>. Otherwise, if the result is unavailable for another reason (for instance, only a dual solution is available), the result is undefined. Users should first check <a href="#MathOptInterface.PrimalStatus"><code>PrimalStatus</code></a> before accessing the <code>ObjectiveValue</code> attribute.</p><p>See <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> for information on how the results are ordered.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.DualObjectiveValue" href="#MathOptInterface.DualObjectiveValue"><code>MathOptInterface.DualObjectiveValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DualObjectiveValue(result_index::Int = 1)</code></pre><p>A model attribute for the value of the objective function of the dual problem for the <code>result_index</code>th dual result.</p><p>If the solver does not have a dual value for the objective because the <code>result_index</code> is beyond the available solutions (whose number is indicated by the <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> attribute), getting this attribute must throw a <a href="../errors/#MathOptInterface.ResultIndexBoundsError"><code>ResultIndexBoundsError</code></a>. Otherwise, if the result is unavailable for another reason (for instance, only a primal solution is available), the result is undefined. Users should first check <a href="#MathOptInterface.DualStatus"><code>DualStatus</code></a> before accessing the <code>DualObjectiveValue</code> attribute.</p><p>See <a href="#MathOptInterface.ResultCount"><code>ResultCount</code></a> for information on how the results are ordered.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ObjectiveBound" href="#MathOptInterface.ObjectiveBound"><code>MathOptInterface.ObjectiveBound</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObjectiveBound()</code></pre><p>A model attribute for the best known bound on the optimal objective value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.RelativeGap" href="#MathOptInterface.RelativeGap"><code>MathOptInterface.RelativeGap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RelativeGap()</code></pre><p>A model attribute for the final relative optimality gap.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The definition of this gap is solver-dependent. However, most solvers implementing this attribute define the relative gap as some variation of <span>$\frac{|b-f|}{|f|}$</span>, where <span>$b$</span> is the best bound and <span>$f$</span> is the best feasible objective value.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SolveTimeSec" href="#MathOptInterface.SolveTimeSec"><code>MathOptInterface.SolveTimeSec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolveTimeSec()</code></pre><p>A model attribute for the total elapsed solution time (in seconds) as reported by the optimizer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.SimplexIterations" href="#MathOptInterface.SimplexIterations"><code>MathOptInterface.SimplexIterations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimplexIterations()</code></pre><p>A model attribute for the cumulative number of simplex iterations during the optimization process. In particular, for a mixed-integer program (MIP), the total simplex iterations for all nodes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.BarrierIterations" href="#MathOptInterface.BarrierIterations"><code>MathOptInterface.BarrierIterations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BarrierIterations()</code></pre><p>A model attribute for the cumulative number of barrier iterations while solving a problem.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.NodeCount" href="#MathOptInterface.NodeCount"><code>MathOptInterface.NodeCount</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NodeCount()</code></pre><p>A model attribute for the total number of branch-and-bound nodes explored while solving a mixed-integer program (MIP).</p></div></section></article><h3 id="Conflict-Status"><a class="docs-heading-anchor" href="#Conflict-Status">Conflict Status</a><a id="Conflict-Status-1"></a><a class="docs-heading-anchor-permalink" href="#Conflict-Status" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.compute_conflict!" href="#MathOptInterface.compute_conflict!"><code>MathOptInterface.compute_conflict!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_conflict!(optimizer::AbstractOptimizer)</code></pre><p>Computes a minimal subset of constraints such that the model with the other constraint removed is still infeasible.</p><p>Some solvers call a set of conflicting constraints an Irreducible Inconsistent Subsystem (IIS).</p><p>See also <a href="#MathOptInterface.ConflictStatus"><code>ConflictStatus</code></a> and <a href="#MathOptInterface.ConstraintConflictStatus"><code>ConstraintConflictStatus</code></a>.</p><p><strong>Note</strong></p><p>If the model is modified after a call to <code>compute_conflict!</code>, the implementor is not obliged to purge the conflict. Any calls to the above attributes may return values for the original conflict without a warning. Similarly, when modifying the model, the conflict can be discarded.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictStatus" href="#MathOptInterface.ConflictStatus"><code>MathOptInterface.ConflictStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConflictStatus()</code></pre><p>A model attribute for the <a href="#MathOptInterface.ConflictStatusCode"><code>ConflictStatusCode</code></a> explaining why the conflict refiner stopped when computing the conflict.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictStatusCode" href="#MathOptInterface.ConflictStatusCode"><code>MathOptInterface.ConflictStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConflictStatusCode</code></pre><p>An Enum of possible values for the <code>ConflictStatus</code> attribute. This attribute is meant to explain the reason why the conflict finder stopped executing in the most recent call to <a href="#MathOptInterface.compute_conflict!"><code>compute_conflict!</code></a>.</p><p>Possible values are:</p><ul><li><code>COMPUTE_CONFLICT_NOT_CALLED</code>: the function <a href="#MathOptInterface.compute_conflict!"><code>compute_conflict!</code></a> has not yet been called</li><li><code>NO_CONFLICT_EXISTS</code>: there is no conflict because the problem is feasible</li><li><code>NO_CONFLICT_FOUND</code>: the solver could not find a conflict</li><li><code>CONFLICT_FOUND</code>: at least one conflict could be found</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConstraintConflictStatus" href="#MathOptInterface.ConstraintConflictStatus"><code>MathOptInterface.ConstraintConflictStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstraintConflictStatus()</code></pre><p>A constraint attribute indicating whether the constraint participates in the conflict. Its type is <a href="#MathOptInterface.ConflictParticipationStatusCode"><code>ConflictParticipationStatusCode</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.ConflictParticipationStatusCode" href="#MathOptInterface.ConflictParticipationStatusCode"><code>MathOptInterface.ConflictParticipationStatusCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConflictParticipationStatusCode</code></pre><p>An Enum of possible values for the <a href="#MathOptInterface.ConstraintConflictStatus"><code>ConstraintConflictStatus</code></a> attribute. This attribute is meant to indicate whether a given constraint participates or not in the last computed conflict.</p><p>Possible values are:</p><ul><li><code>NOT_IN_CONFLICT</code>: the constraint does not participate in the conflict</li><li><code>IN_CONFLICT</code>: the constraint participates in the conflict</li><li><code>MAYBE_IN_CONFLICT</code>: the constraint may participate in the conflict, the solver was not able to prove that the constraint can be excluded from the conflict</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../standard_form/">« Standard form</a><a class="docs-footer-nextpage" href="../variables/">Variables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.14 on <span class="colophon-date" title="Tuesday 15 March 2022 01:43">Tuesday 15 March 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
