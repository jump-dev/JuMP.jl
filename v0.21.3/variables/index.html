<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Variables · JuMP</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><a href="../"><img alt="JuMP logo" class="logo" src="../assets/logo.png"/></a><h1>JuMP</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search/" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../installation/">Installation Guide</a></li><li><a class="toctext" href="../quickstart/">Quick Start Guide</a></li><li class="current"><a class="toctext" href="">Variables</a><ul class="internal"><li><a class="toctext" href="#What-is-a-JuMP-variable?-1">What is a JuMP variable?</a></li><li><a class="toctext" href="#Variable-bounds-1">Variable bounds</a></li><li><a class="toctext" href="#Variable-names-1">Variable names</a></li><li><a class="toctext" href="#Variable-containers-1">Variable containers</a></li><li><a class="toctext" href="#Integrality-shortcuts-1">Integrality shortcuts</a></li><li><a class="toctext" href="#Semidefinite-variables-1">Semidefinite variables</a></li><li><a class="toctext" href="#Anonymous-JuMP-variables-1">Anonymous JuMP variables</a></li><li><a class="toctext" href="#Variables-constrained-on-creation-1">Variables constrained on creation</a></li><li><a class="toctext" href="#User-defined-containers-1">User-defined containers</a></li><li><a class="toctext" href="#Deleting-variables-1">Deleting variables</a></li><li><a class="toctext" href="#Listing-all-variables-1">Listing all variables</a></li><li><a class="toctext" href="#Start-values-1">Start values</a></li><li><a class="toctext" href="#variables-1">The <code>@variables</code> macro</a></li><li><a class="toctext" href="#Reference-1">Reference</a></li></ul></li><li><a class="toctext" href="../expressions/">Expressions</a></li><li><a class="toctext" href="../objective/">Objective</a></li><li><a class="toctext" href="../constraints/">Constraints</a></li><li><a class="toctext" href="../containers/">Containers</a></li><li><a class="toctext" href="../solvers/">Solvers</a></li><li><a class="toctext" href="../solutions/">Query Solutions</a></li><li><a class="toctext" href="../nlp/">Nonlinear Modeling</a></li><li><a class="toctext" href="../callbacks/">Callbacks</a></li><li><a class="toctext" href="../style/">Style Guide</a></li><li><a class="toctext" href="../extensions/">Extensions</a></li><li><a class="toctext" href="../roadmap/">Development Roadmap</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="">Variables</a></li></ul><a class="edit-page" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/variables.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Variables</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Variables-1" id="Variables-1">Variables</a></h1><h2><a class="nav-anchor" href="#What-is-a-JuMP-variable?-1" id="What-is-a-JuMP-variable?-1">What is a JuMP variable?</a></h2><p>The term <em>variable</em> in mathematical optimization has many meanings. Here, we distinguish between the following three types of variables:</p><ol><li><em>optimization</em> variables, which are the mathematical <span>$x$</span> in the problem <span>$\max\{f_0(x) | f_i(x) \in S_i\}$</span>.</li><li><em>Julia</em> variables, which are bindings between a name and a value, for example <code>x = 1</code>. (See <a href="https://docs.julialang.org/en/v1.0.0/manual/variables/">here</a> for the Julia docs.)</li><li><em>JuMP</em> variables, which are instances of the <code>VariableRef</code> struct defined by JuMP that contains a reference to an optimization variable in a model. (Extra for experts: the <code>VariableRef</code> struct is a thin wrapper around a <code>MOI.VariableIndex</code>, and also contains a reference to the JuMP model.)</li></ol><p>To illustrate these three types of variables, consider the following JuMP code (the full syntax is explained below):</p><pre><code class="language-julia-repl">julia&gt; model = Model()
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.

julia&gt; @variable(model, x[1:2])
2-element Array{VariableRef,1}:
 x[1]
 x[2]</code></pre><p>This code does three things:</p><ol><li>It adds two <em>optimization</em> variables to <code>model</code>.</li><li>It creates two <em>JuMP</em> variables that act as references to those optimization variables.</li><li>It binds those JuMP variables as a vector with two elements to the <em>Julia</em> variable <code>x</code>.</li></ol><p>To reduce confusion, we will attempt, where possible, to always refer to variables with their corresponding prefix.</p><p>JuMP variables can have attributes, such as names or an initial primal start value. We illustrate the name attribute in the following example:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, y, base_name="decision variable")
decision variable</code></pre><p>This code does four things:</p><ol><li>It adds one <em>optimization</em> variable to <code>model</code>.</li><li>It creates one <em>JuMP</em> variable that acts as a reference to that optimization variable.</li><li>It binds the JuMP variable to the Julia variable <code>y</code>.</li><li>It tells JuMP that the <em>name</em> attribute of this JuMP variable is "decision variable". JuMP uses the value of <code>base_name</code> when it has to print the variable as a string.</li></ol><p>For example, when we print <code>y</code> at the REPL we get:</p><pre><code class="language-julia-repl">julia&gt; y
decision variable</code></pre><p>Because <code>y</code> is a Julia variable, we can bind it to a different value. For example, if we write:</p><pre><code class="language-julia-repl">julia&gt; y = 1
1</code></pre><p><code>y</code> is no longer a binding to a JuMP variable. This does not mean that the JuMP variable has been destroyed. It still exists and is still a reference to the same optimization variable. The binding can be reset by querying the model for the symbol <em>as it was written in the <code>@variable</code> macro</em>. For example:</p><pre><code class="language-julia-repl">julia&gt; model[:y]
decision variable</code></pre><p>This act of looking up the JuMP variable by using the symbol is most useful when composing JuMP models across multiple functions, as illustrated by the following example:</p><pre><code class="language-julia">function add_component_to_model(model::JuMP.Model)
    x = model[:x]
    # ... code that uses x
end
function build_model()
    model = Model()
    @variable(model, x)
    add_component_to_model(model)
end</code></pre><p>Now that we understand the difference between <em>optimization</em>, <em>JuMP</em>, and <em>Julia</em> variables, we can introduce more of the functionality of the <a href="#JuMP.@variable"><code>@variable</code></a> macro.</p><h2><a class="nav-anchor" href="#Variable-bounds-1" id="Variable-bounds-1">Variable bounds</a></h2><p>We have already seen the basic usage of the <a href="#JuMP.@variable"><code>@variable</code></a> macro. The next extension is to add lower- and upper-bounds to each optimization variable. This can be done as follows:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x_free)
x_free

julia&gt; @variable(model, x_lower &gt;= 0)
x_lower

julia&gt; @variable(model, x_upper &lt;= 1)
x_upper

julia&gt; @variable(model, 2 &lt;= x_interval &lt;= 3)
x_interval

julia&gt; @variable(model, x_fixed == 4)
x_fixed</code></pre><p>In the above examples, <code>x_free</code> represents an unbounded optimization variable, <code>x_lower</code> represents an optimization variable with a lower bound and so forth.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>When creating a variable with only a lower-bound or an upper-bound, and the value of the bound is not a numeric literal, the name of the variable must appear on the left-hand side. Putting the name on the right-hand side will result in an error. For example:</p><pre><code class="language-julia">@variable(model, 1 &lt;= x)  # works
a = 1
@variable(model, a &lt;= x)  # errors
@variable(model, x &gt;= a)  # works</code></pre></div></div><p>We can query whether an optimization variable has a lower- or upper-bound via the <a href="#JuMP.has_lower_bound"><code>has_lower_bound</code></a> and <a href="#JuMP.has_upper_bound"><code>has_upper_bound</code></a> functions. For example:</p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(x_free)
false

julia&gt; has_upper_bound(x_upper)
true</code></pre><p>If a variable has a lower or upper bound, we can query the value of it via the <a href="#JuMP.lower_bound"><code>lower_bound</code></a> and <a href="#JuMP.upper_bound"><code>upper_bound</code></a> functions. For example:</p><pre><code class="language-julia-repl">julia&gt; lower_bound(x_interval)
2.0

julia&gt; upper_bound(x_interval)
3.0</code></pre><p>Querying the value of a bound that does not exist will result in an error.</p><p>Instead of using the <code>&lt;=</code> and <code>&gt;=</code> syntax, we can also use the <code>lower_bound</code> and <code>upper_bound</code> keyword arguments. For example:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x, lower_bound=1, upper_bound=2)
x

julia&gt; lower_bound(x)
1.0</code></pre><p>Another option is to use the <a href="#JuMP.set_lower_bound"><code>set_lower_bound</code></a> and <a href="#JuMP.set_upper_bound"><code>set_upper_bound</code></a> functions. These can also be used to modify an existing variable bound. For example:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x &gt;= 1)
x

julia&gt; lower_bound(x)
1.0

julia&gt; set_lower_bound(x, 2)

julia&gt; lower_bound(x)
2.0</code></pre><p>We can delete variable bounds using <a href="#JuMP.delete_lower_bound"><code>delete_lower_bound</code></a> and <a href="#JuMP.delete_upper_bound"><code>delete_upper_bound</code></a>:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, 1 &lt;= x &lt;= 2)
x

julia&gt; lower_bound(x)
1.0

julia&gt; delete_lower_bound(x)

julia&gt; has_lower_bound(x)
false

julia&gt; upper_bound(x)
2.0

julia&gt; delete_upper_bound(x)

julia&gt; has_upper_bound(x)
false</code></pre><p>In addition to upper and lower bounds, JuMP variables can also be fixed to a value using <a href="#JuMP.fix"><code>fix</code></a>. See also <a href="#JuMP.is_fixed"><code>is_fixed</code></a>, <a href="#JuMP.fix_value"><code>fix_value</code></a>, and <a href="#JuMP.unfix"><code>unfix</code></a>.</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x == 1)
x

julia&gt; is_fixed(x)
true

julia&gt; fix_value(x)
1.0

julia&gt; unfix(x)

julia&gt; is_fixed(x)
false</code></pre><p>Fixing a variable with existing bounds will throw an error. To delete the bounds prior to fixing, use <code>fix(variable, value; force = true)</code>.</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x &gt;= 1)
x

julia&gt; fix(x, 2)
ERROR: Unable to fix x to 2 because it has existing variable bounds. Consider calling `JuMP.fix(variable, value; force=true)` which will delete existing bounds before fixing the variable.

julia&gt; fix(x, 2; force = true)


julia&gt; fix_value(x)
2.0</code></pre><h2><a class="nav-anchor" href="#Variable-names-1" id="Variable-names-1">Variable names</a></h2><p>The name, i.e. the value of the <code>MOI.VariableName</code> attribute, of a variable can be obtained by <a href="#JuMP.name-Tuple{VariableRef}"><code>JuMP.name(::JuMP.VariableRef)</code></a> and set by <a href="#JuMP.set_name-Tuple{VariableRef,String}"><code>JuMP.set_name(::JuMP.VariableRef, ::String)</code></a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.name-Tuple{VariableRef}" id="JuMP.name-Tuple{VariableRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">name(v::VariableRef)::String</code></pre><p>Get a variable's name attribute.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L229-L233" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.set_name-Tuple{VariableRef,String}" id="JuMP.set_name-Tuple{VariableRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">set_name(v::VariableRef, s::AbstractString)</code></pre><p>Set a variable's name attribute.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L236-L240" target="_blank">source</a></section><p>The variable can also be retrieved from its name using <a href="#JuMP.variable_by_name"><code>JuMP.variable_by_name</code></a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.variable_by_name" id="JuMP.variable_by_name"><code>JuMP.variable_by_name</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">variable_by_name(model::AbstractModel,
                 name::String)::Union{AbstractVariableRef, Nothing}</code></pre><p>Returns the reference of the variable with name attribute <code>name</code> or <code>Nothing</code> if no variable has this name attribute. Throws an error if several variables have <code>name</code> as their name attribute.</p><pre><code class="language-julia-repl">julia&gt; model = Model()
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.

julia&gt; @variable(model, x)
x

julia&gt; variable_by_name(model, "x")
x

julia&gt; @variable(model, base_name="x")
x

julia&gt; variable_by_name(model, "x")
ERROR: Multiple variables have the name x.
Stacktrace:
 [1] error(::String) at ./error.jl:33
 [2] get(::MOIU.Model{Float64}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/model.jl:222
 [3] get at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/universalfallback.jl:201 [inlined]
 [4] get(::MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.AbstractOptimizer,MathOptInterface.Utilities.UniversalFallback{MOIU.Model{Float64}}}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/cachingoptimizer.jl:490
 [5] variable_by_name(::Model, ::String) at /home/blegat/.julia/dev/JuMP/src/variables.jl:268
 [6] top-level scope at none:0

julia&gt; var = @variable(model, base_name="y")
y

julia&gt; variable_by_name(model, "y")
y

julia&gt; set_name(var, "z")

julia&gt; variable_by_name(model, "y")

julia&gt; variable_by_name(model, "z")
z

julia&gt; @variable(model, u[1:2])
2-element Array{VariableRef,1}:
 u[1]
 u[2]

julia&gt; variable_by_name(model, "u[2]")
u[2]</code></pre></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L245-L302" target="_blank">source</a></section><h2><a class="nav-anchor" href="#Variable-containers-1" id="Variable-containers-1">Variable containers</a></h2><p>In the examples above, we have mostly created scalar variables. By scalar, we mean that the Julia variable is bound to exactly one JuMP variable. However, it is often useful to create collections of JuMP variables inside more complicated data structures.</p><p>JuMP provides a mechanism for creating three types of these data structures, which we refer to as <em>containers</em>. The three types are <code>Array</code>s, <code>DenseAxisArray</code>s, and <code>SparseAxisArray</code>s. We explain each of these in the following.</p><h3><a class="nav-anchor" href="#Arrays-1" id="Arrays-1">Arrays</a></h3><p>We have already seen the creation of an array of JuMP variables with the <code>x[1:2]</code> syntax. This can naturally be extended to create multi-dimensional arrays of JuMP variables. For example:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x[1:2, 1:2])
2×2 Array{VariableRef,2}:
 x[1,1]  x[1,2]
 x[2,1]  x[2,2]</code></pre><p>Arrays of JuMP variables can be indexed and sliced as follows:</p><pre><code class="language-julia-repl">julia&gt; x[1, 2]
x[1,2]

julia&gt; x[2, :]
2-element Array{VariableRef,1}:
 x[2,1]
 x[2,2]</code></pre><p>Variable bounds can depend upon the indices:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x[i=1:2, j=1:2] &gt;= 2i + j)
2×2 Array{VariableRef,2}:
 x[1,1]  x[1,2]
 x[2,1]  x[2,2]

julia&gt; lower_bound.(x)
2×2 Array{Float64,2}:
 3.0  4.0
 5.0  6.0</code></pre><p>JuMP will form an <code>Array</code> of JuMP variables when it can determine at compile time that the indices are one-based integer ranges. Therefore <code>x[1:b]</code> will create an <code>Array</code> of JuMP variables, but <code>x[a:b]</code> will not. If JuMP cannot determine that the indices are one-based integer ranges (e.g., in the case of <code>x[a:b]</code>), JuMP will create a <code>DenseAxisArray</code> instead.</p><h3><a class="nav-anchor" href="#variable_jump_arrays-1" id="variable_jump_arrays-1">DenseAxisArrays</a></h3><p>We often want to create arrays where the indices are not one-based integer ranges. For example, we may want to create a variable indexed by the name of a product or a location. The syntax is the same as that above, except with an arbitrary vector as an index as opposed to a one-based range. The biggest difference is that instead of returning an <code>Array</code> of JuMP variables, JuMP will return a <code>DenseAxisArray</code>. For example:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x[1:2, [:A,:B]])
2-dimensional DenseAxisArray{VariableRef,2,...} with index sets:
    Dimension 1, Base.OneTo(2)
    Dimension 2, Symbol[:A, :B]
And data, a 2×2 Array{VariableRef,2}:
 x[1,A]  x[1,B]
 x[2,A]  x[2,B]</code></pre><p>DenseAxisArrays can be indexed and sliced as follows:</p><pre><code class="language-julia-repl">julia&gt; x[1, :A]
x[1,A]

julia&gt; x[2, :]
1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:
    Dimension 1, Symbol[:A, :B]
And data, a 2-element Array{VariableRef,1}:
 x[2,A]
 x[2,B]</code></pre><p>Similarly to the <code>Array</code> case, bounds can depend upon indices. For example:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x[i=2:3, j=1:2:3] &gt;= 0.5i + j)
2-dimensional DenseAxisArray{VariableRef,2,...} with index sets:
    Dimension 1, 2:3
    Dimension 2, 1:2:3
And data, a 2×2 Array{VariableRef,2}:
 x[2,1]  x[2,3]
 x[3,1]  x[3,3]

julia&gt; lower_bound.(x)
2-dimensional DenseAxisArray{Float64,2,...} with index sets:
    Dimension 1, 2:3
    Dimension 2, 1:2:3
And data, a 2×2 Array{Float64,2}:
 2.0  4.0
 2.5  4.5</code></pre><h3><a class="nav-anchor" href="#variable_sparseaxisarrays-1" id="variable_sparseaxisarrays-1">SparseAxisArrays</a></h3><p>The third container type that JuMP natively supports is <code>SparseAxisArray</code>. These arrays are created when the indices do not form a rectangular set. For example, this applies when indices have a dependence upon previous indices (called <em>triangular indexing</em>). JuMP supports this as follows:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x[i=1:2, j=i:2])
JuMP.Containers.SparseAxisArray{VariableRef,2,Tuple{Int64,Int64}} with 3 entries:
  [1, 2]  =  x[1,2]
  [2, 2]  =  x[2,2]
  [1, 1]  =  x[1,1]</code></pre><p>We can also conditionally create variables via a JuMP-specific syntax. This syntax appends a comparison check that depends upon the named indices and is separated from the indices by a semi-colon (<code>;</code>). For example:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x[i=1:4; mod(i, 2)==0])
JuMP.Containers.SparseAxisArray{VariableRef,1,Tuple{Int64}} with 2 entries:
  [4]  =  x[4]
  [2]  =  x[2]</code></pre><p>Note that with many index dimensions and a large amount of sparsity, variable construction may be unnecessarily slow if the semi-colon syntax is naively applied. When using the semi-colon as a filter, JuMP iterates over <em>all</em> indices and evaluates the conditional for each combination. When this is undesired, the recommended work-around is to work directly with a list of tuples or create a dictionary. Consider the following examples:</p><pre><code class="language-jl">N = 10
S = [(1, 1, 1),(N, N, N)]
# Slow. It evaluates conditional N^3 times.
@variable(model, x1[i=1:N, j=1:N, k=1:N; (i, j, k) in S])
# Fast.
@variable(model, x2[S])
# Fast. Manually constructs a dictionary and fills it.
x3 = Dict()
for (i, j, k) in S
    x3[i, j, k] = @variable(model)
    # Optional, if you care about pretty printing:
    set_name(x3[i, j, k], "x[$i,$j,$k]")
end</code></pre><h3><a class="nav-anchor" href="#variable_forcing-1" id="variable_forcing-1">Forcing the container type</a></h3><p>When creating a container of JuMP variables, JuMP will attempt to choose the tightest container type that can store the JuMP variables. Thus, it will prefer to create an Array before a DenseAxisArray and a DenseAxisArray before a SparseAxisArray. However, because this happens at compile time, it does not always make the best choice. To illustrate this, consider the following example:</p><pre><code class="language-julia-repl">julia&gt; A = 1:2
1:2

julia&gt; @variable(model, x[A])
1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:
    Dimension 1, 1:2
And data, a 2-element Array{VariableRef,1}:
 x[1]
 x[2]</code></pre><p>Since the value (and type) of <code>A</code> is unknown at parsing time, JuMP is unable to infer that <code>A</code> is a one-based integer range. Therefore, JuMP creates a <code>DenseAxisArray</code>, even though it could store these two variables in a standard one-dimensional <code>Array</code>.</p><p>We can share our knowledge that it is possible to store these JuMP variables as an array by setting the <code>container</code> keyword:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, y[A], container=Array)
2-element Array{VariableRef,1}:
 y[1]
 y[2]</code></pre><p>JuMP now creates a vector of JuMP variables instead of a DenseAxisArray. Note that choosing an invalid container type will throw an error.</p><h2><a class="nav-anchor" href="#Integrality-shortcuts-1" id="Integrality-shortcuts-1">Integrality shortcuts</a></h2><p>Adding integrality constraints to a model such as <code>@constraint(model, x in MOI.ZeroOne())</code> and <code>@constraint(model, x in MOI.Integer())</code> is a common operation. Therefore, JuMP supports two shortcuts for adding such constraints.</p><h4><a class="nav-anchor" href="#Binary-(ZeroOne)-constraints-1" id="Binary-(ZeroOne)-constraints-1">Binary (ZeroOne) constraints</a></h4><p>Binary optimization variables are constrained to the set <span>$x \in \{0, 1\}$</span>. (The <code>MOI.ZeroOne</code> set in MathOptInterface.) Binary optimization variables can be created in JuMP by passing <code>Bin</code> as an optional positional argument:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x, Bin)
x</code></pre><p>We can check if an optimization variable is binary by calling <a href="#JuMP.is_binary"><code>is_binary</code></a> on the JuMP variable, and binary constraints can be removed with <a href="#JuMP.unset_binary"><code>unset_binary</code></a>.</p><pre><code class="language-julia-repl">julia&gt; is_binary(x)
true

julia&gt; unset_binary(x)

julia&gt; is_binary(x)
false</code></pre><p>Binary optimization variables can also be created by setting the <code>binary</code> keyword to <code>true</code>.</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x, binary=true)
x</code></pre><h4><a class="nav-anchor" href="#Integer-constraints-1" id="Integer-constraints-1">Integer constraints</a></h4><p>Integer optimization variables are constrained to the set <span>$x \in \mathbb{Z}$</span>. (The <code>MOI.Integer</code> set in MathOptInterface.) Integer optimization variables can be created in JuMP by passing <code>Int</code> as an optional positional argument:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x, Int)
x</code></pre><p>Integer optimization variables can also be created by setting the <code>integer</code> keyword to <code>true</code>.</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x, integer=true)
x</code></pre><p>We can check if an optimization variable is integer by calling <a href="#JuMP.is_integer"><code>is_integer</code></a> on the JuMP variable, and integer constraints can be removed with <a href="#JuMP.unset_integer"><code>unset_integer</code></a>.</p><pre><code class="language-julia-repl">julia&gt; is_integer(x)
true

julia&gt; unset_integer(x)

julia&gt; is_integer(x)
false</code></pre><h2><a class="nav-anchor" href="#Semidefinite-variables-1" id="Semidefinite-variables-1">Semidefinite variables</a></h2><p>JuMP also supports modeling with semidefinite variables. A square symmetric matrix <span>$X$</span> is positive semidefinite if all eigenvalues are nonnegative. We can declare a matrix of JuMP variables to be positive semidefinite as follows:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x[1:2, 1:2], PSD)
2×2 LinearAlgebra.Symmetric{VariableRef,Array{VariableRef,2}}:
 x[1,1]  x[1,2]
 x[1,2]  x[2,2]</code></pre><p>or using the syntax for <a href="#Variables-constrained-on-creation-1">Variables constrained on creation</a>:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x[1:2, 1:2] in PSDCone())
2×2 LinearAlgebra.Symmetric{VariableRef,Array{VariableRef,2}}:
 x[1,1]  x[1,2]
 x[1,2]  x[2,2]</code></pre><p>Note that <code>x</code> must be a square 2-dimensional <code>Array</code> of JuMP variables; it cannot be a DenseAxisArray or a SparseAxisArray. (See <a href="#Variable-containers-1">Variable containers</a>, above, for more on this.)</p><p>You can also impose a weaker constraint that the square matrix is only symmetric (instead of positive semidefinite) as follows:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x[1:2, 1:2], Symmetric)
2×2 LinearAlgebra.Symmetric{VariableRef,Array{VariableRef,2}}:
 x[1,1]  x[1,2]
 x[1,2]  x[2,2]</code></pre><h2><a class="nav-anchor" href="#Anonymous-JuMP-variables-1" id="Anonymous-JuMP-variables-1">Anonymous JuMP variables</a></h2><p>In all of the above examples, we have created <em>named</em> JuMP variables. However, it is also possible to create so called <em>anonymous</em> JuMP variables. To create an anonymous JuMP variable, we drop the name of the variable from the macro call. This means dropping the second positional argument if the JuMP variable is a scalar, or dropping the name before the square bracket (<code>[</code>) if a container is being created. For example:</p><pre><code class="language-julia-repl">julia&gt; x = @variable(model)
noname</code></pre><p>This shows how <code>@variable(model, x)</code> is really short for:</p><pre><code class="language-julia-repl">julia&gt; x = model[:x] = @variable(model, base_name="x")
x</code></pre><p>An <code>Array</code> of anonymous JuMP variables can be created as follows:</p><pre><code class="language-julia-repl">julia&gt; y = @variable(model, [i=1:2])
2-element Array{VariableRef,1}:
 noname
 noname</code></pre><p>If necessary, you can store <code>x</code> in <code>model</code> as follows:</p><pre><code class="language-none">julia&gt; model[:x] = x</code></pre><p>The <code>&lt;=</code> and <code>&gt;=</code> short-hand cannot be used to set bounds on anonymous JuMP variables. Instead, you should use the <code>lower_bound</code> and <code>upper_bound</code> keywords.</p><p>Passing the <code>Bin</code> and <code>Int</code> variable types are also invalid. Instead, you should use the <code>binary</code> and <code>integer</code> keywords.</p><p>Thus, the anonymous variant of <code>@variable(model, x[i=1:2] &gt;= i, Int)</code> is:</p><pre><code class="language-julia-repl">julia&gt; x = @variable(model, [i=1:2], base_name="x", lower_bound=i, integer=true)
2-element Array{VariableRef,1}:
 x[1]
 x[2]</code></pre><div class="admonition warn"><div class="admonition-title">Warn</div><div class="admonition-text"><p>Creating two named JuMP variables with the same name results in an error at runtime. Use anonymous variables as an alternative.</p></div></div><h2><a class="nav-anchor" href="#Variables-constrained-on-creation-1" id="Variables-constrained-on-creation-1">Variables constrained on creation</a></h2><div class="admonition info"><div class="admonition-title">Info</div><div class="admonition-text"><p>When using JuMP in <a href="../solvers/#Direct-mode-1">Direct mode</a>, it may be required to constrain variables on creation instead of constraining free variables as the solver may only support variables constrained on creation. In <a href="../solvers/#Automatic-and-Manual-modes-1">Automatic and Manual modes</a>, both ways of adding constraints on variables are equivalent. Indeed, during the copy of the cache to the optimizer, the choice of the constraints on variables that are copied as variables constrained on creation does not depend on how it was added to the cache.</p></div></div><p>All uses of the <code>@variable</code> macro documented so far translate to a separate call for variable creation and adding of constraints.</p><p>For example, <code>@variable(model, x &gt;= 0, Int)</code>, is equivalent to:</p><pre><code class="language-julia">@variable(model, x)
set_lower_bound(x, 0.0)
@constraint(model, x in MOI.Integer())</code></pre><p>Importantly, the bound and integrality constraints are added <em>after</em> the variable has been created.</p><p>However, some solvers require a constraining set <em>at creation time</em>. We say that these variables are <em>constrained on creation</em>.</p><p>Use <code>in</code> within <code>@variable</code> to access the special syntax for constraining variables on creation. For example, the following creates a vector of variables constrained on creation to belong to the <a href="../constraints/#JuMP.SecondOrderCone"><code>SecondOrderCone</code></a>:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, y[1:3] in SecondOrderCone())
3-element Array{VariableRef,1}:
 y[1]
 y[2]
 y[3]</code></pre><p>For contrast, the more standard approach is as follows:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x[1:3])
3-element Array{VariableRef,1}:
 x[1]
 x[2]
 x[3]

julia&gt; @constraint(model, x in SecondOrderCone())
[x[1], x[2], x[3]] ∈ MathOptInterface.SecondOrderCone(3)</code></pre><p>The technical difference between the former and the latter is that the former calls <code>MOI.add_constrained_variables</code> while the latter calls <code>MOI.add_variables</code> and then <code>MOI.add_constraint</code>. This distinction is important only in <a href="../solvers/#Direct-mode-1">Direct mode</a>, depending on the solver being used. It's often not possible to delete the <a href="../constraints/#JuMP.SecondOrderCone"><code>SecondOrderCone</code></a> constraint if it was specified at variable creation time.</p><h3><a class="nav-anchor" href="#The-set-keyword-1" id="The-set-keyword-1">The <code>set</code> keyword</a></h3><p>An alternate syntax to <code>x in Set</code> is to use the <code>set</code> keyword of <a href="#JuMP.@variable"><code>@variable</code></a>. This is most useful when creating anonymous variables:</p><pre><code class="language-julia">x = @variable(model, [1:2, 1:2], set = PSDCone())</code></pre><h2><a class="nav-anchor" href="#User-defined-containers-1" id="User-defined-containers-1">User-defined containers</a></h2><p>In the section <a href="#Variable-containers-1">Variable containers</a>, we explained how JuMP supports the efficient creation of collections of JuMP variables in three types of containers. However, users are also free to create collections of JuMP variables in their own datastructures. For example, the following code creates a dictionary with symmetric matrices as the values:</p><pre><code class="language-julia-repl">julia&gt; variables = Dict{Symbol, Array{VariableRef,2}}()
Dict{Symbol,Array{VariableRef,2}} with 0 entries

julia&gt; for key in [:A, :B]
           global variables[key] = @variable(model, [1:2, 1:2])
       end

julia&gt; variables
Dict{Symbol,Array{VariableRef,2}} with 2 entries:
  :A =&gt; VariableRef[noname noname; noname noname]
  :B =&gt; VariableRef[noname noname; noname noname]</code></pre><h2><a class="nav-anchor" href="#Deleting-variables-1" id="Deleting-variables-1">Deleting variables</a></h2><p>JuMP supports the deletion of optimization variables.  To delete variables, we can use the <a href="../constraints/#JuMP.delete"><code>delete</code></a> method. We can also check whether <code>x</code> is a valid JuMP variable in <code>model</code> using the <a href="../constraints/#JuMP.is_valid"><code>is_valid</code></a> method:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x)
x

julia&gt; is_valid(model, x)
true

julia&gt; delete(model, x)

julia&gt; is_valid(model, x)
false</code></pre><h2><a class="nav-anchor" href="#Listing-all-variables-1" id="Listing-all-variables-1">Listing all variables</a></h2><p>Use <a href="#JuMP.all_variables"><code>JuMP.all_variables</code></a> to obtain a list of all variables present in the model. This is useful for performing operations like:</p><ul><li>relaxing all integrality constraints in the model</li><li>setting the starting values for variables to the result of the last solve</li></ul><h2><a class="nav-anchor" href="#Start-values-1" id="Start-values-1">Start values</a></h2><p>There are two ways to provide a primal starting solution (also called MIP-start or a warmstart) for each variable:</p><ul><li>using the <code>start</code> keyword in the <a href="#JuMP.@variable"><code>@variable</code></a> macro</li><li>using <a href="#JuMP.set_start_value"><code>set_start_value</code></a></li></ul><p>The starting value of a variable can be queried using <a href="#JuMP.start_value"><code>start_value</code></a>. If no start value has been set, <a href="#JuMP.start_value"><code>start_value</code></a> will return <code>nothing</code>.</p><pre><code class="language-julia-repl">julia&gt; @variable(model, x)
x

julia&gt; start_value(x)

julia&gt; @variable(model, y, start = 1)
y

julia&gt; start_value(y)
1.0

julia&gt; set_start_value(y, 2)

julia&gt; start_value(y)
2.0</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Prior to JuMP 0.19, the previous solution to a solve was automatically set as the new starting value. JuMP 0.19 no longer does this automatically. To reproduce the functionality, use:</p><pre><code class="language-julia">set_start_value.(all_variables(model), value.(all_variables(model)))</code></pre></div></div><h2><a class="nav-anchor" href="#variables-1" id="variables-1">The <code>@variables</code> macro</a></h2><p>If you have many <a href="#JuMP.@variable"><code>@variable</code></a> calls, JuMP provides the macro <a href="#JuMP.@variables"><code>@variables</code></a> that can improve readability:</p><pre><code class="language-julia-repl">julia&gt; @variables(model, begin
           x
           y[i=1:2] &gt;= i, (start = i, base_name = "Y_$i")
           z, Bin
       end)

julia&gt; print(model)
Feasibility
Subject to
 Y_1[1] ≥ 1.0
 Y_2[2] ≥ 2.0
 z binary</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Keyword arguments must be contained within parentheses. (See the example above.)</p></div></div><h2><a class="nav-anchor" href="#Reference-1" id="Reference-1">Reference</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.@variable" id="JuMP.@variable"><code>JuMP.@variable</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@variable(model, kw_args...)</code></pre><p>Add an <em>anonymous</em> variable to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the variable.</p><pre><code class="language-none">@variable(model, expr, args..., kw_args...)</code></pre><p>Add a variable to the model <code>model</code> described by the expression <code>expr</code>, the positional arguments <code>args</code> and the keyword arguments <code>kw_args</code>. The expression <code>expr</code> can either be (note that in the following the symbol <code>&lt;=</code> can be used instead of <code>≤</code> and the symbol <code>&gt;=</code>can be used instead of <code>≥</code>)</p><ul><li>of the form <code>varexpr</code> creating variables described by <code>varexpr</code>;</li><li>of the form <code>varexpr ≤ ub</code> (resp. <code>varexpr ≥ lb</code>) creating variables described by <code>varexpr</code> with upper bounds given by <code>ub</code> (resp. lower bounds given by <code>lb</code>);</li><li>of the form <code>varexpr == value</code> creating variables described by <code>varexpr</code> with fixed values given by <code>value</code>; or</li><li>of the form <code>lb ≤ varexpr ≤ ub</code> or <code>ub ≥ varexpr ≥ lb</code> creating variables described by <code>varexpr</code> with lower bounds given by <code>lb</code> and upper bounds given by <code>ub</code>.</li><li>of the form <code>varexpr in set</code> creating variables described by <code>varexpr</code> constrained to belong to <code>set</code>, see <a href="#Variables-constrained-on-creation-1">Variables constrained on creation</a>.</li></ul><p>The expression <code>varexpr</code> can either be</p><ul><li>of the form <code>varname</code> creating a scalar real variable of name <code>varname</code>;</li><li>of the form <code>varname[...]</code> or <code>[...]</code> creating a container of variables (see <a href="../containers/#Containers-in-macros-1">Containers in macros</a>).</li></ul><p>The recognized positional arguments in <code>args</code> are the following:</p><ul><li><code>Bin</code>: Sets the variable to be binary, i.e. either 0 or 1.</li><li><code>Int</code>: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...</li><li><code>Symmetric</code>: Only available when creating a square matrix of variables, i.e. when <code>varexpr</code> is of the form <code>varname[1:n,1:n]</code> or <code>varname[i=1:n,j=1:n]</code>. It creates a symmetric matrix of variable, that is, it only creates a new variable for <code>varname[i,j]</code> with <code>i ≤ j</code> and sets <code>varname[j,i]</code> to the same variable as <code>varname[i,j]</code>. It is equivalent to using <code>varexpr in SymMatrixSpace()</code> as <code>expr</code>.</li><li><code>PSD</code>: The square matrix of variable is both <code>Symmetric</code> and constrained to be positive semidefinite. It is equivalent to using <code>varexpr in PSDCone()</code> as <code>expr</code>.</li></ul><p>The recognized keyword arguments in <code>kw_args</code> are the following:</p><ul><li><code>base_name</code>: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>.</li><li><code>lower_bound</code>: Sets the value of the variable lower bound.</li><li><code>upper_bound</code>: Sets the value of the variable upper bound.</li><li><code>start</code>: Sets the variable starting value used as initial guess in optimization.</li><li><code>binary</code>: Sets whether the variable is binary or not.</li><li><code>integer</code>: Sets whether the variable is integer or not.</li><li><code>variable_type</code>: See the "Note for extending the variable macro" section below.</li><li><code>set</code>: Equivalent to using <code>varexpr in value</code> as <code>expr</code> where <code>value</code> is the value of the keyword argument.</li><li><code>container</code>: Specify the container type, see <a href="../containers/#Containers-in-macros-1">Containers in macros</a>.</li></ul><p><strong>Examples</strong></p><p>The following are equivalent ways of creating a variable <code>x</code> of name <code>x</code> with lower bound 0:</p><pre><code class="language-julia"># Specify everything in `expr`
@variable(model, x &gt;= 0)
# Specify the lower bound using a keyword argument
@variable(model, x, lower_bound=0)
# Specify everything in `kw_args`
x = @variable(model, base_name="x", lower_bound=0)</code></pre><p>The following are equivalent ways of creating a <code>DenseAxisArray</code> of index set <code>[:a, :b]</code> and with respective upper bounds 2 and 3 and names <code>x[a]</code> and <code>x[b]</code>. The upper bound can either be specified in <code>expr</code>:</p><pre><code class="language-julia">ub = Dict(:a =&gt; 2, :b =&gt; 3)
@variable(model, x[i=keys(ub)] &lt;= ub[i])

# output
1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:
    Dimension 1, Symbol[:a, :b]
And data, a 2-element Array{VariableRef,1}:
 x[a]
 x[b]</code></pre><p>or it can be specified with the <code>upper_bound</code> keyword argument:</p><pre><code class="language-julia">@variable(model, y[i=keys(ub)], upper_bound=ub[i])

# output
1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:
    Dimension 1, Symbol[:a, :b]
And data, a 2-element Array{VariableRef,1}:
 y[a]
 y[b]</code></pre><p><strong>Note for extending the variable macro</strong></p><p>The single scalar variable or each scalar variable of the container are created using <code>add_variable(model, build_variable(_error, info, extra_args...; extra_kw_args...))</code> where</p><ul><li><code>model</code> is the model passed to the <code>@variable</code> macro;</li><li><code>_error</code> is an error function with a single <code>String</code> argument showing the <code>@variable</code> call in addition to the error message given as argument;</li><li><code>info</code> is the <code>VariableInfo</code> struct containing the information gathered in <code>expr</code>, the recognized keyword arguments (except <code>base_name</code> and <code>variable_type</code>) and the recognized positional arguments (except <code>Symmetric</code> and <code>PSD</code>);</li><li><code>extra_args</code> are the unrecognized positional arguments of <code>args</code> plus the value of the <code>variable_type</code> keyword argument if present. The <code>variable_type</code> keyword argument allows the user to pass a position argument to <code>build_variable</code> without the need to give a positional argument to <code>@variable</code>. In particular, this allows the user to give a positional argument to the <code>build_variable</code> call when using the anonymous single variable syntax <code>@variable(model, kw_args...)</code>; and</li><li><code>extra_kw_args</code> are the unrecognized keyword argument of <code>kw_args</code>.</li></ul><p><strong>Examples</strong></p><p>The following creates a variable <code>x</code> of name <code>x</code> with <code>lower_bound</code> 0 as with the first example above but does it without using the <code>@variable</code> macro</p><pre><code class="language-julia">info = VariableInfo(true, 0, false, NaN, false, NaN, false, NaN, false, false)
JuMP.add_variable(model, JuMP.build_variable(error, info), "x")</code></pre><p>The following creates a <code>DenseAxisArray</code> of index set <code>[:a, :b]</code> and with respective upper bounds 2 and 3 and names <code>x[a]</code> and <code>x[b]</code> as with the second example above but does it without using the <code>@variable</code> macro</p><pre><code class="language-julia"># Without the `@variable` macro
x = JuMP.Containers.container(i -&gt; begin
        info = VariableInfo(false, NaN, true, ub[i], false, NaN, false, NaN, false, false)
        x[i] = JuMP.add_variable(model, JuMP.build_variable(error, info), "x[$i]")
    end, JuMP.Containers.vectorized_product(keys(ub)))

# output
1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:
    Dimension 1, Symbol[:a, :b]
And data, a 2-element Array{VariableRef,1}:
 x[a]
 x[b]</code></pre><p>The following are equivalent ways of creating a <code>Matrix</code> of size <code>N x N</code> with variables custom variables created with a JuMP extension using the <code>Poly(X)</code> positional argument to specify its variables:</p><pre><code class="language-julia"># Using the `@variable` macro
@variable(model, x[1:N,1:N], Symmetric, Poly(X))
# Without the `@variable` macro
x = Matrix{JuMP.variable_type(model, Poly(X))}(N, N)
info = VariableInfo(false, NaN, false, NaN, false, NaN, false, NaN, false, false)
for i in 1:N, j in i:N
    x[i,j] = x[j,i] = JuMP.add_variable(model, build_variable(error, info, Poly(X)), "x[$i,$j]")
end</code></pre></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/macros.jl#L1002-L1163" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.@variables" id="JuMP.@variables"><code>JuMP.@variables</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@variables(m, args...)</code></pre><p>Adds multiple variables to model at once, in the same fashion as <code>@variable</code> macro. The model must be the first argument, and multiple variables can be added on multiple lines wrapped in a <code>begin ... end</code> block. For example:</p><pre><code class="language-none">@variables(m, begin
    x
    y[1:2] &gt;= 0
    z, Bin, (start = 0)
end)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Keyword arguments must be contained within parentheses (refer to the example above).</p></div></div></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/macros.jl#L691-L704" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.owner_model" id="JuMP.owner_model"><code>JuMP.owner_model</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">owner_model(s::AbstractJuMPScalar)</code></pre><p>Return the model owning the scalar <code>s</code>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/JuMP.jl#L712-L716" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.VariableRef" id="JuMP.VariableRef"><code>JuMP.VariableRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">VariableRef &lt;: AbstractVariableRef</code></pre><p>Holds a reference to the model and the corresponding MOI.VariableIndex.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L100-L104" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.all_variables" id="JuMP.all_variables"><code>JuMP.all_variables</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">all_variables(model::Model)::Vector{VariableRef}</code></pre><p>Returns a list of all variables currently in the model. The variables are ordered by creation time.</p><p><strong>Example</strong></p><pre><code class="language-julia">model = Model()
@variable(model, x)
@variable(model, y)
all_variables(model)

# output

2-element Array{VariableRef,1}:
 x
 y</code></pre></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L958-L977" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.num_variables" id="JuMP.num_variables"><code>JuMP.num_variables</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">num_variables(model::Model)::Int64</code></pre><p>Returns number of variables in <code>model</code>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/JuMP.jl#L424-L428" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.has_lower_bound" id="JuMP.has_lower_bound"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">has_lower_bound(v::VariableRef)</code></pre><p>Return <code>true</code> if <code>v</code> has a lower bound. If <code>true</code>, the lower bound can be queried with <a href="#JuMP.lower_bound"><code>lower_bound</code></a>. See also <a href="../constraints/#JuMP.LowerBoundRef"><code>LowerBoundRef</code></a>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L347-L352" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.lower_bound" id="JuMP.lower_bound"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">lower_bound(v::VariableRef)</code></pre><p>Return the lower bound of a variable. Error if one does not exist. See also <a href="#JuMP.has_lower_bound"><code>has_lower_bound</code></a>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L414-L419" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.set_lower_bound" id="JuMP.set_lower_bound"><code>JuMP.set_lower_bound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">set_lower_bound(v::VariableRef, lower::Number)</code></pre><p>Set the lower bound of a variable. If one does not exist, create a new lower bound constraint. See also <a href="#JuMP.delete_lower_bound"><code>delete_lower_bound</code></a>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L369-L374" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.delete_lower_bound" id="JuMP.delete_lower_bound"><code>JuMP.delete_lower_bound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">delete_lower_bound(v::VariableRef)</code></pre><p>Delete the lower bound constraint of a variable.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L404-L408" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.has_upper_bound" id="JuMP.has_upper_bound"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">has_upper_bound(v::VariableRef)</code></pre><p>Return <code>true</code> if <code>v</code> has a upper bound. If <code>true</code>, the upper bound can be queried with <a href="#JuMP.upper_bound"><code>upper_bound</code></a>. See also <a href="../constraints/#JuMP.UpperBoundRef"><code>UpperBoundRef</code></a>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L431-L436" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.upper_bound" id="JuMP.upper_bound"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">upper_bound(v::VariableRef)</code></pre><p>Return the upper bound of a variable. Error if one does not exist. See also <a href="#JuMP.has_upper_bound"><code>has_upper_bound</code></a>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L494-L499" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.set_upper_bound" id="JuMP.set_upper_bound"><code>JuMP.set_upper_bound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">set_upper_bound(v::VariableRef,upper::Number)</code></pre><p>Set the upper bound of a variable. If one does not exist, create an upper bound constraint. See also <a href="#JuMP.delete_upper_bound"><code>delete_upper_bound</code></a>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L449-L454" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.delete_upper_bound" id="JuMP.delete_upper_bound"><code>JuMP.delete_upper_bound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">delete_upper_bound(v::VariableRef)</code></pre><p>Delete the upper bound constraint of a variable.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L484-L488" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.is_fixed" id="JuMP.is_fixed"><code>JuMP.is_fixed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">is_fixed(v::VariableRef)</code></pre><p>Return <code>true</code> if <code>v</code> is a fixed variable. If <code>true</code>, the fixed value can be queried with <a href="#JuMP.fix_value"><code>fix_value</code></a>. See also <a href="../constraints/#JuMP.FixRef"><code>FixRef</code></a>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L511-L516" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.fix_value" id="JuMP.fix_value"><code>JuMP.fix_value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fix_value(v::VariableRef)</code></pre><p>Return the value to which a variable is fixed. Error if one does not exist. See also <a href="#JuMP.is_fixed"><code>is_fixed</code></a>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L581-L586" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.fix" id="JuMP.fix"><code>JuMP.fix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fix(v::VariableRef, value::Number; force::Bool = false)</code></pre><p>Fix a variable to a value. Update the fixing constraint if one exists, otherwise create a new one. See also <a href="#JuMP.unfix"><code>unfix</code></a>.</p><p>If the variable already has variable bounds and <code>force=false</code>, calling <code>fix</code> will throw an error. If <code>force=true</code>, existing variable bounds will be deleted, and the fixing constraint will be added. Note a variable will have no bounds after a call to <a href="#JuMP.unfix"><code>unfix</code></a>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L529-L539" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.unfix" id="JuMP.unfix"><code>JuMP.unfix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">unfix(v::VariableRef)</code></pre><p>Delete the fixing constraint of a variable.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L571-L575" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.is_integer" id="JuMP.is_integer"><code>JuMP.is_integer</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">is_integer(v::VariableRef)</code></pre><p>Return <code>true</code> if <code>v</code> is constrained to be integer. See also <a href="#JuMP.IntegerRef"><code>IntegerRef</code></a>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L606-L611" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.set_integer" id="JuMP.set_integer"><code>JuMP.set_integer</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">set_integer(variable_ref::VariableRef)</code></pre><p>Add an integrality constraint on the variable <code>variable_ref</code>. See also <a href="#JuMP.unset_integer"><code>unset_integer</code></a>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L624-L629" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.unset_integer" id="JuMP.unset_integer"><code>JuMP.unset_integer</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">unset_integer(variable_ref::VariableRef)</code></pre><p>Remove the integrality constraint on the variable <code>variable_ref</code>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L646-L650" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.IntegerRef" id="JuMP.IntegerRef"><code>JuMP.IntegerRef</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">IntegerRef(v::VariableRef)</code></pre><p>Return a constraint reference to the constraint constrainting <code>v</code> to be integer. Errors if one does not exist.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L656-L661" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.is_binary" id="JuMP.is_binary"><code>JuMP.is_binary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">is_binary(v::VariableRef)</code></pre><p>Return <code>true</code> if <code>v</code> is constrained to be binary. See also <a href="#JuMP.BinaryRef"><code>BinaryRef</code></a>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L668-L672" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.set_binary" id="JuMP.set_binary"><code>JuMP.set_binary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">set_binary(v::VariableRef)</code></pre><p>Add a constraint on the variable <code>v</code> that it must take values in the set <span>$\{0,1\}$</span>. See also <a href="#JuMP.unset_binary"><code>unset_binary</code></a>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L685-L690" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.unset_binary" id="JuMP.unset_binary"><code>JuMP.unset_binary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">unset_binary(variable_ref::VariableRef)</code></pre><p>Remove the binary constraint on the variable <code>variable_ref</code>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L707-L711" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.BinaryRef" id="JuMP.BinaryRef"><code>JuMP.BinaryRef</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">BinaryRef(v::VariableRef)</code></pre><p>Return a constraint reference to the constraint constrainting <code>v</code> to be binary. Errors if one does not exist.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L717-L722" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.index-Tuple{VariableRef}" id="JuMP.index-Tuple{VariableRef}"><code>JuMP.index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">index(v::VariableRef)::MOI.VariableIndex</code></pre><p>Return the index of the variable that corresponds to <code>v</code> in the MOI backend.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L215-L219" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.optimizer_index-Tuple{VariableRef}" id="JuMP.optimizer_index-Tuple{VariableRef}"><code>JuMP.optimizer_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">optimizer_index(v::VariableRef)::MOI.VariableIndex</code></pre><p>Return the index of the variable that corresponds to <code>v</code> in the optimizer model. It throws <a href="../solvers/#JuMP.NoOptimizer"><code>NoOptimizer</code></a> if no optimizer is set and throws an <code>ErrorException</code> if the optimizer is set but is not attached.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/JuMP.jl#L779-L785" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.set_start_value" id="JuMP.set_start_value"><code>JuMP.set_start_value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">set_start_value(variable::VariableRef, value::Number)</code></pre><p>Set the start value (MOI attribute <code>VariablePrimalStart</code>) of the variable <code>v</code> to <code>value</code>. See also <a href="#JuMP.start_value"><code>start_value</code></a>.</p><p>Note: <code>VariablePrimalStart</code>s are sometimes called "MIP-starts" or "warmstarts".</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L742-L749" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.start_value" id="JuMP.start_value"><code>JuMP.start_value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">start_value(v::VariableRef)</code></pre><p>Return the start value (MOI attribute <code>VariablePrimalStart</code>) of the variable <code>v</code>. See also <a href="#JuMP.set_start_value"><code>set_start_value</code></a>.</p><p>Note: <code>VariablePrimalStart</code>s are sometimes called "MIP-starts" or "warmstarts".</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L729-L736" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.reduced_cost" id="JuMP.reduced_cost"><code>JuMP.reduced_cost</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">reduced_cost(x::VariableRef)::Float64</code></pre><p>Return the reduced cost associated with variable <code>x</code>.</p><p>Equivalent to querying the shadow price of the active variable bound (if one exists and is active).</p><p>See also: <a href="../constraints/#JuMP.shadow_price"><code>shadow_price</code></a>.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/e2fd3ebd9e3f5e6913ba461c0bc54e5cc92f061e/src/variables.jl#L928-L937" target="_blank">source</a></section><footer><hr/><a class="previous" href="../quickstart/"><span class="direction">Previous</span><span class="title">Quick Start Guide</span></a><a class="next" href="../expressions/"><span class="direction">Next</span><span class="title">Expressions</span></a></footer></article></body></HTML>