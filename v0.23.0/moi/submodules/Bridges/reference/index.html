<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · JuMP</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-44252521-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-44252521-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><script src="../../../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script><link href="../../../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img class="docs-light-only" src="../../../../assets/logo.svg" alt="JuMP logo"/><img class="docs-dark-only" src="../../../../assets/logo-dark.svg" alt="JuMP logo"/></a><form class="docs-search" action="../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../">Introduction</a></li><li><a class="tocitem" href="../../../../should_i_use/">Should I use JuMP?</a></li><li><a class="tocitem" href="../../../../installation/">Installation Guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/getting_started/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/getting_started_with_julia/">Getting started with Julia</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/getting_started_with_JuMP/">Getting started with JuMP</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/getting_started_with_sets_and_indexing/">Getting started with sets and indexing</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/getting_started_with_data_and_plotting/">Getting started with data and plotting</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/performance_tips/">Performance tips</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/design_patterns_for_larger_models/">Design patterns for larger models</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Linear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/linear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../tutorials/linear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../../../tutorials/linear/diet/">The diet problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/facility_location/">The facility location problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../../../../tutorials/linear/finance/">Financial modeling problems</a></li><li><a class="tocitem" href="../../../../tutorials/linear/geographic_clustering/">Geographical clustering</a></li><li><a class="tocitem" href="../../../../tutorials/linear/knapsack/">The knapsack problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/n-queens/">N-Queens</a></li><li><a class="tocitem" href="../../../../tutorials/linear/network_flows/">Network flow problems</a></li><li><a class="tocitem" href="../../../../tutorials/linear/prod/">The workforce scheduling problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/steelT3/">The SteelT3 problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/sudoku/">Sudoku</a></li><li><a class="tocitem" href="../../../../tutorials/linear/transp/">The transportation problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/urban_plan/">The urban planning problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/callbacks/">Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Nonlinear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/nonlinear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/portfolio/">Quadratic portfolio optimization</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/qcp/">Quadratically constrained programs</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/space_shuttle_reentry_trajectory/">Optimal control for a Space Shuttle reentry trajectory</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/rocket_control/">Rocket Control</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/rosenbrock/">The Rosenbrock function</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/mle/">Maximum likelihood estimation</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/clnlbeam/">The clnlbeam problem</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/querying_hessians/">Computing Hessians</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Conic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/conic/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../tutorials/conic/start_values/">Primal and dual warm-starts</a></li><li><a class="tocitem" href="../../../../tutorials/conic/tips_and_tricks/">Tips and Tricks</a></li><li><a class="tocitem" href="../../../../tutorials/conic/logistic_regression/">Logistic regression</a></li><li><a class="tocitem" href="../../../../tutorials/conic/cluster/">K-means clustering via SDP</a></li><li><a class="tocitem" href="../../../../tutorials/conic/corr_sdp/">The correlation problem</a></li><li><a class="tocitem" href="../../../../tutorials/conic/experiment_design/">Experiment design</a></li><li><a class="tocitem" href="../../../../tutorials/conic/max_cut_sdp/">SDP relaxations: max-cut</a></li><li><a class="tocitem" href="../../../../tutorials/conic/min_distortion/">The minimum distortion problem</a></li><li><a class="tocitem" href="../../../../tutorials/conic/min_ellipse/">Minimum ellipses</a></li><li><a class="tocitem" href="../../../../tutorials/conic/robust_uncertainty/">Robust uncertainty sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/algorithms/benders_decomposition/">Benders decomposition</a></li><li><a class="tocitem" href="../../../../tutorials/algorithms/cutting_stock_column_generation/">Column generation</a></li><li><a class="tocitem" href="../../../../tutorials/algorithms/tsp_lazy_constraints/">Traveling Salesperson Problem</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/applications/power_systems/">Power Systems</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../manual/models/">Models</a></li><li><a class="tocitem" href="../../../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../../manual/expressions/">Expressions</a></li><li><a class="tocitem" href="../../../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../../../manual/containers/">Containers</a></li><li><a class="tocitem" href="../../../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../../manual/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../../../manual/callbacks/">Solver-independent Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../reference/models/">Models</a></li><li><a class="tocitem" href="../../../../reference/variables/">Variables</a></li><li><a class="tocitem" href="../../../../reference/expressions/">Expressions</a></li><li><a class="tocitem" href="../../../../reference/objectives/">Objectives</a></li><li><a class="tocitem" href="../../../../reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../../reference/containers/">Containers</a></li><li><a class="tocitem" href="../../../../reference/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../../reference/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../../../reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../../reference/extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Background Information</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../background/algebraic_modeling_languages/">Algebraic modeling languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../developers/contributing/">Contributing</a></li><li><a class="tocitem" href="../../../../developers/extensions/">Extensions</a></li><li><a class="tocitem" href="../../../../developers/custom_solver_binaries/">Custom binaries</a></li><li><a class="tocitem" href="../../../../developers/style/">Style Guide</a></li><li><a class="tocitem" href="../../../../developers/roadmap/">Roadmap</a></li></ul></li><li><a class="tocitem" href="../../../../release_notes/">Release notes</a></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox" checked/><label class="tocitem" for="menuitem-8"><span class="docs-label">MathOptInterface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../">Introduction</a></li><li><a class="tocitem" href="../../../background/motivation/">Motivation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/example/">Solving a problem using MathOptInterface</a></li><li><a class="tocitem" href="../../../tutorials/implementing/">Implementing a solver interface</a></li><li><a class="tocitem" href="../../../tutorials/mathprogbase/">Transitioning from MathProgBase</a></li><li><a class="tocitem" href="../../../tutorials/bridging_constraint/">Implementing a constraint bridge</a></li><li><a class="tocitem" href="../../../tutorials/manipulating_expressions/">Manipulating expressions</a></li><li><a class="tocitem" href="../../../tutorials/latency/">Latency</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../manual/standard_form/">Standard form problem</a></li><li><a class="tocitem" href="../../../manual/models/">Models</a></li><li><a class="tocitem" href="../../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../manual/modification/">Problem modification</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox"/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../background/duality/">Duality</a></li><li><a class="tocitem" href="../../../background/infeasibility_certificates/">Infeasibility certificates</a></li><li><a class="tocitem" href="../../../background/naming_conventions/">Naming conventions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox"/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../reference/standard_form/">Standard form</a></li><li><a class="tocitem" href="../../../reference/models/">Models</a></li><li><a class="tocitem" href="../../../reference/variables/">Variables</a></li><li><a class="tocitem" href="../../../reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../reference/modification/">Modifications</a></li><li><a class="tocitem" href="../../../reference/nonlinear/">Nonlinear programming</a></li><li><a class="tocitem" href="../../../reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../reference/errors/">Errors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6" type="checkbox" checked/><label class="tocitem" for="menuitem-8-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-6-1" type="checkbox"/><label class="tocitem" for="menuitem-8-6-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-2" type="checkbox" checked/><label class="tocitem" for="menuitem-8-6-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../implementation/">Implementation</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Constraint-bridges"><span>Constraint bridges</span></a></li><li><a class="tocitem" href="#ref_variable_bridges"><span>Variable bridges</span></a></li><li><a class="tocitem" href="#Objective-bridges"><span>Objective bridges</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-3" type="checkbox"/><label class="tocitem" for="menuitem-8-6-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../FileFormats/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-4" type="checkbox"/><label class="tocitem" for="menuitem-8-6-4"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Utilities/overview/">Overview</a></li><li><a class="tocitem" href="../../Utilities/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-5" type="checkbox"/><label class="tocitem" for="menuitem-8-6-5"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Test/overview/">Overview</a></li><li><a class="tocitem" href="../../Test/reference/">API Reference</a></li></ul></li></ul></li><li><a class="tocitem" href="../../../release_notes/">Release notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">MathOptInterface</a></li><li><a class="is-disabled">Submodules</a></li><li><a class="is-disabled">Bridges</a></li><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/moi/submodules/Bridges/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Bridges"><a class="docs-heading-anchor" href="#Bridges">Bridges</a><a id="Bridges-1"></a><a class="docs-heading-anchor-permalink" href="#Bridges" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.AbstractBridge" href="#MathOptInterface.Bridges.AbstractBridge"><code>MathOptInterface.Bridges.AbstractBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBridge</code></pre><p>Represents a bridged constraint or variable in a <a href="#MathOptInterface.Bridges.AbstractBridgeOptimizer"><code>MathOptInterface.Bridges.AbstractBridgeOptimizer</code></a>. It contains the indices of the variables and constraints that it has created in the model. These can be obtained using <a href="../../../reference/models/#MathOptInterface.NumberOfVariables"><code>MathOptInterface.NumberOfVariables</code></a>, <a href="../../../reference/models/#MathOptInterface.ListOfVariableIndices"><code>MathOptInterface.ListOfVariableIndices</code></a>, <a href="../../../reference/models/#MathOptInterface.NumberOfConstraints"><code>MathOptInterface.NumberOfConstraints</code></a> and <a href="../../../reference/models/#MathOptInterface.ListOfConstraintIndices"><code>MathOptInterface.ListOfConstraintIndices</code></a> using <a href="../../../reference/models/#MathOptInterface.get"><code>MathOptInterface.get</code></a> with the bridge in place of the <a href="../../../reference/models/#MathOptInterface.ModelLike"><code>MathOptInterface.ModelLike</code></a>. Attributes of the bridged model such as <a href="../../../reference/constraints/#MathOptInterface.ConstraintDual"><code>MathOptInterface.ConstraintDual</code></a> and <a href="../../../reference/constraints/#MathOptInterface.ConstraintPrimal"><code>MathOptInterface.ConstraintPrimal</code></a>, can be obtained using <a href="../../../reference/models/#MathOptInterface.get"><code>MathOptInterface.get</code></a> with the bridge in place of the constraint index. These calls are used by the <a href="#MathOptInterface.Bridges.AbstractBridgeOptimizer"><code>MathOptInterface.Bridges.AbstractBridgeOptimizer</code></a> to communicate with the bridge so they should be implemented by the bridge.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.AbstractBridgeOptimizer" href="#MathOptInterface.Bridges.AbstractBridgeOptimizer"><code>MathOptInterface.Bridges.AbstractBridgeOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBridgeOptimizer</code></pre><p>A bridge optimizer applies given constraint bridges to a given optimizer thus extending the types of supported constraints. The attributes of the inner optimizer are automatically transformed to make the bridges transparent, e.g. the variables and constraints created by the bridges are hidden.</p><p>By convention, the inner optimizer should be stored in a <code>model</code> field and the dictionary mapping constraint indices to bridges should be stored in a <code>bridges</code> field. If a bridge optimizer deviates from these conventions, it should implement the functions <code>MOI.optimize!</code> and <code>bridge</code> respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.LazyBridgeOptimizer" href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>MathOptInterface.Bridges.LazyBridgeOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LazyBridgeOptimizer{OT&lt;:MOI.ModelLike} &lt;: AbstractBridgeOptimizer</code></pre><p>The <code>LazyBridgeOptimizer</code> combines several bridges, which are added using the <a href="#MathOptInterface.Bridges.add_bridge"><code>add_bridge</code></a> function.</p><p>Whenever a constraint is added, it only attempts to bridge it if it is not supported by the internal model (hence its name <code>Lazy</code>).</p><p>When bridging a constraint, it selects the minimal number of bridges needed.</p><p>For example, if a constraint <code>F</code>-in-<code>S</code> can be bridged into a constraint <code>F1</code>-in-<code>S1</code> (supported by the internal model) using bridge 1 or bridged into a constraint <code>F2</code>-in-<code>S2</code> (unsupported by the internal model) using bridge 2 which can then be bridged into a constraint <code>F3</code>-in-<code>S3</code> (supported by the internal model) using bridge 3, it will choose bridge 1 as it allows to bridge <code>F</code>-in-`S using only one bridge instead of two if it uses bridge 2 and 3.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.add_bridge" href="#MathOptInterface.Bridges.add_bridge"><code>MathOptInterface.Bridges.add_bridge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_bridge(b::LazyBridgeOptimizer, BT::Type{&lt;:AbstractBridge})</code></pre><p>Enable the use of the bridges of type <code>BT</code> by <code>b</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.remove_bridge" href="#MathOptInterface.Bridges.remove_bridge"><code>MathOptInterface.Bridges.remove_bridge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remove_bridge(b::LazyBridgeOptimizer, BT::Type{&lt;:AbstractBridge})</code></pre><p>Disable the use of the bridges of type <code>BT</code> by <code>b</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.has_bridge" href="#MathOptInterface.Bridges.has_bridge"><code>MathOptInterface.Bridges.has_bridge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_bridge(b::LazyBridgeOptimizer, BT::Type{&lt;:AbstractBridge})</code></pre><p>Return a <code>Bool</code> indicating whether the bridges of type <code>BT</code> are used by <code>b</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.full_bridge_optimizer" href="#MathOptInterface.Bridges.full_bridge_optimizer"><code>MathOptInterface.Bridges.full_bridge_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">full_bridge_optimizer(model::MOI.ModelLike, ::Type{T}) where {T}</code></pre><p>Returns a <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>LazyBridgeOptimizer</code></a> bridging <code>model</code> for every bridge defined in this package (see below for the few exceptions) and for the coefficient type <code>T</code> in addition to the bridges in the list returned by <code>MOI.get(model, MOI.Bridges.ListOfNonstandardBridges{T}())</code>.</p><p>See also <a href="#MathOptInterface.Bridges.ListOfNonstandardBridges"><code>ListOfNonstandardBridges</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The following bridges are not added by <code>full_bridge_optimizer</code> except if they are in the list returned by <code>MOI.get(model, MOI.Bridges.ListOfNonstandardBridges{T}())</code> (see the docstrings of the corresponding bridge for the reason they are not added):</p><ul><li><a href="#MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge"><code>Constraint.SOCtoNonConvexQuadBridge</code></a>, <a href="#MathOptInterface.Bridges.Constraint.RSOCtoNonConvexQuadBridge"><code>Constraint.RSOCtoNonConvexQuadBridge</code></a> and <a href="#MathOptInterface.Bridges.Constraint.SOCtoPSDBridge"><code>Constraint.SOCtoPSDBridge</code></a>.</li><li>The subtypes of <a href="#MathOptInterface.Bridges.Constraint.AbstractToIntervalBridge"><code>Constraint.AbstractToIntervalBridge</code></a> (i.e. <a href="#MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge"><code>Constraint.GreaterToIntervalBridge</code></a> and <a href="#MathOptInterface.Bridges.Constraint.LessToIntervalBridge"><code>Constraint.LessToIntervalBridge</code></a>) if <code>T</code> is not a subtype of <code>AbstractFloat</code>.</li></ul></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.ListOfNonstandardBridges" href="#MathOptInterface.Bridges.ListOfNonstandardBridges"><code>MathOptInterface.Bridges.ListOfNonstandardBridges</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ListOfNonstandardBridges{T}() &lt;: MOI.AbstractOptimizerAttribute</code></pre><p>Any optimizer can be wrapped in a <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>LazyBridgeOptimizer</code></a> using <a href="#MathOptInterface.Bridges.full_bridge_optimizer"><code>full_bridge_optimizer</code></a>. However, by default <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>LazyBridgeOptimizer</code></a> uses a limited set of bridges that are:</p><ol><li>implemented in <code>MOI.Bridges</code></li><li>generally applicable for all optimizers.</li></ol><p>For some optimizers however, it is useful to add additional bridges, such as those that are implemented in external packages (e.g., within the solver package itself) or only apply in certain circumstances (e.g., <a href="#MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge"><code>Constraint.SOCtoNonConvexQuadBridge</code></a>).</p><p>Such optimizers should implement the <code>ListOfNonstandardBridges</code> attribute to return a vector of bridge types that are added by <a href="#MathOptInterface.Bridges.full_bridge_optimizer"><code>full_bridge_optimizer</code></a> in addition to the list of default bridges.</p><p>Note that optimizers implementing <code>ListOfNonstandardBridges</code> may require package-specific functions or sets to be used if the non-standard bridges are not added. Therefore, you are recommended to use <code>model = MOI.instantiate(Package.Optimizer; with_bridge_type = T)</code> instead of <code>model = MOI.instantiate(Package.Optimizer)</code>. See <a href="../../../reference/models/#MathOptInterface.instantiate"><code>MathOptInterface.instantiate</code></a>.</p><p><strong>Examples</strong></p><p><strong>An optimizer using a non-default bridge in <code>MOI.Bridges</code></strong></p><p>Solvers supporting <a href="../../../reference/standard_form/#MathOptInterface.ScalarQuadraticFunction"><code>MOI.ScalarQuadraticFunction</code></a> can support <a href="../../../reference/standard_form/#MathOptInterface.SecondOrderCone"><code>MOI.SecondOrderCone</code></a> and <a href="../../../reference/standard_form/#MathOptInterface.RotatedSecondOrderCone"><code>MOI.RotatedSecondOrderCone</code></a> by defining:</p><pre><code class="language-julia hljs">function MOI.get(::MyQuadraticOptimizer, ::ListOfNonstandardBridges{Float64})
    return Type[
        MOI.Bridges.Constraint.SOCtoNonConvexQuadBridge{Float64},
        MOI.Bridges.Constraint.RSOCtoNonConvexQuadBridge{Float64},
    ]
end</code></pre><p><strong>An optimizer defining an internal bridge</strong></p><p>Suppose an optimizer can exploit specific structure of a constraint, e.g., it can exploit the structure of the matrix <code>A</code> in the linear system of equations <code>A * x = b</code>.</p><p>The optimizer can define the function:</p><pre><code class="language-julia hljs">struct MatrixAffineFunction{T} &lt;: MOI.AbstractVectorFunction
    A::SomeStructuredMatrixType{T}
    b::Vector{T}
end</code></pre><p>and then a bridge</p><pre><code class="language-julia hljs">struct MatrixAffineFunctionBridge{T} &lt;: MOI.Constraint.AbstractBridge
    # ...
end
# ...</code></pre><p>from <code>VectorAffineFunction{T}</code> to the <code>MatrixAffineFunction</code>. Finally, it defines:</p><pre><code class="language-julia hljs">function MOI.get(::Optimizer{T}, ::ListOfNonstandardBridges{T}) where {T}
    return Type[MatrixAffineFunctionBridge{T}]
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.debug_supports_constraint" href="#MathOptInterface.Bridges.debug_supports_constraint"><code>MathOptInterface.Bridges.debug_supports_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">debug_supports_constraint(
    b::LazyBridgeOptimizer,
    F::Type{&lt;:MOI.AbstractFunction},
    S::Type{&lt;:MOI.AbstractSet};
    io::IO = Base.stdout,
)</code></pre><p>Prints to <code>io</code> explanations for the value of <a href="../../../reference/constraints/#MathOptInterface.supports_constraint"><code>MOI.supports_constraint</code></a> with the same arguments.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.debug_supports" href="#MathOptInterface.Bridges.debug_supports"><code>MathOptInterface.Bridges.debug_supports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">debug_supports(
    b::LazyBridgeOptimizer,
    ::MOI.ObjectiveFunction{F};
    io::IO = Base.stdout,
) where F</code></pre><p>Prints to <code>io</code> explanations for the value of <a href="../../../reference/models/#MathOptInterface.supports"><code>MOI.supports</code></a> with the same arguments.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.bridged_variable_function" href="#MathOptInterface.Bridges.bridged_variable_function"><code>MathOptInterface.Bridges.bridged_variable_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bridged_variable_function(
    b::AbstractBridgeOptimizer,
    vi::MOI.VariableIndex,
)</code></pre><p>Return a <code>MOI.AbstractScalarFunction</code> of variables of <code>b.model</code> that equals <code>vi</code>. That is, if the variable <code>vi</code> is bridged, it returns its expression in terms of the variables of <code>b.model</code>. Otherwise, it returns <code>vi</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.unbridged_variable_function" href="#MathOptInterface.Bridges.unbridged_variable_function"><code>MathOptInterface.Bridges.unbridged_variable_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unbridged_variable_function(
    b::AbstractBridgeOptimizer,
    vi::MOI.VariableIndex,
)</code></pre><p>Return a <code>MOI.AbstractScalarFunction</code> of variables of <code>b</code> that equals <code>vi</code>. That is, if the variable <code>vi</code> is an internal variable of <code>b.model</code> created by a bridge but not visible to the user, it returns its expression in terms of the variables of bridged variables. Otherwise, it returns <code>vi</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.bridged_function" href="#MathOptInterface.Bridges.bridged_function"><code>MathOptInterface.Bridges.bridged_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bridged_function(b::AbstractBridgeOptimizer, value)::typeof(value)</code></pre><p>Substitute any bridged <a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <code>value</code> by an equivalent expression in terms of variables of <code>b.model</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.unbridged_map" href="#MathOptInterface.Bridges.Variable.unbridged_map"><code>MathOptInterface.Bridges.Variable.unbridged_map</code></a> — <span class="docstring-category">Function</span></header><section><div><p>unbridged_map(        bridge::MOI.Bridges.Variable.AbstractBridge,         vi::MOI.VariableIndex,     )</p><p>For a bridged variable in a scalar set, return a tuple of pairs mapping the variables created by the bridge to an affine expression in terms of the bridged variable <code>vi</code>.</p><pre><code class="nohighlight hljs">unbridged_map(
    bridge::MOI.Bridges.Variable.AbstractBridge,
    vis::Vector{MOI.VariableIndex},
)</code></pre><p>For a bridged variable in a vector set, return a tuple of pairs mapping the variables created by the bridge to an affine expression in terms of the bridged variable <code>vis</code>. If this method is not implemented, it falls back to calling the following method for every variable of <code>vis</code>.</p><pre><code class="nohighlight hljs">unbridged_map(
    bridge::MOI.Bridges.Variable.AbstractBridge,
    vi::MOI.VariableIndex,
    i::MOIB.IndexInVector,
)</code></pre><p>For a bridged variable in a vector set, return a tuple of pairs mapping the variables created by the bridge to an affine expression in terms of the bridged variable <code>vi</code> corresponding to the <code>i</code>th variable of the vector.</p><p>If there is no way to recover the expression in terms of the bridged variable(s) <code>vi(s)</code>, return <code>nothing</code>. See <a href="#MathOptInterface.Bridges.Variable.ZerosBridge"><code>ZerosBridge</code></a> for an example of bridge returning <code>nothing</code>.</p></div></section></article><h2 id="Constraint-bridges"><a class="docs-heading-anchor" href="#Constraint-bridges">Constraint bridges</a><a id="Constraint-bridges-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-bridges" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.AbstractBridge" href="#MathOptInterface.Bridges.Constraint.AbstractBridge"><code>MathOptInterface.Bridges.Constraint.AbstractBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBridge</code></pre><p>Subtype of <a href="#MathOptInterface.Bridges.AbstractBridge"><code>MathOptInterface.Bridges.AbstractBridge</code></a> for constraint bridges.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.AbstractFunctionConversionBridge" href="#MathOptInterface.Bridges.Constraint.AbstractFunctionConversionBridge"><code>MathOptInterface.Bridges.Constraint.AbstractFunctionConversionBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractFunctionConversionBridge{F, S} &lt;: AbstractBridge end</code></pre><p>Bridge a constraint <code>G</code>-in-<code>S</code> into a constraint <code>F</code>-in-<code>S</code> where <code>F</code> and <code>G</code> are equivalent representations of the same function. By convention, the transformed function is stored in the <code>constraint</code> field.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer" href="#MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer"><code>MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SingleBridgeOptimizer{BT&lt;:AbstractBridge, OT&lt;:MOI.ModelLike} &lt;:
AbstractBridgeOptimizer</code></pre><p>The <code>SingleBridgeOptimizer</code> bridges any constraint supported by the bridge <code>BT</code>. This is in contrast with the <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>MathOptInterface.Bridges.LazyBridgeOptimizer</code></a> which only bridges the constraints that are unsupported by the internal model, even if they are supported by one of its bridges.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.add_all_bridges" href="#MathOptInterface.Bridges.Constraint.add_all_bridges"><code>MathOptInterface.Bridges.Constraint.add_all_bridges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_all_bridges(bridged_model, ::Type{T}) where {T}</code></pre><p>Add all bridges defined in the <code>Bridges.Constraint</code> submodule to <code>bridged_model</code>. The coefficient type used is <code>T</code>.</p></div></section></article><h3 id="constraint_set_map"><a class="docs-heading-anchor" href="#constraint_set_map">SetMap bridges</a><a id="constraint_set_map-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_set_map" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.SetMapBridge" href="#MathOptInterface.Bridges.Variable.SetMapBridge"><code>MathOptInterface.Bridges.Variable.SetMapBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type SetMapBridge{T,S1,S2} &lt;: AbstractBridge end</code></pre><p>Consider two type of sets <code>S1</code>, <code>S2</code> and a linear mapping <code>A</code> that the image of a set of type <code>S1</code> under <code>A</code> is a set of type <code>S2</code>. A <code>SetMapBridge{T,S1,S2}</code> is a bridge that substitutes constrained variables in <code>S2</code> into the image through <code>A</code> of constrained variables in <code>S1</code>.</p><p>The linear map <code>A</code> is described by <a href="#MathOptInterface.Bridges.map_set"><code>MathOptInterface.Bridges.map_set</code></a>, <a href="#MathOptInterface.Bridges.map_function"><code>MathOptInterface.Bridges.map_function</code></a>. Implementing a method for these two functions is sufficient to bridge constrained variables. In order for the getters and setters of dual solutions, starting values, etc...  to work as well a method for the following functions should be implemented as well: <a href="#MathOptInterface.Bridges.inverse_map_set"><code>MathOptInterface.Bridges.inverse_map_set</code></a>, <a href="#MathOptInterface.Bridges.inverse_map_function"><code>MathOptInterface.Bridges.inverse_map_function</code></a>, <a href="#MathOptInterface.Bridges.adjoint_map_function"><code>MathOptInterface.Bridges.adjoint_map_function</code></a> and <a href="#MathOptInterface.Bridges.inverse_adjoint_map_function"><code>MathOptInterface.Bridges.inverse_adjoint_map_function</code></a>. See the docstrings of the function to see which feature would be missing it it was not implemented for a given bridge.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SetMapBridge" href="#MathOptInterface.Bridges.Constraint.SetMapBridge"><code>MathOptInterface.Bridges.Constraint.SetMapBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type SetMapBridge{T,S2,S1,F,G} &lt;: AbstractBridge end</code></pre><p>Consider two type of sets <code>S1</code>, <code>S2</code> and a linear mapping <code>A</code> that the image of a set of type <code>S1</code> under <code>A</code> is a set of type <code>S2</code>. A <code>SetMapBridge{T,S2,S1,F,G}</code> is a bridge that maps <code>G</code>-in-<code>S2</code> constraints into <code>F</code>-in-<code>S1</code> by mapping the function through <code>A</code>.</p><p>The linear map <code>A</code> is described by <a href="#MathOptInterface.Bridges.map_set"><code>MathOptInterface.Bridges.map_set</code></a>, <a href="#MathOptInterface.Bridges.map_function"><code>MathOptInterface.Bridges.map_function</code></a>. Implementing a method for these two functions is sufficient to bridge constraints. In order for the getters and setters of dual solutions, starting values, etc...  to work as well a method for the following functions should be implemented as well: <a href="#MathOptInterface.Bridges.inverse_map_set"><code>MathOptInterface.Bridges.inverse_map_set</code></a>, <a href="#MathOptInterface.Bridges.inverse_map_function"><code>MathOptInterface.Bridges.inverse_map_function</code></a>, <a href="#MathOptInterface.Bridges.adjoint_map_function"><code>MathOptInterface.Bridges.adjoint_map_function</code></a> and <a href="#MathOptInterface.Bridges.inverse_adjoint_map_function"><code>MathOptInterface.Bridges.inverse_adjoint_map_function</code></a>. See the docstrings of the function to see which feature would be missing it it was not implemented for a given bridge.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.map_set" href="#MathOptInterface.Bridges.map_set"><code>MathOptInterface.Bridges.map_set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">map_set(::Type{BT}, set) where {BT}</code></pre><p>Return the image of <code>set</code> through the linear map <code>A</code> defined in <a href="#MathOptInterface.Bridges.Variable.SetMapBridge"><code>Variable.SetMapBridge</code></a> and <a href="#MathOptInterface.Bridges.Constraint.SetMapBridge"><code>Constraint.SetMapBridge</code></a>. This is used for bridging the constraint and setting the <a href="../../../reference/constraints/#MathOptInterface.ConstraintSet"><code>MathOptInterface.ConstraintSet</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.inverse_map_set" href="#MathOptInterface.Bridges.inverse_map_set"><code>MathOptInterface.Bridges.inverse_map_set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inverse_map_set(::Type{BT}, set) where {BT}</code></pre><p>Return the preimage of <code>set</code> through the linear map <code>A</code> defined in <a href="#MathOptInterface.Bridges.Variable.SetMapBridge"><code>Variable.SetMapBridge</code></a> and <a href="#MathOptInterface.Bridges.Constraint.SetMapBridge"><code>Constraint.SetMapBridge</code></a>. This is used for getting the <a href="../../../reference/constraints/#MathOptInterface.ConstraintSet"><code>MathOptInterface.ConstraintSet</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.map_function" href="#MathOptInterface.Bridges.map_function"><code>MathOptInterface.Bridges.map_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">map_function(::Type{BT}, func) where {BT}</code></pre><p>Return the image of <code>func</code> through the linear map <code>A</code> defined in <a href="#MathOptInterface.Bridges.Variable.SetMapBridge"><code>Variable.SetMapBridge</code></a> and <a href="#MathOptInterface.Bridges.Constraint.SetMapBridge"><code>Constraint.SetMapBridge</code></a>. This is used for getting the <a href="../../../reference/constraints/#MathOptInterface.ConstraintPrimal"><code>MathOptInterface.ConstraintPrimal</code></a> of variable bridges. For constraint bridges, this is used for bridging the constraint, setting the <a href="../../../reference/constraints/#MathOptInterface.ConstraintFunction"><code>MathOptInterface.ConstraintFunction</code></a> and <a href="../../../reference/constraints/#MathOptInterface.ConstraintPrimalStart"><code>MathOptInterface.ConstraintPrimalStart</code></a> and modifying the function with <a href="../../../reference/modification/#MathOptInterface.modify"><code>MathOptInterface.modify</code></a>.</p><pre><code class="nohighlight hljs">map_function(::Type{BT}, func, i::IndexInVector) where {BT}</code></pre><p>Return the scalar function at the <code>i</code>th index of the vector function that would be returned by <code>map_function(BT, func)</code> except that it may compute the <code>i</code>th element. This is used by <a href="#MathOptInterface.Bridges.bridged_function"><code>bridged_function</code></a> and for getting the <a href="../../../reference/variables/#MathOptInterface.VariablePrimal"><code>MathOptInterface.VariablePrimal</code></a> and <a href="../../../reference/variables/#MathOptInterface.VariablePrimalStart"><code>MathOptInterface.VariablePrimalStart</code></a> of variable bridges.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.inverse_map_function" href="#MathOptInterface.Bridges.inverse_map_function"><code>MathOptInterface.Bridges.inverse_map_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inverse_map_function(::Type{BT}, func) where {BT}</code></pre><p>Return the image of <code>func</code> through the inverse of the linear map <code>A</code> defined in <a href="#MathOptInterface.Bridges.Variable.SetMapBridge"><code>Variable.SetMapBridge</code></a> and <a href="#MathOptInterface.Bridges.Constraint.SetMapBridge"><code>Constraint.SetMapBridge</code></a>. This is used by <a href="#MathOptInterface.Bridges.Variable.unbridged_map"><code>Variable.unbridged_map</code></a> and for setting the <a href="../../../reference/variables/#MathOptInterface.VariablePrimalStart"><code>MathOptInterface.VariablePrimalStart</code></a> of variable bridges and for getting the <a href="../../../reference/constraints/#MathOptInterface.ConstraintFunction"><code>MathOptInterface.ConstraintFunction</code></a>, the <a href="../../../reference/constraints/#MathOptInterface.ConstraintPrimal"><code>MathOptInterface.ConstraintPrimal</code></a> and the <a href="../../../reference/constraints/#MathOptInterface.ConstraintPrimalStart"><code>MathOptInterface.ConstraintPrimalStart</code></a> of constraint bridges.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.adjoint_map_function" href="#MathOptInterface.Bridges.adjoint_map_function"><code>MathOptInterface.Bridges.adjoint_map_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adjoint_map_function(::Type{BT}, func) where {BT}</code></pre><p>Return the image of <code>func</code> through the adjoint of the linear map <code>A</code> defined in <a href="#MathOptInterface.Bridges.Variable.SetMapBridge"><code>Variable.SetMapBridge</code></a> and <a href="#MathOptInterface.Bridges.Constraint.SetMapBridge"><code>Constraint.SetMapBridge</code></a>. This is used for getting the <a href="../../../reference/constraints/#MathOptInterface.ConstraintDual"><code>MathOptInterface.ConstraintDual</code></a> and <a href="../../../reference/constraints/#MathOptInterface.ConstraintDualStart"><code>MathOptInterface.ConstraintDualStart</code></a> of constraint bridges.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.inverse_adjoint_map_function" href="#MathOptInterface.Bridges.inverse_adjoint_map_function"><code>MathOptInterface.Bridges.inverse_adjoint_map_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inverse_adjoint_map_function(::Type{BT}, func) where {BT}</code></pre><p>Return the image of <code>func</code> through the inverse of the adjoint of the linear map <code>A</code> defined in <a href="#MathOptInterface.Bridges.Variable.SetMapBridge"><code>Variable.SetMapBridge</code></a> and <a href="#MathOptInterface.Bridges.Constraint.SetMapBridge"><code>Constraint.SetMapBridge</code></a>. This is used for getting the <a href="../../../reference/constraints/#MathOptInterface.ConstraintDual"><code>MathOptInterface.ConstraintDual</code></a> of variable bridges and setting the <a href="../../../reference/constraints/#MathOptInterface.ConstraintDualStart"><code>MathOptInterface.ConstraintDualStart</code></a> of constraint bridges.</p></div></section></article><h3 id="constraint_bridges_ref"><a class="docs-heading-anchor" href="#constraint_bridges_ref">Bridges implemented</a><a id="constraint_bridges_ref-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_bridges_ref" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.FlipSignBridge" href="#MathOptInterface.Bridges.Constraint.FlipSignBridge"><code>MathOptInterface.Bridges.Constraint.FlipSignBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FlipSignBridge{T, S1, S2, F, G}</code></pre><p>Bridge a <code>G</code>-in-<code>S1</code> constraint into an <code>F</code>-in-<code>S2</code> constraint by multiplying the function by <code>-1</code> and taking the point reflection of the set across the origin. The flipped <code>F</code>-in-<code>S</code> constraint is stored in the <code>constraint</code> field by convention.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.AbstractToIntervalBridge" href="#MathOptInterface.Bridges.Constraint.AbstractToIntervalBridge"><code>MathOptInterface.Bridges.Constraint.AbstractToIntervalBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractToIntervalBridge{T, S1, F}</code></pre><p>Bridge a <code>F</code>-in-<code>Interval</code> constraint into an <code>F</code>-in-<code>Interval{T}</code> constraint where we have either:</p><ul><li><code>S1 = MOI.GreaterThan{T}</code></li><li><code>S1 = MOI.LessThan{T}</code></li></ul><p>The <code>F</code>-in-<code>Interval{T}</code> constraint is stored in the <code>constraint</code> field by convention.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is required that <code>T</code> be a <code>AbstractFloat</code> type because otherwise <code>typemin</code> and <code>typemax</code> would either be not implemented (e.g. <code>BigInt</code>) or would not give infinite value (e.g. <code>Int</code>). For this reason, this bridge is only added to <a href="#MathOptInterface.Bridges.full_bridge_optimizer"><code>MathOptInterface.Bridges.full_bridge_optimizer</code></a>.</p><p>when <code>T</code> is a subtype of <code>AbstractFloat</code>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge" href="#MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge"><code>MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GreaterToIntervalBridge{T, F&lt;:MOI.AbstractScalarFunction} &lt;:
    AbstractToIntervalBridge{T, MOI.GreaterThan{T}, F}</code></pre><p>Transforms a <code>F</code>-in-<code>GreaterThan{T}</code> constraint into an <code>F</code>-in-<code>Interval{T}</code> constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.LessToIntervalBridge" href="#MathOptInterface.Bridges.Constraint.LessToIntervalBridge"><code>MathOptInterface.Bridges.Constraint.LessToIntervalBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LessToIntervalBridge{T, F&lt;:MOI.AbstractScalarFunction} &lt;:
    AbstractToIntervalBridge{T, MOI.LessThan{T}, F}</code></pre><p>Transforms a <code>F</code>-in-<code>LessThan{T}</code> constraint into an <code>F</code>-in-<code>Interval{T}</code> constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.GreaterToLessBridge" href="#MathOptInterface.Bridges.Constraint.GreaterToLessBridge"><code>MathOptInterface.Bridges.Constraint.GreaterToLessBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GreaterToLessBridge{
    T,
    F&lt;:MOI.AbstractScalarFunction,
    G&lt;:MOI.AbstractScalarFunction
} &lt;: FlipSignBridge{T, MOI.GreaterThan{T}, MOI.LessThan{T}, F, G}</code></pre><p>Transforms a <code>G</code>-in-<code>GreaterThan{T}</code> constraint into an <code>F</code>-in-<code>LessThan{T}</code> constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.LessToGreaterBridge" href="#MathOptInterface.Bridges.Constraint.LessToGreaterBridge"><code>MathOptInterface.Bridges.Constraint.LessToGreaterBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LessToGreaterBridge{
    T,
    F&lt;:MOI.AbstractScalarFunction,
    G&lt;:MOI.AbstractScalarFunction
} &lt;: FlipSignBridge{T, MOI.LessThan{T}, MOI.GreaterThan{T}, F, G}</code></pre><p>Transforms a <code>G</code>-in-<code>LessThan{T}</code> constraint into an <code>F</code>-in-<code>GreaterThan{T}</code> constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NonnegToNonposBridge" href="#MathOptInterface.Bridges.Constraint.NonnegToNonposBridge"><code>MathOptInterface.Bridges.Constraint.NonnegToNonposBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonnegToNonposBridge{
    T,
    F&lt;:MOI.AbstractVectorFunction,
    G&lt;:MOI.AbstractVectorFunction
} &lt;: FlipSignBridge{T, MOI.Nonnegatives, MOI.Nonpositives, F, G}</code></pre><p>Transforms a <code>G</code>-in-<code>Nonnegatives</code> constraint into a <code>F</code>-in-<code>Nonpositives</code> constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NonposToNonnegBridge" href="#MathOptInterface.Bridges.Constraint.NonposToNonnegBridge"><code>MathOptInterface.Bridges.Constraint.NonposToNonnegBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonposToNonnegBridge{
    T,
    F&lt;:MOI.AbstractVectorFunction,
    G&lt;:MOI.AbstractVectorFunction,
} &lt;: FlipSignBridge{T, MOI.Nonpositives, MOI.Nonnegatives, F, G}</code></pre><p>Transforms a <code>G</code>-in-<code>Nonpositives</code> constraint into a <code>F</code>-in-<code>Nonnegatives</code> constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.VectorizeBridge" href="#MathOptInterface.Bridges.Constraint.VectorizeBridge"><code>MathOptInterface.Bridges.Constraint.VectorizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorizeBridge{T,F,S,G}</code></pre><p>Transforms a constraint <code>G</code>-in-<code>scalar_set_type(S, T)</code> where <code>S &lt;: VectorLinearSet</code> to <code>F</code>-in-<code>S</code>.</p><p><strong>Examples</strong></p><p>The constraint <code>VariableIndex</code>-in-<code>LessThan{Float64}</code> becomes <code>VectorAffineFunction{Float64}</code>-in-<code>Nonpositives</code>, where <code>T = Float64</code>, <code>F = VectorAffineFunction{Float64}</code>, <code>S = Nonpositives</code>, and <code>G = VariableIndex</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.ScalarizeBridge" href="#MathOptInterface.Bridges.Constraint.ScalarizeBridge"><code>MathOptInterface.Bridges.Constraint.ScalarizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScalarizeBridge{T, F, S}</code></pre><p>Transforms a constraint <code>AbstractVectorFunction</code>-in-<code>vector_set_type(S)</code> where <code>S &lt;: LPCone{T}</code> to <code>F</code>-in-<code>S</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.ScalarSlackBridge" href="#MathOptInterface.Bridges.Constraint.ScalarSlackBridge"><code>MathOptInterface.Bridges.Constraint.ScalarSlackBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScalarSlackBridge{T, F, S}</code></pre><p>The <code>ScalarSlackBridge</code> converts a constraint <code>G</code>-in-<code>S</code> where <code>G</code> is a function different from <code>VariableIndex</code> into the constraints <code>F</code>-in-<code>EqualTo{T}</code> and <code>VariableIndex</code>-in-<code>S</code>.</p><p><code>F</code> is the result of subtracting a <code>VariableIndex</code> from <code>G</code>. Typically <code>G</code> is the same as <code>F</code>, but that is not mandatory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.VectorSlackBridge" href="#MathOptInterface.Bridges.Constraint.VectorSlackBridge"><code>MathOptInterface.Bridges.Constraint.VectorSlackBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorSlackBridge{T, F, S}</code></pre><p>The <code>VectorSlackBridge</code> converts a constraint <code>G</code>-in-<code>S</code> where <code>G</code> is a function different from <code>VectorOfVariables</code> into the constraints <code>F</code>in-<code>Zeros</code> and <code>VectorOfVariables</code>-in-<code>S</code>.</p><p><code>F</code> is the result of subtracting a <code>VectorOfVariables</code> from <code>G</code>. Typically <code>G</code> is the same as <code>F</code>, but that is not mandatory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge" href="#MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge"><code>MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScalarFunctionizeBridge{T, S}</code></pre><p>The <code>ScalarFunctionizeBridge</code> converts a constraint <code>VariableIndex</code>-in-<code>S</code> into the constraint <code>ScalarAffineFunction{T}</code>-in-<code>S</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge" href="#MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge"><code>MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorFunctionizeBridge{T, S}</code></pre><p>The <code>VectorFunctionizeBridge</code> converts a constraint <code>VectorOfVariables</code>-in-<code>S</code> into the constraint <code>VectorAffineFunction{T}</code>-in-<code>S</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SplitIntervalBridge" href="#MathOptInterface.Bridges.Constraint.SplitIntervalBridge"><code>MathOptInterface.Bridges.Constraint.SplitIntervalBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SplitIntervalBridge{T, F, S, LS, US}</code></pre><p>The <code>SplitIntervalBridge</code> splits a <code>F</code>-in-<code>S</code> constraint into a <code>F</code>-in-<code>LS</code> and a <code>F</code>-in-<code>US</code> constraint where we have either:</p><ul><li><code>S = MOI.Interval{T}</code>, <code>LS = MOI.GreaterThan{T}</code> and <code>US = MOI.LessThan{T}</code>,</li><li><code>S = MOI.EqualTo{T}</code>, <code>LS = MOI.GreaterThan{T}</code> and <code>US = MOI.LessThan{T}</code>, or</li><li><code>S = MOI.Zeros</code>, <code>LS = MOI.Nonnegatives</code> and <code>US = MOI.Nonpositives</code>.</li></ul><p>For instance, if <code>F</code> is <code>MOI.ScalarAffineFunction</code> and <code>S</code> is <code>MOI.Interval</code>, it transforms the constraint <span>$l ≤ ⟨a, x⟩ + α ≤ u$</span> into the constraints <span>$⟨a, x⟩ + α ≥ l$</span> and <span>$⟨a, x⟩ + α ≤ u$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <code>T&lt;:AbstractFloat</code> and <code>S</code> is <code>MOI.Interval{T}</code> then no lower (resp. upper) bound constraint is created if the lower (resp. upper) bound is <code>typemin(T)</code> (resp. <code>typemax(T)</code>). Similarly, when <a href="../../../reference/constraints/#MathOptInterface.ConstraintSet"><code>MathOptInterface.ConstraintSet</code></a> is set, a lower or upper bound constraint may be deleted or created accordingly.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge" href="#MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge"><code>MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SOCtoRSOCBridge{T, F, G}</code></pre><p>We simply do the inverse transformation of <a href="#MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge"><code>RSOCtoSOCBridge</code></a>. In fact, as the transformation is an involution, we do the same transformation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge" href="#MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge"><code>MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RSOCtoSOCBridge{T, F, G}</code></pre><p>The <code>RotatedSecondOrderCone</code> is <code>SecondOrderCone</code> representable; see [BN01, p. 104]. Indeed, we have <span>$2tu = (t/√2 + u/√2)^2 - (t/√2 - u/√2)^2$</span> hence</p><p class="math-container">\[2tu \ge \lVert x \rVert_2^2\]</p><p>is equivalent to</p><p class="math-container">\[(t/√2 + u/√2)^2 \ge \lVert x \rVert_2^2 + (t/√2 - u/√2)^2.\]</p><p>We can therefore use the transformation <span>$(t, u, x) \mapsto (t/√2+u/√2, t/√2-u/√2, x)$</span>. Note that the linear transformation is a symmetric involution (i.e. it is its own transpose and its own inverse). That means in particular that the norm of constraint primal and dual values are preserved by the tranformation.</p><p>[BN01] Ben-Tal, Aharon, and Nemirovski, Arkadi. <em>Lectures on modern convex optimization: analysis, algorithms, and engineering applications</em>. Society for Industrial and Applied Mathematics, 2001.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge" href="#MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge"><code>MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SOCtoNonConvexQuadBridge{T}</code></pre><p>Constraints of the form <code>VectorOfVariables</code>-in-<code>SecondOrderCone</code> can be transformed into a <code>ScalarQuadraticFunction</code>-in-<code>LessThan</code> and a <code>ScalarAffineFunction</code>-in-<code>GreaterThan</code>. Indeed, the definition of the second-order cone</p><p class="math-container">\[t \ge \lVert x \rVert_2 \  (1)\]</p><p>is equivalent to</p><p class="math-container">\[\sum x_i^2 \le t^2  (2)\]</p><p>with <span>$t \ge 0$</span>.  (3)</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This transformation starts from a convex constraint (1) and creates a non-convex constraint (2), because the Q matrix associated with the constraint (2) has one negative eigenvalue. This might be wrongly interpreted by a solver. Some solvers can look at (2) and understand that it is a second order cone, but this is not a general rule. For these reasons this bridge is not automatically added by <a href="#MathOptInterface.Bridges.full_bridge_optimizer"><code>MOI.Bridges.full_bridge_optimizer</code></a>. Care is recommended when adding this bridge to a optimizer.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.RSOCtoNonConvexQuadBridge" href="#MathOptInterface.Bridges.Constraint.RSOCtoNonConvexQuadBridge"><code>MathOptInterface.Bridges.Constraint.RSOCtoNonConvexQuadBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RSOCtoNonConvexQuadBridge{T}</code></pre><p>Constraints of the form <code>VectorOfVariables</code>-in-<code>SecondOrderCone</code> can be transformed into a <code>ScalarQuadraticFunction</code>-in-<code>LessThan</code> and a <code>ScalarAffineFunction</code>-in-<code>GreaterThan</code>. Indeed, the definition of the second-order cone</p><p class="math-container">\[2tu \ge \lVert x \rVert_2^2, t,u \ge 0  (1)\]</p><p>is equivalent to</p><p class="math-container">\[\sum x_i^2 \le 2tu  (2)\]</p><p>with <span>$t,u \ge 0$</span>.  (3)</p><p><em>WARNING</em> This transformation starts from a convex constraint (1) and creates a non-convex constraint (2), because the Q matrix associated with the constraint 2 has two negative eigenvalues. This might be wrongly interpreted by a solver. Some solvers can look at (2) and understand that it is a rotated second order cone, but this is not a general rule. For these reasons, this bridge is not automatically added by <a href="#MathOptInterface.Bridges.full_bridge_optimizer"><code>MOI.Bridges.full_bridge_optimizer</code></a>. Care is recommended when adding this bridge to an optimizer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.QuadtoSOCBridge" href="#MathOptInterface.Bridges.Constraint.QuadtoSOCBridge"><code>MathOptInterface.Bridges.Constraint.QuadtoSOCBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuadtoSOCBridge{T}</code></pre><p>The set of points <code>x</code> satisfying the constraint</p><p class="math-container">\[\frac{1}{2}x^T Q x + a^T x + b \le 0\]</p><p>is a convex set if <code>Q</code> is positive semidefinite and is the union of two convex cones if <code>a</code> and <code>b</code> are zero (i.e. <em>homogeneous</em> case) and <code>Q</code> has only one negative eigenvalue. Currently, only the non-homogeneous transformation is implemented, see the Note section below for more details.</p><p><strong>Non-homogeneous case</strong></p><p>If <code>Q</code> is positive semidefinite, there exists <code>U</code> such that <span>$Q = U^T U$</span>, the inequality can then be rewritten as</p><p class="math-container">\[\|U x\|_2^2 \le 2 (-a^T x - b)\]</p><p>which is equivalent to the membership of <code>(1, -a^T x - b, Ux)</code> to the rotated second-order cone.</p><p><strong>Homogeneous case</strong></p><p>If <code>Q</code> has only one negative eigenvalue, the set of <code>x</code> such that <span>$x^T Q x \le 0$</span> is the union of a convex cone and its opposite. We can choose which one to model by checking the existence of bounds on variables as shown below.</p><p><strong>Second-order cone</strong></p><p>If <code>Q</code> is diagonal and has eigenvalues <code>(1, 1, -1)</code>, the inequality <span>$x^2 + x^2 \le z^2$</span> combined with <span>$z \ge 0$</span> defines the Lorenz cone (i.e. the second-order cone) but when combined with <span>$z \le 0$</span>, it gives the opposite of the second order cone. Therefore, we need to check if the variable <code>z</code> has a lower bound 0 or an upper bound 0 in order to determine which cone is</p><p><strong>Rotated second-order cone</strong></p><p>The matrix <code>Q</code> corresponding to the inequality <span>$x^2 \le 2yz$</span> has one eigenvalue 1 with eigenvectors <code>(1, 0, 0)</code> and <code>(0, 1, -1)</code> and one eigenvalue <code>-1</code> corresponding to the eigenvector <code>(0, 1, 1)</code>. Hence if we intersect this union of two convex cone with the halfspace <span>$x + y \ge 0$</span>, we get the rotated second-order cone and if we intersect it with the halfspace <span>$x + y \le 0$</span> we get the opposite of the rotated second-order cone. Note that <code>y</code> and <code>z</code> have the same sign since <code>yz</code> is nonnegative hence <span>$x + y \ge 0$</span> is equivalent to <span>$x \ge 0$</span> and <span>$y \ge 0$</span>.</p><p><strong>Note</strong></p><p>The check for existence of bound can be implemented (but inefficiently) with the current interface but if bound is removed or transformed (e.g. <code>≤ 0</code> transformed into <code>≥ 0</code>) then the bridge is no longer valid. For this reason the homogeneous version of the bridge is not implemented yet.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SOCtoPSDBridge" href="#MathOptInterface.Bridges.Constraint.SOCtoPSDBridge"><code>MathOptInterface.Bridges.Constraint.SOCtoPSDBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The <code>SOCtoPSDBridge</code> transforms the second order cone constraint <span>$\lVert x \rVert \le t$</span> into the semidefinite cone constraints</p><p class="math-container">\[\begin{pmatrix}
  t &amp; x^\top\\
  x &amp; tI
\end{pmatrix} \succeq 0\]</p><p>Indeed by the Schur Complement, it is positive definite iff</p><p class="math-container">\[\begin{align*}
  tI &amp; \succ 0\\
  t - x^\top (tI)^{-1} x &amp; \succ 0
\end{align*}\]</p><p>which is equivalent to</p><p class="math-container">\[\begin{align*}
  t &amp; &gt; 0\\
  t^2 &amp; &gt; x^\top x
\end{align*}\]</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This bridge is not added by default by <a href="#MathOptInterface.Bridges.full_bridge_optimizer"><code>MOI.Bridges.full_bridge_optimizer</code></a> as bridging second order cone constraints to semidefinite constraints can be achieved by the <a href="#MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge"><code>SOCtoRSOCBridge</code></a> followed by the <a href="#MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge"><code>RSOCtoPSDBridge</code></a> while creating a smaller semidefinite constraint.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge" href="#MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge"><code>MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The <code>RSOCtoPSDBridge</code> transforms the second order cone constraint <span>$\lVert x \rVert \le 2tu$</span> with <span>$u \ge 0$</span> into the semidefinite cone constraints</p><p class="math-container">\[\begin{pmatrix}
  t &amp; x^\top\\
  x &amp; 2uI
\end{pmatrix} \succeq 0\]</p><p>Indeed by the Schur Complement, it is positive definite iff</p><p class="math-container">\[\begin{align*}
  uI &amp; \succ 0\\
  t - x^\top (2uI)^{-1} x &amp; \succ 0
\end{align*}\]</p><p>which is equivalent to</p><p class="math-container">\[\begin{align*}
  u &amp; &gt; 0\\
  2tu &amp; &gt; x^\top x
\end{align*}\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NormInfinityBridge" href="#MathOptInterface.Bridges.Constraint.NormInfinityBridge"><code>MathOptInterface.Bridges.Constraint.NormInfinityBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NormInfinityBridge{T}</code></pre><p>The <code>NormInfinityCone</code> is representable with LP constraints, since <span>$t \ge \max_i \lvert x_i \rvert$</span> if and only if <span>$t \ge x_i$</span> and <span>$t \ge -x_i$</span> for all <span>$i$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NormOneBridge" href="#MathOptInterface.Bridges.Constraint.NormOneBridge"><code>MathOptInterface.Bridges.Constraint.NormOneBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NormOneBridge{T}</code></pre><p>The <code>NormOneCone</code> is representable with LP constraints, since <span>$t \ge \sum_i \lvert x_i \rvert$</span> if and only if there exists a vector y such that <span>$t \ge \sum_i y_i$</span> and <span>$y_i \ge x_i$</span>, <span>$y_i \ge -x_i$</span> for all <span>$i$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge" href="#MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge"><code>MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeoMeantoRelEntrBridge{T}</code></pre><p>The <code>geometric mean cone</code> is representable with a relative entropy constraint and a nonnegative auxiliary variable.</p><p>This is because <span>$u \le \prod_{i=1}^n w_i^{1/n}$</span> is equivalent to <span>$y \ge 0$</span> and <span>$0 \le u + y \le \prod_{i=1}^n w_i^{1/n}$</span>, and the latter inequality is equivalent to <span>$1 \le \prod_{i=1}^n (\frac{w_i}{u + y})^{1/n}$</span>, which is equivalent to <span>$0 \le \sum_{i=1}^n \log (\frac{w_i}{u + y})^{1/n}$</span>, which is equivalent to <span>$0 \ge \sum_{i=1}^n (u + y) \log (\frac{u + y}{w_i})$</span>.</p><p>Thus <span>$(u, w) \in GeometricMeanCone(1 + n)$</span> is representable as <span>$y \ge 0$</span>, <span>$(0, w, (u + y) e) \in RelativeEntropyCone(1 + 2n)$</span>, where <span>$e$</span> is a vector of ones.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.GeoMeanBridge" href="#MathOptInterface.Bridges.Constraint.GeoMeanBridge"><code>MathOptInterface.Bridges.Constraint.GeoMeanBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeoMeanBridge{T, F, G, H}</code></pre><p>The <code>GeometricMeanCone</code> is <code>SecondOrderCone</code> representable; see [1, p. 105].</p><p>The reformulation is best described in an example.</p><p>Consider the cone of dimension 4:</p><p class="math-container">\[t \le \sqrt[3]{x_1 x_2 x_3}\]</p><p>This can be rewritten as <span>$\exists x_{21} \ge 0$</span> such that:</p><p class="math-container">\[\begin{align*}
  t &amp; \le x_{21},\\
  x_{21}^4 &amp; \le x_1 x_2 x_3 x_{21}.
\end{align*}\]</p><p>Note that we need to create <span>$x_{21}$</span> and not use <span>$t^4$</span> directly as <span>$t$</span> is allowed to be negative. Now, this is equivalent to:</p><p class="math-container">\[\begin{align*}
  t &amp; \le x_{21}/\sqrt{4},\\
  x_{21}^2 &amp; \le 2x_{11} x_{12},\\
  x_{11}^2 &amp; \le 2x_1 x_2, &amp; x_{12}^2 &amp; \le 2x_3(x_{21}/\sqrt{4}).
\end{align*}\]</p><p>[1] Ben-Tal, Aharon, and Arkadi Nemirovski. <em>Lectures on modern convex     optimization: analysis, algorithms, and engineering applications</em>. Society     for Industrial and Applied Mathematics, 2001.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.RelativeEntropyBridge" href="#MathOptInterface.Bridges.Constraint.RelativeEntropyBridge"><code>MathOptInterface.Bridges.Constraint.RelativeEntropyBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RelativeEntropyBridge{T}</code></pre><p>The <code>RelativeEntropyCone</code> is representable with exponential cone and LP constraints, since <span>$u \ge \sum_{i=1}^n w_i \log (\frac{w_i}{v_i})$</span> if and only if there exists a vector <span>$y$</span> such that <span>$u \ge \sum_i y_i$</span> and <span>$y_i \ge w_i \log (\frac{w_i}{v_i})$</span> or equivalently <span>$v_i \ge w_i \exp (\frac{-y_i}{w_i})$</span> or equivalently <span>$(-y_i, w_i, v_i) \in ExponentialCone$</span>, for all <span>$i$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NormSpectralBridge" href="#MathOptInterface.Bridges.Constraint.NormSpectralBridge"><code>MathOptInterface.Bridges.Constraint.NormSpectralBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NormSpectralBridge{T}</code></pre><p>The <code>NormSpectralCone</code> is representable with a PSD constraint, since <span>$t \ge \sigma_1(X)$</span> if and only if <span>$[tI X^\top; X tI] \succ 0$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NormNuclearBridge" href="#MathOptInterface.Bridges.Constraint.NormNuclearBridge"><code>MathOptInterface.Bridges.Constraint.NormNuclearBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NormNuclearBridge{T}</code></pre><p>The <code>NormNuclearCone</code> is representable with an SDP constraint and extra variables, since <span>$t \ge \sum_i \sigma_i (X)$</span> if and only if there exists symmetric matrices <span>$U, V$</span> such that <span>$[U X^\top; X V] \succ 0$</span> and <span>$t \ge (tr(U) + tr(V)) / 2$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SquareBridge" href="#MathOptInterface.Bridges.Constraint.SquareBridge"><code>MathOptInterface.Bridges.Constraint.SquareBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SquareBridge{T, F&lt;:MOI.AbstractVectorFunction,
             G&lt;:MOI.AbstractScalarFunction,
             TT&lt;:MOI.AbstractSymmetricMatrixSetTriangle,
             ST&lt;:MOI.AbstractSymmetricMatrixSetSquare} &lt;: AbstractBridge</code></pre><p>The <code>SquareBridge</code> reformulates the constraint of a square matrix to be in <code>ST</code> to a list of equality constraints for pair or off-diagonal entries with different expressions and a <code>TT</code> constraint the upper triangular part of the matrix.</p><p>For instance, the constraint for the matrix</p><p class="math-container">\[\begin{pmatrix}
  1      &amp; 1 + x &amp; 2 - 3x\\
  1 +  x &amp; 2 + x &amp; 3 -  x\\
  2 - 3x &amp; 2 + x &amp;     2x
\end{pmatrix}\]</p><p>to be PSD can be broken down to the constraint of the symmetric matrix</p><p class="math-container">\[\begin{pmatrix}
  1      &amp; 1 + x &amp; 2 - 3x\\
  \cdot &amp; 2 + x &amp; 3 -  x\\
  \cdot &amp; \cdot &amp;    2x
\end{pmatrix}\]</p><p>and the equality constraint between the off-diagonal entries (2, 3) and (3, 2) <span>$2x == 1$</span>. Note that now symmetrization constraint need to be added between the off-diagonal entries (1, 2) and (2, 1) or between (1, 3) and (3, 1) since the expressions are the same.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.RootDetBridge" href="#MathOptInterface.Bridges.Constraint.RootDetBridge"><code>MathOptInterface.Bridges.Constraint.RootDetBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RootDetBridge{T,F,G,H}</code></pre><p>The <code>RootDetConeTriangle</code> is representable by a <code>PositiveSemidefiniteConeTriangle</code> and an <code>GeometricMeanCone</code> constraints; see [1, p. 149].</p><p>Indeed, <span>$t \le \det(X)^{1/n}$</span> if and only if there exists a lower triangular matrix <span>$Δ$</span> such that:</p><p class="math-container">\[\begin{align*}
  \begin{pmatrix}
    X &amp; Δ\\
    Δ^\top &amp; \mathrm{Diag}(Δ)
  \end{pmatrix} &amp; \succeq 0\\
  t &amp; \le (Δ_{11} Δ_{22} \cdots Δ_{nn})^{1/n}
\end{align*}\]</p><p>[1] Ben-Tal, Aharon, and Arkadi Nemirovski. <em>Lectures on modern convex     optimization: analysis, algorithms, and engineering applications</em>. Society     for Industrial and Applied Mathematics, 2001.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.LogDetBridge" href="#MathOptInterface.Bridges.Constraint.LogDetBridge"><code>MathOptInterface.Bridges.Constraint.LogDetBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LogDetBridge{T,F,G,H,I}</code></pre><p>The <code>LogDetConeTriangle</code> is representable by a <code>PositiveSemidefiniteConeTriangle</code> and <code>ExponentialCone</code> constraints.</p><p>Indeed, <span>$\log\det(X) = \log(\delta_1) + \cdots + \log(\delta_n)$</span> where <span>$\delta_1$</span>, ..., <span>$\delta_n$</span> are the eigenvalues of <span>$X$</span>.</p><p>Adapting the method from [1, p. 149], we see that <span>$t \le u \log(\det(X/u))$</span> for <span>$u &gt; 0$</span> if and only if there exists a lower triangular matrix <span>$Δ$</span> such that</p><p class="math-container">\[\begin{align*}
  \begin{pmatrix}
    X &amp; Δ\\
    Δ^\top &amp; \mathrm{Diag}(Δ)
  \end{pmatrix} &amp; \succeq 0\\
  t &amp; \le u \log(Δ_{11}/u) + u \log(Δ_{22}/u) + \cdots + u \log(Δ_{nn}/u)
\end{align*}\]</p><p>[1] Ben-Tal, Aharon, and Arkadi Nemirovski. <em>Lectures on modern convex     optimization: analysis, algorithms, and engineering applications</em>. Society     for Industrial and Applied Mathematics, 2001. ```</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge" href="#MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge"><code>MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndicatorActiveOnFalseBridge{T}</code></pre><p>The <code>IndicatorActiveOnFalseBridge</code> replaces an indicator constraint activated on 0 with a variable <span>$z_0$</span> with the constraint activated on 1, with a variable <span>$z_1$</span>. It stores the added <code>variable</code> and added constraints:</p><ul><li><span>$z_1 \in \mathbb{B}$</span> in <code>zero_one_cons</code></li><li><span>$z_0 + z_1 == 1$</span> in `<code>in</code>disjunction_cons`</li><li>The added <code>ACTIVATE_ON_ONE</code> indicator constraint in <code>indicator_cons_index</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge" href="#MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge"><code>MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndicatorSOS1Bridge{T,S&lt;:MOI.AbstractScalarSet}</code></pre><p>The <code>IndicatorSOS1Bridge</code> replaces an indicator constraint of the following form: <span>$z \in \mathbb{B}, z == 1 \implies f(x) \in S$</span> with a SOS1 constraint: <span>$z \in \mathbb{B}, slack \text{ free}, f(x) + slack \in S, SOS1(slack, z)$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SemiToBinaryBridge" href="#MathOptInterface.Bridges.Constraint.SemiToBinaryBridge"><code>MathOptInterface.Bridges.Constraint.SemiToBinaryBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SemiToBinaryBridge{T, S &lt;: MOI.AbstractScalarSet}</code></pre><p>The <code>SemiToBinaryBridge</code> replaces a Semicontinuous constraint: <span>$x \in \mathsf{Semicontinuous}(l, u)$</span> is replaced by: <span>$z \in \{0, 1\}$</span>, <span>$x \leq z \cdot u$</span>, <span>$x \geq z \cdot l$</span>.</p><p>The <code>SemiToBinaryBridge</code> replaces a Semiinteger constraint: <span>$x \in Semiinteger(l, u)$</span> is replaced by: <span>$z \in \{0, 1\}$</span>, <span>$x \in \mathbb{Z}$</span>, <span>$x \leq z \cdot u$</span>, <span>$x \geq z \cdot l$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.ZeroOneBridge" href="#MathOptInterface.Bridges.Constraint.ZeroOneBridge"><code>MathOptInterface.Bridges.Constraint.ZeroOneBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZeroOneBridge{T}</code></pre><p>The <code>ZeroOneBridge</code> splits a <code>MOI.VariableIndex</code>-in-<code>MOI.ZeroOne</code> constraint into a <code>MOI.VariableIndex</code>-in-<code>MOI.Integer</code> constraint and a <code>MOI.VariableIndex</code>-in-<code>MOI.Interval(0, 1)</code> constraint.</p></div></section></article><h2 id="ref_variable_bridges"><a class="docs-heading-anchor" href="#ref_variable_bridges">Variable bridges</a><a id="ref_variable_bridges-1"></a><a class="docs-heading-anchor-permalink" href="#ref_variable_bridges" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.AbstractBridge" href="#MathOptInterface.Bridges.Variable.AbstractBridge"><code>MathOptInterface.Bridges.Variable.AbstractBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBridge</code></pre><p>Subtype of <a href="#MathOptInterface.Bridges.AbstractBridge"><code>MathOptInterface.Bridges.AbstractBridge</code></a> for variable bridges.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.SingleBridgeOptimizer" href="#MathOptInterface.Bridges.Variable.SingleBridgeOptimizer"><code>MathOptInterface.Bridges.Variable.SingleBridgeOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SingleBridgeOptimizer{BT&lt;:AbstractBridge, OT&lt;:MOI.ModelLike} &lt;:
AbstractBridgeOptimizer</code></pre><p>The <code>SingleBridgeOptimizer</code> bridges any constrained variables supported by the bridge <code>BT</code>. This is in contrast with the <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>MathOptInterface.Bridges.LazyBridgeOptimizer</code></a> which only bridges the constrained variables that are unsupported by the internal model, even if they are supported by one of its bridges.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Two bridge optimizers using variable bridges cannot be used together as both of them assume that the underlying model only returns variable indices with nonnegative values.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.add_all_bridges" href="#MathOptInterface.Bridges.Variable.add_all_bridges"><code>MathOptInterface.Bridges.Variable.add_all_bridges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_all_bridges(bridged_model, ::Type{T}) where {T}</code></pre><p>Add all bridges defined in the <code>Bridges.Variable</code> submodule to <code>bridged_model</code>. The coefficient type used is <code>T</code>.</p></div></section></article><h3 id="variable_bridges_ref"><a class="docs-heading-anchor" href="#variable_bridges_ref">Bridges implemented</a><a id="variable_bridges_ref-1"></a><a class="docs-heading-anchor-permalink" href="#variable_bridges_ref" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.FlipSignBridge" href="#MathOptInterface.Bridges.Variable.FlipSignBridge"><code>MathOptInterface.Bridges.Variable.FlipSignBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FlipSignBridge{T, S1, S2}</code></pre><p>Bridge constrained variables in <code>S1</code> into constrained variables in <code>S2</code> by multiplying the variables by <code>-1</code> and taking the point reflection of the set across the origin. The flipped <code>MOI.VectorOfVariables</code>-in-<code>S</code> constraint is stored in the <code>flipped_constraint</code> field by convention.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.ZerosBridge" href="#MathOptInterface.Bridges.Variable.ZerosBridge"><code>MathOptInterface.Bridges.Variable.ZerosBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZerosBridge{T} &lt;: Bridges.Variable.AbstractBridge</code></pre><p>Transforms constrained variables in <a href="../../../reference/standard_form/#MathOptInterface.Zeros"><code>MathOptInterface.Zeros</code></a> to zeros, which ends up creating no variables in the underlying model.</p><p>The bridged variables are therefore similar to parameters with zero values. Parameters with non-zero value can be created with constrained variables in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo</code></a> by combining a <a href="#MathOptInterface.Bridges.Variable.VectorizeBridge"><code>VectorizeBridge</code></a> and this bridge. The functions cannot be unbridged, given a function, we cannot determine, if the bridged variables were used.</p><p>The dual values cannot be determined by the bridge but they can be determined by the bridged optimizer using <a href="../../Utilities/reference/#MathOptInterface.Utilities.get_fallback"><code>MathOptInterface.Utilities.get_fallback</code></a> if a <code>CachingOptimizer</code> is used (since <code>ConstraintFunction</code> cannot be got as functions cannot be unbridged).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.FreeBridge" href="#MathOptInterface.Bridges.Variable.FreeBridge"><code>MathOptInterface.Bridges.Variable.FreeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FreeBridge{T} &lt;: Bridges.Variable.AbstractBridge</code></pre><p>Transforms constrained variables in <a href="../../../reference/standard_form/#MathOptInterface.Reals"><code>MOI.Reals</code></a> to the difference of constrained variables in <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.NonposToNonnegBridge" href="#MathOptInterface.Bridges.Variable.NonposToNonnegBridge"><code>MathOptInterface.Bridges.Variable.NonposToNonnegBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonposToNonnegBridge{T} &lt;:
    FlipSignBridge{T, MOI.Nonpositives, MOI.Nonnegatives}</code></pre><p>Transforms constrained variables in <code>Nonpositives</code> into constrained variables in <code>Nonnegatives</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.VectorizeBridge" href="#MathOptInterface.Bridges.Variable.VectorizeBridge"><code>MathOptInterface.Bridges.Variable.VectorizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorizeBridge{T, S}</code></pre><p>Transforms a constrained variable in <code>scalar_set_type(S, T)</code> where <code>S &lt;: VectorLinearSet</code> into a constrained vector of one variable in <code>S</code>. For instance, <code>VectorizeBridge{Float64, MOI.Nonnegatives}</code> transforms a constrained variable in <code>MOI.GreaterThan{Float64}</code> into a constrained vector of one variable in <code>MOI.Nonnegatives</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.SOCtoRSOCBridge" href="#MathOptInterface.Bridges.Variable.SOCtoRSOCBridge"><code>MathOptInterface.Bridges.Variable.SOCtoRSOCBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SOCtoRSOCBridge{T} &lt;: Bridges.Variable.SetMapBridge{T,MOI.RotatedSecondOrderCone,MOI.SecondOrderCone}</code></pre><p>Same transformation as <a href="#MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge"><code>MOI.Bridges.Constraint.SOCtoRSOCBridge</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.RSOCtoSOCBridge" href="#MathOptInterface.Bridges.Variable.RSOCtoSOCBridge"><code>MathOptInterface.Bridges.Variable.RSOCtoSOCBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RSOCtoSOCBridge{T} &lt;: Bridges.Variable.SetMapBridge{T,MOI.SecondOrderCone,MOI.RotatedSecondOrderCone}</code></pre><p>Same transformation as <a href="#MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge"><code>MOI.Bridges.Constraint.RSOCtoSOCBridge</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.RSOCtoPSDBridge" href="#MathOptInterface.Bridges.Variable.RSOCtoPSDBridge"><code>MathOptInterface.Bridges.Variable.RSOCtoPSDBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RSOCtoPSDBridge{T} &lt;: Bridges.Variable.AbstractBridge</code></pre><p>Transforms constrained variables in <a href="../../../reference/standard_form/#MathOptInterface.RotatedSecondOrderCone"><code>MathOptInterface.RotatedSecondOrderCone</code></a> to constrained variables in <a href="../../../reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MathOptInterface.PositiveSemidefiniteConeTriangle</code></a>.</p></div></section></article><h2 id="Objective-bridges"><a class="docs-heading-anchor" href="#Objective-bridges">Objective bridges</a><a id="Objective-bridges-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-bridges" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Objective.AbstractBridge" href="#MathOptInterface.Bridges.Objective.AbstractBridge"><code>MathOptInterface.Bridges.Objective.AbstractBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBridge</code></pre><p>Subtype of <a href="#MathOptInterface.Bridges.AbstractBridge"><code>MathOptInterface.Bridges.AbstractBridge</code></a> for objective bridges.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Objective.SingleBridgeOptimizer" href="#MathOptInterface.Bridges.Objective.SingleBridgeOptimizer"><code>MathOptInterface.Bridges.Objective.SingleBridgeOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SingleBridgeOptimizer{BT&lt;:AbstractBridge, OT&lt;:MOI.ModelLike} &lt;: AbstractBridgeOptimizer</code></pre><p>The <code>SingleBridgeOptimizer</code> bridges any objective functions supported by the bridge <code>BT</code>. This is in contrast with the <a href="#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>MathOptInterface.Bridges.LazyBridgeOptimizer</code></a> which only bridges the objective functions that are unsupported by the internal model, even if they are supported by one of its bridges.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Objective.add_all_bridges" href="#MathOptInterface.Bridges.Objective.add_all_bridges"><code>MathOptInterface.Bridges.Objective.add_all_bridges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_all_bridges(bridged_model, ::Type{T}) where {T}</code></pre><p>Add all bridges defined in the <code>Bridges.Objective</code> submodule to <code>bridged_model</code>. The coefficient type used is <code>T</code>.</p></div></section></article><h3 id="objective_bridges_ref"><a class="docs-heading-anchor" href="#objective_bridges_ref">Bridges implemented</a><a id="objective_bridges_ref-1"></a><a class="docs-heading-anchor-permalink" href="#objective_bridges_ref" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Objective.SlackBridge" href="#MathOptInterface.Bridges.Objective.SlackBridge"><code>MathOptInterface.Bridges.Objective.SlackBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SlackBridge{T, F, G}</code></pre><p>The <code>SlackBridge</code> converts an objective function of type <code>G</code> into a <a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> objective by creating a slack variable and a <code>F</code>-in-<a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan</code></a> constraint for minimization or <code>F</code>-in-<a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan</code></a> constraint for maximization where <code>F</code> is <code>MOI.Utilities.promote_operation(-, T, G, MOI.VariableIndex}</code>. Note that when using this bridge, changing the optimization sense is not supported. Set the sense to <code>MOI.FEASIBILITY_SENSE</code> first to delete the bridge in order to change the sense, then re-add the objective.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Objective.FunctionizeBridge" href="#MathOptInterface.Bridges.Objective.FunctionizeBridge"><code>MathOptInterface.Bridges.Objective.FunctionizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FunctionizeBridge{T}</code></pre><p>The <code>FunctionizeBridge</code> converts a <code>VariableIndex</code> objective into a <code>ScalarAffineFunction{T}</code> objective.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../implementation/">« Implementation</a><a class="docs-footer-nextpage" href="../../FileFormats/overview/">Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Friday 25 February 2022 01:45">Friday 25 February 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
