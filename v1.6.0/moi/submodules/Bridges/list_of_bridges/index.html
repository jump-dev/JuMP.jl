<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>List of bridges · JuMP</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-44252521-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-44252521-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script><link href="../../../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img class="docs-light-only" src="../../../../assets/logo.svg" alt="JuMP logo"/><img class="docs-dark-only" src="../../../../assets/logo-dark.svg" alt="JuMP logo"/></a><form class="docs-search" action="../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../">Introduction</a></li><li><a class="tocitem" href="../../../../should_i_use/">Should I use JuMP?</a></li><li><a class="tocitem" href="../../../../installation/">Installation Guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/getting_started/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/getting_started_with_julia/">Getting started with Julia</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/getting_started_with_JuMP/">Getting started with JuMP</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/getting_started_with_sets_and_indexing/">Getting started with sets and indexing</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/getting_started_with_data_and_plotting/">Getting started with data and plotting</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/debugging/">Debugging</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/design_patterns_for_larger_models/">Design patterns for larger models</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/performance_tips/">Performance tips</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Linear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/linear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../tutorials/linear/diet/">The diet problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../../../tutorials/linear/facility_location/">The facility location problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../../../../tutorials/linear/finance/">Financial modeling problems</a></li><li><a class="tocitem" href="../../../../tutorials/linear/geographic_clustering/">Geographical clustering</a></li><li><a class="tocitem" href="../../../../tutorials/linear/knapsack/">The knapsack problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/n-queens/">N-Queens</a></li><li><a class="tocitem" href="../../../../tutorials/linear/lp_sensitivity/">Sensitivity analysis of a linear program</a></li><li><a class="tocitem" href="../../../../tutorials/linear/network_flows/">Network flow problems</a></li><li><a class="tocitem" href="../../../../tutorials/linear/sudoku/">Sudoku</a></li><li><a class="tocitem" href="../../../../tutorials/linear/transp/">The transportation problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/callbacks/">Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Nonlinear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/nonlinear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/simple_examples/">Simple examples</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/portfolio/">Quadratic portfolio optimization</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/rocket_control/">Rocket Control</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/space_shuttle_reentry_trajectory/">Optimal control for a Space Shuttle reentry trajectory</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/user_defined_hessians/">User-defined Hessians</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/querying_hessians/">Computing Hessians</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Conic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/conic/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../tutorials/conic/start_values/">Primal and dual warm-starts</a></li><li><a class="tocitem" href="../../../../tutorials/conic/tips_and_tricks/">Tips and Tricks</a></li><li><a class="tocitem" href="../../../../tutorials/conic/logistic_regression/">Logistic regression</a></li><li><a class="tocitem" href="../../../../tutorials/conic/cluster/">K-means clustering via SDP</a></li><li><a class="tocitem" href="../../../../tutorials/conic/corr_sdp/">The correlation problem</a></li><li><a class="tocitem" href="../../../../tutorials/conic/experiment_design/">Experiment design</a></li><li><a class="tocitem" href="../../../../tutorials/conic/max_cut_sdp/">SDP relaxations: max-cut</a></li><li><a class="tocitem" href="../../../../tutorials/conic/min_distortion/">The minimum distortion problem</a></li><li><a class="tocitem" href="../../../../tutorials/conic/min_ellipse/">Minimal ellipses</a></li><li><a class="tocitem" href="../../../../tutorials/conic/robust_uncertainty/">Robust uncertainty sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/algorithms/benders_decomposition/">Benders decomposition</a></li><li><a class="tocitem" href="../../../../tutorials/algorithms/cutting_stock_column_generation/">Column generation</a></li><li><a class="tocitem" href="../../../../tutorials/algorithms/tsp_lazy_constraints/">Traveling Salesperson Problem</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/applications/power_systems/">Power Systems</a></li><li><a class="tocitem" href="../../../../tutorials/applications/web_app/">Serving web apps</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../manual/models/">Models</a></li><li><a class="tocitem" href="../../../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../../manual/expressions/">Expressions</a></li><li><a class="tocitem" href="../../../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../../../manual/containers/">Containers</a></li><li><a class="tocitem" href="../../../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../../manual/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../../../manual/callbacks/">Solver-independent Callbacks</a></li><li><a class="tocitem" href="../../../../manual/complex/">Complex number support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../reference/models/">Models</a></li><li><a class="tocitem" href="../../../../reference/variables/">Variables</a></li><li><a class="tocitem" href="../../../../reference/expressions/">Expressions</a></li><li><a class="tocitem" href="../../../../reference/objectives/">Objectives</a></li><li><a class="tocitem" href="../../../../reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../../reference/containers/">Containers</a></li><li><a class="tocitem" href="../../../../reference/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../../reference/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../../../reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../../reference/extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Background Information</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../background/algebraic_modeling_languages/">Algebraic modeling languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../developers/contributing/">Contributing</a></li><li><a class="tocitem" href="../../../../developers/extensions/">Extensions</a></li><li><a class="tocitem" href="../../../../developers/custom_solver_binaries/">Custom binaries</a></li><li><a class="tocitem" href="../../../../developers/style/">Style Guide</a></li><li><a class="tocitem" href="../../../../developers/roadmap/">Roadmap</a></li></ul></li><li><a class="tocitem" href="../../../../release_notes/">Release notes</a></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox" checked/><label class="tocitem" for="menuitem-8"><span class="docs-label">MathOptInterface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../">Introduction</a></li><li><a class="tocitem" href="../../../background/motivation/">Motivation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/example/">Solving a problem using MathOptInterface</a></li><li><a class="tocitem" href="../../../tutorials/implementing/">Implementing a solver interface</a></li><li><a class="tocitem" href="../../../tutorials/mathprogbase/">Transitioning from MathProgBase</a></li><li><a class="tocitem" href="../../../tutorials/bridging_constraint/">Implementing a constraint bridge</a></li><li><a class="tocitem" href="../../../tutorials/manipulating_expressions/">Manipulating expressions</a></li><li><a class="tocitem" href="../../../tutorials/latency/">Latency</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../manual/standard_form/">Standard form problem</a></li><li><a class="tocitem" href="../../../manual/models/">Models</a></li><li><a class="tocitem" href="../../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../manual/modification/">Problem modification</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox"/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../background/duality/">Duality</a></li><li><a class="tocitem" href="../../../background/infeasibility_certificates/">Infeasibility certificates</a></li><li><a class="tocitem" href="../../../background/naming_conventions/">Naming conventions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox"/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../reference/standard_form/">Standard form</a></li><li><a class="tocitem" href="../../../reference/models/">Models</a></li><li><a class="tocitem" href="../../../reference/variables/">Variables</a></li><li><a class="tocitem" href="../../../reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../reference/modification/">Modifications</a></li><li><a class="tocitem" href="../../../reference/nonlinear/">Nonlinear programming</a></li><li><a class="tocitem" href="../../../reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../reference/errors/">Errors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6" type="checkbox" checked/><label class="tocitem" for="menuitem-8-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-6-1" type="checkbox"/><label class="tocitem" for="menuitem-8-6-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-2" type="checkbox" checked/><label class="tocitem" for="menuitem-8-6-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li class="is-active"><a class="tocitem" href>List of bridges</a><ul class="internal"><li><a class="tocitem" href="#constraint_bridges_ref"><span>Constraint bridges</span></a></li><li><a class="tocitem" href="#objective_bridges_ref"><span>Objective bridges</span></a></li><li><a class="tocitem" href="#variable_bridges_ref"><span>Variable bridges</span></a></li></ul></li><li><a class="tocitem" href="../reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-3" type="checkbox"/><label class="tocitem" for="menuitem-8-6-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../FileFormats/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-4" type="checkbox"/><label class="tocitem" for="menuitem-8-6-4"><span class="docs-label">Nonlinear</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nonlinear/overview/">Overview</a></li><li><a class="tocitem" href="../../Nonlinear/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-5" type="checkbox"/><label class="tocitem" for="menuitem-8-6-5"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Utilities/overview/">Overview</a></li><li><a class="tocitem" href="../../Utilities/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-6" type="checkbox"/><label class="tocitem" for="menuitem-8-6-6"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Test/overview/">Overview</a></li><li><a class="tocitem" href="../../Test/reference/">API Reference</a></li></ul></li></ul></li><li><a class="tocitem" href="../../../release_notes/">Release notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">MathOptInterface</a></li><li><a class="is-disabled">Submodules</a></li><li><a class="is-disabled">Bridges</a></li><li class="is-active"><a href>List of bridges</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>List of bridges</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl" title="View the repository on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/moi/submodules/Bridges/list_of_bridges.md" title="Edit source on GitHub"><span class="docs-icon fas"></span></a><a class="docs-settings-button docs-navbar-link fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="List-of-bridges"><a class="docs-heading-anchor" href="#List-of-bridges">List of bridges</a><a id="List-of-bridges-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-bridges" title="Permalink"></a></h1><p>This section describes the <a href="../reference/#MathOptInterface.Bridges.AbstractBridge"><code>Bridges.AbstractBridge</code></a>s that are implemented in MathOptInterface.</p><h2 id="constraint_bridges_ref"><a class="docs-heading-anchor" href="#constraint_bridges_ref">Constraint bridges</a><a id="constraint_bridges_ref-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_bridges_ref" title="Permalink"></a></h2><p>These bridges are subtypes of <a href="../reference/#MathOptInterface.Bridges.Constraint.AbstractBridge"><code>Bridges.Constraint.AbstractBridge</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge" href="#MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge"><code>MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GreaterToIntervalBridge{T,F} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>GreaterToIntervalBridge</code> implements the following reformulations:</p><ul><li><span>$f(x) \ge l$</span> into <span>$f(x) \in [l, \infty)$</span></li></ul><p><strong>Source node</strong></p><p><code>GreaterToIntervalBridge</code> supports:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan{T}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>GreaterToIntervalBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Interval"><code>MOI.Interval{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.LessToIntervalBridge" href="#MathOptInterface.Bridges.Constraint.LessToIntervalBridge"><code>MathOptInterface.Bridges.Constraint.LessToIntervalBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LessToIntervalBridge{T,F} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>LessToIntervalBridge</code> implements the following reformulations:</p><ul><li><span>$f(x) \le u$</span> into <span>$f(x) \in (-\infty, u]$</span></li></ul><p><strong>Source node</strong></p><p><code>LessToIntervalBridge</code> supports:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan{T}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>LessToIntervalBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Interval"><code>MOI.Interval{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.GreaterToLessBridge" href="#MathOptInterface.Bridges.Constraint.GreaterToLessBridge"><code>MathOptInterface.Bridges.Constraint.GreaterToLessBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GreaterToLessBridge{T,F,G} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>GreaterToLessBridge</code> implements the following reformulation:</p><ul><li><span>$f(x) \ge l$</span> into <span>$-f(x) \le -l$</span></li></ul><p><strong>Source node</strong></p><p><code>GreaterToLessBridge</code> supports:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan{T}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>GreaterToLessBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.LessToGreaterBridge" href="#MathOptInterface.Bridges.Constraint.LessToGreaterBridge"><code>MathOptInterface.Bridges.Constraint.LessToGreaterBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LessToGreaterBridge{T,F,G} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>LessToGreaterBridge</code> implements the following reformulation:</p><ul><li><span>$f(x) \le u$</span> into <span>$-f(x) \ge -u$</span></li></ul><p><strong>Source node</strong></p><p><code>LessToGreaterBridge</code> supports:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan{T}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>LessToGreaterBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NonnegToNonposBridge" href="#MathOptInterface.Bridges.Constraint.NonnegToNonposBridge"><code>MathOptInterface.Bridges.Constraint.NonnegToNonposBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonnegToNonposBridge{T,F,G} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>NonnegToNonposBridge</code> implements the following reformulation:</p><ul><li><span>$f(x) \in \mathbb{R}_+$</span> into <span>$-f(x) \in \mathbb{R}_-$</span></li></ul><p><strong>Source node</strong></p><p><code>NonnegToNonposBridge</code> supports:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>NonnegToNonposBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Nonpositives"><code>MOI.Nonpositives</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NonposToNonnegBridge" href="#MathOptInterface.Bridges.Constraint.NonposToNonnegBridge"><code>MathOptInterface.Bridges.Constraint.NonposToNonnegBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonposToNonnegBridge{T,F,G} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>NonposToNonnegBridge</code> implements the following reformulation:</p><ul><li><span>$f(x) \in \mathbb{R}_-$</span> into <span>$-f(x) \in \mathbb{R}_+$</span></li></ul><p><strong>Source node</strong></p><p><code>NonposToNonnegBridge</code> supports:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.Nonpositives"><code>MOI.Nonpositives</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>NonposToNonnegBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.VectorizeBridge" href="#MathOptInterface.Bridges.Constraint.VectorizeBridge"><code>MathOptInterface.Bridges.Constraint.VectorizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorizeBridge{T,F,S,G} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>VectorizeBridge</code> implements the following reformulations:</p><ul><li><span>$g(x) \ge a$</span> into <span>$[g(x) - a] \in \mathbb{R}_+$</span></li><li><span>$g(x) \le a$</span> into <span>$[g(x) - a] \in \mathbb{R}_-$</span></li><li><span>$g(x) == a$</span> into <span>$[g(x) - a] \in \{0\}$</span></li></ul><p>where <code>T</code> is the coefficient type of <code>g(x) - a</code>.</p><p><strong>Source node</strong></p><p><code>VectorizeBridge</code> supports:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan{T}</code></a></li><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan{T}</code></a></li><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{T}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>VectorizeBridge</code> creates:</p><ul><li><code>F</code> in <code>S</code>, where <code>S</code> is one of <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.Nonpositives"><code>MOI.Nonpositives</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.Zeros"><code>MOI.Zeros</code></a> depending on the type of the input set.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.ScalarizeBridge" href="#MathOptInterface.Bridges.Constraint.ScalarizeBridge"><code>MathOptInterface.Bridges.Constraint.ScalarizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScalarizeBridge{T,F,S}</code></pre><p><code>ScalarizeBridge</code> implements the following reformulations:</p><ul><li><span>$f(x) - a \in \mathbb{R}_+$</span> into <span>$f_i(x) \ge a_i$</span> for all <span>$i$</span></li><li><span>$f(x) - a \in \mathbb{R}_-$</span> into <span>$f_i(x) \le a_i$</span> for all <span>$i$</span></li><li><span>$f(x) - a \in \{0\}$</span> into <span>$f_i(x) == a_i$</span> for all <span>$i$</span></li></ul><p><strong>Source node</strong></p><p><code>ScalarizeBridge</code> supports:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives{T}</code></a></li><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.Nonpositives"><code>MOI.Nonpositives{T}</code></a></li><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.Zeros"><code>MOI.Zeros{T}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>ScalarizeBridge</code> creates:</p><ul><li><code>F</code> in <code>S</code>, where <code>S</code> is one of <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan{T}</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan{T}</code></a>, and <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{T}</code></a>, depending on the type of the input set.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.ScalarSlackBridge" href="#MathOptInterface.Bridges.Constraint.ScalarSlackBridge"><code>MathOptInterface.Bridges.Constraint.ScalarSlackBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScalarSlackBridge{T,F,S} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>ScalarSlackBridge</code> implements the following reformulation:</p><ul><li><span>$f(x) \in S$</span> into <span>$f(x) - y == 0$</span> and <span>$y \in S$</span></li></ul><p><strong>Source node</strong></p><p><code>ScalarSlackBridge</code> supports:</p><ul><li><code>G</code> in <code>S</code>, where <code>G</code> is not <a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> and <code>S</code> is not <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>ScalarSlackBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{T}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <code>S</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.VectorSlackBridge" href="#MathOptInterface.Bridges.Constraint.VectorSlackBridge"><code>MathOptInterface.Bridges.Constraint.VectorSlackBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorSlackBridge{T,F,S} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>VectorSlackBridge</code> implements the following reformulation:</p><ul><li><span>$f(x) \in S$</span> into <span>$f(x) - y \in \{0\}$</span> and <span>$y \in S$</span></li></ul><p><strong>Source node</strong></p><p><code>VectorSlackBridge</code> supports:</p><ul><li><code>G</code> in <code>S</code>, where <code>G</code> is not <a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> and <code>S</code> is not <a href="../../../reference/standard_form/#MathOptInterface.Zeros"><code>MOI.Zeros</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>VectorSlackBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Zeros"><code>MOI.Zeros</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <code>S</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge" href="#MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge"><code>MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScalarFunctionizeBridge{T,S} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>ScalarFunctionizeBridge</code> implements the following reformulations:</p><ul><li><span>$x \in S$</span> into <span>$1x + 0 \in S$</span></li></ul><p><strong>Source node</strong></p><p><code>ScalarFunctionizeBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <code>S</code></li></ul><p><strong>Target nodes</strong></p><p><code>ScalarFunctionizeBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <code>S</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge" href="#MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge"><code>MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorFunctionizeBridge{T,S} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>VectorFunctionizeBridge</code> implements the following reformulations:</p><ul><li><span>$x \in S$</span> into <span>$Ix + 0 \in S$</span></li></ul><p><strong>Source node</strong></p><p><code>VectorFunctionizeBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <code>S</code></li></ul><p><strong>Target nodes</strong></p><p><code>VectorFunctionizeBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorAffineFunction"><code>MOI.VectorAffineFunction{T}</code></a> in <code>S</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SplitComplexEqualToBridge" href="#MathOptInterface.Bridges.Constraint.SplitComplexEqualToBridge"><code>MathOptInterface.Bridges.Constraint.SplitComplexEqualToBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SplitComplexEqualToBridge{T,F,G} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>SplitComplexEqualToBridge</code> implements the following reformulation:</p><ul><li><span>$f(x) + g(x) * im = a + b * im$</span> into <span>$f(x) = a$</span> and <span>$g(x) = b$</span></li></ul><p><strong>Source node</strong></p><p><code>SplitComplexEqualToBridge</code> supports:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{Complex{T}}</code></a></li></ul><p>where <code>G</code> is a function with <code>Complex</code> coefficients.</p><p><strong>Target nodes</strong></p><p><code>SplitComplexEqualToBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{T}</code></a></li></ul><p>where <code>F</code> is the type of the real/imaginary part of <code>G</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SplitComplexZerosBridge" href="#MathOptInterface.Bridges.Constraint.SplitComplexZerosBridge"><code>MathOptInterface.Bridges.Constraint.SplitComplexZerosBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SplitComplexZerosBridge{T,F,G} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>SplitComplexZerosBridge</code> implements the following reformulation:</p><ul><li><span>$f(x) \in \{0\}^n$</span> into <span>$\text{Re}(f(x)) \in \{0\}^n$</span> and <span>$\text{Im}(f(x)) \in \{0\}^n$</span></li></ul><p><strong>Source node</strong></p><p><code>SplitComplexZerosBridge</code> supports:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.Zeros"><code>MOI.Zeros</code></a></li></ul><p>where <code>G</code> is a function with <code>Complex</code> coefficients.</p><p><strong>Target nodes</strong></p><p><code>SplitComplexZerosBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Zeros"><code>MOI.Zeros</code></a></li></ul><p>where <code>F</code> is the type of the real/imaginary part of <code>G</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SplitHyperRectangleBridge" href="#MathOptInterface.Bridges.Constraint.SplitHyperRectangleBridge"><code>MathOptInterface.Bridges.Constraint.SplitHyperRectangleBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SplitHyperRectangleBridge{T,G,F} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>SplitHyperRectangleBridge</code> implements the following reformulation:</p><ul><li><span>$f(x) \in \textsf{HyperRectangle}(l, u)$</span> to <span>$[f(x) - l; u - f(x)] \in \mathbb{R}_+$</span>.</li></ul><p><strong>Source node</strong></p><p><code>SplitHyperRectangleBridge</code> supports:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.HyperRectangle"><code>MOI.HyperRectangle</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>SplitHyperRectangleBridge</code> creates:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SplitIntervalBridge" href="#MathOptInterface.Bridges.Constraint.SplitIntervalBridge"><code>MathOptInterface.Bridges.Constraint.SplitIntervalBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SplitIntervalBridge{T,F,S,LS,US} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>SplitIntervalBridge</code> implements the following reformulations:</p><ul><li><span>$l \le f(x) \le u$</span> into <span>$f(x) \ge l$</span> and <span>$f(x) \le u$</span></li><li><span>$f(x) = b$</span> into <span>$f(x) \ge b$</span> and <span>$f(x) \le b$</span></li><li><span>$f(x) \in \{0\}$</span> into <span>$f(x) \in \mathbb{R}_+$</span> and <span>$f(x) \in \mathbb{R}_-$</span></li></ul><p><strong>Source node</strong></p><p><code>SplitIntervalBridge</code> supports:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Interval"><code>MOI.Interval{T}</code></a></li><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{T}</code></a></li><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Zeros"><code>MOI.Zeros</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>SplitIntervalBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan{T}</code></a></li><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan{T}</code></a></li></ul><p>or</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a></li><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Nonpositives"><code>MOI.Nonpositives</code></a></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <code>T&lt;:AbstractFloat</code> and <code>S</code> is <code>MOI.Interval{T}</code> then no lower (resp. upper) bound constraint is created if the lower (resp. upper) bound is <code>typemin(T)</code> (resp. <code>typemax(T)</code>). Similarly, when <a href="../../../reference/constraints/#MathOptInterface.ConstraintSet"><code>MOI.ConstraintSet</code></a> is set, a lower or upper bound constraint may be deleted or created accordingly.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge" href="#MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge"><code>MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SOCtoRSOCBridge{T,F,G} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>SOCtoRSOCBridge</code> implements the following reformulation:</p><ul><li><span>$||x||_2 \le t$</span> into <span>$(t+x_1)(t-x_1)\ge ||(x_2\ldots,x_N)||_2^2$</span></li></ul><p><strong>Assumptions</strong></p><ul><li><code>SOCtoRSOCBridge</code> assumes that the length of <code>x</code> is at least one.</li></ul><p><strong>Source node</strong></p><p><code>SOCtoRSOCBridge</code> supports:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.SecondOrderCone"><code>MOI.SecondOrderCone</code></a></li></ul><p><strong>Target node</strong></p><p><code>SOCtoRSOCBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.RotatedSecondOrderCone"><code>MOI.RotatedSecondOrderCone</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge" href="#MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge"><code>MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RSOCtoSOCBridge{T,F,G} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>RSOCtoSOCBridge</code> implements the following reformulation:</p><ul><li><span>$||x||_2^2 \le 2tu$</span> into <span>$||\frac{t - u}{\sqrt 2}, x||_2 \le  \frac{t + u}{\sqrt 2}$</span></li></ul><p><strong>Source node</strong></p><p><code>RSOCtoSOCBridge</code> supports:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.RotatedSecondOrderCone"><code>MOI.RotatedSecondOrderCone</code></a></li></ul><p><strong>Target node</strong></p><p><code>RSOCtoSOCBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.SecondOrderCone"><code>MOI.SecondOrderCone</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge" href="#MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge"><code>MathOptInterface.Bridges.Constraint.SOCtoNonConvexQuadBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SOCtoNonConvexQuadBridge{T} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>SOCtoNonConvexQuadBridge</code> implements the following reformulations:</p><ul><li><span>$||x||_2 \le t$</span> into <span>$\sum x^2 - t^2 \le 0$</span> and <span>$1t + 0 \ge 0$</span></li></ul><p>The <a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction</code></a> <span>$1t + 0$</span> is used in case the variable has other bound constraints.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This transformation starts from a convex constraint and creates a non-convex constraint. Unless the solver has explicit support for detecting second-order cones in quadratic form, this may (wrongly) be interpreted by the solver as being non-convex. Therefore, this bridge is not added automatically by <a href="../reference/#MathOptInterface.Bridges.full_bridge_optimizer"><code>MOI.Bridges.full_bridge_optimizer</code></a>. Care is recommended when adding this bridge to a optimizer.</p></div></div><p><strong>Source node</strong></p><p><code>SOCtoNonConvexQuadBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.SecondOrderCone"><code>MOI.SecondOrderCone</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>SOCtoNonConvexQuadBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarQuadraticFunction"><code>MOI.ScalarQuadraticFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan{T}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.RSOCtoNonConvexQuadBridge" href="#MathOptInterface.Bridges.Constraint.RSOCtoNonConvexQuadBridge"><code>MathOptInterface.Bridges.Constraint.RSOCtoNonConvexQuadBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RSOCtoNonConvexQuadBridge{T} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>RSOCtoNonConvexQuadBridge</code> implements the following reformulations:</p><ul><li><span>$||x||_2^2 \le 2tu$</span> into <span>$\sum x^2 - 2tu \le 0$</span>, <span>$1t + 0 \ge 0$</span>, and <span>$1u + 0 \ge 0$</span>.</li></ul><p>The <a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction</code></a>s <span>$1t + 0$</span> and <span>$1u + 0$</span> are used in case the variables have other bound constraints.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This transformation starts from a convex constraint and creates a non-convex constraint. Unless the solver has explicit support for detecting rotated second-order cones in quadratic form, this may (wrongly) be interpreted by the solver as being non-convex. Therefore, this bridge is not added automatically by <a href="../reference/#MathOptInterface.Bridges.full_bridge_optimizer"><code>MOI.Bridges.full_bridge_optimizer</code></a>. Care is recommended when adding this bridge to a optimizer.</p></div></div><p><strong>Source node</strong></p><p><code>RSOCtoNonConvexQuadBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.RotatedSecondOrderCone"><code>MOI.RotatedSecondOrderCone</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>RSOCtoNonConvexQuadBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarQuadraticFunction"><code>MOI.ScalarQuadraticFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan{T}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.QuadtoSOCBridge" href="#MathOptInterface.Bridges.Constraint.QuadtoSOCBridge"><code>MathOptInterface.Bridges.Constraint.QuadtoSOCBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuadtoSOCBridge{T} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>QuadtoSOCBridge</code> converts quadratic inequalities</p><p class="math-container">\[\frac{1}{2}x^T Q x + a^T x + b \le 0\]</p><p>into <a href="../../../reference/standard_form/#MathOptInterface.RotatedSecondOrderCone"><code>MOI.RotatedSecondOrderCone</code></a> constraints, but it only applies when <span>$Q$</span> is positive definite.</p><p>This is because, if <code>Q</code> is positive definite, there exists <code>U</code> such that <span>$Q = U^T U$</span>, and so the inequality can then be rewritten as;</p><p class="math-container">\[\|U x\|_2^2 \le 2 (-a^T x - b)\]</p><p>Therefore, <code>QuadtoSOCBridge</code> implements the following reformulation:</p><ul><li><span>$\frac{1}{2}x^T Q x + a^T x + b \le 0$</span> into <span>$(1, -a^T x - b, Ux) \in RotatedSecondOrderCone$</span></li></ul><p><strong>Source node</strong></p><p><code>QuadtoSOCBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan{T}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan{T}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>RelativeEntropyBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorAffineFunction"><code>MOI.VectorAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.RotatedSecondOrderCone"><code>MOI.RotatedSecondOrderCone</code></a></li></ul><p><strong>Errors</strong></p><p>This bridge errors if <code>Q</code> is not positive definite.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SOCtoPSDBridge" href="#MathOptInterface.Bridges.Constraint.SOCtoPSDBridge"><code>MathOptInterface.Bridges.Constraint.SOCtoPSDBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SOCtoPSDBridge{T,F,G} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>SOCtoPSDBridge</code> implements the following reformulation:</p><ul><li><span>$||x||_2 \le t$</span> into <span>$\left[\begin{array}{c c}t &amp; x^\top \\ x &amp; t \mathbf{I}\end{array}\right]\succeq 0$</span></li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This bridge is not added by default by <a href="../reference/#MathOptInterface.Bridges.full_bridge_optimizer"><code>MOI.Bridges.full_bridge_optimizer</code></a> because bridging second order cone constraints to semidefinite constraints can be achieved by the <a href="#MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge"><code>SOCtoRSOCBridge</code></a> followed by the <a href="#MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge"><code>RSOCtoPSDBridge</code></a>, while creating a smaller semidefinite constraint.</p></div></div><p><strong>Source node</strong></p><p><code>SOCtoPSDBridge</code> supports:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.SecondOrderCone"><code>MOI.SecondOrderCone</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>SOCtoPSDBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MOI.PositiveSemidefiniteConeTriangle</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge" href="#MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge"><code>MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RSOCtoPSDBridge{T,F,G} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>RSOCtoPSDBridge</code> implements the following reformulation:</p><ul><li><span>$||x||_2^2 \le 2t\cdot u$</span> into <span>$\left[\begin{array}{c c}t &amp; x^\top \\ x &amp; 2tu \mathbf{I}\end{array}\right]\succeq 0$</span></li></ul><p><strong>Source node</strong></p><p><code>RSOCtoPSDBridge</code> supports:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.RotatedSecondOrderCone"><code>MOI.RotatedSecondOrderCone</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>RSOCtoPSDBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MOI.PositiveSemidefiniteConeTriangle</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NormInfinityBridge" href="#MathOptInterface.Bridges.Constraint.NormInfinityBridge"><code>MathOptInterface.Bridges.Constraint.NormInfinityBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NormInfinityBridge{T,F,G} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>NormInfinityBridge</code> implements the following reformulation:</p><ul><li><span>$|x|_\infty \le t$</span> into <span>$[t - x_i, t + x_i] \in \mathbb{R}_+$</span>.</li></ul><p><strong>Source node</strong></p><p><code>NormInfinityBridge</code> supports:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.NormInfinityCone"><code>MOI.NormInfinityCone{T}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>NormInfinityBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NormOneBridge" href="#MathOptInterface.Bridges.Constraint.NormOneBridge"><code>MathOptInterface.Bridges.Constraint.NormOneBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NormOneBridge{T,F,G} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>NormOneBridge</code> implements the following reformulation:</p><ul><li><span>$\sum |x_i| \le t$</span> into <span>$[t - \sum y_i, y_i - x_i, y_i + x_i] \in \mathbb{R}_+$</span>.</li></ul><p><strong>Source node</strong></p><p><code>NormOneBridge</code> supports:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.NormOneCone"><code>MOI.NormOneCone{T}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>NormOneBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge" href="#MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge"><code>MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeoMeantoRelEntrBridge{T,F,G,H} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>GeoMeantoRelEntrBridge</code> implements the following reformulation:</p><ul><li><span>$(u, w) \in GeometricMeanCone$</span> into <span>$(0, w, (u + y)\mathbf{1})\in RelativeEntropyCone$</span> and <span>$y \ge 0$</span></li></ul><p><strong>Source node</strong></p><p><code>GeoMeantoRelEntrBridge</code> supports:</p><ul><li><code>H</code> in <a href="../../../reference/standard_form/#MathOptInterface.GeometricMeanCone"><code>MOI.GeometricMeanCone</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>GeoMeantoRelEntrBridge</code> creates:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.RelativeEntropyCone"><code>MOI.RelativeEntropyCone</code></a></li><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a></li></ul><p><strong>Derivation</strong></p><p>The derivation of the bridge is as follows:</p><p class="math-container">\[\begin{aligned}
(u, w) \in GeometricMeanCone \iff &amp; u \le \left(\prod_{i=1}^n w_i\right)^{1/n} \\
\iff &amp; 0 \le u + y \le \left(\prod_{i=1}^n w_i\right)^{1/n}, y \ge 0 \\
\iff &amp; 1 \le \frac{\left(\prod_{i=1}^n w_i\right)^{1/n}}{u + y}, y \ge 0 \\
\iff &amp; 1 \le \left(\prod_{i=1}^n \frac{w_i}{u + y}\right)^{1/n}, y \ge 0 \\
\iff &amp; 0 \le \sum_{i=1}^n \log\left(\frac{w_i}{u + y}\right), y \ge 0 \\
\iff &amp; 0 \ge \sum_{i=1}^n \log\left(\frac{u + y}{w_i}\right), y \ge 0 \\
\iff &amp; 0 \ge \sum_{i=1}^n (u + y) \log\left(\frac{u + y}{w_i}\right), y \ge 0 \\
\iff &amp; (0, w, (u + y)\mathbf{1}) \in RelativeEntropyCone, y \ge 0 \\
\end{aligned}\]</p><p>This derivation assumes that <span>$u + y &gt; 0$</span>, which is enforced by the relative entropy cone.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.GeoMeanToPowerBridge" href="#MathOptInterface.Bridges.Constraint.GeoMeanToPowerBridge"><code>MathOptInterface.Bridges.Constraint.GeoMeanToPowerBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeoMeanToPowerBridge{T,F} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>GeoMeanToPowerBridge</code> implements the following reformulation:</p><ul><li><span>$(y, x...) \in GeometricMeanCone(1+d)$</span> into <span>$(x_1, t, y) \in PowerCone(1/d)$</span> and <span>$(t, x_2, ..., x_d) in GeometricMeanCone(d)$</span>, which is then recursively expanded into more <code>PowerCone</code> constraints.</li></ul><p><strong>Source node</strong></p><p><code>GeoMeanToPowerBridge</code> supports:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.GeometricMeanCone"><code>MOI.GeometricMeanCone</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>GeoMeanToPowerBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.PowerCone"><code>MOI.PowerCone{T}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.GeoMeanBridge" href="#MathOptInterface.Bridges.Constraint.GeoMeanBridge"><code>MathOptInterface.Bridges.Constraint.GeoMeanBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeoMeanBridge{T,F,G,H} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>GeoMeanBridge</code> implements a reformulation from <a href="../../../reference/standard_form/#MathOptInterface.GeometricMeanCone"><code>MOI.GeometricMeanCone</code></a> into <a href="../../../reference/standard_form/#MathOptInterface.RotatedSecondOrderCone"><code>MOI.RotatedSecondOrderCone</code></a>.</p><p>The reformulation is best described in an example.</p><p>Consider the cone of dimension 4:</p><p class="math-container">\[t \le \sqrt[3]{x_1 x_2 x_3}\]</p><p>This can be rewritten as <span>$\exists y \ge 0$</span> such that:</p><p class="math-container">\[\begin{align*}
  t &amp; \le y,\\
  y^4 &amp; \le x_1 x_2 x_3 y.
\end{align*}\]</p><p>Note that we need to create <span>$y$</span> and not use <span>$t^4$</span> directly because <span>$t$</span> is allowed to be negative.</p><p>This is equivalent to:</p><p class="math-container">\[\begin{align*}
    t &amp; \le \frac{y_1}{\sqrt{4}},\\
    y_1^2 &amp; \le 2y_2 y_3,\\
    y_2^2 &amp; \le 2x_1 x_2, \\
    y_3^2 &amp; \le 2x_3(y_1/\sqrt{4}) \\
    y     &amp; \ge 0.
\end{align*}\]</p><p>More generally, you can show how the geometric mean code is recursively expanded into a set of new variables <span>$y$</span> in <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a>, a set of <a href="../../../reference/standard_form/#MathOptInterface.RotatedSecondOrderCone"><code>MOI.RotatedSecondOrderCone</code></a> constraints, and a <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan</code></a> constraint between <span>$t$</span> and <span>$y_1$</span>.</p><p><strong>Source node</strong></p><p><code>GeoMeanBridge</code> supports:</p><ul><li><code>H</code> in <a href="../../../reference/standard_form/#MathOptInterface.GeometricMeanCone"><code>MOI.GeometricMeanCone</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>GeoMeanBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan{T}</code></a></li><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.RotatedSecondOrderCone"><code>MOI.RotatedSecondOrderCone</code></a></li><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.RelativeEntropyBridge" href="#MathOptInterface.Bridges.Constraint.RelativeEntropyBridge"><code>MathOptInterface.Bridges.Constraint.RelativeEntropyBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RelativeEntropyBridge{T,F,G,H} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>RelativeEntropyBridge</code> implements the following reformulation that converts a <a href="../../../reference/standard_form/#MathOptInterface.RelativeEntropyCone"><code>MOI.RelativeEntropyCone</code></a> into an <a href="../../../reference/standard_form/#MathOptInterface.ExponentialCone"><code>MOI.ExponentialCone</code></a>:</p><ul><li><span>$u \ge \sum_{i=1}^n w_i \log \left(\frac{w_i}{v_i}\right)$</span> into <span>$y_i \ge 0$</span>, <span>$u \ge \sum_{i=1}^n y_i$</span>, and <span>$(-y_i, w_i, v_i) \in ExponentialCone$</span>.</li></ul><p><strong>Source node</strong></p><p><code>RelativeEntropyBridge</code> supports:</p><ul><li><code>H</code> in <a href="../../../reference/standard_form/#MathOptInterface.RelativeEntropyCone"><code>MOI.RelativeEntropyCone</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>RelativeEntropyBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan{T}</code></a></li><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.ExponentialCone"><code>MOI.ExponentialCone</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NormSpectralBridge" href="#MathOptInterface.Bridges.Constraint.NormSpectralBridge"><code>MathOptInterface.Bridges.Constraint.NormSpectralBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NormSpectralBridge{T,F,G} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>NormSpectralBridge</code> implements the following reformulation:</p><ul><li><span>$t \ge \sigma_1(X)$</span> into <span>$\left[\begin{array}{c c}t\mathbf{I} &amp; X^\top \\ X &amp; t \mathbf{I}\end{array}\right] \succeq 0$</span></li></ul><p><strong>Source node</strong></p><p><code>NormSpectralBridge</code> supports:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.NormSpectralCone"><code>MOI.NormSpectralCone</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>NormSpectralBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MOI.PositiveSemidefiniteConeTriangle</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.NormNuclearBridge" href="#MathOptInterface.Bridges.Constraint.NormNuclearBridge"><code>MathOptInterface.Bridges.Constraint.NormNuclearBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NormNuclearBridge{T,F,G,H} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>NormNuclearBridge</code> implements the following reformulation:</p><ul><li><span>$t \ge \sum_i \sigma_i (X)$</span> into <span>$\left[\begin{array}{c c}U &amp; X^\top \\ X &amp; V\end{array}\right] \succeq 0$</span> and <span>$2t \ge tr(U) + tr(V)$</span>.</li></ul><p><strong>Source node</strong></p><p><code>NormNuclearBridge</code> supports:</p><ul><li><code>H</code> in <a href="../../../reference/standard_form/#MathOptInterface.NormNuclearCone"><code>MOI.NormNuclearCone</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>NormNuclearBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan{T}</code></a></li><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MOI.PositiveSemidefiniteConeTriangle</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SquareBridge" href="#MathOptInterface.Bridges.Constraint.SquareBridge"><code>MathOptInterface.Bridges.Constraint.SquareBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SquareBridge{T,F,G,TT,ST} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>SquareBridge</code> implements the following reformulations:</p><ul><li><span>$(t, u, X) \in LogDetConeSquare$</span> into <span>$(t, u, Y) in LogDetConeTriangle$</span></li><li><span>$(t, X) \in RootDetConeSquare$</span> into <span>$(t, Y) in RootDetConeTriangle$</span></li><li><span>$X \in AbstractSymmetricMatrixSetSquare$</span> into <span>$Y in AbstractSymmetricMatrixSetTriangle$</span></li></ul><p>where <span>$Y$</span> is the upper triangluar component of <span>$X$</span>.</p><p>In addition, constraints are added as necessary to constrain the matrix <span>$X$</span> to be symmetric. For example, the constraint for the matrix:</p><p class="math-container">\[\begin{pmatrix}
  1      &amp; 1 + x &amp; 2 - 3x\\
  1 +  x &amp; 2 + x &amp; 3 -  x\\
  2 - 3x &amp; 2 + x &amp;     2x
\end{pmatrix}\]</p><p>can be broken down to the constraint of the symmetric matrix</p><p class="math-container">\[\begin{pmatrix}
  1      &amp; 1 + x &amp; 2 - 3x\\
  \cdot &amp; 2 + x &amp; 3 -  x\\
  \cdot &amp; \cdot &amp;    2x
\end{pmatrix}\]</p><p>and the equality constraint between the off-diagonal entries (2, 3) and (3, 2) <span>$3 - x == 2 + x$</span>. Note that no symmetrization constraint needs to be added between the off-diagonal entries (1, 2) and (2, 1) or between (1, 3) and (3, 1) because the expressions are the same.</p><p><strong>Source node</strong></p><p><code>SquareBridge</code> supports:</p><ul><li><code>F</code> in <code>ST</code></li></ul><p><strong>Target nodes</strong></p><p><code>SquareBridge</code> creates:</p><ul><li><code>G</code> in <code>TT</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.HermitianToSymmetricPSDBridge" href="#MathOptInterface.Bridges.Constraint.HermitianToSymmetricPSDBridge"><code>MathOptInterface.Bridges.Constraint.HermitianToSymmetricPSDBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HermitianToSymmetricPSDBridge{T,F,G} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>HermitianToSymmetricPSDBridge</code> implements the following reformulation:</p><ul><li>Hermitian positive semidefinite <code>n x n</code> complex matrix to a symmetric positive semidefinite <code>2n x 2n</code> real matrix.</li></ul><p>See also <a href="#MathOptInterface.Bridges.Variable.HermitianToSymmetricPSDBridge"><code>MOI.Bridges.Variable.HermitianToSymmetricPSDBridge</code></a>.</p><p><strong>Source node</strong></p><p><code>HermitianToSymmetricPSDBridge</code> supports:</p><ul><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.HermitianPositiveSemidefiniteConeTriangle"><code>MOI.HermitianPositiveSemidefiniteConeTriangle</code></a></li></ul><p><strong>Target node</strong></p><p><code>HermitianToSymmetricPSDBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MOI.PositiveSemidefiniteConeTriangle</code></a></li></ul><p><strong>Reformulation</strong></p><p>The reformulation is best described by example.</p><p>The Hermitian matrix:</p><p class="math-container">\[\begin{bmatrix}
  x_{11}            &amp; x_{12} + y_{12}im &amp; x_{13} + y_{13}im\\
  x_{12} - y_{12}im &amp; x_{22}            &amp; x_{23} + y_{23}im\\
  x_{13} - y_{13}im &amp; x_{23} - y_{23}im &amp; x_{33}
\end{bmatrix}\]</p><p>is positive semidefinite if and only if the symmetric matrix:</p><p class="math-container">\[\begin{bmatrix}
    x_{11} &amp; x_{12} &amp; x_{13} &amp; 0       &amp; y_{12}  &amp; y_{13} \\
           &amp; x_{22} &amp; x_{23} &amp; -y_{12} &amp; 0       &amp; y_{23} \\
           &amp;        &amp; x_{33} &amp; -y_{13} &amp; -y_{23} &amp; 0      \\
           &amp;        &amp;        &amp; x_{11}  &amp; x_{12}  &amp; x_{13} \\
           &amp;        &amp;        &amp;         &amp; x_{22}  &amp; x_{23} \\
           &amp;        &amp;        &amp;         &amp;         &amp; x_{33}
\end{bmatrix}\]</p><p>is positive semidefinite.</p><p>The bridge achieves this reformulation by constraining the above matrix to belong to the <code>MOI.PositiveSemidefiniteConeTriangle(6)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.RootDetBridge" href="#MathOptInterface.Bridges.Constraint.RootDetBridge"><code>MathOptInterface.Bridges.Constraint.RootDetBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RootDetBridge{T,F,G,H} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p>The <a href="../../../reference/standard_form/#MathOptInterface.RootDetConeTriangle"><code>MOI.RootDetConeTriangle</code></a> is representable by <a href="../../../reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MOI.PositiveSemidefiniteConeTriangle</code></a> and <a href="../../../reference/standard_form/#MathOptInterface.GeometricMeanCone"><code>MOI.GeometricMeanCone</code></a> constraints, see [1, p. 149].</p><p>Indeed, <span>$t \le \det(X)^{1/n}$</span> if and only if there exists a lower triangular matrix <span>$Δ$</span> such that:</p><p class="math-container">\[\begin{align*}
  \begin{pmatrix}
    X &amp; Δ\\
    Δ^\top &amp; \mathrm{Diag}(Δ)
  \end{pmatrix} &amp; \succeq 0\\
  (t, \mathrm{Diag}(Δ)) &amp; \in GeometricMeanCone
\end{align*}\]</p><p><strong>Source node</strong></p><p><code>RootDetBridge</code> supports:</p><ul><li><code>I</code> in <a href="../../../reference/standard_form/#MathOptInterface.RootDetConeTriangle"><code>MOI.RootDetConeTriangle</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>RootDetBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MOI.PositiveSemidefiniteConeTriangle</code></a></li><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.GeometricMeanCone"><code>MOI.GeometricMeanCone</code></a></li></ul><p>[1] Ben-Tal, Aharon, and Arkadi Nemirovski. <em>Lectures on modern convex     optimization: analysis, algorithms, and engineering applications</em>. Society     for Industrial and Applied Mathematics, 2001.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.LogDetBridge" href="#MathOptInterface.Bridges.Constraint.LogDetBridge"><code>MathOptInterface.Bridges.Constraint.LogDetBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LogDetBridge{T,F,G,H,I} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p>The <a href="../../../reference/standard_form/#MathOptInterface.LogDetConeTriangle"><code>MOI.LogDetConeTriangle</code></a> is representable by <a href="../../../reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MOI.PositiveSemidefiniteConeTriangle</code></a> and <a href="../../../reference/standard_form/#MathOptInterface.ExponentialCone"><code>MOI.ExponentialCone</code></a> constraints.</p><p>Indeed, <span>$\log\det(X) = \sum\limits_{i=1}^n \log(\delta_i)$</span> where <span>$\delta_i$</span> are the eigenvalues of <span>$X$</span>.</p><p>Adapting the method from [1, p. 149], we see that <span>$t \le u \log(\det(X/u))$</span> for <span>$u &gt; 0$</span> if and only if there exists a lower triangular matrix <span>$Δ$</span> such that</p><p class="math-container">\[\begin{align*}
  \begin{pmatrix}
    X &amp; Δ\\
    Δ^\top &amp; \mathrm{Diag}(Δ)
  \end{pmatrix} &amp; \succeq 0\\
  t - \sum_{i=1}^n u \log\left(\frac{Δ_{ii}}{u}\right) &amp; \le 0
\end{align*}\]</p><p>Which we reformulate further into</p><p class="math-container">\[\begin{align*}
  \begin{pmatrix}
    X &amp; Δ\\
    Δ^\top &amp; \mathrm{Diag}(Δ)
  \end{pmatrix} &amp; \succeq 0\\
  (l_i, u , Δ_{ii}) &amp; \in ExponentialCone\quad \forall i \\
  t - \sum_{i=1}^n l_i &amp; \le 0
\end{align*}\]</p><p><strong>Source node</strong></p><p><code>LogDetBridge</code> supports:</p><ul><li><code>I</code> in <a href="../../../reference/standard_form/#MathOptInterface.LogDetConeTriangle"><code>MOI.LogDetConeTriangle</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>LogDetBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MOI.PositiveSemidefiniteConeTriangle</code></a></li><li><code>G</code> in <a href="../../../reference/standard_form/#MathOptInterface.ExponentialCone"><code>MOI.ExponentialCone</code></a></li><li><code>H</code> in <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan{T}</code></a></li></ul><p>[1] Ben-Tal, Aharon, and Arkadi Nemirovski. <em>Lectures on modern convex     optimization: analysis, algorithms, and engineering applications</em>. Society     for Industrial and Applied Mathematics, 2001.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge" href="#MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge"><code>MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndicatorActiveOnFalseBridge{T,F,S} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>IndicatorActiveOnFalseBridge</code> implements the following reformulation:</p><ul><li><span>$\neg z \implies {f(x) \in S}$</span> into <span>$y \implies {f(x) \in S}$</span>, <span>$z + y = 1$</span>, and <span>$y \in \{0, 1\}$</span></li></ul><p><strong>Source node</strong></p><p><code>IndicatorActiveOnFalseBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorAffineFunction"><code>MOI.VectorAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Indicator"><code>MOI.Indicator{MOI.ACTIVATE_ON_ZERO,S}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>IndicatorActiveOnFalseBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorAffineFunction"><code>MOI.VectorAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Indicator"><code>MOI.Indicator{MOI.ACTIVATE_ON_ONE,S}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.ZeroOne"><code>MOI.ZeroOne</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.IndicatorGreaterToLessThanBridge" href="#MathOptInterface.Bridges.Constraint.IndicatorGreaterToLessThanBridge"><code>MathOptInterface.Bridges.Constraint.IndicatorGreaterToLessThanBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndicatorGreaterToLessThanBridge{T,A} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>IndicatorGreaterToLessThanBridge</code> implements the following reformulation:</p><ul><li><span>$z \implies {f(x) \ge l}$</span> into <span>$z \implies {-f(x) \le -l}$</span></li></ul><p><strong>Source node</strong></p><p><code>IndicatorGreaterToLessThanBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorAffineFunction"><code>MOI.VectorAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Indicator"><code>MOI.Indicator{A,MOI.GreaterThan{T}}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>IndicatorGreaterToLessThanBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorAffineFunction"><code>MOI.VectorAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Indicator"><code>MOI.Indicator{A,MOI.LessThan{T}}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.IndicatorLessToGreaterThanBridge" href="#MathOptInterface.Bridges.Constraint.IndicatorLessToGreaterThanBridge"><code>MathOptInterface.Bridges.Constraint.IndicatorLessToGreaterThanBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndicatorLessToGreaterThanBridge{T,A} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>IndicatorLessToGreaterThanBridge</code> implements the following reformulations:</p><ul><li><span>$z \implies {f(x) \le u}$</span> into <span>$z \implies {-f(x) \ge -u}$</span></li></ul><p><strong>Source node</strong></p><p><code>IndicatorLessToGreaterThanBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorAffineFunction"><code>MOI.VectorAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Indicator"><code>MOI.Indicator{A,MOI.LessThan{T}}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>IndicatorLessToGreaterThanBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorAffineFunction"><code>MOI.VectorAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Indicator"><code>MOI.Indicator{A,MOI.GreaterThan{T}}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge" href="#MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge"><code>MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndicatorSOS1Bridge{T,S} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>IndicatorSOS1Bridge</code> implements the following reformulation:</p><ul><li><span>$z \implies {f(x) \in S}$</span> into <span>$f(x) + y \in S$</span>, <span>$SOS1(y, z)$</span></li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This bridge assumes that the solver supports <a href="../../../reference/standard_form/#MathOptInterface.SOS1"><code>MOI.SOS1{T}</code></a> constraints in which one of the variables (<span>$y$</span>) is continuous.</p></div></div><p><strong>Source node</strong></p><p><code>IndicatorSOS1Bridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorAffineFunction"><code>MOI.VectorAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Indicator"><code>MOI.Indicator{MOI.ACTIVATE_ON_ONE,S}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>IndicatorSOS1Bridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <code>S</code></li><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.SOS1"><code>MOI.SOS1{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.SemiToBinaryBridge" href="#MathOptInterface.Bridges.Constraint.SemiToBinaryBridge"><code>MathOptInterface.Bridges.Constraint.SemiToBinaryBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SemiToBinaryBridge{T,S} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>SemiToBinaryBridge</code> implements the following reformulations:</p><ul><li><span>$x \in \{0\} \cup [l, u]$</span> into<p class="math-container">\[\begin{aligned}
x \leq z u \\
x \geq z l \\
z \in \{0, 1\}
\end{aligned}\]</p></li><li><span>$x \in \{0\} \cup \{l, \ldots, u\}$</span> into<p class="math-container">\[\begin{aligned}
x \leq z u \\
x \geq z l \\
z \in \{0, 1\} \\
x \in \mathbb{Z}
\end{aligned}\]</p></li></ul><p><strong>Source node</strong></p><p><code>SemiToBinaryBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Semicontinuous"><code>MOI.Semicontinuous{T}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Semiinteger"><code>MOI.Semiinteger{T}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>SemiToBinaryBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.ZeroOne"><code>MOI.ZeroOne</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan{T}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan{T}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Integer"><code>MOI.Integer</code></a> (if <code>S</code> is <a href="../../../reference/standard_form/#MathOptInterface.Semiinteger"><code>MOI.Semiinteger{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.ZeroOneBridge" href="#MathOptInterface.Bridges.Constraint.ZeroOneBridge"><code>MathOptInterface.Bridges.Constraint.ZeroOneBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZeroOneBridge{T} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>ZeroOneBridge</code> implements the following reformulation:</p><ul><li><span>$x \in \{0, 1\}$</span> into <span>$x \in \mathbb{Z}$</span>, <span>$1x \in [0, 1]$</span>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>ZeroOneBridge</code> adds a linear constraint instead of adding variable bounds to avoid conflicting with bounds set by the user.</p></div></div><p><strong>Source node</strong></p><p><code>ZeroOneBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.ZeroOne"><code>MOI.ZeroOne</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>ZeroOneBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Integer"><code>MOI.Integer</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Interval"><code>MOI.Interval{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.AllDifferentToCountDistinctBridge" href="#MathOptInterface.Bridges.Constraint.AllDifferentToCountDistinctBridge"><code>MathOptInterface.Bridges.Constraint.AllDifferentToCountDistinctBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AllDifferentToCountDistinctBridge{T,F} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>AllDifferentToCountDistinctBridge</code> implements the following reformulations:</p><ul><li><span>$x \in \textsf{AllDifferent}(d)$</span> to <span>$(n, x) \in \textsf{CountDistinct}(1+d)$</span> and <span>$n = d$</span></li><li><span>$f(x) \in \textsf{AllDifferent}(d)$</span> to <span>$(d, f(x)) \in \textsf{CountDistinct}(1+d)$</span></li></ul><p><strong>Source node</strong></p><p><code>AllDifferentToCountDistinctBridge</code> supports:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.AllDifferent"><code>MOI.AllDifferent</code></a></li></ul><p>where <code>F</code> is <a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> or <a href="../../../reference/standard_form/#MathOptInterface.VectorAffineFunction"><code>MOI.VectorAffineFunction{T}</code></a>.</p><p><strong>Target nodes</strong></p><p><code>AllDifferentToCountDistinctBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.CountDistinct"><code>MOI.CountDistinct</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.ReifiedAllDifferentToCountDistinctBridge" href="#MathOptInterface.Bridges.Constraint.ReifiedAllDifferentToCountDistinctBridge"><code>MathOptInterface.Bridges.Constraint.ReifiedAllDifferentToCountDistinctBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReifiedAllDifferentToCountDistinctBridge{T,F} &lt;:
Bridges.Constraint.AbstractBridge</code></pre><p><code>ReifiedAllDifferentToCountDistinctBridge</code> implements the following reformulations:</p><ul><li><span>$r \iff x \in \textsf{AllDifferent}(d)$</span> to <span>$r \iff (n, x) \in \textsf{CountDistinct}(1+d)$</span> and <span>$n = d$</span></li><li><span>$r \iff f(x) \in \textsf{AllDifferent}(d)$</span> to <span>$r \iff (d, f(x)) \in \textsf{CountDistinct}(1+d)$</span></li></ul><p><strong>Source node</strong></p><p><code>ReifiedAllDifferentToCountDistinctBridge</code> supports:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Reified"><code>MOI.Reified{MOI.AllDifferent}</code></a></li></ul><p>where <code>F</code> is <a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> or <a href="../../../reference/standard_form/#MathOptInterface.VectorAffineFunction"><code>MOI.VectorAffineFunction{T}</code></a>.</p><p><strong>Target nodes</strong></p><p><code>ReifiedAllDifferentToCountDistinctBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Reified"><code>MOI.Reified{MOI.CountDistinct}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.BinPackingToMILPBridge" href="#MathOptInterface.Bridges.Constraint.BinPackingToMILPBridge"><code>MathOptInterface.Bridges.Constraint.BinPackingToMILPBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BinPackingToMILPBridge{T,F} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>BinPackingToMILPBridge</code> implements the following reformulation:</p><ul><li><span>$x \in BinPacking(c, w)$</span> into a mixed-integer linear program.</li></ul><p><strong>Reformulation</strong></p><p>The reformulation is non-trivial, and it depends on the finite domain of each variable <span>$x_i$</span>, which we as define <span>$S_i = \{l_i,\ldots,u_i\}$</span>.</p><p>First, we introduce new binary variables <span>$z_{ij}$</span>, which are <span>$1$</span> if variable <span>$x_i$</span> takes the value <span>$j$</span> in the optimal solution and <span>$0$</span> otherwise:</p><p class="math-container">\[\begin{aligned}
z_{ij} \in \{0, 1\}                              &amp; \;\; \forall i \in 1\ldots d, j \in S_i  \\
x_i - \sum\limits_{j\in S_i} j \cdot z_{ij} = 0 &amp; \;\; \forall i \in 1\ldots d              \\
\sum\limits_{j\in S_i} z_{ij} = 1                &amp; \;\; \forall i \in 1\ldots d              \\
\end{aligned}\]</p><p>Then, we add the capacity constraint for all possible bins <span>$j$</span>:</p><p class="math-container">\[\sum\limits_{i} w_i z_{ij} \le c \forall j \in \bigcup_{i=1,\ldots,d} S_i\]</p><p><strong>Source node</strong></p><p><code>BinPackingToMILPBridge</code> supports:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.BinPacking"><code>MOI.BinPacking{T}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>BinPackingToMILPBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.ZeroOne"><code>MOI.ZeroOne</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{T}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.CircuitToMILPBridge" href="#MathOptInterface.Bridges.Constraint.CircuitToMILPBridge"><code>MathOptInterface.Bridges.Constraint.CircuitToMILPBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CircuitToMILPBridge{T,F} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>CircuitToMILPBridge</code> implements the following reformulation:</p><ul><li><span>$x \in \textsf{Circuit}(d)$</span> to the Miller-Tucker-Zemlin formulation of the Traveling Salesperson Problem.</li></ul><p><strong>Source node</strong></p><p><code>CircuitToMILPBridge</code> supports:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Circuit"><code>MOI.Circuit</code></a></li></ul><p>where <code>F</code> is <a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> or <a href="../../../reference/standard_form/#MathOptInterface.VectorAffineFunction"><code>MOI.VectorAffineFunction{T}</code></a>.</p><p><strong>Target nodes</strong></p><p><code>CircuitToMILPBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.ZeroOne"><code>MOI.ZeroOne</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Integer"><code>MOI.Integer</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Interval"><code>MOI.Interval{T}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{T}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.CountAtLeastToCountBelongsBridge" href="#MathOptInterface.Bridges.Constraint.CountAtLeastToCountBelongsBridge"><code>MathOptInterface.Bridges.Constraint.CountAtLeastToCountBelongsBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CountAtLeastToCountBelongsBridge{T,F} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>CountAtLeastToCountBelongsBridge</code> implements the following reformulation:</p><ul><li><span>$x \in \textsf{CountAtLeast}(n, d, \mathcal{S})$</span> to <span>$(n_i, x_{d_i}) \in \textsf{CountBelongs}(1+d, \mathcal{S})$</span> and <span>$n_i \ge n$</span> for all <span>$i$</span>.</li></ul><p><strong>Source node</strong></p><p><code>CountAtLeastToCountBelongsBridge</code> supports:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.CountAtLeast"><code>MOI.CountAtLeast</code></a></li></ul><p>where <code>F</code> is <a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> or <a href="../../../reference/standard_form/#MathOptInterface.VectorAffineFunction"><code>MOI.VectorAffineFunction{T}</code></a>.</p><p><strong>Target nodes</strong></p><p><code>CountAtLeastToCountBelongsBridge</code> creates:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.CountBelongs"><code>MOI.CountBelongs</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.CountBelongsToMILPBridge" href="#MathOptInterface.Bridges.Constraint.CountBelongsToMILPBridge"><code>MathOptInterface.Bridges.Constraint.CountBelongsToMILPBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CountBelongsToMILPBridge{T,F} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>CountBelongsToMILPBridge</code> implements the following reformulation:</p><ul><li><span>$(n, x) \in \textsf{CountBelongs}(1+d, \mathcal{S})$</span> into a mixed-integer linear program.</li></ul><p><strong>Reformulation</strong></p><p>The reformulation is non-trivial, and it depends on the finite domain of each variable <span>$x_i$</span>, which we as define <span>$S_i = \{l_i,\ldots,u_i\}$</span>.</p><p>First, we introduce new binary variables <span>$z_{ij}$</span>, which are <span>$1$</span> if variable <span>$x_i$</span> takes the value <span>$j$</span> in the optimal solution and <span>$0$</span> otherwise:</p><p class="math-container">\[\begin{aligned}
z_{ij} \in \{0, 1\}                              &amp; \;\; \forall i \in 1\ldots d, j \in S_i  \\
x_i - \sum\limits_{j\in S_i} j \cdot z_{ij} = 0 &amp; \;\; \forall i \in 1\ldots d              \\
\sum\limits_{j\in S_i} z_{ij} = 1                &amp; \;\; \forall i \in 1\ldots d              \\
\end{aligned}\]</p><p>Finally, <span>$n$</span> is constrained to be the number of <span>$z_{ij}$</span> elements that are in <span>$\mathcal{S}$</span>:</p><p class="math-container">\[n - \sum\limits_{i\in 1\ldots d, j \in \mathcal{S}} z_{ij} = 0\]</p><p><strong>Source node</strong></p><p><code>CountBelongsToMILPBridge</code> supports:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.CountBelongs"><code>MOI.CountBelongs</code></a></li></ul><p>where <code>F</code> is <a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> or <a href="../../../reference/standard_form/#MathOptInterface.VectorAffineFunction"><code>MOI.VectorAffineFunction{T}</code></a>.</p><p><strong>Target nodes</strong></p><p><code>CountBelongsToMILPBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.ZeroOne"><code>MOI.ZeroOne</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.CountDistinctToMILPBridge" href="#MathOptInterface.Bridges.Constraint.CountDistinctToMILPBridge"><code>MathOptInterface.Bridges.Constraint.CountDistinctToMILPBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CountDistinctToMILPBridge{T,F} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>CountDistinctToMILPBridge</code> implements the following reformulation:</p><ul><li><span>$(n, x) \in \textsf{CountDistinct}(1+d)$</span> into a mixed-integer linear program.</li></ul><p><strong>Reformulation</strong></p><p>The reformulation is non-trivial, and it depends on the finite domain of each variable <span>$x_i$</span>, which we as define <span>$S_i = \{l_i,\ldots,u_i\}$</span>.</p><p>First, we introduce new binary variables <span>$z_{ij}$</span>, which are <span>$1$</span> if variable <span>$x_i$</span> takes the value <span>$j$</span> in the optimal solution and <span>$0$</span> otherwise:</p><p class="math-container">\[\begin{aligned}
z_{ij} \in \{0, 1\}                              &amp; \;\; \forall i \in 1\ldots d, j \in S_i  \\
x_i - \sum\limits_{j\in S_i} j \cdot z_{ij} = 0 &amp; \;\; \forall i \in 1\ldots d              \\
\sum\limits_{j\in S_i} z_{ij} = 1                &amp; \;\; \forall i \in 1\ldots d              \\
\end{aligned}\]</p><p>Then, we introduce new binary variables <span>$y_j$</span>, which are <span>$1$</span> if a variable takes the value <span>$j$</span> in the optimal solution and <span>$0$</span> otherwise.</p><p class="math-container">\[\begin{aligned}
y_{j} \in \{0, 1\}                        &amp; \;\; \forall j \in \bigcup_{i=1,\ldots,d} S_i \\
y_j \le \sum\limits_{i \in 1\ldots d: j \in S_i} z_{ij} \le M y_j &amp; \;\; \forall j \in \bigcup_{i=1,\ldots,d} S_i\\
\end{aligned}\]</p><p>Finally, <span>$n$</span> is constrained to be the number of <span>$y_j$</span> elements that are non-zero:</p><p class="math-container">\[n - \sum\limits_{j \in \bigcup_{i=1,\ldots,d} S_i} y_{j} = 0\]</p><p><strong>Source node</strong></p><p><code>CountDistinctToMILPBridge</code> supports:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.CountDistinct"><code>MOI.CountDistinct</code></a></li></ul><p>where <code>F</code> is <a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> or <a href="../../../reference/standard_form/#MathOptInterface.VectorAffineFunction"><code>MOI.VectorAffineFunction{T}</code></a>.</p><p><strong>Target nodes</strong></p><p><code>CountDistinctToMILPBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.ZeroOne"><code>MOI.ZeroOne</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{T}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.ReifiedCountDistinctToMILPBridge" href="#MathOptInterface.Bridges.Constraint.ReifiedCountDistinctToMILPBridge"><code>MathOptInterface.Bridges.Constraint.ReifiedCountDistinctToMILPBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReifiedCountDistinctToMILPBridge{T,F} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>ReifiedCountDistinctToMILPBridge</code> implements the following reformulation:</p><ul><li><span>$r \iff (n, x) \in \textsf{CountDistinct}(1+d)$</span> into a mixed-integer linear program.</li></ul><p><strong>Reformulation</strong></p><p>The reformulation is non-trivial, and it depends on the finite domain of each variable <span>$x_i$</span>, which we as define <span>$S_i = \{l_i,\ldots,u_i\}$</span>.</p><p>First, we introduce new binary variables <span>$z_{ij}$</span>, which are <span>$1$</span> if variable <span>$x_i$</span> takes the value <span>$j$</span> in the optimal solution and <span>$0$</span> otherwise:</p><p class="math-container">\[\begin{aligned}
z_{ij} \in \{0, 1\}                              &amp; \;\; \forall i \in 1\ldots d, j \in S_i  \\
x_i - \sum\limits_{j\in S_i} j \cdot z_{ij} = 0 &amp; \;\; \forall i \in 1\ldots d              \\
\sum\limits_{j\in S_i} z_{ij} = 1                &amp; \;\; \forall i \in 1\ldots d              \\
\end{aligned}\]</p><p>Then, we introduce new binary variables <span>$y_j$</span>, which are <span>$1$</span> if a variable takes the value <span>$j$</span> in the optimal solution and <span>$0$</span> otherwise.</p><p class="math-container">\[\begin{aligned}
y_{j} \in \{0, 1\}                        &amp; \;\; \forall j \in \bigcup_{i=1,\ldots,d} S_i \\
y_j \le \sum\limits_{i \in 1\ldots d: j \in S_i} z_{ij} \le M y_j &amp; \;\; \forall j \in \bigcup_{i=1,\ldots,d} S_i\\
\end{aligned}\]</p><p>Finally, <span>$n$</span> is constrained to be the number of <span>$y_j$</span> elements that are non-zero, with some slack:</p><p class="math-container">\[n - \sum\limits_{j \in \bigcup_{i=1,\ldots,d} S_i} y_{j} = \delta^+ - \delta^-\]</p><p>And then the slack is constrained to respect the reif variable <span>$r$</span>:</p><p class="math-container">\[\begin{aligned}
d_1 \le \delta^+ \le M d_1 \\
d_2 \le \delta^- \le M d_s \\
d_1 + d_2 + r = 1             \\
d_1, d_2 \in \{0, 1\}
\end{aligned}\]</p><p><strong>Source node</strong></p><p><code>ReifiedCountDistinctToMILPBridge</code> supports:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Reified"><code>MOI.Reified{MOI.CountDistinct}</code></a></li></ul><p>where <code>F</code> is <a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> or <a href="../../../reference/standard_form/#MathOptInterface.VectorAffineFunction"><code>MOI.VectorAffineFunction{T}</code></a>.</p><p><strong>Target nodes</strong></p><p><code>ReifiedCountDistinctToMILPBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.ZeroOne"><code>MOI.ZeroOne</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{T}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.CountGreaterThanToMILPBridge" href="#MathOptInterface.Bridges.Constraint.CountGreaterThanToMILPBridge"><code>MathOptInterface.Bridges.Constraint.CountGreaterThanToMILPBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CountGreaterThanToMILPBridge{T,F} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>CountGreaterThanToMILPBridge</code> implements the following reformulation:</p><ul><li><span>$(c, y, x) \in CountGreaterThan()$</span> into a mixed-integer linear program.</li></ul><p><strong>Source node</strong></p><p><code>CountGreaterThanToMILPBridge</code> supports:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.CountGreaterThan"><code>MOI.CountGreaterThan</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>CountGreaterThanToMILPBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.ZeroOne"><code>MOI.ZeroOne</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{T}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan{T}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Constraint.TableToMILPBridge" href="#MathOptInterface.Bridges.Constraint.TableToMILPBridge"><code>MathOptInterface.Bridges.Constraint.TableToMILPBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TableToMILPBridge{T,F} &lt;: Bridges.Constraint.AbstractBridge</code></pre><p><code>TableToMILPBridge</code> implements the following reformulation:</p><ul><li><span>$x \in Table(t)$</span> into<p class="math-container">\[\begin{aligned}
z_{j} \in \{0, 1\}                     &amp; \quad \forall i, j \\
\sum\limits_{j=1}^n z_{j} = 1                           \\
\sum\limits_{j=1}^n t_{ij} z_{j} = x_i &amp; \quad \forall i
\end{aligned}\]</p></li></ul><p><strong>Source node</strong></p><p><code>TableToMILPBridge</code> supports:</p><ul><li><code>F</code> in <a href="../../../reference/standard_form/#MathOptInterface.Table"><code>MOI.Table{T}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>TableToMILPBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.ZeroOne"><code>MOI.ZeroOne</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{T}</code></a></li></ul></div></section></article><h2 id="objective_bridges_ref"><a class="docs-heading-anchor" href="#objective_bridges_ref">Objective bridges</a><a id="objective_bridges_ref-1"></a><a class="docs-heading-anchor-permalink" href="#objective_bridges_ref" title="Permalink"></a></h2><p>These bridges are subtypes of <a href="../reference/#MathOptInterface.Bridges.Objective.AbstractBridge"><code>Bridges.Objective.AbstractBridge</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Objective.FunctionizeBridge" href="#MathOptInterface.Bridges.Objective.FunctionizeBridge"><code>MathOptInterface.Bridges.Objective.FunctionizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FunctionizeBridge{T}</code></pre><p><code>FunctionizeBridge</code> implements the following reformulations:</p><ul><li><span>$\min \{x\}$</span> into <span>$\min\{1x + 0\}$</span></li><li><span>$\max \{x\}$</span> into <span>$\max\{1x + 0\}$</span></li></ul><p>where <code>T</code> is the coefficient type of <code>1</code> and <code>0</code>.</p><p><strong>Source node</strong></p><p><code>FunctionizeBridge</code> supports:</p><ul><li><a href="../../../reference/models/#MathOptInterface.ObjectiveFunction"><code>MOI.ObjectiveFunction{MOI.VariableIndex}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>FunctionizeBridge</code> creates:</p><ul><li>One objective node: <a href="../../../reference/models/#MathOptInterface.ObjectiveFunction"><code>MOI.ObjectiveFunction{MOI.ScalarAffineFunction{T}}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Objective.QuadratizeBridge" href="#MathOptInterface.Bridges.Objective.QuadratizeBridge"><code>MathOptInterface.Bridges.Objective.QuadratizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuadratizeBridge{T}</code></pre><p><code>QuadratizeBridge</code> implements the following reformulations:</p><ul><li><span>$\min \{a^\top x + b\}$</span> into <span>$\min\{x^\top \mathbf{0} x + a^\top x + b\}$</span></li><li><span>$\max \{a^\top x + b\}$</span> into <span>$\max\{x^\top \mathbf{0} x + a^\top x + b\}$</span></li></ul><p>where <code>T</code> is the coefficient type of <code>0</code>.</p><p><strong>Source node</strong></p><p><code>QuadratizeBridge</code> supports:</p><ul><li><a href="../../../reference/models/#MathOptInterface.ObjectiveFunction"><code>MOI.ObjectiveFunction{MOI.ScalarAffineFunction{T}}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>QuadratizeBridge</code> creates:</p><ul><li>One objective node: <a href="../../../reference/models/#MathOptInterface.ObjectiveFunction"><code>MOI.ObjectiveFunction{MOI.ScalarQuadraticFunction{T}}</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Objective.SlackBridge" href="#MathOptInterface.Bridges.Objective.SlackBridge"><code>MathOptInterface.Bridges.Objective.SlackBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SlackBridge{T,F,G}</code></pre><p><code>SlackBridge</code> implements the following reformulations:</p><ul><li><span>$\min\{f(x)\}$</span> into <span>$\min\{y\;|\; f(x) - y \le 0\}$</span></li><li><span>$\max\{f(x)\}$</span> into <span>$\max\{y\;|\; f(x) - y \ge 0\}$</span></li></ul><p>where <code>F</code> is the type of <code>f(x) - y</code>, <code>G</code> is the type of <code>f(x)</code>, and <code>T</code> is the coefficient type of <code>f(x)</code>.</p><p><strong>Source node</strong></p><p><code>SlackBridge</code> supports:</p><ul><li><a href="../../../reference/models/#MathOptInterface.ObjectiveFunction"><code>MOI.ObjectiveFunction{G}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>SlackBridge</code> creates:</p><ul><li>One variable node: <a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Reals"><code>MOI.Reals</code></a></li><li>One objective node: <a href="../../../reference/models/#MathOptInterface.ObjectiveFunction"><code>MOI.ObjectiveFunction{MOI.VariableIndex}</code></a></li><li>One constraint node, that depends on the <a href="../../../reference/models/#MathOptInterface.ObjectiveSense"><code>MOI.ObjectiveSense</code></a>:<ul><li><code>F</code>-in-<a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan</code></a> if <code>MIN_SENSE</code></li><li><code>F</code>-in-<a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan</code></a> if <code>MAX_SENSE</code></li></ul></li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When using this bridge, changing the optimization sense is not supported. Set the sense to <code>MOI.FEASIBILITY_SENSE</code> first to delete the bridge, then set <a href="../../../reference/models/#MathOptInterface.ObjectiveSense"><code>MOI.ObjectiveSense</code></a> and re-add the objective.</p></div></div></div></section></article><h2 id="variable_bridges_ref"><a class="docs-heading-anchor" href="#variable_bridges_ref">Variable bridges</a><a id="variable_bridges_ref-1"></a><a class="docs-heading-anchor-permalink" href="#variable_bridges_ref" title="Permalink"></a></h2><p>These bridges are subtypes of <a href="../reference/#MathOptInterface.Bridges.Variable.AbstractBridge"><code>Bridges.Variable.AbstractBridge</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.FreeBridge" href="#MathOptInterface.Bridges.Variable.FreeBridge"><code>MathOptInterface.Bridges.Variable.FreeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FreeBridge{T} &lt;: Bridges.Variable.AbstractBridge</code></pre><p><code>FreeBridge</code> implements the following reformulation:</p><ul><li><span>$x \in \mathbb{R}$</span> into <span>$y, z \ge 0$</span> with the substitution rule <span>$x = y - z$</span>,</li></ul><p>where <code>T</code> is the coefficient type of <code>y - z</code>.</p><p><strong>Source node</strong></p><p><code>FreeBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Reals"><code>MOI.Reals</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>FreeBridge</code> creates:</p><ul><li>One variable node: <a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.NonposToNonnegBridge" href="#MathOptInterface.Bridges.Variable.NonposToNonnegBridge"><code>MathOptInterface.Bridges.Variable.NonposToNonnegBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonposToNonnegBridge{T} &lt;: Bridges.Variable.AbstractBridge</code></pre><p><code>NonposToNonnegBridge</code> implements the following reformulation:</p><ul><li><span>$x \in \mathbb{R}_-$</span> into <span>$y \in \mathbb{R}_+$</span> with the substitution rule <span>$x = -y$</span>,</li></ul><p>where <code>T</code> is the coefficient type of <code>-y</code>.</p><p><strong>Source node</strong></p><p><code>NonposToNonnegBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Nonpositives"><code>MOI.Nonpositives</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>NonposToNonnegBridge</code> creates:</p><ul><li>One variable node: <a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a>,</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.RSOCtoPSDBridge" href="#MathOptInterface.Bridges.Variable.RSOCtoPSDBridge"><code>MathOptInterface.Bridges.Variable.RSOCtoPSDBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RSOCtoPSDBridge{T} &lt;: Bridges.Variable.AbstractBridge</code></pre><p><code>RSOCtoPSDBridge</code> implements the following reformulation:</p><ul><li><span>$||x||_2^2 \le 2tu$</span> where <span>$t, u \ge 0$</span> into <span>$Y \succeq 0$</span>, with the substitution rule: <span>$Y = \left[\begin{array}{c c}t &amp; x^\top \\ x &amp; 2u \mathbf{I}\end{array}\right].$</span></li></ul><p>Additional bounds are added to ensure the off-diagonals of the <span>$2uI$</span> submatrix are <code>0</code>, and linear constraints are added to ennsure the diagonal of <span>$2uI$</span> takes the same values.</p><p>As a special case, if <span>$|x|| = 0$</span>, then <code>RSOCtoPSDBridge</code> reformulates into <span>$(t, u) \in \mathbb{R}_+$</span>.</p><p><strong>Source node</strong></p><p><code>RSOCtoPSDBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.RotatedSecondOrderCone"><code>MOI.RotatedSecondOrderCone</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>RSOCtoPSDBridge</code> creates:</p><ul><li>One variable node that depends on the input dimension:<ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a> if dimension is <code>1</code> or <code>2</code></li><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in</li></ul><a href="../../../reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MOI.PositiveSemidefiniteConeTriangle</code></a> otherwise</li><li>The constraint node <a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo</code></a></li><li>The constrant node <a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.RSOCtoSOCBridge" href="#MathOptInterface.Bridges.Variable.RSOCtoSOCBridge"><code>MathOptInterface.Bridges.Variable.RSOCtoSOCBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RSOCtoSOCBridge{T} &lt;: Bridges.Variable.AbstractBridge</code></pre><p><code>RSOCtoSOCBridge</code> implements the following reformulation:</p><ul><li><span>$||x||_2^2 \le 2tu$</span> into <span>$||v||_2 \le w$</span>, with the substitution rules <span>$t = \frac{w}{\sqrt 2} + \frac{v_1}{\sqrt 2}$</span>, <span>$u = \frac{w}{\sqrt 2} - \frac{v_1}{\sqrt 2}$</span>, and <span>$x = (v_2,\ldots,v_N)$</span>.</li></ul><p><strong>Source node</strong></p><p><code>RSOCtoSOCBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.RotatedSecondOrderCone"><code>MOI.RotatedSecondOrderCone</code></a></li></ul><p><strong>Target node</strong></p><p><code>RSOCtoSOCBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.SecondOrderCone"><code>MOI.SecondOrderCone</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.SOCtoRSOCBridge" href="#MathOptInterface.Bridges.Variable.SOCtoRSOCBridge"><code>MathOptInterface.Bridges.Variable.SOCtoRSOCBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SOCtoRSOCBridge{T} &lt;: Bridges.Variable.AbstractBridge</code></pre><p><code>SOCtoRSOCBridge</code> implements the following reformulation:</p><ul><li><span>$||x||_2 \le t$</span> into <span>$2uv \ge ||w||_2^2$</span>, with the substitution rules <span>$t = \frac{u}{\sqrt 2} + \frac{v}{\sqrt 2}$</span>, <span>$x = (\frac{u}{\sqrt 2} - \frac{v}{\sqrt 2}, w)$</span>.</li></ul><p><strong>Assumptions</strong></p><ul><li><code>SOCtoRSOCBridge</code> assumes that <span>$|x| \ge 1$</span>.</li></ul><p><strong>Source node</strong></p><p><code>SOCtoRSOCBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.SecondOrderCone"><code>MOI.SecondOrderCone</code></a></li></ul><p><strong>Target node</strong></p><p><code>SOCtoRSOCBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.RotatedSecondOrderCone"><code>MOI.RotatedSecondOrderCone</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.VectorizeBridge" href="#MathOptInterface.Bridges.Variable.VectorizeBridge"><code>MathOptInterface.Bridges.Variable.VectorizeBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorizeBridge{T,S} &lt;: Bridges.Variable.AbstractBridge</code></pre><p><code>VectorizeBridge</code> implements the following reformulations:</p><ul><li><span>$x \ge a$</span> into <span>$[y] \in \mathbb{R}_+$</span> with the substitution rule <span>$x = a + y$</span></li><li><span>$x \le a$</span> into <span>$[y] \in \mathbb{R}_-$</span> with the substitution rule <span>$x = a + y$</span></li><li><span>$x == a$</span> into <span>$[y] \in \{0\}$</span> with the substitution rule <span>$x = a + y$</span></li></ul><p>where <code>T</code> is the coefficient type of <code>a + y</code>.</p><p><strong>Source node</strong></p><p><code>VectorizeBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MOI.GreaterThan{T}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MOI.LessThan{T}</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{T}</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>VectorizeBridge</code> creates:</p><ul><li>One variable node: <a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <code>S</code>, where <code>S</code> is one of <a href="../../../reference/standard_form/#MathOptInterface.Nonnegatives"><code>MOI.Nonnegatives</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.Nonpositives"><code>MOI.Nonpositives</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.Zeros"><code>MOI.Zeros</code></a> depending on the type of <span>$S$</span>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.ZerosBridge" href="#MathOptInterface.Bridges.Variable.ZerosBridge"><code>MathOptInterface.Bridges.Variable.ZerosBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZerosBridge{T} &lt;: Bridges.Variable.AbstractBridge</code></pre><p><code>ZerosBridge</code> implements the following reformulation:</p><ul><li><span>$x \in \{0\}$</span> into the substitution rule <span>$x = 0$</span>,</li></ul><p>where <code>T</code> is the coefficient type of <code>0</code>.</p><p><strong>Source node</strong></p><p><code>ZerosBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.Zeros"><code>MOI.Zeros</code></a></li></ul><p><strong>Target nodes</strong></p><p><code>ZerosBridge</code> does not create target nodes. It replaces all instances of <code>x</code> with <code>0</code> via substitution. This means that no variables are created in the underlying model.</p><p><strong>Caveats</strong></p><p>The bridged variables are similar to parameters with zero values. Parameters with non-zero values can be created with constrained variables in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo</code></a> by combining a <a href="#MathOptInterface.Bridges.Variable.VectorizeBridge"><code>VectorizeBridge</code></a> and this bridge.</p><p>However, functions modified by <code>ZerosBridge</code> cannot be unbridged. That is, for a given function, we cannot determine if the bridged variables were used.</p><p>A related implication is that this bridge does not support <a href="../../../reference/constraints/#MathOptInterface.ConstraintDual"><code>MOI.ConstraintDual</code></a>. However, if a <a href="../../Utilities/reference/#MathOptInterface.Utilities.CachingOptimizer"><code>MOI.Utilities.CachingOptimizer</code></a> is used, the dual can be determined by the bridged optimizer using <a href="../../Utilities/reference/#MathOptInterface.Utilities.get_fallback"><code>MOI.Utilities.get_fallback</code></a> because the caching optimizer records the unbridged function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Bridges.Variable.HermitianToSymmetricPSDBridge" href="#MathOptInterface.Bridges.Variable.HermitianToSymmetricPSDBridge"><code>MathOptInterface.Bridges.Variable.HermitianToSymmetricPSDBridge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HermitianToSymmetricPSDBridge{T} &lt;: Bridges.Variable.AbstractBridge</code></pre><p><code>HermitianToSymmetricPSDBridge</code> implements the following reformulation:</p><ul><li>Hermitian positive semidefinite <code>n x n</code> complex matrix to a symmetric positive semidefinite <code>2n x 2n</code> real matrix satisfying equality constraints described below.</li></ul><p><strong>Source node</strong></p><p><code>HermitianToSymmetricPSDBridge</code> supports:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.HermitianPositiveSemidefiniteConeTriangle"><code>MOI.HermitianPositiveSemidefiniteConeTriangle</code></a></li></ul><p><strong>Target node</strong></p><p><code>HermitianToSymmetricPSDBridge</code> creates:</p><ul><li><a href="../../../reference/standard_form/#MathOptInterface.VectorOfVariables"><code>MOI.VectorOfVariables</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MOI.PositiveSemidefiniteConeTriangle</code></a></li><li><a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction{T}</code></a> in <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MOI.EqualTo{T}</code></a></li></ul><p><strong>Reformulation</strong></p><p>The reformulation is best described by example.</p><p>The Hermitian matrix:</p><p class="math-container">\[\begin{bmatrix}
  x_{11}            &amp; x_{12} + y_{12}im &amp; x_{13} + y_{13}im\\
  x_{12} - y_{12}im &amp; x_{22}            &amp; x_{23} + y_{23}im\\
  x_{13} - y_{13}im &amp; x_{23} - y_{23}im &amp; x_{33}
\end{bmatrix}\]</p><p>is positive semidefinite if and only if the symmetric matrix:</p><p class="math-container">\[\begin{bmatrix}
    x_{11} &amp; x_{12} &amp; x_{13} &amp; 0       &amp; y_{12}  &amp; y_{13} \\
           &amp; x_{22} &amp; x_{23} &amp; -y_{12} &amp; 0       &amp; y_{23} \\
           &amp;        &amp; x_{33} &amp; -y_{13} &amp; -y_{23} &amp; 0      \\
           &amp;        &amp;        &amp; x_{11}  &amp; x_{12}  &amp; x_{13} \\
           &amp;        &amp;        &amp;         &amp; x_{22}  &amp; x_{23} \\
           &amp;        &amp;        &amp;         &amp;         &amp; x_{33}
\end{bmatrix}\]</p><p>is positive semidefinite.</p><p>The bridge achieves this reformulation by adding a new set of variables in <code>MOI.PositiveSemidefiniteConeTriangle(6)</code>, and then adding three groups of equality constraints to:</p><ul><li>constrain the two <code>x</code> blocks to be equal</li><li>force the diagonal of the <code>y</code> blocks to be <code>0</code></li><li>force the lower triangular of the <code>y</code> block to be the negative of the upper triangle.</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview/">« Overview</a><a class="docs-footer-nextpage" href="../reference/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Sunday 1 January 2023 21:55">Sunday 1 January 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
