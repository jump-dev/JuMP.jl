<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Callbacks · JuMP</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img alt="JuMP logo" src="../assets/logo.png"/></a><div class="docs-package-name"><span class="docs-autofit">JuMP</span></div><form action="../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><input checked="" class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../installation/">Installation Guide</a></li><li><a class="tocitem" href="../quickstart/">Quick Start Guide</a></li><li><a class="tocitem" href="../variables/">Variables</a></li><li><a class="tocitem" href="../expressions/">Expressions</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../containers/">Containers</a></li><li><a class="tocitem" href="../solvers/">Interacting with solvers</a></li><li><a class="tocitem" href="../solutions/">Querying Solutions</a></li><li><a class="tocitem" href="../nlp/">Nonlinear Modeling</a></li><li class="is-active"><a class="tocitem" href="">Callbacks</a><ul class="internal"><li><a class="tocitem" href="#Available-solvers"><span>Available solvers</span></a></li><li><a class="tocitem" href="#Things-you-can-and-cannot-do-during-callbacks"><span>Things you can and cannot do during callbacks</span></a></li><li><a class="tocitem" href="#Lazy-constraints"><span>Lazy constraints</span></a></li><li><a class="tocitem" href="#User-cuts"><span>User cuts</span></a></li><li><a class="tocitem" href="#Heuristic-solutions"><span>Heuristic solutions</span></a></li></ul></li><li><a class="tocitem" href="../extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../reference/callbacks/">Callback API</a></li><li><a class="tocitem" href="../reference/constraints/">Constraint API</a></li><li><a class="tocitem" href="../reference/containers/">Containers API</a></li><li><a class="tocitem" href="../reference/expressions/">Expression API</a></li><li><a class="tocitem" href="../reference/models/">Model API</a></li><li><a class="tocitem" href="../reference/moi/">MathOptInterface API</a></li><li><a class="tocitem" href="../reference/nonlinear/">Nonlinear API</a></li><li><a class="tocitem" href="../reference/objectives/">Objective API</a></li><li><a class="tocitem" href="../reference/solutions/">Solution API</a></li><li><a class="tocitem" href="../reference/variables/">Variable API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/basic/">A basic example</a></li><li><a class="tocitem" href="../examples/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../examples/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../examples/clnlbeam/">The clnlbeam problem</a></li><li><a class="tocitem" href="../examples/cluster/">K-means clustering via SDP</a></li><li><a class="tocitem" href="../examples/corr_sdp/">The correlation problem</a></li><li><a class="tocitem" href="../examples/cutting_stock_column_generation/">Cutting stock</a></li><li><a class="tocitem" href="../examples/diet/">The diet problem</a></li><li><a class="tocitem" href="../examples/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../examples/knapsack/">The knapsack problem</a></li><li><a class="tocitem" href="../examples/max_cut_sdp/">SDP relaxations: max-cut</a></li><li><a class="tocitem" href="../examples/min_distortion/">The minimum distortion problem</a></li><li><a class="tocitem" href="../examples/min_ellipse/">Minimum ellipses</a></li><li><a class="tocitem" href="../examples/mle/">Maximum likelihood estimation</a></li><li><a class="tocitem" href="../examples/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../examples/nlp_tricks/">Nonlinear tips and tricks</a></li><li><a class="tocitem" href="../examples/prod/">The workforce scheduling problem</a></li><li><a class="tocitem" href="../examples/qcp/">Quadratically constrained programs</a></li><li><a class="tocitem" href="../examples/robust_uncertainty/">Robust uncertainty sets</a></li><li><a class="tocitem" href="../examples/rosenbrock/">The Rosenbrock function</a></li><li><a class="tocitem" href="../examples/steelT3/">The SteelT3 problem</a></li><li><a class="tocitem" href="../examples/sudoku/">Solving Sudokus with MIP</a></li><li><a class="tocitem" href="../examples/transp/">The transportation problem</a></li><li><a class="tocitem" href="../examples/urban_plan/">The urban planning problem</a></li></ul></li><li><a class="tocitem" href="../style/">Style Guide</a></li><li><a class="tocitem" href="../roadmap/">Development Roadmap</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href="">Callbacks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Callbacks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/callbacks.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="callbacks_manual"><a class="docs-heading-anchor" href="#callbacks_manual">Callbacks</a><a id="callbacks_manual-1"></a><a class="docs-heading-anchor-permalink" href="#callbacks_manual" title="Permalink"></a></h1><p>Many mixed-integer (linear, conic, and nonlinear) programming solvers offer the ability to modify the solve process. Examples include changing branching decisions in branch-and-bound, adding custom cutting planes, providing custom heuristics to find feasible solutions, or implementing on-demand separators to add new constraints only when they are violated by the current solution (also known as lazy constraints).</p><p>While historically this functionality has been limited to solver-specific interfaces, JuMP provides solver-independent support for three types of callbacks:</p><ol><li>lazy constraints</li><li>user-cuts</li><li>heuristic solutions</li></ol><h2 id="Available-solvers"><a class="docs-heading-anchor" href="#Available-solvers">Available solvers</a><a id="Available-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Available-solvers" title="Permalink"></a></h2><p>Callback support is limited to a few solvers. This includes <a href="https://github.com/JuliaOpt/CPLEX.jl">CPLEX</a>, <a href="https://github.com/JuliaOpt/GLPK.jl">GLPK</a>, and <a href="https://github.com/JuliaOpt/Gurobi.jl">Gurobi</a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>While JuMP provides a solver-independent way of accessing callbacks, you should not assume that you will see identical behavior when running the same code on different solvers. For example, some solvers may ignore user-cuts for various reasons, while other solvers may add every user-cut. Read the underlying solver's callback documentation to understand details specific to each solver.</p></div></div><h2 id="Things-you-can-and-cannot-do-during-callbacks"><a class="docs-heading-anchor" href="#Things-you-can-and-cannot-do-during-callbacks">Things you can and cannot do during callbacks</a><a id="Things-you-can-and-cannot-do-during-callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Things-you-can-and-cannot-do-during-callbacks" title="Permalink"></a></h2><p>There is a very limited range of things you can do during a callback. Only use the functions and macros explicitly stated in this page of the documentation, or in the <a href="/examples/callbacks">Callbacks example</a>.</p><p>Using any other part of the JuMP API (e.g., adding a constraint with <a href="../reference/constraints/#JuMP.@constraint"><code>@constraint</code></a> or modifying a variable bound with <a href="../reference/variables/#JuMP.set_lower_bound"><code>set_lower_bound</code></a>) is undefined behavior, and your solver may throw an error, return an incorrect solution, or result in a segfault that aborts Julia.</p><p>In each of the three solver-independent callbacks, there are two things you may query:</p><ul><li><a href="../reference/callbacks/#JuMP.callback_node_status"><code>callback_node_status</code></a> returns an <a href="../reference/moi/#MathOptInterface.CallbackNodeStatusCode"><code>MOI.CallbackNodeStatusCode</code></a> enum indicating if the current primal solution is integer feasible.</li><li><a href="../reference/callbacks/#JuMP.callback_value"><code>callback_value</code></a> returns the current primal solution of a variable.</li></ul><p>If you need to query any other information, use a solver-dependent callback instead. Each solver supporting a solver-dependent callback has information on how to use it in the README of their Github repository.</p><p>If you want to modify the problem in a callback, you <em>must</em> use a lazy constraint.</p><h2 id="Lazy-constraints"><a class="docs-heading-anchor" href="#Lazy-constraints">Lazy constraints</a><a id="Lazy-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Lazy-constraints" title="Permalink"></a></h2><p>Lazy constraints are useful when the full set of constraints is too large to explicitly include in the initial formulation. When a MIP solver reaches a new solution, for example with a heuristic or by solving a problem at a node in the branch-and-bound tree, it will give the user the chance to provide constraint(s) that would make the current solution infeasible. For some more information about lazy constraints, see this <a href="https://orinanobworld.blogspot.com/2012/08/user-cuts-versus-lazy-constraints.html">blog post by Paul Rubin</a>.</p><p>A lazy constraint callback can be set using the following syntax:</p><pre><code class="language-julia">model = Model(GLPK.Optimizer)
@variable(model, x &lt;= 10, Int)
@objective(model, Max, x)
function my_callback_function(cb_data)
    status = callback_node_status(cb_data, model)
    if status == MOI.CALLBACK_NODE_STATUS_FRACTIONAL
        # `callback_value(cb_data, x)` is not integer (to some tolerance).
        # If, for example, your lazy constraint generator requires an
        # integer-feasible primal solution, you can add a `return` here.
        return
    elseif status == MOI.CALLBACK_NODE_STATUS_INTEGER
        # `callback_value(cb_data, x)` is integer (to some tolerance).
    else
        @assert status == MOI.CALLBACK_NODE_STATUS_UNKNOWN
        # `callback_value(cb_data, x)` might be fractional or integer.
    end
    x_val = callback_value(cb_data, x)
    if x_val &gt; 2 + 1e-6
        con = @build_constraint(x &lt;= 2)
        MOI.submit(model, MOI.LazyConstraint(cb_data), con)
    end
end
MOI.set(model, MOI.LazyConstraintCallback(), my_callback_function)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The lazy constraint callback <em>may</em> be called at fractional or integer nodes in the branch-and-bound tree. There is no guarantee that the callback is called at <em>every</em> primal solution.</p></div></div><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>Only add a lazy constraint if your primal solution violates the constraint. Adding the lazy constraint irrespective of feasibility may result in the solver returning an incorrect solution, or lead to a large number of constraints being added, slowing down the solution process.</p><pre><code class="language-julia">model = Model(GLPK.Optimizer)
@variable(model, x &lt;= 10, Int)
@objective(model, Max, x)
function bad_callback_function(cb_data)
    # Don't do this!
    con = @build_constraint(x &lt;= 2)
    MOI.submit(model, MOI.LazyConstraint(cb_data), con)
end
function good_callback_function(cb_data)
    if callback_value(x) &gt; 2
        con = @build_constraint(x &lt;= 2)
        MOI.submit(model, MOI.LazyConstraint(cb_data), con)
    end
end
MOI.set(model, MOI.LazyConstraintCallback(), good_callback_function)</code></pre></div></div><h2 id="User-cuts"><a class="docs-heading-anchor" href="#User-cuts">User cuts</a><a id="User-cuts-1"></a><a class="docs-heading-anchor-permalink" href="#User-cuts" title="Permalink"></a></h2><p>User cuts, or simply cuts, provide a way for the user to tighten the LP relaxation using problem-specific knowledge that the solver cannot or is unable to infer from the model. Just like with lazy constraints, when a MIP solver reaches a new node in the branch-and-bound tree, it will give the user the chance to provide cuts to make the current relaxed (fractional) solution infeasible in the hopes of obtaining an integer solution. For more details about the difference between user cuts and lazy constraints see the aforementioned <a href="https://orinanobworld.blogspot.com/2012/08/user-cuts-versus-lazy-constraints.html">blog post</a>.</p><p>A user-cut callback can be set using the following syntax:</p><pre><code class="language-julia">model = Model(GLPK.Optimizer)
@variable(model, x &lt;= 10.5, Int)
@objective(model, Max, x)
function my_callback_function(cb_data)
    x_val = callback_value(cb_data, x)
    con = @build_constraint(x &lt;= floor(x_val))
    MOI.submit(model, MOI.UserCut(cb_data), con)
end
MOI.set(model, MOI.UserCutCallback(), my_callback_function)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Your user cuts should not change the set of integer feasible solutions. Equivalently, your cuts can only remove fractional solutions. If you add a cut that removes an integer solution, the solver may return an incorrect solution.</p></div></div><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The user-cut callback <em>may</em> be called at fractional nodes in the branch-and-bound tree. There is no guarantee that the callback is called at <em>every</em> fractional primal solution.</p></div></div><h2 id="Heuristic-solutions"><a class="docs-heading-anchor" href="#Heuristic-solutions">Heuristic solutions</a><a id="Heuristic-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Heuristic-solutions" title="Permalink"></a></h2><p>Integer programming solvers frequently include heuristics that run at the nodes of the branch-and-bound tree. They aim to find integer solutions quicker than plain branch-and-bound would to tighten the bound, allowing us to fathom nodes quicker and to tighten the integrality gap.</p><p>Some heuristics take integer solutions and explore their "local neighborhood" (e.g., flipping binary variables, fix some variables and solve a smaller MILP) and others take fractional solutions and attempt to round them in an intelligent way.</p><p>You may want to add a heuristic of your own if you have some special insight into the problem structure that the solver is not aware of, e.g. you can consistently take fractional solutions and intelligently guess integer solutions from them.</p><p>A heuristic solution callback can be set using the following syntax:</p><pre><code class="language-julia">model = Model(GLPK.Optimizer)
@variable(model, x &lt;= 10.5, Int)
@objective(model, Max, x)
function my_callback_function(cb_data)
    x_val = callback_value(cb_data, x)
    status = MOI.submit(
        model, MOI.HeuristicSolution(cb_data), [x], [floor(Int, x_val)]
    )
    println("I submitted a heuristic solution, and the status was: ", status)
end
MOI.set(model, MOI.HeuristicCallback(), my_callback_function)</code></pre><p>The third argument to <code>submit</code> should be a vector of JuMP variables, and the fourth argument should be a vector of values corresponding to each variable.</p><p><code>MOI.submit</code> returns an enum that depends on whether the solver accepted the solution. The possible return codes are:</p><ul><li><code>MOI.HEURISTIC_SOLUTION_ACCEPTED</code></li><li><code>MOI.HEURISTIC_SOLUTION_REJECTED</code></li><li><code>MOI.HEURISTIC_SOLUTION_UNKNOWN</code></li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Some solvers may accept partial solutions. Others require a feasible integer solution for every variable. If in doubt, provide a complete solution.</p></div></div><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The heuristic solution callback <em>may</em> be called at fractional nodes in the branch-and-bound tree. There is no guarantee that the callback is called at <em>every</em> fractional primal solution.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nlp/">« Nonlinear Modeling</a><a class="docs-footer-nextpage" href="../extensions/">Extensions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 28 January 2021 23:52">Thursday 28 January 2021</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>