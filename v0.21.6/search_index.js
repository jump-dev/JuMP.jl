var documenterSearchIndex = {"docs":
[{"location":"examples/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/multi.jl\"","category":"page"},{"location":"examples/multi/#The-multi-commodity-flow-problem","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"","category":"section"},{"location":"examples/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"JuMP implementation of the multicommodity transportation model AMPL: A Modeling Language for Mathematical Programming, 2nd ed by Robert Fourer, David Gay, and Brian W. Kernighan 4-1.","category":"page"},{"location":"examples/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"Originally contributed by Louis Luangkesorn, February 26, 2015.","category":"page"},{"location":"examples/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_multi(; verbose = true)\n    orig = [\"GARY\", \"CLEV\", \"PITT\"]\n    dest = [\"FRA\", \"DET\", \"LAN\", \"WIN\", \"STL\", \"FRE\", \"LAF\"]\n    prod = [\"bands\", \"coils\", \"plate\"]\n    numorig = length(orig)\n    numdest = length(dest)\n    numprod = length(prod)\n    # supply(prod, orig) amounts available at origins\n    supply = [\n        400    700    800;\n        800   1600   1800;\n        200    300    300\n    ]\n    # demand(prod, dest) amounts required at destinations\n    demand = [\n        300   300   100    75   650   225   250;\n        500   750   400   250   950   850   500;\n        100   100     0    50   200   100   250\n    ]\n    # limit(orig, dest) of total units from any origin to destination\n    limit = [625.0 for j in 1:numorig, i in 1:numdest]\n    # cost(dest, orig, prod) Shipment cost per unit\n    cost = reshape([\n        [\n            [  30,   10,    8,   10,   11,   71,    6];\n            [  22,    7,   10,    7,   21,   82,   13];\n            [  19,   11,   12,   10,   25,   83,   15]\n        ];\n        [\n            [  39,   14,   11,   14,   16,   82,    8];\n            [  27,    9,   12,    9,   26,   95,   17];\n            [  24,   14,   17,   13,   28,   99,   20]\n        ];\n        [\n            [  41,   15,   12,   16,   17,   86,    8];\n            [  29,    9,   13,    9,   28,   99,   18];\n            [  26,   14,   17,   13,   31,  104,   20]\n        ]\n    ], 7, 3, 3)\n    # DECLARE MODEL\n    multi = Model(GLPK.Optimizer)\n    # VARIABLES\n    @variable(multi, trans[1:numorig, 1:numdest, 1:numprod] >= 0)\n    # OBJECTIVE\n    @objective(\n        multi,\n        Max,\n        sum(\n            cost[j, i, p] * trans[i, j, p]\n            for i in 1:numorig, j in 1:numdest, p in 1:numprod\n        )\n    )\n    # CONSTRAINTS\n    # Supply constraint\n    @constraint(\n        multi,\n        supply_con[i in 1:numorig, p in 1:numprod],\n        sum(trans[i, j, p] for j in 1:numdest) == supply[p, i]\n    )\n    # Demand constraint\n    @constraint(\n        multi,\n        demand_con[j in 1:numdest, p in 1:numprod],\n        sum(trans[i, j, p] for i in 1:numorig) == demand[p, j]\n    )\n    # Total shipment constraint\n    @constraint(\n        multi,\n        total_con[i in 1:numorig, j in 1:numdest],\n        sum(trans[i, j, p] for p in 1:numprod) - limit[i, j] <= 0\n    )\n    optimize!(multi)\n    Test.@test termination_status(multi) == MOI.OPTIMAL\n    Test.@test primal_status(multi) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(multi) == 225_700.0\n    if verbose\n        println(\"RESULTS:\")\n        for i in 1:length(orig)\n            for j in 1:length(dest)\n                for p in 1:length(prod)\n                    print(\" $(prod[p]) $(orig[i]) $(dest[j]) = $(value(trans[i, j, p]))\\t\")\n                end\n                println()\n            end\n        end\n    end\n    return\nend\n\n\nexample_multi()","category":"page"},{"location":"examples/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"View this file on Github.","category":"page"},{"location":"examples/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"","category":"page"},{"location":"examples/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/corr_sdp.jl\"","category":"page"},{"location":"examples/corr_sdp/#The-correlation-problem","page":"The correlation problem","title":"The correlation problem","text":"","category":"section"},{"location":"examples/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"Given three random variables A, B, C and given bounds on two of the three correlation coefficients:","category":"page"},{"location":"examples/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"-0.2 <= ρ_AB <= -0.1\n0.4 <= ρ_BC <=  0.5","category":"page"},{"location":"examples/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"We can use the following property of the correlations to determine bounds on ρ_AC by solving a SDP:","category":"page"},{"location":"examples/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"|  1    ρ_AB  ρ_AC |\n| ρ_AB   1    ρ_BC |  ≽ 0\n| ρ_AC  ρ_BC   1   |","category":"page"},{"location":"examples/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"using JuMP\nimport SCS\n\nfunction example_corr_sdp()\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, X[1:3, 1:3], PSD)\n    # Diagonal is 1s\n    @constraint(model, X[1, 1] == 1)\n    @constraint(model, X[2, 2] == 1)\n    @constraint(model, X[3, 3] == 1)\n    # Bounds on the known correlations\n    @constraint(model, X[1, 2] >= -0.2)\n    @constraint(model, X[1, 2] <= -0.1)\n    @constraint(model, X[2, 3] >=  0.4)\n    @constraint(model, X[2, 3] <=  0.5)\n    # Find upper bound\n    @objective(model, Max, X[1, 3])\n    optimize!(model)\n    println(\"An upper bound for X[1, 3] is $(value(X[1, 3]))\")\n    # Find lower bound\n    @objective(model, Min, X[1, 3])\n    optimize!(model)\n    println(\"A lower bound for X[1, 3] is $(value(X[1, 3]))\")\n    return\nend\n\nexample_corr_sdp()","category":"page"},{"location":"examples/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"View this file on Github.","category":"page"},{"location":"examples/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"","category":"page"},{"location":"examples/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/basic/","page":"A basic example","title":"A basic example","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/basic.jl\"","category":"page"},{"location":"examples/basic/#A-basic-example","page":"A basic example","title":"A basic example","text":"","category":"section"},{"location":"examples/basic/","page":"A basic example","title":"A basic example","text":"This example uses the following packages:","category":"page"},{"location":"examples/basic/","page":"A basic example","title":"A basic example","text":"using JuMP\nimport GLPK","category":"page"},{"location":"examples/basic/","page":"A basic example","title":"A basic example","text":"Build the model:","category":"page"},{"location":"examples/basic/","page":"A basic example","title":"A basic example","text":"model = Model(GLPK.Optimizer)\n\n@variable(model, 0 <= x <= 2)\n@variable(model, 0 <= y <= 30)\n\n@objective(model, Max, 5x + 3y)\n\n@constraint(model, 1x + 5y <= 3.0)\n\nprint(model)","category":"page"},{"location":"examples/basic/","page":"A basic example","title":"A basic example","text":"Optimize the model:","category":"page"},{"location":"examples/basic/","page":"A basic example","title":"A basic example","text":"optimize!(model)","category":"page"},{"location":"examples/basic/","page":"A basic example","title":"A basic example","text":"Check the termination and primal status to see if we have a solution:","category":"page"},{"location":"examples/basic/","page":"A basic example","title":"A basic example","text":"println(\"Termination status : \", termination_status(model))\nprintln(\"Primal status      : \", primal_status(model))","category":"page"},{"location":"examples/basic/","page":"A basic example","title":"A basic example","text":"Print the solution:","category":"page"},{"location":"examples/basic/","page":"A basic example","title":"A basic example","text":"obj_value = objective_value(model)\nx_value = value(x)\ny_value = value(y)\n\nprintln(\"Objective value : \", obj_value)\nprintln(\"x value         : \", x_value)\nprintln(\"y value         : \", y_value)","category":"page"},{"location":"examples/basic/","page":"A basic example","title":"A basic example","text":"View this file on Github.","category":"page"},{"location":"examples/basic/","page":"A basic example","title":"A basic example","text":"","category":"page"},{"location":"examples/basic/","page":"A basic example","title":"A basic example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/containers/#Containers-API","page":"Containers API","title":"Containers API","text":"","category":"section"},{"location":"reference/containers/","page":"Containers API","title":"Containers API","text":"More information can be found in the Containers section of the manual.","category":"page"},{"location":"reference/containers/","page":"Containers API","title":"Containers API","text":"Containers","category":"page"},{"location":"reference/containers/#JuMP.Containers","page":"Containers API","title":"JuMP.Containers","text":"Containers\n\nModule defining the containers DenseAxisArray and SparseAxisArray that behaves as a regular AbstractArray but with custom indexes that are not necessarily integers.\n\n\n\n\n\n","category":"module"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/nlp_tricks.jl\"","category":"page"},{"location":"examples/nlp_tricks/#Nonlinear-tips-and-tricks","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"","category":"section"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"This example collates some tips and tricks you can use when formulating nonlinear programs. It uses the following packages:","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"using JuMP\nimport Ipopt\nimport Test","category":"page"},{"location":"examples/nlp_tricks/#User-defined-functions-with-vector-outputs","page":"Nonlinear tips and tricks","title":"User-defined functions with vector outputs","text":"","category":"section"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"A common situation is to have a user-defined function like the following that returns multiple outputs (we define function_calls to keep track of how many times we call this method):","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"function_calls = 0\nfunction foo(x, y)\n    global function_calls += 1\n    common_term = x^2 + y^2\n    term_1 = sqrt(1 + common_term)\n    term_2 = common_term\n    return term_1, term_2\nend","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"For example, the first term might be used in the objective, and the second term might be used in a constraint, and often they share share work that is expensive to evaluate.","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"This is a problem for JuMP, because it requires user-defined functions to return a single number. One option is to define two separate functions, the first returning the first argument, and the second returning the second argument.","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"foo_1(x, y) = foo(x, y)[1]\nfoo_2(x, y) = foo(x, y)[2]","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"However, if the common term is expensive to compute, this approach is wasteful because it will evaluate the expensive term twice. Let's have a look at how many times we evalute x^2 + y^2 during a solve:","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"model = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, x[1:2] >= 0, start = 0.1)\nregister(model, :foo_1, 2, foo_1; autodiff = true)\nregister(model, :foo_2, 2, foo_2; autodiff = true)\n@NLobjective(model, Max, foo_1(x[1], x[2]))\n@NLconstraint(model, foo_2(x[1], x[2]) <= 2)\nfunction_calls = 0\noptimize!(model)\nTest.@test objective_value(model) ≈ √3 atol=1e-4\nTest.@test value.(x) ≈ [1.0, 1.0] atol=1e-4\nprintln(\"Naive approach: function calls = $(function_calls)\")","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"An alternative approach is to use memoization, which uses a cache to store the result of function evaluations. We can write a memoization function as follows:","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"\"\"\"\n    memoize(foo::Function, n_outputs::Int)\n\nTake a function `foo` and return a vector of length `n_outputs`, where each\nelement is a function that returns the `i`'th output of `foo`.\n\nTo avoid duplication of work, cache the most-recent evaluations of `foo`.\nBecause `foo_i` is auto-differentiated with ForwardDiff, our cache needs to\nwork when `x` is a `Float64` and a `ForwardDiff.Dual`.\n\"\"\"\nfunction memoize(foo::Function, n_outputs::Int)\n    last_x, last_f = nothing, nothing\n    last_dx, last_dfdx = nothing, nothing\n    function foo_i(i, x::T...) where {T <: Real}\n        if T == Float64\n            if x != last_x\n                last_x, last_f = x, foo(x...)\n            end\n            return last_f[i]::T\n        else\n            if x != last_dx\n                last_dx, last_dfdx = x, foo(x...)\n            end\n            return last_dfdx[i]::T\n        end\n    end\n    return [(x...) -> foo_i(i, x...) for i = 1:n_outputs]\nend","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"Let's see how it works. First, construct the memoized versions of foo:","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"memoized_foo = memoize(foo, 2)","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"Now try evaluating the first element of memoized_foo.","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"function_calls = 0\nmemoized_foo[1](1.0, 1.0)\nprintln(\"function_calls = \", function_calls)","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"As expected, this evaluated the function once. However, if we call the function again, we hit the cache instead of needing to re-compute foo and function_calls is still 1!","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"memoized_foo[1](1.0, 1.0)\nprintln(\"function_calls = \", function_calls)","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"Now let's see how this works during a real solve:","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"model = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, x[1:2] >= 0, start = 0.1)\nregister(model, :foo_1, 2, memoized_foo[1]; autodiff = true)\nregister(model, :foo_2, 2, memoized_foo[2]; autodiff = true)\n@NLobjective(model, Max, foo_1(x[1], x[2]))\n@NLconstraint(model, foo_2(x[1], x[2]) <= 2)\nfunction_calls = 0\noptimize!(model)\nTest.@test objective_value(model) ≈ √3 atol=1e-4\nTest.@test value.(x) ≈ [1.0, 1.0] atol=1e-4\nprintln(\"Memoized approach: function_calls = $(function_calls)\")","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"Compared to the naive approach, the memoized approach requires half as many function evaluations!","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"View this file on Github.","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"","category":"page"},{"location":"examples/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solvers/#Interacting-with-solvers","page":"Interacting with solvers","title":"Interacting with solvers","text":"","category":"section"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"A JuMP model keeps a MathOptInterface (MOI) backend of type MOI.ModelLike that stores the optimization problem and acts as the optimization solver. We call it an MOI backend and not optimizer as it can also be a wrapper around an optimization file format such as MPS that writes the JuMP model in a file. From JuMP, the MOI backend can be accessed using the backend function. JuMP can be viewed as a lightweight, user-friendly layer on top of the MOI backend, in the sense that:","category":"page"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"JuMP does not maintain any copy of the model outside this MOI backend.\nJuMP variable (resp. constraint) references are simple structures containing both a reference to the JuMP model and the MOI index of the variable (resp. constraint).\nJuMP gives the constraints to the MOI backend in the form provided by the user without doing any automatic reformulation.\nvariables additions, constraints additions/modifications and objective modifications are directly applied to the MOI backend thus expecting the backend to support such modifications.","category":"page"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"While this allows JuMP to be a thin wrapper on top of the solver API, as mentioned in the last point above, this seems rather demanding on the solver. Indeed, while some solvers support incremental building of the model and modifications before and after solve, other solvers only support the model being copied at once before solve. Moreover, it seems to require all solvers to implement all possible reformulations independently which seems both very ambitious and might generate a lot of duplicated code.","category":"page"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"These apparent limitations are addressed at level of MOI in a manner that is completely transparent to JuMP. While the MOI API may seem very demanding, it allows MOI models to be a succession of lightweight MOI layers that fill the gap between JuMP requirements and the solver capabilities. The remainder of this section describes how JuMP interacts with the MOI backend.","category":"page"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"JuMP models can be created in three different modes: AUTOMATIC, MANUAL and DIRECT.","category":"page"},{"location":"solvers/#Automatic-and-Manual-modes","page":"Interacting with solvers","title":"Automatic and Manual modes","text":"","category":"section"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"In AUTOMATIC and MANUAL modes, two MOI layers are automatically applied to the optimizer:","category":"page"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"CachingOptimizer: maintains a cache of the model so that when the optimizer does not support an incremental change to the model, the optimizer's internal model can be discarded and restored from the cache just before optimization. The CachingOptimizer has two different modes: AUTOMATIC and MANUAL corresponding to the two JuMP modes with the same names.\nLazyBridgeOptimizer (this can be disabled using the bridge_constraints keyword argument to Model constructor): when a constraint added is not supported by the optimizer, it attempts to transform the constraint into an equivalent form, possibly adding new variables and constraints that are supported by the optimizer. The applied transformations are selected among known recipes which are called bridges. A few default bridges are defined in MOI but new ones can be defined and added to the LazyBridgeOptimizer used by JuMP.","category":"page"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"See the MOI documentation for more details on these two MOI layers.","category":"page"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"To attach an optimizer to a JuMP model, JuMP needs to be able to create a new empty optimizer instance. For this reason, we provide JuMP with a function that creates a new optimizer (i.e., an optimizer factory), instead of a concrete optimizer object.","category":"page"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"The factory can be provided either at model construction time by calling set_optimizer. An optimizer must be set before a call to optimize!. The optimizer can be grouped with attributes to be set before optimization with optimizer_with_attributes.","category":"page"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"New JuMP models are created using the Model constructor:","category":"page"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"A JuMP model may be reused by emptying it first with empty!(model).","category":"page"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"# TODO: how to control the caching optimizer states","category":"page"},{"location":"solvers/#Direct-mode","page":"Interacting with solvers","title":"Direct mode","text":"","category":"section"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"JuMP models can be created in MOI.DIRECT mode using the JuMP.direct_model function.","category":"page"},{"location":"solvers/#Solver-attributes","page":"Interacting with solvers","title":"Solver attributes","text":"","category":"section"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"Some solver attributes can be queried and set through JuMP models.","category":"page"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"Examples include:","category":"page"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"set_silent and unset_silent\nset_time_limit_sec and unset_time_limit_sec","category":"page"},{"location":"solvers/#File-formats","page":"Interacting with solvers","title":"File formats","text":"","category":"section"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"JuMP can write models to a variety of file-formats using write_to_file and Base.write.","category":"page"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"The file formats are defined within MathOptInterface in the FileFormats enumeration.","category":"page"},{"location":"solvers/","page":"Interacting with solvers","title":"Interacting with solvers","text":"JuMP models can be created from file formats using read_from_file and Base.read.","category":"page"},{"location":"roadmap/#Development-roadmap","page":"Development Roadmap","title":"Development roadmap","text":"","category":"section"},{"location":"roadmap/","page":"Development Roadmap","title":"Development Roadmap","text":"This page is not JuMP documentation per se but are notes for the JuMP community. The JuMP developers have compiled this roadmap document to share their plans and goals. Contributions to roadmap issues are especially invited.","category":"page"},{"location":"roadmap/#JuMP-1.0","page":"Development Roadmap","title":"JuMP 1.0","text":"","category":"section"},{"location":"roadmap/","page":"Development Roadmap","title":"Development Roadmap","text":"JuMP 1.0 will be ready to release roughly when all of these tasks are completed. Some but not all of these tasks are summarized in the JuMP 1.0 milestone.","category":"page"},{"location":"roadmap/","page":"Development Roadmap","title":"Development Roadmap","text":"Create a website for JuMP. (Done: jump.dev)\nDeprecate the JuliaOpt organization and move repositories to the JuMP-dev organization. (Done)\nAddress major regressions from JuMP 0.18.\nPerformance (#1403,              #1654,              #1607)\nCallbacks (Done: see examples/callbacks.jl)\nColumn generation syntax (Done: see examples/cutting_stock_column_generation.jl)\nSupport for second-order cones in Gurobi, CPLEX, and Xpress (Done)\nFix issues that we promised MOI would fix.\nChecking feasibility of solutions (#693)\nAccessing IIS (Done: see Conflicts)\nAccessing multiple results from solvers\nDual warm-starts (Done: #2214)\nAddress “easy” usability issues\nLine numbers in error messages (Done: #2276)\nLP sensitivity summary (Done: see Sensitivity analysis for LP)\nInferred element types for collections in macros (Done: #2070)\nExpose solver-independent options from JuMP (Done: see set_silent etc.)\nImprove the documentation (#1062)\nSeparate how-to, concept explanation, and technical reference following the Divio recommendations\nFully integrate JuMPTutorials with JuMP's documentation.\nDeveloper experience\nGet JuMP’s unit tests running in less than two minutes. See #1745.\nAll solvers should complete the transition to MOI.\nProvide packages for installing Bonmin and Couenne.\nMathOptFormat 1.0 (Done)","category":"page"},{"location":"roadmap/#MOI-1.0","page":"Development Roadmap","title":"MOI 1.0","text":"","category":"section"},{"location":"roadmap/","page":"Development Roadmap","title":"Development Roadmap","text":"# TODO: List MOI 1.0 items here.","category":"page"},{"location":"roadmap/#Beyond-JuMP-1.0","page":"Development Roadmap","title":"Beyond JuMP 1.0","text":"","category":"section"},{"location":"roadmap/","page":"Development Roadmap","title":"Development Roadmap","text":"# TODO: Copy over list of items not tied to JuMP 1.0. These should have more\n# elaborate explanations so that potential contributors know what we mean,\n# i.e., a few sentences each or a link to a document/issue.","category":"page"},{"location":"containers/","page":"Containers","title":"Containers","text":"DocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"containers/#Containers","page":"Containers","title":"Containers","text":"","category":"section"},{"location":"containers/","page":"Containers","title":"Containers","text":"JuMP provides a specialized container similar to AxisArrays that enables indexing with non-integer indices. Normally these are created automatically by JuMP's macros. The following constructors can be used to create them manually.","category":"page"},{"location":"containers/","page":"Containers","title":"Containers","text":"JuMP.Containers.DenseAxisArray\nJuMP.Containers.SparseAxisArray","category":"page"},{"location":"containers/#JuMP.Containers.DenseAxisArray","page":"Containers","title":"JuMP.Containers.DenseAxisArray","text":"DenseAxisArray(data::Array{T, N}, axes...) where {T, N}\n\nConstruct a JuMP array with the underlying data specified by the data array and the given axes. Exactly N axes must be provided, and their lengths must match size(data) in the corresponding dimensions.\n\nExample\n\njulia> array = JuMP.Containers.DenseAxisArray([1 2; 3 4], [:a, :b], 2:3)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 2:3\nAnd data, a 2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> array[:b, 3]\n4\n\n\n\n\n\nDenseAxisArray{T}(undef, axes...) where T\n\nConstruct an uninitialized DenseAxisArray with element-type T indexed over the given axes.\n\nExample\n\njulia> array = JuMP.Containers.DenseAxisArray{Float64}(undef, [:a, :b], 1:2);\n\njulia> fill!(array, 1.0)\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 1:2\nAnd data, a 2×2 Array{Float64,2}:\n 1.0  1.0\n 1.0  1.0\n\njulia> array[:a, 2] = 5.0\n5.0\n\njulia> array[:a, 2]\n5.0\n\njulia> array\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 1:2\nAnd data, a 2×2 Array{Float64,2}:\n 1.0  5.0\n 1.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"containers/#JuMP.Containers.SparseAxisArray","page":"Containers","title":"JuMP.Containers.SparseAxisArray","text":"struct SparseAxisArray{T,N,K<:NTuple{N, Any}} <: AbstractArray{T,N}\n    data::Dict{K,T}\nend\n\nN-dimensional array with elements of type T where only a subset of the entries are defined. The entries with indices idx = (i1, i2, ..., iN) in keys(data) has value data[idx]. Note that as opposed to SparseArrays.AbstractSparseArray, the missing entries are not assumed to be zero(T), they are simply not part of the array. This means that the result of map(f, sa::SparseAxisArray) or f.(sa::SparseAxisArray) has the same sparsity structure than sa even if f(zero(T)) is not zero.\n\nExample\n\njulia> dict = Dict((:a, 2) => 1.0, (:a, 3) => 2.0, (:b, 3) => 3.0)\nDict{Tuple{Symbol,Int64},Float64} with 3 entries:\n  (:b, 3) => 3.0\n  (:a, 2) => 1.0\n  (:a, 3) => 2.0\n\njulia> array = JuMP.Containers.SparseAxisArray(dict)\nJuMP.Containers.SparseAxisArray{Float64,2,Tuple{Symbol,Int64}} with 3 entries:\n  [b, 3]  =  3.0\n  [a, 2]  =  1.0\n  [a, 3]  =  2.0\n\njulia> array[:b, 3]\n3.0\n\n\n\n\n\n","category":"type"},{"location":"containers/#Containers-in-macros","page":"Containers","title":"Containers in macros","text":"","category":"section"},{"location":"containers/","page":"Containers","title":"Containers","text":"The container function encodes the logic for how containers are constructed in JuMP's macros. The @container macro is available to create containers independently of any JuMP model.","category":"page"},{"location":"containers/","page":"Containers","title":"Containers","text":"JuMP.Containers.container\nJuMP.Containers.default_container\nJuMP.Containers.VectorizedProductIterator\nJuMP.Containers.NestedIterator\nJuMP.Containers.@container","category":"page"},{"location":"containers/#JuMP.Containers.container","page":"Containers","title":"JuMP.Containers.container","text":"container(f::Function, indices, ::Type{C})\n\nCreate a container of type C with indices indices and values at given indices given by f.\n\ncontainer(f::Function, indices)\n\nCreate a container with indices indices and values at given indices given by f. The type of container used is determined by default_container.\n\nExamples\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(Base.OneTo(3), Base.OneTo(3)))\n3×3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(1:3, 1:3))\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, 1:3\nAnd data, a 3×3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(2:3, Base.OneTo(3)))\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, Base.OneTo(3)\nAnd data, a 2×3 Array{Int64,2}:\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.nested(() -> 1:3, i -> i:3, condition = (i, j) -> isodd(i) || isodd(j)))\nSparseAxisArray{Int64,2,Tuple{Int64,Int64}} with 5 entries:\n  [1, 2]  =  3\n  [2, 3]  =  5\n  [3, 3]  =  6\n  [1, 1]  =  2\n  [1, 3]  =  4\n\n\n\n\n\n","category":"function"},{"location":"containers/#JuMP.Containers.default_container","page":"Containers","title":"JuMP.Containers.default_container","text":"default_container(indices)\n\nIf indices is a NestedIterator, return a SparseAxisArray. Otherwise, indices should be a VectorizedProductIterator and the function returns Array if all iterators of the product are Base.OneTo and retunrs DenseAxisArray otherwise.\n\n\n\n\n\n","category":"function"},{"location":"containers/#JuMP.Containers.VectorizedProductIterator","page":"Containers","title":"JuMP.Containers.VectorizedProductIterator","text":"struct VectorizedProductIterator{T}\n    prod::Iterators.ProductIterator{T}\nend\n\nCartesian product of the iterators prod.iterators. It is the same iterator as Base.Iterators.ProductIterator except that it is independent of the IteratorSize of the elements of prod.iterators. For instance:\n\nsize(Iterators.product(1, 2)) is tuple() while size(VectorizedProductIterator(1, 2)) is (1, 1).\nsize(Iterators.product(ones(2, 3))) is (2, 3) while size(VectorizedProductIterator(ones(2, 3))) is (1, 1).\n\n\n\n\n\n","category":"type"},{"location":"containers/#JuMP.Containers.NestedIterator","page":"Containers","title":"JuMP.Containers.NestedIterator","text":"struct NestedIterator{T}\n    iterators::T # Tuple of functions\n    condition::Function\nend\n\nIterators over the tuples that are produced by a nested for loop. For instance, if length(iterators) == 3 , this corresponds to the tuples (i1, i2, i3) produced by:\n\nfor i1 in iterators[1]()\n    for i2 in iterator[2](i1)\n        for i3 in iterator[3](i1, i2)\n            if condition(i1, i2, i3)\n                # produces (i1, i2, i3)\n            end\n        end\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"containers/#JuMP.Containers.@container","page":"Containers","title":"JuMP.Containers.@container","text":"@container([i=..., j=..., ...], expr)\n\nCreate a container with indices i, j, ... and values given by expr that may depend on the value of the indices.\n\n@container(ref[i=..., j=..., ...], expr)\n\nSame as above but the container is assigned to the variable of name ref.\n\nThe type of container can be controlled by the container keyword. See Containers in macros. Note that when the index set is explicitly given as 1:n for any expression n, it is transformed to Base.OneTo(n) before being given to container.\n\nExamples\n\njulia> Containers.@container([i = 1:3, j = 1:3], i + j)\n3×3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> I = 1:3\n1:3\n\njulia> Containers.@container([i = I, j = I], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, 1:3\nAnd data, a 3×3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.@container([i = 2:3, j = 1:3], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, Base.OneTo(3)\nAnd data, a 2×3 Array{Int64,2}:\n 3  4  5\n 4  5  6\n\njulia> Containers.@container([i = 1:3, j = 1:3; i <= j], i + j)\nJuMP.Containers.SparseAxisArray{Int64,2,Tuple{Int64,Int64}} with 6 entries:\n  [1, 2]  =  3\n  [2, 3]  =  5\n  [3, 3]  =  6\n  [2, 2]  =  4\n  [1, 1]  =  2\n  [1, 3]  =  4\n\n\n\n\n\n","category":"macro"},{"location":"containers/","page":"Containers","title":"Containers","text":"In the @variable (resp. @constraint) macro, containers of variables (resp. constraints) can be created with the following syntax:","category":"page"},{"location":"containers/","page":"Containers","title":"Containers","text":"name[index_set_1, index_set_2, ..., index_set_n] creating an n-dimensional container of name name; or\n[index_set_1, index_set_2, ..., index_set_n] creating an anonymous n-dimensional container.","category":"page"},{"location":"containers/","page":"Containers","title":"Containers","text":"Each expression index_set_i can either be","category":"page"},{"location":"containers/","page":"Containers","title":"Containers","text":"of the form index_set specifying that the ith index set of the container is index_set; or\nof the form index_name=index_set specifying that the ith index set of the container is index_set and allowing values used in the macro expression and keyword arguments to be expressions depending on the index_name.","category":"page"},{"location":"containers/","page":"Containers","title":"Containers","text":"The macro then creates the container using the JuMP.Containers.container function with the following arguments:","category":"page"},{"location":"containers/","page":"Containers","title":"Containers","text":"A function taking as argument the value of the indices and returning the value to be stored in the container, e.g. a variable for the @variable macro and a constraint for the @constraint macro.\nAn iterator over the indices of the container.\nThe value of the container keyword argument if given.","category":"page"},{"location":"examples/cannery/","page":"The cannery problem","title":"The cannery problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/cannery.jl\"","category":"page"},{"location":"examples/cannery/#The-cannery-problem","page":"The cannery problem","title":"The cannery problem","text":"","category":"section"},{"location":"examples/cannery/","page":"The cannery problem","title":"The cannery problem","text":"A JuMP implementation of the cannery problem from:","category":"page"},{"location":"examples/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Dantzig, Linear Programming and Extensions, Princeton University Press, Princeton, NJ, 1963.","category":"page"},{"location":"examples/cannery/","page":"The cannery problem","title":"The cannery problem","text":"It was originally contributed by Louis Luangkesorn, January 30, 2015.","category":"page"},{"location":"examples/cannery/","page":"The cannery problem","title":"The cannery problem","text":"using JuMP\nimport GLPK\n\nfunction example_cannery()\n    # Origin plants.\n    plants = [\"Seattle\", \"San-Diego\"]\n    num_plants = length(plants)\n    # Destination markets.\n    markets = [\"New-York\", \"Chicago\", \"Topeka\"]\n    num_markets = length(markets)\n    # Capacity and demand in cases.\n    capacity = [350, 600]\n    demand = [300, 300, 300]\n    # Distance in thousand miles.\n    distance = [2.5 1.7 1.8; 2.5 1.8 1.4]\n    # Cost per case per thousand miles.\n    freight = 90\n    cannery = Model()\n    set_optimizer(cannery, GLPK.Optimizer)\n    # Create decision variables.\n    @variable(cannery, ship[1:num_plants, 1:num_markets] >= 0)\n    # Ship no more than plant capacity\n    @constraint(\n        cannery, capacity_con[i = 1:num_plants], sum(ship[i, :]) <= capacity[i]\n    )\n    # Ship at least market demand\n    @constraint(\n        cannery, demand_con[j = 1:num_markets], sum(ship[:, j]) >= demand[j]\n    )\n    # Minimize transporatation cost\n    @objective(\n        cannery,\n        Min,\n        sum(\n            distance[i, j] * freight * ship[i, j]\n            for i = 1:num_plants, j = 1:num_markets\n        )\n    )\n    optimize!(cannery)\n    println(\"RESULTS:\")\n    for i = 1:num_plants\n        for j = 1:num_markets\n            println(\"  $(plants[i]) $(markets[j]) = $(value(ship[i, j]))\")\n        end\n    end\n    return\nend\n\nexample_cannery()","category":"page"},{"location":"examples/cannery/","page":"The cannery problem","title":"The cannery problem","text":"View this file on Github.","category":"page"},{"location":"examples/cannery/","page":"The cannery problem","title":"The cannery problem","text":"","category":"page"},{"location":"examples/cannery/","page":"The cannery problem","title":"The cannery problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/min_distortion.jl\"","category":"page"},{"location":"examples/min_distortion/#The-minimum-distortion-problem","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"","category":"section"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"This example arises from computational geometry, in particular the problem of embedding a general finite metric space into a euclidean space.","category":"page"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"It is known that the 4-point metric space defined by the star graph:","category":"page"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"x\n \\\\\n  x — x\n /\nx","category":"page"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"where distances are computed by length of the shortest path between vertices, cannot be exactly embedded into a euclidean space of any dimension.","category":"page"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"Here we will formulate and solve an SDP to compute the best possible embedding, that is, the embedding f() that minimizes the distortion c such that","category":"page"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"(1 / c) * D(a, b) ≤ ||f(a) - f(b)|| ≤ D(a, b)","category":"page"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"for all points (a, b), where D(a, b) is the distance in the metric space.","category":"page"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"Any embedding can be characterized by its Gram matrix Q, which is PSD, and","category":"page"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"||f(a) - f(b)||^2 = Q[a, a] + Q[b, b] - 2 * Q[a, b]","category":"page"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"We can therefore constrain","category":"page"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"D[i, j]^2 ≤ Q[i, i] + Q[j, j] - 2 * Q[i, j] ≤ c^2 * D[i, j]^2","category":"page"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"and minimize c^2, which gives us the SDP formulation below.","category":"page"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"For more detail, see \"Lectures on discrete geometry\" by J. Matoušek, Springer, 2002, pp. 378-379.","category":"page"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"using JuMP\nimport SCS\nimport Test\n\nfunction example_min_distortion()\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    D = [\n        0.0 1.0 1.0 1.0;\n        1.0 0.0 2.0 2.0;\n        1.0 2.0 0.0 2.0;\n        1.0 2.0 2.0 0.0\n    ]\n    @variable(model, c² >= 1.0)\n    @variable(model, Q[1:4, 1:4], PSD)\n    for i in 1:4\n        for j in (i + 1):4\n            @constraint(model, D[i, j]^2 <= Q[i, i] + Q[j, j] - 2 * Q[i, j])\n            @constraint(model, Q[i, i] + Q[j, j] - 2 * Q[i, j] <= c² * D[i, j]^2)\n        end\n    end\n    @objective(model, Min, c²)\n    optimize!(model)\n    Test.@test termination_status(model) == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ≈ 4/3 atol = 1e-4\n    return\nend\n\nexample_min_distortion()","category":"page"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"View this file on Github.","category":"page"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"","category":"page"},{"location":"examples/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/qcp.jl\"","category":"page"},{"location":"examples/qcp/#Quadratically-constrained-programs","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"","category":"section"},{"location":"examples/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"A simple quadratically constrained program based on an example from Gurobi.","category":"page"},{"location":"examples/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"using JuMP\nimport Ipopt\nimport Test\n\nfunction example_qcp(; verbose = true)\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, x)\n    @variable(model, y >= 0)\n    @variable(model, z >= 0)\n    @objective(model, Max, x)\n    @constraint(model, x + y + z == 1)\n    @constraint(model, x * x + y * y - z * z <= 0)\n    @constraint(model, x * x - y * z <= 0)\n    optimize!(model)\n    if verbose\n        print(model)\n        println(\"Objective value: \", objective_value(model))\n        println(\"x = \", value(x))\n        println(\"y = \", value(y))\n    end\n    Test.@test termination_status(model) == MOI.LOCALLY_SOLVED\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ≈ 0.32699 atol = 1e-5\n    Test.@test value(x) ≈ 0.32699 atol = 1e-5\n    Test.@test value(y) ≈ 0.25707 atol = 1e-5\n    return\nend\n\nexample_qcp()","category":"page"},{"location":"examples/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"View this file on Github.","category":"page"},{"location":"examples/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"","category":"page"},{"location":"examples/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"variables/#What-is-a-JuMP-variable?","page":"Variables","title":"What is a JuMP variable?","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"The term variable in mathematical optimization has many meanings. Here, we distinguish between the following three types of variables:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"optimization variables, which are the mathematical x in the problem maxf_0(x)  f_i(x) in S_i.\nJulia variables, which are bindings between a name and a value, for example x = 1. (See here for the Julia docs.)\nJuMP variables, which are instances of the VariableRef struct defined by JuMP that contains a reference to an optimization variable in a model. (Extra for experts: the VariableRef struct is a thin wrapper around a MOI.VariableIndex, and also contains a reference to the JuMP model.)","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"To illustrate these three types of variables, consider the following JuMP code (the full syntax is explained below):","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x[1:2])\n2-element Array{VariableRef,1}:\n x[1]\n x[2]","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"This code does three things:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"It adds two optimization variables to model.\nIt creates two JuMP variables that act as references to those optimization variables.\nIt binds those JuMP variables as a vector with two elements to the Julia variable x.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"To reduce confusion, we will attempt, where possible, to always refer to variables with their corresponding prefix.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"JuMP variables can have attributes, such as names or an initial primal start value. We illustrate the name attribute in the following example:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, y, base_name=\"decision variable\")\ndecision variable","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"This code does four things:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"It adds one optimization variable to model.\nIt creates one JuMP variable that acts as a reference to that optimization variable.\nIt binds the JuMP variable to the Julia variable y.\nIt tells JuMP that the name attribute of this JuMP variable is \"decision variable\". JuMP uses the value of base_name when it has to print the variable as a string.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"For example, when we print y at the REPL we get:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> y\ndecision variable","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Because y is a Julia variable, we can bind it to a different value. For example, if we write:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> y = 1\n1","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"y is no longer a binding to a JuMP variable. This does not mean that the JuMP variable has been destroyed. It still exists and is still a reference to the same optimization variable. The binding can be reset by querying the model for the symbol as it was written in the @variable macro. For example:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> model[:y]\ndecision variable","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"This act of looking up the JuMP variable by using the symbol is most useful when composing JuMP models across multiple functions, as illustrated by the following example:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"function add_component_to_model(model::JuMP.Model)\n    x = model[:x]\n    # ... code that uses x\nend\nfunction build_model()\n    model = Model()\n    @variable(model, x)\n    add_component_to_model(model)\nend","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Now that we understand the difference between optimization, JuMP, and Julia variables, we can introduce more of the functionality of the @variable macro.","category":"page"},{"location":"variables/#Variable-bounds","page":"Variables","title":"Variable bounds","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"We have already seen the basic usage of the @variable macro. The next extension is to add lower- and upper-bounds to each optimization variable. This can be done as follows:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x_free)\nx_free\n\njulia> @variable(model, x_lower >= 0)\nx_lower\n\njulia> @variable(model, x_upper <= 1)\nx_upper\n\njulia> @variable(model, 2 <= x_interval <= 3)\nx_interval\n\njulia> @variable(model, x_fixed == 4)\nx_fixed","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"In the above examples, x_free represents an unbounded optimization variable, x_lower represents an optimization variable with a lower bound and so forth.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"note: Note\nWhen creating a variable with only a lower-bound or an upper-bound, and the value of the bound is not a numeric literal, the name of the variable must appear on the left-hand side. Putting the name on the right-hand side will result in an error. For example:@variable(model, 1 <= x)  # works\na = 1\n@variable(model, a <= x)  # errors\n@variable(model, x >= a)  # works","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"We can query whether an optimization variable has a lower- or upper-bound via the has_lower_bound and has_upper_bound functions. For example:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> has_lower_bound(x_free)\nfalse\n\njulia> has_upper_bound(x_upper)\ntrue","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"If a variable has a lower or upper bound, we can query the value of it via the lower_bound and upper_bound functions. For example:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> lower_bound(x_interval)\n2.0\n\njulia> upper_bound(x_interval)\n3.0","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Querying the value of a bound that does not exist will result in an error.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Instead of using the <= and >= syntax, we can also use the lower_bound and upper_bound keyword arguments. For example:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, lower_bound=1, upper_bound=2)\nx\n\njulia> lower_bound(x)\n1.0","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Another option is to use the set_lower_bound and set_upper_bound functions. These can also be used to modify an existing variable bound. For example:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x >= 1)\nx\n\njulia> lower_bound(x)\n1.0\n\njulia> set_lower_bound(x, 2)\n\njulia> lower_bound(x)\n2.0","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"We can delete variable bounds using delete_lower_bound and delete_upper_bound:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, 1 <= x <= 2)\nx\n\njulia> lower_bound(x)\n1.0\n\njulia> delete_lower_bound(x)\n\njulia> has_lower_bound(x)\nfalse\n\njulia> upper_bound(x)\n2.0\n\njulia> delete_upper_bound(x)\n\njulia> has_upper_bound(x)\nfalse","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"In addition to upper and lower bounds, JuMP variables can also be fixed to a value using fix. See also is_fixed, fix_value, and unfix.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x == 1)\nx\n\njulia> is_fixed(x)\ntrue\n\njulia> fix_value(x)\n1.0\n\njulia> unfix(x)\n\njulia> is_fixed(x)\nfalse","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Fixing a variable with existing bounds will throw an error. To delete the bounds prior to fixing, use fix(variable, value; force = true).","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x >= 1)\nx\n\njulia> fix(x, 2)\nERROR: Unable to fix x to 2 because it has existing variable bounds. Consider calling `JuMP.fix(variable, value; force=true)` which will delete existing bounds before fixing the variable.\n\njulia> fix(x, 2; force = true)\n\n\njulia> fix_value(x)\n2.0","category":"page"},{"location":"variables/#Variable-names","page":"Variables","title":"Variable names","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"The name, i.e. the value of the MOI.VariableName attribute, of a variable can be obtained by JuMP.name(::JuMP.VariableRef) and set by JuMP.set_name(::JuMP.VariableRef, ::String).","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"The variable can also be retrieved from its name using JuMP.variable_by_name.","category":"page"},{"location":"variables/#Variable-containers","page":"Variables","title":"Variable containers","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"In the examples above, we have mostly created scalar variables. By scalar, we mean that the Julia variable is bound to exactly one JuMP variable. However, it is often useful to create collections of JuMP variables inside more complicated data structures.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"JuMP provides a mechanism for creating three types of these data structures, which we refer to as containers. The three types are Arrays, DenseAxisArrays, and SparseAxisArrays. We explain each of these in the following.","category":"page"},{"location":"variables/#Arrays","page":"Variables","title":"Arrays","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"We have already seen the creation of an array of JuMP variables with the x[1:2] syntax. This can naturally be extended to create multi-dimensional arrays of JuMP variables. For example:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2])\n2×2 Array{VariableRef,2}:\n x[1,1]  x[1,2]\n x[2,1]  x[2,2]","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Arrays of JuMP variables can be indexed and sliced as follows:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> x[1, 2]\nx[1,2]\n\njulia> x[2, :]\n2-element Array{VariableRef,1}:\n x[2,1]\n x[2,2]","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Variable bounds can depend upon the indices:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=1:2, j=1:2] >= 2i + j)\n2×2 Array{VariableRef,2}:\n x[1,1]  x[1,2]\n x[2,1]  x[2,2]\n\njulia> lower_bound.(x)\n2×2 Array{Float64,2}:\n 3.0  4.0\n 5.0  6.0","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"JuMP will form an Array of JuMP variables when it can determine at compile time that the indices are one-based integer ranges. Therefore x[1:b] will create an Array of JuMP variables, but x[a:b] will not. If JuMP cannot determine that the indices are one-based integer ranges (e.g., in the case of x[a:b]), JuMP will create a DenseAxisArray instead.","category":"page"},{"location":"variables/#variable_jump_arrays","page":"Variables","title":"DenseAxisArrays","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"We often want to create arrays where the indices are not one-based integer ranges. For example, we may want to create a variable indexed by the name of a product or a location. The syntax is the same as that above, except with an arbitrary vector as an index as opposed to a one-based range. The biggest difference is that instead of returning an Array of JuMP variables, JuMP will return a DenseAxisArray. For example:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, [:A,:B]])\n2-dimensional DenseAxisArray{VariableRef,2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, Symbol[:A, :B]\nAnd data, a 2×2 Array{VariableRef,2}:\n x[1,A]  x[1,B]\n x[2,A]  x[2,B]","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"DenseAxisArrays can be indexed and sliced as follows:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> x[1, :A]\nx[1,A]\n\njulia> x[2, :]\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:A, :B]\nAnd data, a 2-element Array{VariableRef,1}:\n x[2,A]\n x[2,B]","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Similarly to the Array case, bounds can depend upon indices. For example:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=2:3, j=1:2:3] >= 0.5i + j)\n2-dimensional DenseAxisArray{VariableRef,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, 1:2:3\nAnd data, a 2×2 Array{VariableRef,2}:\n x[2,1]  x[2,3]\n x[3,1]  x[3,3]\n\njulia> lower_bound.(x)\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, 1:2:3\nAnd data, a 2×2 Array{Float64,2}:\n 2.0  4.0\n 2.5  4.5","category":"page"},{"location":"variables/#variable_sparseaxisarrays","page":"Variables","title":"SparseAxisArrays","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"The third container type that JuMP natively supports is SparseAxisArray. These arrays are created when the indices do not form a rectangular set. For example, this applies when indices have a dependence upon previous indices (called triangular indexing). JuMP supports this as follows:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=1:2, j=i:2])\nJuMP.Containers.SparseAxisArray{VariableRef,2,Tuple{Int64,Int64}} with 3 entries:\n  [1, 2]  =  x[1,2]\n  [2, 2]  =  x[2,2]\n  [1, 1]  =  x[1,1]","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"We can also conditionally create variables via a JuMP-specific syntax. This syntax appends a comparison check that depends upon the named indices and is separated from the indices by a semi-colon (;). For example:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=1:4; mod(i, 2)==0])\nJuMP.Containers.SparseAxisArray{VariableRef,1,Tuple{Int64}} with 2 entries:\n  [4]  =  x[4]\n  [2]  =  x[2]","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Note that with many index dimensions and a large amount of sparsity, variable construction may be unnecessarily slow if the semi-colon syntax is naively applied. When using the semi-colon as a filter, JuMP iterates over all indices and evaluates the conditional for each combination. When this is undesired, the recommended work-around is to work directly with a list of tuples or create a dictionary. Consider the following examples:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"# TODO: Reformat the code below as a doctest.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"N = 10\nS = [(1, 1, 1),(N, N, N)]\n# Slow. It evaluates conditional N^3 times.\n@variable(model, x1[i=1:N, j=1:N, k=1:N; (i, j, k) in S])\n# Fast.\n@variable(model, x2[S])\n# Fast. Manually constructs a dictionary and fills it.\nx3 = Dict()\nfor (i, j, k) in S\n    x3[i, j, k] = @variable(model)\n    # Optional, if you care about pretty printing:\n    set_name(x3[i, j, k], \"x[$i,$j,$k]\")\nend","category":"page"},{"location":"variables/#variable_forcing","page":"Variables","title":"Forcing the container type","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"When creating a container of JuMP variables, JuMP will attempt to choose the tightest container type that can store the JuMP variables. Thus, it will prefer to create an Array before a DenseAxisArray and a DenseAxisArray before a SparseAxisArray. However, because this happens at compile time, it does not always make the best choice. To illustrate this, consider the following example:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> A = 1:2\n1:2\n\njulia> @variable(model, x[A])\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, 1:2\nAnd data, a 2-element Array{VariableRef,1}:\n x[1]\n x[2]","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Since the value (and type) of A is unknown at parsing time, JuMP is unable to infer that A is a one-based integer range. Therefore, JuMP creates a DenseAxisArray, even though it could store these two variables in a standard one-dimensional Array.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"We can share our knowledge that it is possible to store these JuMP variables as an array by setting the container keyword:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, y[A], container=Array)\n2-element Array{VariableRef,1}:\n y[1]\n y[2]","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"JuMP now creates a vector of JuMP variables instead of a DenseAxisArray. Note that choosing an invalid container type will throw an error.","category":"page"},{"location":"variables/#Integrality-utilities","page":"Variables","title":"Integrality utilities","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"Adding integrality constraints to a model such as @constraint(model, x in MOI.ZeroOne()) and @constraint(model, x in MOI.Integer()) is a common operation. Therefore, JuMP supports two shortcuts for adding such constraints.","category":"page"},{"location":"variables/#Binary-(ZeroOne)-constraints","page":"Variables","title":"Binary (ZeroOne) constraints","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"Binary optimization variables are constrained to the set x in 0 1. (The MOI.ZeroOne set in MathOptInterface.) Binary optimization variables can be created in JuMP by passing Bin as an optional positional argument:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, Bin)\nx","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"We can check if an optimization variable is binary by calling is_binary on the JuMP variable, and binary constraints can be removed with unset_binary.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> is_binary(x)\ntrue\n\njulia> unset_binary(x)\n\njulia> is_binary(x)\nfalse","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Binary optimization variables can also be created by setting the binary keyword to true.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, binary=true)\nx","category":"page"},{"location":"variables/#Integer-constraints","page":"Variables","title":"Integer constraints","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"Integer optimization variables are constrained to the set x in mathbbZ. (The MOI.Integer set in MathOptInterface.) Integer optimization variables can be created in JuMP by passing Int as an optional positional argument:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, Int)\nx","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Integer optimization variables can also be created by setting the integer keyword to true.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, integer=true)\nx","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"We can check if an optimization variable is integer by calling is_integer on the JuMP variable, and integer constraints can be removed with unset_integer.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> is_integer(x)\ntrue\n\njulia> unset_integer(x)\n\njulia> is_integer(x)\nfalse","category":"page"},{"location":"variables/#Relaxing-integrality","page":"Variables","title":"Relaxing integrality","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"The relax_integrality function relaxes all integrality constraints in the model, returning a function that can be called to undo the operation later on.","category":"page"},{"location":"variables/#Semidefinite-variables","page":"Variables","title":"Semidefinite variables","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"JuMP also supports modeling with semidefinite variables. A square symmetric matrix X is positive semidefinite if all eigenvalues are nonnegative. We can declare a matrix of JuMP variables to be positive semidefinite as follows:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2], PSD)\n2×2 LinearAlgebra.Symmetric{VariableRef,Array{VariableRef,2}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"or using the syntax for Variables constrained on creation:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2] in PSDCone())\n2×2 LinearAlgebra.Symmetric{VariableRef,Array{VariableRef,2}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Note that x must be a square 2-dimensional Array of JuMP variables; it cannot be a DenseAxisArray or a SparseAxisArray. (See Variable containers, above, for more on this.)","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"You can also impose a weaker constraint that the square matrix is only symmetric (instead of positive semidefinite) as follows:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2], Symmetric)\n2×2 LinearAlgebra.Symmetric{VariableRef,Array{VariableRef,2}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"You can impose a constraint that the square matrix is skew symmetric with SkewSymmetricMatrixSpace:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2] in SkewSymmetricMatrixSpace())\n2×2 Array{GenericAffExpr{Float64,VariableRef},2}:\n 0        x[1,2]\n -x[1,2]  0","category":"page"},{"location":"variables/#Anonymous-JuMP-variables","page":"Variables","title":"Anonymous JuMP variables","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"In all of the above examples, we have created named JuMP variables. However, it is also possible to create so called anonymous JuMP variables. To create an anonymous JuMP variable, we drop the name of the variable from the macro call. This means dropping the second positional argument if the JuMP variable is a scalar, or dropping the name before the square bracket ([) if a container is being created. For example:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> x = @variable(model)\nnoname","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"This shows how @variable(model, x) is really short for:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> x = model[:x] = @variable(model, base_name=\"x\")\nx","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"An Array of anonymous JuMP variables can be created as follows:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> y = @variable(model, [i=1:2])\n2-element Array{VariableRef,1}:\n noname\n noname","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"If necessary, you can store x in model as follows:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> model[:x] = x","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"The <= and >= short-hand cannot be used to set bounds on anonymous JuMP variables. Instead, you should use the lower_bound and upper_bound keywords.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Passing the Bin and Int variable types are also invalid. Instead, you should use the binary and integer keywords.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Thus, the anonymous variant of @variable(model, x[i=1:2] >= i, Int) is:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> x = @variable(model, [i=1:2], base_name=\"x\", lower_bound=i, integer=true)\n2-element Array{VariableRef,1}:\n x[1]\n x[2]","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"warn: Warn\nCreating two named JuMP variables with the same name results in an error at runtime. Use anonymous variables as an alternative.","category":"page"},{"location":"variables/#Variables-constrained-on-creation","page":"Variables","title":"Variables constrained on creation","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"info: Info\nWhen using JuMP in Direct mode, it may be required to constrain variables on creation instead of constraining free variables as the solver may only support variables constrained on creation. In Automatic and Manual modes, both ways of adding constraints on variables are equivalent. Indeed, during the copy of the cache to the optimizer, the choice of the constraints on variables that are copied as variables constrained on creation does not depend on how it was added to the cache.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"All uses of the @variable macro documented so far translate to a separate call for variable creation and adding of constraints.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"For example, @variable(model, x >= 0, Int), is equivalent to:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"@variable(model, x)\nset_lower_bound(x, 0.0)\n@constraint(model, x in MOI.Integer())","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Importantly, the bound and integrality constraints are added after the variable has been created.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"However, some solvers require a constraining set at creation time. We say that these variables are constrained on creation.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Use in within @variable to access the special syntax for constraining variables on creation. For example, the following creates a vector of variables constrained on creation to belong to the SecondOrderCone:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, y[1:3] in SecondOrderCone())\n3-element Array{VariableRef,1}:\n y[1]\n y[2]\n y[3]","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"For contrast, the more standard approach is as follows:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in SecondOrderCone())\n[x[1], x[2], x[3]] ∈ MathOptInterface.SecondOrderCone(3)","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"The technical difference between the former and the latter is that the former calls MOI.add_constrained_variables while the latter calls MOI.add_variables and then MOI.add_constraint. This distinction is important only in Direct mode, depending on the solver being used. It's often not possible to delete the SecondOrderCone constraint if it was specified at variable creation time.","category":"page"},{"location":"variables/#The-set-keyword","page":"Variables","title":"The set keyword","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"An alternate syntax to x in Set is to use the set keyword of @variable. This is most useful when creating anonymous variables:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"x = @variable(model, [1:2, 1:2], set = PSDCone())","category":"page"},{"location":"variables/#User-defined-containers","page":"Variables","title":"User-defined containers","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"In the section Variable containers, we explained how JuMP supports the efficient creation of collections of JuMP variables in three types of containers. However, users are also free to create collections of JuMP variables in their own datastructures. For example, the following code creates a dictionary with symmetric matrices as the values:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> variables = Dict{Symbol, Array{VariableRef,2}}()\nDict{Symbol,Array{VariableRef,2}} with 0 entries\n\njulia> for key in [:A, :B]\n           global variables[key] = @variable(model, [1:2, 1:2])\n       end\n\njulia> variables\nDict{Symbol,Array{VariableRef,2}} with 2 entries:\n  :A => VariableRef[noname noname; noname noname]\n  :B => VariableRef[noname noname; noname noname]","category":"page"},{"location":"variables/#Deleting-variables","page":"Variables","title":"Deleting variables","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"JuMP supports the deletion of optimization variables.  To delete variables, we can use the delete method. We can also check whether x is a valid JuMP variable in model using the is_valid method:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x)\nx\n\njulia> is_valid(model, x)\ntrue\n\njulia> delete(model, x)\n\njulia> is_valid(model, x)\nfalse","category":"page"},{"location":"variables/#Listing-all-variables","page":"Variables","title":"Listing all variables","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"Use JuMP.all_variables to obtain a list of all variables present in the model. This is useful for performing operations like:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"relaxing all integrality constraints in the model\nsetting the starting values for variables to the result of the last solve","category":"page"},{"location":"variables/#Start-values","page":"Variables","title":"Start values","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"There are two ways to provide a primal starting solution (also called MIP-start or a warmstart) for each variable:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"using the start keyword in the @variable macro\nusing set_start_value","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"The starting value of a variable can be queried using start_value. If no start value has been set, start_value will return nothing.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x)\nx\n\njulia> start_value(x)\n\njulia> @variable(model, y, start = 1)\ny\n\njulia> start_value(y)\n1.0\n\njulia> set_start_value(y, 2)\n\njulia> start_value(y)\n2.0","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"note: Note\nPrior to JuMP 0.19, the previous solution to a solve was automatically set as the new starting value. JuMP 0.19 no longer does this automatically. To reproduce the functionality, use:set_start_value.(all_variables(model), value.(all_variables(model)))","category":"page"},{"location":"variables/#variables","page":"Variables","title":"The @variables macro","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"If you have many @variable calls, JuMP provides the macro @variables that can improve readability:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variables(model, begin\n           x\n           y[i=1:2] >= i, (start = i, base_name = \"Y_$i\")\n           z, Bin\n       end)\n\njulia> print(model)\nFeasibility\nSubject to\n Y_1[1] ≥ 1.0\n Y_2[2] ≥ 2.0\n z binary","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"note: Note\nKeyword arguments must be contained within parentheses. (See the example above.)","category":"page"},{"location":"reference/moi/#MathOptInterface-API","page":"MathOptInterface API","title":"MathOptInterface API","text":"","category":"section"},{"location":"reference/moi/","page":"MathOptInterface API","title":"MathOptInterface API","text":"This page contains extracts from the MathOptInterface documentation. More information can be found at in the MathOptInterface documentation.","category":"page"},{"location":"reference/moi/","page":"MathOptInterface API","title":"MathOptInterface API","text":"MOI.CallbackNodeStatus\nMOI.CallbackNodeStatusCode\nMOI.CallbackVariablePrimal\n\nMOI.get","category":"page"},{"location":"reference/moi/#MathOptInterface.CallbackNodeStatus","page":"MathOptInterface API","title":"MathOptInterface.CallbackNodeStatus","text":"CallbackNodeStatus(callback_data)\n\nAn optimizer attribute describing the (in)feasibility of the primal solution available from CallbackVariablePrimal during a callback identified by callback_data.\n\nReturns a CallbackNodeStatusCode Enum.\n\n\n\n\n\n","category":"type"},{"location":"reference/moi/#MathOptInterface.CallbackNodeStatusCode","page":"MathOptInterface API","title":"MathOptInterface.CallbackNodeStatusCode","text":"CallbackNodeStatusCode\n\nAn Enum of possible return values from calling get with CallbackNodeStatus.\n\nPossible values are:\n\nCALLBACKNODESTATUS_INTEGER: the primal solution available from CallbackVariablePrimal is integer feasible.\nCALLBACKNODESTATUS_FRACTIONAL: the primal solution available from CallbackVariablePrimal is integer infeasible.\nCALLBACKNODESTATUS_UNKNOWN: the primal solution available from CallbackVariablePrimal might be integer feasible or infeasible.\n\n\n\n\n\n","category":"type"},{"location":"reference/moi/#MathOptInterface.CallbackVariablePrimal","page":"MathOptInterface API","title":"MathOptInterface.CallbackVariablePrimal","text":"CallbackVariablePrimal(callback_data)\n\nA variable attribute for the assignment to some primal variable's value during the callback identified by callback_data.\n\n\n\n\n\n","category":"type"},{"location":"reference/moi/#MathOptInterface.get","page":"MathOptInterface API","title":"MathOptInterface.get","text":"get(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute)\n\nReturn an attribute attr of the optimizer optimizer.\n\nget(model::ModelLike, attr::AbstractModelAttribute)\n\nReturn an attribute attr of the model model.\n\nget(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex)\n\nIf the attribute attr is set for the variable v in the model model, return its value, return nothing otherwise. If the attribute attr is not supported by model then an error should be thrown instead of returning nothing.\n\nget(model::ModelLike, attr::AbstractVariableAttribute, v::Vector{VariableIndex})\n\nReturn a vector of attributes corresponding to each variable in the collection v in the model model.\n\nget(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex)\n\nIf the attribute attr is set for the constraint c in the model model, return its value, return nothing otherwise. If the attribute attr is not supported by model then an error should be thrown instead of returning nothing.\n\nget(model::ModelLike, attr::AbstractConstraintAttribute, c::Vector{ConstraintIndex{F,S}})\n\nReturn a vector of attributes corresponding to each constraint in the collection c in the model model.\n\nget(model::ModelLike, ::Type{VariableIndex}, name::String)\n\nIf a variable with name name exists in the model model, return the corresponding index, otherwise return nothing. Errors if two variables have the same name.\n\nget(model::ModelLike, ::Type{ConstraintIndex{F,S}}, name::String) where {F<:AbstractFunction,S<:AbstractSet}\n\nIf an F-in-S constraint with name name exists in the model model, return the corresponding index, otherwise return nothing. Errors if two constraints have the same name.\n\nget(model::ModelLike, ::Type{ConstraintIndex}, name::String)\n\nIf any constraint with name name exists in the model model, return the corresponding index, otherwise return nothing. This version is available for convenience but may incur a performance penalty because it is not type stable. Errors if two constraints have the same name.\n\nExamples\n\nget(model, ObjectiveValue())\nget(model, VariablePrimal(), ref)\nget(model, VariablePrimal(5), [ref1, ref2])\nget(model, OtherAttribute(\"something specific to cplex\"))\nget(model, VariableIndex, \"var1\")\nget(model, ConstraintIndex{ScalarAffineFunction{Float64},LessThan{Float64}}, \"con1\")\nget(model, ConstraintIndex, \"con1\")\n\n\n\n\n\n","category":"function"},{"location":"examples/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/factory_schedule.jl\"","category":"page"},{"location":"examples/factory_schedule/#The-factory-schedule-example","page":"The factory schedule example","title":"The factory schedule example","text":"","category":"section"},{"location":"examples/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"This is a Julia translation of part 5 from \"Introduction to to Linear Programming with Python\" available at https://github.com/benalexkeen/Introduction-to-linear-programming","category":"page"},{"location":"examples/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"For 2 factories (A, B), minimize the cost of production over the course of 12 months while meeting monthly demand. Factory B has a planned outage during month 5.","category":"page"},{"location":"examples/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"It was originally contributed by @Crghilardi.","category":"page"},{"location":"examples/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_factory_schedule()\n   # Sets in the problem:\n   months, factories = 1:12, [:A, :B]\n   # This function takes a matrix and converts it to a JuMP container so we can\n   # refer to elements such as `d_max_cap[1, :A]`.\n   containerize(A::Matrix) = Containers.DenseAxisArray(A, months, factories)\n   # Maximum production capacity in (month, factory) [units/month]:\n   d_max_cap = containerize([\n         100000\t50000;\n         110000\t55000;\n         120000\t60000;\n         145000\t100000;\n         160000\t0;\n         140000\t70000;\n         155000\t60000;\n         200000\t100000;\n         210000\t100000;\n         197000\t100000;\n         80000\t120000;\n         150000\t150000;\n   ])\n   # Minimum production capacity in (month, factory) [units/month]:\n   d_min_cap = containerize([\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t0;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n   ])\n   # Variable cost of production in (month, factory) [$/unit]:\n   d_var_cost = containerize([\n         10\t5;\n         11\t4;\n         12\t3;\n         9\t5;\n         8\t0;\n         8\t6;\n         5\t4;\n         7\t6;\n         9\t8;\n         10\t11;\n         8\t10;\n         8\t12\n   ])\n   # Fixed cost of production in (month, factory) # [$/month]:\n   d_fixed_cost = containerize([\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t0;\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t600\n   ])\n   # Demand in each month [units/month]:\n   d_demand = [\n      120_000,\n      100_000,\n      130_000,\n      130_000,\n      140_000,\n      130_000,\n      150_000,\n      170_000,\n      200_000,\n      190_000,\n      140_000,\n      100_000,\n   ]\n   # The model!\n   model = Model(GLPK.Optimizer)\n   # Decision variables\n   @variables(model, begin\n      status[m in months, f in factories], Bin\n      production[m in months, f in factories], Int\n   end)\n   # The production cannot be less than minimum capacity.\n   @constraint(\n      model,\n      [m in months, f in factories],\n      production[m, f] >= d_min_cap[m, f] * status[m, f],\n   )\n   # The production cannot be more tha maximum capacity.\n   @constraint(\n      model,\n      [m in months, f in factories],\n      production[m, f] <= d_max_cap[m, f] * status[m, f],\n   )\n   # The production must equal demand in a given month.\n   @constraint(model, [m in months], sum(production[m, :]) == d_demand[m])\n   # Factory B is shut down during month 5, so production and status are both\n   # zero.\n   fix(status[5, :B], 0.0)\n   fix(production[5, :B], 0.0)\n   # The objective is to minimize the cost of production across all time\n   ##periods.\n   @objective(\n      model,\n      Min,\n      sum(\n         d_fixed_cost[m, f] * status[m, f] + d_var_cost[m, f] * production[m, f]\n         for m in months, f in factories\n      )\n   )\n   # Optimize the problem\n   optimize!(model)\n   # Check the solution!\n   Test.@testset \"Check the solution against known optimal\" begin\n      Test.@test termination_status(model) == MOI.OPTIMAL\n      Test.@test objective_value(model) == 12_906_400.0\n      Test.@test value.(production)[1, :A] == 70_000\n      Test.@test value.(status)[1, :A] == 1\n      Test.@test value.(status)[5, :B] == 0\n      Test.@test value.(production)[5, :B] == 0\n   end\n   println(\"The production schedule is:\")\n   println(value.(production))\n   return\nend\n\nexample_factory_schedule()","category":"page"},{"location":"examples/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"View this file on Github.","category":"page"},{"location":"examples/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"","category":"page"},{"location":"examples/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"DocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"expressions/#Expressions","page":"Expressions","title":"Expressions","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"JuMP has three types of expressions: affine, quadratic, and nonlinear. These expressions can be inserted into constraints or into the objective. This is particularly useful if an expression is used in multiple places in the model.","category":"page"},{"location":"expressions/#Affine-expressions","page":"Expressions","title":"Affine expressions","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"There are four ways of constructing an affine expression in JuMP: with the @expression macro, with operator overloading, with the AffExpr constructor, and with add_to_expression!.","category":"page"},{"location":"expressions/#Macros","page":"Expressions","title":"Macros","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"The recommended way to create an affine expression is via the @expression macro.","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = @expression(model, 2x + y - 1)\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"This expression can be used in the objective or added to a constraint. For example:","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"@objective(model, Min, 2 * ex - 1)\nobjective_function(model)\n\n# output\n\n4 x + 2 y - 3","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"Just like variables and constraints, named expressions can also be created. For example","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x[i = 1:3])\n@expression(model, expr[i = 1:3], i * sum(x[j] for j in i:3))\nexpr\n\n# output\n\n3-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x[1] + x[2] + x[3]\n 2 x[2] + 2 x[3]\n 3 x[3]","category":"page"},{"location":"expressions/#Operator-overloading","page":"Expressions","title":"Operator overloading","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"Expressions can also be created without macros. However, note that in some cases, this can be much slower that constructing an expression using macros.","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = 2x + y - 1\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"expressions/#Constructors","page":"Expressions","title":"Constructors","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"A third way to create an affine expression is by the AffExpr constructor. The first argument is the constant term, and the remaining arguments are variable-coefficient pairs.","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = AffExpr(-1.0, x => 2.0, y => 1.0)\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"expressions/#add_to_expression!","page":"Expressions","title":"add_to_expression!","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"The fourth way to create an affine expression is by using add_to_expression!. Compared to the operator overloading method, this approach is faster because it avoids constructing temporary objects. The @expression macro uses add_to_expression! behind-the-scenes.","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = AffExpr(-1.0)\nadd_to_expression!(ex, 2.0, x)\nadd_to_expression!(ex, 1.0, y)\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"expressions/#Removing-zero-terms","page":"Expressions","title":"Removing zero terms","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"Use drop_zeros! to remove terms from an affine expression with a 0 coefficient.","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @expression(model, ex, x + 1 - x)\n0 x + 1\n\njulia> drop_zeros!(ex)\n\njulia> ex\n1","category":"page"},{"location":"expressions/#Quadratic-expressions","page":"Expressions","title":"Quadratic expressions","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"Like affine expressions, there are four ways of constructing a quadratic expression in JuMP: macros, operator overloading, constructors, and add_to_expression!.","category":"page"},{"location":"expressions/#Macros-2","page":"Expressions","title":"Macros","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"The @expression macro can be used to create quadratic expressions by including quadratic terms.","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = @expression(model, x^2 + 2 * x * y + y^2 + x + y - 1)\n\n# output\n\nx² + 2 y*x + y² + x + y - 1","category":"page"},{"location":"expressions/#Operator-overloading-2","page":"Expressions","title":"Operator overloading","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"Operator overloading can also be used to create quadratic expressions. The same performance warning (discussed in the affine expression section) applies.","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = x^2 + 2 * x * y + y^2 + x + y - 1\n\n# output\n\nx² + 2 x*y + y² + x + y - 1","category":"page"},{"location":"expressions/#Constructors-2","page":"Expressions","title":"Constructors","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"Quadratic expressions can also be created using the QuadExpr constructor. The first argument is an affine expression, and the remaining arguments are pairs, where the first term is a JuMP.UnorderedPair and the second term is the coefficient.","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\naff_expr = AffExpr(-1.0, x => 1.0, y => 1.0)\nquad_expr = QuadExpr(aff_expr, UnorderedPair(x, x) => 1.0,\n                     UnorderedPair(x, y) => 2.0, UnorderedPair(y, y) => 1.0)\n\n# output\n\nx² + 2 x*y + y² + x + y - 1","category":"page"},{"location":"expressions/#add_to_expression!-2","page":"Expressions","title":"add_to_expression!","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"Finally, add_to_expression! can also be used to add quadratic terms.","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = QuadExpr(x + y - 1.0)\nadd_to_expression!(ex, 1.0, x, x)\nadd_to_expression!(ex, 2.0, x, y)\nadd_to_expression!(ex, 1.0, y, y)\n\n# output\n\nx² + 2 x*y + y² + x + y - 1","category":"page"},{"location":"expressions/#Removing-zero-terms-2","page":"Expressions","title":"Removing zero terms","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"Use drop_zeros! to remove terms from a quadratic expression with a 0 coefficient.","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @expression(model, ex, x^2 + x + 1 - x^2)\n0 x² + x + 1\n\njulia> drop_zeros!(ex)\n\njulia> ex\nx + 1","category":"page"},{"location":"expressions/#Nonlinear-expressions","page":"Expressions","title":"Nonlinear expressions","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"Nonlinear expressions can be constructed only using the @NLexpression macro and can be used only in @NLobjective, @NLconstraint, and other @NLexpressions. Moreover, quadratic and affine expressions cannot be used in the nonlinear macros. For more details, see the Nonlinear Modeling section.","category":"page"},{"location":"examples/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/knapsack.jl\"","category":"page"},{"location":"examples/knapsack/#The-knapsack-problem","page":"The knapsack problem","title":"The knapsack problem","text":"","category":"section"},{"location":"examples/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"Formulate and solve a simple knapsack problem:","category":"page"},{"location":"examples/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"max sum(p_j x_j)\n st sum(w_j x_j) <= C\n    x binary","category":"page"},{"location":"examples/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_knapsack(; verbose = true)\n    profit = [5, 3, 2, 7, 4]\n    weight = [2, 8, 4, 2, 5]\n    capacity = 10\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:5], Bin)\n    # Objective: maximize profit\n    @objective(model, Max, profit' * x)\n    # Constraint: can carry all\n    @constraint(model, weight' * x <= capacity)\n    # Solve problem using MIP solver\n    optimize!(model)\n    if verbose\n        println(\"Objective is: \", objective_value(model))\n        println(\"Solution is:\")\n        for i in 1:5\n            print(\"x[$i] = \", value(x[i]))\n            println(\", p[$i]/w[$i] = \", profit[i] / weight[i])\n        end\n    end\n    Test.@test termination_status(model) == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) == 16.0\n    return\nend\n\nexample_knapsack()","category":"page"},{"location":"examples/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"View this file on Github.","category":"page"},{"location":"examples/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"","category":"page"},{"location":"examples/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/constraints/#Constraint-API","page":"Constraint API","title":"Constraint API","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraint API","title":"Constraint API","text":"More information can be found in the Constraints section of the manual.","category":"page"},{"location":"reference/constraints/","page":"Constraint API","title":"Constraint API","text":"@constraint\n@constraints\n@SDconstraint\n@SDconstraints\n\nname(::ConstraintRef{Model,<:JuMP._MOICON})\nset_name(::ConstraintRef{Model,<:JuMP._MOICON}, ::String)\nconstraint_by_name\n\nnormalized_coefficient\nset_normalized_coefficient\n\nnormalized_rhs\nset_normalized_rhs\n\nadd_to_function_constant\n\nis_valid\nJuMP.delete\n\nlist_of_constraint_types\n\nall_constraints\n\nnum_constraints\n\nset_dual_start_value\ndual_start_value\n\nConstraintRef\n\nSecondOrderCone\nRotatedSecondOrderCone\nPSDCone\nSOS1\nSOS2\nSkewSymmetricMatrixSpace\nSkewSymmetricMatrixShape\n\nAbstractConstraint\nScalarConstraint\nVectorConstraint\n\nindex(::ConstraintRef)\noptimizer_index(::ConstraintRef{Model})\n\nconstraint_object\nmoi_set\n\nfunction_string\nconstraints_string\nin_set_string\nshow_constraints_summary\n\nConstraintNotOwned","category":"page"},{"location":"reference/constraints/#JuMP.@constraint","page":"Constraint API","title":"JuMP.@constraint","text":"@constraint(m::Model, expr)\n\nAdd a constraint described by the expression expr.\n\n@constraint(m::Model, ref[i=..., j=..., ...], expr)\n\nAdd a group of constraints described by the expression expr parametrized by i, j, ...\n\nThe expression expr can either be\n\nof the form func in set constraining the function func to belong to the set set which is either a MOI.AbstractSet or one of the JuMP shortcuts SecondOrderCone, RotatedSecondOrderCone and PSDCone, e.g. @constraint(model, [1, x-1, y-2] in SecondOrderCone()) constrains the norm of [x-1, y-2] be less than 1;\nof the form a sign b, where sign is one of ==, ≥, >=, ≤ and <= building the single constraint enforcing the comparison to hold for the expression a and b, e.g. @constraint(m, x^2 + y^2 == 1) constrains x and y to lie on the unit circle;\nof the form a ≤ b ≤ c or a ≥ b ≥ c (where ≤ and <= (resp. ≥ and >=) can be used interchangeably) constraining the paired the expression b to lie between a and c;\nof the forms @constraint(m, a .sign b) or @constraint(m, a .sign b .sign c) which broadcast the constraint creation to each element of the vectors.\n\nNote for extending the constraint macro\n\nEach constraint will be created using add_constraint(m, build_constraint(_error, func, set)) where\n\n_error is an error function showing the constraint call in addition to the error message given as argument,\nfunc is the expression that is constrained\nand set is the set in which it is constrained to belong.\n\nFor expr of the first type (i.e. @constraint(m, func in set)), func and set are passed unchanged to build_constraint but for the other types, they are determined from the expressions and signs. For instance, @constraint(m, x^2 + y^2 == 1) is transformed into add_constraint(m, build_constraint(_error, x^2 + y^2, MOI.EqualTo(1.0))).\n\nTo extend JuMP to accept new constraints of this form, it is necessary to add the corresponding methods to build_constraint. Note that this will likely mean that either func or set will be some custom type, rather than e.g. a Symbol, since we will likely want to dispatch on the type of the function or set appearing in the constraint.\n\n\n\n\n\n","category":"macro"},{"location":"reference/constraints/#JuMP.@constraints","page":"Constraint API","title":"JuMP.@constraints","text":"@constraints(model, args...)\n\nAdds groups of constraints at once, in the same fashion as the @constraint macro.\n\nThe model must be the first argument, and multiple constraints can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@constraints(model, begin\n    x >= 1\n    y - w <= 2\n    sum_to_one[i=1:3], z[i] + y == 1\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/constraints/#JuMP.@SDconstraint","page":"Constraint API","title":"JuMP.@SDconstraint","text":"@SDconstraint(model::Model, expr)\n\nAdd a semidefinite constraint described by the expression expr.\n\n@SDconstraint(model::Model, ref[i=..., j=..., ...], expr)\n\nAdd a group of semidefinite constraints described by the expression expr parametrized by i, j, ...\n\nThe expression expr needs to be of the form a sign b where sign is ⪰, ≥, >=, ⪯, ≤ or <= and a and b are square matrices. It constrains the square matrix x (or -x if the sign is ⪯, ≤ or <=) to be symmetric and positive semidefinite where\n\nx = a, if b is the symbol 0,\nx = -b, if a is the symbol 0,\notherwise, x = a - b.\n\nBy default, we check numerical symmetry of the matrix x, and if symmetry is violated by some arbitrary amount, we add explicit equality constraints. You can use Symmetric(x) in PSDCone() with the @constraint macro to skip these checks if you know the matrix must be symmetric; see PSDCone for more information.\n\nExamples\n\nThe following constrains the matrix [x-1 2x-2; -3 x-4] to be symmetric and positive semidefinite, that is, it constrains 2x-2 to be equal to -3 and constrains all eigenvalues of the matrix to be nonnegative.\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> a = [x 2x\n            0  x];\n\njulia> b = [1 2\n            3 4];\n\njulia> cref = @SDconstraint(model, a ⪰ b)\n[x - 1  2 x - 2;\n -3     x - 4  ] ∈ PSDCone()\n\njulia> jump_function(constraint_object(cref))\n4-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n -3\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeSquare(2)\n\nIn the set PositiveSemidefiniteConeSquare(2) in the last output, Square means that the matrix is passed as a square matrix as the corresponding off-diagonal entries need to be constrained to be equal. A similar set PositiveSemidefiniteConeTriangle exists which only uses the upper triangular part of the matrix assuming that it is symmetric, see PSDCone to see how to use it.\n\n\n\n\n\n","category":"macro"},{"location":"reference/constraints/#JuMP.@SDconstraints","page":"Constraint API","title":"JuMP.@SDconstraints","text":"@SDconstraints(model, args...)\n\nAdds multiple semi-definite constraints to model at once, in the same fashion as the @SDconstraint macro.\n\nThe model must be the first argument, and multiple constraints can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@SDconstraints(model, begin\n    A * x >= b\n    b - C * y >= 0\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/constraints/#JuMP.name-Tuple{ConstraintRef{Model,#s760,Shape} where Shape<:AbstractShape where #s760<:MathOptInterface.ConstraintIndex}","page":"Constraint API","title":"JuMP.name","text":"name(con_ref::ConstraintRef)\n\nGet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"reference/constraints/#JuMP.set_name-Tuple{ConstraintRef{Model,#s760,Shape} where Shape<:AbstractShape where #s760<:MathOptInterface.ConstraintIndex,String}","page":"Constraint API","title":"JuMP.set_name","text":"set_name(con_ref::ConstraintRef, s::AbstractString)\n\nSet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"reference/constraints/#JuMP.constraint_by_name","page":"Constraint API","title":"JuMP.constraint_by_name","text":"constraint_by_name(model::AbstractModel,\n                   name::String)::Union{ConstraintRef, Nothing}\n\nReturns the reference of the constraint with name attribute name or Nothing if no constraint has this name attribute. Throws an error if several constraints have name as their name attribute.\n\nconstraint_by_name(model::AbstractModel,\n                   name::String,\n                   F::Type{<:Union{AbstractJuMPScalar,\n                                   Vector{<:AbstractJuMPScalar},\n                                   MOI.AbstactFunction}},\n                   S::Type{<:MOI.AbstractSet})::Union{ConstraintRef, Nothing}\n\nSimilar to the method above, except that it throws an error if the constraint is not an F-in-S contraint where F is either the JuMP or MOI type of the function, and S is the MOI type of the set. This method is recommended if you know the type of the function and set since its returned type can be inferred while for the method above (i.e. without F and S), the exact return type of the constraint index cannot be inferred.\n\njulia> using JuMP\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x^2 == 1)\ncon : x² = 1.0\n\njulia> constraint_by_name(model, \"kon\")\n\njulia> constraint_by_name(model, \"con\")\ncon : x² = 1.0\n\njulia> constraint_by_name(model, \"con\", AffExpr, MOI.EqualTo{Float64})\n\njulia> constraint_by_name(model, \"con\", QuadExpr, MOI.EqualTo{Float64})\ncon : x² = 1.0\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.normalized_coefficient","page":"Constraint API","title":"JuMP.normalized_coefficient","text":"normalized_coefficient(con_ref::ConstraintRef, variable::VariableRef)\n\nReturn the coefficient associated with variable in constraint after JuMP has normalized the constraint into its standard form. See also set_normalized_coefficient.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.set_normalized_coefficient","page":"Constraint API","title":"JuMP.set_normalized_coefficient","text":"set_normalized_coefficient(con_ref::ConstraintRef, variable::VariableRef, value)\n\nSet the coefficient of variable in the constraint constraint to value.\n\nNote that prior to this step, JuMP will aggregate multiple terms containing the same variable. For example, given a constraint 2x + 3x <= 2, set_normalized_coefficient(con, x, 4) will create the constraint 4x <= 2.\n\nmodel = Model()\n@variable(model, x)\n@constraint(model, con, 2x + 3x <= 2)\nset_normalized_coefficient(con, x, 4)\ncon\n\n# output\n\ncon : 4 x <= 2.0\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.normalized_rhs","page":"Constraint API","title":"JuMP.normalized_rhs","text":"normalized_rhs(con_ref::ConstraintRef)\n\nReturn the right-hand side term of con_ref after JuMP has converted the constraint into its normalized form. See also set_normalized_rhs.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.set_normalized_rhs","page":"Constraint API","title":"JuMP.set_normalized_rhs","text":"set_normalized_rhs(con_ref::ConstraintRef, value)\n\nSet the right-hand side term of constraint to value.\n\nNote that prior to this step, JuMP will aggregate all constant terms onto the right-hand side of the constraint. For example, given a constraint 2x + 1 <= 2, set_normalized_rhs(con, 4) will create the constraint 2x <= 4, not 2x + 1 <= 4.\n\njulia> @constraint(model, con, 2x + 1 <= 2)\ncon : 2 x <= 1.0\n\njulia> set_normalized_rhs(con, 4)\n\njulia> con\ncon : 2 x <= 4.0\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.add_to_function_constant","page":"Constraint API","title":"JuMP.add_to_function_constant","text":"add_to_function_constant(constraint::ConstraintRef, value)\n\nAdd value to the function constant term.\n\nNote that for scalar constraints, JuMP will aggregate all constant terms onto the right-hand side of the constraint so instead of modifying the function, the set will be translated by -value. For example, given a constraint 2x <= 3, add_to_function_constant(c, 4) will modify it to 2x <= -1.\n\nExamples\n\nFor scalar constraints, the set is translated by -value:\n\njulia> @constraint(model, con, 0 <= 2x - 1 <= 2)\ncon : 2 x ∈ [1.0, 3.0]\n\njulia> add_to_function_constant(con, 4)\n\njulia> con\ncon : 2 x ∈ [-3.0, -1.0]\n\nFor vector constraints, the constant is added to the function:\n\njulia> @constraint(model, con, [x + y, x, y] in SecondOrderCone())\ncon : [x + y, x, y] ∈ MathOptInterface.SecondOrderCone(3)\n\njulia> add_to_function_constant(con, [1, 2, 2])\n\njulia> con\ncon : [x + y + 1, x + 2, y + 2] ∈ MathOptInterface.SecondOrderCone(3)\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.is_valid","page":"Constraint API","title":"JuMP.is_valid","text":"is_valid(model::Model, con_ref::ConstraintRef{Model})\n\nReturn true if constraint_ref refers to a valid constraint in model.\n\n\n\n\n\nis_valid(model::Model, variable_ref::VariableRef)\n\nReturn true if variable refers to a valid variable in model.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.delete","page":"Constraint API","title":"JuMP.delete","text":"delete(model::Model, con_ref::ConstraintRef)\n\nDelete the constraint associated with constraint_ref from the model model.\n\nSee also: unregister\n\n\n\n\n\ndelete(model::Model, con_refs::Vector{<:ConstraintRef})\n\nDelete the constraints associated with con_refs from the model model. Solvers may implement specialized methods for deleting multiple constraints of the same concrete type, i.e., when isconcretetype(eltype(con_refs)). These may be more efficient than repeatedly calling the single constraint delete method.\n\nSee also: unregister\n\n\n\n\n\ndelete(model::Model, variable_ref::VariableRef)\n\nDelete the variable associated with variable_ref from the model model.\n\nSee also: unregister\n\n\n\n\n\ndelete(model::Model, variable_refs::Vector{VariableRef})\n\nDelete the variables associated with variable_refs from the model model. Solvers may implement methods for deleting multiple variables that are more efficient than repeatedly calling the single variable delete method.\n\nSee also: unregister\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.list_of_constraint_types","page":"Constraint API","title":"JuMP.list_of_constraint_types","text":"list_of_constraint_types(model::Model)::Vector{Tuple{DataType, DataType}}\n\nReturn a list of tuples of the form (F, S) where F is a JuMP function type and S is an MOI set type such that all_constraints(model, F, S) returns a nonempty list.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> list_of_constraint_types(model)\n3-element Array{Tuple{DataType,DataType},1}:\n (GenericAffExpr{Float64,VariableRef}, MathOptInterface.LessThan{Float64})\n (VariableRef, MathOptInterface.GreaterThan{Float64})\n (VariableRef, MathOptInterface.ZeroOne)\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.all_constraints","page":"Constraint API","title":"JuMP.all_constraints","text":"all_constraints(model::Model, function_type, set_type)::Vector{<:ConstraintRef}\n\nReturn a list of all constraints currently in the model where the function has type function_type and the set has type set_type. The constraints are ordered by creation time.\n\nSee also list_of_constraint_types and num_constraints.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> all_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}},ScalarShape},1}:\n x ≥ 0.0\n\njulia> all_constraints(model, VariableRef, MOI.ZeroOne)\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.ZeroOne},ScalarShape},1}:\n x binary\n\njulia> all_constraints(model, AffExpr, MOI.LessThan{Float64})\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n 2 x ≤ 1.0\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.num_constraints","page":"Constraint API","title":"JuMP.num_constraints","text":"num_constraints(model::Model, function_type, set_type)::Int64\n\nReturn the number of constraints currently in the model where the function has type function_type and the set has type set_type.\n\nSee also list_of_constraint_types and all_constraints.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @variable(model, y);\n\njulia> @constraint(model, y in MOI.GreaterThan(1.0));\n\njulia> @constraint(model, y <= 1.0);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> num_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n2\n\njulia> num_constraints(model, VariableRef, MOI.ZeroOne)\n1\n\njulia> num_constraints(model, AffExpr, MOI.LessThan{Float64})\n2\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.set_dual_start_value","page":"Constraint API","title":"JuMP.set_dual_start_value","text":"set_dual_start_value(con_ref::ConstraintRef, value)\n\nSet the dual start value (MOI attribute ConstraintDualStart) of the constraint con_ref to value. To remove a dual start value set it to nothing.\n\nSee also dual_start_value.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.dual_start_value","page":"Constraint API","title":"JuMP.dual_start_value","text":"dual_start_value(con_ref::ConstraintRef)\n\nReturn the dual start value (MOI attribute ConstraintDualStart) of the constraint con_ref.\n\nNote: If no dual start value has been set, dual_start_value will return nothing.\n\nSee also set_dual_start_value.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.ConstraintRef","page":"Constraint API","title":"JuMP.ConstraintRef","text":"ConstraintRef\n\nHolds a reference to the model and the corresponding MOI.ConstraintIndex.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SecondOrderCone","page":"Constraint API","title":"JuMP.SecondOrderCone","text":"SecondOrderCone\n\nSecond order cone object that can be used to constrain the euclidean norm of a vector x to be less than or equal to a nonnegative scalar t. This is a shortcut for the MOI.SecondOrderCone.\n\nExamples\n\nThe following constrains (x-1 x-2)_2 le t and t ge 0:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, t)\nt\n\njulia> @constraint(model, [t, x-1, x-2] in SecondOrderCone())\n[t, x - 1, x - 2] ∈ MathOptInterface.SecondOrderCone(3)\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.RotatedSecondOrderCone","page":"Constraint API","title":"JuMP.RotatedSecondOrderCone","text":"RotatedSecondOrderCone\n\nRotated second order cone object that can be used to constrain the square of the euclidean norm of a vector x to be less than or equal to 2tu where t and u are nonnegative scalars. This is a shortcut for the MOI.RotatedSecondOrderCone.\n\nExamples\n\nThe following constrains (x-1 x-2)_2 le 2tx and t x ge 0:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, t)\nt\n\njulia> @constraint(model, [t, x, x-1, x-2] in RotatedSecondOrderCone())\n[t, x, x - 1, x - 2] ∈ MathOptInterface.RotatedSecondOrderCone(4)\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.PSDCone","page":"Constraint API","title":"JuMP.PSDCone","text":"PSDCone\n\nPositive semidefinite cone object that can be used to constrain a square matrix to be positive semidefinite in the @constraint macro. If the matrix has type Symmetric then the columns vectorization (the vector obtained by concatenating the columns) of its upper triangular part is constrained to belong to the MOI.PositiveSemidefiniteConeTriangle set, otherwise its column vectorization is constrained to belong to the MOI.PositiveSemidefiniteConeSquare set.\n\nExamples\n\nConsider the following example:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> a = [ x 2x\n            2x  x];\n\njulia> b = [1 2\n            2 4];\n\njulia> cref = @SDconstraint(model, a ⪰ b)\n[x - 1    2 x - 2;\n 2 x - 2  x - 4  ] ∈ PSDCone()\n\njulia> jump_function(constraint_object(cref))\n4-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n 2 x - 2\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeSquare(2)\n\nWe see in the output of the last command that the matrix the vectorization of the matrix is constrained to belong to the PositiveSemidefiniteConeSquare.\n\njulia> using LinearAlgebra # For Symmetric\n\njulia> cref = @constraint(model, Symmetric(a - b) in PSDCone())\n[x - 1    2 x - 2;\n 2 x - 2  x - 4  ] ∈ PSDCone()\n\njulia> jump_function(constraint_object(cref))\n3-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeTriangle(2)\n\nAs we see in the output of the last command, the vectorization of only the upper triangular part of the matrix is constrained to belong to the PositiveSemidefiniteConeSquare.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SOS1","page":"Constraint API","title":"JuMP.SOS1","text":"SOS1\n\nSOS1 (Special Ordered Sets type 1) object than can be used to constrain a vector x to a set where at most 1 variable can take a non-zero value, all others being at 0. The weights, when specified, induce an ordering of the variables; as such, they should be unique values. The kth element in the set corresponds to the kth weight in weights. See here for a description of SOS constraints and their potential uses. This is a shortcut for the MathOptInterface.SOS1 set.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SOS2","page":"Constraint API","title":"JuMP.SOS2","text":"SOS2\n\nSOS1 (Special Ordered Sets type 2) object than can be used to constrain a vector x to a set where at most 2 variables can take a non-zero value, all others being at 0. In addition, if two are non-zero these must be consecutive in their ordering. The weights induce an ordering of the variables; as such, they should be unique values. The kth element in the set corresponds to the kth weight in weights. See here for a description of SOS constraints and their potential uses. This is a shortcut for the MathOptInterface.SOS2 set.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SkewSymmetricMatrixSpace","page":"Constraint API","title":"JuMP.SkewSymmetricMatrixSpace","text":"SkewSymmetricMatrixSpace()\n\nUse in the @variable macro to constrain a matrix of variables to be skew-symmetric.\n\nExamples\n\n@variable(model, Q[1:2, 1:2] in SkewSymmetricMatrixSpace())\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SkewSymmetricMatrixShape","page":"Constraint API","title":"JuMP.SkewSymmetricMatrixShape","text":"SkewSymmetricMatrixShape\n\nShape object for a skew symmetric square matrix of side_dimension rows and columns. The vectorized form contains the entries of the upper-right triangular part of the matrix (without the diagonal) given column by column (or equivalently, the entries of the lower-left triangular part given row by row). The diagonal is zero.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.AbstractConstraint","page":"Constraint API","title":"JuMP.AbstractConstraint","text":"abstract type AbstractConstraint\n\nAn abstract base type for all constraint types. AbstractConstraints store the function and set directly, unlike ConstraintRefs that are merely references to constraints stored in a model. AbstractConstraints do not need to be attached to a model.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.ScalarConstraint","page":"Constraint API","title":"JuMP.ScalarConstraint","text":"struct ScalarConstraint\n\nThe data for a scalar constraint. The func field containts a JuMP object representing the function and the set field contains the MOI set. See also the documentation on JuMP's representation of constraints for more background.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.VectorConstraint","page":"Constraint API","title":"JuMP.VectorConstraint","text":"struct VectorConstraint\n\nThe data for a vector constraint. The func field containts a JuMP object representing the function and the set field contains the MOI set. The shape field contains an AbstractShape matching the form in which the constraint was constructed (e.g., by using matrices or flat vectors). See also the documentation on JuMP's representation of constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.index-Tuple{ConstraintRef}","page":"Constraint API","title":"JuMP.index","text":"index(cr::ConstraintRef)::MOI.ConstraintIndex\n\nReturn the index of the constraint that corresponds to cr in the MOI backend.\n\n\n\n\n\n","category":"method"},{"location":"reference/constraints/#JuMP.optimizer_index-Tuple{ConstraintRef{Model,C,Shape} where Shape<:AbstractShape where C}","page":"Constraint API","title":"JuMP.optimizer_index","text":"optimizer_index(cr::ConstraintRef{Model})::MOI.ConstraintIndex\n\nReturn the index of the constraint that corresponds to cr in the optimizer model. It throws NoOptimizer if no optimizer is set and throws an ErrorException if the optimizer is set but is not attached or if the constraint is bridged.\n\n\n\n\n\n","category":"method"},{"location":"reference/constraints/#JuMP.constraint_object","page":"Constraint API","title":"JuMP.constraint_object","text":"constraint_object(con_ref::ConstraintRef)\n\nReturn the underlying constraint data for the constraint referenced by ref.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.moi_set","page":"Constraint API","title":"JuMP.moi_set","text":"moi_set(constraint::AbstractConstraint)\n\nReturn the set of the constraint constraint in the function-in-set form as a MathOptInterface.AbstractSet.\n\nmoi_set(s::AbstractVectorSet, dim::Int)\n\nReturns the MOI set of dimension dim corresponding to the JuMP set s.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.function_string","page":"Constraint API","title":"JuMP.function_string","text":"function_string(print_mode::Type{<:JuMP.PrintMode},\n                func::Union{JuMP.AbstractJuMPScalar,\n                            Vector{<:JuMP.AbstractJuMPScalar}})\n\nReturn a String representing the function func using print mode print_mode.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.constraints_string","page":"Constraint API","title":"JuMP.constraints_string","text":"constraints_string(print_mode, model::AbstractModel)::Vector{String}\n\nReturn a list of Strings describing each constraint of the model.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.in_set_string","page":"Constraint API","title":"JuMP.in_set_string","text":"in_set_string(print_mode::Type{<:JuMP.PrintMode},\n              set::Union{PSDCone, MOI.AbstractSet})\n\nReturn a String representing the membership to the set set using print mode print_mode.\n\n\n\n\n\nin_set_string(print_mode::Type{<:JuMP.PrintMode},\n              constraint::JuMP.AbstractConstraint)\n\nReturn a String representing the membership to the set of the constraint constraint using print mode print_mode.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.show_constraints_summary","page":"Constraint API","title":"JuMP.show_constraints_summary","text":"show_constraints_summary(io::IO, model::AbstractModel)\n\nWrite to io a summary of the number of constraints.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.ConstraintNotOwned","page":"Constraint API","title":"JuMP.ConstraintNotOwned","text":"struct ConstraintNotOwned{C <: ConstraintRef} <: Exception\n    constraint_ref::C\nend\n\nThe constraint constraint_ref was used in a model different to owner_model(constraint_ref).\n\n\n\n\n\n","category":"type"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"CurrentModule = JuMP","category":"page"},{"location":"extensions/#Extending-JuMP","page":"Extensions","title":"Extending JuMP","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"# TODO: How to extend JuMP: discussion on different ways to build on top of JuMP.\n# How to extend JuMP's macros and how to avoid doing this.","category":"page"},{"location":"extensions/#Extending-MOI","page":"Extensions","title":"Extending MOI","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"# TODO: Create new MOI function/sets, how to use it in JuMP","category":"page"},{"location":"extensions/#Adding-a-bridge","page":"Extensions","title":"Adding a bridge","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"# TODO: create new bridge","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"See the bridge section in the MOI manual.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"add_bridge\nBridgeableConstraint","category":"page"},{"location":"extensions/#JuMP.add_bridge","page":"Extensions","title":"JuMP.add_bridge","text":" add_bridge(model::Model,\n            BridgeType::Type{<:MOI.Bridges.AbstractBridge})\n\nAdd BridgeType to the list of bridges that can be used to transform unsupported constraints into an equivalent formulation using only constraints supported by the optimizer.\n\n\n\n\n\n","category":"function"},{"location":"extensions/#JuMP.BridgeableConstraint","page":"Extensions","title":"JuMP.BridgeableConstraint","text":"struct BridgeableConstraint{C, B} <: AbstractConstraint\n    constraint::C\n    bridge_type::B\nend\n\nConstraint constraint that can be bridged by the bridge of type bridge_type. Adding this constraint to a model is equivalent to\n\nadd_bridge(model, bridge_type)\nadd_constraint(model, constraint)\n\nExamples\n\nGiven a new scalar set type CustomSet with a bridge CustomBridge that can bridge F-in-CustomSet constraints, when the user does\n\nmodel = Model()\n@variable(model, x)\n@constraint(model, x + 1 in CustomSet())\noptimize!(model)\n\nwith an optimizer that does not support F-in-CustomSet constraints, the constraint will not be bridged unless he manually calls add_bridge(model, CustomBridge). In order to automatically add the CustomBridge to any model to which an F-in-CustomSet is added, simply add the following method:\n\nfunction JuMP.build_constraint(_error::Function, func::AbstractJuMPScalar,\n                               set::CustomSet)\n    constraint = ScalarConstraint(func, set)\n    return JuMP.BridgeableConstraint(constraint, CustomBridge)\nend\n\nNote\n\nJuMP extensions should extend JuMP.build_constraint only if they also defined CustomSet, for three reasons:\n\nIt is problematic if multiple extensions overload the same JuMP method.\nA missing method will not inform the users that they forgot to load the extension module defining the build_constraint method.\nDefining a method where neither the function nor any of the argument types are defined in the package is called type piracy and is discouraged in the Julia style guide.\n\n\n\n\n\n","category":"type"},{"location":"extensions/#Extending-JuMP-macros","page":"Extensions","title":"Extending JuMP macros","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"In order to provide a convenient syntax for the user to create variables, constraints or set the objective of a JuMP extension, it might be required to use macros similar to @variable, @constraint and @objective. It is recommended to first check whether it is possible to extend one of these three macros before creating a new one so as to leverage all their features and provide a more consistent interface to the user.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"### Extending the `@variable` macro\n\n# TODO: parse/build/add","category":"page"},{"location":"extensions/#Extending-the-@constraint-macro","page":"Extensions","title":"Extending the @constraint macro","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"The @constraint macro always calls the same three functions:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"parse_constraint: is called at parsing time, it parses the constraint expression and returns a build_constraint call expression;\nbuild_constraint: given the functions and sets involved in the constraints, it returns a AbstractConstraint;\nadd_constraint: given the model, the AbstractConstraint constructed in build_constraint and the constraint name, it stores them in the model and returns a ConstraintRef.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Adding methods to these functions is the recommended way to extend the @constraint macro.","category":"page"},{"location":"extensions/#Adding-parse_constraint-methods","page":"Extensions","title":"Adding parse_constraint methods","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"# TODO(Benoît): Detail how `parse_constraint` works and show how `sense_to_set`\n#               fits into the picture.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"sense_to_set","category":"page"},{"location":"extensions/#JuMP.sense_to_set","page":"Extensions","title":"JuMP.sense_to_set","text":"sense_to_set(_error::Function, ::Val{sense_symbol})\n\nConverts a sense symbol to a set set such that @constraint(model, func sense_symbol 0) is equivalent to @constraint(model, func in set) for any func::AbstractJuMPScalar.\n\nExample\n\nOnce a custom set is defined you can directly create a JuMP constraint with it:\n\njulia> struct CustomSet{T} <: MOI.AbstractScalarSet\n           value::T\n       end\n\njulia> Base.copy(x::CustomSet) = CustomSet(x.value)\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> cref = @constraint(model, x in CustomSet(1.0))\nx ∈ CustomSet{Float64}(1.0)\n\nHowever, there might be an appropriate sign that could be used in order to provide a more convenient syntax:\n\njulia> JuMP.sense_to_set(::Function, ::Val{:⊰}) = CustomSet(0.0)\n\njulia> MOIU.shift_constant(set::CustomSet, value) = CustomSet(set.value + value)\n\njulia> cref = @constraint(model, x ⊰ 1)\nx ∈ CustomSet{Float64}(1.0)\n\nNote that the whole function is first moved to the right-hand side, then the sign is transformed into a set with zero constant and finally the constant is moved to the set with MOIU.shift_constant.\n\n\n\n\n\n","category":"function"},{"location":"extensions/#Adding-build_constraint-methods","page":"Extensions","title":"Adding build_constraint methods","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"There are typically two choices when creating a build_constraint method, either return an AbstractConstraint already supported by the model, i.e. ScalarConstraint or VectorConstraint, or a custom AbstractConstraint with a corresponding add_constraint method (see Adding add_constraint methods).","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"build_constraint","category":"page"},{"location":"extensions/#JuMP.build_constraint","page":"Extensions","title":"JuMP.build_constraint","text":"build_constraint(_error::Function, Q::Symmetric{V, M},\n                 ::PSDCone) where {V <: AbstractJuMPScalar,\n                                   M <: AbstractMatrix{V}}\n\nReturn a VectorConstraint of shape SymmetricMatrixShape constraining the matrix Q to be positive semidefinite.\n\nThis function is used by the @constraint macros as follows:\n\n@constraint(model, Symmetric(Q) in PSDCone())\n\nThe form above is usually used when the entries of Q are affine or quadratic expressions, but it can also be used when the entries are variables to get the reference of the semidefinite constraint, e.g.,\n\n@variable model Q[1:2,1:2] Symmetric\n# The type of `Q` is `Symmetric{VariableRef, Matrix{VariableRef}}`\nvar_psd = @constraint model Q in PSDCone()\n# The `var_psd` variable contains a reference to the constraint\n\n\n\n\n\nbuild_constraint(_error::Function,\n                 Q::AbstractMatrix{<:AbstractJuMPScalar},\n                 ::PSDCone)\n\nReturn a VectorConstraint of shape SquareMatrixShape constraining the matrix Q to be symmetric and positive semidefinite.\n\nThis function is used by the @constraint and @SDconstraint macros as follows:\n\n@constraint(model, Q in PSDCone())\n@SDconstraint(model, P ⪰ Q)\n\nThe @constraint call above is usually used when the entries of Q are affine or quadratic expressions, but it can also be used when the entries are variables to get the reference of the semidefinite constraint, e.g.,\n\n@variable model Q[1:2,1:2]\n# The type of `Q` is `Matrix{VariableRef}`\nvar_psd = @constraint model Q in PSDCone()\n# The `var_psd` variable contains a reference to the constraint\n\n\n\n\n\n","category":"function"},{"location":"extensions/#Shapes","page":"Extensions","title":"Shapes","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Shapes allow vector constraints, which are represented as flat vectors in MOI, to retain a matrix shape at the JuMP level. There is a shape field in VectorConstraint that can be set in build_constraint and that is used to reshape the result computed in value and dual.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"AbstractShape\nshape\nreshape_vector\nreshape_set\ndual_shape\nScalarShape\nVectorShape\nSquareMatrixShape\nSymmetricMatrixShape","category":"page"},{"location":"extensions/#JuMP.AbstractShape","page":"Extensions","title":"JuMP.AbstractShape","text":"AbstractShape\n\nAbstract vectorizable shape. Given a flat vector form of an object of shape shape, the original object can be obtained by reshape_vector.\n\n\n\n\n\n","category":"type"},{"location":"extensions/#JuMP.shape","page":"Extensions","title":"JuMP.shape","text":"shape(c::AbstractConstraint)::AbstractShape\n\nReturn the shape of the constraint c.\n\n\n\n\n\n","category":"function"},{"location":"extensions/#JuMP.reshape_vector","page":"Extensions","title":"JuMP.reshape_vector","text":"reshape_vector(vectorized_form::Vector, shape::AbstractShape)\n\nReturn an object in its original shape shape given its vectorized form vectorized_form.\n\nExamples\n\nGiven a SymmetricMatrixShape of vectorized form [1, 2, 3], the following code returns the matrix Symmetric(Matrix[1 2; 2 3]):\n\njulia> reshape_vector([1, 2, 3], SymmetricMatrixShape(2))\n2×2 LinearAlgebra.Symmetric{Int64,Array{Int64,2}}:\n 1  2\n 2  3\n\n\n\n\n\n","category":"function"},{"location":"extensions/#JuMP.reshape_set","page":"Extensions","title":"JuMP.reshape_set","text":"reshape_set(vectorized_set::MOI.AbstractSet, shape::AbstractShape)\n\nReturn a set in its original shape shape given its vectorized form vectorized_form.\n\nExamples\n\nGiven a SymmetricMatrixShape of vectorized form [1, 2, 3] in MOI.PositiveSemidefinieConeTriangle(2), the following code returns the set of the original constraint Symmetric(Matrix[1 2; 2 3]) in PSDCone():\n\njulia> reshape_set(MOI.PositiveSemidefiniteConeTriangle(2), SymmetricMatrixShape(2))\nPSDCone()\n\n\n\n\n\n","category":"function"},{"location":"extensions/#JuMP.dual_shape","page":"Extensions","title":"JuMP.dual_shape","text":"dual_shape(shape::AbstractShape)::AbstractShape\n\nReturns the shape of the dual space of the space of objects of shape shape. By default, the dual_shape of a shape is itself. See the examples section below for an example for which this is not the case.\n\nExamples\n\nConsider polynomial constraints for which the dual is moment constraints and moment constraints for which the dual is polynomial constraints. Shapes for polynomials can be defined as follows:\n\nstruct Polynomial\n    coefficients::Vector{Float64}\n    monomials::Vector{Monomial}\nend\nstruct PolynomialShape <: AbstractShape\n    monomials::Vector{Monomial}\nend\nJuMP.reshape_vector(x::Vector, shape::PolynomialShape) = Polynomial(x, shape.monomials)\n\nand a shape for moments can be defined as follows:\n\nstruct Moments\n    coefficients::Vector{Float64}\n    monomials::Vector{Monomial}\nend\nstruct MomentsShape <: AbstractShape\n    monomials::Vector{Monomial}\nend\nJuMP.reshape_vector(x::Vector, shape::MomentsShape) = Moments(x, shape.monomials)\n\nThen dual_shape allows the definition of the shape of the dual of polynomial and moment constraints:\n\ndual_shape(shape::PolynomialShape) = MomentsShape(shape.monomials)\ndual_shape(shape::MomentsShape) = PolynomialShape(shape.monomials)\n\n\n\n\n\n","category":"function"},{"location":"extensions/#JuMP.ScalarShape","page":"Extensions","title":"JuMP.ScalarShape","text":"ScalarShape\n\nShape of scalar constraints.\n\n\n\n\n\n","category":"type"},{"location":"extensions/#JuMP.VectorShape","page":"Extensions","title":"JuMP.VectorShape","text":"VectorShape\n\nVector for which the vectorized form corresponds exactly to the vector given.\n\n\n\n\n\n","category":"type"},{"location":"extensions/#JuMP.SquareMatrixShape","page":"Extensions","title":"JuMP.SquareMatrixShape","text":"SquareMatrixShape\n\nShape object for a square matrix of side_dimension rows and columns. The vectorized form contains the entries of the the matrix given column by column (or equivalently, the entries of the lower-left triangular part given row by row).\n\n\n\n\n\n","category":"type"},{"location":"extensions/#JuMP.SymmetricMatrixShape","page":"Extensions","title":"JuMP.SymmetricMatrixShape","text":"SymmetricMatrixShape\n\nShape object for a symmetric square matrix of side_dimension rows and columns. The vectorized form contains the entries of the upper-right triangular part of the matrix given column by column (or equivalently, the entries of the lower-left triangular part given row by row).\n\n\n\n\n\n","category":"type"},{"location":"extensions/#Adding-add_constraint-methods","page":"Extensions","title":"Adding add_constraint methods","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"# TODO: Introduce `add_constraint`","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"add_constraint","category":"page"},{"location":"extensions/#JuMP.add_constraint","page":"Extensions","title":"JuMP.add_constraint","text":"add_constraint(model::Model, con::AbstractConstraint, name::String=\"\")\n\nAdd a constraint con to Model model and sets its name.\n\n\n\n\n\n","category":"function"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"### Extending the [`@objective`](@ref) macro\n\n# TODO: Describe how to `@objective` macro by implementing new `JuMP.set_objective_function` methods\n\n## Defining new JuMP models\n\n# TODO: Describe how to create a new JuMP model (similar to `test/JuMPExtension.jl` and StructJuMP).","category":"page"},{"location":"examples/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/steelT3.jl\"","category":"page"},{"location":"examples/steelT3/#The-SteelT3-problem","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"","category":"section"},{"location":"examples/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"The steelT3 model from AMPL: A Modeling Language for Mathematical Programming, 2nd ed by Robert Fourer, David Gay, and Brian W. Kernighan.","category":"page"},{"location":"examples/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"Originally contributed by Louis Luangkesorn, April 3, 2015.","category":"page"},{"location":"examples/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_steelT3(; verbose = true)\n    T = 4\n    prod = [\"bands\", \"coils\"]\n    area = Dict(\n        \"bands\" => (\"east\", \"north\"),\n        \"coils\" => (\"east\", \"west\", \"export\")\n    )\n    avail = [40, 40, 32, 40]\n    rate = Dict(\"bands\" => 200, \"coils\" => 140)\n    inv0 = Dict(\"bands\" => 10, \"coils\" => 0)\n    prodcost = Dict(\"bands\" => 10, \"coils\" => 11)\n    invcost = Dict(\"bands\" => 2.5, \"coils\" => 3)\n    revenue = Dict(\n        \"bands\" => Dict(\n            \"east\" => [25.0, 26.0, 27.0, 27.0],\n            \"north\" => [26.5, 27.5, 28.0, 28.5],\n        ),\n        \"coils\" => Dict(\n            \"east\" =>[30, 35, 37, 39],\n            \"west\" => [29, 32, 33, 35],\n            \"export\" => [25, 25, 25, 28],\n        )\n    )\n    market = Dict(\n        \"bands\" => Dict(\n            \"east\" => [2000, 2000, 1500, 2000],\n            \"north\" => [4000, 4000, 2500, 4500],\n        ),\n        \"coils\" => Dict(\n            \"east\" => [1000, 800, 1000, 1100],\n            \"west\" => [2000, 1200, 2000, 2300],\n            \"export\" => [1000, 500, 500, 800],\n        )\n    )\n    # Model\n    model = Model(GLPK.Optimizer)\n    # Decision Variables\n    @variables(model, begin\n        make[p in prod, t in 1:T] >= 0\n        inventory[p in prod, t in 0:T] >= 0\n        0 <= sell[p in prod, a in area[p], t in 1:T] <= market[p][a][t]\n    end)\n    @constraints(model, begin\n        [p = prod, a = area[p], t = 1:T], sell[p, a, t] <= market[p][a][t]\n        # Total of hours used by all products may not exceed hours available,\n        # in each week\n        [t in 1:T], sum(1 / rate[p] * make[p, t] for p in prod) <= avail[t]\n        # Initial inventory must equal given value\n        [p in prod], inventory[p, 0] == inv0[p]\n        # Tons produced and taken from inventory must equal tons sold and put\n        # into inventory.\n        [p in prod, t in 1:T], make[p, t] + inventory[p, t - 1] == sum(sell[p, a, t] for a in area[p]) + inventory[p, t]\n    end)\n    # Maximize total profit: total revenue less costs for all products in all\n    # weeks.\n    @objective(\n        model,\n        Max,\n        sum(\n            revenue[p][a][t] * sell[p, a, t] -\n            prodcost[p] * make[p, t] -\n            invcost[p] * inventory[p, t]\n            for p in prod, a in area[p], t in 1:T\n        )\n    )\n    optimize!(model)\n    Test.@test termination_status(model) == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) == 172850.0\n    if verbose\n        println(\"RESULTS:\")\n        for p in prod\n            println(\"make $(p)\")\n            for t in 1:T\n                print(value(make[p, t]), \"\\t\")\n            end\n            println()\n            println(\"Inventory $(p)\")\n            for t in 1:T\n                print(value(inventory[p, t]), \"\\t\")\n            end\n            println()\n            for a in area[p]\n                println(\"sell $(p) $(a)\")\n            for t in 1:T\n                print(value(sell[p, a, t]), \"\\t\")\n            end\n            println()\n            end\n        end\n    end\n    return\nend\n\nexample_steelT3()","category":"page"},{"location":"examples/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"View this file on Github.","category":"page"},{"location":"examples/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"","category":"page"},{"location":"examples/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/cluster.jl\"","category":"page"},{"location":"examples/cluster/#K-means-clustering-via-SDP","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"","category":"section"},{"location":"examples/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"From \"Approximating K-means-type clustering via semidefinite programming\" By Jiming Peng and Yu Wei.","category":"page"},{"location":"examples/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"Given a set of points a_1 ldots a_m  in R_n, allocate them to k clusters.","category":"page"},{"location":"examples/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"using JuMP\nimport LinearAlgebra\nimport SCS\n\nfunction example_cluster(; verbose = true)\n    # Data points\n    n = 2\n    m = 6\n    a = Any[\n        [2.0, 2.0], [2.5, 2.1], [7.0, 7.0], [2.2, 2.3], [6.8, 7.0], [7.2, 7.5]\n    ]\n    k = 2\n    # Weight matrix\n    W = zeros(m, m)\n    for i in 1:m\n        for j in i + 1:m\n            W[i, j] = W[j, i] = exp(-LinearAlgebra.norm(a[i] - a[j]) / 1.0)\n        end\n    end\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    # Z >= 0, PSD\n    @variable(model, Z[1:m, 1:m], PSD)\n    @constraint(model, Z .>= 0)\n    # min Tr(W(I-Z))\n    I = Matrix(1.0 * LinearAlgebra.I, m, m)\n    @objective(model, Min, LinearAlgebra.tr(W * (I - Z)))\n    # Z e = e\n    @constraint(model, Z * ones(m) .== ones(m))\n    # Tr(Z) = k\n    @constraint(model, LinearAlgebra.tr(Z) == k)\n    optimize!(model)\n    Z_val = value.(Z)\n    # A simple rounding scheme\n    which_cluster = zeros(Int, m)\n    num_clusters = 0\n    for i in 1:m\n        Z_val[i, i] <= 1e-6 && continue\n        if which_cluster[i] == 0\n            num_clusters += 1\n            which_cluster[i] = num_clusters\n            for j in i + 1:m\n                if LinearAlgebra.norm(Z_val[i, j] - Z_val[i, i]) <= 1e-6\n                    which_cluster[j] = num_clusters\n                end\n            end\n        end\n    end\n    if verbose\n        # Print results\n        for cluster in 1:k\n            println(\"Cluster $cluster\")\n            for i in 1:m\n                if which_cluster[i] == cluster\n                    println(a[i])\n                end\n            end\n        end\n    end\n    return\nend\n\nexample_cluster()","category":"page"},{"location":"examples/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"View this file on Github.","category":"page"},{"location":"examples/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"","category":"page"},{"location":"examples/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"This page was generated using Literate.jl.","category":"page"},{"location":"installation/#Installation-Guide","page":"Installation Guide","title":"Installation Guide","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"info: Info\nInstallation troubles? Check the Common installation issues section below.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"JuMP is a package for Julia. To use JuMP, first download and install Julia.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nThis version of JuMP is compatible with Julia 1.0 and later.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"From Julia, JuMP is installed using the built-in package manager:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.add(\"JuMP\")","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"tip: Tip\nWe recommend you create a Pkg environment for each project you use JuMP for, instead of adding lots of packages to the global environment. The Pkg manager documentation has more information on this topic.","category":"page"},{"location":"installation/#Installing-a-solver","page":"Installation Guide","title":"Installing a solver","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"JuMP depends on solvers to solve optimization problems, and you will need to install one before you can solve problems with JuMP. The table below lists the currently available solvers.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Install a solver using the Julia package manager, replacing \"Clp\" by the Julia package name as appropriate.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.add(\"Clp\")","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Once installed, you can use Clp as a solver with JuMP as follows, using set_optimizer_attributes to set solver-specific options:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"using JuMP\nusing Clp\nmodel = Model(Clp.Optimizer)\nset_optimizer_attributes(model, \"LogLevel\" => 1, \"PrimalTolerance\" => 1e-7)","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nMost packages follow the ModuleName.Optimizer naming convention, but exceptions may exist. See the README of the Julia package's Github repository for more details on how to use a particular solver, including any solver-specific options.","category":"page"},{"location":"installation/#Supported-solvers","page":"Installation Guide","title":"Supported solvers","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Most solvers are not written in Julia, and some require commercial licenses to use, so installation is often more complex.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"If a solver has Manual in the Installation column, the solver requires a manual installation step, such as downloading and installing a binary, or obtaining a commercial license. Consult the README of the relevant Julia package for more information.\nIf the solver has Manualᴹ in the Installation column, the solver requires an installation of MATLAB.\nIf the Installation column is missing an entry, installing the Julia package will download and install any relevant solver binaries automatically, and you shouldn't need to do anything other than Pkg.add.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Solvers with a missing entry in the Julia Package column are written in Julia. The link in the Solver column is the corresponding Julia package.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Solver Julia Package Installation License Supports\nAlpine.jl   Triad NS (MI)NLP\nArtelys Knitro KNITRO.jl Manual Comm. (MI)LP, (MI)SOCP, (MI)NLP\nBARON BARON.jl Manual Comm. (MI)NLP\nCbc Cbc.jl  EPL (MI)LP\nCDCS CDCS.jl Manualᴹ GPL LP, SOCP, SDP\nCDD CDDLib.jl  GPL LP\nClp Clp.jl  EPL LP\nCOSMO.jl   Apache LP, QP, SOCP, SDP\nCPLEX CPLEX.jl Manual Comm. (MI)LP, (MI)SOCP\nCSDP CSDP.jl  EPL LP, SDP\nEAGO.jl   CC BY-NC-SA NLP\nECOS ECOS.jl  GPL LP, SOCP\nFICO Xpress Xpress.jl Manual Comm. (MI)LP, (MI)SOCP\nGLPK GLPK.jl  GPL (MI)LP\nGurobi Gurobi.jl Manual Comm. (MI)LP, (MI)SOCP\nHypatia.jl   MIT LP, SOCP, SDP\nIpopt Ipopt.jl  EPL LP, QP, NLP\nJuniper.jl   MIT (MI)SOCP, (MI)NLP\nMOSEK MosekTools.jl Manual Comm. (MI)LP, (MI)SOCP, SDP\nNLopt NLopt.jl  GPL LP, QP, NLP\nOSQP OSQP.jl  Apache LP, QP\nPATH PATHSolver.jl  MIT MCP\nPavito.jl   MPL-2 (MI)NLP\nProxSDP.jl   MIT LP, SOCP, SDP\nSCIP SCIP.jl Manual ZIB (MI)LP, (MI)NLP\nSCS SCS.jl  MIT LP, SOCP, SDP\nSDPA SDPA.jl, SDPAFamily.jl  GPL LP, SDP\nSDPNAL SDPNAL.jl Manualᴹ CC BY-SA LP, SDP\nSDPT3 SDPT3.jl Manualᴹ GPL LP, SOCP, SDP\nSeDuMi SeDuMi.jl Manualᴹ GPL LP, SOCP, SDP\nTulip.jl   MPL-2 LP","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Where:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"LP = Linear programming\nQP = Quadratic programming\nSOCP = Second-order conic programming (including problems with convex quadratic constraints and/or objective)\nMCP = Mixed-complementarity programming\nNLP = Nonlinear programming\nSDP = Semidefinite programming\n(MI)XXX = Mixed-integer equivalent of problem type XXX","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nDeveloped a solver or solver wrapper? This table is open for new contributions! Start by making a pull request to edit the installation.md file.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nDeveloping a solver or solver wrapper? See Interacting with solvers and the MathOptInterface docs for more details on how JuMP interacts with solvers. Please get in touch via the Developer Chatroom with any questions about connecting new solvers with JuMP.","category":"page"},{"location":"installation/#Solver-specific-notes","page":"Installation Guide","title":"Solver-specific notes","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Artelys Knitro","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a license.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"BARON","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a license. A trial version is available for small problem instances.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"CDD","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"CDD can solve the problem both using Float64 and Rational{BigInt} arithmetics. The arithmetic used the type T given in CDDLib.Optimizer{T}. Only CDDLib.Optimizer{Float64} can be used with JuMP as JuMP inputs the problem in Float64 arithmetics. Use MOI directly for CDDLib.Optimizer{Rational{BigInt}}.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"COIN-OR Cbc","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Cbc supports \"SOS\" constraints.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"COSMO","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"COSMO can solve LPs, QPs, SOCPs and SDPs. It can handle SDPs with quadratic objective functions and supports chordal decomposition of large structured PSD constraints. COSMO is a first order method that performs well on large problems but has a low accuracy by default (10^4). See the COSMO.jl documentation for more information.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"CPLEX","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a working installation of CPLEX with a license (free for faculty members and graduate teaching assistants). CPLEX supports \"SOS\" constraints.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"ECOS","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"ECOS can be used by JuMP to solve LPs and SOCPs. ECOS does not support general quadratic objectives or constraints, only second-order conic constraints specified by using the SecondOrderCone set.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Gurobi","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a working installation of Gurobi with an activated license (free for academic use). Gurobi supports \"SOS\" constraints.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"FICO Xpress","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a working installation of Xpress with an active license (it is possible to get a license for academic use, see FICO Academic Partner Program). Supports SOCP and \"SOS\" constraints.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"MOSEK","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a license (free for academic use). The Mosek interface is maintained by the Mosek team. (Thanks!) Note that even if the package implementing MathOptInterface is MosekTools, for consistency the MOI optimizer is called Mosek.Optimizer so do the following to create a model with the Mosek solver:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"using MosekTools\nmodel = Model(Mosek.Optimizer)","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"ProxSDP","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"ProxSDP solves general SDP problems by means of a first order proximal algorithm based on the primal-dual hybrid gradient, also known as Chambolle-Pock method. The main advantage of ProxSDP over other state-of-the-art solvers is the ability to exploit the low-rank property inherent to several SDP problems. ProxSDP is a first order solver and has low accuracy. See the ProxSDP.jl documentation for more information.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"SCS","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"SCS can be used by JuMP to solve LPs and SOCPs, and SDPs. SCS is a first order solver and has low accuracy (10^4) by default; see the SCS.jl documentation for more information.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"SDPA","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"SDPA is a second order solver which comes in several variants. The main version has a C++ interface which SDPA.jl uses for efficiently communicating the problem instance to the solver. The three high-precision variants, SDPA-GMP (arbitrary precision), SDPA-QD (\"quad-double\" precision) and SDPA-DD (\"double-double\" precision) do not expose a library interface, but can used via SDPAFamily.jl, which writes and reads files to interact with the solver binary.","category":"page"},{"location":"installation/#AMPL-and-GAMS","page":"Installation Guide","title":"AMPL and GAMS","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Use AmplNLWriter to access solvers that support the nl format. Such solvers include Bonmin and Couenne. See a more complete list here.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Use GAMS.jl to access solvers available through GAMS. Such solvers include: AlphaECP, Antigone, BARON, CONOPT, Couenne, LocalSolver, PATHNLP, SHOT, SNOPT, SoPlex. See a complete list here.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nGAMS.jl requires an installation of the commercial software GAMS for which a free community license exists.","category":"page"},{"location":"installation/#Previously-supported-solvers","page":"Installation Guide","title":"Previously supported solvers","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"The following solvers were compatible with JuMP up to release 0.18 but are not yet compatible with the latest version because they do not implement the new MathOptInterface API:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Pajarito","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Please join the Developer Chatroom if you have interest in reviving a previously supported solver.","category":"page"},{"location":"installation/#Common-installation-issues","page":"Installation Guide","title":"Common installation issues","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"tip: Tip\nWhen in doubt, run import Pkg; Pkg.update() to see if updating your packages fixes the issue. Remember you will need to exit Julia and start a new session for the changes to take effect.","category":"page"},{"location":"installation/#Check-the-version-of-your-packages","page":"Installation Guide","title":"Check the version of your packages","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Each package is versioned with a three-part number of the  form vX.Y.Z. You can check which versions you have installed with import Pkg; Pkg.status().","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"This should almost always be the most-recent release. You can check the releases of a package by going to the relevant Github page, and navigating to the \"releases\" page. For example, the list of JuMP releases is available at: https://github.com/jump-dev/JuMP.jl/releases.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"If you post on the community forum, please include the output of Pkg.status()!","category":"page"},{"location":"installation/#Unsatisfiable-requirements-detected","page":"Installation Guide","title":"Unsatisfiable requirements detected","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Did you get an error like Unsatisfiable requirements detected for package JuMP? The Pkg documentation has a section on how to understand and manage these conflicts.","category":"page"},{"location":"installation/#Installing-new-packages-can-make-JuMP-downgrade-to-an-earlier-version","page":"Installation Guide","title":"Installing new packages can make JuMP downgrade to an earlier version","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Another common complaint is that after adding a new package, code that previously worked no longer works.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"This usually happens because the new package is not compatible with the latest version of JuMP. Therefore, the package manager rolls-back JuMP to an earlier version! Here's an example.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"First, we add JuMP:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"(jump_example) pkg> add JuMP\n  Resolving package versions...\nUpdating `~/jump_example/Project.toml`\n  [4076af6c] + JuMP v0.21.5\nUpdating `~/jump_example/Manifest.toml`\n  ... lines omitted ...","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"The + JuMP v0.21.5 line indicates that JuMP has been added at version 0.21.5. However, watch what happens when we add JuMPeR:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"(jump_example) pkg> add JuMPeR\n  Resolving package versions...\nUpdating `~/jump_example/Project.toml`\n  [4076af6c] ↓ JuMP v0.21.5 ⇒ v0.18.6\n  [707a9f91] + JuMPeR v0.6.0\nUpdating `~/jump_example/Manifest.toml`\n  ... lines omitted ...","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"JuMPeR gets added at version 0.6.0 (+ JuMPeR v0.6.0), but JuMP gets downgraded from 0.21.5 to 0.18.6 (↓ JuMP v0.21.5 ⇒ v0.18.6)! The reason for this is that JuMPeR doesn't support a version of JuMP newer than 0.18.6.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"tip: Tip\nPay careful attention to the output of the package manager when adding new packages, especially when you see a package being downgraded!","category":"page"},{"location":"reference/solutions/#Solution-API","page":"Solution API","title":"Solution API","text":"","category":"section"},{"location":"reference/solutions/","page":"Solution API","title":"Solution API","text":"More information can be found in the Querying Solutions section of the manual.","category":"page"},{"location":"reference/solutions/","page":"Solution API","title":"Solution API","text":"JuMP.optimize!\nNoOptimizer\n\ntermination_status\nMOI.TerminationStatusCode\n\nraw_status\nprimal_status\nMOI.ResultStatusCode\n\nresult_count\n\nhas_values\nvalue\n\ndual_status\nhas_duals\ndual\nshadow_price\nreduced_cost\n\nobjective_bound\nobjective_value\ndual_objective_value\n\nsolve_time\nrelative_gap\nsimplex_iterations\nbarrier_iterations\nnode_count\n\nOptimizeNotCalled\nMOI.optimize!\n\nJuMP.compute_conflict!\nMOI.compute_conflict!\nMOI.ConflictStatus\nMOI.ConflictStatusCode\nMOI.ConstraintConflictStatus\nMOI.ConflictParticipationStatusCode\n\nlp_objective_perturbation_range\nlp_rhs_perturbation_range\nlp_sensitivity_report\nSensitivityReport","category":"page"},{"location":"reference/solutions/#JuMP.optimize!","page":"Solution API","title":"JuMP.optimize!","text":"optimize!(model::Model;\n          ignore_optimize_hook=(model.optimize_hook === nothing),\n          kwargs...)\n\nOptimize the model. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nKeyword arguments kwargs are passed to the optimize_hook. An error is thrown if optimize_hook is nothing and keyword arguments are provided.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.NoOptimizer","page":"Solution API","title":"JuMP.NoOptimizer","text":"struct NoOptimizer <: Exception end\n\nNo optimizer is set. The optimizer can be provided to the Model constructor or by calling set_optimizer.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#JuMP.termination_status","page":"Solution API","title":"JuMP.termination_status","text":"termination_status(model::Model)\n\nReturn the reason why the solver stopped (i.e., the MathOptInterface model attribute TerminationStatus).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#MathOptInterface.TerminationStatusCode","page":"Solution API","title":"MathOptInterface.TerminationStatusCode","text":"TerminationStatusCode\n\nAn Enum of possible values for the TerminationStatus attribute. This attribute is meant to explain the reason why the optimizer stopped executing in the most recent call to optimize!.\n\nIf no call has been made to optimize!, then the TerminationStatus is:\n\nOPTIMIZE_NOT_CALLED: The algorithm has not started.\n\nOK\n\nThese are generally OK statuses, i.e., the algorithm ran to completion normally.\n\nOPTIMAL: The algorithm found a globally optimal solution.\nINFEASIBLE: The algorithm concluded that no feasible solution exists.\nDUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem. If, additionally, a feasible (primal) solution is known to exist, this status typically implies that the problem is unbounded, with some technical exceptions.\nLOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.\nLOCALLY_INFEASIBLE: The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.\nINFEASIBLE_OR_UNBOUNDED: The algorithm stopped because it decided that the problem is infeasible or unbounded; this occasionally happens during MIP presolve.\n\nSolved to relaxed tolerances\n\nALMOST_OPTIMAL: The algorithm found a globally optimal solution to relaxed tolerances.\nALMOST_INFEASIBLE: The algorithm concluded that no feasible solution exists within relaxed tolerances.\nALMOST_DUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.\nALMOST_LOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.\n\nLimits\n\nThe optimizer stopped because of some user-defined limit.\n\nITERATION_LIMIT: An iterative algorithm stopped after conducting the maximum number of iterations.\nTIME_LIMIT: The algorithm stopped after a user-specified computation time.\nNODE_LIMIT: A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.\nSOLUTION_LIMIT: The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.\nMEMORY_LIMIT: The algorithm stopped because it ran out of memory.\nOBJECTIVE_LIMIT: The algorithm stopped because it found a solution better than a minimum limit set by the user.\nNORM_LIMIT: The algorithm stopped because the norm of an iterate became too large.\nOTHER_LIMIT: The algorithm stopped due to a limit not covered by one of the above.\n\nProblematic\n\nThis group of statuses means that something unexpected or problematic happened.\n\nSLOW_PROGRESS: The algorithm stopped because it was unable to continue making progress towards the solution.\nNUMERICAL_ERROR: The algorithm stopped because it encountered unrecoverable numerical error.\nINVALID_MODEL: The algorithm stopped because the model is invalid.\nINVALID_OPTION: The algorithm stopped because it was provided an invalid option.\nINTERRUPTED: The algorithm stopped because of an interrupt signal.\nOTHER_ERROR: The algorithm stopped because of an error not covered by one of the statuses defined above.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#JuMP.raw_status","page":"Solution API","title":"JuMP.raw_status","text":"raw_status(model::Model)\n\nReturn the reason why the solver stopped in its own words (i.e., the MathOptInterface model attribute RawStatusString).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.primal_status","page":"Solution API","title":"JuMP.primal_status","text":"primal_status(model::Model; result::Int = 1)\n\nReturn the status of the most recent primal solution of the solver (i.e., the MathOptInterface model attribute PrimalStatus) associated with the result index result.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#MathOptInterface.ResultStatusCode","page":"Solution API","title":"MathOptInterface.ResultStatusCode","text":"ResultStatusCode\n\nAn Enum of possible values for the PrimalStatus and DualStatus attributes. The values indicate how to interpret the result vector.\n\nNO_SOLUTION: the result vector is empty.\nFEASIBLE_POINT: the result vector is a feasible point.\nNEARLY_FEASIBLE_POINT: the result vector is feasible if some constraint tolerances are relaxed.\nINFEASIBLE_POINT: the result vector is an infeasible point.\nINFEASIBILITY_CERTIFICATE: the result vector is an infeasibility certificate. If the PrimalStatus is INFEASIBILITY_CERTIFICATE, then the primal result vector is a certificate of dual infeasibility. If the DualStatus is INFEASIBILITY_CERTIFICATE, then the dual result vector is a proof of primal infeasibility.\nNEARLY_INFEASIBILITY_CERTIFICATE: the result satisfies a relaxed criterion for a certificate of infeasibility.\nREDUCTION_CERTIFICATE: the result vector is an ill-posed certificate; see this article for details. If the PrimalStatus is REDUCTION_CERTIFICATE, then the primal result vector is a proof that the dual problem is ill-posed. If the DualStatus is REDUCTION_CERTIFICATE, then the dual result vector is a proof that the primal is ill-posed.\nNEARLY_REDUCTION_CERTIFICATE: the result satisfies a relaxed criterion for an ill-posed certificate.\nUNKNOWN_RESULT_STATUS: the result vector contains a solution with an unknown interpretation.\nOTHER_RESULT_STATUS: the result vector contains a solution with an interpretation not covered by one of the statuses defined above.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#JuMP.result_count","page":"Solution API","title":"JuMP.result_count","text":"result_count(model::Model)\n\nReturn the number of results available to query after a call to optimize!.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.has_values","page":"Solution API","title":"JuMP.has_values","text":"has_values(model::Model; result::Int = 1)\n\nReturn true if the solver has a primal solution in result index result available to query, otherwise return false.\n\nSee also value and result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.value","page":"Solution API","title":"JuMP.value","text":"value(con_ref::ConstraintRef; result::Int = 1)\n\nReturn the primal value of constraint con_ref associated with result index result of the most-recent solution returned by the solver.\n\nThat is, if con_ref is the reference of a constraint func-in-set, it returns the value of func evaluated at the value of the variables (given by value(::VariableRef)).\n\nUse has_values to check if a result exists before asking for values.\n\nSee also: result_count.\n\nNote\n\nFor scalar contraints, the constant is moved to the set so it is not taken into account in the primal value of the constraint. For instance, the constraint @constraint(model, 2x + 3y + 1 == 5) is transformed into 2x + 3y-in-MOI.EqualTo(4) so the value returned by this function is the evaluation of 2x + 3y. ```\n\n\n\n\n\nvalue(con_ref::ConstraintRef, var_value::Function)\n\nEvaluate the primal value of the constraint con_ref using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(v::VariableRef; result = 1)\n\nReturn the value of variable v associated with result index result of the most-recent returned by the solver.\n\nUse has_values to check if a result exists before asking for values.\n\nSee also: result_count.\n\n\n\n\n\nvalue(v::VariableRef, var_value::Function)\n\nEvaluate the value of the variable v as var_value(v).\n\n\n\n\n\nvalue(ex::GenericAffExpr, var_value::Function)\n\nEvaluate ex using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(v::GenericAffExpr; result::Int = 1)\n\nReturn the value of the GenericAffExpr v associated with result index result of the most-recent solution returned by the solver.\n\nReplaces getvalue for most use cases.\n\nSee also: result_count.\n\n\n\n\n\nvalue(v::GenericQuadExpr; result::Int = 1)\n\nReturn the value of the GenericQuadExpr v associated with result index result of the most-recent solution returned by the solver.\n\nReplaces getvalue for most use cases.\n\nSee also: result_count.\n\n\n\n\n\nvalue(p::NonlinearParameter)\n\nReturn the current value stored in the nonlinear parameter p.\n\nExample\n\nmodel = Model()\n@NLparameter(model, p == 10)\nvalue(p)\n\n# output\n10.0\n\n\n\n\n\nvalue(ex::NonlinearExpression, var_value::Function)\n\nEvaluate ex using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(ex::NonlinearExpression; result::Int = 1)\n\nReturn the value of the NonlinearExpression ex associated with result index result of the most-recent solution returned by the solver.\n\nReplaces getvalue for most use cases.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.dual_status","page":"Solution API","title":"JuMP.dual_status","text":"dual_status(model::Model; result::Int = 1)\n\nReturn the status of the most recent dual solution of the solver (i.e., the MathOptInterface model attribute DualStatus) associated with the result index result.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.has_duals","page":"Solution API","title":"JuMP.has_duals","text":"has_duals(model::Model; result::Int = 1)\n\nReturn true if the solver has a dual solution in result index result available to query, otherwise return false.\n\nSee also dual, shadow_price, and result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.dual","page":"Solution API","title":"JuMP.dual","text":"dual(con_ref::ConstraintRef; result::Int = 1)\n\nReturn the dual value of constraint con_ref associated with result index result of the most-recent solution returned by the solver.\n\nUse has_dual to check if a result exists before asking for values.\n\nSee also: result_count, shadow_price.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.shadow_price","page":"Solution API","title":"JuMP.shadow_price","text":"shadow_price(con_ref::ConstraintRef)\n\nReturn the change in the objective from an infinitesimal relaxation of the constraint.\n\nThis value is computed from dual and can be queried only when has_duals is true and the objective sense is MIN_SENSE or MAX_SENSE (not FEASIBILITY_SENSE). For linear constraints, the shadow prices differ at most in sign from the dual value depending on the objective sense.\n\nSee also reduced_cost.\n\nNotes\n\nThe function simply translates signs from dual and does not validate the conditions needed to guarantee the sensitivity interpretation of the shadow price. The caller is responsible, e.g., for checking whether the solver converged to an optimal primal-dual pair or a proof of infeasibility.\nThe computation is based on the current objective sense of the model. If this has changed since the last solve, the results will be incorrect.\nRelaxation of equality constraints (and hence the shadow price) is defined based on which sense of the equality constraint is active.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.reduced_cost","page":"Solution API","title":"JuMP.reduced_cost","text":"reduced_cost(x::VariableRef)::Float64\n\nReturn the reduced cost associated with variable x.\n\nEquivalent to querying the shadow price of the active variable bound (if one exists and is active).\n\nSee also: shadow_price.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.objective_bound","page":"Solution API","title":"JuMP.objective_bound","text":"objective_bound(model::Model)\n\nReturn the best known bound on the optimal objective value after a call to optimize!(model).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.objective_value","page":"Solution API","title":"JuMP.objective_value","text":"objective_value(model::Model; result::Int = 1)\n\nReturn the objective value associated with result index result of the most-recent solution returned by the solver.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.dual_objective_value","page":"Solution API","title":"JuMP.dual_objective_value","text":"dual_objective_value(model::Model; result::Int = 1)\n\nReturn the value of the objective of the dual problem associated with result index result of the most-recent solution returned by the solver.\n\nThrows MOI.UnsupportedAttribute{MOI.DualObjectiveValue} if the solver does not support this attribute.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.solve_time","page":"Solution API","title":"JuMP.solve_time","text":"solve_time(model::Model)\n\nIf available, returns the solve time reported by the solver. Returns \"ArgumentError: ModelLike of type Solver.Optimizer does not support accessing the attribute MathOptInterface.SolveTime()\" if the attribute is not implemented.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.relative_gap","page":"Solution API","title":"JuMP.relative_gap","text":"relative_gap(model::Model)\n\nReturn the final relative optimality gap after a call to optimize!(model). Exact value depends upon implementation of MathOptInterface.RelativeGap() by the particular solver used for optimization.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.simplex_iterations","page":"Solution API","title":"JuMP.simplex_iterations","text":"simplex_iterations(model::Model)\n\nGets the cumulative number of simplex iterations during the most-recent optimization.\n\nSolvers must implement MOI.SimplexIterations() to use this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.barrier_iterations","page":"Solution API","title":"JuMP.barrier_iterations","text":"barrier_iterations(model::Model)\n\nGets the cumulative number of barrier iterations during the most recent optimization.\n\nSolvers must implement MOI.BarrierIterations() to use this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.node_count","page":"Solution API","title":"JuMP.node_count","text":"node_count(model::Model)\n\nGets the total number of branch-and-bound nodes explored during the most recent optimization in a Mixed Integer Program.\n\nSolvers must implement MOI.NodeCount() to use this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.OptimizeNotCalled","page":"Solution API","title":"JuMP.OptimizeNotCalled","text":"struct OptimizeNotCalled <: Exception end\n\nA result attribute cannot be queried before optimize! is called.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#MathOptInterface.optimize!","page":"Solution API","title":"MathOptInterface.optimize!","text":"optimize!(optimizer::AbstractOptimizer)\n\nStart the solution procedure.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.compute_conflict!","page":"Solution API","title":"JuMP.compute_conflict!","text":"compute_conflict!(model::Model)\n\nCompute a conflict if the model is infeasible. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nThe status of the conflict can be checked with the MOI.ConflictStatus model attribute. Then, the status for each constraint can be queried with the MOI.ConstraintConflictStatus attribute.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#MathOptInterface.compute_conflict!","page":"Solution API","title":"MathOptInterface.compute_conflict!","text":"compute_conflict!(optimizer::AbstractOptimizer)\n\nComputes a minimal subset of constraints such that the model with the other constraint removed is still infeasible.\n\nSome solvers call a set of conflicting constraints an Irreducible Inconsistent Subsystem (IIS).\n\nSee also ConflictStatus and ConstraintConflictStatus.\n\nNote\n\nIf the model is modified after a call to compute_conflict!, the implementor is not obliged to purge the conflict. Any calls to the above attributes may return values for the original conflict without a warning. Similarly, when modifying the model, the conflict can be discarded.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#MathOptInterface.ConflictStatus","page":"Solution API","title":"MathOptInterface.ConflictStatus","text":"ConflictStatus()\n\nA model attribute for the ConflictStatusCode explaining why the conflict refiner stopped when computing the conflict.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#MathOptInterface.ConflictStatusCode","page":"Solution API","title":"MathOptInterface.ConflictStatusCode","text":"ConflictStatusCode\n\nAn Enum of possible values for the ConflictStatus attribute. This attribute is meant to explain the reason why the conflict finder stopped executing in the most recent call to compute_conflict!.\n\nPossible values are:\n\nCOMPUTE_CONFLICT_NOT_CALLED: the function compute_conflict! has not yet been called\nNO_CONFLICT_EXISTS: there is no conflict because the problem is feasible\nNO_CONFLICT_FOUND: the solver could not find a conflict\nCONFLICT_FOUND: at least one conflict could be found\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#MathOptInterface.ConstraintConflictStatus","page":"Solution API","title":"MathOptInterface.ConstraintConflictStatus","text":"ConstraintConflictStatus()\n\nA constraint attribute indicating whether the constraint participates in the conflict. Its type is ConflictParticipationStatusCode.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#MathOptInterface.ConflictParticipationStatusCode","page":"Solution API","title":"MathOptInterface.ConflictParticipationStatusCode","text":"ConflictParticipationStatusCode\n\nAn Enum of possible values for the ConstraintConflictStatus attribute. This attribute is meant to indicate whether a given constraint participates or not in the last computed conflict.\n\nPossible values are:\n\nNOT_IN_CONFLICT: the constraint does not participate in the conflict\nIN_CONFLICT: the constraint participates in the conflict\nMAYBE_IN_CONFLICT: the constraint may participate in the conflict, the solver was not able to prove that the constraint can be excluded from the conflict\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#JuMP.lp_objective_perturbation_range","page":"Solution API","title":"JuMP.lp_objective_perturbation_range","text":"lp_objective_perturbation_range(var::VariableRef;\n                                optimality_tolerance::Float64)\n                                ::Tuple{Float64, Float64}\n\nGives the range by which the cost coefficient can change and the current LP basis remains optimal, i.e., the reduced costs remain valid.\n\nNotes\n\nThe range denotes valid changes, Δ ∈ [l, u], for which cost[var] += Δ do not violate the current optimality conditions.\noptimality_tolerance is the dual feasibility tolerance, this should preferably match the tolerance used by the solver. The defualt tolerance should however apply in most situations (c.f. \"Computational Techniques of the Simplex Method\" by István Maros, section 9.3.4).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.lp_rhs_perturbation_range","page":"Solution API","title":"JuMP.lp_rhs_perturbation_range","text":"lp_rhs_perturbation_range(constraint::ConstraintRef;\n                          feasibility_tolerance::Float64)\n                          ::Tuple{Float64, Float64}\n\nGives the range by which the rhs coefficient can change and the current LP basis remains feasible, i.e., where the shadow prices apply.\n\nNotes\n\nThe rhs coefficient is the value right of the relation, i.e., b for the constraint when of the form a*x □ b, where □ is ≤, =, or ≥.\nThe range denotes valid changes, e.g., for a*x <= b + Δ, the LP basis remains feasible for all Δ ∈ [l, u].\nfeasibility_tolerance is the primal feasibility tolerance, this should preferably match the tolerance used by the solver. The default tolerance should however apply in most situations (c.f. \"Computational Techniques of the Simplex Method\" by István Maros, section 9.3.4).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.lp_sensitivity_report","page":"Solution API","title":"JuMP.lp_sensitivity_report","text":"lp_sensitivity_report(model::Model; atol::Float64 = 1e-8)::SensitivityReport\n\nGiven a linear program model with a current optimal basis, return a SensitivityReport object, which maps:\n\nEvery variable reference to a tuple (d_lo, d_hi)::Tuple{Float64,Float64}, explaining how much the objective coefficient of the corresponding variable can change by, such that the original basis remains optimal.\nEvery constraint reference to a tuple (d_lo, d_hi)::Tuple{Float64,Float64}, explaining how much the right-hand side of the corresponding constraint can change by, such that the basis remains optimal.\n\nBoth tuples are relative, rather than absolute. So given a objective coefficient of 1.0 and a tuple (-0.5, 0.5), the objective coefficient can range between 1.0 - 0.5 an 1.0 + 0.5.\n\natol is the primal/dual optimality tolerance, and should match the tolerance of the solver used to compute the basis.\n\nNote: interval constraints are NOT supported.\n\nExample\n\nmodel = Model(GLPK.Optimizer)\n@variable(model, -1 <= x <= 2)\n@objective(model, Min, x)\noptimize!(model)\nreport = lp_sensitivity_report(model; atol = 1e-7)\ndx_lo, dx_hi = report[x]\nprintln(\n    \"The objective coefficient of `x` can decrease by $dx_lo or \" *\n    \"increase by $dx_hi.\"\n)\nc = LowerBoundRef(x)\ndRHS_lo, dRHS_hi = report[c]\nprintln(\n    \"The lower bound of `x` can decrease by $dRHS_lo or increase \" *\n    \"by $dRHS_hi.\"\n)\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.SensitivityReport","page":"Solution API","title":"JuMP.SensitivityReport","text":"SensitivityReport\n\nSee lp_sensitivity_report.\n\n\n\n\n\n","category":"type"},{"location":"style/#Style-guide-and-design-principles","page":"Style Guide","title":"Style guide and design principles","text":"","category":"section"},{"location":"style/#Style-guide","page":"Style Guide","title":"Style guide","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"This section describes the coding style rules that apply to JuMP code and that we recommend for JuMP models and surrounding Julia code. The motivations for a style guide include:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"conveying best practices for writing readable and maintainable code\nreducing the amount of time spent on bike-shedding by establishing basic naming and formatting conventions\nlowering the barrier for new contributors by codifying the existing practices (e.g., you can be more confident your code will pass review if you follow the style guide)","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"In some cases, the JuMP style guide diverges from the Julia style guide. All such cases will be explicitly noted and justified.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"The JuMP style guide adopts many recommendations from the Google style guides.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"info: Info\nThe style guide is always a work in progress, and not all JuMP code follows the rules. When modifying JuMP, please fix the style violations of the surrounding code (i.e., leave the code tidier than when you started). If large changes are needed, consider separating them into another PR.","category":"page"},{"location":"style/#Formatting","page":"Style Guide","title":"Formatting","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Julia unfortunately does not have an autoformatting tool like gofmt. Until a reliable autoformatting tool is available, we adopt the following conventions.","category":"page"},{"location":"style/#Whitespace","page":"Style Guide","title":"Whitespace","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"For conciseness, never use more than one blank line within a function, and never begin a function with a blank line.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"function foo(x)\n    y = 2 * x\n\n\n    return y\nend\n\nfunction foo(x)\n\n    y = 2 * x\n    return y\nend","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Julia is mostly insensitive to whitespace characters within lines. For consistency:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Use spaces between binary operators (with some exceptions, see below)\nUse a single space after commas and semicolons\nDo not use extra spaces for unary operators, parentheses, or braces\nIndent within new blocks (except module) using 4 spaces","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"f(x, y) = [3 * dot(x, y); x']","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"f(x,y) = [ 3*dot(x,y) ; x' ]","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"module Foo\n\nfunction f(x)\n    return x + 1\nend\n\nend # module Foo","category":"page"},{"location":"style/#Exceptions","page":"Style Guide","title":"Exceptions","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"For aesthetic reasons, we make an exception for whitespace surrounding the exponential operator ^.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"f(x) = x^2","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"f(x) = x ^ 2","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"We also make an exception for the : operator when it is used to form a range.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"x = 1:5","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"x = 1 : 5","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"One reason is that it can be confused with Julia's conditional statement: cond ? x : y which requires whitespace around the :.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"We also make an exception for juxtaposed multiplication (i.e. dropping the * between a numeric literal and an expression) when the right-hand side is a symbol.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"2x  # Acceptable if there are space constraints.\n2 * x  # This is preferred if space is not an issue.\n2 * (x + 1)","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"2(x + 1)","category":"page"},{"location":"style/#Return-statements","page":"Style Guide","title":"Return statements","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"To avoid situations in which it is unclear whether the author intended to return a certain value or not, always use an explicit return statement to exit from a function. If the return from a function is nothing, use return instead of return nothing.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"We make an exception for assignment-form one-line functions (f(x) = 2x).","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"foo(x) = 2x  # Acceptable if one line\nfunction foo(x)\n    return 2x\nend\nfunction foo(x)\n    x[1] += 1\n    return\nend","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"function foo(x)\n    2x\nend\nfunction foo(x)\n    x[1] += 1\n    return nothing\nend","category":"page"},{"location":"style/#Line-length","page":"Style Guide","title":"Line length","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Line lengths are a contentious issue. Our foremost goal is to maximize code readability. Very long line lengths can be hard to easily comprehend. However, arbitrarily enforcing a maximum line length (like 80 characters) inevitably leads to cases in which slightly longer lines (e.g. 81 characters) might be more readable.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Therefore, aim to keep line lengths under 80 characters by breaking lines for maximum readability (examples are given in the Line breaks section), but don't treat this as a hard rule.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"We make exceptions for","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"URLs\npathnames","category":"page"},{"location":"style/#Line-breaks","page":"Style Guide","title":"Line breaks","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"The \"readability\" of a line is subjective. In this section we give suggestions of good and bad style of how to break a line. These suggestions are inspired by Google's Python style guide.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"note: Note\nIf you're unsure about how format your code, you can experiment (in Python) using YAPF.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"When defining functions, align arguments vertically after the opening parenthesis, or list all arguments on a new (indented) line.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"# Arguments to the function are aligned vertically.\nfunction my_very_long_function_name(with_lots_of_long_arguments_1,\n                                    and_another_long_one)\n    # First line of the function begins here.\nend\n\n# Arguments to the function are listed on a new line and indented.\nfunction my_very_long_function_name(\n    with_lots_of_long_arguments_1, and_another_long_one)\n    # First line of the function begins here.\nend","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"# When defining functions, if vertical alignment is not used, then the arguments\n# should not begin on the first line.\nfunction my_very_long_function_name(with_lots_of_long_arguments_1,\n    and_another_long_one)\n    # First line of the function begins here.\nend","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Don't use vertical alignment if all of the arguments are very far to the right.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"a_very_long_variable_name = a_long_variable_name_with_arguments(first_argument,\n                                                                second_argument)","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Better:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"a_very_long_variable_name = a_long_variable_name_with_arguments(\n    first_argument, second_argument)","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Don't use vertical alignment if it would be more readable to place all arguments on a new indented line.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"con_index = MOI.add_constraint(backend(owner_model(variable)),\n                               MOI.SingleVariable(index(variable)), set)","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Better:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"con_index = MOI.add_constraint(\n    backend(owner_model(variable)), MOI.SingleVariable(index(variable)), set)","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Don't break lines at an inner-level of function nesting.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"con_index = MOI.add_constraint(\n    backend(owner_model(variable)), MOI.SingleVariable(\n    index(variable)), new_set)","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Better:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"con_index = MOI.add_constraint(\n    backend(owner_model(variable)),\n    MOI.SingleVariable(index(variable)), new_set)","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"For readability, don't split a one-line function over multiple lines.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"f(x) = 1 + x +\n    x^2 + x^3","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Better:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"f(x) = 1 + x + x^2 + x^3 + x^3","category":"page"},{"location":"style/#Syntax","page":"Style Guide","title":"Syntax","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Julia sometimes provides equivalent syntax to express the same basic operation. We discuss these cases below.","category":"page"},{"location":"style/#for-loops","page":"Style Guide","title":"for loops","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Julia allows both for x = 1:N and for x in 1:N. Always prefer to use in over =, because in generalizes better to other index sets like for x in eachindex(A).","category":"page"},{"location":"style/#Empty-vectors","page":"Style Guide","title":"Empty vectors","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"For a type T, T[] and Vector{T}() are equivalent ways to create an empty vector with element type T. Prefer T[] because it is more concise.","category":"page"},{"location":"style/#Trailing-periods-in-floating-point-constants","page":"Style Guide","title":"Trailing periods in floating-point constants","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Both 1.0 and 1. create a Float64 with value 1.0. Prefer 1.0 over 1. because it is more easily distinguished from the integer constant 1.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Moreover, as recommended by the Julia style guide, never use 1.0 when 1 is okay.","category":"page"},{"location":"style/#Comments","page":"Style Guide","title":"Comments","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"For non-native speakers and for general clarity, comments in code must be proper English sentences with appropriate punctuation.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"# This is a comment demonstrating a good comment.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"# a bad comment","category":"page"},{"location":"style/#JuMP-macro-syntax","page":"Style Guide","title":"JuMP macro syntax","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"For consistency, always use parentheses.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0)","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"@variable model x >= 0","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"For consistency, always use constant * variable as opposed to variable * constant. This makes it easier to read models in ambiguous cases like a * x.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"a = 4\n@constraint(model, 3 * x <= 1)\n@constraint(model, a * x <= 1)","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"a = 4\n@constraint(model, x * 3 <= 1)\n@constraint(model, x * a <= 1)","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"In order to reduce boilerplate code, prefer the plural form of macros over lots of repeated calls to singular forms.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"@variables(model, begin\n    x >= 0\n    y >= 1\n    z <= 2\nend)","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0)\n@variable(model, y >= 1)\n@variable(model, z <= 2)","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"An exception is made for calls with many keyword arguments, since these need to be enclosed in parentheses in order to parse properly.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Acceptable:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0, start = 0.0, base_name = \"my_x\")\n@variable(model, y >= 1, start = 2.0)\n@variable(model, z <= 2, start = -1.0)","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Also acceptable:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"@variables(model, begin\n    x >= 0, (start = 0.0, base_name = \"my_x\")\n    y >= 1, (start = 2.0)\n    z <= 2, (start = -1.0)\nend)","category":"page"},{"location":"style/#Naming","page":"Style Guide","title":"Naming","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"module SomeModule end\nfunction some_function end\nconst SOME_CONSTANT = ...\nstruct SomeStruct\n  some_field::SomeType\nend\n@enum SomeEnum ENUM_VALUE_A ENUM_VALUE_B\nsome_local_variable = ...\nsome_file.jl # Except for ModuleName.jl.","category":"page"},{"location":"style/#Exported-and-non-exported-names","page":"Style Guide","title":"Exported and non-exported names","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Begin private module level functions and constants with an underscore. All other objects in the scope of a module should be exported. (See JuMP.jl for an example of how to do this.)","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Names beginning with an underscore should only be used for distinguishing between exported (public) and non-exported (private) objects. Therefore, never begin the name of a local variable with an underscore.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"module MyModule\n\nexport public_function, PUBLIC_CONSTANT\n\nfunction _private_function()\n    local_variable = 1\n    return\nend\n\nfunction public_function end\n\nconst _PRIVATE_CONSTANT = 3.14159\nconst PUBLIC_CONSTANT = 1.41421\n\nend","category":"page"},{"location":"style/#Use-of-underscores-within-names","page":"Style Guide","title":"Use of underscores within names","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"The Julia style guide recommends avoiding underscores \"when readable\", for example, haskey, isequal, remotecall, and remotecall_fetch. This convention creates the potential for unnecessary bikeshedding and also forces the user to recall the presence/absence of an underscore, e.g., \"was that argument named basename or base_name?\". For consistency, always use underscores in variable names and function names to separate words.","category":"page"},{"location":"style/#Use-of-!","page":"Style Guide","title":"Use of !","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Julia has a convention of appending ! to a function name if the function modifies its arguments. We recommend to:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Omit ! when the name itself makes it clear that modification is taking place, e.g., add_constraint and set_name. We depart from the Julia style guide because ! does not provide a reader with any additional information in this case, and adherence to this convention is not uniform even in base Julia itself (consider Base.println and Base.finalize).\nUse ! in all other cases. In particular it can be used to distinguish between modifying and non-modifying variants of the same function like scale and scale!.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Note that ! is not a self-documenting feature because it is still ambiguous which arguments are modified when multiple arguments are present. Be sure to document which arguments are modified in the method's docstring.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"See also the Julia style guide recommendations for ordering of function arguments.","category":"page"},{"location":"style/#Abbreviations","page":"Style Guide","title":"Abbreviations","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Abbreviate names to make the code more readable, not to save typing. Don't arbitrarily delete letters from a word to abbreviate it (e.g., indx). Use abbreviations consistently within a body of code (e.g., do not mix con and constr, idx and indx).","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Common abbreviations:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"num for number\ncon for constraint","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"TODO: add more","category":"page"},{"location":"style/#Miscellaneous","page":"Style Guide","title":"Miscellaneous","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"(TODO: Rethink categories.)","category":"page"},{"location":"style/#User-facing-MethodError","page":"Style Guide","title":"User-facing MethodError","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Specifying argument types for methods is mostly optional in Julia, which means that it's possible to find out that you are working with unexpected types deep in the call chain. Avoid this situation or handle it with a helpful error message. A user should see a MethodError only for methods that they called directly.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"_internal_function(x::Integer) = x + 1\n# The user sees a MethodError for _internal_function when calling\n# public_function(\"a string\"). This is not very helpful.\npublic_function(x) = _internal_function(x)","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"_internal_function(x::Integer) = x + 1\n# The user sees a MethodError for public_function when calling\n# public_function(\"a string\"). This is easy to understand.\npublic_function(x::Integer) = _internal_function(x)","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"If it is hard to provide an error message at the top of the call chain, then the following pattern is also ok:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"_internal_function(x::Integer) = x + 1\nfunction _internal_function(x)\n    error(\"Internal error. This probably means that you called \" *\n          \"public_function() with the wrong type.\")\nend\npublic_function(x) = _internal_function(x)","category":"page"},{"location":"style/#@enum-vs.-Symbol","page":"Style Guide","title":"@enum vs. Symbol","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"The @enum macro lets you define types with a finite number of values that are explicitly enumerated (like enum in C/C++). Symbols are lightweight strings that are used to represent identifiers in Julia (for example, :x).","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"@enum provides type safety and can have docstrings attached to explain the possible values. Use @enums when applicable, e.g., for reporting statuses. Use strings to provide long-form additional information like error messages.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Use of Symbol should typically be reserved for identifiers, e.g., for lookup in the JuMP model (model[:my_variable]).","category":"page"},{"location":"style/#using-vs.-import","page":"Style Guide","title":"using vs. import","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"using ModuleName brings all symbols exported by the module ModuleName into scope, while import ModuleName brings only the module itself into scope. (See the Julia manual) for examples and more details.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"For the same reason that from <module> import * is not recommended in python (PEP 8), avoid using ModuleName except in throw-away scripts or at the REPL. The using statement makes it harder to track where symbols come from and exposes the code to ambiguities when two modules export the same symbol.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Prefer using ModuleName: x, p to import ModuleName.x, ModuleName.p and import MyModule: x, p because the import versions allow method extension without qualifying with the module name.","category":"page"},{"location":"style/#Documentation","page":"Style Guide","title":"Documentation","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"This section describes the writing style that should be used when writing documentation for JuMP (and supporting packages).","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"We can recommend the documentation style guides by Divio, Google, and Write the Docs as general reading for those writing documentation. This guide delegates a thorough handling of the topic to those guides and instead elaborates on the points more specific to Julia and documentation that uses Documenter.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Be concise.\nUse lists instead of long sentences.\nUse numbered lists when describing a sequence, e.g., (1) do X, (2) then Y.\nUse bullet points when the items are not ordered.\nExample code should be covered by doctests. (But it's unclear what to do if the code depends on a solver.)\nWhen a word is a Julia symbol and not an English word, enclose it with backticks. In addition, if it has a docstring in this doc add a link using @ref. If it is a plural, add the \"s\" after the closing backtick. For example,\n[`VariableRef`](@ref)s\nUse @meta blocks for TODOs and other comments that shouldn't be visible to readers. For example,\n```@meta\n# TODO: Mention also X, Y, and Z.\n```","category":"page"},{"location":"style/#Design-principles","page":"Style Guide","title":"Design principles","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"TODO: How to structure and test large JuMP models, libraries that use JuMP.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"For how to write a solver, see MOI.","category":"page"},{"location":"examples/sudoku/","page":"Solving Sudokus with MIP","title":"Solving Sudokus with MIP","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/sudoku.jl\"","category":"page"},{"location":"examples/sudoku/#Solving-Sudokus-with-MIP","page":"Solving Sudokus with MIP","title":"Solving Sudokus with MIP","text":"","category":"section"},{"location":"examples/sudoku/","page":"Solving Sudokus with MIP","title":"Solving Sudokus with MIP","text":"A sudoku solver that uses a MIP to find solutions.","category":"page"},{"location":"examples/sudoku/","page":"Solving Sudokus with MIP","title":"Solving Sudokus with MIP","text":"We have binary variables x[i, j, k] which, if = 1, say that cell (i, j) contains the number k. The constraints are:  1 - Each cell has one value only  2 - Each row contains each number exactly once  3 - Each column contains each number exactly once  4 - Each 3x3 subgrid contains each number exactly once We will take the initial grid as a CSV file at filepath, where 0s are blanks.","category":"page"},{"location":"examples/sudoku/","page":"Solving Sudokus with MIP","title":"Solving Sudokus with MIP","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_sudoku(filepath::String)\n    initial_grid = zeros(Int, 9, 9)\n    open(filepath, \"r\") do fp\n        for row in 1:9\n            line = readline(fp)\n            initial_grid[row, :] .= parse.(Int, split(line, \",\"))\n        end\n    end\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:9, 1:9, 1:9], Bin)\n    @constraints(model, begin\n        # Constraint 1 - Only one value appears in each cell\n        cell[i in 1:9, j in 1:9], sum(x[i, j, :]) == 1\n        # Constraint 2 - Each value appears in each row once only\n        row[i in 1:9, k in 1:9], sum(x[i, :, k]) == 1\n        # Constraint 3 - Each value appears in each column once only\n        col[j in 1:9, k in 1:9], sum(x[:, j, k]) == 1\n        # Constraint 4 - Each value appears in each 3x3 subgrid once only\n        subgrid[i=1:3:7, j=1:3:7, val=1:9], sum(x[i:i + 2, j:j + 2, val]) == 1\n    end)\n    # Initial solution\n    for row in 1:9, col in 1:9\n        if initial_grid[row, col] != 0\n            fix(x[row, col, initial_grid[row, col]], 1)\n        end\n    end\n    # Solve it\n    optimize!(model)\n    # Check solution\n    term_status = termination_status(model)\n    is_optimal = term_status == MOI.OPTIMAL\n    if is_optimal\n        mip_solution = value.(x)\n        sol = zeros(Int, 9, 9)\n        for row in 1:9, col in 1:9, val in 1:9\n            if mip_solution[row, col, val] >= 0.9\n                sol[row, col] = val\n            end\n        end\n        return sol\n    else\n        error(\"The solver did not find an optimal solution.\")\n    end\nend","category":"page"},{"location":"examples/sudoku/","page":"Solving Sudokus with MIP","title":"Solving Sudokus with MIP","text":"Create an initial file. We could have set the example_sudoku function to take a matrix as input, but this example shows Julia's ability to parse files.","category":"page"},{"location":"examples/sudoku/","page":"Solving Sudokus with MIP","title":"Solving Sudokus with MIP","text":"open(\"sudoku.csv\", \"w\") do io\n    write(io, \"\"\"\n    3, 1, 0, 0, 5, 8, 0, 0, 4\n    0, 0, 9, 3, 2, 0, 0, 0, 0\n    0, 2, 5, 1, 0, 4, 0, 9, 0\n    0, 0, 0, 0, 0, 0, 3, 8, 9\n    0, 0, 8, 0, 0, 0, 5, 0, 0\n    5, 4, 6, 0, 0, 0, 0, 0, 0\n    0, 8, 0, 2, 0, 3, 6, 5, 0\n    0, 0, 0, 0, 7, 1, 4, 0, 0\n    7, 0, 0, 4, 8, 0, 0, 2, 1\n    \"\"\")\nend","category":"page"},{"location":"examples/sudoku/","page":"Solving Sudokus with MIP","title":"Solving Sudokus with MIP","text":"Now try solving the example:","category":"page"},{"location":"examples/sudoku/","page":"Solving Sudokus with MIP","title":"Solving Sudokus with MIP","text":"solution = example_sudoku(\"sudoku.csv\")\n\nTest.@test solution == [\n    3 1 7 9 5 8 2 6 4;\n    4 6 9 3 2 7 8 1 5;\n    8 2 5 1 6 4 7 9 3;\n    2 7 1 6 4 5 3 8 9;\n    9 3 8 7 1 2 5 4 6;\n    5 4 6 8 3 9 1 7 2;\n    1 8 4 2 9 3 6 5 7;\n    6 9 2 5 7 1 4 3 8;\n    7 5 3 4 8 6 9 2 1\n]","category":"page"},{"location":"examples/sudoku/","page":"Solving Sudokus with MIP","title":"Solving Sudokus with MIP","text":"The matrix can be hard to read. Print the solution properly:","category":"page"},{"location":"examples/sudoku/","page":"Solving Sudokus with MIP","title":"Solving Sudokus with MIP","text":"function print_sudoku_solution(solution)\n    println(\"Solution:\")\n    println(\"[-----------------------]\")\n    for row in 1:9\n        print(\"[ \")\n        for col in 1:9\n            print(solution[row, col], \" \")\n            if col % 3 == 0 && col < 9\n                print(\"| \")\n            end\n        end\n        println(\"]\")\n        if row % 3 == 0\n            println(\"[-----------------------]\")\n        end\n    end\nend\n\nprint_sudoku_solution(solution)","category":"page"},{"location":"examples/sudoku/","page":"Solving Sudokus with MIP","title":"Solving Sudokus with MIP","text":"Clean up the file we made:","category":"page"},{"location":"examples/sudoku/","page":"Solving Sudokus with MIP","title":"Solving Sudokus with MIP","text":"rm(\"sudoku.csv\")","category":"page"},{"location":"examples/sudoku/","page":"Solving Sudokus with MIP","title":"Solving Sudokus with MIP","text":"View this file on Github.","category":"page"},{"location":"examples/sudoku/","page":"Solving Sudokus with MIP","title":"Solving Sudokus with MIP","text":"","category":"page"},{"location":"examples/sudoku/","page":"Solving Sudokus with MIP","title":"Solving Sudokus with MIP","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/prod.jl\"","category":"page"},{"location":"examples/prod/#The-workforce-scheduling-problem","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"","category":"section"},{"location":"examples/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"This model determines a set of workforce levels that will most economically meet demands and inventory requirements over time. The formulation is motivated by the experiences of a large producer in the United States. The data are for three products and 13 periods.","category":"page"},{"location":"examples/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"Problem taken from the Appendix C of the expanded version of Fourer, Gay, and Kernighan, A Modeling Language for Mathematical Programming","category":"page"},{"location":"examples/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"Originally contributed by Louis Luangkesorn, February 26, 2015.","category":"page"},{"location":"examples/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_prod(; verbose = true)\n    # PRODUCTION SETS AND PARAMETERS\n    prd = [\"18REG\"  \"24REG\" \"24PRO\"]\n    # Members of the product group\n    numprd = length(prd)\n    pt =\t[1.194,\t1.509,\t1.509]\n    # Crew-hours to produce 1000 units\n    pc =\t[2304,\t2920,\t2910]\n    # Nominal production cost per 1000, used\n    # to compute inventory and shortage costs\n    #\n    # TIME PERIOD SETS AND PARAMETERS\n    firstperiod = 1\n    # Index of first production period to be modeled\n    lastperiod  = 13\n    # Index of last production period to be modeled\n    numperiods = firstperiod:lastperiod\n    # 'planning horizon' := first..last;\n    # EMPLOYMENT PARAMETERS\n    # Workers per crew\n    cs = 18\n    # Regular-time hours per shift\n    sl =  8\n    # Wage per hour for regular-time labor\n    rtr = 16.00\n    # Wage per hour for overtime labor\n    otr = 43.85\n    # Crews employed at start of first period\n    iw =  8\n    # Regular working days in a production period\n    dpp =\t [19.5,\t19,\t20,\t19,\t19.5,\t19,\t19,\t20,\t19,\t20,\t20,\t18,\t18]\n    # Maximum crew-hours of overtime in a period\n    ol =\t [96,\t96,\t96,\t96,\t96,\t96,\t96,\t96,\t96,\t96,\t96,\t96,\t96]\n    # Lower limit on average employment in a period\n    cmin =\t[0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0]\n    # Upper limit on average employment in a period\n    cmax =\t[8,\t8,\t8,\t8,\t8,\t8,\t8,\t8,\t8,\t8,\t8,\t8,\t8]\n    # Penalty cost of hiring a crew\n    hc =\t [7500,\t7500,\t7500,\t7500,\t15000,\t15000,\t15000,\t15000,\t15000,\t15000,\t7500,\t7500,\t7500]\n    # Penalty cost of laying off a crew\n    lc =\t [7500,\t7500,\t7500,\t7500,\t15000,\t15000,\t15000,\t15000,\t15000,\t15000,\t7500,\t7500,\t7500]\n    # DEMAND PARAMETERS\n    d18REG = [63.8,\t76,\t88.4,\t913.8,\t115,\t133.8,\t79.6,\t111,\t121.6,\t470,\t78.4,\t99.4,\t140.4,\t63.8]\n    d24REG = [1212,\t306.2,\t319,\t208.4,\t298,\t328.2,\t959.6,\t257.6,\t335.6,\t118,\t284.8,\t970,\t343.8,\t1212]\n    d24PRO = [0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t1102,\t0,\t0,\t0,\t0]\n    # Requirements (in 1000s) to be met from current production and inventory\n    dem = Array[d18REG, d24REG, d24PRO]\n    # true if product will be the subject of a special promotion in the period\n    pro = Array[\n        [0,\t0,\t0,\t1,\t0,\t0,\t0,\t0,\t0,\t1,\t0,\t0,\t0,\t0],\n        [1,\t0,\t0,\t0,\t0,\t0,\t1,\t0,\t0,\t0,\t0,\t0,\t1,\t1],\n        [0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t1,\t0,\t0,\t0,\t0],\n    ]\n    # INVENTORY AND SHORTAGE PARAMETERS\n    # Proportion of non-promoted demand that must be in inventory the previous\n    # period\n    rir = 0.75\n    # Proportion of promoted demand that must be in inventory the previous\n    # period\n    pir = 0.80\n    # Upper limit on number of periods that any product may sit in inventory\n    life = 2\n    # Inventory cost per 1000 units is cri times nominal production cost\n    cri\t= [0.015,\t0.015,\t0.015]\n    # Shortage cost per 1000 units is crs times nominal production cost\n    crs\t= [1.1,\t1.1,\t1.1]\n    # Inventory at start of first period; age unknown\n    iinv = [82,\t792.2,\t0]\n    # Initial inventory still available for allocation at end of period t\n    iil = [\n        [\n            max(0, iinv[p] - sum(dem[p][v] for v in firstperiod:t))\n            for t in numperiods\n        ]\n        for p in 1:numprd\n    ]\n    # Lower limit on inventory at end of period t\n    function checkpro(\n        product, timeperiod, production, promotionalrate, regularrate\n    )\n        if production[product][timeperiod + 1] == 1\n            return promotionalrate\n        else\n            return regularrate\n        end\n    end\n    minv = [\n        [dem[p][t + 1] * checkpro(p, t, pro, pir, rir) for t in numperiods]\n        for p in 1:numprd\n    ]\n    # DEFINE MODEL\n    prod = Model(GLPK.Optimizer)\n    # VARIABLES\n    # Average number of crews employed in each period\n    @variable(prod, Crews[0:lastperiod] >= 0)\n    # Crews hired from previous to current period\n    @variable(prod, Hire[numperiods] >= 0)\n    # Crews laid off from previous to current period\n    @variable(prod, Layoff[numperiods]>= 0)\n    # Production using regular-time labor, in 1000s\n    @variable(prod, Rprd[1:numprd, numperiods] >= 0)\n    # Production using overtime labor, in 1000s\n    @variable(prod, Oprd[1:numprd, numperiods]>= 0)\n    # a numperiods old -- produced in period (t+1)-a --\n    # and still in storage at the end of period t\n    @variable(prod, Inv[1:numprd, numperiods, 1:life] >= 0)\n    # Accumulated unsatisfied demand at the end of period t\n    @variable(prod, Short[1:numprd, numperiods] >= 0)\n    # CONSTRAINTS\n    # Hours needed to accomplish all regular-time production in a period must\n    # not exceed hours available on all shifts\n    @constraint(\n        prod,\n        [t = numperiods],\n        sum(pt[p] * Rprd[p, t] for p in 1:numprd) <= sl * dpp[t] * Crews[t]\n    )\n    # Hours needed to accomplish all overtime production in a period must not\n    # exceed the specified overtime limit\n    @constraint(\n        prod,\n        [t = numperiods],\n        sum(pt[p] * Oprd[p, t] for p in 1:numprd)  <= ol[t]\n    )\n    # Use given initial workforce\n    @constraint(prod, Crews[firstperiod - 1] == iw)\n    # Workforce changes by hiring or layoffs\n    @constraint(\n        prod, [t in numperiods], Crews[t] == Crews[t - 1] + Hire[t] - Layoff[t]\n    )\n    # Workforce must remain within specified bounds\n    @constraint(prod, [t in numperiods], cmin[t] <= Crews[t])\n    @constraint(prod, [t in numperiods], Crews[t] <= cmax[t])\n    # 'first demand requirement\n    @constraint(\n        prod,\n        [p in 1:numprd],\n        Rprd[p, firstperiod] + Oprd[p, firstperiod] + Short[p, firstperiod] -\n            Inv[p, firstperiod, 1] == max(0, dem[p][firstperiod] - iinv[p])\n    )\n    # Production plus increase in shortage plus decrease in inventory must\n    # equal demand\n    for t in (firstperiod + 1):lastperiod\n        @constraint(\n            prod,\n            [p in 1:numprd],\n            Rprd[p, t] + Oprd[p, t] + Short[p,t] - Short[p,t-1] +\n                sum(Inv[p, t - 1, a] - Inv[p, t, a] for a in 1:life) ==\n                max(0, dem[p][t] - iil[p][t - 1])\n        )\n    end\n    # Inventory in storage at end of period t must meet specified minimum\n    @constraint(\n        prod,\n        [p in 1:numprd, t in numperiods],\n        sum(Inv[p, t, a] + iil[p][t] for a in 1:life) >= minv[p][t]\n    )\n    # In the vth period (starting from first) no inventory may be more than v\n    # numperiods old (initial inventories are handled separately)\n    @constraint(\n        prod,\n        [p in 1:numprd, v in 1:(life - 1), a in (v + 1):life],\n        Inv[p, firstperiod + v - 1, a] == 0\n    )\n    # New inventory cannot exceed production in the most recent period\n    @constraint(\n        prod,\n        [p in 1:numprd, t in numperiods],\n        Inv[p, t, 1] <= Rprd[p, t] + Oprd[p, t]\n    )\n    # Inventory left from period (t+1)-p can only decrease as time goes on\n    secondperiod = firstperiod + 1\n    @constraint(\n        prod,\n        [p in 1:numprd, t in 2:lastperiod, a in 2:life],\n        Inv[p, t, a] <= Inv[p, t - 1, a - 1]\n    )\n    # OBJECTIVE\n    # Full regular wages for all crews employed, plus penalties for hiring and\n    # layoffs, plus wages for any overtime worked, plus inventory and shortage\n    # costs. (All other production costs are assumed to depend on initial\n    # inventory and on demands, and so are not included explicitly.)\n    @objective(\n        prod,\n        Min,\n        sum(\n            rtr * sl * dpp[t] * cs * Crews[t] +\n            hc[t] * Hire[t] +\n            lc[t] * Layoff[t] +\n            sum(\n                otr * cs * pt[p] * Oprd[p, t] +\n                sum(cri[p] * pc[p] * Inv[p, t, a] for a in 1:life) +\n                crs[p] * pc[p] * Short[p, t]\n                for p in 1:numprd\n            )\n           for t in numperiods\n        )\n    )\n    # Obtain solution\n    optimize!(prod)\n    Test.@test termination_status(prod) == MOI.OPTIMAL\n    Test.@test primal_status(prod) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(prod) ≈ 4_426_822.89 atol = 1e-2\n    if verbose\n        println(\"RESULTS:\")\n        println(\"Crews\")\n        for t = 0:length(Crews.data) - 1\n            print(\" $(value(Crews[t])) \")\n        end\n        println()\n        println(\"Hire\")\n        for t = 1:length(Hire.data)\n            print(\" $(value(Hire[t])) \")\n        end\n        println()\n        println(\"Layoff\")\n        for t = 1:length(Layoff.data)\n            print(\" $(value(Layoff[t])) \")\n        end\n        println()\n    end\n    return\nend\n\nexample_prod()","category":"page"},{"location":"examples/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"View this file on Github.","category":"page"},{"location":"examples/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"","category":"page"},{"location":"examples/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/callbacks/#Callback-API","page":"Callback API","title":"Callback API","text":"","category":"section"},{"location":"reference/callbacks/","page":"Callback API","title":"Callback API","text":"More information can be found in the Callbacks section of the manual.","category":"page"},{"location":"reference/callbacks/","page":"Callback API","title":"Callback API","text":"@build_constraint\ncallback_node_status\ncallback_value","category":"page"},{"location":"reference/callbacks/#JuMP.@build_constraint","page":"Callback API","title":"JuMP.@build_constraint","text":"@build_constraint(constraint_expr)\n\nConstructs a ScalarConstraint or VectorConstraint using the same machinery as @constraint but without adding the constraint to a model.\n\nConstraints using broadcast operators like x .<= 1 are also supported and will create arrays of ScalarConstraint or VectorConstraint.\n\nExamples\n\nmodel = Model();\n@variable(model, x);\n@build_constraint(2x >= 1)\n\n# output\nScalarConstraint{GenericAffExpr{Float64,VariableRef},MathOptInterface.GreaterThan{Float64}}(2 x, MathOptInterface.GreaterThan{Float64}(1.0))\n\n\n\n\n\n","category":"macro"},{"location":"reference/callbacks/#JuMP.callback_node_status","page":"Callback API","title":"JuMP.callback_node_status","text":"callback_node_status(cb_data, model::Model)\n\nReturn an MOI.CallbackNodeStatusCode enum, indicating if the current primal solution available from callback_value is integer feasible.\n\n\n\n\n\n","category":"function"},{"location":"reference/callbacks/#JuMP.callback_value","page":"Callback API","title":"JuMP.callback_value","text":"callback_value(cb_data, x::VariableRef)\n\nReturn the primal solution of a variable inside a callback.\n\ncb_data is the argument to the callback function, and the type is dependent on the solver.\n\n\n\n\n\ncallback_value(cb_data, expr::Union{GenericAffExpr, GenericQuadExpr})\n\nReturn the primal solution of an affine or quadratic expression inside a callback by getting the value for each variable appearing in the expression.\n\ncb_data is the argument to the callback function, and the type is dependent on the solver.\n\n\n\n\n\n","category":"function"},{"location":"examples/diet/","page":"The diet problem","title":"The diet problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/diet.jl\"","category":"page"},{"location":"examples/diet/#The-diet-problem","page":"The diet problem","title":"The diet problem","text":"","category":"section"},{"location":"examples/diet/","page":"The diet problem","title":"The diet problem","text":"Solve the classic \"diet problem\". Based on an example from Gurobi.","category":"page"},{"location":"examples/diet/","page":"The diet problem","title":"The diet problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction print_solution(is_optimal, foods, buy)\n    println(\"RESULTS:\")\n    if is_optimal\n        for food in foods\n            println(\"  $(food) = $(value(buy[food]))\")\n        end\n    else\n        println(\"The solver did not find an optimal solution.\")\n    end\nend\n\nfunction example_diet(; verbose = true)\n    # Nutrition guidelines\n    categories = [\"calories\", \"protein\", \"fat\", \"sodium\"]\n    category_data = Containers.DenseAxisArray([\n        1800 2200;\n        91   Inf;\n        0    65;\n        0    1779\n        ], categories, [\"min\", \"max\"]\n    )\n    Test.@test category_data[\"protein\", \"min\"] == 91.0\n    Test.@test category_data[\"sodium\", \"max\"] == 1779.0\n    # Foods\n    foods = [\n        \"hamburger\", \"chicken\", \"hot dog\", \"fries\", \"macaroni\", \"pizza\",\n        \"salad\", \"milk\", \"ice cream\",\n    ]\n    cost = Containers.DenseAxisArray(\n        [2.49, 2.89, 1.50, 1.89, 2.09, 1.99, 2.49, 0.89, 1.59],\n        foods\n    )\n    food_data = Containers.DenseAxisArray(\n        [\n            410 24 26 730;\n            420 32 10 1190;\n            560 20 32 1800;\n            380  4 19 270;\n            320 12 10 930;\n            320 15 12 820;\n            320 31 12 1230;\n            100  8 2.5 125;\n            330  8 10 180\n        ], foods, categories\n    )\n    Test.@test food_data[\"hamburger\", \"calories\"] == 410.0\n    Test.@test food_data[\"milk\", \"fat\"] == 2.5\n    # Build model\n    model = Model(GLPK.Optimizer)\n    @variables(model, begin\n        # Variables for nutrition info\n        category_data[c, \"min\"] <= nutrition[c = categories] <= category_data[c, \"max\"]\n        # Variables for which foods to buy\n        buy[foods] >= 0\n    end)\n    # Objective - minimize cost\n    @objective(model, Min, sum(cost[f] * buy[f] for f in foods))\n    # Nutrition constraints\n    @constraint(model, [c in categories],\n        sum(food_data[f, c] * buy[f] for f in foods) == nutrition[c]\n    )\n    # Solve\n    if verbose\n        println(\"Solving original problem...\")\n    end\n    optimize!(model)\n    term_status = termination_status(model)\n    is_optimal = term_status == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ≈ 11.8288 atol = 1e-4\n    if verbose\n        print_solution(is_optimal, foods, buy)\n    end\n    # Limit dairy (note that the problem will become infeasible).\n    @constraint(model, buy[\"milk\"] + buy[\"ice cream\"] <= 6)\n    if verbose\n        println(\"Solving dairy-limited problem...\")\n    end\n    optimize!(model)\n    Test.@test termination_status(model) == MOI.INFEASIBLE\n    Test.@test primal_status(model) == MOI.NO_SOLUTION\n    if verbose\n        print_solution(false, foods, buy)\n    end\n    return\nend\n\nexample_diet()","category":"page"},{"location":"examples/diet/","page":"The diet problem","title":"The diet problem","text":"View this file on Github.","category":"page"},{"location":"examples/diet/","page":"The diet problem","title":"The diet problem","text":"","category":"page"},{"location":"examples/diet/","page":"The diet problem","title":"The diet problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/clnlbeam.jl\"","category":"page"},{"location":"examples/clnlbeam/#The-clnlbeam-problem","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"","category":"section"},{"location":"examples/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"Based on an AMPL model by Hande Y. Benson","category":"page"},{"location":"examples/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"Copyright (C) 2001 Princeton University All Rights Reserved","category":"page"},{"location":"examples/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that the copyright notice and this permission notice appear in all supporting documentation.","category":"page"},{"location":"examples/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"Source: H. Maurer and H.D. Mittelman, \"The non-linear beam via optimal control with bound state variables\", Optimal Control Applications and Methods 12, pp. 19-31, 1991.","category":"page"},{"location":"examples/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"using JuMP\nimport Ipopt\n\nfunction example_clnlbeam()\n    N = 1000\n    h = 1/N\n    alpha = 350\n    model = Model(Ipopt.Optimizer)\n    @variables(model, begin\n           -1 <= t[1:(N + 1)] <= 1\n        -0.05 <= x[1:(N + 1)] <= 0.05\n                 u[1:(N + 1)]\n    end)\n    @NLobjective(\n        model,\n        Min,\n        sum(\n            0.5 * h * (u[i + 1]^2 + u[i]^2) +\n            0.5 * alpha * h * (cos(t[i + 1]) + cos(t[i]))\n            for i = 1:N\n        ),\n    )\n    @NLconstraint(\n        model,\n        [i = 1:N],\n        x[i + 1] - x[i] - 0.5 * h * (sin(t[i + 1]) + sin(t[i])) == 0,\n    )\n    @constraint(\n        model,\n        [i = 1:N],\n        t[i + 1] - t[i] - 0.5 * h * u[i + 1] - 0.5 * h * u[i] == 0,\n    )\n    optimize!(model)\n    println(\"\"\"\n    termination_status = $(termination_status(model))\n    primal_status      = $(primal_status(model))\n    objective_value    = $(objective_value(model))\n    \"\"\")\n    return\nend\n\nexample_clnlbeam()","category":"page"},{"location":"examples/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"View this file on Github.","category":"page"},{"location":"examples/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"","category":"page"},{"location":"examples/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"callbacks/#callbacks_manual","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"Many mixed-integer (linear, conic, and nonlinear) programming solvers offer the ability to modify the solve process. Examples include changing branching decisions in branch-and-bound, adding custom cutting planes, providing custom heuristics to find feasible solutions, or implementing on-demand separators to add new constraints only when they are violated by the current solution (also known as lazy constraints).","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"While historically this functionality has been limited to solver-specific interfaces, JuMP provides solver-independent support for three types of callbacks:","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"lazy constraints\nuser-cuts\nheuristic solutions","category":"page"},{"location":"callbacks/#Available-solvers","page":"Callbacks","title":"Available solvers","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"Callback support is limited to a few solvers. This includes CPLEX, GLPK, and Gurobi.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"warning: Warning\nWhile JuMP provides a solver-independent way of accessing callbacks, you should not assume that you will see identical behavior when running the same code on different solvers. For example, some solvers may ignore user-cuts for various reasons, while other solvers may add every user-cut. Read the underlying solver's callback documentation to understand details specific to each solver.","category":"page"},{"location":"callbacks/#Things-you-can-and-cannot-do-during-callbacks","page":"Callbacks","title":"Things you can and cannot do during callbacks","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"There is a very limited range of things you can do during a callback. Only use the functions and macros explicitly stated in this page of the documentation, or in the Callbacks example.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"Using any other part of the JuMP API (e.g., adding a constraint with @constraint or modifying a variable bound with set_lower_bound) is undefined behavior, and your solver may throw an error, return an incorrect solution, or result in a segfault that aborts Julia.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"In each of the three solver-independent callbacks, there are two things you may query:","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"callback_node_status returns an MOI.CallbackNodeStatusCode enum indicating if the current primal solution is integer feasible.\ncallback_value returns the current primal solution of a variable.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"If you need to query any other information, use a solver-dependent callback instead. Each solver supporting a solver-dependent callback has information on how to use it in the README of their Github repository.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"If you want to modify the problem in a callback, you must use a lazy constraint.","category":"page"},{"location":"callbacks/#Lazy-constraints","page":"Callbacks","title":"Lazy constraints","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"Lazy constraints are useful when the full set of constraints is too large to explicitly include in the initial formulation. When a MIP solver reaches a new solution, for example with a heuristic or by solving a problem at a node in the branch-and-bound tree, it will give the user the chance to provide constraint(s) that would make the current solution infeasible. For some more information about lazy constraints, see this blog post by Paul Rubin.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"A lazy constraint callback can be set using the following syntax:","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"model = Model(GLPK.Optimizer)\n@variable(model, x <= 10, Int)\n@objective(model, Max, x)\nfunction my_callback_function(cb_data)\n    status = callback_node_status(cb_data, model)\n    if status == MOI.CALLBACK_NODE_STATUS_FRACTIONAL\n        # `callback_value(cb_data, x)` is not integer (to some tolerance).\n        # If, for example, your lazy constraint generator requires an\n        # integer-feasible primal solution, you can add a `return` here.\n        return\n    elseif status == MOI.CALLBACK_NODE_STATUS_INTEGER\n        # `callback_value(cb_data, x)` is integer (to some tolerance).\n    else\n        @assert status == MOI.CALLBACK_NODE_STATUS_UNKNOWN\n        # `callback_value(cb_data, x)` might be fractional or integer.\n    end\n    x_val = callback_value(cb_data, x)\n    if x_val > 2 + 1e-6\n        con = @build_constraint(x <= 2)\n        MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n    end\nend\nMOI.set(model, MOI.LazyConstraintCallback(), my_callback_function)","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"info: Info\nThe lazy constraint callback may be called at fractional or integer nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every primal solution.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"warn: Warn\nOnly add a lazy constraint if your primal solution violates the constraint. Adding the lazy constraint irrespective of feasibility may result in the solver returning an incorrect solution, or lead to a large number of constraints being added, slowing down the solution process.model = Model(GLPK.Optimizer)\n@variable(model, x <= 10, Int)\n@objective(model, Max, x)\nfunction bad_callback_function(cb_data)\n    # Don't do this!\n    con = @build_constraint(x <= 2)\n    MOI.submit(model, MOI.LazyConstraint(cb_data), con)\nend\nfunction good_callback_function(cb_data)\n    if callback_value(x) > 2\n        con = @build_constraint(x <= 2)\n        MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n    end\nend\nMOI.set(model, MOI.LazyConstraintCallback(), good_callback_function)","category":"page"},{"location":"callbacks/#User-cuts","page":"Callbacks","title":"User cuts","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"User cuts, or simply cuts, provide a way for the user to tighten the LP relaxation using problem-specific knowledge that the solver cannot or is unable to infer from the model. Just like with lazy constraints, when a MIP solver reaches a new node in the branch-and-bound tree, it will give the user the chance to provide cuts to make the current relaxed (fractional) solution infeasible in the hopes of obtaining an integer solution. For more details about the difference between user cuts and lazy constraints see the aforementioned blog post.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"A user-cut callback can be set using the following syntax:","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"model = Model(GLPK.Optimizer)\n@variable(model, x <= 10.5, Int)\n@objective(model, Max, x)\nfunction my_callback_function(cb_data)\n    x_val = callback_value(cb_data, x)\n    con = @build_constraint(x <= floor(x_val))\n    MOI.submit(model, MOI.UserCut(cb_data), con)\nend\nMOI.set(model, MOI.UserCutCallback(), my_callback_function)","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"warning: Warning\nYour user cuts should not change the set of integer feasible solutions. Equivalently, your cuts can only remove fractional solutions. If you add a cut that removes an integer solution, the solver may return an incorrect solution.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"info: Info\nThe user-cut callback may be called at fractional nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every fractional primal solution.","category":"page"},{"location":"callbacks/#Heuristic-solutions","page":"Callbacks","title":"Heuristic solutions","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"Integer programming solvers frequently include heuristics that run at the nodes of the branch-and-bound tree. They aim to find integer solutions quicker than plain branch-and-bound would to tighten the bound, allowing us to fathom nodes quicker and to tighten the integrality gap.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"Some heuristics take integer solutions and explore their \"local neighborhood\" (e.g., flipping binary variables, fix some variables and solve a smaller MILP) and others take fractional solutions and attempt to round them in an intelligent way.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"You may want to add a heuristic of your own if you have some special insight into the problem structure that the solver is not aware of, e.g. you can consistently take fractional solutions and intelligently guess integer solutions from them.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"A heuristic solution callback can be set using the following syntax:","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"model = Model(GLPK.Optimizer)\n@variable(model, x <= 10.5, Int)\n@objective(model, Max, x)\nfunction my_callback_function(cb_data)\n    x_val = callback_value(cb_data, x)\n    status = MOI.submit(\n        model, MOI.HeuristicSolution(cb_data), [x], [floor(Int, x_val)]\n    )\n    println(\"I submitted a heuristic solution, and the status was: \", status)\nend\nMOI.set(model, MOI.HeuristicCallback(), my_callback_function)","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"The third argument to submit should be a vector of JuMP variables, and the fourth argument should be a vector of values corresponding to each variable.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"MOI.submit returns an enum that depends on whether the solver accepted the solution. The possible return codes are:","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"MOI.HEURISTIC_SOLUTION_ACCEPTED\nMOI.HEURISTIC_SOLUTION_REJECTED\nMOI.HEURISTIC_SOLUTION_UNKNOWN","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"warning: Warning\nSome solvers may accept partial solutions. Others require a feasible integer solution for every variable. If in doubt, provide a complete solution.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"info: Info\nThe heuristic solution callback may be called at fractional nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every fractional primal solution.","category":"page"},{"location":"#![JuMP-logo](assets/jump-logo-with-text.svg)","page":"Introduction","title":"(Image: JuMP logo)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Powered by NumFOCUS)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"# These comments do not display in the HTML output.\n# See https://github.com/JuliaDocs/Documenter.jl/issues/674.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nBetween versions 0.18 and 0.19, JuMP underwent a major transition in its underlying solver abstraction API, from MathProgBase to MathOptInterface. See NEWS.md for a comprehensive list of changes between the two versions, many of which are breaking. This documentation is for JuMP/MathOptInterface. For the documentation of JuMP 0.18, see here.","category":"page"},{"location":"#What-is-JuMP?","page":"Introduction","title":"What is JuMP?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP is a domain-specific modeling language for mathematical optimization embedded in Julia. It currently supports a number of open-source and commercial solvers for a variety of problem classes, including linear, mixed-integer, second-order conic, semidefinite, and nonlinear programming.","category":"page"},{"location":"#Resources-for-getting-started","page":"Introduction","title":"Resources for getting started","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Checkout the Installation Guide.\nRead the Quick Start Guide.\nBrowse some of our examples, including classics such as The diet problem, or the Maximum likelihood estimation problem using nonlinear programming.\nWork through more in-depth tutorials at JuMPTutorials.jl\nJoin the community forum to search for questions to commonly asked questions.\nBefore asking a question, make sure to read PSA: make it easier to help you, which contains a number of tips on how to ask a good question.","category":"page"},{"location":"#Key-features","page":"Introduction","title":"Key features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP's features include:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"User friendliness\nSyntax that mimics natural mathematical expressions.\nComplete documentation (WIP!)\nSpeed\nBenchmarking has shown that JuMP can create problems at similar speeds   to special-purpose modeling languages such as   AMPL.\nJuMP communicates with most solvers in memory, avoiding the need to   write intermediary files.\nSolver independence\nJuMP uses a generic solver-independent interface provided by the   MathOptInterface   package, making it easy to change between a number of open-source and   commercial optimization software packages (\"solvers\"). The Supported solvers   section contains a table of the currently supported solvers.\nAccess to advanced algorithmic techniques\nIncluding efficient LP re-solves which previously required using   solver-specific and/or low-level C++ libraries.\nEase of embedding\nJuMP itself is written purely in Julia. Solvers are the only binary   dependencies.\nBeing embedded in a general-purpose programming language makes it easy   to solve optimization problems as part of a larger workflow (e.g.,   inside a simulation, behind a web server, or as a subproblem in a   decomposition algorithm).\nAs a trade-off, JuMP's syntax is constrained by the syntax available   in Julia.\nJuMP is MPL licensed, meaning that   it can be embedded in commercial software that complies with the terms   of the license.","category":"page"},{"location":"#Citing-JuMP","page":"Introduction","title":"Citing JuMP","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you find JuMP useful in your work, we kindly request that you cite the following paper (pdf):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@article{DunningHuchetteLubin2017,\nauthor = {Iain Dunning and Joey Huchette and Miles Lubin},\ntitle = {JuMP: A Modeling Language for Mathematical Optimization},\njournal = {SIAM Review},\nvolume = {59},\nnumber = {2},\npages = {295-320},\nyear = {2017},\ndoi = {10.1137/15M1020575},\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For an earlier work where we presented a prototype implementation of JuMP, see here:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@article{LubinDunningIJOC,\nauthor = {Miles Lubin and Iain Dunning},\ntitle = {Computing in Operations Research Using Julia},\njournal = {INFORMS Journal on Computing},\nvolume = {27},\nnumber = {2},\npages = {238-248},\nyear = {2015},\ndoi = {10.1287/ijoc.2014.0623},\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A preprint of this paper is freely available.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: NumFOCUS logo)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP is a Sponsored Project of NumFOCUS, a 501(c)(3) nonprofit charity in the United States. NumFOCUS provides JuMP with fiscal, legal, and administrative support to help ensure the health and sustainability of the project. Visit numfocus.org for more information.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can support JuMP by donating.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Donations to JuMP are managed by NumFOCUS. For donors in the United States, your gift is tax-deductible to the extent provided by law. As with any donation, you should consult with your tax adviser about your particular tax situation.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP's largest expense is the annual JuMP-dev workshop. Donations will help us provide travel support for JuMP-dev attendees and take advantage of other opportunities that arise to support JuMP development.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"solutions/#Querying-Solutions","page":"Querying Solutions","title":"Querying Solutions","text":"","category":"section"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"So far we have seen all the elements and constructs related to writing a JuMP optimization model. In this section we reach the point of what to do with a solved problem. Suppose your model is named model. Right after the call to optimize!(model), it's natural to ask JuMP questions about the finished optimization step. Typical questions include:","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"Why has the optimization process stopped? Did it hit the time limit or run into numerical issues?\nDo I have a solution to my problem?\nIs it optimal?\nDo I have a dual solution?\nHow sensitive is the solution to data perturbations?","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"JuMP follows closely the concepts defined in MathOptInterface (MOI) to answer user questions about a finished call to optimize!(model). There are three main steps in querying a solution:","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"First, we can query the termination_status which will tell us why the optimization stopped. This could be due to a number of reasons. For example, the solver found an optimal solution, the problem was proven to be infeasible, or a user-provided limit such as a time limit was encountered. For more information, see the Termination statuses section below.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"Second, we can query the primal_status and the dual_status, which will tell us what kind of results we have for our primal and dual solutions. This might be an optimal primal-dual pair, a primal solution without a corresponding dual solution, or a certificate of primal or dual infeasibility. For more information, see the Solution statuses section below.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"Third, we can query value and dual to obtain the primal and dual values of the optimization variables and constraints (if there are values to be queried).","category":"page"},{"location":"solutions/#Termination-statuses","page":"Querying Solutions","title":"Termination statuses","text":"","category":"section"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"The reason why the optimization of model was finished is given by","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"termination_status(model)","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"This function will return a MOI.TerminationStatusCode enum. Common return values include MOI.OPTIMAL, MOI.INFEASIBLE, MOI.DUAL_INFEASIBLE, and MOI.TIME_LIMIT.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"Note that a return status of MOI.DUAL_INFEASIBLE does not guarantee that the primal is unbounded. When the dual is infeasible, the primal is unbounded if there exists a feasible primal solution.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"We can receive a solver specific string explaining why the optimization stopped with raw_status.","category":"page"},{"location":"solutions/#Solution-statuses","page":"Querying Solutions","title":"Solution statuses","text":"","category":"section"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"These statuses indicate what kind of result is available to be queried with value and dual. It's possible that no result is available to be queried.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"We can obtain these statuses by calling primal_status for the primal status, and dual_status for the dual status. Both will return a MOI.ResultStatusCode enum.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"Common status situations are described in the MOI docs.","category":"page"},{"location":"solutions/#Obtaining-solutions","page":"Querying Solutions","title":"Obtaining solutions","text":"","category":"section"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"Provided the primal status is not MOI.NO_SOLUTION, the primal solution can be obtained by calling value. For the dual solution, the function is dual. Calling has_values for the primal status and has_duals for the dual solution is an equivalent way to check whether the status is MOI.NO_SOLUTION.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"It is important to note that if has_values or has_duals return false, calls to value and dual might throw an error or return arbitrary values.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"The container type (e.g., scalar, vector, or matrix) of the returned solution (primal or dual) depends on the type of the variable or constraint. See AbstractShape and dual_shape for details.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"info: Info\nTo call value or dual on containers of VariableRef or ConstraintRef, use the broadcast syntax, e.g., value.(x).","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"The objective value of a solved problem can be obtained via objective_value. The best known bound on the optimal objective value can be obtained via objective_bound. If the solver supports it, the value of the dual objective can be obtained via dual_objective_value.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"The following is a recommended workflow for solving a model and querying the solution:","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"using JuMP\nmodel = Model()\n@variable(model, x[1:10] >= 0)\n# ... other constraints ...\noptimize!(model)\n\nif termination_status(model) == MOI.OPTIMAL\n    optimal_solution = value.(x)\n    optimal_objective = objective_value(model)\nelseif termination_status(model) == MOI.TIME_LIMIT && has_values(model)\n    suboptimal_solution = value.(x)\n    suboptimal_objective = objective_value(model)\nelse\n    error(\"The model was not solved correctly.\")\nend","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"warning: Warning\nQuerying solution information after modifying a solved model is undefined  behavior, and solvers may throw an error or return incorrect results. Modifications include adding, deleting, or modifying any variable,  objective, or constraint. Instead of modify then query, query the results  first, then modify the problem. For example:model = Model(GLPK.Optimizer)\n@variable(model, x >= 0)\noptimize!(model)\n# Bad:\nset_lower_bound(x, 1)\n@show value(x)\n# Good:\nx_val = value(x)\nset_lower_bound(x, 1)\n@show x_val","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"# TODO: How to accurately measure the solve time.","category":"page"},{"location":"solutions/#Accessing-MathOptInterface-attributes","page":"Querying Solutions","title":"Accessing MathOptInterface attributes","text":"","category":"section"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"MathOptInterface defines a large number of model attributes that can be queried. Examples include MOI.RelativeGap and MOI.SimplexIterations.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"Some attributes can be directly accessed by getter functions. These include","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"objective_bound\nrelative_gap\nsimplex_iterations\nbarrier_iterations\nnode_count","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"To query these attributes, use:","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"using JuMP\nmodel = Model()\n# ...\noptimize!(model)\n\n@show relative_gap(model)\n# or\n@show MOI.get(model, MOI.RelativeGap())\n\n@show simplex_iterations(model)\n# or\n@show MOI.get(model, MOI.SimplexIterations())","category":"page"},{"location":"solutions/#Sensitivity-analysis-for-LP","page":"Querying Solutions","title":"Sensitivity analysis for LP","text":"","category":"section"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"Given an LP problem and an optimal solution corresponding to a basis, we can question how much an objective coefficient or standard form right-hand side coefficient (c.f., normalized_rhs) can change without violating primal or dual feasibility of the basic solution.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"Note that not all solvers compute the basis, and for sensitivity analysis, the solver interface must implement MOI.ConstraintBasisStatus.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"To give a simple example, we could analyze the sensitivity of the optimal solution to the following (non-degenerate) LP problem:","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"model = Model();\n@variable(model, x[1:2])\nset_lower_bound(x[2], -0.5)\nset_upper_bound(x[2], 0.5)\n@constraint(model, c1, x[1] + x[2] <= 1);\n@constraint(model, c2, x[1] - x[2] <= 1);\n@objective(model, Max, x[1]);","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"DocTestSetup = quote\n    using JuMP\n    mock = MOIU.MockOptimizer(\n        MOIU.Model{Float64}(), eval_variable_constraint_dual=false\n    )\n    model = direct_model(mock)\n    @variable(model, x[1:2]);\n    set_lower_bound(x[2], -0.5)\n    set_upper_bound(x[2], 0.5)\n    @constraint(model, c1, x[1] + x[2] <= 1);\n    @constraint(model, c2, x[1] - x[2] <= 1);\n    @objective(model, Max, x[1]);\n    optimize!(model);\n    MOI.set(model, MOI.TerminationStatus(), MOI.OPTIMAL);\n    MOI.set(model, MOI.PrimalStatus(), MOI.FEASIBLE_POINT);\n    MOI.set(model, MOI.DualStatus(), MOI.FEASIBLE_POINT);\n    MOI.set(model, MOI.VariablePrimal(), x[1], 1.0);\n    MOI.set(model, MOI.VariablePrimal(), x[2], 0.0);\n    MOI.set(model, MOI.ConstraintBasisStatus(), c1, MOI.NONBASIC);\n    MOI.set(model, MOI.ConstraintBasisStatus(), c2, MOI.NONBASIC);\n    MOI.set(model, MOI.ConstraintBasisStatus(), LowerBoundRef(x[2]), MOI.BASIC);\n    MOI.set(model, MOI.ConstraintBasisStatus(), UpperBoundRef(x[2]), MOI.BASIC);\n    MOI.set(model, MOI.ConstraintDual(), c1, -0.5);\n    MOI.set(model, MOI.ConstraintDual(), c2, -0.5);\n    MOI.set(model, MOI.ConstraintDual(), LowerBoundRef(x[2]), 0.0);\n    MOI.set(model, MOI.ConstraintDual(), UpperBoundRef(x[2]), 0.0);\nend","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"To analyze the sensitivity of the problem we could check the allowed perturbation ranges of, e.g., the cost coefficients and the right-hand side coefficient of the constraint c1 as follows:","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"julia> optimize!(model)\n\njulia> value.(x)\n2-element Array{Float64,1}:\n 1.0\n 0.0\n\njulia> report = lp_sensitivity_report(model);\n\njulia> x1_lo, x1_hi = report[x[1]]\n(-1.0, Inf)\n\njulia> println(\"The objective coefficient of x[1] could decrease by $(x1_lo) or increase by $(x1_hi).\")\nThe objective coefficient of x[1] could decrease by -1.0 or increase by Inf.\n\njulia> x2_lo, x2_hi = report[x[2]]\n(-1.0, 1.0)\n\njulia> println(\"The objective coefficient of x[2] could decrease by $(x2_lo) or increase by $(x2_hi).\")\nThe objective coefficient of x[2] could decrease by -1.0 or increase by 1.0.\n\njulia> c_lo, c_hi = report[c1]\n(-1.0, 1.0)\n\njulia> println(\"The RHS of c1 could decrease by $(c_lo) or increase by $(c_hi).\")\nThe RHS of c1 could decrease by -1.0 or increase by 1.0.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"The range associated with a variable is the range of the allowed perturbation of the corresponding objective coefficient. Note that the current primal solution remains optimal within this range; however the corresponding dual solution might change since a cost coefficient is perturbed. Similarly, the range associated with a constraint is the range of the allowed perturbation of the corresponding right-hand side coefficient. In this range the current dual solution remains optimal, but the optimal primal solution might change.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"If the problem is degenerate, there are multiple optimal bases and hence these ranges might not be as intuitive and seem too narrow. E.g., a larger cost coefficient perturbation might not invalidate the optimality of the current primal solution. Moreover, if a problem is degenerate, due to finite precision, it can happen that, e.g., a perturbation seems to invalidate a basis even though it doesn't (again providing too narrow ranges). To prevent this, increase the atol keyword argument to lp_sensitivity_report. Note that this might make the ranges too wide for numerically challenging instances. Thus, do not blindly trust these ranges, especially not for highly degenerate or numerically unstable instances.","category":"page"},{"location":"solutions/#Conflicts","page":"Querying Solutions","title":"Conflicts","text":"","category":"section"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"When the model you input is infeasible, some solvers can help you find the cause of this infeasibility by offering a conflict, i.e., a subset of the constraints that create this infeasibility. Depending on the solver, this can also be called an IIS (irreducible inconsistent subsystem).","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"The function compute_conflict! is used to trigger the computation of a conflict. Once this process is finished, the attribute MOI.ConflictStatus returns a MOI.ConflictStatusCode.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"If there is a conflict, you can query from each constraint whether it participates in the conflict or not using the attribute MOI.ConstraintConflictStatus, which returns a MOI.ConflictParticipationStatusCode.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"For instance, this is how you can use this functionality:","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"using JuMP\nmodel = Model() # You must use a solver that supports conflict refining/IIS computation, like CPLEX or Gurobi\n@variable(model, x >= 0)\n@constraint(model, c1, x >= 2)\n@constraint(model, c2, x <= 1)\noptimize!(model)\n\n# termination_status(model) will likely be MOI.INFEASIBLE,\n# depending on the solver\n\ncompute_conflict!(model)\nif MOI.get(model, MOI.ConflictStatus()) != MOI.CONFLICT_FOUND\n    error(\"No conflict could be found for an infeasible model.\")\nend\n\n# Both constraints should participate in the conflict.\nMOI.get(model, MOI.ConstraintConflictStatus(), c1)\nMOI.get(model, MOI.ConstraintConflictStatus(), c2)","category":"page"},{"location":"solutions/#Multiple-solutions","page":"Querying Solutions","title":"Multiple solutions","text":"","category":"section"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"Some solvers support returning multiple solutions. You can check how many solutions are available to query using result_count.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"Functions for querying the solutions, e.g., primal_status and value, all take an additional keyword argument result which can be used to specify which result to return.","category":"page"},{"location":"solutions/","page":"Querying Solutions","title":"Querying Solutions","text":"using JuMP\nmodel = Model()\n@variable(model, x[1:10] >= 0)\n# ... other constraints ...\noptimize!(model)\n\nif termination_status(model) != MOI.OPTIMAL\n    error(\"The model was not solved correctly.\")\nend\n\nnum_results = result_count(model)\n@assert has_values(model; result = num_results)\nan_optimal_solution = value.(x; result = num_results)\nan_optimal_objective = objective_value(model; result = num_results)","category":"page"},{"location":"examples/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/robust_uncertainty.jl\"","category":"page"},{"location":"examples/robust_uncertainty/#Robust-uncertainty-sets","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"","category":"section"},{"location":"examples/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"Computes the Value at Risk for a data-driven uncertainty set; see \"Data-Driven Robust Optimization\" (Bertsimas 2013), section 6.1 for details. Closed-form expressions for the optimal value are available.","category":"page"},{"location":"examples/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"using JuMP\nimport SCS\nimport LinearAlgebra\nimport Test\n\nfunction example_robust_uncertainty()\n    R = 1\n    d = 3\n    𝛿 = 0.05\n    ɛ = 0.05\n    N = ceil((2 + 2 * log(2 / 𝛿))^2) + 1\n    c = randn(d)\n    μhat = rand(d)\n    M = rand(d, d)\n    Σhat = 1 / (d - 1) * (M - ones(d) * μhat')' * (M - ones(d) * μhat')\n    Γ1(𝛿, N) = R / sqrt(N) * (2 + sqrt(2 * log(1 / 𝛿)))\n    Γ2(𝛿, N) = 2 * R^2 / sqrt(N) * (2 + sqrt(2 * log(2 / 𝛿)))\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, Σ[1:d, 1:d], PSD)\n    @variable(model, u[1:d])\n    @variable(model, μ[1:d])\n    @constraint(model, [Γ1(𝛿 / 2, N); μ - μhat] in SecondOrderCone())\n    @constraint(model, [Γ2(𝛿 / 2, N); vec(Σ - Σhat)] in SecondOrderCone())\n    @SDconstraint(model, [((1 - ɛ) / ɛ) (u - μ)'; (u - μ) Σ] >= 0)\n    @objective(model, Max, LinearAlgebra.dot(c, u))\n    optimize!(model)\n    I = Matrix(1.0 * LinearAlgebra.I, d, d)\n    exact =\n        LinearAlgebra.dot(μhat, c) +\n        Γ1(𝛿 / 2, N) * LinearAlgebra.norm(c) +\n        sqrt((1 - ɛ) / ɛ) * sqrt(LinearAlgebra.dot(c, (Σhat + Γ2(𝛿 / 2, N) * I) * c))\n    Test.@test objective_value(model) ≈ exact atol = 1e-3\n    return\nend\n\nexample_robust_uncertainty()","category":"page"},{"location":"examples/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"View this file on Github.","category":"page"},{"location":"examples/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"","category":"page"},{"location":"examples/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/transp/","page":"The transportation problem","title":"The transportation problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/transp.jl\"","category":"page"},{"location":"examples/transp/#The-transportation-problem","page":"The transportation problem","title":"The transportation problem","text":"","category":"section"},{"location":"examples/transp/","page":"The transportation problem","title":"The transportation problem","text":"Allocation of passenger cars to trains to minimize cars required or car-miles run. Based on:","category":"page"},{"location":"examples/transp/","page":"The transportation problem","title":"The transportation problem","text":"Fourer, D.M. Gay and Brian W. Kernighan, A Modeling Language for Mathematical Programming, https://ampl.com/REFS/amplmod.ps.gz Appendix D.","category":"page"},{"location":"examples/transp/","page":"The transportation problem","title":"The transportation problem","text":"Originally contributed by Louis Luangkesorn, January 30, 2015.","category":"page"},{"location":"examples/transp/","page":"The transportation problem","title":"The transportation problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_transp()\n\tORIG = [\"GARY\", \"CLEV\", \"PITT\"]\n\tDEST = [\"FRA\", \"DET\", \"LAN\", \"WIN\", \"STL\", \"FRE\", \"LAF\"]\n\tsupply = [1_400, 2_600, 2_900]\n\tdemand = [900, 1_200, 600, 400, 1_700, 1_100, 1_000]\n\tTest.@test sum(supply) == sum(demand)\n\tcost = [\n\t\t39   14   11   14   16   82    8;\n\t\t27    9   12    9   26   95   17;\n\t\t24   14   17   13   28   99   20\n\t]\n\tmodel = Model(GLPK.Optimizer)\n\t@variable(model, trans[1:length(ORIG), 1:length(DEST)] >= 0)\n\t@objective(\n\t\tmodel,\n\t\tMin,\n\t\tsum(\n\t\t\tcost[i, j] * trans[i, j]\n\t\t\tfor i in 1:length(ORIG), j in 1:length(DEST)\n\t\t)\n\t)\n\t@constraints(model, begin\n\t\t[i in 1:length(ORIG)], sum(trans[i, :]) == supply[i]\n\t\t[j in 1:length(DEST)], sum(trans[:, j]) == demand[j]\n\tend)\n\toptimize!(model)\n\tTest.@test termination_status(model) == MOI.OPTIMAL\n\tTest.@test primal_status(model) == MOI.FEASIBLE_POINT\n\tTest.@test objective_value(model) == 196200.0\n\tprintln(\"The optimal solution is:\")\n\tprintln(value.(trans))\n\treturn\nend\n\nexample_transp()","category":"page"},{"location":"examples/transp/","page":"The transportation problem","title":"The transportation problem","text":"View this file on Github.","category":"page"},{"location":"examples/transp/","page":"The transportation problem","title":"The transportation problem","text":"","category":"page"},{"location":"examples/transp/","page":"The transportation problem","title":"The transportation problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"≤|<=\", r\"≥|>=\", r\" == | = \", r\" ∈ | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"This page explains how to write various types of constraints in JuMP. Before reading further, please make sure you are familiar with JuMP models, and JuMP Variables. For nonlinear constraints, see Nonlinear Modeling instead.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"JuMP is based on the MathOptInterface (MOI) API. Because of this, JuMP thinks of a constraint as the restriction that the output of a function belongs to a set. For example, instead of representing a constraint a^top x le b as a less-than-or-equal-to constraint, JuMP models this as the scalar affine function a^top x belonging to the less-than set (-infty b. Thus, instead of a less-than-or-equal-to constraint, we consider this constraint to be a scalar affine -in- less than constraint. More generally, we use the shorthand function-in-set to refer to constraints composed of different types of functions and sets. In the rest of this page, we will introduce the different types of functions and sets that JuMP knows about as needed. You can read more details about this function-in-set concept in the MOI documentation.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nThe examples use MOI as an alias for the MathOptInterface module. This alias is defined by using JuMP. You may also define it in your code byimport MathOptInterface\nconst MOI = MathOptInterface","category":"page"},{"location":"constraints/#The-@constraint-macro","page":"Constraints","title":"The @constraint macro","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Constraints are added to a JuMP model using the @constraint macro. Here is an example of how to add the constraint 2x le 1 to a JuMP model:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Wasn't that easy! Let's unpack what happened, because just like @variable there are a few subtle things going on.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The mathematical constraint 2x le 1 was added to the model.\nA Julia variable called con was created that is a reference to the constraint.\nThis Julia variable was stored in model and can be accessed by model[:con].\nJuMP set the name attribute (the one that is shown when printing) of the constraint to \"con\".","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Just like the Julia variables created in @variable, con can be bound to a different value. For example:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> con\ncon : 2 x <= 1.0\n\njulia> con = 1\n1\n\njulia> con\n1","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"However, the reference can be retrieved by querying the model using the symbolic name:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> con = model[:con]\ncon : 2 x <= 1.0\n\njulia> con\ncon : 2 x <= 1.0","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Because the named variables and constraints are stored in the same namespace, creating a constraint with the same name as a variable or an existing constraint will result in an error. To overcome this limitation, it is possible to create anonymous constraints, just like it is possible to create Anonymous JuMP variables. This is done by dropping the second argument to @constraint:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> con = @constraint(model, 2x <= 1)\n2 x <= 1.0","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"It is also possible use different comparison operators (e.g., >= and ==) to create the following types of constraints:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, 2x >= 1)\n2 x >= 1.0\n\njulia> @constraint(model, 2x == 1)\n2 x = 1.0\n\njulia> @constraint(model, 1 <= 2x <= 3)\n2 x ∈ [1.0, 3.0]","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Note that JuMP normalizes the constraints by moving all of the terms containing variables to the left-hand side, and all of the constant terms to the right-hand side. Thus, we get:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, 2x + 1 <= 4x + 4)\n-2 x <= 3.0","category":"page"},{"location":"constraints/#The-@constraints-macro","page":"Constraints","title":"The @constraints macro","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Like @variables, there is a \"plural\" version of the @constraint macro:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraints(model, begin\n           2x <=  1\n            x >= -1\n       end)\n\njulia> print(model)\nFeasibility\nSubject to\n x ≥ -1.0\n 2 x ≤ 1.0","category":"page"},{"location":"constraints/#constraint_duality","page":"Constraints","title":"Duality","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"JuMP adopts the notion of conic duality from MOI. For linear programs, a feasible dual on a >= constraint is nonnegative and a feasible dual on a <= constraint is nonpositive. If the constraint is an equality constraint, it depends on which direction is binding.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nJuMP's definition of duality is independent of the objective sense. That is, the sign of feasible duals associated with a constraint depends on the direction of the constraint and not whether the problem is maximization or minimization. This is a different convention from linear programming duality in some common textbooks. If you have a linear program, and you want the textbook definition, you probably want to use shadow_price and reduced_cost instead.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The dual value associated with a constraint in the most recent solution can be accessed using the dual function. You can use the has_duals function to check whether the model has a dual solution available to query. For example:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x <= 1)\ncon : x <= 1.0\n\njulia> has_duals(model)\nfalse","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"DocTestSetup = quote\n    using JuMP\n    model = Model(() -> MOIU.MockOptimizer(\n                            MOIU.Model{Float64}(),\n                            eval_objective_value = false,\n                            eval_variable_constraint_dual = false));\n    @variable(model, x);\n    @constraint(model, con, x <= 1);\n    @objective(model, Max, -2x);\n    optimize!(model);\n    mock = backend(model).optimizer.model;\n    MOI.set(mock, MOI.TerminationStatus(), MOI.OPTIMAL)\n    MOI.set(mock, MOI.DualStatus(), MOI.FEASIBLE_POINT)\n    MOI.set(mock, MOI.ConstraintDual(), optimizer_index(con), -2.0)\nend","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @objective(model, Min, -2x)\n-2 x\n\njulia> optimize!(model)\n\njulia> has_duals(model)\ntrue\n\njulia> dual(con)\n-2.0\n\njulia> @objective(model, Max, 2x)\n2 x\n\njulia> optimize!(model)\n\njulia> dual(con)\n-2.0","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"To help users who may be less familiar with conic duality, JuMP provides the shadow_price function which returns a value that can be interpreted as the improvement in the objective in response to an infinitesimal relaxation (on the scale of one unit) in the right-hand side of the constraint. shadow_price can be used only on linear constraints with a <=, >=, or == comparison operator.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"In the example above, dual(con) returned -2.0 regardless of the optimization sense. However, in the second case when the optimization sense is Max, shadow_price returns:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> shadow_price(con)\n2.0","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"To query the dual variables associated with a variable bound, first obtain a constraint reference using one of UpperBoundRef, LowerBoundRef, or FixRef, and then call dual on the returned constraint reference. The reduced_cost function may simplify this process as it returns the shadow price of an active bound of a variable (or zero, if no active bound exists).","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"DocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"constraints/#Constraint-names","page":"Constraints","title":"Constraint names","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The name, i.e. the value of the MOI.ConstraintName attribute, of a constraint can be obtained by name(::JuMP.ConstraintRef) and set by set_name(::JuMP.ConstraintRef, ::String).","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The constraint can also be retrieved from its name using constraint_by_name.","category":"page"},{"location":"constraints/#Start-Values","page":"Constraints","title":"Start Values","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Provide a starting value (also called warmstart) for a constraint's dual using set_dual_start_value.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The start value of a constraint's dual can be queried using dual_start_value. If no start value has been set, dual_start_value will return nothing.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x >= 10)\ncon : x ≥ 10.0\n\njulia> dual_start_value(con)\n\njulia> set_dual_start_value(con, 2)\n\njulia> dual_start_value(con)\n2.0","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"A vector constraint will require a vector warmstart:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, con, x in SecondOrderCone())\ncon : [x[1], x[2], x[3]] in MathOptInterface.SecondOrderCone(3)\n\njulia> dual_start_value(con)\n\njulia> set_dual_start_value(con, [1.0, 2.0, 3.0])\n\njulia> dual_start_value(con)\n3-element Array{Float64,1}:\n 1.0\n 2.0\n 3.0","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"To take the dual solution from the last solve and use it as the starting point for a new solve, use:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"for (F, S) in list_of_constraint_types(model)\n    for con in all_constraints(model, F, S)\n        set_dual_start_value(con, dual(con))\n    end\nend","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nSome constraints might not have well defined duals, hence one might need to filter (F, S) pairs.","category":"page"},{"location":"constraints/#Constraint-containers","page":"Constraints","title":"Constraint containers","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"So far, we've added constraints one-by-one. However, just like Variable containers, JuMP provides a mechanism for building groups of constraints compactly. References to these groups of constraints are returned in containers. Three types of constraint containers are supported: Arrays, DenseAxisArrays, and SparseAxisArrays. We explain each of these in the following.","category":"page"},{"location":"constraints/#constraint_arrays","page":"Constraints","title":"Arrays","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"One way of adding a group of constraints compactly is the following:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con[i = 1:3], i * x <= i + 1)\n3-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n con[1] : x <= 2.0\n con[2] : 2 x <= 3.0\n con[3] : 3 x <= 4.0","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"JuMP returns references to the three constraints in an Array that is bound to the Julia variable con. This array can be accessed and sliced as you would with any Julia array:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> con[1]\ncon[1] : x <= 2.0\n\njulia> con[2:3]\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n con[2] : 2 x <= 3.0\n con[3] : 3 x <= 4.0","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Anonymous containers can also be constructed by dropping the name (e.g. con) before the square brackets:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, [i = 1:2], i * x <= i + 1)\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n x <= 2.0\n 2 x <= 3.0","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Just like @variable, JuMP will form an Array of constraints when it can determine at parse time that the indices are one-based integer ranges. Therefore con[1:b] will create an Array, but con[a:b] will not. A special case is con[Base.OneTo(n)] which will produce an Array. If JuMP cannot determine that the indices are one-based integer ranges (e.g., in the case of con[a:b]), JuMP will create a DenseAxisArray instead.","category":"page"},{"location":"constraints/#DenseAxisArrays","page":"Constraints","title":"DenseAxisArrays","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The syntax for constructing a DenseAxisArray of constraints is very similar to the syntax for constructing a DenseAxisArray of variables.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con[i = 1:2, j = 2:3], i * x <= j + 1)\n2-dimensional DenseAxisArray{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, 2:3\nAnd data, a 2×2 Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},2}:\n con[1,2] : x <= 3.0    con[1,3] : x <= 4.0\n con[2,2] : 2 x <= 3.0  con[2,3] : 2 x <= 4.0","category":"page"},{"location":"constraints/#SparseAxisArrays","page":"Constraints","title":"SparseAxisArrays","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The syntax for constructing a SparseAxisArray of constraints is very similar to the syntax for constructing a SparseAxisArray of variables.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con[i = 1:2, j = 1:2; i != j], i * x <= j + 1)\nJuMP.Containers.SparseAxisArray{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},2,Tuple{Int64,Int64}} with 2 entries:\n  [1, 2]  =  con[1,2] : x <= 3.0\n  [2, 1]  =  con[2,1] : 2 x <= 2.0","category":"page"},{"location":"constraints/#Forcing-the-container-type","page":"Constraints","title":"Forcing the container type","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"When creating a container of constraints, JuMP will attempt to choose the tightest container type that can store the constraints. However, because this happens at parse time, it does not always make the best choice. Just like in @variable, we can force the type of container using the container keyword. For syntax and the reason behind this, take a look at the variable docs.","category":"page"},{"location":"constraints/#Vectorized-constraints","page":"Constraints","title":"Vectorized constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"We can also add constraints to JuMP using vectorized linear algebra. For example:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[i=1:2])\n2-element Array{VariableRef,1}:\n x[1]\n x[2]\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> b = [5, 6]\n2-element Array{Int64,1}:\n 5\n 6\n\njulia> @constraint(model, con, A * x .== b)\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}},ScalarShape},1}:\n x[1] + 2 x[2] == 5.0\n 3 x[1] + 4 x[2] == 6.0","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nMake sure to use Julia's dot syntax in front of the comparison operators (e.g. .==, .>=, and .<=). If you use a comparison without the dot, an error will be thrown.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Instead of adding an array of ScalarAffineFunction-in-EqualTo constraints, we can instead construct a VectorAffineFunction-in-Nonnegatives constraint as follows:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, A * x - b in MOI.Nonnegatives(2))\n[x[1] + 2 x[2] - 5, 3 x[1] + 4 x[2] - 6] in MathOptInterface.Nonnegatives(2)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"In addition to the Nonnegatives set, MOI defines a number of other vector-valued sets such as Nonpositives. See the MOI documentation for more information.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Note also that for the first time we have used an explicit function-in-set description of the constraint. Read more about this representation for constraints in the MOI documentation.","category":"page"},{"location":"constraints/#Constraints-on-a-single-variable","page":"Constraints","title":"Constraints on a single variable","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"In Variables, we saw how to modify the variable bounds, as well as add binary and integer restrictions to the domain of each variable. This can also be achieved using the @constraint macro. For example, MOI.ZeroOne() restricts the domain to 0 1:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.ZeroOne())\nx binary","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"and MOI.Integer() restricts to the domain to the integers mathbbZ:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.Integer())\nx integer","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"JuMP also supports modeling semi-continuous variables, whose domain is 0  l u, using the MOI.Semicontinuous set:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.Semicontinuous(1.5, 3.5))\nx in MathOptInterface.Semicontinuous{Float64}(1.5, 3.5)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"as well as semi-integer variables, whose domain is 0  l l+1 dots u, using the MOI.Semiinteger set:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.Semiinteger(1.0, 3.0))\nx in MathOptInterface.Semiinteger{Float64}(1.0, 3.0)","category":"page"},{"location":"constraints/#Quadratic-constraints","page":"Constraints","title":"Quadratic constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"In addition to affine functions, JuMP also supports constraints with quadratic terms. (For more general nonlinear functions, see Nonlinear Modeling.) For example:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[i=1:2])\n2-element Array{VariableRef,1}:\n x[1]\n x[2]\n\njulia> @variable(model, t >= 0)\nt\n\njulia> @constraint(model, x[1]^2 + x[2]^2 <= t^2)\nx[1]² + x[2]² - t² <= 0.0","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Note that this quadratic constraint (including the lower bound on t) is equivalent to a second order cone constraint where ||x[1]^2 + x[2]^2||\\_2 ≤ t and t ≥ 0. Instead of writing out the quadratic expansion, we can pass JuMP the constraint in function-in-set form. To do so, we need to define the function and the set.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The function is a vector of variables:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> [t, x[1], x[2]]\n3-element Array{VariableRef,1}:\n t\n x[1]\n x[2]","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Note that the variable t comes first, followed by the x arguments. The set is an instance of SecondOrderCone: SecondOrderCone(). Thus, we can add the second order cone constraint as follows:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, [t, x[1], x[2]] in SecondOrderCone())\n[t, x[1], x[2]] in MathOptInterface.SecondOrderCone(3)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"JuMP also supports the RotatedSecondOrderCone which requires the addition of a perspective variable u. The rotated second order cone constraints the variables t, u, and x such that: ||x[1]^2 + x[2]^2||\\_2 ≤ t × u and t, u ≥ 0. It can be added as follows:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, u)\nu\n\njulia> @constraint(model, [t, u, x[1], x[2]] in RotatedSecondOrderCone())\n[t, u, x[1], x[2]] in MathOptInterface.RotatedSecondOrderCone(4)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"In addition to the second order cone and rotated second order cone, MOI defines a number of other conic sets such as the exponential and power cones. See the MathOptInterface documentation for more information.","category":"page"},{"location":"constraints/#Constraints-on-a-collection-of-variables","page":"Constraints","title":"Constraints on a collection of variables","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"In addition to constraining the domain of a single variable, JuMP supports placing constraints of a subset of the variables. We already saw an example of this in the Quadratic constraints section when we constrained a vector of variables to belong to the second order cone.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"In a special ordered set of type I (often denoted SOS-I), at most one variable can take a non-zero value. We can construct SOS-I constraints using the MOI.SOS1 set:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in MOI.SOS1([1.0, 2.0, 3.0]))\n[x[1], x[2], x[3]] in MathOptInterface.SOS1{Float64}([1.0, 2.0, 3.0])","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Note that we have to pass MOI.SOS1 a weight vector. This vector implies an ordering on the variables. If the decision variables are related and have a physical ordering (e.g., they correspond to the size of a factory to be built, and the SOS-I constraint enforces that only one factory can be built), then the weight vector, although not used directly in the constraint, can help the solver make a better decision in the solution process.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"This ordering is more important in a special ordered set of type II (SOS-II), in which at most two values can be non-zero, and if there are two non-zeros, they must be consecutive according to the ordering. For example, in the following constraint, the possible non-zero pairs are (x[1] and x[3]) and (x[2] and x[3]):","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.SOS2([3.0, 1.0, 2.0]))\n[x[1], x[2], x[3]] in MathOptInterface.SOS2{Float64}([3.0, 1.0, 2.0])","category":"page"},{"location":"constraints/#Indicator-constraints","page":"Constraints","title":"Indicator constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"JuMP provides a special syntax for creating indicator constraints, that is, enforce a constraint to hold depending on the value of a binary variable. In order to constrain the constraint x + y <= 1 to hold when a binary variable a is one, use the following syntax:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @variable(model, a, Bin)\na\n\njulia> @constraint(model, a => {x + y <= 1})\na => {x + y ≤ 1.0}","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"If instead the constraint should hold when a is zero, simply add a ! or ¬ before the binary variable.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, !a => {x + y <= 1})\n!a => {x + y ≤ 1.0}","category":"page"},{"location":"constraints/#Semidefinite-constraints","page":"Constraints","title":"Semidefinite constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"JuMP provides a special syntax for constraining a matrix to be symmetric positive semidefinite (PSD) with the @SDconstraint macro. In the context of this macro, the inequality A >= B between two square matrices A and B is understood as constraining A - B to be symmetric positive semidefinite.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x)\nx\n\njulia> @SDconstraint(model, [x 2x; 3x 4x] >= ones(2, 2))\n[x - 1    2 x - 1;\n 3 x - 1  4 x - 1] ∈ PSDCone()","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Solvers supporting such constraints usually expect to be given a matrix that is symbolically symmetric, that is, for which the expression in corresponding off-diagonal entries are the same. In our example, the expressions of entries (1, 2) and (2, 1) are respectively 2x - 1 and 3x - 1 which are different. To bridge the gap between the constraint modeled and what the solver expects, JuMP creates an equality constraint 3x - 1 == 2x - 1 and constrains the symmetric matrix [x - 1, 2 x - 1, 2 x - 1, 4 x - 1] to be positive semidefinite.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nIf the matrix provided is already symbolically symmetric, the equality constrains are equivalent to 0 = 0 and are not added. In practice, if all coefficients are smaller than 1e-10, the constraint is ignored, if all coefficients are smaller than 1e-8 but some are larger than 1e-10, it is ignored but a warning is displayed, otherwise if at least one coefficient is larger than 1e-8, the constraint is added.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"If the matrix is known to be symmetric, the PSD constraint can be added as follows:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> using LinearAlgebra\n\njulia> @constraint(model, Symmetric([x 2x; 2x 4x] - ones(2, 2)) in PSDCone())\n[x - 1    2 x - 1;\n 2 x - 1  4 x - 1] ∈ PSDCone()","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Note that the lower triangular entries are silently ignored even if they are different so use it with caution:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> cref = @constraint(model, Symmetric([x 2x; 3x 4x]) in PSDCone())\n[x    2 x;\n 2 x  4 x] ∈ PSDCone()\n\njulia> jump_function(constraint_object(cref))\n3-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x\n 2 x\n 4 x\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeTriangle(2)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Note that as @SDconstraint(model, A >= B) constrains A - B to be symmetric positive semidefinite, even if A is a matrix of variables and B is a matrix of zeros, A - B will be a matrix of affine expressions. For instance, in the example below, the function is VectorAffineFunction instead of VectorOfVariables.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> typeof(@SDconstraint(model, [x x; x x] >= zeros(2, 2)))\nConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64},MathOptInterface.PositiveSemidefiniteConeSquare},SquareMatrixShape}","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Moreover, the Symmetric structure can be lost in the operation A - B. For instance, in the example below, the set is PositiveSemidefiniteConeSquare instead of PositiveSemidefiniteConeTriangle.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> typeof(@SDconstraint(model, Symmetric([x x; x x]) >= zeros(2, 2)))\nConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64},MathOptInterface.PositiveSemidefiniteConeSquare},SquareMatrixShape}","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"To create a constraint on the vector of variables with the @SDconstraint macro, use the 0 symbol. The following three syntax are equivalent:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"@SDconstraint(model, A >= 0),\n@SDconstraint(model, 0 <= A) and\n@constraint(model, A in PSDCone()).","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> typeof(@SDconstraint(model, [x x; x x] >= 0))\nConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables,MathOptInterface.PositiveSemidefiniteConeSquare},SquareMatrixShape}\n\njulia> typeof(@SDconstraint(model, 0 <= Symmetric([x x; x x])))\nConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables,MathOptInterface.PositiveSemidefiniteConeTriangle},SymmetricMatrixShape}","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"As the syntax is recognized at parse time, using a variable with value zero does not work:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> a = 0\n0\n\njulia> @SDconstraint(model, [x x; x x] >= a)\nERROR: Operation `-` between `Array{VariableRef,2}` and `Int64` is not allowed. You should use broadcast.\n[...]","category":"page"},{"location":"constraints/#Constraint-modifications","page":"Constraints","title":"Constraint modifications","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"A common paradigm, especially in linear programming, is to repeatedly solve a model with different coefficients.","category":"page"},{"location":"constraints/#Modifying-a-constant-term","page":"Constraints","title":"Modifying a constant term","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Use set_normalized_rhs to modify the right-hand side (constant) term of a constraint. Use normalized_rhs to query the right-hand side term.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0\n\njulia> set_normalized_rhs(con, 3)\n\njulia> con\ncon : 2 x <= 3.0\n\njulia> normalized_rhs(con)\n3.0","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nJuMP normalizes constraints into a standard form by moving all constant terms onto the right-hand side of the constraint.@constraint(model, 2x - 1 <= 2)will be normalized to@constraint(model, 2x <= 3)set_normalized_rhs sets the right-hand side term of the normalized constraint.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"If constraints are complicated, e.g., they are composed of a number of components, each of which has a constant term, then it may be difficult to calculate what the right-hand side term should be in the standard form.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"For this situation, JuMP includes the ability to fix variables to a value using the fix function. Fixing a variable sets its lower and upper bound to the same value. Thus, changes in a constant term can be simulated by adding a dummy variable and fixing it to different values. Here is an example:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, const_term)\nconst_term\n\njulia> @constraint(model, con, 2x <= const_term + 1)\ncon : 2 x - const_term <= 1.0\n\njulia> fix(const_term, 1.0)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The constraint con is now equivalent to 2x <= 2.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nEven though const_term is fixed, it is still a decision variable. Thus, const_term * x is bilinear. Fixed variables are not replaced with constants when communicating the problem to a solver.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Another option is to use add_to_function_constant. The constant given is added to the function of a func-in-set constraint. In the following example, adding 2 to the function has the effect of removing 2 to the right-hand side:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0\n\njulia> add_to_function_constant(con, 2)\n\njulia> con\ncon : 2 x <= -1.0\n\njulia> normalized_rhs(con)\n-1.0","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"In the case of interval constraints, the constant is removed in each bounds.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 0 <= 2x + 1 <= 2)\ncon : 2 x ∈ [-1.0, 1.0]\n\njulia> add_to_function_constant(con, 3)\n\njulia> con\ncon : 2 x ∈ [-4.0, -2.0]","category":"page"},{"location":"constraints/#Modifying-a-variable-coefficient","page":"Constraints","title":"Modifying a variable coefficient","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"To modify the coefficients for a linear term in a constraint (but notably not yet the coefficients on a quadratic term), use set_normalized_coefficient. To query the current coefficient, use normalized_coefficient.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x[1] + x[2] <= 1)\ncon : 2 x[1] + x[2] ≤ 1.0\n\njulia> set_normalized_coefficient(con, x[2], 0)\n\njulia> con\ncon : 2 x[1] ≤ 1.0\n\njulia> normalized_coefficient(con, x[2])\n0.0","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nJuMP normalizes constraints into a standard form by moving all terms involving variables onto the left-hand side of the constraint.@constraint(model, 2x <= 1 - x)will be normalized to@constraint(model, 3x <= 1)set_normalized_coefficient sets the coefficient of the normalized constraint.","category":"page"},{"location":"constraints/#Constraint-deletion","page":"Constraints","title":"Constraint deletion","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Constraints can be deleted from a model using delete. Just like variable references, it is possible to check if a constraint reference is valid using is_valid. Here is an example of deleting a constraint:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0\n\njulia> is_valid(model, con)\ntrue\n\njulia> delete(model, con)\n\njulia> is_valid(model, con)\nfalse","category":"page"},{"location":"constraints/#Accessing-constraints-from-a-model","page":"Constraints","title":"Accessing constraints from a model","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"You can query the types of constraints currently present in the model by calling list_of_constraint_types. Then, given a function and set type, use num_constraints to access the number of constraints of this type and all_constraints to access a list of their references. Then use constraint_object to get an instance of an AbstractConstraint object, either ScalarConstraint or VectorConstraint, that stores the constraint data.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[i=1:2] >= i, Int);\n\njulia> @constraint(model, x[1] + x[2] <= 1);\n\njulia> list_of_constraint_types(model)\n3-element Array{Tuple{DataType,DataType},1}:\n (GenericAffExpr{Float64,VariableRef}, MathOptInterface.LessThan{Float64})\n (VariableRef, MathOptInterface.GreaterThan{Float64})\n (VariableRef, MathOptInterface.Integer)\n\njulia> num_constraints(model, VariableRef, MOI.Integer)\n2\n\njulia> all_constraints(model, VariableRef, MOI.Integer)\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.Integer},ScalarShape},1}:\n x[1] integer\n x[2] integer\n\njulia> num_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n2\n\njulia> all_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}},ScalarShape},1}:\n x[1] ≥ 1.0\n x[2] ≥ 2.0\n\njulia> num_constraints(model, GenericAffExpr{Float64,VariableRef}, MOI.LessThan{Float64})\n1\n\njulia> less_than_constraints = all_constraints(model, GenericAffExpr{Float64,VariableRef}, MOI.LessThan{Float64})\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n x[1] + x[2] ≤ 1.0\n\njulia> con = constraint_object(less_than_constraints[1])\nScalarConstraint{GenericAffExpr{Float64,VariableRef},MathOptInterface.LessThan{Float64}}(x[1] + x[2], MathOptInterface.LessThan{Float64}(1.0))\n\njulia> con.func\nx[1] + x[2]\n\njulia> con.set\nMathOptInterface.LessThan{Float64}(1.0)","category":"page"},{"location":"constraints/#Complementarity-constraints","page":"Constraints","title":"Complementarity constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"A mixed complementarity constraint F(x) ⟂ x consists of finding x in the interval [lb, ub], such that the following holds:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"F(x) == 0 if lb < x < ub\nF(x) >= 0 if lb == x\nF(x) <= 0 if x == ub","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"For more information, see the MOI.Complements documentation.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"JuMP supports mixed complementarity constraints via complements(F(x), x) or F(x) ⟂ x in the @constraint macro. The interval set [lb, ub] is obtained from the variable bounds on x.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"For example, to define the problem 2x - 1 ⟂ x with x ∈ [0, ∞), do:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x >= 0)\nx\n\njulia> @constraint(model, 2x - 1 ⟂ x)\n[2 x - 1, x] ∈ MathOptInterface.Complements(1)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"This problem has a unique solution at x = 0.5.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The perp operator ⟂ can be entered in most editors (and the Julia REPL) by typing \\perp<tab>.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"An alternative approach that does not require the ⟂ symbol uses the complements function as follows:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, complements(2x - 1, x))\n[2 x - 1, x] ∈ MathOptInterface.Complements(1)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"In both cases, the mapping F(x) is supplied as the first argument, and the matching variable x is supplied as the second.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Vector-valued complementarity constraints are also supported:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, -2 <= y[1:2] <= 2)\n2-element Array{VariableRef,1}:\n y[1]\n y[2]\n\njulia> M = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> q = [5, 6]\n2-element Array{Int64,1}:\n 5\n 6\n\njulia> @constraint(model, M * y + q ⟂ y)\n[y[1] + 2 y[2] + 5, 3 y[1] + 4 y[2] + 6, y[1], y[2]] ∈ MathOptInterface.Complements(2)","category":"page"},{"location":"constraints/#Special-Ordered-Sets-(SOS1-and-SOS2)","page":"Constraints","title":"Special Ordered Sets (SOS1 and SOS2)","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"A Special Ordered Set (SOS) is an ordered set of variables with the following characteristics.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"If a vector of variables x is in a Special Ordered Set of Type I (SOS1), then at most one element of x can take a non-zero value, and all other elements must be zero.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Although not required for feasibility, solvers can benefit from an ordering of the variables (e.g., the variables represent different factories to build, at most one factory can be built, and the factories can be ordered according to cost). To induce an ordering, weights can be provided; as such, they should be unique values. The kth element in the ordered set corresponds to the kth weight in weights when the weights are sorted.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"A SOS1 constraint is equivalent to:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"x[i] >= 0 for some i\nx[j] == 0 for all j != i","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"If a vector of variables x is in a Special Ordered Set of Type II (SOS2), then at most two elements can be non-zero, and if two elements are non-zero, they must be adjacent.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Because of the adjacency requirement, you should supply a weight vector (with unique elements) to induce an ordering of the variables. The kth element in the ordered set corresponds to the kth weight in weights when the weights are sorted.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"A SOS2 constraint is equivalent to:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"x[i] >= 0, x[i+1] >= 0  for some i\nx[j] == 0 for all j != i, j != i+1","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Create an SOS constraint as follows:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in SOS2([3,5,2]))\n[x[1], x[2], x[3]] ∈ MathOptInterface.SOS2{Float64}([3.0, 5.0, 2.0])","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"In the case above, x[3] is the first variable and x[2] the last variable under the induced ordering. When no ordering vector is provided, JuMP induces an ordering from 1:length(x).","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in SOS2())\n[x[1], x[2], x[3]] ∈ MathOptInterface.SOS2{Float64}([1.0, 2.0, 3.0])","category":"page"},{"location":"reference/objectives/#Objective-API","page":"Objective API","title":"Objective API","text":"","category":"section"},{"location":"reference/objectives/","page":"Objective API","title":"Objective API","text":"More information can be found in the Objectives section of the manual.","category":"page"},{"location":"reference/objectives/","page":"Objective API","title":"Objective API","text":"@objective\n\nobjective_function\nobjective_function_type\nobjective_sense\n\nset_objective\nset_objective_coefficient\nset_objective_function\nset_objective_sense\n\nobjective_function_string\nshow_objective_function_summary","category":"page"},{"location":"reference/objectives/#JuMP.@objective","page":"Objective API","title":"JuMP.@objective","text":"@objective(model::Model, sense, func)\n\nSet the objective sense to sense and objective function to func. The objective sense can be either Min, Max, MathOptInterface.MIN_SENSE, MathOptInterface.MAX_SENSE or MathOptInterface.FEASIBILITY_SENSE; see MathOptInterface.ObjectiveSense. In order to set the sense programatically, i.e., when sense is a Julia variable whose value is the sense, one of the three MathOptInterface.ObjectiveSense values should be used. The function func can be a single JuMP variable, an affine expression of JuMP variables or a quadratic expression of JuMP variables.\n\nExamples\n\nTo minimize the value of the variable x, do as follows:\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @objective(model, Min, x)\nx\n\nTo maximize the value of the affine expression 2x - 1, do as follows:\n\njulia> @objective(model, Max, 2x - 1)\n2 x - 1\n\nTo set a quadratic objective and set the objective sense programatically, do as follows:\n\njulia> sense = MOI.MIN_SENSE\nMIN_SENSE::OptimizationSense = 0\n\njulia> @objective(model, sense, x^2 - 2x + 1)\nx² - 2 x + 1\n\n\n\n\n\n","category":"macro"},{"location":"reference/objectives/#JuMP.objective_function","page":"Objective API","title":"JuMP.objective_function","text":"objective_function(model::Model,\n               T::Type{<:AbstractJuMPScalar}=objective_function_type(model))\n\nReturn an object of type T representing the objective function. Error if the objective is not convertible to type T.\n\nExamples\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @objective(model, Min, 2x + 1)\n2 x + 1\n\njulia> objective_function(model, AffExpr)\n2 x + 1\n\njulia> objective_function(model, QuadExpr)\n2 x + 1\n\njulia> typeof(objective_function(model, QuadExpr))\nGenericQuadExpr{Float64,VariableRef}\n\nWe see with the last two commands that even if the objective function is affine, as it is convertible to a quadratic function, it can be queried as a quadratic function and the result is quadratic.\n\nHowever, it is not convertible to a variable.\n\njulia> objective_function(model, VariableRef)\nERROR: InexactError: convert(MathOptInterface.SingleVariable, MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 1.0))\n[...]\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.objective_function_type","page":"Objective API","title":"JuMP.objective_function_type","text":"objective_function_type(model::Model)::AbstractJuMPScalar\n\nReturn the type of the objective function.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.objective_sense","page":"Objective API","title":"JuMP.objective_sense","text":"objective_sense(model::Model)::MathOptInterface.OptimizationSense\n\nReturn the objective sense.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.set_objective","page":"Objective API","title":"JuMP.set_objective","text":"set_objective(model::AbstractModel, sense::MOI.OptimizationSense, func)\n\nThe functional equivalent of the @objective macro.\n\nSets the objective sense and objective function simultaneously, and is equivalent to:\n\nset_objective_sense(model, sense)\nset_objective_function(model, func)\n\nExamples\n\nmodel = Model()\n@variable(model, x)\nset_objective(model, MOI.MIN_SENSE, x)\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.set_objective_coefficient","page":"Objective API","title":"JuMP.set_objective_coefficient","text":"set_objective_coefficient(model::Model, variable::VariableRef, coefficient::Real)\n\nSet the linear objective coefficient associated with Variable to coefficient.\n\nNote: this function will throw an error if a nonlinear objective is set.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.set_objective_function","page":"Objective API","title":"JuMP.set_objective_function","text":"set_objective_function(\n    model::Model,\n    func::Union{AbstractJuMPScalar, MathOptInterface.AbstractScalarFunction})\n\nSets the objective function of the model to the given function. See set_objective_sense to set the objective sense. These are low-level functions; the recommended way to set the objective is with the @objective macro.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.set_objective_sense","page":"Objective API","title":"JuMP.set_objective_sense","text":"set_objective_sense(model::Model, sense::MathOptInterface.OptimizationSense)\n\nSets the objective sense of the model to the given sense. See set_objective_function to set the objective function. These are low-level functions; the recommended way to set the objective is with the @objective macro.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.objective_function_string","page":"Objective API","title":"JuMP.objective_function_string","text":"objective_function_string(print_mode, model::AbstractModel)::String\n\nReturn a String describing the objective function of the model.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.show_objective_function_summary","page":"Objective API","title":"JuMP.show_objective_function_summary","text":"show_objective_function_summary(io::IO, model::AbstractModel)\n\nWrite to io a summary of the objective function type.\n\n\n\n\n\n","category":"function"},{"location":"examples/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/min_ellipse.jl\"","category":"page"},{"location":"examples/min_ellipse/#Minimum-ellipses","page":"Minimum ellipses","title":"Minimum ellipses","text":"","category":"section"},{"location":"examples/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"This example is from the Boyd & Vandenberghe book \"Convex Optimization\". Given a set of ellipses centered on the origin","category":"page"},{"location":"examples/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"E(A) = { u | u^T inv(A) u <= 1 }","category":"page"},{"location":"examples/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"find a \"minimal\" ellipse that contains the provided ellipses.","category":"page"},{"location":"examples/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"We can formulate this as an SDP:","category":"page"},{"location":"examples/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"minimize    trace(WX)\nsubject to  X >= A_i,    i = 1,...,m\n            X PSD","category":"page"},{"location":"examples/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"where W is a PD matrix of weights to choose between different solutions.","category":"page"},{"location":"examples/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"using JuMP\nimport LinearAlgebra\nimport SCS\nimport Test\n\nfunction example_min_ellipse()\n    # We will use three ellipses: two \"simple\" ones, and a random one.\n    As = [\n        [2.0  0.0; 0.0  1.0],\n        [1.0  0.0; 0.0  3.0],\n        [2.86715 1.60645; 1.60645 1.12639]\n    ]\n    # We change the weights to see different solutions, if they exist\n    weights = [1.0 0.0; 0.0 1.0]\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, X[i=1:2, j=1:2], PSD)\n    @objective(model, Min, LinearAlgebra.tr(weights * X))\n    for As_i in As\n        @SDconstraint(model, X >= As_i)\n    end\n    optimize!(model)\n    Test.@test termination_status(model) == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ≈ 6.46233 atol = 1e-5\n    Test.@test value.(X) ≈ [3.1651 0.8022; 0.8022 3.2972] atol = 1e-4\n    return\nend\n\nexample_min_ellipse()","category":"page"},{"location":"examples/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"View this file on Github.","category":"page"},{"location":"examples/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"","category":"page"},{"location":"examples/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/cutting_stock_column_generation.jl\"","category":"page"},{"location":"examples/cutting_stock_column_generation/#Cutting-stock","page":"Cutting stock","title":"Cutting stock","text":"","category":"section"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"This example solves the cutting stock problem (sometimes also called the cutting rod problem) using a column-generation technique. It is based on https://doi.org/10.5281/zenodo.3329388.","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"Intuitively, this problem is about cutting large rolls of paper into smaller pieces. There is an exact demand of pieces to meet, and all rolls have the same size. The goal is to meet the demand while maximising the profits (each paper roll has a fixed cost, each sold piece allows earning some money), which is roughly equivalent to using the smallest amount of rolls to cut (or, equivalently, to minimise the amount of paper waste).","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"This function takes five parameters:","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"maxwidth: the maximum width of a roll (or length of a rod)\nwidths: an array of the requested widths\nrollcost: the cost of a complete roll\ndemand: the demand, in number of pieces, for each width\nprices: the selling price for each width","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"Mathematically, this problem might be formulated with two variables:","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"x[i, j] ∈ ℕ: the number of times the width i is cut out of the roll j\ny[j] ∈ 𝔹: whether the roll j is used","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"Several constraints are needed:","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"the demand must be satisfied, for each width i: ∑j x[i, j] = demand[i]\nthe roll size cannot be exceed, for each roll j that is used: ∑i x[i, j] width[i] ≤ maxwidth y[j]","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"If you want to implement this naïve model, you will need an upper bound on the number of rolls to use: the simplest one is to consider that each required width is cut from its own roll, i.e. j varies from 1 to ∑i demand[i].","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"This example prefers a more advanced technique to solve this problem: column generation.","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"It considers a different set of variables: patterns of width to cut a roll. The decisions then become the number of times each pattern is used (i.e. the number of rolls that are cut following this pattern).","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"The intelligence comes from the way these patterns are chosen: not all of them are considered, but only the \"interesting\" ones, within the master problem.","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"A \"pricing\" problem is used to decide whether a new pattern should be generated or not (it is implemented in the function solve_pricing). \"Interesting\" means, for a pattern, that the optimal solution may use this cutting pattern.","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"In more detail, the solving process is the following. First, a series of dumb patterns are generated (just one width per roll, repeated until the roll is completely cut). Then, the master problem is solved with these first patterns and its dual solution is passed on to the pricing problem. The latter decides if there is a new pattern to include in the formulation or not; if so, it returns it to the master problem. The master is solved again, the new dual variables are given to the pricing problem, until there is no more pattern to generate from the pricing problem: all \"interesting\" patterns have been generated, and the master can take its optimal decision.","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"In the implementation, the variables deciding how many times a pattern is chosen are called θ.","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"For more information on column-generation techniques applied on the cutting stock problem, you can see:","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"Integer programming column generation strategies for the cutting stock problem and its variants\nTackling the cutting stock problem","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"This example uses the following packages:","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"using JuMP\nimport GLPK\nimport SparseArrays","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"The function solve_pricing implements the pricing problem for the function example_cutting_stock.","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"It takes, as input, the dual solution from the master problem and the cutting stock instance.","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"It outputs either a new cutting pattern, or nothing if no pattern could improve the current cost.","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"function solve_pricing(\n    dual_demand_satisfaction, maxwidth, widths, rollcost, demand, prices\n)\n    reduced_costs = dual_demand_satisfaction + prices\n    n = length(reduced_costs)\n    # The actual pricing model.\n    submodel = Model(GLPK.Optimizer)\n    set_silent(submodel)\n    @variable(submodel, xs[1:n] >= 0, Int)\n    @constraint(submodel, sum(xs .* widths) <= maxwidth)\n    @objective(submodel, Max, sum(xs .* reduced_costs))\n    optimize!(submodel)\n    new_pattern = round.(Int, value.(xs))\n    net_cost = rollcost - sum(new_pattern .* (dual_demand_satisfaction .+ prices))\n    # If the net cost of this new pattern is nonnegative, no more patterns to add.\n    return net_cost >= 0 ? nothing : new_pattern\nend\n\nfunction example_cutting_stock(; max_gen_cols::Int = 5_000)\n    maxwidth = 100.0\n    rollcost = 500.0\n    prices = [\n        167.0, 197.0, 281.0, 212.0, 225.0, 111.0, 93.0, 129.0, 108.0, 106.0,\n        55.0, 85.0, 66.0, 44.0, 47.0, 15.0, 24.0, 13.0, 16.0, 14.0,\n    ]\n    widths = [\n        75.0, 75.0, 75.0, 75.0, 75.0, 53.8, 53.0, 51.0, 50.2, 32.2,\n        30.8, 29.8, 20.1, 16.2, 14.5, 11.0, 8.6, 8.2, 6.6, 5.1,\n    ]\n    demand = [\n        38, 44, 30, 41, 36, 33, 36, 41, 35, 37,\n        44, 49, 37, 36, 42, 33, 47, 35, 49, 42,\n    ]\n    nwidths = length(prices)\n    n = length(widths)\n    ncols = length(widths)\n    # Initial set of patterns (stored in a sparse matrix: a pattern won't\n    # include many different cuts).\n    patterns = SparseArrays.spzeros(UInt16, n, ncols)\n    for i = 1:n\n        patterns[i, i] = min(\n            floor(Int, maxwidth / widths[i]), round(Int, demand[i])\n        )\n    end\n    # Write the master problem with this \"reduced\" set of patterns.\n    # Not yet integer variables: otherwise, the dual values may make no sense\n    # (actually, GLPK will yell at you if you're trying to get duals for\n    # integer problems).\n    m = Model(GLPK.Optimizer)\n    set_silent(m)\n    @variable(m, θ[1:ncols] >= 0)\n    @objective(\n        m,\n        Min,\n        sum(\n            θ[p] * (rollcost - sum(patterns[j, p] * prices[j] for j = 1:n))\n            for p = 1:ncols\n        )\n    )\n    @constraint(\n        m,\n        demand_satisfaction[j=1:n],\n        sum(patterns[j, p] * θ[p] for p = 1:ncols) >= demand[j]\n    )\n    # First solve of the master problem.\n    optimize!(m)\n    if termination_status(m) != MOI.OPTIMAL\n        warn(\"Master not optimal ($ncols patterns so far)\")\n    end\n    # Then, generate new patterns, based on the dual information.\n    while ncols - n <= max_gen_cols ## Generate at most max_gen_cols columns.\n        if ! has_duals(m)\n            break\n        end\n        new_pattern = solve_pricing(\n            dual.(demand_satisfaction),\n            maxwidth,\n            widths,\n            rollcost,\n            demand,\n            prices,\n        )\n        # No new pattern to add to the formulation: done!\n        if new_pattern === nothing\n            break\n        end\n        # Otherwise, add the new pattern to the master problem, recompute the\n        # duals, and go on waltzing one more time with the pricing problem.\n        ncols += 1\n        patterns = hcat(patterns, new_pattern)\n        # One new variable.\n        new_var = @variable(m, [ncols], base_name = \"θ\", lower_bound = 0)\n        push!(θ, new_var[ncols])\n        # Update the objective function.\n        set_objective_coefficient(\n            m,\n            θ[ncols],\n            rollcost - sum(patterns[j, ncols] * prices[j] for j = 1:n)\n        )\n        # Update the constraint number j if the new pattern impacts this production.\n        for j = 1:n\n            if new_pattern[j] > 0\n                set_normalized_coefficient(\n                    demand_satisfaction[j], new_var[ncols], new_pattern[j]\n                )\n            end\n        end\n        # Solve the new master problem to update the dual variables.\n        optimize!(m)\n        if termination_status(m) != MOI.OPTIMAL\n            @warn(\"Master not optimal ($ncols patterns so far)\")\n        end\n    end\n    # Finally, impose the master variables to be integer and resolve.\n    # To be exact, at each node in the branch-and-bound tree, we would need to\n    # restart the column generation process (just in case a new column would be\n    # interesting to add). This way, we only get an upper bound (a feasible\n    # solution).\n    set_integer.(θ)\n    optimize!(m)\n    if termination_status(m) != MOI.OPTIMAL\n        @warn(\"Final master not optimal ($ncols patterns)\")\n        return\n    end\n    println(\"Final solution:\")\n    for i = 1:length(θ)\n        if value(θ[i]) > 0.5\n            println(\"$(round(Int, value(θ[i]))) units of pattern $(i)\")\n        end\n    end\n    return\nend\n\nexample_cutting_stock()","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"View this file on Github.","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"","category":"page"},{"location":"examples/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/callbacks/","page":"Callbacks","title":"Callbacks","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/callbacks.jl\"","category":"page"},{"location":"examples/callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"examples/callbacks/","page":"Callbacks","title":"Callbacks","text":"This example uses the following packages:","category":"page"},{"location":"examples/callbacks/","page":"Callbacks","title":"Callbacks","text":"using JuMP\nimport GLPK\nimport Random","category":"page"},{"location":"examples/callbacks/#Lazy-constraints","page":"Callbacks","title":"Lazy constraints","text":"","category":"section"},{"location":"examples/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using a lazy constraint callback.","category":"page"},{"location":"examples/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_lazy_constraint()\n    model = Model(GLPK.Optimizer)\n    @variable(model, 0 <= x <= 2.5, Int)\n    @variable(model, 0 <= y <= 2.5, Int)\n    @objective(model, Max, y)\n    lazy_called = false\n    function my_callback_function(cb_data)\n        lazy_called = true\n        x_val = callback_value(cb_data, x)\n        y_val = callback_value(cb_data, y)\n        println(\"Called from (x, y) = ($x_val, $y_val)\")\n        status = callback_node_status(cb_data, model)\n        if status == MOI.CALLBACK_NODE_STATUS_FRACTIONAL\n            println(\" - Solution is integer infeasible!\")\n        elseif status == MOI.CALLBACK_NODE_STATUS_INTEGER\n            println(\" - Solution is integer feasible!\")\n        else\n            @assert status == MOI.CALLBACK_NODE_STATUS_UNKNOWN\n            println(\" - I don't know if the solution is integer feasible :(\")\n        end\n        if y_val - x_val > 1 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        elseif y_val + x_val > 3 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        end\n    end\n    MOI.set(model, MOI.LazyConstraintCallback(), my_callback_function)\n    optimize!(model)\n    println(\"Optimal solution (x, y) = ($(value(x)), $(value(y)))\")\n    return\nend\n\nexample_lazy_constraint()","category":"page"},{"location":"examples/callbacks/#User-cut","page":"Callbacks","title":"User-cut","text":"","category":"section"},{"location":"examples/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using a user-cut callback.","category":"page"},{"location":"examples/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_user_cut_constraint()\n    Random.seed!(1)\n    N = 30\n    item_weights, item_values = rand(N), rand(N)\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:N], Bin)\n    @constraint(model, sum(item_weights[i] * x[i] for i = 1:N) <= 10)\n    @objective(model, Max, sum(item_values[i] * x[i] for i = 1:N))\n    callback_called = false\n    function my_callback_function(cb_data)\n        callback_called = true\n        x_vals = callback_value.(Ref(cb_data), x)\n        accumulated = sum(item_weights[i] for i = 1:N if x_vals[i] > 1e-4)\n        println(\"Called with accumulated = $(accumulated)\")\n        n_terms = sum(1 for i = 1:N if x_vals[i] > 1e-4)\n        if accumulated > 10\n            con = @build_constraint(\n                sum(x[i] for i = 1:N if x_vals[i] > 0.5) <= n_terms - 1\n            )\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.UserCut(cb_data), con)\n        end\n    end\n    MOI.set(model, MOI.UserCutCallback(), my_callback_function)\n    optimize!(model)\n    @show callback_called\n    return\nend\n\nexample_user_cut_constraint()","category":"page"},{"location":"examples/callbacks/#HeuristicCallback","page":"Callbacks","title":"HeuristicCallback","text":"","category":"section"},{"location":"examples/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using a heuristic solution callback.","category":"page"},{"location":"examples/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_heuristic_solution()\n    Random.seed!(1)\n    N = 30\n    item_weights, item_values = rand(N), rand(N)\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:N], Bin)\n    @constraint(model, sum(item_weights[i] * x[i] for i = 1:N) <= 10)\n    @objective(model, Max, sum(item_values[i] * x[i] for i = 1:N))\n    callback_called = false\n    function my_callback_function(cb_data)\n        callback_called = true\n        x_vals = callback_value.(Ref(cb_data), x)\n        ret = MOI.submit(\n            model, MOI.HeuristicSolution(cb_data), x, floor.(x_vals)\n        )\n        println(\"Heuristic solution status = $(ret)\")\n    end\n    MOI.set(model, MOI.HeuristicCallback(), my_callback_function)\n    optimize!(model)\n    return\nend\n\nexample_heuristic_solution()","category":"page"},{"location":"examples/callbacks/#GLPK-solver-dependent-callback","page":"Callbacks","title":"GLPK solver-dependent callback","text":"","category":"section"},{"location":"examples/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using GLPK's solver-dependent callback.","category":"page"},{"location":"examples/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_solver_dependent_callback()\n    model = Model(GLPK.Optimizer)\n    @variable(model, 0 <= x <= 2.5, Int)\n    @variable(model, 0 <= y <= 2.5, Int)\n    @objective(model, Max, y)\n    lazy_called = false\n    function my_callback_function(cb_data)\n        lazy_called = true\n        reason = GLPK.glp_ios_reason(cb_data.tree)\n        println(\"Called from reason = $(reason)\")\n        if reason != GLPK.GLP_IROWGEN\n            return\n        end\n        x_val = callback_value(cb_data, x)\n        y_val = callback_value(cb_data, y)\n        if y_val - x_val > 1 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        elseif y_val + x_val > 3 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        end\n    end\n    MOI.set(model, GLPK.CallbackFunction(), my_callback_function)\n    optimize!(model)\n    return\nend\n\nexample_solver_dependent_callback()","category":"page"},{"location":"examples/callbacks/","page":"Callbacks","title":"Callbacks","text":"View this file on Github.","category":"page"},{"location":"examples/callbacks/","page":"Callbacks","title":"Callbacks","text":"","category":"page"},{"location":"examples/callbacks/","page":"Callbacks","title":"Callbacks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/rosenbrock.jl\"","category":"page"},{"location":"examples/rosenbrock/#The-Rosenbrock-function","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"","category":"section"},{"location":"examples/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"A nonlinear example of the classical Rosenbrock function.","category":"page"},{"location":"examples/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"using JuMP\nimport Ipopt\nimport Test\n\nfunction example_rosenbrock()\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, x)\n    @variable(model, y)\n    @NLobjective(model, Min, (1 - x)^2 + 100 * (y - x^2)^2)\n    optimize!(model)\n\n    Test.@test termination_status(model) == MOI.LOCALLY_SOLVED\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ≈ 0.0 atol = 1e-10\n    Test.@test value(x) ≈ 1.0\n    Test.@test value(y) ≈ 1.0\n    return\nend\n\nexample_rosenbrock()","category":"page"},{"location":"examples/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"View this file on Github.","category":"page"},{"location":"examples/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"","category":"page"},{"location":"examples/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/max_cut_sdp.jl\"","category":"page"},{"location":"examples/max_cut_sdp/#SDP-relaxations:-max-cut","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"","category":"section"},{"location":"examples/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"Solves a semidefinite programming relaxation of the MAXCUT graph problem:","category":"page"},{"location":"examples/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"max   0.25 * L•X\ns.t.  diag(X) == e\n      X ≽ 0","category":"page"},{"location":"examples/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"Where L is the weighted graph Laplacian. Uses this relaxation to generate a solution to the original MAXCUT problem using the method from the paper:","category":"page"},{"location":"examples/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"Goemans, M. X., & Williamson, D. P. (1995). Improved approximation algorithms for maximum cut and satisfiability problems using semidefinite programming. Journal of the ACM (JACM), 42(6), 1115-1145.","category":"page"},{"location":"examples/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"using JuMP\nimport LinearAlgebra\nimport Random\nimport SCS\nimport Test\n\nfunction solve_max_cut_sdp(num_vertex, weights)\n    # Calculate the (weighted) Lapacian of the graph: L = D - W.\n    laplacian = LinearAlgebra.diagm(0 => weights * ones(num_vertex)) - weights\n    # Solve the SDP relaxation\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, X[1:num_vertex, 1:num_vertex], PSD)\n    @objective(model, Max, 1 / 4 * LinearAlgebra.dot(laplacian, X))\n    @constraint(model, LinearAlgebra.diag(X) .== 1)\n    optimize!(model)\n    # Compute the Cholesky factorization of X, i.e., X = V^T V.\n    opt_X = LinearAlgebra.Hermitian(value.(X), :U)  # Tell Julia its PSD.\n    factorization = LinearAlgebra.cholesky(opt_X, Val(true); check = false)\n    V = (factorization.P * factorization.L)'\n    # Normalize columns.\n    for i in 1:num_vertex\n        V[:, i] ./= LinearAlgebra.norm(V[:, i])\n    end\n    # Generate random vector on unit sphere.\n    Random.seed!(num_vertex)\n    r = rand(num_vertex)\n    r /= LinearAlgebra.norm(r)\n    # Iterate over vertices, and assign each vertex to a side of cut.\n    cut = ones(num_vertex)\n    for i in 1:num_vertex\n        if LinearAlgebra.dot(r, V[:, i]) <= 0\n            cut[i] = -1\n        end\n    end\n\n    return cut, 0.25 * sum(laplacian .* (cut * cut'))\nend\n\nfunction example_max_cut_sdp()\n    #   [1] --- 5 --- [2]\n    #\n    # Solution:\n    #  (S, S′)  = ({1}, {2})\n    cut, cutval = solve_max_cut_sdp(2, [0.0 5.0; 5.0 0.0])\n    Test.@test cut[1] != cut[2]\n    #   [1] --- 5 --- [2]\n    #    |  \\          |\n    #    |    \\        |\n    #    7      6      1\n    #    |        \\    |\n    #    |          \\  |\n    #   [3] --- 1 --- [4]\n    #\n    # Solution:\n    #  (S, S′)  = ({1}, {2, 3, 4})\n    W = [0.0 5.0 7.0 6.0;\n         5.0 0.0 0.0 1.0;\n         7.0 0.0 0.0 1.0;\n         6.0 1.0 1.0 0.0]\n    cut, cutval = solve_max_cut_sdp(4, W)\n    Test.@test cut[1] != cut[2]\n    Test.@test cut[2] == cut[3] == cut[4]\n    #   [1] --- 1 --- [2]\n    #    |             |\n    #    |             |\n    #    5             9\n    #    |             |\n    #    |             |\n    #   [3] --- 2 --- [4]\n    #\n    # Solution:\n    #  (S, S′)  = ({1, 4}, {2, 3})\n    W = [0.0 1.0 5.0 0.0;\n         1.0 0.0 0.0 9.0;\n         5.0 0.0 0.0 2.0;\n         0.0 9.0 2.0 0.0]\n    cut, cutval = solve_max_cut_sdp(4, W)\n    Test.@test cut[1] == cut[4]\n    Test.@test cut[2] == cut[3]\n    Test.@test cut[1] != cut[2]\n    return\nend\n\nexample_max_cut_sdp()","category":"page"},{"location":"examples/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"View this file on Github.","category":"page"},{"location":"examples/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"","category":"page"},{"location":"examples/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/mle.jl\"","category":"page"},{"location":"examples/mle/#Maximum-likelihood-estimation","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"","category":"section"},{"location":"examples/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"Use nonlinear optimization to compute the maximum likelihood estimate (MLE) of the parameters of a normal distribution, a.k.a., the sample mean and variance.","category":"page"},{"location":"examples/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"using JuMP\nimport Ipopt\nimport Random\nimport Statistics\nimport Test\n\nfunction example_mle(; verbose = true)\n    n = 1_000\n    Random.seed!(1234)\n    data = randn(n)\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, μ, start = 0.0)\n    @variable(model, σ >= 0.0, start = 1.0)\n    @NLobjective(\n        model,\n        Max,\n        n / 2 * log(1 / (2 * π * σ^2)) - sum((data[i] - μ)^2 for i = 1:n) / (2 * σ^2)\n    )\n    optimize!(model)\n    if verbose\n        println(\"μ             = \", value(μ))\n        println(\"mean(data)    = \", Statistics.mean(data))\n        println(\"σ^2           = \", value(σ)^2)\n        println(\"var(data)     = \", Statistics.var(data))\n        println(\"MLE objective = \", objective_value(model))\n    end\n    Test.@test value(μ) ≈ Statistics.mean(data) atol = 1e-3\n    Test.@test value(σ)^2 ≈ Statistics.var(data) atol = 1e-2\n    # You can even do constrained MLE!\n    @NLconstraint(model, μ == σ^2)\n    optimize!(model)\n    Test.@test value(μ) ≈ value(σ)^2\n    if verbose\n        println()\n        println(\"With constraint μ == σ^2:\")\n        println(\"μ                         = \", value(μ))\n        println(\"σ^2                       = \", value(σ)^2)\n        println(\"Constrained MLE objective = \", objective_value(model))\n    end\n    return\nend\n\nexample_mle()","category":"page"},{"location":"examples/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"View this file on Github.","category":"page"},{"location":"examples/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"","category":"page"},{"location":"examples/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/variables/#Variable-API","page":"Variable API","title":"Variable API","text":"","category":"section"},{"location":"reference/variables/","page":"Variable API","title":"Variable API","text":"More information can be found in the Variables section of the manual.","category":"page"},{"location":"reference/variables/","page":"Variable API","title":"Variable API","text":"@variable\n@variables\n\nname(::JuMP.VariableRef)\nset_name(::JuMP.VariableRef, ::String)\nvariable_by_name\n\nset_start_value\nstart_value\n\nhas_lower_bound\nlower_bound\nset_lower_bound\ndelete_lower_bound\nLowerBoundRef\n\nhas_upper_bound\nupper_bound\nset_upper_bound\ndelete_upper_bound\nUpperBoundRef\n\nis_fixed\nfix_value\nfix\nunfix\nFixRef\n\nis_integer\nset_integer\nunset_integer\nIntegerRef\n\nis_binary\nset_binary\nunset_binary\nBinaryRef\n\nrelax_integrality\n\nall_variables\nowner_model\nnum_variables\nVariableRef\nindex(::VariableRef)\noptimizer_index(::VariableRef)\n\nadd_variable\ncheck_belongs_to_model\nbuild_variable\nparse_one_operator_variable\n\nAbstractVariable\nAbstractVariableRef\nVariableNotOwned\nVariableConstrainedOnCreation\nVariablesConstrainedOnCreation","category":"page"},{"location":"reference/variables/#JuMP.@variable","page":"Variable API","title":"JuMP.@variable","text":"@variable(model, kw_args...)\n\nAdd an anonymous variable to the model model described by the keyword arguments kw_args and returns the variable.\n\n@variable(model, expr, args..., kw_args...)\n\nAdd a variable to the model model described by the expression expr, the positional arguments args and the keyword arguments kw_args. The expression expr can either be (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥)\n\nof the form varexpr creating variables described by varexpr;\nof the form varexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb);\nof the form varexpr == value creating variables described by varexpr with fixed values given by value; or\nof the form lb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub.\nof the form varexpr in set creating variables described by varexpr constrained to belong to set, see Variables constrained on creation.\n\nThe expression varexpr can either be\n\nof the form varname creating a scalar real variable of name varname;\nof the form varname[...] or [...] creating a container of variables (see Containers in macros).\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\nSymmetric: Only available when creating a square matrix of variables, i.e. when varexpr is of the form varname[1:n,1:n] or varname[i=1:n,j=1:n]. It creates a symmetric matrix of variable, that is, it only creates a new variable for varname[i,j] with i ≤ j and sets varname[j,i] to the same variable as varname[i,j]. It is equivalent to using varexpr in SymMatrixSpace() as expr.\nPSD: The square matrix of variable is both Symmetric and constrained to be positive semidefinite. It is equivalent to using varexpr in PSDCone() as expr.\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes.\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\nvariable_type: See the \"Note for extending the variable macro\" section below.\nset: Equivalent to using varexpr in value as expr where value is the value of the keyword argument.\ncontainer: Specify the container type, see Containers in macros.\n\nExamples\n\nThe following are equivalent ways of creating a variable x of name x with lower bound 0:\n\n# Specify everything in `expr`\n@variable(model, x >= 0)\n# Specify the lower bound using a keyword argument\n@variable(model, x, lower_bound=0)\n# Specify everything in `kw_args`\nx = @variable(model, base_name=\"x\", lower_bound=0)\n\nThe following are equivalent ways of creating a DenseAxisArray of index set [:a, :b] and with respective upper bounds 2 and 3 and names x[a] and x[b]. The upper bound can either be specified in expr:\n\nub = Dict(:a => 2, :b => 3)\n@variable(model, x[i=keys(ub)] <= ub[i])\n\n# output\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{VariableRef,1}:\n x[a]\n x[b]\n\nor it can be specified with the upper_bound keyword argument:\n\n@variable(model, y[i=keys(ub)], upper_bound=ub[i])\n\n# output\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{VariableRef,1}:\n y[a]\n y[b]\n\nNote for extending the variable macro\n\nThe single scalar variable or each scalar variable of the container are created using add_variable(model, build_variable(_error, info, extra_args...; extra_kw_args...)) where\n\nmodel is the model passed to the @variable macro;\n_error is an error function with a single String argument showing the @variable call in addition to the error message given as argument;\ninfo is the VariableInfo struct containing the information gathered in expr, the recognized keyword arguments (except base_name and variable_type) and the recognized positional arguments (except Symmetric and PSD);\nextra_args are the unrecognized positional arguments of args plus the value of the variable_type keyword argument if present. The variable_type keyword argument allows the user to pass a position argument to build_variable without the need to give a positional argument to @variable. In particular, this allows the user to give a positional argument to the build_variable call when using the anonymous single variable syntax @variable(model, kw_args...); and\nextra_kw_args are the unrecognized keyword argument of kw_args.\n\nExamples\n\nThe following creates a variable x of name x with lower_bound 0 as with the first example above but does it without using the @variable macro\n\ninfo = VariableInfo(true, 0, false, NaN, false, NaN, false, NaN, false, false)\nJuMP.add_variable(model, JuMP.build_variable(error, info), \"x\")\n\nThe following creates a DenseAxisArray of index set [:a, :b] and with respective upper bounds 2 and 3 and names x[a] and x[b] as with the second example above but does it without using the @variable macro\n\n# Without the `@variable` macro\nx = JuMP.Containers.container(i -> begin\n        info = VariableInfo(false, NaN, true, ub[i], false, NaN, false, NaN, false, false)\n        x[i] = JuMP.add_variable(model, JuMP.build_variable(error, info), \"x[$i]\")\n    end, JuMP.Containers.vectorized_product(keys(ub)))\n\n# output\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{VariableRef,1}:\n x[a]\n x[b]\n\nThe following are equivalent ways of creating a Matrix of size N x N with variables custom variables created with a JuMP extension using the Poly(X) positional argument to specify its variables:\n\n# Using the `@variable` macro\n@variable(model, x[1:N,1:N], Symmetric, Poly(X))\n# Without the `@variable` macro\nx = Matrix{JuMP.variable_type(model, Poly(X))}(N, N)\ninfo = VariableInfo(false, NaN, false, NaN, false, NaN, false, NaN, false, false)\nfor i in 1:N, j in i:N\n    x[i,j] = x[j,i] = JuMP.add_variable(model, build_variable(error, info, Poly(X)), \"x[$i,$j]\")\nend\n\n\n\n\n\n","category":"macro"},{"location":"reference/variables/#JuMP.@variables","page":"Variable API","title":"JuMP.@variables","text":"@variables(model, args...)\n\nAdds multiple variables to model at once, in the same fashion as the @variable macro.\n\nThe model must be the first argument, and multiple variables can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@variables(model, begin\n    x\n    y[i = 1:2] >= 0, (start = i)\n    z, Bin, (start = 0, base_name = \"Z\")\nend)\n\nnote: Note\nKeyword arguments must be contained within parentheses (refer to the example above).\n\n\n\n\n\n","category":"macro"},{"location":"reference/variables/#JuMP.name-Tuple{VariableRef}","page":"Variable API","title":"JuMP.name","text":"name(v::VariableRef)::String\n\nGet a variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"reference/variables/#JuMP.set_name-Tuple{VariableRef,String}","page":"Variable API","title":"JuMP.set_name","text":"set_name(v::VariableRef, s::AbstractString)\n\nSet a variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"reference/variables/#JuMP.variable_by_name","page":"Variable API","title":"JuMP.variable_by_name","text":"variable_by_name(model::AbstractModel,\n                 name::String)::Union{AbstractVariableRef, Nothing}\n\nReturns the reference of the variable with name attribute name or Nothing if no variable has this name attribute. Throws an error if several variables have name as their name attribute.\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> variable_by_name(model, \"x\")\nx\n\njulia> @variable(model, base_name=\"x\")\nx\n\njulia> variable_by_name(model, \"x\")\nERROR: Multiple variables have the name x.\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] get(::MOIU.Model{Float64}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/model.jl:222\n [3] get at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/universalfallback.jl:201 [inlined]\n [4] get(::MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.AbstractOptimizer,MathOptInterface.Utilities.UniversalFallback{MOIU.Model{Float64}}}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/cachingoptimizer.jl:490\n [5] variable_by_name(::Model, ::String) at /home/blegat/.julia/dev/JuMP/src/variables.jl:268\n [6] top-level scope at none:0\n\njulia> var = @variable(model, base_name=\"y\")\ny\n\njulia> variable_by_name(model, \"y\")\ny\n\njulia> set_name(var, \"z\")\n\njulia> variable_by_name(model, \"y\")\n\njulia> variable_by_name(model, \"z\")\nz\n\njulia> @variable(model, u[1:2])\n2-element Array{VariableRef,1}:\n u[1]\n u[2]\n\njulia> variable_by_name(model, \"u[2]\")\nu[2]\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.set_start_value","page":"Variable API","title":"JuMP.set_start_value","text":"set_start_value(variable::VariableRef, value::Number)\n\nSet the start value (MOI attribute VariablePrimalStart) of the variable v to value. See also start_value.\n\nNote: VariablePrimalStarts are sometimes called \"MIP-starts\" or \"warmstarts\".\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.start_value","page":"Variable API","title":"JuMP.start_value","text":"start_value(v::VariableRef)\n\nReturn the start value (MOI attribute VariablePrimalStart) of the variable v. See also set_start_value.\n\nNote: VariablePrimalStarts are sometimes called \"MIP-starts\" or \"warmstarts\".\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.has_lower_bound","page":"Variable API","title":"JuMP.has_lower_bound","text":"has_lower_bound(v::VariableRef)\n\nReturn true if v has a lower bound. If true, the lower bound can be queried with lower_bound. See also LowerBoundRef.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.lower_bound","page":"Variable API","title":"JuMP.lower_bound","text":"lower_bound(v::VariableRef)\n\nReturn the lower bound of a variable. Error if one does not exist. See also has_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.set_lower_bound","page":"Variable API","title":"JuMP.set_lower_bound","text":"set_lower_bound(v::VariableRef, lower::Number)\n\nSet the lower bound of a variable. If one does not exist, create a new lower bound constraint. See also delete_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.delete_lower_bound","page":"Variable API","title":"JuMP.delete_lower_bound","text":"delete_lower_bound(v::VariableRef)\n\nDelete the lower bound constraint of a variable.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.LowerBoundRef","page":"Variable API","title":"JuMP.LowerBoundRef","text":"LowerBoundRef(v::VariableRef)\n\nReturn a constraint reference to the lower bound constraint of v. Errors if one does not exist.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.has_upper_bound","page":"Variable API","title":"JuMP.has_upper_bound","text":"has_upper_bound(v::VariableRef)\n\nReturn true if v has a upper bound. If true, the upper bound can be queried with upper_bound. See also UpperBoundRef.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.upper_bound","page":"Variable API","title":"JuMP.upper_bound","text":"upper_bound(v::VariableRef)\n\nReturn the upper bound of a variable. Error if one does not exist. See also has_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.set_upper_bound","page":"Variable API","title":"JuMP.set_upper_bound","text":"set_upper_bound(v::VariableRef,upper::Number)\n\nSet the upper bound of a variable. If one does not exist, create an upper bound constraint. See also delete_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.delete_upper_bound","page":"Variable API","title":"JuMP.delete_upper_bound","text":"delete_upper_bound(v::VariableRef)\n\nDelete the upper bound constraint of a variable.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.UpperBoundRef","page":"Variable API","title":"JuMP.UpperBoundRef","text":"UpperBoundRef(v::VariableRef)\n\nReturn a constraint reference to the upper bound constraint of v. Errors if one does not exist.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.is_fixed","page":"Variable API","title":"JuMP.is_fixed","text":"is_fixed(v::VariableRef)\n\nReturn true if v is a fixed variable. If true, the fixed value can be queried with fix_value. See also FixRef.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.fix_value","page":"Variable API","title":"JuMP.fix_value","text":"fix_value(v::VariableRef)\n\nReturn the value to which a variable is fixed. Error if one does not exist. See also is_fixed.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.fix","page":"Variable API","title":"JuMP.fix","text":"fix(v::VariableRef, value::Number; force::Bool = false)\n\nFix a variable to a value. Update the fixing constraint if one exists, otherwise create a new one. See also unfix.\n\nIf the variable already has variable bounds and force=false, calling fix will throw an error. If force=true, existing variable bounds will be deleted, and the fixing constraint will be added. Note a variable will have no bounds after a call to unfix.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.unfix","page":"Variable API","title":"JuMP.unfix","text":"unfix(v::VariableRef)\n\nDelete the fixing constraint of a variable.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.FixRef","page":"Variable API","title":"JuMP.FixRef","text":"FixRef(v::VariableRef)\n\nReturn a constraint reference to the constraint fixing the value of v. Errors if one does not exist.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.is_integer","page":"Variable API","title":"JuMP.is_integer","text":"is_integer(v::VariableRef)\n\nReturn true if v is constrained to be integer. See also IntegerRef.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.set_integer","page":"Variable API","title":"JuMP.set_integer","text":"set_integer(variable_ref::VariableRef)\n\nAdd an integrality constraint on the variable variable_ref. See also unset_integer.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.unset_integer","page":"Variable API","title":"JuMP.unset_integer","text":"unset_integer(variable_ref::VariableRef)\n\nRemove the integrality constraint on the variable variable_ref.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.IntegerRef","page":"Variable API","title":"JuMP.IntegerRef","text":"IntegerRef(v::VariableRef)\n\nReturn a constraint reference to the constraint constrainting v to be integer. Errors if one does not exist.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.is_binary","page":"Variable API","title":"JuMP.is_binary","text":"is_binary(v::VariableRef)\n\nReturn true if v is constrained to be binary. See also BinaryRef.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.set_binary","page":"Variable API","title":"JuMP.set_binary","text":"set_binary(v::VariableRef)\n\nAdd a constraint on the variable v that it must take values in the set 01. See also unset_binary.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.unset_binary","page":"Variable API","title":"JuMP.unset_binary","text":"unset_binary(variable_ref::VariableRef)\n\nRemove the binary constraint on the variable variable_ref.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.BinaryRef","page":"Variable API","title":"JuMP.BinaryRef","text":"BinaryRef(v::VariableRef)\n\nReturn a constraint reference to the constraint constrainting v to be binary. Errors if one does not exist.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.relax_integrality","page":"Variable API","title":"JuMP.relax_integrality","text":"relax_integrality(model::Model)\n\nModifies model to \"relax\" all binary and integrality constraints on variables. Specifically,\n\nBinary constraints are deleted, and variable bounds are tightened if necessary to ensure the variable is constrained to the interval 0 1.\nIntegrality constraints are deleted without modifying variable bounds.\nAn error is thrown if semi-continuous or semi-integer constraints are present (support may be added for these in the future).\nAll other constraints are ignored (left in place). This includes discrete constraints like SOS and indicator constraints.\n\nReturns a function that can be called without any arguments to restore the original model. The behavior of this function is undefined if additional changes are made to the affected variables in the meantime.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x, Bin);\n\njulia> @variable(model, 1 <= y <= 10, Int);\n\njulia> @objective(model, Min, x + y);\n\njulia> undo_relax = relax_integrality(model);\n\njulia> print(model)\nMin x + y\nSubject to\n x ≥ 0.0\n y ≥ 1.0\n x ≤ 1.0\n y ≤ 10.0\n\njulia> undo_relax()\n\njulia> print(model)\nMin x + y\nSubject to\n y ≥ 1.0\n y ≤ 10.0\n y integer\n x binary\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.all_variables","page":"Variable API","title":"JuMP.all_variables","text":"all_variables(model::Model)::Vector{VariableRef}\n\nReturns a list of all variables currently in the model. The variables are ordered by creation time.\n\nExample\n\nmodel = Model()\n@variable(model, x)\n@variable(model, y)\nall_variables(model)\n\n# output\n\n2-element Array{VariableRef,1}:\n x\n y\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.owner_model","page":"Variable API","title":"JuMP.owner_model","text":"owner_model(s::AbstractJuMPScalar)\n\nReturn the model owning the scalar s.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.num_variables","page":"Variable API","title":"JuMP.num_variables","text":"num_variables(model::Model)::Int64\n\nReturns number of variables in model.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.VariableRef","page":"Variable API","title":"JuMP.VariableRef","text":"VariableRef <: AbstractVariableRef\n\nHolds a reference to the model and the corresponding MOI.VariableIndex.\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.index-Tuple{VariableRef}","page":"Variable API","title":"JuMP.index","text":"index(v::VariableRef)::MOI.VariableIndex\n\nReturn the index of the variable that corresponds to v in the MOI backend.\n\n\n\n\n\n","category":"method"},{"location":"reference/variables/#JuMP.optimizer_index-Tuple{VariableRef}","page":"Variable API","title":"JuMP.optimizer_index","text":"optimizer_index(v::VariableRef)::MOI.VariableIndex\n\nReturn the index of the variable that corresponds to v in the optimizer model. It throws NoOptimizer if no optimizer is set and throws an ErrorException if the optimizer is set but is not attached.\n\n\n\n\n\n","category":"method"},{"location":"reference/variables/#JuMP.add_variable","page":"Variable API","title":"JuMP.add_variable","text":"add_variable(m::Model, v::AbstractVariable, name::String=\"\")\n\nAdd a variable v to Model m and sets its name.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.check_belongs_to_model","page":"Variable API","title":"JuMP.check_belongs_to_model","text":"check_belongs_to_model(func::AbstractJuMPScalar, model::AbstractModel)\n\nThrow VariableNotOwned if the owner_model of one of the variables of the function func is not model.\n\ncheck_belongs_to_model(constraint::AbstractConstraint, model::AbstractModel)\n\nThrow VariableNotOwned if the owner_model of one of the variables of the constraint constraint is not model.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.build_variable","page":"Variable API","title":"JuMP.build_variable","text":"build_constraint(_error::Function, variables, ::SymMatrixSpace)\n\nReturn a VariablesConstrainedOnCreation of shape SymmetricMatrixShape creating variables in MOI.Reals, i.e. \"free\" variables unless they are constrained after their creation.\n\nThis function is used by the @variable macro as follows:\n\n@variable(model, Q[1:2, 1:2], Symmetric)\n\n\n\n\n\nbuild_variable(_error::Function, variables, ::SkewSymmetricMatrixSpace)\n\nReturn a VariablesConstrainedOnCreation of shape SkewSymmetricMatrixShape creating variables in MOI.Reals, i.e. \"free\" variables unless they are constrained after their creation.\n\nThis function is used by the @variable macro as follows:\n\n@variable(model, Q[1:2, 1:2] in SkewSymmetricMatrixSpace())\n\n\n\n\n\nbuild_constraint(_error::Function, variables, ::PSDCone)\n\nReturn a VariablesConstrainedOnCreation of shape SymmetricMatrixShape constraining the variables to be positive semidefinite.\n\nThis function is used by the @variable macro as follows:\n\n@variable(model, Q[1:2, 1:2], PSD)\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.parse_one_operator_variable","page":"Variable API","title":"JuMP.parse_one_operator_variable","text":"parse_one_operator_variable(_error::Function, infoexpr::_VariableInfoExpr, sense::Val{S}, value) where S\n\nUpdate infoexr for a variable expression in the @variable macro of the form variable name S value.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.AbstractVariable","page":"Variable API","title":"JuMP.AbstractVariable","text":"AbstractVariable\n\nVariable returned by build_variable. It represents a variable that has not been added yet to any model. It can be added to a given model with add_variable.\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.AbstractVariableRef","page":"Variable API","title":"JuMP.AbstractVariableRef","text":"AbstractVariableRef\n\nVariable returned by add_variable. Affine (resp. quadratic) operations with variables of type V<:AbstractVariableRef and coefficients of type T     create a GenericAffExpr{T,V} (resp. GenericQuadExpr{T,V}).\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.VariableNotOwned","page":"Variable API","title":"JuMP.VariableNotOwned","text":"struct VariableNotOwned{V <: AbstractVariableRef} <: Exception\n    variable::V\nend\n\nThe variable variable was used in a model different to owner_model(variable).\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.VariableConstrainedOnCreation","page":"Variable API","title":"JuMP.VariableConstrainedOnCreation","text":"VariablesConstrainedOnCreation <: AbstractVariable\n\nVariable scalar_variables constrained to belong to set. Adding this variable can be understood as doing:\n\nfunction JuMP.add_variable(model::Model, variable::JuMP.VariableConstrainedOnCreation, names)\n    var_ref = JuMP.add_variable(model, variable.scalar_variable, name)\n    JuMP.add_constraint(model, JuMP.VectorConstraint(var_ref, variable.set))\n    return var_ref\nend\n\nbut adds the variables with MOI.add_constrained_variable(model, variable.set) instead. See the MOI documentation for the difference between adding the variables with MOI.add_constrained_variable and adding them with MOI.add_variable and adding the constraint separately.\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.VariablesConstrainedOnCreation","page":"Variable API","title":"JuMP.VariablesConstrainedOnCreation","text":"VariablesConstrainedOnCreation <: AbstractVariable\n\nVector of variables scalar_variables constrained to belong to set. Adding this variable can be thought as doing:\n\nfunction JuMP.add_variable(model::Model, variable::JuMP.VariablesConstrainedOnCreation, names)\n    var_refs = JuMP.add_variable.(model, variable.scalar_variables,\n                                  JuMP.vectorize(names, variable.shape))\n    JuMP.add_constraint(model, JuMP.VectorConstraint(var_refs, variable.set))\n    return JuMP.reshape_vector(var_refs, variable.shape)\nend\n\nbut adds the variables with MOI.add_constrained_variables(model, variable.set) instead. See the MOI documentation for the difference between adding the variables with MOI.add_constrained_variables and adding them with MOI.add_variables and adding the constraint separately.\n\n\n\n\n\n","category":"type"},{"location":"nlp/#Nonlinear-Modeling","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"","category":"section"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP has support for general smooth nonlinear (convex and nonconvex) optimization problems. JuMP is able to provide exact, sparse second-order derivatives to solvers. This information can improve solver accuracy and performance.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear objectives and constraints are specified by using the @NLobjective and @NLconstraint macros. The familiar sum() syntax is supported within these macros, as well as prod() which analogously represents the product of the terms within. Note that the @objective and @constraint macros (and corresponding functions) do not currently support nonlinear expressions. However, a model can contain a mix of linear, quadratic, and nonlinear contraints or objective functions. Starting points may be provided by using the start keyword argument to @variable.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For example, we can solve the classical Rosenbrock problem (with a twist) as follows:","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using Ipopt\nmodel = Model(Ipopt.Optimizer)\n@variable(model, x, start = 0.0)\n@variable(model, y, start = 0.0)\n\n@NLobjective(model, Min, (1 - x)^2 + 100 * (y - x^2)^2)\n\noptimize!(model)\nprintln(\"x = \", value(x), \" y = \", value(y))\n\n# adding a (linear) constraint\n@constraint(model, x + y == 10)\noptimize!(model)\nprintln(\"x = \", value(x), \" y = \", value(y))","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"See the JuMP examples directory for more examples (which include mle.jl, rosenbrock.jl, and clnlbeam.jl).","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The NLP solver tests contain additional examples.","category":"page"},{"location":"nlp/#Syntax-notes","page":"Nonlinear Modeling","title":"Syntax notes","text":"","category":"section"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The syntax accepted in nonlinear expressions is more restricted than the syntax for linear and quadratic expressions. We note some important points below.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"With the exception of the splatting syntax discussed below, all expressions must be simple scalar operations. You cannot use dot, matrix-vector products, vector slices, etc. Translate vector operations into explicit sum() operations or use the AffExpr plus auxiliary variable trick described below.\nThere is no operator overloading provided to build up nonlinear expressions. For example, if x is a JuMP variable, the code 3x will return an AffExpr object that can be used inside of future expressions and linear constraints. However, the code sin(x) is an error. All nonlinear expressions must be inside of macros.\nUser-defined Functions may be used within nonlinear expressions only after they are registered. For example, the follow code results in an error because register() must be called first to register my_function.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"model = Model()\nmy_function(a, b) = exp(a) * b\n@variable(model, x)\n@variable(model, y)\n@NLobjective(model, Min, my_function(x, y))\n\n# output\n\nERROR: Unrecognized function \"my_function\" used in nonlinear expression.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"AffExpr and QuadExpr objects cannot currently be used inside nonlinear expressions. Instead, introduce auxiliary variables, e.g.:","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"    my_expr = dot(c, x) + 3y # where x and y are variables\n    @variable(model, aux)\n    @constraint(model, aux == my_expr)\n    @NLobjective(model, Min, sin(aux))","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"You can declare embeddable nonlinear expressions with @NLexpression. For example:","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"    @NLexpression(model, my_expr[i = 1:n], sin(x[i]))\n    @NLconstraint(model, my_constr[i = 1:n], my_expr[i] <= 0.5)","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Anonymous syntax is supported in @NLexpression and @NLconstraint:","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"    my_expr = @NLexpression(model, [i = 1:n], sin(x[i]))\n    my_constr = @NLconstraint(model, [i = 1:n], my_expr[i] <= 0.5)","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The splatting operator ... is recognized in a very restricted setting for expanding function arguments. The expression splatted can be only a symbol. More complex expressions are not recognized.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x[1:3]);\n\njulia> @NLconstraint(model, *(x...) <= 1.0)\nx[1] * x[2] * x[3] - 1.0 ≤ 0\n\njulia> @NLconstraint(model, *((x / 2)...) <= 0.0)\nERROR: LoadError: Unexpected expression in (*)(x / 2...). JuMP supports splatting only symbols. For example, x... is ok, but (x + 1)..., [x; y]... and g(f(y)...) are not.","category":"page"},{"location":"nlp/#Nonlinear-Parameters","page":"Nonlinear Modeling","title":"Nonlinear Parameters","text":"","category":"section"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For nonlinear models only, JuMP offers a syntax for explicit \"parameter\" objects which can be used to modify a model in-place just by updating the value of the parameter. Nonlinear parameters are declared by using the @NLparameter macro and may be indexed by arbitrary sets analogously to JuMP variables and expressions. The initial value of the parameter must be provided on the right-hand side of the == sign. There is no anonymous syntax for creating parameters.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"You may use value and set_value to query or update the value of a parameter.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @NLparameter(model, p[i = 1:2] == i);\n\njulia> value.(p)\n2-element Array{Float64,1}:\n 1.0\n 2.0\n\njulia> set_value(p[2], 3.0)\n3.0\n\njulia> value.(p)\n2-element Array{Float64,1}:\n 1.0\n 3.0","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear parameters can be used within nonlinear expressions only:","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLparameter(model, x == 10)\n@variable(model, z)\n@objective(model, Max, x * z)             # Error: x is a nonlinear parameter.\n@NLobjective(model, Max, x * z)           # Ok.\n@expression(model, my_expr, x * z^2)      # Error: x is a nonlinear parameter.\n@NLexpression(model, my_nl_expr, x * z^2) # Ok.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear parameters are useful when solving nonlinear models in a sequence:","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using Ipopt\nmodel = Model(Ipopt.Optimizer)\n@variable(model, z)\n@NLparameter(model, x == 1.0)\n@NLobjective(model, Min, (z - x)^2)\noptimize!(model)\nvalue(z) # Equals 1.0.\n\n# Now, update the value of x to solve a different problem.\nset_value(x, 5.0)\noptimize!(model)\nvalue(z) # Equals 5.0","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Using nonlinear parameters can be faster than creating a new model from scratch with updated data because JuMP is able to avoid repeating a number of steps in processing the model before handing it off to the solver.","category":"page"},{"location":"nlp/#User-defined-Functions","page":"Nonlinear Modeling","title":"User-defined Functions","text":"","category":"section"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP's library of recognized univariate functions is derived from the Calculus.jl package. If you encounter a standard special function not currently supported by JuMP, consider contributing to the list of derivative rules there. In addition to this built-in list of functions, it is possible to register custom (user-defined) nonlinear functions to use within nonlinear expressions. JuMP does not support black-box optimization, so all user-defined functions must provide derivatives in some form. Fortunately, JuMP supports automatic differentiation of user-defined functions, a feature to our knowledge not available in any comparable modeling systems.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"note: Note\nAutomatic differentiation is not finite differencing. JuMP's automatically computed derivatives are not subject to approximation error.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP uses ForwardDiff.jl to perform automatic differentiation; see the ForwardDiff.jl documentation for a description of how to write a function suitable for automatic differentiation.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"note: Note\nIf you see method errors with ForwardDiff.Duals, see the guidelines at ForwardDiff.jl. The most common error is that your user-defined function is not generic with respect to the number type, i.e., don't assume that the input to the function is Float64.f(x::Float64) = 2 * x  # This will not work.\nf(x::Real)    = 2 * x  # This is good.\nf(x)          = 2 * x  # This is also good.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"To register a user-defined function with derivatives computed by automatic differentiation, use the register method as in the following example:","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"my_square(x) = x^2\nmy_f(x,y) = (x - 1)^2 + (y - 2)^2\n\nmodel = Model()\n\nregister(model, :my_f, 2, my_f, autodiff=true)\nregister(model, :my_square, 1, my_square, autodiff=true)\n\n@variable(model, x[1:2] >= 0.5)\n@NLobjective(model, Min, my_f(x[1], my_square(x[2])))","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The above code creates a JuMP model with the objective function (x[1] - 1)^2 + (x[2]^2 - 2)^2. The first argument to register is the model for which the functions are registered. The second argument is a Julia symbol object which serves as the name of the user-defined function in JuMP expressions; the JuMP name need not be the same as the name of the corresponding Julia method. The third argument specifies how many arguments the function takes. The fourth argument is the name of the Julia method which computes the function, and autodiff=true instructs JuMP to compute exact gradients automatically.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Forward-mode automatic differentiation as implemented by ForwardDiff.jl has a computational cost that scales linearly with the number of input dimensions. As such, it is not the most efficient way to compute gradients of user-defined functions if the number of input arguments is large. In this case, users may want to provide their own routines for evaluating gradients. The more general syntax for register which accepts user-provided derivative evaluation routines is:","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP.register(model::Model, s::Symbol, dimension::Integer, f::Function,\n              ∇f::Function, ∇²f::Function)","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The input differs between functions which take a single input argument and functions which take more than one. For univariate functions, the derivative evaluation routines should return a number which represents the first and second-order derivatives respectively. For multivariate functions, the derivative evaluation routines will be passed a gradient vector which they must explicitly fill. Second-order derivatives of multivariate functions are not currently supported; this argument should be omitted. The following example sets up the same optimization problem as before, but now we explicitly provide evaluation routines for the user-defined functions:","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"my_square(x) = x^2\nmy_square_prime(x) = 2x\nmy_square_prime_prime(x) = 2\n\nmy_f(x, y) = (x - 1)^2 + (y - 2)^2\nfunction ∇f(g, x, y)\n    g[1] = 2 * (x - 1)\n    g[2] = 2 * (y - 2)\nend\n\nmodel = Model()\n\nregister(model, :my_f, 2, my_f, ∇f)\nregister(model, :my_square, 1, my_square, my_square_prime,\n         my_square_prime_prime)\n\n@variable(model, x[1:2] >= 0.5)\n@NLobjective(model, Min, my_f(x[1], my_square(x[2])))","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Once registered, user-defined functions can also be used in constraints. For example:","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLconstraint(model, my_square(x[1]) <= 2.0)","category":"page"},{"location":"nlp/#User-defined-functions-with-vector-inputs","page":"Nonlinear Modeling","title":"User-defined functions with vector inputs","text":"","category":"section"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"User-defined functions which take vectors as input arguments (e.g. f(x::Vector)) are not supported. Instead, use Julia's splatting syntax to create a function with scalar arguments. For example, instead of","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"f(x::Vector) = sum(x[i]^i for i in 1:length(x))","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"define:","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"f(x...) = sum(x[i]^i for i in 1:length(x))","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This function f can be used in a JuMP model as follows:","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"model = Model()\n@variable(model, x[1:5] >= 0)\nf(x...) = sum(x[i]^i for i in 1:length(x))\nregister(model, :f, 5, f; autodiff = true)\n@NLobjective(model, Min, f(x...))","category":"page"},{"location":"nlp/#Factors-affecting-solution-time","page":"Nonlinear Modeling","title":"Factors affecting solution time","text":"","category":"section"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The execution time when solving a nonlinear programming problem can be divided into two parts, the time spent in the optimization algorithm (the solver) and the time spent evaluating the nonlinear functions and corresponding derivatives. Ipopt explicitly displays these two timings in its output, for example:","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Total CPU secs in IPOPT (w/o function evaluations)   =      7.412\nTotal CPU secs in NLP function evaluations           =      2.083","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For Ipopt in particular, one can improve the performance by installing advanced sparse linear algebra packages, see Installation Guide. For other solvers, see their respective documentation for performance tips.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The function evaluation time, on the other hand, is the responsibility of the modeling language. JuMP computes derivatives by using reverse-mode automatic differentiation with graph coloring methods for exploiting sparsity of the Hessian matrix [1]. As a conservative bound, JuMP's performance here currently may be expected to be within a factor of 5 of AMPL's.","category":"page"},{"location":"nlp/#Querying-derivatives-from-a-JuMP-model","page":"Nonlinear Modeling","title":"Querying derivatives from a JuMP model","text":"","category":"section"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For some advanced use cases, one may want to directly query the derivatives of a JuMP model instead of handing the problem off to a solver. Internally, JuMP implements the AbstractNLPEvaluator interface from MathOptInterface. To obtain an NLP evaluator object from a JuMP model, use JuMP.NLPEvaluator. JuMP.index returns the MOI.VariableIndex corresponding to a JuMP variable. MOI.VariableIndex itself is a type-safe wrapper for Int64 (stored in the value field.)","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For example:","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"raw_index(v::MOI.VariableIndex) = v.value\nmodel = Model()\n@variable(model, x)\n@variable(model, y)\n@NLobjective(model, Min, sin(x) + sin(y))\nvalues = zeros(2)\nx_index = raw_index(JuMP.index(x))\ny_index = raw_index(JuMP.index(y))\nvalues[x_index] = 2.0\nvalues[y_index] = 3.0\nd = NLPEvaluator(model)\nMOI.initialize(d, [:Grad])\nMOI.eval_objective(d, values) # == sin(2.0) + sin(3.0)\n\n# output\n1.0504174348855488","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"∇f = zeros(2)\nMOI.eval_objective_gradient(d, ∇f, values)\n(∇f[x_index], ∇f[y_index]) # == (cos(2.0), cos(3.0))\n\n# output\n(-0.4161468365471424, -0.9899924966004454)","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Only nonlinear constraints (those added with @NLconstraint), and nonlinear objectives (added with @NLobjective) exist in the scope of the NLPEvaluator. The NLPEvaluator does not evaluate derivatives of linear or quadratic constraints or objectives. The index method applied to a nonlinear constraint reference object returns its index as a NonlinearConstraintIndex. The value field of NonlinearConstraintIndex stores the raw integer index. For example:","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @NLconstraint(model, cons1, sin(x) <= 1);\n\njulia> @NLconstraint(model, cons2, x + 5 == 10);\n\njulia> typeof(cons1)\nConstraintRef{Model,NonlinearConstraintIndex,ScalarShape}\n\njulia> index(cons1)\nNonlinearConstraintIndex(1)\n\njulia> index(cons2)\nNonlinearConstraintIndex(2)","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"# TODO: Provide a link for how to access the linear and quadratic parts of the\n# model.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Note that for one-sided nonlinear constraints, JuMP subtracts any values on the right-hand side when computing expressions. In other words, one-sided nonlinear constraints are always transformed to have a right-hand side of zero.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This method of querying derivatives directly from a JuMP model is convenient for interacting with the model in a structured way, e.g., for accessing derivatives of specific variables. For example, in statistical maximum likelihood estimation problems, one is often interested in the Hessian matrix at the optimal solution, which can be queried using the NLPEvaluator.","category":"page"},{"location":"nlp/#Raw-expression-input","page":"Nonlinear Modeling","title":"Raw expression input","text":"","category":"section"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"In addition to the @NLobjective and @NLconstraint macros, it is also possible to provide Julia Expr objects directly by using set_NL_objective and add_NL_constraint. This input form may be useful if the expressions are generated programmatically. JuMP variables should be spliced into the expression object. For example:","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@variable(model, 1 <= x[i = 1:4] <= 5)\nset_NL_objective(model, :Min, :($(x[1])*$(x[4])*($(x[1])+$(x[2])+$(x[3])) + $(x[3])))\nadd_NL_constraint(model, :($(x[1])*$(x[2])*$(x[3])*$(x[4]) >= 25))\n\n# Equivalent form using traditional JuMP macros:\n@NLobjective(model, Min, x[1] * x[4] * (x[1] + x[2] + x[3]) + x[3])\n@NLconstraint(model, x[1] * x[2] * x[3] * x[4] >= 25)","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"See the Julia documentation for more examples and description of Julia expressions.","category":"page"},{"location":"nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"[1]: Dunning, Huchette, and Lubin, \"JuMP: A Modeling Language for Mathematical Optimization\", SIAM Review, PDF.","category":"page"},{"location":"reference/models/#Model-API","page":"Model API","title":"Model API","text":"","category":"section"},{"location":"reference/models/","page":"Model API","title":"Model API","text":"More information can be found in the Interacting with solvers section of the manual.","category":"page"},{"location":"reference/models/","page":"Model API","title":"Model API","text":"Model\n\ndirect_model\n\nmode\n\nset_optimizer\noptimizer_with_attributes\n\nobject_dictionary\nunregister\n\nset_silent\nunset_silent\n\nset_time_limit_sec\nunset_time_limit_sec\ntime_limit_sec\n\nsolver_name\n\nbackend\n\nBase.empty!(::Model)\n\nget_optimizer_attribute\nset_optimizer_attribute\nset_optimizer_attributes\n\nbridge_constraints\nprint_bridge_graph\n\nwrite_to_file\nBase.write(::IO, ::Model; ::MOI.FileFormats.FileFormat)\n\nread_from_file\nBase.read(::IO, ::Type{Model}; ::MOI.FileFormats.FileFormat)\n\nReferenceMap\ncopy_model\ncopy_extension_data\nBase.copy(::AbstractModel)\n\noperator_warn\nerror_if_direct_mode","category":"page"},{"location":"reference/models/#JuMP.Model","page":"Model API","title":"JuMP.Model","text":"Model\n\nA mathematical model of an optimization problem.\n\n\n\n\n\n","category":"type"},{"location":"reference/models/#JuMP.direct_model","page":"Model API","title":"JuMP.direct_model","text":"direct_model(backend::MOI.ModelLike)\n\nReturn a new JuMP model using backend to store the model and solve it. As opposed to the Model constructor, no cache of the model is stored outside of backend and no bridges are automatically applied to backend. The absence of cache reduces the memory footprint but it is important to bear in mind the following implications of creating models using this direct mode:\n\nWhen backend does not support an operation, such as modifying constraints or adding variables/constraints after solving, an error is thrown. For models created using the Model constructor, such situations can be dealt with by storing the modifications in a cache and loading them into the optimizer when optimize! is called.\nNo constraint bridging is supported by default.\nThe optimizer used cannot be changed the model is constructed.\nThe model created cannot be copied.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.mode","page":"Model API","title":"JuMP.mode","text":"mode(model::Model)\n\nReturn mode (DIRECT, AUTOMATIC, MANUAL) of model.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.set_optimizer","page":"Model API","title":"JuMP.set_optimizer","text":"set_optimizer(model::Model, optimizer_factory;\n              bridge_constraints::Bool=true)\n\nCreates an empty MathOptInterface.AbstractOptimizer instance by calling optimizer_factory() and sets it as the optimizer of model. Specifically, optimizer_factory must be callable with zero arguments and return an empty MathOptInterface.AbstractOptimizer.\n\nIf bridge_constraints is true, constraints that are not supported by the optimizer are automatically bridged to equivalent supported constraints when an appropriate transformation is defined in the MathOptInterface.Bridges module or is defined in another module and is explicitly added.\n\nSee set_optimizer_attributes and set_optimizer_attribute for setting solver-specific parameters of the optimizer.\n\nExamples\n\nmodel = Model()\nset_optimizer(model, GLPK.Optimizer)\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.optimizer_with_attributes","page":"Model API","title":"JuMP.optimizer_with_attributes","text":"optimizer_with_attributes(optimizer_constructor, attrs::Pair...)\n\nGroups an optimizer constructor with the list of attributes attrs. Note that it is equivalent to MOI.OptimizerWithAttributes.\n\nWhen provided to the Model constructor or to set_optimizer, it creates an optimizer by calling optimizer_constructor(), and then sets the attributes using set_optimizer_attribute.\n\nExample\n\nmodel = Model(\n    optimizer_with_attributes(\n        Gurobi.Optimizer, \"Presolve\" => 0, \"OutputFlag\" => 1\n    )\n)\n\nis equivalent to:\n\nmodel = Model(Gurobi.Optimizer)\nset_optimizer_attribute(model, \"Presolve\", 0)\nset_optimizer_attribute(model, \"OutputFlag\", 1)\n\nNote\n\nThe string names of the attributes are specific to each solver. One should consult the solver's documentation to find the attributes of interest.\n\nSee also: set_optimizer_attribute, set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.object_dictionary","page":"Model API","title":"JuMP.object_dictionary","text":"object_dictionary(model::Model)\n\nReturn the dictionary that maps the symbol name of a variable, constraint, or expression to the corresponding object.\n\nObjects are registered to a specific symbol in the macros. For example, @variable(model, x[1:2, 1:2]) registers the array of variables x to the symbol :x.\n\nThis method should be defined for any subtype of AbstractModel.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.unregister","page":"Model API","title":"JuMP.unregister","text":"unregister(model::Model, key::Symbol)\n\nUnregister the name key from model so that a new variable, constraint, or expression can be created with the same key.\n\nNote that this will not delete the object model[key]; it will just remove the reference at model[key]. To delete the object, use\n\ndelete(model, model[key])\nunregister(model, key)\n\nExamples\n\n```jldoctest; setup=:(model = Model()) julia> @variable(model, x) x\n\njulia> @variable(model, x) ERROR: An object of name x is already attached to this model. If this is intended, consider using the anonymous construction syntax, e.g., x = @variable(model, [1:N], ...) where the name of the object does not appear inside the macro.\n\nAlternatively, use unregister(model, :x) to first unregister the existing name from the model. Note that this will not delete the object; it will just remove the reference at model[:x]. [...]\n\njulia> num_variables(model) 1\n\njulia> unregister(model, :x)\n\njulia> @variable(model, x) x\n\njulia> num_variables(model) 2\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.set_silent","page":"Model API","title":"JuMP.set_silent","text":"set_silent(model::Model)\n\nTakes precedence over any other attribute controlling verbosity and requires the solver to produce no output.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.unset_silent","page":"Model API","title":"JuMP.unset_silent","text":"unset_silent(model::Model)\n\nNeutralize the effect of the set_silent function and let the solver attributes control the verbosity.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.set_time_limit_sec","page":"Model API","title":"JuMP.set_time_limit_sec","text":"set_time_limit_sec(model::Model, limit)\n\nSets the time limit (in seconds) of the solver. Can be unset using unset_time_limit_sec or with limit set to nothing.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.unset_time_limit_sec","page":"Model API","title":"JuMP.unset_time_limit_sec","text":"unset_time_limit_sec(model::Model)\n\nUnsets the time limit of the solver. Can be set using set_time_limit_sec.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.time_limit_sec","page":"Model API","title":"JuMP.time_limit_sec","text":"time_limit_sec(model::Model)\n\nGets the time limit (in seconds) of the model (nothing if unset). Can be set using set_time_limit_sec.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.solver_name","page":"Model API","title":"JuMP.solver_name","text":"solver_name(model::Model)\n\nIf available, returns the SolverName property of the underlying optimizer. Returns \"No optimizer attached\" in AUTOMATIC or MANUAL modes when no optimizer is attached. Returns \"SolverName() attribute not implemented by the optimizer.\" if the attribute is not implemented.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.backend","page":"Model API","title":"JuMP.backend","text":"backend(model::Model)\n\nReturn the lower-level MathOptInterface model that sits underneath JuMP. This model depends on which operating mode JuMP is in (manual, automatic, or direct), and whether there are any bridges in the model.\n\nIf JuMP is in direct mode (i.e., the model was created using direct_model), the backend with be the optimizer passed to direct_model. If JuMP is in manual or automatic mode, the backend is a MOI.Utilities.CachingOptimizer.\n\nThis function should only be used by advanced users looking to access low-level MathOptInterface or solver-specific functionality.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Base.empty!-Tuple{Model}","page":"Model API","title":"Base.empty!","text":"empty!(model::Model) -> model\n\nEmpty the model, that is, remove all variables, constraints and model attributes but not optimizer attributes. Always return the argument.\n\nNote: removes extensions data.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#JuMP.get_optimizer_attribute","page":"Model API","title":"JuMP.get_optimizer_attribute","text":"get_optimizer_attribute(model, name::String)\n\nReturn the value associated with the solver-specific attribute named name.\n\nNote that this is equivalent to get_optimizer_attribute(model, MOI.RawParameter(name)).\n\nExample\n\nget_optimizer_attribute(model, \"SolverSpecificAttributeName\")\n\nSee also: set_optimizer_attribute, set_optimizer_attributes.\n\n\n\n\n\nget_optimizer_attribute(\n    model::Model, attr::MOI.AbstractOptimizerAttribute\n)\n\nReturn the value of the solver-specific attribute attr in model.\n\nExample\n\nget_optimizer_attribute(model, MOI.Silent())\n\nSee also: set_optimizer_attribute, set_optimizer_attributes.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.set_optimizer_attribute","page":"Model API","title":"JuMP.set_optimizer_attribute","text":"set_optimizer_attribute(model::Model, name::String, value)\n\nSets solver-specific attribute identified by name to value.\n\nNote that this is equivalent to set_optimizer_attribute(model, MOI.RawParameter(name), value).\n\nExample\n\nset_optimizer_attribute(model, \"SolverSpecificAttributeName\", true)\n\nSee also: set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\nset_optimizer_attribute(\n    model::Model, attr::MOI.AbstractOptimizerAttribute, value\n)\n\nSet the solver-specific attribute attr in model to value.\n\nExample\n\nset_optimizer_attribute(model, MOI.Silent(), true)\n\nSee also: set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.set_optimizer_attributes","page":"Model API","title":"JuMP.set_optimizer_attributes","text":"set_optimizer_attributes(model::Model, pairs::Pair...)\n\nGiven a list of attribute => value pairs, calls set_optimizer_attribute(model, attribute, value) for each pair.\n\nExample\n\nmodel = Model(Ipopt.Optimizer)\nset_optimizer_attributes(model, \"tol\" => 1e-4, \"max_iter\" => 100)\n\nis equivalent to:\n\nmodel = Model(Ipopt.Optimizer)\nset_optimizer_attribute(model, \"tol\", 1e-4)\nset_optimizer_attribute(model, \"max_iter\", 100)\n\nSee also: set_optimizer_attribute, get_optimizer_attribute.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.bridge_constraints","page":"Model API","title":"JuMP.bridge_constraints","text":"bridge_constraints(model::Model)\n\nWhen in direct mode, return false. When in manual or automatic mode, return a Bool indicating whether the optimizer is set and unsupported constraints are automatically bridged to equivalent supported constraints when an appropriate transformation is available.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.print_bridge_graph","page":"Model API","title":"JuMP.print_bridge_graph","text":" print_bridge_graph([io::IO,] model::Model)\n\nPrint the hyper-graph containing all variable, constraint, and objective types that could be obtained by bridging the variables, constraints, and objectives that are present in the model.\n\nEach node in the hyper-graph corresponds to a variable, constraint, or objective type.\n\nVariable nodes are indicated by [ ]\nConstraint nodes are indicated by ( )\nObjective nodes are indicated by | |\n\nThe number inside each pair of brackets is an index of the node in the hyper-graph.\n\nNote that this hyper-graph is the full list of possible transformations. When the bridged model is created, we select the shortest hyper-path(s) from this graph, so many nodes may be un-used.\n\nFor more information, see Legat, B., Dowson, O., Garcia, J., and Lubin, M. (2020).  \"MathOptInterface: a data structure for mathematical optimization problems.\" URL: https://arxiv.org/abs/2002.03447\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.write_to_file","page":"Model API","title":"JuMP.write_to_file","text":"write_to_file(\n    model::Model,\n    filename::String;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_AUTOMATIC\n)\n\nWrite the JuMP model model to filename in the format format.\n\nIf the filename ends in .gz, it will be compressed using Gzip. If the filename ends in .bz2, it will be compressed using BZip2.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Base.write-Tuple{IO,Model}","page":"Model API","title":"Base.write","text":"Base.write(\n    io::IO,\n    model::Model;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_MOF\n)\n\nWrite the JuMP model model to io in the format format.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#JuMP.read_from_file","page":"Model API","title":"JuMP.read_from_file","text":"read_from_file(\n    filename::String;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_AUTOMATIC\n)\n\nReturn a JuMP model read from filename in the format format.\n\nIf the filename ends in .gz, it will be uncompressed using Gzip. If the filename ends in .bz2, it will be uncompressed using BZip2.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Base.read-Tuple{IO,Type{Model}}","page":"Model API","title":"Base.read","text":"Base.read(io::IO, ::Type{Model}; format::MOI.FileFormats.FileFormat)\n\nReturn a JuMP model read from io in the format format.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#JuMP.ReferenceMap","page":"Model API","title":"JuMP.ReferenceMap","text":"ReferenceMap\n\nMapping between variable and constraint reference of a model and its copy. The reference of the copied model can be obtained by indexing the map with the reference of the corresponding reference of the original model.\n\n\n\n\n\n","category":"type"},{"location":"reference/models/#JuMP.copy_model","page":"Model API","title":"JuMP.copy_model","text":"copy_model(model::Model)\n\nReturn a copy of the model model and a ReferenceMap that can be used to obtain the variable and constraint reference of the new model corresponding to a given model's reference. A Base.copy(::AbstractModel) method has also been implemented, it is similar to copy_model but does not return the reference map.\n\nNote\n\nModel copy is not supported in DIRECT mode, i.e. when a model is constructed using the direct_model constructor instead of the Model constructor. Moreover, independently on whether an optimizer was provided at model construction, the new model will have no optimizer, i.e., an optimizer will have to be provided to the new model in the optimize! call.\n\nExamples\n\nIn the following example, a model model is constructed with a variable x and a constraint cref. It is then copied into a model new_model with the new references assigned to x_new and cref_new.\n\nmodel = Model()\n@variable(model, x)\n@constraint(model, cref, x == 2)\n\nnew_model, reference_map = copy_model(model)\nx_new = reference_map[x]\ncref_new = reference_map[cref]\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.copy_extension_data","page":"Model API","title":"JuMP.copy_extension_data","text":"copy_extension_data(data, new_model::AbstractModel, model::AbstractModel)\n\nReturn a copy of the extension data data of the model model to the extension data of the new model new_model. A method should be added for any JuMP extension storing data in the ext field.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Base.copy-Tuple{AbstractModel}","page":"Model API","title":"Base.copy","text":"copy(model::AbstractModel)\n\nReturn a copy of the model model. It is similar to copy_model except that it does not return the mapping between the references of model and its copy.\n\nNote\n\nModel copy is not supported in DIRECT mode, i.e. when a model is constructed using the direct_model constructor instead of the Model constructor. Moreover, independently on whether an optimizer was provided at model construction, the new model will have no optimizer, i.e., an optimizer will have to be provided to the new model in the optimize! call.\n\nExamples\n\nIn the following example, a model model is constructed with a variable x and a constraint cref. It is then copied into a model new_model with the new references assigned to x_new and cref_new.\n\nmodel = Model()\n@variable(model, x)\n@constraint(model, cref, x == 2)\n\nnew_model = copy(model)\nx_new = model[:x]\ncref_new = model[:cref]\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#JuMP.operator_warn","page":"Model API","title":"JuMP.operator_warn","text":"operator_warn(model::AbstractModel)\noperator_warn(model::Model)\n\nThis function is called on the model whenever two affine expressions are added together without using destructive_add!, and at least one of the two expressions has more than 50 terms.\n\nFor the case of Model, if this function is called more than 20,000 times then a warning is generated once.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.error_if_direct_mode","page":"Model API","title":"JuMP.error_if_direct_mode","text":"error_if_direct_mode(model::Model, func::Symbol)\n\nErrors if model is in direct mode during a call from the function named func.\n\nUsed internally within JuMP, or by JuMP extensions who do not want to support models in direct mode.\n\n\n\n\n\n","category":"function"},{"location":"examples/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/examples/urban_plan.jl\"","category":"page"},{"location":"examples/urban_plan/#The-urban-planning-problem","page":"The urban planning problem","title":"The urban planning problem","text":"","category":"section"},{"location":"examples/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"An \"urban planning\" problem based on an example from puzzlor.","category":"page"},{"location":"examples/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_urban_plan()\n    model = Model(GLPK.Optimizer)\n    # x is indexed by row and column\n    @variable(model, 0 <= x[1:5, 1:5] <= 1, Int)\n    # y is indexed by R or C, the points, and an index in 1:5. Note how JuMP\n    # allows indexing on arbitrary sets.\n    rowcol = [\"R\", \"C\"]\n    points = [5, 4, 3, -3, -4, -5]\n    @variable(model, 0 <= y[rowcol, points, 1:5] <= 1, Int)\n    # Objective - combine the positive and negative parts\n    @objective(model, Max, sum(\n          3 * (y[\"R\", 3, i] + y[\"C\", 3, i])\n        + 1 * (y[\"R\", 4, i] + y[\"C\", 4, i])\n        + 1 * (y[\"R\", 5, i] + y[\"C\", 5, i])\n        - 3 * (y[\"R\", -3, i] + y[\"C\", -3, i])\n        - 1 * (y[\"R\", -4, i] + y[\"C\", -4, i])\n        - 1 * (y[\"R\", -5, i] + y[\"C\", -5, i])\n        for i in 1:5)\n    )\n    # Constrain the number of residential lots\n    @constraint(model, sum(x) == 12)\n    # Add the constraints that link the auxiliary y variables to the x variables\n    for i = 1:5\n        @constraints(model, begin\n            # Rows\n            y[\"R\", 5, i] <= 1 / 5 * sum(x[i, :]) # sum = 5\n            y[\"R\", 4, i] <= 1 / 4 * sum(x[i, :]) # sum = 4\n            y[\"R\", 3, i] <= 1 / 3 * sum(x[i, :]) # sum = 3\n            y[\"R\", -3, i] >= 1 - 1 / 3 * sum(x[i, :]) # sum = 2\n            y[\"R\", -4, i] >= 1 - 1 / 2 * sum(x[i, :]) # sum = 1\n            y[\"R\", -5, i] >= 1 - 1 / 1 * sum(x[i, :]) # sum = 0\n            # Columns\n            y[\"C\", 5, i] <= 1 / 5 * sum(x[:, i]) # sum = 5\n            y[\"C\", 4, i] <= 1 / 4 * sum(x[:, i]) # sum = 4\n            y[\"C\", 3, i] <= 1 / 3 * sum(x[:, i]) # sum = 3\n            y[\"C\", -3, i] >= 1 - 1 / 3 * sum(x[:, i]) # sum = 2\n            y[\"C\", -4, i] >= 1 - 1 / 2 * sum(x[:, i]) # sum = 1\n            y[\"C\", -5, i] >= 1 - 1 / 1 * sum(x[:, i]) # sum = 0\n        end)\n    end\n    # Solve it\n    optimize!(model)\n    Test.@test termination_status(model) == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ≈ 14.0\n    return\nend\n\nexample_urban_plan()","category":"page"},{"location":"examples/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"View this file on Github.","category":"page"},{"location":"examples/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"","category":"page"},{"location":"examples/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/nonlinear/#Nonlinear-API","page":"Nonlinear API","title":"Nonlinear API","text":"","category":"section"},{"location":"reference/nonlinear/","page":"Nonlinear API","title":"Nonlinear API","text":"More information can be found in the Nonlinear Modeling section of the manual.","category":"page"},{"location":"reference/nonlinear/","page":"Nonlinear API","title":"Nonlinear API","text":"@NLconstraint\n@NLconstraints\n@NLexpression\n@NLexpressions\n@NLobjective\n@NLparameter\nvalue(::JuMP.NonlinearParameter)\nset_value(::JuMP.NonlinearParameter, ::Number)\n\nnum_nl_constraints","category":"page"},{"location":"reference/nonlinear/#JuMP.@NLconstraint","page":"Nonlinear API","title":"JuMP.@NLconstraint","text":"@NLconstraint(m::Model, expr)\n\nAdd a constraint described by the nonlinear expression expr. See also @constraint. For example:\n\n@NLconstraint(model, sin(x) <= 1)\n@NLconstraint(model, [i = 1:3], sin(i * x) <= 1 / i)\n\n\n\n\n\n","category":"macro"},{"location":"reference/nonlinear/#JuMP.@NLconstraints","page":"Nonlinear API","title":"JuMP.@NLconstraints","text":"@NLconstraints(model, args...)\n\nAdds multiple nonlinear constraints to model at once, in the same fashion as the @NLconstraint macro.\n\nThe model must be the first argument, and multiple variables can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@NLconstraints(model, begin\n    t >= sqrt(x^2 + y^2)\n    [i = 1:2], z[i] <= log(a[i])\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/nonlinear/#JuMP.@NLexpression","page":"Nonlinear API","title":"JuMP.@NLexpression","text":"@NLexpression(args...)\n\nEfficiently build a nonlinear expression which can then be inserted in other nonlinear constraints and the objective. See also [@expression]. For example:\n\n@NLexpression(model, my_expr, sin(x)^2 + cos(x^2))\n@NLconstraint(model, my_expr + y >= 5)\n@NLobjective(model, Min, my_expr)\n\nIndexing over sets and anonymous expressions are also supported:\n\n@NLexpression(m, my_expr_1[i=1:3], sin(i * x))\nmy_expr_2 = @NLexpression(m, log(1 + sum(exp(x[i])) for i in 1:2))\n\n\n\n\n\n","category":"macro"},{"location":"reference/nonlinear/#JuMP.@NLexpressions","page":"Nonlinear API","title":"JuMP.@NLexpressions","text":"@NLexpressions(model, args...)\n\nAdds multiple nonlinear expressions to model at once, in the same fashion as the @NLexpression macro.\n\nThe model must be the first argument, and multiple variables can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@NLexpressions(model, begin\n    my_expr, sqrt(x^2 + y^2)\n    my_expr_1[i = 1:2], log(a[i]) - z[i]\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/nonlinear/#JuMP.@NLobjective","page":"Nonlinear API","title":"JuMP.@NLobjective","text":"@NLobjective(model, sense, expression)\n\nAdd a nonlinear objective to model with optimization sense sense. sense must be Max or Min.\n\nExample\n\n@NLobjective(model, Max, 2x + 1 + sin(x))\n\n\n\n\n\n","category":"macro"},{"location":"reference/nonlinear/#JuMP.@NLparameter","page":"Nonlinear API","title":"JuMP.@NLparameter","text":"@NLparameter(model, param == value)\n\nCreate and return a nonlinear parameter param attached to the model model with initial value set to value. Nonlinear parameters may be used only in nonlinear expressions.\n\nExample\n\nmodel = Model()\n@NLparameter(model, x == 10)\nvalue(x)\n\n# output\n10.0\n\n@NLparameter(model, param_collection[...] == value_expr)\n\nCreate and return a collection of nonlinear parameters param_collection attached to the model model with initial value set to value_expr (may depend on index sets). Uses the same syntax for specifying index sets as @variable.\n\nExample\n\nmodel = Model()\n@NLparameter(model, y[i = 1:10] == 2 * i)\nvalue(y[9])\n\n# output\n18.0\n\n\n\n\n\n","category":"macro"},{"location":"reference/nonlinear/#JuMP.value-Tuple{NonlinearParameter}","page":"Nonlinear API","title":"JuMP.value","text":"value(p::NonlinearParameter)\n\nReturn the current value stored in the nonlinear parameter p.\n\nExample\n\nmodel = Model()\n@NLparameter(model, p == 10)\nvalue(p)\n\n# output\n10.0\n\n\n\n\n\n","category":"method"},{"location":"reference/nonlinear/#JuMP.set_value-Tuple{NonlinearParameter,Number}","page":"Nonlinear API","title":"JuMP.set_value","text":"set_value(p::NonlinearParameter, v::Number)\n\nStore the value v in the nonlinear parameter p.\n\nExample\n\nmodel = Model()\n@NLparameter(model, p == 0)\nset_value(p, 5)\nvalue(p)\n\n# output\n5.0\n\n\n\n\n\n","category":"method"},{"location":"reference/nonlinear/#JuMP.num_nl_constraints","page":"Nonlinear API","title":"JuMP.num_nl_constraints","text":"num_nl_constraints(model::Model)\n\nReturns the number of nonlinear constraints associated with the model.\n\n\n\n\n\n","category":"function"},{"location":"quickstart/#Quick-Start-Guide","page":"Quick Start Guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"This quick start guide will introduce the main concepts of JuMP. If you are familiar with another modeling language embedded in a high-level language such as PuLP (Python) or a solver-specific interface you will find most of this familiar. If you are coming from an AMPL or similar background, you may find some of the concepts novel but the general appearance will still be familiar.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"The example in this guide is deliberately kept simple. There are more complex examples in Jupyter notebook form at JuMPTutorials.jl.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Once JuMP is installed, to use JuMP in your programs, you just need to say:","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> using JuMP","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"You also need to include a Julia package which provides an appropriate solver. One such solver is GLPK.Optimizer, which is provided by the GLPK.jl package.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> using GLPK","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"See Installation Guide for a list of other solvers you can use.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Models are created with the Model function. The optimizer can be set either in Model() or by calling set_optimizer:","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> model = Model(GLPK.Optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: GLPK","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"equivalently,","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> model = Model();\njulia> set_optimizer(model, GLPK.Optimizer);\njulia> model\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: GLPK","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"note: Note\nThe term \"solver\" is used as a synonym for \"optimizer\". The convention in code, however, is to always use \"optimizer\", e.g., GLPK.Optimizer.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"DocTestSetup = quote\n    # Using a mock optimizer removes the need to load a solver such as GLPK for\n    # building the documentation.\n    const MOI = JuMP.MathOptInterface\n    model = Model(() -> MOI.Utilities.MockOptimizer(\n                            MOIU.Model{Float64}(),\n                            eval_objective_value = false,\n                            eval_variable_constraint_dual = false))\nend","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"note: Note\nYour model doesn't have to be called model - it's just a name.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"The following commands will create two variables, x and y, with both lower and upper bounds. Note the first argument is our model model. These variables (x and y) are associated with this model and cannot be used in another model.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> @variable(model, 0 <= x <= 2)\nx\n\njulia> @variable(model, 0 <= y <= 30)\ny","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"See the Variables section for more information on creating variables, including the syntax for specifying different combinations of bounds, i.e., only lower bounds, only upper bounds, or no bounds.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"DocTestSetup = nothing","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Next we'll set our objective. Note again the model, so we know which model's objective we are setting! The objective sense, Max or Min, should be provided as the second argument. Note also that we don't have a multiplication * symbol between 5 and our variable x - Julia is smart enough to not need it! Feel free to use * if it makes you feel more comfortable, as we have done with 3 * y. (We have been intentionally inconsistent here to demonstrate different syntax; however, it is good practice to pick one way or the other consistently in your code.)","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> @objective(model, Max, 5x + 3 * y)\n5 x + 3 y","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Adding constraints is a lot like setting the objective. Here we create a less-than-or-equal-to constraint using <=, but we can also create equality constraints using == and greater-than-or-equal-to constraints with >=:","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> @constraint(model, con, 1x + 5y <= 3)\ncon : x + 5 y <= 3.0","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Note that in a similar manner to the @variable macro, we have named the constraint con. This will bind the constraint to the Julia variable con for later analysis.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Models are solved with the JuMP.optimize! function:","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> optimize!(model)","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"DocTestSetup = quote\n    # Now we load in the solution. Using a caching optimizer removes the need to\n    # load a solver such as GLPK for building the documentation.\n    mock = JuMP.backend(model).optimizer.model\n    MOI.set(mock, MOI.TerminationStatus(), MOI.OPTIMAL)\n    MOI.set(mock, MOI.PrimalStatus(), MOI.FEASIBLE_POINT)\n    MOI.set(mock, MOI.DualStatus(), MOI.FEASIBLE_POINT)\n    MOI.set(mock, MOI.ResultCount(), 1)\n    MOI.set(mock, MOI.ObjectiveValue(), 10.6)\n    MOI.set(mock, MOI.VariablePrimal(), JuMP.optimizer_index(x), 2.0)\n    MOI.set(mock, MOI.VariablePrimal(), JuMP.optimizer_index(y), 0.2)\n    MOI.set(mock, MOI.ConstraintDual(), JuMP.optimizer_index(con), -0.6)\n    MOI.set(mock, MOI.ConstraintDual(), JuMP.optimizer_index(UpperBoundRef(x)), -4.4)\n    MOI.set(mock, MOI.ConstraintDual(), JuMP.optimizer_index(LowerBoundRef(y)), 0.0)\nend","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"After the call to JuMP.optimize! has finished, we need to query what happened. The solve could terminate for a number of reasons. First, the solver might have found the optimal solution or proved that the problem is infeasible. However, it might also have run into numerical difficulties or terminated due to a setting such as a time limit. We can ask the solver why it stopped using the JuMP.termination_status function:","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> termination_status(model)\nOPTIMAL::TerminationStatusCode = 1","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"In this case, GLPK returned OPTIMAL, this means that it has found the optimal solution.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"DocTestSetup = nothing","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"As the solver found an optimal solution, we expect the solution returned to be a primal-dual pair of feasible solutions with zero duality gap. We can verify the primal and dual status as follows to confirm this:","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> primal_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1\n\njulia> dual_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Note that the primal and dual status only inform that the primal and dual solutions are feasible and it is only because we verified that the termination status is OPTIMAL that we can conclude that they form an optimal solution.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Finally, we can query the result of the optimization. First, we can query the objective value:","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> objective_value(model)\n10.6","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"We can also query the primal result values of the x and y variables:","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> value(x)\n2.0\n\njulia> value(y)\n0.2","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"We can also query the value of the dual variable associated with the constraint con (which we bound to a Julia variable when defining the constraint):","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> dual(con)\n-0.6","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"info: Info\nSee the duality section for a discussion of the convention that JuMP uses for signs of duals.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"To query the dual variables associated with the variable bounds, things are a little trickier as we first need to obtain a reference to the constraint:","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> x_upper = UpperBoundRef(x)\nx <= 2.0\n\njulia> dual(x_upper)\n-4.4","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"A similar process can be followed to obtain the dual of the lower bound constraint on y:","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> y_lower = LowerBoundRef(y)\ny >= 0.0\n\njulia> dual(y_lower)\n0.0","category":"page"},{"location":"objective/#Objectives","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"objective/","page":"Objectives","title":"Objectives","text":"This page describes macros and functions related to linear and quadratic objective functions only, unless otherwise indicated. For nonlinear objective functions, see Nonlinear Modeling.","category":"page"},{"location":"objective/","page":"Objectives","title":"Objectives","text":"Use the @objective macro to set linear and quadratic objective functions in a JuMP model. The functions set_objective_sense and set_objective_function provide an equivalent lower-level interface.","category":"page"},{"location":"objective/","page":"Objectives","title":"Objectives","text":"To update a term in the objective function, see set_objective_coefficient.","category":"page"},{"location":"objective/","page":"Objectives","title":"Objectives","text":"To query the objective function from a model, see objective_sense, objective_function, and objective_function_type.","category":"page"},{"location":"objective/","page":"Objectives","title":"Objectives","text":"To query the optimal objective value or best known bound after a solve, see objective_value and objective_bound. These two functions apply to nonlinear objectives also. The optimal value of the dual objective can be obtained via dual_objective_value.","category":"page"},{"location":"reference/expressions/#Expression-API","page":"Expression API","title":"Expression API","text":"","category":"section"},{"location":"reference/expressions/","page":"Expression API","title":"Expression API","text":"More information can be found in the Expressions section of the manual.","category":"page"},{"location":"reference/expressions/","page":"Expression API","title":"Expression API","text":"@expression\n@expressions\n\nGenericAffExpr\nAffExpr\nGenericQuadExpr\nQuadExpr\nUnorderedPair\n\nadd_to_expression!\nconstant\ndrop_zeros!\nisequal_canonical\nlinear_terms\nmap_coefficients\nmap_coefficients_inplace!\nquad_terms\nvariable_ref_type\n\njump_function\njump_function_type\nmoi_function\nmoi_function_type","category":"page"},{"location":"reference/expressions/#JuMP.@expression","page":"Expression API","title":"JuMP.@expression","text":"@expression(args...)\n\nEfficiently builds a linear or quadratic expression but does not add to model immediately. Instead, returns the expression which can then be inserted in other constraints. For example:\n\n@expression(m, shared, sum(i*x[i] for i=1:5))\n@constraint(m, shared + y >= 5)\n@constraint(m, shared + z <= 10)\n\nThe ref accepts index sets in the same way as @variable, and those indices can be used in the construction of the expressions:\n\n@expression(m, expr[i=1:3], i*sum(x[j] for j=1:3))\n\nAnonymous syntax is also supported:\n\nexpr = @expression(m, [i=1:3], i*sum(x[j] for j=1:3))\n\n\n\n\n\n","category":"macro"},{"location":"reference/expressions/#JuMP.@expressions","page":"Expression API","title":"JuMP.@expressions","text":"@expressions(model, args...)\n\nAdds multiple expressions to model at once, in the same fashion as the @expression macro.\n\nThe model must be the first argument, and multiple variables can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@expressions(model, begin\n    my_expr, x^2 + y^2\n    my_expr_1[i = 1:2], a[i] - z[i]\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/expressions/#JuMP.GenericAffExpr","page":"Expression API","title":"JuMP.GenericAffExpr","text":"mutable struct GenericAffExpr{CoefType,VarType} <: AbstractJuMPScalar\n    constant::CoefType\n    terms::OrderedDict{VarType,CoefType}\nend\n\nAn expression type representing an affine expression of the form: sum a_i x_i + c.\n\nFields\n\n.constant: the constant c in the expression.\n.terms: an OrderedDict, with keys of VarType and values of CoefType describing the sparse vector a.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.AffExpr","page":"Expression API","title":"JuMP.AffExpr","text":"AffExpr\n\nAlias for GenericAffExpr{Float64,VariableRef}, the specific GenericAffExpr used by JuMP.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.GenericQuadExpr","page":"Expression API","title":"JuMP.GenericQuadExpr","text":"mutable struct GenericQuadExpr{CoefType,VarType} <: AbstractJuMPScalar\n    aff::GenericAffExpr{CoefType,VarType}\n    terms::OrderedDict{UnorderedPair{VarType}, CoefType}\nend\n\nAn expression type representing an quadratic expression of the form: sum q_ij x_i x_j + sum a_i x_i + c.\n\nFields\n\n.aff: an GenericAffExpr representing the affine portion of the expression.\n.terms: an OrderedDict, with keys of UnorderedPair{VarType} and values of CoefType, describing the sparse list of terms q.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.QuadExpr","page":"Expression API","title":"JuMP.QuadExpr","text":"QuadExpr\n\nAn alias for GenericQuadExpr{Float64,VariableRef}, the specific     GenericQuadExpr used by JuMP.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.UnorderedPair","page":"Expression API","title":"JuMP.UnorderedPair","text":"UnorderedPair(a::T, b::T)\n\nA wrapper type used by GenericQuadExpr with fields .a and .b.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.add_to_expression!","page":"Expression API","title":"JuMP.add_to_expression!","text":"add_to_expression!(expression, terms...)\n\nUpdates expression in place to expression + (*)(terms...). This is typically much more efficient than expression += (*)(terms...). For example, add_to_expression!(expression, a, b) produces the same result as expression += a*b, and add_to_expression!(expression, a) produces the same result as expression += a.\n\nOnly a few methods are defined, mostly for internal use, and only for the cases when (1) they can be implemented efficiently and (2) expression is capable of storing the result. For example, add_to_expression!(::AffExpr, ::VariableRef, ::VariableRef) is not defined because a GenericAffExpr cannot store the product of two variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.constant","page":"Expression API","title":"JuMP.constant","text":"constant(aff::GenericAffExpr{C, V})::C\n\nReturn the constant of the affine expression.\n\n\n\n\n\nconstant(aff::GenericQuadExpr{C, V})::C\n\nReturn the constant of the quadratic expression.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.drop_zeros!","page":"Expression API","title":"JuMP.drop_zeros!","text":"drop_zeros!(expr::GenericAffExpr)\n\nRemove terms in the affine expression with 0 coefficients.\n\n\n\n\n\ndrop_zeros!(expr::GenericQuadExpr)\n\nRemove terms in the quadratic expression with 0 coefficients.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.isequal_canonical","page":"Expression API","title":"JuMP.isequal_canonical","text":"isequal_canonical(\n    aff::GenericAffExpr{C,V},\n    other::GenericAffExpr{C,V}\n) where {C,V}\n\nReturn true if aff is equal to other after dropping zeros and disregarding the order. Mainly useful for testing.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.linear_terms","page":"Expression API","title":"JuMP.linear_terms","text":"linear_terms(aff::GenericAffExpr{C, V})\n\nProvides an iterator over coefficient-variable tuples (a_i::C, x_i::V) in the linear part of the affine expression.\n\n\n\n\n\nlinear_terms(quad::GenericQuadExpr{C, V})\n\nProvides an iterator over tuples (coefficient::C, variable::V) in the linear part of the quadratic expression.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.map_coefficients","page":"Expression API","title":"JuMP.map_coefficients","text":"map_coefficients(f::Function, a::GenericAffExpr)\n\nApply f to the coefficients and constant term of an GenericAffExpr a and return a new expression.\n\nSee also: map_coefficients_inplace!\n\nExample\n\njulia> a = GenericAffExpr(1.0, x => 1.0)\nx + 1\n\njulia> map_coefficients(c -> 2 * c, a)\n2 x + 2\n\njulia> a\nx + 1\n\n\n\n\n\nmap_coefficients(f::Function, a::GenericQuadExpr)\n\nApply f to the coefficients and constant term of an GenericQuadExpr a and return a new expression.\n\nSee also: map_coefficients_inplace!\n\nExample\n\njulia> a = @expression(model, x^2 + x + 1)\nx² + x + 1\n\njulia> map_coefficients(c -> 2 * c, a)\n2 x² + 2 x + 2\n\njulia> a\nx² + x + 1\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.map_coefficients_inplace!","page":"Expression API","title":"JuMP.map_coefficients_inplace!","text":"map_coefficients_inplace!(f::Function, a::GenericAffExpr)\n\nApply f to the coefficients and constant term of an GenericAffExpr a and update them in-place.\n\nSee also: map_coefficients\n\nExample\n\njulia> a = GenericAffExpr(1.0, x => 1.0)\nx + 1\n\njulia> map_coefficients_inplace!(c -> 2 * c, a)\n2 x + 2\n\njulia> a\n2 x + 2\n\n\n\n\n\nmap_coefficients_inplace!(f::Function, a::GenericQuadExpr)\n\nApply f to the coefficients and constant term of an GenericQuadExpr a and update them in-place.\n\nSee also: map_coefficients\n\nExample\n\njulia> a = @expression(model, x^2 + x + 1)\nx² + x + 1\n\njulia> map_coefficients_inplace!(c -> 2 * c, a)\n2 x² + 2 x + 2\n\njulia> a\n2 x² + 2 x + 2\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.quad_terms","page":"Expression API","title":"JuMP.quad_terms","text":"quad_terms(quad::GenericQuadExpr{C, V})\n\nProvides an iterator over tuples (coefficient::C, var_1::V, var_2::V) in the quadratic part of the quadratic expression.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.variable_ref_type","page":"Expression API","title":"JuMP.variable_ref_type","text":"variable_ref_type(::GenericAffExpr{C, V}) where {C, V}\n\nA helper function used internally by JuMP and some JuMP extensions. Returns the variable type V from a GenericAffExpr\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.jump_function","page":"Expression API","title":"JuMP.jump_function","text":"jump_function(x)\n\nGiven an MathOptInterface object x, return the JuMP equivalent.\n\nSee also: moi_function.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.jump_function_type","page":"Expression API","title":"JuMP.jump_function_type","text":"jump_function_type(::Type{T}) where {T}\n\nGiven an MathOptInterface object type T, return the JuMP equivalent.\n\nSee also: moi_function_type.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.moi_function","page":"Expression API","title":"JuMP.moi_function","text":"moi_function(x)\n\nGiven a JuMP object x, return the MathOptInterface equivalent.\n\nSee also: jump_function.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.moi_function_type","page":"Expression API","title":"JuMP.moi_function_type","text":"moi_function_type(::Type{T}) where {T}\n\nGiven a JuMP object type T, return the MathOptInterface equivalent.\n\nSee also: jump_function_type.\n\n\n\n\n\n","category":"function"}]
}
