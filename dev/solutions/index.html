<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Query Solutions · JuMP</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="JuMP logo"/></a><h1>JuMP</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../installation/">Installation Guide</a></li><li><a class="toctext" href="../quickstart/">Quick Start Guide</a></li><li><a class="toctext" href="../variables/">Variables</a></li><li><a class="toctext" href="../expressions/">Expressions</a></li><li><a class="toctext" href="../objective/">Objective</a></li><li><a class="toctext" href="../constraints/">Constraints</a></li><li><a class="toctext" href="../containers/">Containers</a></li><li><a class="toctext" href="../solvers/">Solvers</a></li><li class="current"><a class="toctext" href>Query Solutions</a><ul class="internal"><li><a class="toctext" href="#Termination-statuses-1">Termination statuses</a></li><li><a class="toctext" href="#Solution-statuses-1">Solution statuses</a></li><li><a class="toctext" href="#Obtaining-solutions-1">Obtaining solutions</a></li><li><a class="toctext" href="#Reference-1">Reference</a></li></ul></li><li><a class="toctext" href="../nlp/">Nonlinear Modeling</a></li><li><a class="toctext" href="../style/">Style Guide</a></li><li><a class="toctext" href="../extensions/">Extensions</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Query Solutions</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/JuMP.jl/blob/master/docs/src/solutions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Query Solutions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Querying-Solutions-1" href="#Querying-Solutions-1">Querying Solutions</a></h1><p>So far we have seen all the elements and constructs related to writing a JuMP optimization model. In this section we reach the point of what to do with a solved problem. Suppose your model is named <code>model</code>. Right after the call to <code>JuMP.optimize!(model)</code> (which might take a while) it&#39;s possible to ask JuMP questions about the finished optimization step. Typical questions include:</p><ul><li>Why has the optimization process stopped?</li><li>Do I have a solution to my problem?</li><li>Is it optimal?</li><li>Do I have a dual solution?</li></ul><p>JuMP follows closely the concepts defined in <a href="https://github.com/JuliaOpt/MathOptInterface.jl">MathOptInterface (MOI)</a> to answer user questions about a finished call to <code>JuMP.optimize!(model)</code>. There are three main steps in querying a solution:</p><p>First, we can query the <a href="#JuMP.termination_status"><code>termination_status</code></a> which will tell us why the optimization stopped. This could be due to a number of reasons. For example, the solver found an optimal solution, the problem was proven to be infeasible, or a user-provided limit such as a time limit was encountered. For more information, see the <a href="#Termination-statuses-1">Termination statuses</a> section below.</p><p>Second, we can query the <a href="#JuMP.primal_status"><code>primal_status</code></a> and <a href="#JuMP.dual_status"><code>dual_status</code></a>, which will tell us what kind of result do we have for our primal and dual solution. This might be an optimal primal-dual pair, a primal solution without a corresponding dual solution, or a certificate of primal or dual infeasibility. For more information, see the <a href="#Solution-statuses-1">Solution statuses</a> section below.</p><p>Third, we can query <a href="#JuMP.value"><code>JuMP.value</code></a> and <a href="#JuMP.dual"><code>JuMP.dual</code></a> to obtain the primal and dual values of the optimization variables and constraints (if there are values to be queried).</p><h2><a class="nav-anchor" id="Termination-statuses-1" href="#Termination-statuses-1">Termination statuses</a></h2><p>The reason why the optimization of <code>model</code> was finished is given by</p><pre><code class="language-julia">JuMP.termination_status(model)</code></pre><p>This function will return a <code>MOI.TerminationStatusCode</code> <code>enum</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.TerminationStatusCode" href="#MathOptInterface.TerminationStatusCode"><code>MathOptInterface.TerminationStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TerminationStatusCode</code></pre><p>An Enum of possible values for the <code>TerminationStatus</code> attribute. This attribute is meant to explain the reason why the optimizer stopped executing in the most recent call to <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>.</p><p>If no call has been made to <a href="#MathOptInterface.optimize!"><code>optimize!</code></a>, then the <code>TerminationStatus</code> is:</p><ul><li><code>OPTIMIZE_NOT_CALLED</code>: The algorithm has not started.</li></ul><p><strong>OK</strong></p><p>These are generally OK statuses, i.e., the algorithm ran to completion normally.</p><ul><li><code>OPTIMAL</code>: The algorithm found a globally optimal solution.</li><li><code>INFEASIBLE</code>: The algorithm concluded that no feasible solution exists.</li><li><code>DUAL_INFEASIBLE</code>: The algorithm concluded that no dual bound exists for the problem. If, additionally, a feasible (primal) solution is known to exist, this status typically implies that the problem is unbounded, with some technical exceptions.</li><li><code>LOCALLY_SOLVED</code>: The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.</li><li><code>LOCALLY_INFEASIBLE</code>: The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.</li><li><code>INFEASIBLE_OR_UNBOUNDED</code>: The algorithm stopped because it decided that the problem is infeasible or unbounded; this occasionally happens during MIP presolve.</li></ul><p><strong>Solved to relaxed tolerances</strong></p><ul><li><code>ALMOST_OPTIMAL</code>: The algorithm found a globally optimal solution to relaxed tolerances.</li><li><code>ALMOST_INFEASIBLE</code>: The algorithm concluded that no feasible solution exists within relaxed tolerances.</li><li><code>ALMOST_DUAL_INFEASIBLE</code>: The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.</li><li><code>ALMOST_LOCALLY_SOLVED</code>: The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.</li></ul><p><strong>Limits</strong></p><p>The optimizer stopped because of some user-defined limit.</p><ul><li><code>ITERATION_LIMIT</code>: An iterative algorithm stopped after conducting the maximum number of iterations.</li><li><code>TIME_LIMIT</code>: The algorithm stopped after a user-specified computation time.</li><li><code>NODE_LIMIT</code>: A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.</li><li><code>SOLUTION_LIMIT</code>: The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.</li><li><code>MEMORY_LIMIT</code>: The algorithm stopped because it ran out of memory.</li><li><code>OBJECTIVE_LIMIT</code>: The algorthm stopped because it found a solution better than a minimum limit set by the user.</li><li><code>NORM_LIMIT</code>: The algorithm stopped because the norm of an iterate became too large.</li><li><code>OTHER_LIMIT</code>: The algorithm stopped due to a limit not covered by one of the above.</li></ul><p><strong>Problematic</strong></p><p>This group of statuses means that something unexpected or problematic happened.</p><ul><li><code>SLOW_PROGRESS</code>: The algorithm stopped because it was unable to continue making progress towards the solution.</li><li><code>NUMERICAL_ERROR</code>: The algorithm stopped because it encountered unrecoverable numerical error.</li><li><code>INVALID_MODEL</code>: The algorithm stopped because the model is invalid.</li><li><code>INVALID_OPTION</code>: The algorithm stopped because it was provided an invalid option.</li><li><code>INTERRUPTED</code>: The algorithm stopped because of an interrupt signal.</li><li><code>OTHER_ERROR</code>: The algorithm stopped because of an error not covered by one of the statuses defined above.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/#L0-L78">source</a></section><h2><a class="nav-anchor" id="Solution-statuses-1" href="#Solution-statuses-1">Solution statuses</a></h2><p>These statuses indicate what kind of result is available to be queried with <a href="#JuMP.value"><code>JuMP.value</code></a> and <a href="#JuMP.dual"><code>JuMP.dual</code></a>. Its possible that no result is available to be queried.</p><p>We can obtain these statuses by calling <a href="#JuMP.primal_status"><code>JuMP.primal_status</code></a> for the primal status, and <a href="#JuMP.dual_status"><code>JuMP.dual_status</code></a> for the dual status. Both will return a <code>MOI.ResultStatusCode</code> <code>enum</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ResultStatusCode" href="#MathOptInterface.ResultStatusCode"><code>MathOptInterface.ResultStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ResultStatusCode</code></pre><p>An Enum of possible values for the <code>PrimalStatus</code> and <code>DualStatus</code> attributes. The values indicate how to interpret the result vector.</p><ul><li><code>NO_SOLUTION</code>: the result vector is empty.</li><li><code>FEASIBLE_POINT</code>: the result vector is a feasible point.</li><li><code>NEARLY_FEASIBLE_POINT</code>: the result vector is feasible if some constraint tolerances are relaxed.</li><li><code>INFEASIBLE_POINT</code>: the result vector is an infeasible point.</li><li><code>INFEASIBILITY_CERTIFICATE</code>: the result vector is an infeasibility certificate. If the <code>PrimalStatus</code> is <code>INFEASIBILITY_CERTIFICATE</code>, then the primal result vector is a certificate of dual infeasibility. If the <code>DualStatus</code> is <code>INFEASIBILITY_CERTIFICATE</code>, then the dual result vector is a proof of primal infeasibility.</li><li><code>NEARLY_INFEASIBILITY_CERTIFICATE</code>: the result satisfies a relaxed criterion for a certificate of infeasibility.</li><li><code>UNKNOWN_RESULT_STATUS</code>: the result vector contains a solution with an unknown interpretation.</li><li><code>OTHER_RESULT_STATUS</code>: the result vector contains a solution with an interpretation not covered by one of the statuses defined above.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/#L0-L22">source</a></section><p>Common status situations are described in the <a href="http://www.juliaopt.org/MathOptInterface.jl/v0.8/apimanual/#Common-status-situations-1"><code>MathOptInterface</code> docs</a>.</p><h2><a class="nav-anchor" id="Obtaining-solutions-1" href="#Obtaining-solutions-1">Obtaining solutions</a></h2><p>Provided the primal status is not (<code>MOI.NO_SOLUTION</code>), the primal solution can be obtained by calling <a href="#JuMP.value"><code>JuMP.value</code></a>. For the dual solution, the function is <a href="#JuMP.dual"><code>JuMP.dual</code></a>. One fast way to check if the status is not <code>MOI.NO_SOLUTION</code> is via <a href="#JuMP.has_values"><code>JuMP.has_values</code></a> for the primal status and <a href="#JuMP.has_duals"><code>JuMP.has_duals</code></a> for the dual solution.</p><p>It is important to note that if <code>has_values</code> returns false, calls to <a href="#JuMP.value"><code>JuMP.value</code></a> and <a href="#JuMP.dual"><code>JuMP.dual</code></a> might throw an error or return arbitrary values.</p><p>The container type (e.g., scalar, vector, or matrix) of the returned solution (primal or dual) depends on the type of the variable or constraint. See <a href="../extensions/#JuMP.AbstractShape"><code>AbstractShape</code></a> and <a href="../extensions/#JuMP.dual_shape"><code>dual_shape</code></a> for details.</p><p>To call <a href="#JuMP.value"><code>JuMP.value</code></a> or <a href="#JuMP.dual"><code>JuMP.dual</code></a> on container of <a href="../variables/#JuMP.VariableRef"><code>VariableRef</code></a> or <a href="../constraints/#JuMP.ConstraintRef"><code>ConstraintRef</code></a>, use the broadcast syntax, e.g., <code>JuMP.value.(x)</code>.</p><p>The objective value of a solved problem can be obtained via <a href="../objective/#JuMP.objective_value"><code>JuMP.objective_value</code></a>. The best known bound on the optimal objective value can be obtained via <a href="../objective/#JuMP.objective_bound"><code>JuMP.objective_bound</code></a>.</p><p>A recommended workflow for solving a model and querying the solution is the following:</p><pre><code class="language-julia">using JuMP, MathOptInterface
const MOI = MathOptInterface
model = Model()
@variable(model, x[1:10] &gt;= 0)
# ... other constraints ...
JuMP.optimize!(model)

if JuMP.termination_status(model) == MOI.OPTIMAL
    optimal_solution = JuMP.value.(x)
    optimal_objective = JuMP.objective_value(model)
elseif JuMP.termination_status(model) == MOI.TIME_LIMIT &amp;&amp; JuMP.has_values(model)
    suboptimal_solution = JuMP.value.(x)
    suboptimal_objective = JuMP.objective_value(model)
else
    error(&quot;The model was not solved correctly.&quot;)
end</code></pre><h2><a class="nav-anchor" id="Reference-1" href="#Reference-1">Reference</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.termination_status" href="#JuMP.termination_status"><code>JuMP.termination_status</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">termination_status(model::Model)</code></pre><p>Return the reason why the solver stopped (i.e., the MathOptInterface model attribute <code>TerminationStatus</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.primal_status" href="#JuMP.primal_status"><code>JuMP.primal_status</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">primal_status(model::Model)</code></pre><p>Return the status of the most recent primal solution of the solver (i.e., the MathOptInterface model attribute <code>PrimalStatus</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.has_values" href="#JuMP.has_values"><code>JuMP.has_values</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_values(model::Model)</code></pre><p>Return true if the solver has a primal solution available to query, otherwise return false.</p><p>See also <a href="#JuMP.value"><code>value</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.value" href="#JuMP.value"><code>JuMP.value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">value(cref::ConstraintRef)</code></pre><p>Get the primal value of this constraint in the result returned by a solver. That is, if <code>cref</code> is the reference of a constraint <code>func</code>-in-<code>set</code>, it returns the value of <code>func</code> evaluated at the value of the variables (given by <a href="#JuMP.value"><code>value(::VariableRef)</code></a>). Use <a href="#JuMP.has_values"><code>has_values</code></a> to check if a result exists before asking for values.</p><p><strong>Note</strong></p><p>For scalar contraints, the constant is moved to the <code>set</code> so it is not taken into account in the primal value of the constraint. For instance, the constraint <code>@constraint(model, 2x + 3y + 1 == 5)</code> is transformed into <code>2x + 3y</code>-in-<code>MOI.EqualTo(4)</code> so the value returned by this function is the evaluation of <code>2x + 3y</code>. ```</p></div></div><div><div><pre><code class="language-none">value(v::VariableRef)</code></pre><p>Get the value of this variable in the result returned by a solver. Use <code>has_values</code> to check if a result exists before asking for values. Replaces <code>getvalue</code> for most use cases.</p></div></div><div><div><pre><code class="language-none">value(ex::GenericAffExpr, var_value::Function)</code></pre><p>Evaluate <code>ex</code> using <code>var_value(v)</code> as the value for each variable <code>v</code>.</p></div></div><div><div><pre><code class="language-none">value(v::GenericAffExpr)</code></pre><p>Evaluate an <code>GenericAffExpr</code> given the result returned by a solver. Replaces <code>getvalue</code> for most use cases.</p></div></div><div><div><pre><code class="language-none">value(p::NonlinearParameter)</code></pre><p>Return the current value stored in the nonlinear parameter <code>p</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">model = Model()
@NLparameter(model, p == 10)
JuMP.value(p)

# output
10.0</code></pre></div></div><div><div><pre><code class="language-none">value(ex::NonlinearExpression, var_value::Function)</code></pre><p>Evaluate <code>ex</code> using <code>var_value(v)</code> as the value for each variable <code>v</code>.</p></div></div><div><div><pre><code class="language-none">value(ex::NonlinearExpression)</code></pre><p>Evaluate <code>ex</code> using <code>JuMP.value</code> as the value for each variable <code>v</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.dual_status" href="#JuMP.dual_status"><code>JuMP.dual_status</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dual_status(model::Model)</code></pre><p>Return the status of the most recent dual solution of the solver (i.e., the MathOptInterface model attribute <code>DualStatus</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.has_duals" href="#JuMP.has_duals"><code>JuMP.has_duals</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_duals(model::Model)</code></pre><p>Return true if the solver has a dual solution available to query, otherwise return false.</p><p>See also <a href="#JuMP.dual"><code>dual</code></a> and <a href="../constraints/#JuMP.shadow_price"><code>shadow_price</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.dual" href="#JuMP.dual"><code>JuMP.dual</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dual(cr::ConstraintRef)</code></pre><p>Get the dual value of this constraint in the result returned by a solver. Use <code>has_dual</code> to check if a result exists before asking for values. See also <a href="../constraints/#JuMP.shadow_price"><code>shadow_price</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.optimize!" href="#MathOptInterface.optimize!"><code>MathOptInterface.optimize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">optimize!(optimizer::AbstractOptimizer)</code></pre><p>Start the solution procedure.</p></div></div></section><footer><hr/><a class="previous" href="../solvers/"><span class="direction">Previous</span><span class="title">Solvers</span></a><a class="next" href="../nlp/"><span class="direction">Next</span><span class="title">Nonlinear Modeling</span></a></footer></article></body></html>
